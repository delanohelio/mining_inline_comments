{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2MDExMjMy", "number": 1458, "title": "feat(extensions): ot-tracer propagator", "bodyText": "supports propagation headers used by lightstep tracers, copied from the lightstep tracer and the b3 opentelemetry propagator (in this package).\nI couldn't find the issue again, but I remember reading that these were welcome in the extensions module. If someone remembers which issue the ot-tracer headers were mentioned feel free to tag it here.", "createdAt": "2020-07-24T00:05:21Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458", "merged": true, "mergeCommit": {"oid": "96e8523544f04c305da5382854eee06218599075"}, "closed": true, "closedAt": "2020-07-27T21:53:27Z", "author": {"login": "FrankSpitulski"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc34pVegBqjM1ODIxNDg5Njc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5Iqx8ABqjM1OTE3MTAwMDk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0cfae7e5c0fef4e46d1be99cc70312d31985c8c6", "author": {"user": {"login": "FrankSpitulski", "name": "Frank Spitulski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0cfae7e5c0fef4e46d1be99cc70312d31985c8c6", "committedDate": "2020-07-24T00:10:31Z", "message": "fix googleJavaFormat"}, "afterCommit": {"oid": "65ef9a2314f83e30a676970022600df3a651efea", "author": {"user": {"login": "FrankSpitulski", "name": "Frank Spitulski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/65ef9a2314f83e30a676970022600df3a651efea", "committedDate": "2020-07-24T00:11:36Z", "message": "fix googleJavaFormat"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjUzNzAy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#pullrequestreview-454653702", "createdAt": "2020-07-24T06:15:14Z", "commit": {"oid": "c3fefefcd0fa1a1de0f3abc68b54b06d7f338526"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjoxNToxNFrOG2kNXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjoxNToxNFrOG2kNXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTUzMw==", "bodyText": "I think generally we shouldn't reference implementation of other propagators here. Should we promote to a top-level class, maybe HexIdUtils?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r459869533", "createdAt": "2020-07-24T06:15:14Z", "author": {"login": "anuraaga"}, "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.extensions.trace.propagation.B3PropagatorExtractor.Util;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3fefefcd0fa1a1de0f3abc68b54b06d7f338526"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjIwMzg2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#pullrequestreview-454620386", "createdAt": "2020-07-24T03:45:18Z", "commit": {"oid": "c3fefefcd0fa1a1de0f3abc68b54b06d7f338526"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMzo0NToxOVrOG2iVyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMzo0NToxOVrOG2iVyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzODkyMA==", "bodyText": "Please write a javadoc for the class", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r459838920", "createdAt": "2020-07-24T03:45:19Z", "author": {"login": "iNikem"}, "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.extensions.trace.propagation.B3PropagatorExtractor.Util;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+@Immutable\n+public class OtTracerPropagator implements HttpTextFormat {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3fefefcd0fa1a1de0f3abc68b54b06d7f338526"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MjUxNDYy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#pullrequestreview-455251462", "createdAt": "2020-07-25T01:50:09Z", "commit": {"oid": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMTo1MDoxMFrOG3Bg0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMTo1NDowN1rOG3BiKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTY1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class PropagatorUtils {\n          \n          \n            \n            final class PropagatorUtils {", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349651", "createdAt": "2020-07-25T01:50:10Z", "author": {"login": "anuraaga"}, "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/PropagatorUtils.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+@Immutable\n+public class PropagatorUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTcxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(carrier).hasSize(0);\n          \n          \n            \n                assertThat(carrier).isEmpty();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349715", "createdAt": "2020-07-25T01:50:45Z", "author": {"login": "anuraaga"}, "path": "extensions/trace_propagators/src/test/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagatorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class OtTracerPropagatorTest {\n+\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+  private static final String TRACE_ID_BASE16 = \"ff000000000000000000000000000041\";\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String SHORT_TRACE_ID_BASE16 = \"ff00000000000000\";\n+  private static final TraceId SHORT_TRACE_ID =\n+      TraceId.fromLowerBase16(StringUtils.padLeft(SHORT_TRACE_ID_BASE16, 32), 0);\n+  private static final String SPAN_ID_BASE16 = \"ff00000000000041\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final byte SAMPLED_TRACE_OPTIONS_BYTES = 1;\n+  private static final TraceFlags SAMPLED_TRACE_OPTIONS =\n+      TraceFlags.fromByte(SAMPLED_TRACE_OPTIONS_BYTES);\n+  private static final Setter<Map<String, String>> setter = Map::put;\n+  private static final Getter<Map<String, String>> getter =\n+      new Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final OtTracerPropagator propagator = OtTracerPropagator.getInstance();\n+\n+  @Rule public ExpectedException thrown = ExpectedException.none();\n+\n+  private static SpanContext getSpanContext(Context context) {\n+    return TracingContextUtils.getSpan(context).getContext();\n+  }\n+\n+  private static Context withSpanContext(SpanContext spanContext, Context context) {\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @Test\n+  public void inject_invalidContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    propagator.inject(\n+        withSpanContext(\n+            SpanContext.create(\n+                TraceId.getInvalid(),\n+                SpanId.getInvalid(),\n+                SAMPLED_TRACE_OPTIONS,\n+                TraceState.builder().set(\"foo\", \"bar\").build()),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier).hasSize(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTgyNw==", "bodyText": "I would just inline for better readability, this separation doesn't really improve maintenance", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349827", "createdAt": "2020-07-25T01:52:03Z", "author": {"login": "anuraaga"}, "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Lightstep propagation protocol. See <a\n+ * href=https://github.com/lightstep/lightstep-tracer-java-common/blob/master/common/src/main/java/com/lightstep/tracer/shared/TextMapPropagator.java>Lightstep\n+ * TextMapPropagator</a>.\n+ */\n+@Immutable\n+public class OtTracerPropagator implements HttpTextFormat {\n+\n+  private static final String OT_TRACER = \"ot-tracer-\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTg0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static final String TRACE_ID_HEADER = OT_TRACER + \"traceid\";\n          \n          \n            \n              static final String TRACE_ID_HEADER = \"ot-tracer-traceid\";", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349844", "createdAt": "2020-07-25T01:52:14Z", "author": {"login": "anuraaga"}, "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Lightstep propagation protocol. See <a\n+ * href=https://github.com/lightstep/lightstep-tracer-java-common/blob/master/common/src/main/java/com/lightstep/tracer/shared/TextMapPropagator.java>Lightstep\n+ * TextMapPropagator</a>.\n+ */\n+@Immutable\n+public class OtTracerPropagator implements HttpTextFormat {\n+\n+  private static final String OT_TRACER = \"ot-tracer-\";\n+  static final String TRACE_ID_HEADER = OT_TRACER + \"traceid\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTg3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static final String SPAN_ID_HEADER = OT_TRACER + \"spanid\";\n          \n          \n            \n              static final String SPAN_ID_HEADER = \"ot-tracer-spanid\";", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349875", "createdAt": "2020-07-25T01:52:32Z", "author": {"login": "anuraaga"}, "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Lightstep propagation protocol. See <a\n+ * href=https://github.com/lightstep/lightstep-tracer-java-common/blob/master/common/src/main/java/com/lightstep/tracer/shared/TextMapPropagator.java>Lightstep\n+ * TextMapPropagator</a>.\n+ */\n+@Immutable\n+public class OtTracerPropagator implements HttpTextFormat {\n+\n+  private static final String OT_TRACER = \"ot-tracer-\";\n+  static final String TRACE_ID_HEADER = OT_TRACER + \"traceid\";\n+  static final String SPAN_ID_HEADER = OT_TRACER + \"spanid\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTg5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static final String SAMPLED_HEADER = OT_TRACER + \"sampled\";\n          \n          \n            \n              static final String SAMPLED_HEADER = \"ot-tracer-sampled\";", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349895", "createdAt": "2020-07-25T01:52:43Z", "author": {"login": "anuraaga"}, "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Lightstep propagation protocol. See <a\n+ * href=https://github.com/lightstep/lightstep-tracer-java-common/blob/master/common/src/main/java/com/lightstep/tracer/shared/TextMapPropagator.java>Lightstep\n+ * TextMapPropagator</a>.\n+ */\n+@Immutable\n+public class OtTracerPropagator implements HttpTextFormat {\n+\n+  private static final String OT_TRACER = \"ot-tracer-\";\n+  static final String TRACE_ID_HEADER = OT_TRACER + \"traceid\";\n+  static final String SPAN_ID_HEADER = OT_TRACER + \"spanid\";\n+  static final String SAMPLED_HEADER = OT_TRACER + \"sampled\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTk1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Test\n          \n          \n            \n              public void fieldsList() {\n          \n          \n            \n                assertThat(propagator.fields())\n          \n          \n            \n                    .containsExactly(\n          \n          \n            \n                        OtTracerPropagator.TRACE_ID_HEADER,\n          \n          \n            \n                        OtTracerPropagator.SPAN_ID_HEADER,\n          \n          \n            \n                        OtTracerPropagator.SAMPLED_HEADER);\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              @Test\n          \n          \n            \n              public void headerNames() {\n          \n          \n            \n                assertThat(OtTracerPropagator.TRACE_ID_HEADER).isEqualTo(\"ot-tracer-traceid\");\n          \n          \n            \n                assertThat(OtTracerPropagator.SPAN_ID_HEADER).isEqualTo(\"ot-tracer-spanid\");\n          \n          \n            \n                assertThat(OtTracerPropagator.SAMPLED_HEADER).isEqualTo(\"ot-tracer-sampled\");\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nThese tests are basically equivalent to the code, just checking constants, don't think they provide value.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349954", "createdAt": "2020-07-25T01:53:27Z", "author": {"login": "anuraaga"}, "path": "extensions/trace_propagators/src/test/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagatorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class OtTracerPropagatorTest {\n+\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+  private static final String TRACE_ID_BASE16 = \"ff000000000000000000000000000041\";\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String SHORT_TRACE_ID_BASE16 = \"ff00000000000000\";\n+  private static final TraceId SHORT_TRACE_ID =\n+      TraceId.fromLowerBase16(StringUtils.padLeft(SHORT_TRACE_ID_BASE16, 32), 0);\n+  private static final String SPAN_ID_BASE16 = \"ff00000000000041\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final byte SAMPLED_TRACE_OPTIONS_BYTES = 1;\n+  private static final TraceFlags SAMPLED_TRACE_OPTIONS =\n+      TraceFlags.fromByte(SAMPLED_TRACE_OPTIONS_BYTES);\n+  private static final Setter<Map<String, String>> setter = Map::put;\n+  private static final Getter<Map<String, String>> getter =\n+      new Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final OtTracerPropagator propagator = OtTracerPropagator.getInstance();\n+\n+  @Rule public ExpectedException thrown = ExpectedException.none();\n+\n+  private static SpanContext getSpanContext(Context context) {\n+    return TracingContextUtils.getSpan(context).getContext();\n+  }\n+\n+  private static Context withSpanContext(SpanContext spanContext, Context context) {\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @Test\n+  public void inject_invalidContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    propagator.inject(\n+        withSpanContext(\n+            SpanContext.create(\n+                TraceId.getInvalid(),\n+                SpanId.getInvalid(),\n+                SAMPLED_TRACE_OPTIONS,\n+                TraceState.builder().set(\"foo\", \"bar\").build()),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier).hasSize(0);\n+  }\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    propagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SAMPLED_HEADER, \"true\");\n+  }\n+\n+  @Test\n+  public void inject_SampledContext_nullCarrierUsage() {\n+    final Map<String, String> carrier = new LinkedHashMap<>();\n+    propagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        null,\n+        (Setter<Map<String, String>>) (ignored, key, value) -> carrier.put(key, value));\n+    assertThat(carrier).containsEntry(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SAMPLED_HEADER, \"true\");\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    propagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    assertThat(carrier).containsEntry(OtTracerPropagator.SAMPLED_HEADER, \"false\");\n+  }\n+\n+  @Test\n+  public void extract_Nothing() {\n+    // Context remains untouched.\n+    assertThat(\n+            propagator.extract(Context.current(), Collections.<String, String>emptyMap(), Map::get))\n+        .isSameInstanceAs(Context.current());\n+  }\n+\n+  @Test\n+  public void extract_SampledContext_Int() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_SampledContext_Bool() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, \"true\");\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.FALSE_INT);\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_SampledContext_Int_Short_TraceId() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, SHORT_TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                SHORT_TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_SampledContext_Bool_Short_TraceId() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, SHORT_TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, \"true\");\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                SHORT_TRACE_ID, SPAN_ID, SAMPLED_TRACE_OPTIONS, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_NotSampledContext_Short_TraceId() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(OtTracerPropagator.TRACE_ID_HEADER, SHORT_TRACE_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    carrier.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.FALSE_INT);\n+\n+    assertThat(getSpanContext(propagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                SHORT_TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(OtTracerPropagator.TRACE_ID_HEADER, \"abcdefghijklmnopabcdefghijklmnop\");\n+    invalidHeaders.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    invalidHeaders.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+    assertThat(getSpanContext(propagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16 + \"00\");\n+    invalidHeaders.put(OtTracerPropagator.SPAN_ID_HEADER, SPAN_ID_BASE16);\n+    invalidHeaders.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+    assertThat(getSpanContext(propagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    invalidHeaders.put(OtTracerPropagator.SPAN_ID_HEADER, \"abcdefghijklmnop\");\n+    invalidHeaders.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+    assertThat(getSpanContext(propagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(OtTracerPropagator.TRACE_ID_HEADER, TRACE_ID_BASE16);\n+    invalidHeaders.put(OtTracerPropagator.SPAN_ID_HEADER, \"abcdefghijklmnop\" + \"00\");\n+    invalidHeaders.put(OtTracerPropagator.SAMPLED_HEADER, PropagatorUtils.TRUE_INT);\n+    assertThat(getSpanContext(propagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void fieldsList() {\n+    assertThat(propagator.fields())\n+        .containsExactly(\n+            OtTracerPropagator.TRACE_ID_HEADER,\n+            OtTracerPropagator.SPAN_ID_HEADER,\n+            OtTracerPropagator.SAMPLED_HEADER);\n+  }\n+\n+  @Test\n+  public void headerNames() {\n+    assertThat(OtTracerPropagator.TRACE_ID_HEADER).isEqualTo(\"ot-tracer-traceid\");\n+    assertThat(OtTracerPropagator.SPAN_ID_HEADER).isEqualTo(\"ot-tracer-spanid\");\n+    assertThat(OtTracerPropagator.SAMPLED_HEADER).isEqualTo(\"ot-tracer-sampled\");\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM0OTk5Mg==", "bodyText": "Does Map::get not work?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460349992", "createdAt": "2020-07-25T01:54:07Z", "author": {"login": "anuraaga"}, "path": "extensions/trace_propagators/src/test/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagatorTest.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class OtTracerPropagatorTest {\n+\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+  private static final String TRACE_ID_BASE16 = \"ff000000000000000000000000000041\";\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String SHORT_TRACE_ID_BASE16 = \"ff00000000000000\";\n+  private static final TraceId SHORT_TRACE_ID =\n+      TraceId.fromLowerBase16(StringUtils.padLeft(SHORT_TRACE_ID_BASE16, 32), 0);\n+  private static final String SPAN_ID_BASE16 = \"ff00000000000041\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final byte SAMPLED_TRACE_OPTIONS_BYTES = 1;\n+  private static final TraceFlags SAMPLED_TRACE_OPTIONS =\n+      TraceFlags.fromByte(SAMPLED_TRACE_OPTIONS_BYTES);\n+  private static final Setter<Map<String, String>> setter = Map::put;\n+  private static final Getter<Map<String, String>> getter =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0f3342a793f7943afd6c0b44d0e97e83e03d8b3"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MjU2OTUx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#pullrequestreview-455256951", "createdAt": "2020-07-25T03:21:12Z", "commit": {"oid": "0291997ccf21f6f7a7917a0cef1cf8a1de6c65cb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1Mzg0OTIw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#pullrequestreview-455384920", "createdAt": "2020-07-26T18:17:02Z", "commit": {"oid": "0291997ccf21f6f7a7917a0cef1cf8a1de6c65cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxODoxNzowMlrOG3OMww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxODoxNzowMlrOG3OMww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1NzUwNw==", "bodyText": "I'd rename this to PropagatorsCommon or even Common,  as it has utility methods but it also has actual fields used by the implementations.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#discussion_r460557507", "createdAt": "2020-07-26T18:17:02Z", "author": {"login": "carlosalberto"}, "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/PropagatorUtils.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.extensions.trace.propagation;\n+\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+@Immutable\n+final class PropagatorUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0291997ccf21f6f7a7917a0cef1cf8a1de6c65cb"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MDYxODU2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1458#pullrequestreview-456061856", "createdAt": "2020-07-27T19:13:24Z", "commit": {"oid": "0930424a63a51fcd240c0837824ab1e92994398c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4e84699deb822ba9929913ced199fb1216a3c40", "author": {"user": {"login": "FrankSpitulski", "name": "Frank Spitulski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f4e84699deb822ba9929913ced199fb1216a3c40", "committedDate": "2020-07-27T21:23:26Z", "message": "feat(extensions): ot-tracer propagator\n\nsupports propagation headers used by lightstep tracers"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0930424a63a51fcd240c0837824ab1e92994398c", "author": {"user": {"login": "FrankSpitulski", "name": "Frank Spitulski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0930424a63a51fcd240c0837824ab1e92994398c", "committedDate": "2020-07-27T18:57:23Z", "message": "incorporate suggestions"}, "afterCommit": {"oid": "f4e84699deb822ba9929913ced199fb1216a3c40", "author": {"user": {"login": "FrankSpitulski", "name": "Frank Spitulski"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f4e84699deb822ba9929913ced199fb1216a3c40", "committedDate": "2020-07-27T21:23:26Z", "message": "feat(extensions): ot-tracer propagator\n\nsupports propagation headers used by lightstep tracers"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2631, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}