{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5MTYzNDIx", "number": 1875, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNzo1NTowMVrOExexdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0NDowNlrOEy2NWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzE5ODYzOnYy", "diffSide": "RIGHT", "path": "exporters/jaeger_thrift/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNzo1NTowMVrOHnpXqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNzo1NTowMVrOHnpXqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNDMxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            An example of simple Jaeger gRPC exporter initialization. In this case\n          \n          \n            \n            spans will be sent to a Jaeger gRPC endpoint running on `localhost`:\n          \n          \n            \n            An example of simple Jaeger Thrift exporter initialization. In this case\n          \n          \n            \n            spans will be sent to a Jaeger Thrift endpoint running on `localhost`:", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511334313", "createdAt": "2020-10-24T07:55:01Z", "author": {"login": "anuraaga"}, "path": "exporters/jaeger_thrift/README.md", "diffHunk": "@@ -0,0 +1,49 @@\n+# OpenTelemetry - Jaeger Exporter - Thrift\n+\n+[![Javadocs][javadoc-image]][javadoc-url]\n+\n+This is the OpenTelemetry exporter, sending span data to Jaeger via Thrift over HTTP. \n+\n+## Configuration\n+\n+The Jaeger Thrift span exporter can be configured programmatically.\n+\n+An example of simple Jaeger gRPC exporter initialization. In this case\n+spans will be sent to a Jaeger gRPC endpoint running on `localhost`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzE5ODkzOnYy", "diffSide": "RIGHT", "path": "exporters/jaeger_thrift/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNzo1NToxM1rOHnpXxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNzo1NToxM1rOHnpXxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNDM0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Jaeger gRPC span exporter will look for the following environment variables / system properties:\n          \n          \n            \n            The Jaeger Thrift span exporter will look for the following environment variables / system properties:", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511334343", "createdAt": "2020-10-24T07:55:13Z", "author": {"login": "anuraaga"}, "path": "exporters/jaeger_thrift/README.md", "diffHunk": "@@ -0,0 +1,49 @@\n+# OpenTelemetry - Jaeger Exporter - Thrift\n+\n+[![Javadocs][javadoc-image]][javadoc-url]\n+\n+This is the OpenTelemetry exporter, sending span data to Jaeger via Thrift over HTTP. \n+\n+## Configuration\n+\n+The Jaeger Thrift span exporter can be configured programmatically.\n+\n+An example of simple Jaeger gRPC exporter initialization. In this case\n+spans will be sent to a Jaeger gRPC endpoint running on `localhost`:\n+\n+```java\n+JaegerThriftSpanExporter exporter =\n+        JaegerThriftSpanExporter.builder()\n+            .setEndpoint(\"localhost:14250\")\n+            .setServiceName(\"my-service\")\n+            .build();\n+```\n+\n+Service name and Endpoint can be also configured via environment variables or system properties.\n+\n+```java\n+// Using environment variables\n+JaegerThriftSpanExporter exporter = \n+        JaegerThriftSpanExporter.builder()\n+            .readEnvironmentVariables()\n+            .build()\n+```\n+\n+```java\n+// Using system properties\n+JaegerThriftSpanExporter exporter = \n+        JaegerThriftSpanExporter.builder()\n+            .readSystemProperties()\n+            .build()\n+```\n+\n+The Jaeger gRPC span exporter will look for the following environment variables / system properties:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzIwMzgxOnYy", "diffSide": "RIGHT", "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwODowMjo0M1rOHnpaGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTowMzoxMVrOHoT3IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNDkzOA==", "bodyText": "Can kind be null?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511334938", "createdAt": "2020-10-24T08:02:43Z", "author": {"login": "anuraaga"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import static io.opentelemetry.common.AttributeKey.booleanKey;\n+\n+import com.google.gson.Gson;\n+import io.jaegertracing.thriftjava.Log;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.SpanRef;\n+import io.jaegertracing.thriftjava.SpanRefType;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.common.AttributeConsumer;\n+import io.opentelemetry.common.AttributeKey;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Adapts OpenTelemetry objects to Jaeger objects. */\n+@ThreadSafe\n+final class Adapter {\n+\n+  static final AttributeKey<Boolean> KEY_ERROR = booleanKey(\"error\");\n+  static final String KEY_LOG_EVENT = \"event\";\n+  static final String KEY_EVENT_DROPPED_ATTRIBUTES_COUNT = \"otel.event.dropped_attributes_count\";\n+  static final String KEY_SPAN_KIND = \"span.kind\";\n+  static final String KEY_SPAN_STATUS_MESSAGE = \"span.status.message\";\n+  static final String KEY_SPAN_STATUS_CODE = \"span.status.code\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_NAME = \"otel.library.name\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_VERSION = \"otel.library.version\";\n+  public static final Gson GSON = new Gson();\n+\n+  private Adapter() {}\n+\n+  /**\n+   * Converts a list of {@link SpanData} into a collection of Jaeger's {@link Span}.\n+   *\n+   * @param spans the list of spans to be converted\n+   * @return the collection of Jaeger spans\n+   * @see #toJaeger(SpanData)\n+   */\n+  static List<Span> toJaeger(Collection<SpanData> spans) {\n+    return spans.stream().map(Adapter::toJaeger).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Converts a single {@link SpanData} into a Jaeger's {@link Span}.\n+   *\n+   * @param span the span to be converted\n+   * @return the Jaeger span\n+   */\n+  static Span toJaeger(SpanData span) {\n+    Span target = new Span();\n+\n+    long traceIdHigh = TraceId.traceIdHighBytesAsLong(span.getTraceId());\n+    long traceIdLow = TraceId.traceIdLowBytesAsLong(span.getTraceId());\n+    long spanIdAsLong = SpanId.asLong(span.getSpanId());\n+\n+    target.setTraceIdHigh(traceIdHigh);\n+    target.setTraceIdLow(traceIdLow);\n+    target.setSpanId(spanIdAsLong);\n+    target.setOperationName(span.getName());\n+    target.setStartTime(TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos()));\n+    target.setDuration(\n+        TimeUnit.NANOSECONDS.toMicros(span.getEndEpochNanos() - span.getStartEpochNanos()));\n+\n+    List<Tag> tags = toTags(span.getAttributes());\n+\n+    target.setLogs(toJaegerLogs(span.getEvents()));\n+    List<SpanRef> references = toSpanRefs(span.getLinks());\n+\n+    // add the parent span\n+    if (SpanId.isValid(span.getParentSpanId())) {\n+      references.add(\n+          new SpanRef(\n+              SpanRefType.CHILD_OF,\n+              traceIdLow,\n+              traceIdHigh,\n+              SpanId.asLong(span.getParentSpanId())));\n+    }\n+    target.setReferences(references);\n+\n+    if (span.getKind() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5NTU2Mg==", "bodyText": "hmm. as you probably have guessed at this point, this was cribbed from the GRPC exporter. probably not. I'll fix it up.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511495562", "createdAt": "2020-10-24T17:36:00Z", "author": {"login": "jkwatson"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import static io.opentelemetry.common.AttributeKey.booleanKey;\n+\n+import com.google.gson.Gson;\n+import io.jaegertracing.thriftjava.Log;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.SpanRef;\n+import io.jaegertracing.thriftjava.SpanRefType;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.common.AttributeConsumer;\n+import io.opentelemetry.common.AttributeKey;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Adapts OpenTelemetry objects to Jaeger objects. */\n+@ThreadSafe\n+final class Adapter {\n+\n+  static final AttributeKey<Boolean> KEY_ERROR = booleanKey(\"error\");\n+  static final String KEY_LOG_EVENT = \"event\";\n+  static final String KEY_EVENT_DROPPED_ATTRIBUTES_COUNT = \"otel.event.dropped_attributes_count\";\n+  static final String KEY_SPAN_KIND = \"span.kind\";\n+  static final String KEY_SPAN_STATUS_MESSAGE = \"span.status.message\";\n+  static final String KEY_SPAN_STATUS_CODE = \"span.status.code\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_NAME = \"otel.library.name\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_VERSION = \"otel.library.version\";\n+  public static final Gson GSON = new Gson();\n+\n+  private Adapter() {}\n+\n+  /**\n+   * Converts a list of {@link SpanData} into a collection of Jaeger's {@link Span}.\n+   *\n+   * @param spans the list of spans to be converted\n+   * @return the collection of Jaeger spans\n+   * @see #toJaeger(SpanData)\n+   */\n+  static List<Span> toJaeger(Collection<SpanData> spans) {\n+    return spans.stream().map(Adapter::toJaeger).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Converts a single {@link SpanData} into a Jaeger's {@link Span}.\n+   *\n+   * @param span the span to be converted\n+   * @return the Jaeger span\n+   */\n+  static Span toJaeger(SpanData span) {\n+    Span target = new Span();\n+\n+    long traceIdHigh = TraceId.traceIdHighBytesAsLong(span.getTraceId());\n+    long traceIdLow = TraceId.traceIdLowBytesAsLong(span.getTraceId());\n+    long spanIdAsLong = SpanId.asLong(span.getSpanId());\n+\n+    target.setTraceIdHigh(traceIdHigh);\n+    target.setTraceIdLow(traceIdLow);\n+    target.setSpanId(spanIdAsLong);\n+    target.setOperationName(span.getName());\n+    target.setStartTime(TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos()));\n+    target.setDuration(\n+        TimeUnit.NANOSECONDS.toMicros(span.getEndEpochNanos() - span.getStartEpochNanos()));\n+\n+    List<Tag> tags = toTags(span.getAttributes());\n+\n+    target.setLogs(toJaegerLogs(span.getEvents()));\n+    List<SpanRef> references = toSpanRefs(span.getLinks());\n+\n+    // add the parent span\n+    if (SpanId.isValid(span.getParentSpanId())) {\n+      references.add(\n+          new SpanRef(\n+              SpanRefType.CHILD_OF,\n+              traceIdLow,\n+              traceIdHigh,\n+              SpanId.asLong(span.getParentSpanId())));\n+    }\n+    target.setReferences(references);\n+\n+    if (span.getKind() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNDkzOA=="}, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzMDQ5Nw==", "bodyText": "fixed.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r512030497", "createdAt": "2020-10-26T15:03:11Z", "author": {"login": "jkwatson"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import static io.opentelemetry.common.AttributeKey.booleanKey;\n+\n+import com.google.gson.Gson;\n+import io.jaegertracing.thriftjava.Log;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.SpanRef;\n+import io.jaegertracing.thriftjava.SpanRefType;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.common.AttributeConsumer;\n+import io.opentelemetry.common.AttributeKey;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Adapts OpenTelemetry objects to Jaeger objects. */\n+@ThreadSafe\n+final class Adapter {\n+\n+  static final AttributeKey<Boolean> KEY_ERROR = booleanKey(\"error\");\n+  static final String KEY_LOG_EVENT = \"event\";\n+  static final String KEY_EVENT_DROPPED_ATTRIBUTES_COUNT = \"otel.event.dropped_attributes_count\";\n+  static final String KEY_SPAN_KIND = \"span.kind\";\n+  static final String KEY_SPAN_STATUS_MESSAGE = \"span.status.message\";\n+  static final String KEY_SPAN_STATUS_CODE = \"span.status.code\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_NAME = \"otel.library.name\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_VERSION = \"otel.library.version\";\n+  public static final Gson GSON = new Gson();\n+\n+  private Adapter() {}\n+\n+  /**\n+   * Converts a list of {@link SpanData} into a collection of Jaeger's {@link Span}.\n+   *\n+   * @param spans the list of spans to be converted\n+   * @return the collection of Jaeger spans\n+   * @see #toJaeger(SpanData)\n+   */\n+  static List<Span> toJaeger(Collection<SpanData> spans) {\n+    return spans.stream().map(Adapter::toJaeger).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Converts a single {@link SpanData} into a Jaeger's {@link Span}.\n+   *\n+   * @param span the span to be converted\n+   * @return the Jaeger span\n+   */\n+  static Span toJaeger(SpanData span) {\n+    Span target = new Span();\n+\n+    long traceIdHigh = TraceId.traceIdHighBytesAsLong(span.getTraceId());\n+    long traceIdLow = TraceId.traceIdLowBytesAsLong(span.getTraceId());\n+    long spanIdAsLong = SpanId.asLong(span.getSpanId());\n+\n+    target.setTraceIdHigh(traceIdHigh);\n+    target.setTraceIdLow(traceIdLow);\n+    target.setSpanId(spanIdAsLong);\n+    target.setOperationName(span.getName());\n+    target.setStartTime(TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos()));\n+    target.setDuration(\n+        TimeUnit.NANOSECONDS.toMicros(span.getEndEpochNanos() - span.getStartEpochNanos()));\n+\n+    List<Tag> tags = toTags(span.getAttributes());\n+\n+    target.setLogs(toJaegerLogs(span.getEvents()));\n+    List<SpanRef> references = toSpanRefs(span.getLinks());\n+\n+    // add the parent span\n+    if (SpanId.isValid(span.getParentSpanId())) {\n+      references.add(\n+          new SpanRef(\n+              SpanRefType.CHILD_OF,\n+              traceIdLow,\n+              traceIdHigh,\n+              SpanId.asLong(span.getParentSpanId())));\n+    }\n+    target.setReferences(references);\n+\n+    if (span.getKind() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNDkzOA=="}, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzIwNDE0OnYy", "diffSide": "RIGHT", "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwODowMzoxN1rOHnpaQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTowMzo0N1rOHoT43Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNDk3OQ==", "bodyText": "Probably better to not set key instead of setting to empty string.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511334979", "createdAt": "2020-10-24T08:03:17Z", "author": {"login": "anuraaga"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import static io.opentelemetry.common.AttributeKey.booleanKey;\n+\n+import com.google.gson.Gson;\n+import io.jaegertracing.thriftjava.Log;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.SpanRef;\n+import io.jaegertracing.thriftjava.SpanRefType;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.common.AttributeConsumer;\n+import io.opentelemetry.common.AttributeKey;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Adapts OpenTelemetry objects to Jaeger objects. */\n+@ThreadSafe\n+final class Adapter {\n+\n+  static final AttributeKey<Boolean> KEY_ERROR = booleanKey(\"error\");\n+  static final String KEY_LOG_EVENT = \"event\";\n+  static final String KEY_EVENT_DROPPED_ATTRIBUTES_COUNT = \"otel.event.dropped_attributes_count\";\n+  static final String KEY_SPAN_KIND = \"span.kind\";\n+  static final String KEY_SPAN_STATUS_MESSAGE = \"span.status.message\";\n+  static final String KEY_SPAN_STATUS_CODE = \"span.status.code\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_NAME = \"otel.library.name\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_VERSION = \"otel.library.version\";\n+  public static final Gson GSON = new Gson();\n+\n+  private Adapter() {}\n+\n+  /**\n+   * Converts a list of {@link SpanData} into a collection of Jaeger's {@link Span}.\n+   *\n+   * @param spans the list of spans to be converted\n+   * @return the collection of Jaeger spans\n+   * @see #toJaeger(SpanData)\n+   */\n+  static List<Span> toJaeger(Collection<SpanData> spans) {\n+    return spans.stream().map(Adapter::toJaeger).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Converts a single {@link SpanData} into a Jaeger's {@link Span}.\n+   *\n+   * @param span the span to be converted\n+   * @return the Jaeger span\n+   */\n+  static Span toJaeger(SpanData span) {\n+    Span target = new Span();\n+\n+    long traceIdHigh = TraceId.traceIdHighBytesAsLong(span.getTraceId());\n+    long traceIdLow = TraceId.traceIdLowBytesAsLong(span.getTraceId());\n+    long spanIdAsLong = SpanId.asLong(span.getSpanId());\n+\n+    target.setTraceIdHigh(traceIdHigh);\n+    target.setTraceIdLow(traceIdLow);\n+    target.setSpanId(spanIdAsLong);\n+    target.setOperationName(span.getName());\n+    target.setStartTime(TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos()));\n+    target.setDuration(\n+        TimeUnit.NANOSECONDS.toMicros(span.getEndEpochNanos() - span.getStartEpochNanos()));\n+\n+    List<Tag> tags = toTags(span.getAttributes());\n+\n+    target.setLogs(toJaegerLogs(span.getEvents()));\n+    List<SpanRef> references = toSpanRefs(span.getLinks());\n+\n+    // add the parent span\n+    if (SpanId.isValid(span.getParentSpanId())) {\n+      references.add(\n+          new SpanRef(\n+              SpanRefType.CHILD_OF,\n+              traceIdLow,\n+              traceIdHigh,\n+              SpanId.asLong(span.getParentSpanId())));\n+    }\n+    target.setReferences(references);\n+\n+    if (span.getKind() != null) {\n+      tags.add(\n+          new Tag(KEY_SPAN_KIND, TagType.STRING)\n+              .setVStr(span.getKind().name().toLowerCase(Locale.ROOT)));\n+    }\n+\n+    tags.add(\n+        new Tag(KEY_SPAN_STATUS_MESSAGE, TagType.STRING)\n+            .setVStr(\n+                span.getStatus().getDescription() == null\n+                    ? \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5NTYyOA==", "bodyText": "not sure what Jaeger wants here. copied this from GRPC, assuming that was correct, but it might not be.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511495628", "createdAt": "2020-10-24T17:36:26Z", "author": {"login": "jkwatson"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import static io.opentelemetry.common.AttributeKey.booleanKey;\n+\n+import com.google.gson.Gson;\n+import io.jaegertracing.thriftjava.Log;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.SpanRef;\n+import io.jaegertracing.thriftjava.SpanRefType;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.common.AttributeConsumer;\n+import io.opentelemetry.common.AttributeKey;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Adapts OpenTelemetry objects to Jaeger objects. */\n+@ThreadSafe\n+final class Adapter {\n+\n+  static final AttributeKey<Boolean> KEY_ERROR = booleanKey(\"error\");\n+  static final String KEY_LOG_EVENT = \"event\";\n+  static final String KEY_EVENT_DROPPED_ATTRIBUTES_COUNT = \"otel.event.dropped_attributes_count\";\n+  static final String KEY_SPAN_KIND = \"span.kind\";\n+  static final String KEY_SPAN_STATUS_MESSAGE = \"span.status.message\";\n+  static final String KEY_SPAN_STATUS_CODE = \"span.status.code\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_NAME = \"otel.library.name\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_VERSION = \"otel.library.version\";\n+  public static final Gson GSON = new Gson();\n+\n+  private Adapter() {}\n+\n+  /**\n+   * Converts a list of {@link SpanData} into a collection of Jaeger's {@link Span}.\n+   *\n+   * @param spans the list of spans to be converted\n+   * @return the collection of Jaeger spans\n+   * @see #toJaeger(SpanData)\n+   */\n+  static List<Span> toJaeger(Collection<SpanData> spans) {\n+    return spans.stream().map(Adapter::toJaeger).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Converts a single {@link SpanData} into a Jaeger's {@link Span}.\n+   *\n+   * @param span the span to be converted\n+   * @return the Jaeger span\n+   */\n+  static Span toJaeger(SpanData span) {\n+    Span target = new Span();\n+\n+    long traceIdHigh = TraceId.traceIdHighBytesAsLong(span.getTraceId());\n+    long traceIdLow = TraceId.traceIdLowBytesAsLong(span.getTraceId());\n+    long spanIdAsLong = SpanId.asLong(span.getSpanId());\n+\n+    target.setTraceIdHigh(traceIdHigh);\n+    target.setTraceIdLow(traceIdLow);\n+    target.setSpanId(spanIdAsLong);\n+    target.setOperationName(span.getName());\n+    target.setStartTime(TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos()));\n+    target.setDuration(\n+        TimeUnit.NANOSECONDS.toMicros(span.getEndEpochNanos() - span.getStartEpochNanos()));\n+\n+    List<Tag> tags = toTags(span.getAttributes());\n+\n+    target.setLogs(toJaegerLogs(span.getEvents()));\n+    List<SpanRef> references = toSpanRefs(span.getLinks());\n+\n+    // add the parent span\n+    if (SpanId.isValid(span.getParentSpanId())) {\n+      references.add(\n+          new SpanRef(\n+              SpanRefType.CHILD_OF,\n+              traceIdLow,\n+              traceIdHigh,\n+              SpanId.asLong(span.getParentSpanId())));\n+    }\n+    target.setReferences(references);\n+\n+    if (span.getKind() != null) {\n+      tags.add(\n+          new Tag(KEY_SPAN_KIND, TagType.STRING)\n+              .setVStr(span.getKind().name().toLowerCase(Locale.ROOT)));\n+    }\n+\n+    tags.add(\n+        new Tag(KEY_SPAN_STATUS_MESSAGE, TagType.STRING)\n+            .setVStr(\n+                span.getStatus().getDescription() == null\n+                    ? \"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNDk3OQ=="}, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzMDk0MQ==", "bodyText": "made it not set a null/missing status description. seems like the right answer. we can change it back if there is a problem.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r512030941", "createdAt": "2020-10-26T15:03:47Z", "author": {"login": "jkwatson"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import static io.opentelemetry.common.AttributeKey.booleanKey;\n+\n+import com.google.gson.Gson;\n+import io.jaegertracing.thriftjava.Log;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.SpanRef;\n+import io.jaegertracing.thriftjava.SpanRefType;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.common.AttributeConsumer;\n+import io.opentelemetry.common.AttributeKey;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Adapts OpenTelemetry objects to Jaeger objects. */\n+@ThreadSafe\n+final class Adapter {\n+\n+  static final AttributeKey<Boolean> KEY_ERROR = booleanKey(\"error\");\n+  static final String KEY_LOG_EVENT = \"event\";\n+  static final String KEY_EVENT_DROPPED_ATTRIBUTES_COUNT = \"otel.event.dropped_attributes_count\";\n+  static final String KEY_SPAN_KIND = \"span.kind\";\n+  static final String KEY_SPAN_STATUS_MESSAGE = \"span.status.message\";\n+  static final String KEY_SPAN_STATUS_CODE = \"span.status.code\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_NAME = \"otel.library.name\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_VERSION = \"otel.library.version\";\n+  public static final Gson GSON = new Gson();\n+\n+  private Adapter() {}\n+\n+  /**\n+   * Converts a list of {@link SpanData} into a collection of Jaeger's {@link Span}.\n+   *\n+   * @param spans the list of spans to be converted\n+   * @return the collection of Jaeger spans\n+   * @see #toJaeger(SpanData)\n+   */\n+  static List<Span> toJaeger(Collection<SpanData> spans) {\n+    return spans.stream().map(Adapter::toJaeger).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Converts a single {@link SpanData} into a Jaeger's {@link Span}.\n+   *\n+   * @param span the span to be converted\n+   * @return the Jaeger span\n+   */\n+  static Span toJaeger(SpanData span) {\n+    Span target = new Span();\n+\n+    long traceIdHigh = TraceId.traceIdHighBytesAsLong(span.getTraceId());\n+    long traceIdLow = TraceId.traceIdLowBytesAsLong(span.getTraceId());\n+    long spanIdAsLong = SpanId.asLong(span.getSpanId());\n+\n+    target.setTraceIdHigh(traceIdHigh);\n+    target.setTraceIdLow(traceIdLow);\n+    target.setSpanId(spanIdAsLong);\n+    target.setOperationName(span.getName());\n+    target.setStartTime(TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos()));\n+    target.setDuration(\n+        TimeUnit.NANOSECONDS.toMicros(span.getEndEpochNanos() - span.getStartEpochNanos()));\n+\n+    List<Tag> tags = toTags(span.getAttributes());\n+\n+    target.setLogs(toJaegerLogs(span.getEvents()));\n+    List<SpanRef> references = toSpanRefs(span.getLinks());\n+\n+    // add the parent span\n+    if (SpanId.isValid(span.getParentSpanId())) {\n+      references.add(\n+          new SpanRef(\n+              SpanRefType.CHILD_OF,\n+              traceIdLow,\n+              traceIdHigh,\n+              SpanId.asLong(span.getParentSpanId())));\n+    }\n+    target.setReferences(references);\n+\n+    if (span.getKind() != null) {\n+      tags.add(\n+          new Tag(KEY_SPAN_KIND, TagType.STRING)\n+              .setVStr(span.getKind().name().toLowerCase(Locale.ROOT)));\n+    }\n+\n+    tags.add(\n+        new Tag(KEY_SPAN_STATUS_MESSAGE, TagType.STRING)\n+            .setVStr(\n+                span.getStatus().getDescription() == null\n+                    ? \"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNDk3OQ=="}, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzIwNjYwOnYy", "diffSide": "RIGHT", "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwODowNjozMVrOHnpbbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNzozNjo0OVrOHnzN-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNTI3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // millis? nanos?\n          \n      \n    \n    \n  \n\nmicros seems right", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511335276", "createdAt": "2020-10-24T08:06:31Z", "author": {"login": "anuraaga"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import static io.opentelemetry.common.AttributeKey.booleanKey;\n+\n+import com.google.gson.Gson;\n+import io.jaegertracing.thriftjava.Log;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.SpanRef;\n+import io.jaegertracing.thriftjava.SpanRefType;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.common.AttributeConsumer;\n+import io.opentelemetry.common.AttributeKey;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Adapts OpenTelemetry objects to Jaeger objects. */\n+@ThreadSafe\n+final class Adapter {\n+\n+  static final AttributeKey<Boolean> KEY_ERROR = booleanKey(\"error\");\n+  static final String KEY_LOG_EVENT = \"event\";\n+  static final String KEY_EVENT_DROPPED_ATTRIBUTES_COUNT = \"otel.event.dropped_attributes_count\";\n+  static final String KEY_SPAN_KIND = \"span.kind\";\n+  static final String KEY_SPAN_STATUS_MESSAGE = \"span.status.message\";\n+  static final String KEY_SPAN_STATUS_CODE = \"span.status.code\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_NAME = \"otel.library.name\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_VERSION = \"otel.library.version\";\n+  public static final Gson GSON = new Gson();\n+\n+  private Adapter() {}\n+\n+  /**\n+   * Converts a list of {@link SpanData} into a collection of Jaeger's {@link Span}.\n+   *\n+   * @param spans the list of spans to be converted\n+   * @return the collection of Jaeger spans\n+   * @see #toJaeger(SpanData)\n+   */\n+  static List<Span> toJaeger(Collection<SpanData> spans) {\n+    return spans.stream().map(Adapter::toJaeger).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Converts a single {@link SpanData} into a Jaeger's {@link Span}.\n+   *\n+   * @param span the span to be converted\n+   * @return the Jaeger span\n+   */\n+  static Span toJaeger(SpanData span) {\n+    Span target = new Span();\n+\n+    long traceIdHigh = TraceId.traceIdHighBytesAsLong(span.getTraceId());\n+    long traceIdLow = TraceId.traceIdLowBytesAsLong(span.getTraceId());\n+    long spanIdAsLong = SpanId.asLong(span.getSpanId());\n+\n+    target.setTraceIdHigh(traceIdHigh);\n+    target.setTraceIdLow(traceIdLow);\n+    target.setSpanId(spanIdAsLong);\n+    target.setOperationName(span.getName());\n+    target.setStartTime(TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos()));\n+    target.setDuration(\n+        TimeUnit.NANOSECONDS.toMicros(span.getEndEpochNanos() - span.getStartEpochNanos()));\n+\n+    List<Tag> tags = toTags(span.getAttributes());\n+\n+    target.setLogs(toJaegerLogs(span.getEvents()));\n+    List<SpanRef> references = toSpanRefs(span.getLinks());\n+\n+    // add the parent span\n+    if (SpanId.isValid(span.getParentSpanId())) {\n+      references.add(\n+          new SpanRef(\n+              SpanRefType.CHILD_OF,\n+              traceIdLow,\n+              traceIdHigh,\n+              SpanId.asLong(span.getParentSpanId())));\n+    }\n+    target.setReferences(references);\n+\n+    if (span.getKind() != null) {\n+      tags.add(\n+          new Tag(KEY_SPAN_KIND, TagType.STRING)\n+              .setVStr(span.getKind().name().toLowerCase(Locale.ROOT)));\n+    }\n+\n+    tags.add(\n+        new Tag(KEY_SPAN_STATUS_MESSAGE, TagType.STRING)\n+            .setVStr(\n+                span.getStatus().getDescription() == null\n+                    ? \"\"\n+                    : span.getStatus().getDescription()));\n+\n+    tags.add(\n+        new Tag(KEY_SPAN_STATUS_CODE, TagType.LONG)\n+            .setVLong(span.getStatus().getCanonicalCode().value()));\n+\n+    tags.add(\n+        new Tag(KEY_INSTRUMENTATION_LIBRARY_NAME, TagType.STRING)\n+            .setVStr(span.getInstrumentationLibraryInfo().getName()));\n+\n+    if (span.getInstrumentationLibraryInfo().getVersion() != null) {\n+      tags.add(\n+          new Tag(KEY_INSTRUMENTATION_LIBRARY_VERSION, TagType.STRING)\n+              .setVStr(span.getInstrumentationLibraryInfo().getVersion()));\n+    }\n+\n+    if (!span.getStatus().isOk()) {\n+      tags.add(toTag(KEY_ERROR, true));\n+    }\n+    target.setTags(tags);\n+\n+    return target;\n+  }\n+\n+  /**\n+   * Converts {@link Event}s into a collection of Jaeger's {@link Log}.\n+   *\n+   * @param timedEvents the timed events to be converted\n+   * @return a collection of Jaeger logs\n+   * @see #toJaegerLog(Event)\n+   */\n+  // VisibleForTesting\n+  static List<Log> toJaegerLogs(List<Event> timedEvents) {\n+    return timedEvents.stream().map(Adapter::toJaegerLog).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Converts a {@link Event} into Jaeger's {@link Log}.\n+   *\n+   * @param event the timed event to be converted\n+   * @return a Jaeger log\n+   */\n+  // VisibleForTesting\n+  static Log toJaegerLog(Event event) {\n+    Log result = new Log();\n+    // millis? nanos?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5NTY3NA==", "bodyText": "yeah, I micros works correctly, even though I can't find any documentation about it. :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511495674", "createdAt": "2020-10-24T17:36:49Z", "author": {"login": "jkwatson"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/Adapter.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import static io.opentelemetry.common.AttributeKey.booleanKey;\n+\n+import com.google.gson.Gson;\n+import io.jaegertracing.thriftjava.Log;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.SpanRef;\n+import io.jaegertracing.thriftjava.SpanRefType;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.common.AttributeConsumer;\n+import io.opentelemetry.common.AttributeKey;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Adapts OpenTelemetry objects to Jaeger objects. */\n+@ThreadSafe\n+final class Adapter {\n+\n+  static final AttributeKey<Boolean> KEY_ERROR = booleanKey(\"error\");\n+  static final String KEY_LOG_EVENT = \"event\";\n+  static final String KEY_EVENT_DROPPED_ATTRIBUTES_COUNT = \"otel.event.dropped_attributes_count\";\n+  static final String KEY_SPAN_KIND = \"span.kind\";\n+  static final String KEY_SPAN_STATUS_MESSAGE = \"span.status.message\";\n+  static final String KEY_SPAN_STATUS_CODE = \"span.status.code\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_NAME = \"otel.library.name\";\n+  static final String KEY_INSTRUMENTATION_LIBRARY_VERSION = \"otel.library.version\";\n+  public static final Gson GSON = new Gson();\n+\n+  private Adapter() {}\n+\n+  /**\n+   * Converts a list of {@link SpanData} into a collection of Jaeger's {@link Span}.\n+   *\n+   * @param spans the list of spans to be converted\n+   * @return the collection of Jaeger spans\n+   * @see #toJaeger(SpanData)\n+   */\n+  static List<Span> toJaeger(Collection<SpanData> spans) {\n+    return spans.stream().map(Adapter::toJaeger).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Converts a single {@link SpanData} into a Jaeger's {@link Span}.\n+   *\n+   * @param span the span to be converted\n+   * @return the Jaeger span\n+   */\n+  static Span toJaeger(SpanData span) {\n+    Span target = new Span();\n+\n+    long traceIdHigh = TraceId.traceIdHighBytesAsLong(span.getTraceId());\n+    long traceIdLow = TraceId.traceIdLowBytesAsLong(span.getTraceId());\n+    long spanIdAsLong = SpanId.asLong(span.getSpanId());\n+\n+    target.setTraceIdHigh(traceIdHigh);\n+    target.setTraceIdLow(traceIdLow);\n+    target.setSpanId(spanIdAsLong);\n+    target.setOperationName(span.getName());\n+    target.setStartTime(TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos()));\n+    target.setDuration(\n+        TimeUnit.NANOSECONDS.toMicros(span.getEndEpochNanos() - span.getStartEpochNanos()));\n+\n+    List<Tag> tags = toTags(span.getAttributes());\n+\n+    target.setLogs(toJaegerLogs(span.getEvents()));\n+    List<SpanRef> references = toSpanRefs(span.getLinks());\n+\n+    // add the parent span\n+    if (SpanId.isValid(span.getParentSpanId())) {\n+      references.add(\n+          new SpanRef(\n+              SpanRefType.CHILD_OF,\n+              traceIdLow,\n+              traceIdHigh,\n+              SpanId.asLong(span.getParentSpanId())));\n+    }\n+    target.setReferences(references);\n+\n+    if (span.getKind() != null) {\n+      tags.add(\n+          new Tag(KEY_SPAN_KIND, TagType.STRING)\n+              .setVStr(span.getKind().name().toLowerCase(Locale.ROOT)));\n+    }\n+\n+    tags.add(\n+        new Tag(KEY_SPAN_STATUS_MESSAGE, TagType.STRING)\n+            .setVStr(\n+                span.getStatus().getDescription() == null\n+                    ? \"\"\n+                    : span.getStatus().getDescription()));\n+\n+    tags.add(\n+        new Tag(KEY_SPAN_STATUS_CODE, TagType.LONG)\n+            .setVLong(span.getStatus().getCanonicalCode().value()));\n+\n+    tags.add(\n+        new Tag(KEY_INSTRUMENTATION_LIBRARY_NAME, TagType.STRING)\n+            .setVStr(span.getInstrumentationLibraryInfo().getName()));\n+\n+    if (span.getInstrumentationLibraryInfo().getVersion() != null) {\n+      tags.add(\n+          new Tag(KEY_INSTRUMENTATION_LIBRARY_VERSION, TagType.STRING)\n+              .setVStr(span.getInstrumentationLibraryInfo().getVersion()));\n+    }\n+\n+    if (!span.getStatus().isOk()) {\n+      tags.add(toTag(KEY_ERROR, true));\n+    }\n+    target.setTags(tags);\n+\n+    return target;\n+  }\n+\n+  /**\n+   * Converts {@link Event}s into a collection of Jaeger's {@link Log}.\n+   *\n+   * @param timedEvents the timed events to be converted\n+   * @return a collection of Jaeger logs\n+   * @see #toJaegerLog(Event)\n+   */\n+  // VisibleForTesting\n+  static List<Log> toJaegerLogs(List<Event> timedEvents) {\n+    return timedEvents.stream().map(Adapter::toJaegerLog).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Converts a {@link Event} into Jaeger's {@link Log}.\n+   *\n+   * @param event the timed event to be converted\n+   * @return a Jaeger log\n+   */\n+  // VisibleForTesting\n+  static Log toJaegerLog(Event event) {\n+    Log result = new Log();\n+    // millis? nanos?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNTI3Ng=="}, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMzIwOTUwOnYy", "diffSide": "RIGHT", "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwODoxMDoyNVrOHnpcuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwODoxMDoyNVrOHnpcuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNTYxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        e.printStackTrace();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511335611", "createdAt": "2020-10-24T08:10:25Z", "author": {"login": "anuraaga"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import io.jaegertracing.internal.exceptions.SenderException;\n+import io.jaegertracing.thrift.internal.senders.HttpSender;\n+import io.jaegertracing.thrift.internal.senders.ThriftSender;\n+import io.jaegertracing.thriftjava.Process;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans to Jaeger via Thrift, using Jaeger's thrift model. */\n+@ThreadSafe\n+public final class JaegerThriftSpanExporter implements SpanExporter {\n+\n+  public static final String DEFAULT_HOST_NAME = \"unknown\";\n+  public static final String DEFAULT_ENDPOINT = \"http://localhost:14268/api/traces\";\n+  public static final String DEFAULT_SERVICE_NAME = DEFAULT_HOST_NAME;\n+\n+  private static final Logger logger = Logger.getLogger(JaegerThriftSpanExporter.class.getName());\n+  private static final String CLIENT_VERSION_KEY = \"jaeger.version\";\n+  private static final String CLIENT_VERSION_VALUE = \"opentelemetry-java\";\n+  private static final String HOSTNAME_KEY = \"hostname\";\n+  private static final String IP_KEY = \"ip\";\n+  private static final String IP_DEFAULT = \"0.0.0.0\";\n+  private final ThriftSender thriftSender;\n+  private final Process process;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param thriftSender The sender used for sending the data.\n+   * @param serviceName this service's name.\n+   */\n+  private JaegerThriftSpanExporter(ThriftSender thriftSender, String serviceName) {\n+    this.thriftSender = thriftSender;\n+    String hostname;\n+    String ipv4;\n+\n+    if (serviceName == null || serviceName.trim().length() == 0) {\n+      throw new IllegalArgumentException(\"Service name must not be null or empty\");\n+    }\n+\n+    try {\n+      hostname = InetAddress.getLocalHost().getHostName();\n+      ipv4 = InetAddress.getLocalHost().getHostAddress();\n+    } catch (UnknownHostException e) {\n+      hostname = DEFAULT_HOST_NAME;\n+      ipv4 = IP_DEFAULT;\n+    }\n+\n+    Tag clientTag = new Tag(CLIENT_VERSION_KEY, TagType.STRING).setVStr(CLIENT_VERSION_VALUE);\n+    Tag ipv4Tag = new Tag(IP_KEY, TagType.STRING).setVStr(ipv4);\n+    Tag hostnameTag = new Tag(HOSTNAME_KEY, TagType.STRING).setVStr(hostname);\n+\n+    this.process = new Process().setServiceName(serviceName);\n+    this.process.addToTags(clientTag);\n+    this.process.addToTags(ipv4Tag);\n+    this.process.addToTags(hostnameTag);\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public CompletableResultCode export(Collection<SpanData> spans) {\n+    Map<Process, List<Span>> batches =\n+        spans.stream().collect(Collectors.groupingBy(SpanData::getResource)).entrySet().stream()\n+            .collect(\n+                Collectors.toMap(\n+                    entry -> createProcess(entry.getKey()),\n+                    entry -> Adapter.toJaeger(entry.getValue())));\n+\n+    List<CompletableResultCode> batchResults = new ArrayList<>(batches.size());\n+    batches.forEach(\n+        (process, jaegerSpans) -> {\n+          CompletableResultCode batchResult = new CompletableResultCode();\n+          try {\n+            // todo: consider making truly async\n+            thriftSender.send(process, jaegerSpans);\n+            batchResult.succeed();\n+          } catch (SenderException e) {\n+            logger.log(Level.WARNING, \"Failed to export spans\", e);\n+            batchResult.fail();\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDA3NTgwOnYy", "diffSide": "RIGHT", "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNDo0NjozMVrOHnx_2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNzozNTowNlrOHnzNMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3NTY3Mw==", "bodyText": "Should we remove e.printStackTrace();?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511475673", "createdAt": "2020-10-24T14:46:31Z", "author": {"login": "dengliming"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import io.jaegertracing.internal.exceptions.SenderException;\n+import io.jaegertracing.thrift.internal.senders.HttpSender;\n+import io.jaegertracing.thrift.internal.senders.ThriftSender;\n+import io.jaegertracing.thriftjava.Process;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans to Jaeger via Thrift, using Jaeger's thrift model. */\n+@ThreadSafe\n+public final class JaegerThriftSpanExporter implements SpanExporter {\n+\n+  public static final String DEFAULT_HOST_NAME = \"unknown\";\n+  public static final String DEFAULT_ENDPOINT = \"http://localhost:14268/api/traces\";\n+  public static final String DEFAULT_SERVICE_NAME = DEFAULT_HOST_NAME;\n+\n+  private static final Logger logger = Logger.getLogger(JaegerThriftSpanExporter.class.getName());\n+  private static final String CLIENT_VERSION_KEY = \"jaeger.version\";\n+  private static final String CLIENT_VERSION_VALUE = \"opentelemetry-java\";\n+  private static final String HOSTNAME_KEY = \"hostname\";\n+  private static final String IP_KEY = \"ip\";\n+  private static final String IP_DEFAULT = \"0.0.0.0\";\n+  private final ThriftSender thriftSender;\n+  private final Process process;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param thriftSender The sender used for sending the data.\n+   * @param serviceName this service's name.\n+   */\n+  private JaegerThriftSpanExporter(ThriftSender thriftSender, String serviceName) {\n+    this.thriftSender = thriftSender;\n+    String hostname;\n+    String ipv4;\n+\n+    if (serviceName == null || serviceName.trim().length() == 0) {\n+      throw new IllegalArgumentException(\"Service name must not be null or empty\");\n+    }\n+\n+    try {\n+      hostname = InetAddress.getLocalHost().getHostName();\n+      ipv4 = InetAddress.getLocalHost().getHostAddress();\n+    } catch (UnknownHostException e) {\n+      hostname = DEFAULT_HOST_NAME;\n+      ipv4 = IP_DEFAULT;\n+    }\n+\n+    Tag clientTag = new Tag(CLIENT_VERSION_KEY, TagType.STRING).setVStr(CLIENT_VERSION_VALUE);\n+    Tag ipv4Tag = new Tag(IP_KEY, TagType.STRING).setVStr(ipv4);\n+    Tag hostnameTag = new Tag(HOSTNAME_KEY, TagType.STRING).setVStr(hostname);\n+\n+    this.process = new Process().setServiceName(serviceName);\n+    this.process.addToTags(clientTag);\n+    this.process.addToTags(ipv4Tag);\n+    this.process.addToTags(hostnameTag);\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public CompletableResultCode export(Collection<SpanData> spans) {\n+    Map<Process, List<Span>> batches =\n+        spans.stream().collect(Collectors.groupingBy(SpanData::getResource)).entrySet().stream()\n+            .collect(\n+                Collectors.toMap(\n+                    entry -> createProcess(entry.getKey()),\n+                    entry -> Adapter.toJaeger(entry.getValue())));\n+\n+    List<CompletableResultCode> batchResults = new ArrayList<>(batches.size());\n+    batches.forEach(\n+        (process, jaegerSpans) -> {\n+          CompletableResultCode batchResult = new CompletableResultCode();\n+          try {\n+            // todo: consider making truly async\n+            thriftSender.send(process, jaegerSpans);\n+            batchResult.succeed();\n+          } catch (SenderException e) {\n+            logger.log(Level.WARNING, \"Failed to export spans\", e);\n+            batchResult.fail();\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5NTQ3Mw==", "bodyText": "oh crud. yes. good catch. :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r511495473", "createdAt": "2020-10-24T17:35:06Z", "author": {"login": "jkwatson"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import io.jaegertracing.internal.exceptions.SenderException;\n+import io.jaegertracing.thrift.internal.senders.HttpSender;\n+import io.jaegertracing.thrift.internal.senders.ThriftSender;\n+import io.jaegertracing.thriftjava.Process;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans to Jaeger via Thrift, using Jaeger's thrift model. */\n+@ThreadSafe\n+public final class JaegerThriftSpanExporter implements SpanExporter {\n+\n+  public static final String DEFAULT_HOST_NAME = \"unknown\";\n+  public static final String DEFAULT_ENDPOINT = \"http://localhost:14268/api/traces\";\n+  public static final String DEFAULT_SERVICE_NAME = DEFAULT_HOST_NAME;\n+\n+  private static final Logger logger = Logger.getLogger(JaegerThriftSpanExporter.class.getName());\n+  private static final String CLIENT_VERSION_KEY = \"jaeger.version\";\n+  private static final String CLIENT_VERSION_VALUE = \"opentelemetry-java\";\n+  private static final String HOSTNAME_KEY = \"hostname\";\n+  private static final String IP_KEY = \"ip\";\n+  private static final String IP_DEFAULT = \"0.0.0.0\";\n+  private final ThriftSender thriftSender;\n+  private final Process process;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param thriftSender The sender used for sending the data.\n+   * @param serviceName this service's name.\n+   */\n+  private JaegerThriftSpanExporter(ThriftSender thriftSender, String serviceName) {\n+    this.thriftSender = thriftSender;\n+    String hostname;\n+    String ipv4;\n+\n+    if (serviceName == null || serviceName.trim().length() == 0) {\n+      throw new IllegalArgumentException(\"Service name must not be null or empty\");\n+    }\n+\n+    try {\n+      hostname = InetAddress.getLocalHost().getHostName();\n+      ipv4 = InetAddress.getLocalHost().getHostAddress();\n+    } catch (UnknownHostException e) {\n+      hostname = DEFAULT_HOST_NAME;\n+      ipv4 = IP_DEFAULT;\n+    }\n+\n+    Tag clientTag = new Tag(CLIENT_VERSION_KEY, TagType.STRING).setVStr(CLIENT_VERSION_VALUE);\n+    Tag ipv4Tag = new Tag(IP_KEY, TagType.STRING).setVStr(ipv4);\n+    Tag hostnameTag = new Tag(HOSTNAME_KEY, TagType.STRING).setVStr(hostname);\n+\n+    this.process = new Process().setServiceName(serviceName);\n+    this.process.addToTags(clientTag);\n+    this.process.addToTags(ipv4Tag);\n+    this.process.addToTags(hostnameTag);\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public CompletableResultCode export(Collection<SpanData> spans) {\n+    Map<Process, List<Span>> batches =\n+        spans.stream().collect(Collectors.groupingBy(SpanData::getResource)).entrySet().stream()\n+            .collect(\n+                Collectors.toMap(\n+                    entry -> createProcess(entry.getKey()),\n+                    entry -> Adapter.toJaeger(entry.getValue())));\n+\n+    List<CompletableResultCode> batchResults = new ArrayList<>(batches.size());\n+    batches.forEach(\n+        (process, jaegerSpans) -> {\n+          CompletableResultCode batchResult = new CompletableResultCode();\n+          try {\n+            // todo: consider making truly async\n+            thriftSender.send(process, jaegerSpans);\n+            batchResult.succeed();\n+          } catch (SenderException e) {\n+            logger.log(Level.WARNING, \"Failed to export spans\", e);\n+            batchResult.fail();\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3NTY3Mw=="}, "originalCommit": {"oid": "f0d41ebcc62bd7f24792adbca3699cacd37099d8"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTE1Mjk4OnYy", "diffSide": "RIGHT", "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMjowNjo0M1rOHpXXOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMjozNToyOFrOHpX1Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNjQ0Mg==", "bodyText": "Can't see where to add the send result to batchResults. lost batchResults.add(batchResult); ?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513136442", "createdAt": "2020-10-28T02:06:43Z", "author": {"login": "dengliming"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import io.jaegertracing.internal.exceptions.SenderException;\n+import io.jaegertracing.thrift.internal.senders.HttpSender;\n+import io.jaegertracing.thrift.internal.senders.ThriftSender;\n+import io.jaegertracing.thriftjava.Process;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans to Jaeger via Thrift, using Jaeger's thrift model. */\n+@ThreadSafe\n+public final class JaegerThriftSpanExporter implements SpanExporter {\n+\n+  public static final String DEFAULT_HOST_NAME = \"unknown\";\n+  public static final String DEFAULT_ENDPOINT = \"http://localhost:14268/api/traces\";\n+  public static final String DEFAULT_SERVICE_NAME = DEFAULT_HOST_NAME;\n+\n+  private static final Logger logger = Logger.getLogger(JaegerThriftSpanExporter.class.getName());\n+  private static final String CLIENT_VERSION_KEY = \"jaeger.version\";\n+  private static final String CLIENT_VERSION_VALUE = \"opentelemetry-java\";\n+  private static final String HOSTNAME_KEY = \"hostname\";\n+  private static final String IP_KEY = \"ip\";\n+  private static final String IP_DEFAULT = \"0.0.0.0\";\n+  private final ThriftSender thriftSender;\n+  private final Process process;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param thriftSender The sender used for sending the data.\n+   * @param serviceName this service's name.\n+   */\n+  private JaegerThriftSpanExporter(ThriftSender thriftSender, String serviceName) {\n+    this.thriftSender = thriftSender;\n+    String hostname;\n+    String ipv4;\n+\n+    if (serviceName == null || serviceName.trim().length() == 0) {\n+      throw new IllegalArgumentException(\"Service name must not be null or empty\");\n+    }\n+\n+    try {\n+      hostname = InetAddress.getLocalHost().getHostName();\n+      ipv4 = InetAddress.getLocalHost().getHostAddress();\n+    } catch (UnknownHostException e) {\n+      hostname = DEFAULT_HOST_NAME;\n+      ipv4 = IP_DEFAULT;\n+    }\n+\n+    Tag clientTag = new Tag(CLIENT_VERSION_KEY, TagType.STRING).setVStr(CLIENT_VERSION_VALUE);\n+    Tag ipv4Tag = new Tag(IP_KEY, TagType.STRING).setVStr(ipv4);\n+    Tag hostnameTag = new Tag(HOSTNAME_KEY, TagType.STRING).setVStr(hostname);\n+\n+    this.process = new Process().setServiceName(serviceName);\n+    this.process.addToTags(clientTag);\n+    this.process.addToTags(ipv4Tag);\n+    this.process.addToTags(hostnameTag);\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public CompletableResultCode export(Collection<SpanData> spans) {\n+    Map<Process, List<Span>> batches =\n+        spans.stream().collect(Collectors.groupingBy(SpanData::getResource)).entrySet().stream()\n+            .collect(\n+                Collectors.toMap(\n+                    entry -> createProcess(entry.getKey()),\n+                    entry -> Adapter.toJaeger(entry.getValue())));\n+\n+    List<CompletableResultCode> batchResults = new ArrayList<>(batches.size());\n+    batches.forEach(\n+        (process, jaegerSpans) -> {\n+          CompletableResultCode batchResult = new CompletableResultCode();\n+          try {\n+            // todo: consider making truly async\n+            thriftSender.send(process, jaegerSpans);\n+            batchResult.succeed();\n+          } catch (SenderException e) {\n+            logger.log(Level.WARNING, \"Failed to export spans\", e);\n+            batchResult.fail();\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d865d0f12ec0f17865d3be56f7cf60b7df8b967"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0MDAwMg==", "bodyText": "That seems right - I would expect basically all unit tests to fail if not adding to the batchResults. @jkwatson know what could be up?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513140002", "createdAt": "2020-10-28T02:20:17Z", "author": {"login": "anuraaga"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import io.jaegertracing.internal.exceptions.SenderException;\n+import io.jaegertracing.thrift.internal.senders.HttpSender;\n+import io.jaegertracing.thrift.internal.senders.ThriftSender;\n+import io.jaegertracing.thriftjava.Process;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans to Jaeger via Thrift, using Jaeger's thrift model. */\n+@ThreadSafe\n+public final class JaegerThriftSpanExporter implements SpanExporter {\n+\n+  public static final String DEFAULT_HOST_NAME = \"unknown\";\n+  public static final String DEFAULT_ENDPOINT = \"http://localhost:14268/api/traces\";\n+  public static final String DEFAULT_SERVICE_NAME = DEFAULT_HOST_NAME;\n+\n+  private static final Logger logger = Logger.getLogger(JaegerThriftSpanExporter.class.getName());\n+  private static final String CLIENT_VERSION_KEY = \"jaeger.version\";\n+  private static final String CLIENT_VERSION_VALUE = \"opentelemetry-java\";\n+  private static final String HOSTNAME_KEY = \"hostname\";\n+  private static final String IP_KEY = \"ip\";\n+  private static final String IP_DEFAULT = \"0.0.0.0\";\n+  private final ThriftSender thriftSender;\n+  private final Process process;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param thriftSender The sender used for sending the data.\n+   * @param serviceName this service's name.\n+   */\n+  private JaegerThriftSpanExporter(ThriftSender thriftSender, String serviceName) {\n+    this.thriftSender = thriftSender;\n+    String hostname;\n+    String ipv4;\n+\n+    if (serviceName == null || serviceName.trim().length() == 0) {\n+      throw new IllegalArgumentException(\"Service name must not be null or empty\");\n+    }\n+\n+    try {\n+      hostname = InetAddress.getLocalHost().getHostName();\n+      ipv4 = InetAddress.getLocalHost().getHostAddress();\n+    } catch (UnknownHostException e) {\n+      hostname = DEFAULT_HOST_NAME;\n+      ipv4 = IP_DEFAULT;\n+    }\n+\n+    Tag clientTag = new Tag(CLIENT_VERSION_KEY, TagType.STRING).setVStr(CLIENT_VERSION_VALUE);\n+    Tag ipv4Tag = new Tag(IP_KEY, TagType.STRING).setVStr(ipv4);\n+    Tag hostnameTag = new Tag(HOSTNAME_KEY, TagType.STRING).setVStr(hostname);\n+\n+    this.process = new Process().setServiceName(serviceName);\n+    this.process.addToTags(clientTag);\n+    this.process.addToTags(ipv4Tag);\n+    this.process.addToTags(hostnameTag);\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public CompletableResultCode export(Collection<SpanData> spans) {\n+    Map<Process, List<Span>> batches =\n+        spans.stream().collect(Collectors.groupingBy(SpanData::getResource)).entrySet().stream()\n+            .collect(\n+                Collectors.toMap(\n+                    entry -> createProcess(entry.getKey()),\n+                    entry -> Adapter.toJaeger(entry.getValue())));\n+\n+    List<CompletableResultCode> batchResults = new ArrayList<>(batches.size());\n+    batches.forEach(\n+        (process, jaegerSpans) -> {\n+          CompletableResultCode batchResult = new CompletableResultCode();\n+          try {\n+            // todo: consider making truly async\n+            thriftSender.send(process, jaegerSpans);\n+            batchResult.succeed();\n+          } catch (SenderException e) {\n+            logger.log(Level.WARNING, \"Failed to export spans\", e);\n+            batchResult.fail();\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNjQ0Mg=="}, "originalCommit": {"oid": "0d865d0f12ec0f17865d3be56f7cf60b7df8b967"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0MTk1Ng==", "bodyText": "it works because we never look at the result code in the tests! I'll fix it", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513141956", "createdAt": "2020-10-28T02:27:44Z", "author": {"login": "jkwatson"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import io.jaegertracing.internal.exceptions.SenderException;\n+import io.jaegertracing.thrift.internal.senders.HttpSender;\n+import io.jaegertracing.thrift.internal.senders.ThriftSender;\n+import io.jaegertracing.thriftjava.Process;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans to Jaeger via Thrift, using Jaeger's thrift model. */\n+@ThreadSafe\n+public final class JaegerThriftSpanExporter implements SpanExporter {\n+\n+  public static final String DEFAULT_HOST_NAME = \"unknown\";\n+  public static final String DEFAULT_ENDPOINT = \"http://localhost:14268/api/traces\";\n+  public static final String DEFAULT_SERVICE_NAME = DEFAULT_HOST_NAME;\n+\n+  private static final Logger logger = Logger.getLogger(JaegerThriftSpanExporter.class.getName());\n+  private static final String CLIENT_VERSION_KEY = \"jaeger.version\";\n+  private static final String CLIENT_VERSION_VALUE = \"opentelemetry-java\";\n+  private static final String HOSTNAME_KEY = \"hostname\";\n+  private static final String IP_KEY = \"ip\";\n+  private static final String IP_DEFAULT = \"0.0.0.0\";\n+  private final ThriftSender thriftSender;\n+  private final Process process;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param thriftSender The sender used for sending the data.\n+   * @param serviceName this service's name.\n+   */\n+  private JaegerThriftSpanExporter(ThriftSender thriftSender, String serviceName) {\n+    this.thriftSender = thriftSender;\n+    String hostname;\n+    String ipv4;\n+\n+    if (serviceName == null || serviceName.trim().length() == 0) {\n+      throw new IllegalArgumentException(\"Service name must not be null or empty\");\n+    }\n+\n+    try {\n+      hostname = InetAddress.getLocalHost().getHostName();\n+      ipv4 = InetAddress.getLocalHost().getHostAddress();\n+    } catch (UnknownHostException e) {\n+      hostname = DEFAULT_HOST_NAME;\n+      ipv4 = IP_DEFAULT;\n+    }\n+\n+    Tag clientTag = new Tag(CLIENT_VERSION_KEY, TagType.STRING).setVStr(CLIENT_VERSION_VALUE);\n+    Tag ipv4Tag = new Tag(IP_KEY, TagType.STRING).setVStr(ipv4);\n+    Tag hostnameTag = new Tag(HOSTNAME_KEY, TagType.STRING).setVStr(hostname);\n+\n+    this.process = new Process().setServiceName(serviceName);\n+    this.process.addToTags(clientTag);\n+    this.process.addToTags(ipv4Tag);\n+    this.process.addToTags(hostnameTag);\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public CompletableResultCode export(Collection<SpanData> spans) {\n+    Map<Process, List<Span>> batches =\n+        spans.stream().collect(Collectors.groupingBy(SpanData::getResource)).entrySet().stream()\n+            .collect(\n+                Collectors.toMap(\n+                    entry -> createProcess(entry.getKey()),\n+                    entry -> Adapter.toJaeger(entry.getValue())));\n+\n+    List<CompletableResultCode> batchResults = new ArrayList<>(batches.size());\n+    batches.forEach(\n+        (process, jaegerSpans) -> {\n+          CompletableResultCode batchResult = new CompletableResultCode();\n+          try {\n+            // todo: consider making truly async\n+            thriftSender.send(process, jaegerSpans);\n+            batchResult.succeed();\n+          } catch (SenderException e) {\n+            logger.log(Level.WARNING, \"Failed to export spans\", e);\n+            batchResult.fail();\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNjQ0Mg=="}, "originalCommit": {"oid": "0d865d0f12ec0f17865d3be56f7cf60b7df8b967"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0MzQ2MQ==", "bodyText": "also, great catch, @dengliming !", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513143461", "createdAt": "2020-10-28T02:33:15Z", "author": {"login": "jkwatson"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import io.jaegertracing.internal.exceptions.SenderException;\n+import io.jaegertracing.thrift.internal.senders.HttpSender;\n+import io.jaegertracing.thrift.internal.senders.ThriftSender;\n+import io.jaegertracing.thriftjava.Process;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans to Jaeger via Thrift, using Jaeger's thrift model. */\n+@ThreadSafe\n+public final class JaegerThriftSpanExporter implements SpanExporter {\n+\n+  public static final String DEFAULT_HOST_NAME = \"unknown\";\n+  public static final String DEFAULT_ENDPOINT = \"http://localhost:14268/api/traces\";\n+  public static final String DEFAULT_SERVICE_NAME = DEFAULT_HOST_NAME;\n+\n+  private static final Logger logger = Logger.getLogger(JaegerThriftSpanExporter.class.getName());\n+  private static final String CLIENT_VERSION_KEY = \"jaeger.version\";\n+  private static final String CLIENT_VERSION_VALUE = \"opentelemetry-java\";\n+  private static final String HOSTNAME_KEY = \"hostname\";\n+  private static final String IP_KEY = \"ip\";\n+  private static final String IP_DEFAULT = \"0.0.0.0\";\n+  private final ThriftSender thriftSender;\n+  private final Process process;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param thriftSender The sender used for sending the data.\n+   * @param serviceName this service's name.\n+   */\n+  private JaegerThriftSpanExporter(ThriftSender thriftSender, String serviceName) {\n+    this.thriftSender = thriftSender;\n+    String hostname;\n+    String ipv4;\n+\n+    if (serviceName == null || serviceName.trim().length() == 0) {\n+      throw new IllegalArgumentException(\"Service name must not be null or empty\");\n+    }\n+\n+    try {\n+      hostname = InetAddress.getLocalHost().getHostName();\n+      ipv4 = InetAddress.getLocalHost().getHostAddress();\n+    } catch (UnknownHostException e) {\n+      hostname = DEFAULT_HOST_NAME;\n+      ipv4 = IP_DEFAULT;\n+    }\n+\n+    Tag clientTag = new Tag(CLIENT_VERSION_KEY, TagType.STRING).setVStr(CLIENT_VERSION_VALUE);\n+    Tag ipv4Tag = new Tag(IP_KEY, TagType.STRING).setVStr(ipv4);\n+    Tag hostnameTag = new Tag(HOSTNAME_KEY, TagType.STRING).setVStr(hostname);\n+\n+    this.process = new Process().setServiceName(serviceName);\n+    this.process.addToTags(clientTag);\n+    this.process.addToTags(ipv4Tag);\n+    this.process.addToTags(hostnameTag);\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public CompletableResultCode export(Collection<SpanData> spans) {\n+    Map<Process, List<Span>> batches =\n+        spans.stream().collect(Collectors.groupingBy(SpanData::getResource)).entrySet().stream()\n+            .collect(\n+                Collectors.toMap(\n+                    entry -> createProcess(entry.getKey()),\n+                    entry -> Adapter.toJaeger(entry.getValue())));\n+\n+    List<CompletableResultCode> batchResults = new ArrayList<>(batches.size());\n+    batches.forEach(\n+        (process, jaegerSpans) -> {\n+          CompletableResultCode batchResult = new CompletableResultCode();\n+          try {\n+            // todo: consider making truly async\n+            thriftSender.send(process, jaegerSpans);\n+            batchResult.succeed();\n+          } catch (SenderException e) {\n+            logger.log(Level.WARNING, \"Failed to export spans\", e);\n+            batchResult.fail();\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNjQ0Mg=="}, "originalCommit": {"oid": "0d865d0f12ec0f17865d3be56f7cf60b7df8b967"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0NDEwNg==", "bodyText": "I'm also going to add this check to the other Jaeger exporter test. :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513144106", "createdAt": "2020-10-28T02:35:28Z", "author": {"login": "jkwatson"}, "path": "exporters/jaeger_thrift/src/main/java/io/opentelemetry/exporters/jaeger/JaegerThriftSpanExporter.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import io.jaegertracing.internal.exceptions.SenderException;\n+import io.jaegertracing.thrift.internal.senders.HttpSender;\n+import io.jaegertracing.thrift.internal.senders.ThriftSender;\n+import io.jaegertracing.thriftjava.Process;\n+import io.jaegertracing.thriftjava.Span;\n+import io.jaegertracing.thriftjava.Tag;\n+import io.jaegertracing.thriftjava.TagType;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans to Jaeger via Thrift, using Jaeger's thrift model. */\n+@ThreadSafe\n+public final class JaegerThriftSpanExporter implements SpanExporter {\n+\n+  public static final String DEFAULT_HOST_NAME = \"unknown\";\n+  public static final String DEFAULT_ENDPOINT = \"http://localhost:14268/api/traces\";\n+  public static final String DEFAULT_SERVICE_NAME = DEFAULT_HOST_NAME;\n+\n+  private static final Logger logger = Logger.getLogger(JaegerThriftSpanExporter.class.getName());\n+  private static final String CLIENT_VERSION_KEY = \"jaeger.version\";\n+  private static final String CLIENT_VERSION_VALUE = \"opentelemetry-java\";\n+  private static final String HOSTNAME_KEY = \"hostname\";\n+  private static final String IP_KEY = \"ip\";\n+  private static final String IP_DEFAULT = \"0.0.0.0\";\n+  private final ThriftSender thriftSender;\n+  private final Process process;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param thriftSender The sender used for sending the data.\n+   * @param serviceName this service's name.\n+   */\n+  private JaegerThriftSpanExporter(ThriftSender thriftSender, String serviceName) {\n+    this.thriftSender = thriftSender;\n+    String hostname;\n+    String ipv4;\n+\n+    if (serviceName == null || serviceName.trim().length() == 0) {\n+      throw new IllegalArgumentException(\"Service name must not be null or empty\");\n+    }\n+\n+    try {\n+      hostname = InetAddress.getLocalHost().getHostName();\n+      ipv4 = InetAddress.getLocalHost().getHostAddress();\n+    } catch (UnknownHostException e) {\n+      hostname = DEFAULT_HOST_NAME;\n+      ipv4 = IP_DEFAULT;\n+    }\n+\n+    Tag clientTag = new Tag(CLIENT_VERSION_KEY, TagType.STRING).setVStr(CLIENT_VERSION_VALUE);\n+    Tag ipv4Tag = new Tag(IP_KEY, TagType.STRING).setVStr(ipv4);\n+    Tag hostnameTag = new Tag(HOSTNAME_KEY, TagType.STRING).setVStr(hostname);\n+\n+    this.process = new Process().setServiceName(serviceName);\n+    this.process.addToTags(clientTag);\n+    this.process.addToTags(ipv4Tag);\n+    this.process.addToTags(hostnameTag);\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public CompletableResultCode export(Collection<SpanData> spans) {\n+    Map<Process, List<Span>> batches =\n+        spans.stream().collect(Collectors.groupingBy(SpanData::getResource)).entrySet().stream()\n+            .collect(\n+                Collectors.toMap(\n+                    entry -> createProcess(entry.getKey()),\n+                    entry -> Adapter.toJaeger(entry.getValue())));\n+\n+    List<CompletableResultCode> batchResults = new ArrayList<>(batches.size());\n+    batches.forEach(\n+        (process, jaegerSpans) -> {\n+          CompletableResultCode batchResult = new CompletableResultCode();\n+          try {\n+            // todo: consider making truly async\n+            thriftSender.send(process, jaegerSpans);\n+            batchResult.succeed();\n+          } catch (SenderException e) {\n+            logger.log(Level.WARNING, \"Failed to export spans\", e);\n+            batchResult.fail();\n+          }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNjQ0Mg=="}, "originalCommit": {"oid": "0d865d0f12ec0f17865d3be56f7cf60b7df8b967"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTM0MzM1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/api/trace/SpanId.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMzo1MDo0M1rOHpZD3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODoyNzowMlrOHrbYcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NDI1NQ==", "bodyText": "Can you add some small unit tests for these trace utility change?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513164255", "createdAt": "2020-10-28T03:50:43Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/api/trace/SpanId.java", "diffHunk": "@@ -93,4 +93,9 @@ public static boolean isValid(String spanId) {\n   public static String bytesToHex(byte[] spanId) {\n     return BigendianEncoding.toLowerBase16(spanId);\n   }\n+\n+  /** Convert the the given hex spanId into a long representation. */\n+  public static long asLong(String src) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c981f671b0f7453c67c04c71628a31b90b1df85d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3MzgxOQ==", "bodyText": "yes, good idea. I will do so.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513173819", "createdAt": "2020-10-28T04:29:38Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/api/trace/SpanId.java", "diffHunk": "@@ -93,4 +93,9 @@ public static boolean isValid(String spanId) {\n   public static String bytesToHex(byte[] spanId) {\n     return BigendianEncoding.toLowerBase16(spanId);\n   }\n+\n+  /** Convert the the given hex spanId into a long representation. */\n+  public static long asLong(String src) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NDI1NQ=="}, "originalCommit": {"oid": "c981f671b0f7453c67c04c71628a31b90b1df85d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE3ODIxNg==", "bodyText": "done", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513178216", "createdAt": "2020-10-28T04:46:54Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/api/trace/SpanId.java", "diffHunk": "@@ -93,4 +93,9 @@ public static boolean isValid(String spanId) {\n   public static String bytesToHex(byte[] spanId) {\n     return BigendianEncoding.toLowerBase16(spanId);\n   }\n+\n+  /** Convert the the given hex spanId into a long representation. */\n+  public static long asLong(String src) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NDI1NQ=="}, "originalCommit": {"oid": "c981f671b0f7453c67c04c71628a31b90b1df85d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwMDcwNA==", "bodyText": "We should consider to move this class in an api extension, I don't think it should be part of the public API .", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513500704", "createdAt": "2020-10-28T14:42:42Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/api/trace/SpanId.java", "diffHunk": "@@ -93,4 +93,9 @@ public static boolean isValid(String spanId) {\n   public static String bytesToHex(byte[] spanId) {\n     return BigendianEncoding.toLowerBase16(spanId);\n   }\n+\n+  /** Convert the the given hex spanId into a long representation. */\n+  public static long asLong(String src) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NDI1NQ=="}, "originalCommit": {"oid": "c981f671b0f7453c67c04c71628a31b90b1df85d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMjI0Nw==", "bodyText": "I would like to do that, but I'd rather not make a verbatim copy of the BigendianEncoding class, since there are a bunch of fiddly bits in there that it would be better not to have duplicates of. Any thoughts on that?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513522247", "createdAt": "2020-10-28T15:08:04Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/api/trace/SpanId.java", "diffHunk": "@@ -93,4 +93,9 @@ public static boolean isValid(String spanId) {\n   public static String bytesToHex(byte[] spanId) {\n     return BigendianEncoding.toLowerBase16(spanId);\n   }\n+\n+  /** Convert the the given hex spanId into a long representation. */\n+  public static long asLong(String src) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NDI1NQ=="}, "originalCommit": {"oid": "c981f671b0f7453c67c04c71628a31b90b1df85d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5OTQ0Mg==", "bodyText": "@bogdandrutu any ideas on how to tackle this? Should we follow-up with a separate issue/PR?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r515299442", "createdAt": "2020-10-30T18:27:02Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/api/trace/SpanId.java", "diffHunk": "@@ -93,4 +93,9 @@ public static boolean isValid(String spanId) {\n   public static String bytesToHex(byte[] spanId) {\n     return BigendianEncoding.toLowerBase16(spanId);\n   }\n+\n+  /** Convert the the given hex spanId into a long representation. */\n+  public static long asLong(String src) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NDI1NQ=="}, "originalCommit": {"oid": "c981f671b0f7453c67c04c71628a31b90b1df85d"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNTM0NjM4OnYy", "diffSide": "RIGHT", "path": "exporters/jaeger_thrift/src/test/java/io/opentelemetry/exporters/jaeger/JaegerThriftIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMzo1MjoxNFrOHpZFkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMzo1MjoxNFrOHpZFkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NDY5MQ==", "bodyText": "Another jaeger integration test \ud83d\ude2e  Scared of the container startup issues (not related to this PR, just noting)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513164691", "createdAt": "2020-10-28T03:52:14Z", "author": {"login": "anuraaga"}, "path": "exporters/jaeger_thrift/src/test/java/io/opentelemetry/exporters/jaeger/JaegerThriftIntegrationTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporters.jaeger;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.opentelemetry.api.OpenTelemetry;\n+import io.opentelemetry.api.trace.Span;\n+import io.opentelemetry.api.trace.Tracer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.concurrent.TimeUnit;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.awaitility.Awaitility;\n+import org.junit.jupiter.api.Test;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+import org.testcontainers.utility.DockerImageName;\n+\n+@Testcontainers(disabledWithoutDocker = true)\n+class JaegerThriftIntegrationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c981f671b0f7453c67c04c71628a31b90b1df85d"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzUyNDExOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/api/trace/TraceId.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0NDowNlrOHptqjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0NDowNlrOHptqjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwMTgzOA==", "bodyText": "Confused why use CharSequence here and String in the other place. We should be consistent.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1875#discussion_r513501838", "createdAt": "2020-10-28T14:44:06Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/api/trace/TraceId.java", "diffHunk": "@@ -140,6 +140,16 @@ public static String bytesToHex(byte[] traceId) {\n    * @return the rightmost 8 bytes of the trace-id as a long value.\n    */\n   public static long getTraceIdRandomPart(CharSequence traceId) {\n+    return traceIdLowBytesAsLong(traceId);\n+  }\n+\n+  /** Convert the \"high bytes\" of the given hex traceId into a long representation. */\n+  public static long traceIdHighBytesAsLong(CharSequence traceId) {\n+    return BigendianEncoding.longFromBase16String(traceId, 0);\n+  }\n+\n+  /** Convert the \"low bytes\" of the given hex traceId into a long representation. */\n+  public static long traceIdLowBytesAsLong(CharSequence traceId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9821ecd4a244825696e0597981b52fe753f54c21"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2011, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}