{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwNDA5MjEx", "number": 1424, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMDowNjoxMFrOEPSUkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMjo1NDozMVrOEPVVVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NDY0MjcyOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMDowNjoxMFrOGy638g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMjo1MTo1NlrOGy_dUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0NjU3OA==", "bodyText": "shouldn't we wait on the countDownLatch before starting the work? Right now, the latch isn't being used to ensure concurrency at all.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456046578", "createdAt": "2020-07-16T20:06:10Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    final int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch countDownLatch = new CountDownLatch(numberOfThreads);\n+    List<Thread> workers = new ArrayList<>();\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      workers.add(\n+          new Thread(\n+              () -> {\n+                for (int j = 0; j < numberOfSpans; j++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62f9dfbd11770b14ab425d2ca7baf0bd7efd0420"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMTY4Mw==", "bodyText": "Yeah, sorry about that! I was basing the implementation off another OTel class. I've updated the test to ensure checking for concurrency.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456121683", "createdAt": "2020-07-16T22:51:56Z", "author": {"login": "williamhu99"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    final int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch countDownLatch = new CountDownLatch(numberOfThreads);\n+    List<Thread> workers = new ArrayList<>();\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      workers.add(\n+          new Thread(\n+              () -> {\n+                for (int j = 0; j < numberOfSpans; j++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0NjU3OA=="}, "originalCommit": {"oid": "62f9dfbd11770b14ab425d2ca7baf0bd7efd0420"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTEzNDc0OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMjo1Mzo1N1rOGy_f-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMzozNjoxNFrOGzAVPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg==", "bodyText": "I don't know if this line would ever be visible inside a background thread.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456122362", "createdAt": "2020-07-16T22:53:57Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch startSignal = new CountDownLatch(1);\n+    final CountDownLatch endSignal = new CountDownLatch(numberOfThreads);\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      new Thread(\n+              () -> {\n+                try {\n+                  startSignal.await();\n+                  for (int j = 0; j < numberOfSpans; j++) {\n+                    Span span = tracer.spanBuilder(SPAN_NAME).startSpan();\n+                    spanBucket.add((ReadableSpan) span);\n+                    span.end();\n+                  }\n+                  endSignal.countDown();\n+                } catch (InterruptedException e) {\n+                  Assert.fail(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyNDE3MQ==", "bodyText": "Would logging the exception be better?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456124171", "createdAt": "2020-07-16T22:59:18Z", "author": {"login": "williamhu99"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch startSignal = new CountDownLatch(1);\n+    final CountDownLatch endSignal = new CountDownLatch(numberOfThreads);\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      new Thread(\n+              () -> {\n+                try {\n+                  startSignal.await();\n+                  for (int j = 0; j < numberOfSpans; j++) {\n+                    Span span = tracer.spanBuilder(SPAN_NAME).startSpan();\n+                    spanBucket.add((ReadableSpan) span);\n+                    span.end();\n+                  }\n+                  endSignal.countDown();\n+                } catch (InterruptedException e) {\n+                  Assert.fail(e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg=="}, "originalCommit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyNDYxMA==", "bodyText": "can you test out what happens if the exception gets thrown in the method? It might work the way you expect; I'm not sure how junit deals with this case.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456124610", "createdAt": "2020-07-16T23:00:32Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch startSignal = new CountDownLatch(1);\n+    final CountDownLatch endSignal = new CountDownLatch(numberOfThreads);\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      new Thread(\n+              () -> {\n+                try {\n+                  startSignal.await();\n+                  for (int j = 0; j < numberOfSpans; j++) {\n+                    Span span = tracer.spanBuilder(SPAN_NAME).startSpan();\n+                    spanBucket.add((ReadableSpan) span);\n+                    span.end();\n+                  }\n+                  endSignal.countDown();\n+                } catch (InterruptedException e) {\n+                  Assert.fail(e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg=="}, "originalCommit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyNjQwNw==", "bodyText": "The assertion doesn't seem to do anything. The test continues and eventually times out.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456126407", "createdAt": "2020-07-16T23:05:57Z", "author": {"login": "williamhu99"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch startSignal = new CountDownLatch(1);\n+    final CountDownLatch endSignal = new CountDownLatch(numberOfThreads);\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      new Thread(\n+              () -> {\n+                try {\n+                  startSignal.await();\n+                  for (int j = 0; j < numberOfSpans; j++) {\n+                    Span span = tracer.spanBuilder(SPAN_NAME).startSpan();\n+                    spanBucket.add((ReadableSpan) span);\n+                    span.end();\n+                  }\n+                  endSignal.countDown();\n+                } catch (InterruptedException e) {\n+                  Assert.fail(e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg=="}, "originalCommit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNTk5OA==", "bodyText": "I just replaced the assert with a return statement. The test should fail from time limit or a lack of enough spans if anything does go wrong.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456135998", "createdAt": "2020-07-16T23:36:14Z", "author": {"login": "williamhu99"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch startSignal = new CountDownLatch(1);\n+    final CountDownLatch endSignal = new CountDownLatch(numberOfThreads);\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      new Thread(\n+              () -> {\n+                try {\n+                  startSignal.await();\n+                  for (int j = 0; j < numberOfSpans; j++) {\n+                    Span span = tracer.spanBuilder(SPAN_NAME).startSpan();\n+                    spanBucket.add((ReadableSpan) span);\n+                    span.end();\n+                  }\n+                  endSignal.countDown();\n+                } catch (InterruptedException e) {\n+                  Assert.fail(e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg=="}, "originalCommit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTEzNjIyOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMjo1NDozMVrOGy_g1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMjo1NDozMVrOGy_g1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjU4Mg==", "bodyText": "because we're relying on this, we should put a timeout on the test annotation, just in case things go badly awry. That way, we won't hang indefinitely waiting for things to finish.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456122582", "createdAt": "2020-07-16T22:54:31Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch startSignal = new CountDownLatch(1);\n+    final CountDownLatch endSignal = new CountDownLatch(numberOfThreads);\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      new Thread(\n+              () -> {\n+                try {\n+                  startSignal.await();\n+                  for (int j = 0; j < numberOfSpans; j++) {\n+                    Span span = tracer.spanBuilder(SPAN_NAME).startSpan();\n+                    spanBucket.add((ReadableSpan) span);\n+                    span.end();\n+                  }\n+                  endSignal.countDown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e"}, "originalPosition": 99}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1487, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}