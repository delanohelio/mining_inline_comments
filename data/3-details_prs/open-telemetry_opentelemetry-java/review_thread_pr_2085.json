{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyMjk1MzIz", "number": 2085, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNjo1NzoyNVrOE65pEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToxMDowOFrOFA8FkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTk3MjY2OnYy", "diffSide": "RIGHT", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNjo1NzoyNVrOH2PGyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNjo1NzoyNVrOH2PGyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYzMjY0OQ==", "bodyText": "Prefer a normal for loop if just for a range of ints", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r526632649", "createdAt": "2020-11-19T06:57:25Z", "author": {"login": "anuraaga"}, "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+import java.util.stream.IntStream;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader = IntervalMetricReader.create(this, reader, options.build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    LOGGER.info(\"Exporting metrics\");\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        IntStream.range(0, metric.getMetricDescriptor().getLabelKeys().size())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7dc479fcd766512c56850dea41698c7968db319"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTk3NjA5OnYy", "diffSide": "RIGHT", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNjo1ODo0N1rOH2PI2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNjo1ODo0N1rOH2PI2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYzMzE3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      long epochNanos =\n          \n          \n            \n                      long timestampNanos =\n          \n      \n    \n    \n  \n\nThe epoch is a constant :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r526633179", "createdAt": "2020-11-19T06:58:47Z", "author": {"login": "anuraaga"}, "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+import java.util.stream.IntStream;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader = IntervalMetricReader.create(this, reader, options.build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    LOGGER.info(\"Exporting metrics\");\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        IntStream.range(0, metric.getMetricDescriptor().getLabelKeys().size())\n+            .forEach(\n+                i ->\n+                    labelsBuilder.put(\n+                        metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+                        Objects.requireNonNull(timeSeries.getLabelValues().get(i).getValue())));\n+        Labels labels = labelsBuilder.build();\n+        ArrayList<MetricData.Point> points = new ArrayList<>();\n+        MetricDescriptor.Type type = null;\n+        for (Point point : timeSeries.getPoints()) {\n+          long epochNanos =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7dc479fcd766512c56850dea41698c7968db319"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTk4MDcyOnYy", "diffSide": "RIGHT", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNzowMDoxN1rOH2PLPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNzowMDoxN1rOH2PLPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYzMzc4OA==", "bodyText": "Maybe can use io.opentelemetry.opencensusshim as name at least for now. Let's go ahead and extract a constant for the InstrumentationLibraryInfo too", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r526633788", "createdAt": "2020-11-19T07:00:17Z", "author": {"login": "anuraaga"}, "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+import java.util.stream.IntStream;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader = IntervalMetricReader.create(this, reader, options.build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    LOGGER.info(\"Exporting metrics\");\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        IntStream.range(0, metric.getMetricDescriptor().getLabelKeys().size())\n+            .forEach(\n+                i ->\n+                    labelsBuilder.put(\n+                        metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+                        Objects.requireNonNull(timeSeries.getLabelValues().get(i).getValue())));\n+        Labels labels = labelsBuilder.build();\n+        ArrayList<MetricData.Point> points = new ArrayList<>();\n+        MetricDescriptor.Type type = null;\n+        for (Point point : timeSeries.getPoints()) {\n+          long epochNanos =\n+              TimeUnit.SECONDS.toNanos(point.getTimestamp().getSeconds())\n+                  + point.getTimestamp().getNanos();\n+          type = metric.getMetricDescriptor().getType();\n+          switch (type) {\n+            case GAUGE_INT64:\n+            case CUMULATIVE_INT64:\n+              points.add(\n+                  LongPoint.create(\n+                      epochNanos,\n+                      epochNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              Double::longValue,\n+                              arg -> arg,\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null)));\n+              break;\n+            case GAUGE_DOUBLE:\n+            case CUMULATIVE_DOUBLE:\n+              points.add(\n+                  DoublePoint.create(\n+                      epochNanos,\n+                      epochNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> arg,\n+                              Long::doubleValue,\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null)));\n+              break;\n+            case SUMMARY:\n+              points.add(\n+                  SummaryPoint.create(\n+                      epochNanos,\n+                      epochNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null,\n+                              Summary::getCount,\n+                              arg -> null),\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null, arg -> null, arg -> null, Summary::getSum, arg -> null),\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null,\n+                              OpenTelemetryMetricsExporter::mapPercentiles,\n+                              arg -> null)));\n+              break;\n+            default:\n+              LOGGER.warning(type + \" not supported by OpenCensus to OpenTelemetry migrator.\");\n+              break;\n+          }\n+        }\n+        MetricData.Type metricDataType = mapType(type);\n+        if (metricDataType != null) {\n+          // TODO(@zoercai): resource, attributes, instrumentationLibraryInfo need to be\n+          // added/mapped properly\n+          metricData.add(\n+              MetricData.create(\n+                  Resource.getDefault(),\n+                  InstrumentationLibraryInfo.create(\"das\", \"1\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7dc479fcd766512c56850dea41698c7968db319"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMzk3MzI0OnYy", "diffSide": "RIGHT", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMTozODozOVrOH39VhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QwMTozODozOVrOH39VhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzODY2MA==", "bodyText": "This message will be printed for every data point - maybe we should aggregate detected unsupported types and print one message per export?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r528438660", "createdAt": "2020-11-23T01:38:39Z", "author": {"login": "nilebox"}, "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        for (int i = 0; i < metric.getMetricDescriptor().getLabelKeys().size(); i++) {\n+          labelsBuilder.put(\n+              metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+              Objects.requireNonNull(timeSeries.getLabelValues().get(i).getValue()));\n+        }\n+        Labels labels = labelsBuilder.build();\n+        ArrayList<MetricData.Point> points = new ArrayList<>();\n+        MetricDescriptor.Type type = null;\n+        for (Point point : timeSeries.getPoints()) {\n+          long timestampNanos =\n+              TimeUnit.SECONDS.toNanos(point.getTimestamp().getSeconds())\n+                  + point.getTimestamp().getNanos();\n+          type = metric.getMetricDescriptor().getType();\n+          switch (type) {\n+            case GAUGE_INT64:\n+            case CUMULATIVE_INT64:\n+              points.add(\n+                  LongPoint.create(\n+                      timestampNanos,\n+                      timestampNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              Double::longValue,\n+                              arg -> arg,\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null)));\n+              break;\n+            case GAUGE_DOUBLE:\n+            case CUMULATIVE_DOUBLE:\n+              points.add(\n+                  DoublePoint.create(\n+                      timestampNanos,\n+                      timestampNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> arg,\n+                              Long::doubleValue,\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null)));\n+              break;\n+            case SUMMARY:\n+              points.add(\n+                  SummaryPoint.create(\n+                      timestampNanos,\n+                      timestampNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null,\n+                              Summary::getCount,\n+                              arg -> null),\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null, arg -> null, arg -> null, Summary::getSum, arg -> null),\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null,\n+                              OpenTelemetryMetricsExporter::mapPercentiles,\n+                              arg -> null)));\n+              break;\n+            default:\n+              LOGGER.warning(type + \" not supported by OpenCensus to OpenTelemetry migrator.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a55b656f754a178b9497e9aba4491359b491f9db"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMjE0ODAxOnYy", "diffSide": "RIGHT", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMzoxNjo1NVrOH6o9mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMzoxNjo1NVrOH6o9mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI1MDU4NQ==", "bodyText": "I think this should be a HashSet, otherwise it may contain duplicate types from every data point.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ArrayList<MetricDescriptor.Type> unsupportedTypes = new ArrayList<>();\n          \n          \n            \n                Set<MetricDescriptor.Type> unsupportedTypes = new HashSet<>();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r531250585", "createdAt": "2020-11-26T23:16:55Z", "author": {"login": "nilebox"}, "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import com.google.common.base.Joiner;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    ArrayList<MetricDescriptor.Type> unsupportedTypes = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "799667edc0494d9ec20e1484fcd3635ff9942958"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMjE1MDE3OnYy", "diffSide": "RIGHT", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMzoxODo1MFrOH6o-rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMzoxODo1MFrOH6o-rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI1MDg2Mw==", "bodyText": "nit: here and in other places: List<> (interface) is more idiomatic for variable type.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ArrayList<MetricData> metricData = new ArrayList<>();\n          \n          \n            \n                List<MetricData> metricData = new ArrayList<>();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r531250863", "createdAt": "2020-11-26T23:18:50Z", "author": {"login": "nilebox"}, "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import com.google.common.base.Joiner;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    ArrayList<MetricData> metricData = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "799667edc0494d9ec20e1484fcd3635ff9942958"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMjE1Mjk0OnYy", "diffSide": "RIGHT", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMzoyMDozNlrOH6pABQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwMTowMTo0NVrOH6q8mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI1MTIwNQ==", "bodyText": "Are you sure it's not possible to have a \"null\" label value in OpenCensus? Maybe it has to be an empty string in that case (then this code is fine)?\nMaybe not, just double checking.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r531251205", "createdAt": "2020-11-26T23:20:36Z", "author": {"login": "nilebox"}, "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import com.google.common.base.Joiner;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    ArrayList<MetricDescriptor.Type> unsupportedTypes = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        for (int i = 0; i < metric.getMetricDescriptor().getLabelKeys().size(); i++) {\n+          labelsBuilder.put(\n+              metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+              Objects.requireNonNull(timeSeries.getLabelValues().get(i).getValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "799667edc0494d9ec20e1484fcd3635ff9942958"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI4MzA5OQ==", "bodyText": "Ah good catch!\n\nReturns the value of this {@link LabelValue}. Returns {@code null} if the value is unset and supposed to be ignored.\n\nI've updated the code now to only add a label if it's not null.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r531283099", "createdAt": "2020-11-27T01:01:45Z", "author": {"login": "zoercai"}, "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import com.google.common.base.Joiner;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    ArrayList<MetricDescriptor.Type> unsupportedTypes = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        for (int i = 0; i < metric.getMetricDescriptor().getLabelKeys().size(); i++) {\n+          labelsBuilder.put(\n+              metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+              Objects.requireNonNull(timeSeries.getLabelValues().get(i).getValue()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI1MTIwNQ=="}, "originalCommit": {"oid": "799667edc0494d9ec20e1484fcd3635ff9942958"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTI4Nzg1OnYy", "diffSide": "RIGHT", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToxMDowOFrOH_eQ0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxOToxMDowOFrOH_eQ0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxODE2MA==", "bodyText": "I'd like to see the contents of the loop extracted into a method, to make this code a little easier to understand.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r536318160", "createdAt": "2020-12-04T19:10:08Z", "author": {"login": "jkwatson"}, "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import com.google.common.base.Joiner;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+import javax.annotation.Nonnull;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    List<MetricData> metricData = new ArrayList<>();\n+    Set<MetricDescriptor.Type> unsupportedTypes = new HashSet<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        for (int i = 0; i < metric.getMetricDescriptor().getLabelKeys().size(); i++) {\n+          if (timeSeries.getLabelValues().get(i).getValue() != null) {\n+            labelsBuilder.put(\n+                metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+                timeSeries.getLabelValues().get(i).getValue());\n+          }\n+        }\n+        Labels labels = labelsBuilder.build();\n+        List<MetricData.Point> points = new ArrayList<>();\n+        MetricDescriptor.Type type = null;\n+        for (Point point : timeSeries.getPoints()) {\n+          long timestampNanos =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4609e4140d44d4cceddc1da1333123d154e130e7"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1949, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}