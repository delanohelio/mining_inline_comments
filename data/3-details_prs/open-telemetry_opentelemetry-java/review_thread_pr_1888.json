{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwNDI3OTk3", "number": 1888, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwMjo1MDo1N1rOEyKY2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzo1Nzo0OVrOEymQQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMDM0NDU3OnYy", "diffSide": "RIGHT", "path": "context/src/otelInBraveTest/java/io/opentelemetry/context/BraveContextStorageProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwMjo1MDo1N1rOHophhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwMjo1MDo1N1rOHophhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM4NTQxMg==", "bodyText": "Instead of this, I may be able to check for DefaultContext but that may not work for everyone, so to show how to do it I wrapped it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r512385412", "createdAt": "2020-10-27T02:50:57Z", "author": {"login": "bogdandrutu"}, "path": "context/src/otelInBraveTest/java/io/opentelemetry/context/BraveContextStorageProvider.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import brave.Tracing;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.TraceContext;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+public class BraveContextStorageProvider implements ContextStorageProvider {\n+\n+  @Override\n+  public ContextStorage get() {\n+    return BraveContextStorage.INSTANCE;\n+  }\n+\n+  @SuppressWarnings(\"ReferenceEquality\")\n+  private enum BraveContextStorage implements ContextStorage {\n+    INSTANCE;\n+\n+    @Override\n+    public Scope attach(Context toAttach) {\n+      CurrentTraceContext currentTraceContext = Tracing.current().currentTraceContext();\n+      TraceContext currentBraveContext = currentTraceContext.get();\n+      ContextWrapper currentContext = fromBraveContext(currentBraveContext);\n+      if (currentContext == ContextWrapper.ROOT\n+          && (toAttach == null || toAttach == Context.root())) {\n+        // It may be possible that in the current brave we have null, and asked to add root,\n+        // but the behavior of Current is to never return null, so it is fine to return noop.\n+        return Scope.noop();\n+      }\n+\n+      TraceContext newBraveContext =\n+          currentBraveContext.toBuilder().addExtra(new ContextWrapper(toAttach)).build();\n+      CurrentTraceContext.Scope braveScope = currentTraceContext.newScope(newBraveContext);\n+      return braveScope::close;\n+    }\n+\n+    @Override\n+    public Context current() {\n+      TraceContext currentBraveContext = Tracing.current().currentTraceContext().get();\n+      if (currentBraveContext == null) {\n+        return Context.root();\n+      }\n+      return fromBraveContext(currentBraveContext);\n+    }\n+\n+    private static ContextWrapper fromBraveContext(TraceContext braveContext) {\n+      ContextWrapper currentContext = findContextWrapper(braveContext.extra());\n+      return currentContext == null ? ContextWrapper.ROOT : currentContext;\n+    }\n+\n+    static ContextWrapper findContextWrapper(List<Object> extra) {\n+      for (int i = extra.size() - 1; i >= 0; i--) {\n+        Object nextExtra = extra.get(i);\n+        if (nextExtra.getClass() == ContextWrapper.class) return (ContextWrapper) nextExtra;\n+      }\n+      return null;\n+    }\n+  }\n+\n+  // Need to wrap the Context because brave findExtra searches for perfect match of the class.\n+  static final class ContextWrapper implements Context {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d809b877008f3431e9957e6358fdf1f214bbf2"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDE3ODk0OnYy", "diffSide": "RIGHT", "path": "context/src/otelInBraveTest/java/io/opentelemetry/context/OtelInBraveTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTo1MTo0NVrOHpOTUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMDo1Mjo1OVrOHpQagw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4Nzk4Ng==", "bodyText": "an unusual animal. :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r512987986", "createdAt": "2020-10-27T19:51:45Z", "author": {"login": "jkwatson"}, "path": "context/src/otelInBraveTest/java/io/opentelemetry/context/OtelInBraveTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import brave.Tracing;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.TraceContext;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+class OtelInBraveTest {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\");\n+  private static final Context CONTEXT_WITH_ANIMAL = Context.root().with(ANIMAL, \"japan\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91347daaa3207edd611fadc7ae02e00267e9d455"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAyMjU5NQ==", "bodyText": "@anuraaga is guilty for this :)) and me that I copied paste", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r513022595", "createdAt": "2020-10-27T20:52:59Z", "author": {"login": "bogdandrutu"}, "path": "context/src/otelInBraveTest/java/io/opentelemetry/context/OtelInBraveTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import brave.Tracing;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.TraceContext;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+class OtelInBraveTest {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\");\n+  private static final Context CONTEXT_WITH_ANIMAL = Context.root().with(ANIMAL, \"japan\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4Nzk4Ng=="}, "originalCommit": {"oid": "91347daaa3207edd611fadc7ae02e00267e9d455"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDkwMDUxOnYy", "diffSide": "RIGHT", "path": "context/src/main/java/io/opentelemetry/context/DefaultContext.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzo1MzoyN1rOHpVF6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDoxNzoyMVrOHsbyqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5OTI0MA==", "bodyText": "Don't think it hurts but is there something we get with covariant types here?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r513099240", "createdAt": "2020-10-27T23:53:27Z", "author": {"login": "anuraaga"}, "path": "context/src/main/java/io/opentelemetry/context/DefaultContext.java", "diffHunk": "@@ -61,22 +61,22 @@ private DefaultContext(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object>\n   }\n \n   @Override\n-  public <V> Context with(ContextKey<V> k1, V v1) {\n+  public <V> DefaultContext with(ContextKey<V> k1, V v1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91347daaa3207edd611fadc7ae02e00267e9d455"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0MjgzNg==", "bodyText": "Ah realized it does hurt a bit since bytecode instrumentation doesn't work anymore (root() being the important one)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r513142836", "createdAt": "2020-10-28T02:30:51Z", "author": {"login": "anuraaga"}, "path": "context/src/main/java/io/opentelemetry/context/DefaultContext.java", "diffHunk": "@@ -61,22 +61,22 @@ private DefaultContext(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object>\n   }\n \n   @Override\n-  public <V> Context with(ContextKey<V> k1, V v1) {\n+  public <V> DefaultContext with(ContextKey<V> k1, V v1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5OTI0MA=="}, "originalCommit": {"oid": "91347daaa3207edd611fadc7ae02e00267e9d455"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUzNzE3NQ==", "bodyText": "You approved this PR. Is this ok, @anuraaga ?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r515537175", "createdAt": "2020-10-31T20:41:11Z", "author": {"login": "jkwatson"}, "path": "context/src/main/java/io/opentelemetry/context/DefaultContext.java", "diffHunk": "@@ -61,22 +61,22 @@ private DefaultContext(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object>\n   }\n \n   @Override\n-  public <V> Context with(ContextKey<V> k1, V v1) {\n+  public <V> DefaultContext with(ContextKey<V> k1, V v1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5OTI0MA=="}, "originalCommit": {"oid": "91347daaa3207edd611fadc7ae02e00267e9d455"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU1MTE1NQ==", "bodyText": "Can you explain what is the problem?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r515551155", "createdAt": "2020-10-31T23:12:39Z", "author": {"login": "bogdandrutu"}, "path": "context/src/main/java/io/opentelemetry/context/DefaultContext.java", "diffHunk": "@@ -61,22 +61,22 @@ private DefaultContext(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object>\n   }\n \n   @Override\n-  public <V> Context with(ContextKey<V> k1, V v1) {\n+  public <V> DefaultContext with(ContextKey<V> k1, V v1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5OTI0MA=="}, "originalCommit": {"oid": "91347daaa3207edd611fadc7ae02e00267e9d455"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU3MzkyNg==", "bodyText": "Yeah - root() is intercepted by auto instrumentation to return an agent managed context. We need the return value to be the public type.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r515573926", "createdAt": "2020-11-01T04:30:00Z", "author": {"login": "anuraaga"}, "path": "context/src/main/java/io/opentelemetry/context/DefaultContext.java", "diffHunk": "@@ -61,22 +61,22 @@ private DefaultContext(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object>\n   }\n \n   @Override\n-  public <V> Context with(ContextKey<V> k1, V v1) {\n+  public <V> DefaultContext with(ContextKey<V> k1, V v1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5OTI0MA=="}, "originalCommit": {"oid": "91347daaa3207edd611fadc7ae02e00267e9d455"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1NDczMQ==", "bodyText": "No more changes.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r516354731", "createdAt": "2020-11-03T00:17:21Z", "author": {"login": "bogdandrutu"}, "path": "context/src/main/java/io/opentelemetry/context/DefaultContext.java", "diffHunk": "@@ -61,22 +61,22 @@ private DefaultContext(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object>\n   }\n \n   @Override\n-  public <V> Context with(ContextKey<V> k1, V v1) {\n+  public <V> DefaultContext with(ContextKey<V> k1, V v1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5OTI0MA=="}, "originalCommit": {"oid": "91347daaa3207edd611fadc7ae02e00267e9d455"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDkxMDA5OnYy", "diffSide": "RIGHT", "path": "context/src/otelInBraveTest/java/io/opentelemetry/context/BraveContextStorageProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzo1Nzo0OVrOHpVLiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDoxNDo0NVrOHqs9ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMDY4MQ==", "bodyText": "Does it work to check class != ContextWrapper? This test is lucky to have package private access but a real provider wouldn't.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r513100681", "createdAt": "2020-10-27T23:57:49Z", "author": {"login": "anuraaga"}, "path": "context/src/otelInBraveTest/java/io/opentelemetry/context/BraveContextStorageProvider.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import brave.Tracing;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.TraceContext;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+public class BraveContextStorageProvider implements ContextStorageProvider {\n+\n+  @Override\n+  public ContextStorage get() {\n+    return BraveContextStorage.INSTANCE;\n+  }\n+\n+  @SuppressWarnings(\"ReferenceEquality\")\n+  private enum BraveContextStorage implements ContextStorage {\n+    INSTANCE;\n+\n+    @Override\n+    public Scope attach(Context toAttach) {\n+      CurrentTraceContext currentTraceContext = Tracing.current().currentTraceContext();\n+      TraceContext currentBraveContext = currentTraceContext.get();\n+      if (currentBraveContext == null) {\n+        if (toAttach == Context.root()) {\n+          return Scope.noop();\n+        }\n+      } else {\n+        Context currentContext = ContextWrapper.fromBraveContext(currentBraveContext);\n+        if (currentContext == toAttach) {\n+          return Scope.noop();\n+        }\n+      }\n+\n+      TraceContext newBraveContext;\n+      if (toAttach instanceof ContextWrapper) {\n+        newBraveContext = ((ContextWrapper) toAttach).toBraveContext();\n+      } else {\n+        TraceContext.Builder builder =\n+            currentBraveContext == null\n+                ? TraceContext.newBuilder()\n+                : currentBraveContext.toBuilder();\n+        newBraveContext = builder.addExtra(toAttach).build();\n+      }\n+\n+      if (currentBraveContext == newBraveContext) {\n+        return Scope.noop();\n+      }\n+      CurrentTraceContext.Scope braveScope = currentTraceContext.newScope(newBraveContext);\n+      return braveScope::close;\n+    }\n+\n+    @Override\n+    public Context current() {\n+      TraceContext currentBraveContext = Tracing.current().currentTraceContext().get();\n+      if (currentBraveContext == null) {\n+        return Context.root();\n+      }\n+      return new ContextWrapper(\n+          currentBraveContext, ContextWrapper.fromBraveContext(currentBraveContext));\n+    }\n+  }\n+\n+  // Need to wrap the Context because brave findExtra searches for perfect match of the class.\n+  static final class ContextWrapper implements Context {\n+    private final TraceContext baseBraveContext;\n+    private final DefaultContext context;\n+\n+    ContextWrapper(TraceContext baseBraveContext, DefaultContext context) {\n+      this.baseBraveContext = baseBraveContext;\n+      this.context = context;\n+    }\n+\n+    TraceContext toBraveContext() {\n+      if (fromBraveContext(baseBraveContext) == context) {\n+        return baseBraveContext;\n+      }\n+      return baseBraveContext.toBuilder().addExtra(context).build();\n+    }\n+\n+    @Nullable\n+    @Override\n+    public <V> V get(ContextKey<V> key) {\n+      return context.get(key);\n+    }\n+\n+    @Override\n+    public <V> Context with(ContextKey<V> k1, V v1) {\n+      return new ContextWrapper(baseBraveContext, context.with(k1, v1));\n+    }\n+\n+    private static DefaultContext fromBraveContext(TraceContext braveContext) {\n+      List<Object> extra = braveContext.extra();\n+      for (int i = extra.size() - 1; i >= 0; i--) {\n+        Object nextExtra = extra.get(i);\n+        if (nextExtra.getClass() == DefaultContext.class) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91347daaa3207edd611fadc7ae02e00267e9d455"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUzODkxNQ==", "bodyText": "We cannot add ContextWrapper because it will create a circular reference. So if that is the case I need another ContextWrapper that wraps only the otel Context.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1888#discussion_r514538915", "createdAt": "2020-10-29T20:14:45Z", "author": {"login": "bogdandrutu"}, "path": "context/src/otelInBraveTest/java/io/opentelemetry/context/BraveContextStorageProvider.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import brave.Tracing;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.TraceContext;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+public class BraveContextStorageProvider implements ContextStorageProvider {\n+\n+  @Override\n+  public ContextStorage get() {\n+    return BraveContextStorage.INSTANCE;\n+  }\n+\n+  @SuppressWarnings(\"ReferenceEquality\")\n+  private enum BraveContextStorage implements ContextStorage {\n+    INSTANCE;\n+\n+    @Override\n+    public Scope attach(Context toAttach) {\n+      CurrentTraceContext currentTraceContext = Tracing.current().currentTraceContext();\n+      TraceContext currentBraveContext = currentTraceContext.get();\n+      if (currentBraveContext == null) {\n+        if (toAttach == Context.root()) {\n+          return Scope.noop();\n+        }\n+      } else {\n+        Context currentContext = ContextWrapper.fromBraveContext(currentBraveContext);\n+        if (currentContext == toAttach) {\n+          return Scope.noop();\n+        }\n+      }\n+\n+      TraceContext newBraveContext;\n+      if (toAttach instanceof ContextWrapper) {\n+        newBraveContext = ((ContextWrapper) toAttach).toBraveContext();\n+      } else {\n+        TraceContext.Builder builder =\n+            currentBraveContext == null\n+                ? TraceContext.newBuilder()\n+                : currentBraveContext.toBuilder();\n+        newBraveContext = builder.addExtra(toAttach).build();\n+      }\n+\n+      if (currentBraveContext == newBraveContext) {\n+        return Scope.noop();\n+      }\n+      CurrentTraceContext.Scope braveScope = currentTraceContext.newScope(newBraveContext);\n+      return braveScope::close;\n+    }\n+\n+    @Override\n+    public Context current() {\n+      TraceContext currentBraveContext = Tracing.current().currentTraceContext().get();\n+      if (currentBraveContext == null) {\n+        return Context.root();\n+      }\n+      return new ContextWrapper(\n+          currentBraveContext, ContextWrapper.fromBraveContext(currentBraveContext));\n+    }\n+  }\n+\n+  // Need to wrap the Context because brave findExtra searches for perfect match of the class.\n+  static final class ContextWrapper implements Context {\n+    private final TraceContext baseBraveContext;\n+    private final DefaultContext context;\n+\n+    ContextWrapper(TraceContext baseBraveContext, DefaultContext context) {\n+      this.baseBraveContext = baseBraveContext;\n+      this.context = context;\n+    }\n+\n+    TraceContext toBraveContext() {\n+      if (fromBraveContext(baseBraveContext) == context) {\n+        return baseBraveContext;\n+      }\n+      return baseBraveContext.toBuilder().addExtra(context).build();\n+    }\n+\n+    @Nullable\n+    @Override\n+    public <V> V get(ContextKey<V> key) {\n+      return context.get(key);\n+    }\n+\n+    @Override\n+    public <V> Context with(ContextKey<V> k1, V v1) {\n+      return new ContextWrapper(baseBraveContext, context.with(k1, v1));\n+    }\n+\n+    private static DefaultContext fromBraveContext(TraceContext braveContext) {\n+      List<Object> extra = braveContext.extra();\n+      for (int i = extra.size() - 1; i >= 0; i--) {\n+        Object nextExtra = extra.get(i);\n+        if (nextExtra.getClass() == DefaultContext.class) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMDY4MQ=="}, "originalCommit": {"oid": "91347daaa3207edd611fadc7ae02e00267e9d455"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2018, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}