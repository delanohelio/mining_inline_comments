{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0NjE2NDQ4", "number": 1046, "title": "added jaeger propagator and tests", "bodyText": "Sorry for taking my time with this, been a bit hectic with everything going on right now.\nQuestion - should this be in the API package (along with the B3 propagtor)? To me it would feel better placed in the SDK.", "createdAt": "2020-03-27T08:24:21Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046", "merged": true, "mergeCommit": {"oid": "b14a2dd87d733e43d6119e8a3dae6da1bd3b9e1d"}, "closed": true, "closedAt": "2020-04-02T15:27:37Z", "author": {"login": "jarebudev"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRlJIDgH2gAyMzk0NjE2NDQ4OmE0M2NhMzdhZGI0ZDRjYThmODEwNzgwNDUxMmJmMjgyZjZmMGY5NTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTt_9fAFqTM4NjUzOTEwNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958", "author": {"user": {"login": "jarebudev", "name": null}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a43ca37adb4d4ca8f8107804512bf282f6f0f958", "committedDate": "2020-03-26T23:59:15Z", "message": "added jaeger propogator and test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNzAwMjAy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#pullrequestreview-382700202", "createdAt": "2020-03-27T09:33:18Z", "commit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTozMzoxOVrOF8paiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTozMzoxOVrOF8paiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEzNzQxNg==", "bodyText": "TRUE_INT and FALSE_INT kinda misleading names because type is String and they are using to mark that span is sampled, if u are wanna use static variable consider to use smth like IS_SAMPLED", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399137416", "createdAt": "2020-03-27T09:33:19Z", "author": {"login": "DotSpy"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNzA2Mzc3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#pullrequestreview-382706377", "createdAt": "2020-03-27T09:42:07Z", "commit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTo0MjowN1rOF8puRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTo0MjowN1rOF8puRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0MjQ3MQ==", "bodyText": "same for this name explain that we are setting it to 0 because this field is deprecated.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399142471", "createdAt": "2020-03-27T09:42:07Z", "author": {"login": "DotSpy"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNzA3NDQx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#pullrequestreview-382707441", "createdAt": "2020-03-27T09:43:38Z", "commit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTo0MzozOFrOF8pxeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTo0MzozOFrOF8pxeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0MzI4OQ==", "bodyText": "if u are using UTF-8 one time i don't think it worse it to do a static variable for it", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399143289", "createdAt": "2020-03-27T09:43:38Z", "author": {"login": "DotSpy"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNzEwNTg0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#pullrequestreview-382710584", "createdAt": "2020-03-27T09:48:13Z", "commit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTo0ODoxNFrOF8p8DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTo0ODoxNFrOF8p8DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0NTk5Nw==", "bodyText": "consider to log here value that we couldn't decode", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399145997", "createdAt": "2020-03-27T09:48:14Z", "author": {"login": "DotSpy"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty header: '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, UTF_8);\n+    } catch (UnsupportedEncodingException e) {\n+      logger.info(\"Error decoding '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNzExNzI2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#pullrequestreview-382711726", "createdAt": "2020-03-27T09:49:51Z", "commit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTo0OTo1MlrOF8p_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwOTo0OTo1MlrOF8p_uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0NjkzOQ==", "bodyText": "consider to log here trace id that invalid", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399146939", "createdAt": "2020-03-27T09:49:52Z", "author": {"login": "DotSpy"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty header: '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, UTF_8);\n+    } catch (UnsupportedEncodingException e) {\n+      logger.info(\"Error decoding '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String[] parts = value.split(SEPARATOR);\n+    if (parts.length != 4) {\n+      logger.info(\"Invalid header '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in Jaeger header: '\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyODMzNTc4", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#pullrequestreview-382833578", "createdAt": "2020-03-27T12:59:35Z", "commit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMjo1OTozNVrOF8wCBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxMzoxMTo0OVrOF8wc8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0NTgyOQ==", "bodyText": "There might be a built in constant StandardCharsets.UTF_8.name();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399245829", "createdAt": "2020-03-27T12:59:35Z", "author": {"login": "pavolloffay"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0MzI4OQ=="}, "originalCommit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0ODMyMQ==", "bodyText": "This log is not necessary. It can happen quite often.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399248321", "createdAt": "2020-03-27T13:04:11Z", "author": {"login": "pavolloffay"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0OTY0NQ==", "bodyText": "nit: log the value", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399249645", "createdAt": "2020-03-27T13:06:33Z", "author": {"login": "pavolloffay"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty header: '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, UTF_8);\n+    } catch (UnsupportedEncodingException e) {\n+      logger.info(\"Error decoding '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String[] parts = value.split(SEPARATOR);\n+    if (parts.length != 4) {\n+      logger.info(\"Invalid header '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI1MjcyMg==", "bodyText": "Tests could use Jaeger client and compare results on in the carrier with this implementation.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399252722", "createdAt": "2020-03-27T13:11:49Z", "author": {"login": "pavolloffay"}, "path": "api/src/test/java/io/opentelemetry/trace/propagation/JaegerPropagatorTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.trace.propagation.JaegerPropagator.PARENT_SPAN;\n+import static io.opentelemetry.trace.propagation.JaegerPropagator.SEPARATOR;\n+import static io.opentelemetry.trace.propagation.JaegerPropagator.TRACE_ID_HEADER;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link io.opentelemetry.trace.propagation.JaegerPropagator}. */\n+@RunWith(JUnit4.class)\n+public class JaegerPropagatorTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0861da2d10ad548d2a4d443771634c0b8c640ed9", "author": {"user": {"login": "jarebudev", "name": null}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0861da2d10ad548d2a4d443771634c0b8c640ed9", "committedDate": "2020-03-28T21:38:59Z", "message": "address PR comments about logging and static var names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "139050b0709f678ea961fa39985b35d724d7398b", "author": {"user": {"login": "jarebudev", "name": null}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/139050b0709f678ea961fa39985b35d724d7398b", "committedDate": "2020-03-29T22:20:48Z", "message": "added jaeger client for testing jaeger propagator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c", "author": {"user": {"login": "jarebudev", "name": null}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c", "committedDate": "2020-03-30T20:44:34Z", "message": "resolved conflict in build.gradle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0Mjg5OTIw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#pullrequestreview-384289920", "createdAt": "2020-03-30T22:55:42Z", "commit": {"oid": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjo1NTo0M1rOF9_OxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMzowOTo0MVrOF9_h3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MzQyOA==", "bodyText": "The standard says that it is base16 encoded, I am not sure why do you need to call URLDecoder(base16) is base16 if I am not missing something.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r400543428", "createdAt": "2020-03-30T22:55:43Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  // Parent span has been deprecated but Jaeger propagation protocol requires it\n+  static final String DEPRECATED_PARENT_SPAN = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String IS_SAMPLED = \"1\";\n+  private static final String NOT_SAMPLED = \"0\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + DEPRECATED_PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, \"UTF-8\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NjY3Mg==", "bodyText": "consider to benchmark this to see if allocated a char[] with the right size and calling copyLowerBase16To gives better performance. maybe just a TODO.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r400546672", "createdAt": "2020-03-30T23:04:43Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  // Parent span has been deprecated but Jaeger propagation protocol requires it\n+  static final String DEPRECATED_PARENT_SPAN = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String IS_SAMPLED = \"1\";\n+  private static final String NOT_SAMPLED = \"0\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + DEPRECATED_PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NzY4MA==", "bodyText": "I think I got it the separator \":\" may be encoded, please comment.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r400547680", "createdAt": "2020-03-30T23:07:50Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  // Parent span has been deprecated but Jaeger propagation protocol requires it\n+  static final String DEPRECATED_PARENT_SPAN = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String IS_SAMPLED = \"1\";\n+  private static final String NOT_SAMPLED = \"0\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + DEPRECATED_PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, \"UTF-8\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MzQyOA=="}, "originalCommit": {"oid": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NzcwMA==", "bodyText": "You can avoid using split. The first separator is the only one which can be on different position then all the others are at known positions relative to the first one.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r400547700", "createdAt": "2020-03-30T23:07:53Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  // Parent span has been deprecated but Jaeger propagation protocol requires it\n+  static final String DEPRECATED_PARENT_SPAN = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String IS_SAMPLED = \"1\";\n+  private static final String NOT_SAMPLED = \"0\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + DEPRECATED_PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      logger.info(\n+          \"Error decoding '\"\n+              + TRACE_ID_HEADER\n+              + \"' with value \"\n+              + value\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String[] parts = value.split(SEPARATOR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0ODMxOQ==", "bodyText": "Or the base16 encoding in the spec actually is hex encoded which means is variable size?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r400548319", "createdAt": "2020-03-30T23:09:41Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  // Parent span has been deprecated but Jaeger propagation protocol requires it\n+  static final String DEPRECATED_PARENT_SPAN = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String IS_SAMPLED = \"1\";\n+  private static final String NOT_SAMPLED = \"0\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + DEPRECATED_PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      logger.info(\n+          \"Error decoding '\"\n+              + TRACE_ID_HEADER\n+              + \"' with value \"\n+              + value\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String[] parts = value.split(SEPARATOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NzcwMA=="}, "originalCommit": {"oid": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MjIyMTA5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#pullrequestreview-385222109", "createdAt": "2020-04-01T02:12:34Z", "commit": {"oid": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7526af496f0bc2022cc25e0e110a95faf367cecb", "author": {"user": {"login": "jarebudev", "name": null}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7526af496f0bc2022cc25e0e110a95faf367cecb", "committedDate": "2020-04-02T07:05:59Z", "message": "added comment to explain why UTF-8 decoding is needed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NTM5MTA1", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#pullrequestreview-386539105", "createdAt": "2020-04-02T15:26:14Z", "commit": {"oid": "7526af496f0bc2022cc25e0e110a95faf367cecb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2877, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}