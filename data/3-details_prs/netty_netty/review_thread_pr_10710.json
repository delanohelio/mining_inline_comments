{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MzczNzAx", "number": 10710, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo1NToyMlrOEvn_7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoyMTozMlrOEvojPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzczODY4OnYy", "diffSide": "RIGHT", "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo1NToyMlrOHktN9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNjo1NToyMlrOHktN9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1MTYzOQ==", "bodyText": "nit: please use:\nHttpResponseStatus.SWITCHING_PROTOCOLS.equals(httpResponse.status())", "url": "https://github.com/netty/netty/pull/10710#discussion_r508251639", "createdAt": "2020-10-20T06:55:22Z", "author": {"login": "normanmaurer"}, "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "diffHunk": "@@ -104,50 +105,60 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n     @Override\n     public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n         if (msg instanceof HttpResponse) {\n-            HttpHeaders headers = ((HttpResponse) msg).headers();\n+            HttpResponse httpResponse = (HttpResponse) msg;\n+            //checking the status is faster than looking at headers\n+            //so we do this first\n+            if (httpResponse.status().code() == HttpResponseStatus.SWITCHING_PROTOCOLS.code()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f2a3c3bd600cc17d8ba001c86093c4fc6158cd8"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MzgyOTExOnYy", "diffSide": "RIGHT", "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoyMTozMlrOHkuDtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNzoyNDoxNVrOHkuJ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2NTM5OQ==", "bodyText": "As we're already here, we can move ctx.name() to own local variable out of the loop. That will help the compiler a bit.", "url": "https://github.com/netty/netty/pull/10710#discussion_r508265399", "createdAt": "2020-10-20T07:21:32Z", "author": {"login": "doom369"}, "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "diffHunk": "@@ -104,50 +105,60 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n     @Override\n     public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n         if (msg instanceof HttpResponse) {\n-            HttpHeaders headers = ((HttpResponse) msg).headers();\n+            HttpResponse httpResponse = (HttpResponse) msg;\n+            //checking the status is faster than looking at headers\n+            //so we do this first\n+            if (httpResponse.status().code() == HttpResponseStatus.SWITCHING_PROTOCOLS.code()) {\n+                handlePotentialUpgrade(ctx, promise, httpResponse);\n+            }\n+        }\n \n-            if (WebSocketExtensionUtil.isWebsocketUpgrade(headers)) {\n+        super.write(ctx, msg, promise);\n+    }\n \n-                if (validExtensions != null) {\n-                    String headerValue = headers.getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);\n+    private void handlePotentialUpgrade(final ChannelHandlerContext ctx,\n+                                        ChannelPromise promise, HttpResponse httpResponse) {\n+        HttpHeaders headers = httpResponse.headers();\n \n-                    for (WebSocketServerExtension extension : validExtensions) {\n-                        WebSocketExtensionData extensionData = extension.newReponseData();\n-                        headerValue = WebSocketExtensionUtil.appendExtension(headerValue,\n-                                                                             extensionData.name(),\n-                                                                             extensionData.parameters());\n-                    }\n-                    promise.addListener(new ChannelFutureListener() {\n-                        @Override\n-                        public void operationComplete(ChannelFuture future) {\n-                            if (future.isSuccess()) {\n-                                for (WebSocketServerExtension extension : validExtensions) {\n-                                    WebSocketExtensionDecoder decoder = extension.newExtensionDecoder();\n-                                    WebSocketExtensionEncoder encoder = extension.newExtensionEncoder();\n-                                    ctx.pipeline()\n-                                       .addAfter(ctx.name(), decoder.getClass().getName(), decoder)\n-                                       .addAfter(ctx.name(), encoder.getClass().getName(), encoder);\n-                                }\n-                            }\n-                        }\n-                    });\n+        if (WebSocketExtensionUtil.isWebsocketUpgrade(headers)) {\n \n-                    if (headerValue != null) {\n-                        headers.set(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS, headerValue);\n-                    }\n-                }\n+            if (validExtensions != null) {\n+                String headerValue = headers.getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);\n \n+                for (WebSocketServerExtension extension : validExtensions) {\n+                    WebSocketExtensionData extensionData = extension.newReponseData();\n+                    headerValue = WebSocketExtensionUtil.appendExtension(headerValue,\n+                        extensionData.name(),\n+                        extensionData.parameters());\n+                }\n                 promise.addListener(new ChannelFutureListener() {\n                     @Override\n                     public void operationComplete(ChannelFuture future) {\n                         if (future.isSuccess()) {\n-                            ctx.pipeline().remove(WebSocketServerExtensionHandler.this);\n+                            for (WebSocketServerExtension extension : validExtensions) {\n+                                WebSocketExtensionDecoder decoder = extension.newExtensionDecoder();\n+                                WebSocketExtensionEncoder encoder = extension.newExtensionEncoder();\n+                                ctx.pipeline()\n+                                    .addAfter(ctx.name(), decoder.getClass().getName(), decoder)\n+                                    .addAfter(ctx.name(), encoder.getClass().getName(), encoder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f2a3c3bd600cc17d8ba001c86093c4fc6158cd8"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2Njk4OA==", "bodyText": "Good idea, especially if this code isn't going to get hot most of the time", "url": "https://github.com/netty/netty/pull/10710#discussion_r508266988", "createdAt": "2020-10-20T07:24:15Z", "author": {"login": "franz1981"}, "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "diffHunk": "@@ -104,50 +105,60 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n     @Override\n     public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n         if (msg instanceof HttpResponse) {\n-            HttpHeaders headers = ((HttpResponse) msg).headers();\n+            HttpResponse httpResponse = (HttpResponse) msg;\n+            //checking the status is faster than looking at headers\n+            //so we do this first\n+            if (httpResponse.status().code() == HttpResponseStatus.SWITCHING_PROTOCOLS.code()) {\n+                handlePotentialUpgrade(ctx, promise, httpResponse);\n+            }\n+        }\n \n-            if (WebSocketExtensionUtil.isWebsocketUpgrade(headers)) {\n+        super.write(ctx, msg, promise);\n+    }\n \n-                if (validExtensions != null) {\n-                    String headerValue = headers.getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);\n+    private void handlePotentialUpgrade(final ChannelHandlerContext ctx,\n+                                        ChannelPromise promise, HttpResponse httpResponse) {\n+        HttpHeaders headers = httpResponse.headers();\n \n-                    for (WebSocketServerExtension extension : validExtensions) {\n-                        WebSocketExtensionData extensionData = extension.newReponseData();\n-                        headerValue = WebSocketExtensionUtil.appendExtension(headerValue,\n-                                                                             extensionData.name(),\n-                                                                             extensionData.parameters());\n-                    }\n-                    promise.addListener(new ChannelFutureListener() {\n-                        @Override\n-                        public void operationComplete(ChannelFuture future) {\n-                            if (future.isSuccess()) {\n-                                for (WebSocketServerExtension extension : validExtensions) {\n-                                    WebSocketExtensionDecoder decoder = extension.newExtensionDecoder();\n-                                    WebSocketExtensionEncoder encoder = extension.newExtensionEncoder();\n-                                    ctx.pipeline()\n-                                       .addAfter(ctx.name(), decoder.getClass().getName(), decoder)\n-                                       .addAfter(ctx.name(), encoder.getClass().getName(), encoder);\n-                                }\n-                            }\n-                        }\n-                    });\n+        if (WebSocketExtensionUtil.isWebsocketUpgrade(headers)) {\n \n-                    if (headerValue != null) {\n-                        headers.set(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS, headerValue);\n-                    }\n-                }\n+            if (validExtensions != null) {\n+                String headerValue = headers.getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);\n \n+                for (WebSocketServerExtension extension : validExtensions) {\n+                    WebSocketExtensionData extensionData = extension.newReponseData();\n+                    headerValue = WebSocketExtensionUtil.appendExtension(headerValue,\n+                        extensionData.name(),\n+                        extensionData.parameters());\n+                }\n                 promise.addListener(new ChannelFutureListener() {\n                     @Override\n                     public void operationComplete(ChannelFuture future) {\n                         if (future.isSuccess()) {\n-                            ctx.pipeline().remove(WebSocketServerExtensionHandler.this);\n+                            for (WebSocketServerExtension extension : validExtensions) {\n+                                WebSocketExtensionDecoder decoder = extension.newExtensionDecoder();\n+                                WebSocketExtensionEncoder encoder = extension.newExtensionEncoder();\n+                                ctx.pipeline()\n+                                    .addAfter(ctx.name(), decoder.getClass().getName(), decoder)\n+                                    .addAfter(ctx.name(), encoder.getClass().getName(), encoder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2NTM5OQ=="}, "originalCommit": {"oid": "1f2a3c3bd600cc17d8ba001c86093c4fc6158cd8"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3628, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}