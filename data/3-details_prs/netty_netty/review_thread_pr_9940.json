{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNDk3ODEx", "number": 9940, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNTozNDo0MlrODXMDrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMDoyNTo1N1rODXzGQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NjQxMzkwOnYy", "diffSide": "RIGHT", "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxNTozNDo0MlrOFcXonA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQyMDo1NDo0OVrOFcf2vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI5MTY3Ng==", "bodyText": "Can we split this condition on 2 separate if's? So we can perform only 1 class cast:\n((HttpResponse) msg).headers()\nHttpResponse response = (HttpResponse) msg;\nAlso, response.headers() could be moved to variable.", "url": "https://github.com/netty/netty/pull/9940#discussion_r365291676", "createdAt": "2020-01-10T15:34:42Z", "author": {"login": "doom369"}, "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "diffHunk": "@@ -103,36 +103,46 @@ public void channelRead(ChannelHandlerContext ctx, Object msg)\n \n     @Override\n     public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n-        if (msg instanceof HttpResponse &&\n-                WebSocketExtensionUtil.isWebsocketUpgrade(((HttpResponse) msg).headers()) && validExtensions != null) {\n-            HttpResponse response = (HttpResponse) msg;\n-            String headerValue = response.headers().getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);\n-\n-            for (WebSocketServerExtension extension : validExtensions) {\n-                WebSocketExtensionData extensionData = extension.newReponseData();\n-                headerValue = WebSocketExtensionUtil.appendExtension(headerValue,\n-                        extensionData.name(), extensionData.parameters());\n+        if (msg instanceof HttpResponse && WebSocketExtensionUtil.isWebsocketUpgrade(((HttpResponse) msg).headers())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9fd6af1190ac2f7601758e2c71997e90b3944a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQyNjM2NA==", "bodyText": "no problem", "url": "https://github.com/netty/netty/pull/9940#discussion_r365426364", "createdAt": "2020-01-10T20:54:49Z", "author": {"login": "amizurov"}, "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "diffHunk": "@@ -103,36 +103,46 @@ public void channelRead(ChannelHandlerContext ctx, Object msg)\n \n     @Override\n     public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n-        if (msg instanceof HttpResponse &&\n-                WebSocketExtensionUtil.isWebsocketUpgrade(((HttpResponse) msg).headers()) && validExtensions != null) {\n-            HttpResponse response = (HttpResponse) msg;\n-            String headerValue = response.headers().getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);\n-\n-            for (WebSocketServerExtension extension : validExtensions) {\n-                WebSocketExtensionData extensionData = extension.newReponseData();\n-                headerValue = WebSocketExtensionUtil.appendExtension(headerValue,\n-                        extensionData.name(), extensionData.parameters());\n+        if (msg instanceof HttpResponse && WebSocketExtensionUtil.isWebsocketUpgrade(((HttpResponse) msg).headers())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI5MTY3Ng=="}, "originalCommit": {"oid": "8a9fd6af1190ac2f7601758e2c71997e90b3944a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MjgwNjYxOnYy", "diffSide": "RIGHT", "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMDoyNDo1N1rOFdSn7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNDowMjoxOVrOFdYdeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI1ODE1OQ==", "bodyText": "nit: use ctx.pipeline().remove(WebSocketServerExtensionHandler.this);", "url": "https://github.com/netty/netty/pull/9940#discussion_r366258159", "createdAt": "2020-01-14T10:24:57Z", "author": {"login": "normanmaurer"}, "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "diffHunk": "@@ -103,35 +103,48 @@ public void channelRead(ChannelHandlerContext ctx, Object msg)\n \n     @Override\n     public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n-        if (msg instanceof HttpResponse &&\n-                WebSocketExtensionUtil.isWebsocketUpgrade(((HttpResponse) msg).headers()) && validExtensions != null) {\n-            HttpResponse response = (HttpResponse) msg;\n-            String headerValue = response.headers().getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);\n-\n-            for (WebSocketServerExtension extension : validExtensions) {\n-                WebSocketExtensionData extensionData = extension.newReponseData();\n-                headerValue = WebSocketExtensionUtil.appendExtension(headerValue,\n-                        extensionData.name(), extensionData.parameters());\n-            }\n+        if (msg instanceof HttpResponse) {\n+            HttpHeaders headers = ((HttpResponse) msg).headers();\n \n-            promise.addListener(new ChannelFutureListener() {\n-                @Override\n-                public void operationComplete(ChannelFuture future) throws Exception {\n-                    if (future.isSuccess()) {\n-                        for (WebSocketServerExtension extension : validExtensions) {\n-                            WebSocketExtensionDecoder decoder = extension.newExtensionDecoder();\n-                            WebSocketExtensionEncoder encoder = extension.newExtensionEncoder();\n-                            ctx.pipeline().addAfter(ctx.name(), decoder.getClass().getName(), decoder);\n-                            ctx.pipeline().addAfter(ctx.name(), encoder.getClass().getName(), encoder);\n-                        }\n+            if (WebSocketExtensionUtil.isWebsocketUpgrade(headers)) {\n+\n+                if (validExtensions != null) {\n+                    String headerValue = headers.getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);\n+\n+                    for (WebSocketServerExtension extension : validExtensions) {\n+                        WebSocketExtensionData extensionData = extension.newReponseData();\n+                        headerValue = WebSocketExtensionUtil.appendExtension(headerValue,\n+                                                                             extensionData.name(),\n+                                                                             extensionData.parameters());\n                     }\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture future) {\n+                            if (future.isSuccess()) {\n+                                for (WebSocketServerExtension extension : validExtensions) {\n+                                    WebSocketExtensionDecoder decoder = extension.newExtensionDecoder();\n+                                    WebSocketExtensionEncoder encoder = extension.newExtensionEncoder();\n+                                    ctx.pipeline()\n+                                       .addAfter(ctx.name(), decoder.getClass().getName(), decoder)\n+                                       .addAfter(ctx.name(), encoder.getClass().getName(), encoder);\n+                                }\n+                            }\n+                        }\n+                    });\n \n-                    ctx.pipeline().remove(ctx.name());\n+                    if (headerValue != null) {\n+                        headers.set(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS, headerValue);\n+                    }\n                 }\n-            });\n \n-            if (headerValue != null) {\n-                response.headers().set(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS, headerValue);\n+                promise.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture future) {\n+                        if (future.isSuccess()) {\n+                            ctx.pipeline().remove(ctx.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1479c2e369864bbd6c5c171810a4599dd66178b7"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM1Mzc4NA==", "bodyText": "done", "url": "https://github.com/netty/netty/pull/9940#discussion_r366353784", "createdAt": "2020-01-14T14:02:19Z", "author": {"login": "amizurov"}, "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandler.java", "diffHunk": "@@ -103,35 +103,48 @@ public void channelRead(ChannelHandlerContext ctx, Object msg)\n \n     @Override\n     public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n-        if (msg instanceof HttpResponse &&\n-                WebSocketExtensionUtil.isWebsocketUpgrade(((HttpResponse) msg).headers()) && validExtensions != null) {\n-            HttpResponse response = (HttpResponse) msg;\n-            String headerValue = response.headers().getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);\n-\n-            for (WebSocketServerExtension extension : validExtensions) {\n-                WebSocketExtensionData extensionData = extension.newReponseData();\n-                headerValue = WebSocketExtensionUtil.appendExtension(headerValue,\n-                        extensionData.name(), extensionData.parameters());\n-            }\n+        if (msg instanceof HttpResponse) {\n+            HttpHeaders headers = ((HttpResponse) msg).headers();\n \n-            promise.addListener(new ChannelFutureListener() {\n-                @Override\n-                public void operationComplete(ChannelFuture future) throws Exception {\n-                    if (future.isSuccess()) {\n-                        for (WebSocketServerExtension extension : validExtensions) {\n-                            WebSocketExtensionDecoder decoder = extension.newExtensionDecoder();\n-                            WebSocketExtensionEncoder encoder = extension.newExtensionEncoder();\n-                            ctx.pipeline().addAfter(ctx.name(), decoder.getClass().getName(), decoder);\n-                            ctx.pipeline().addAfter(ctx.name(), encoder.getClass().getName(), encoder);\n-                        }\n+            if (WebSocketExtensionUtil.isWebsocketUpgrade(headers)) {\n+\n+                if (validExtensions != null) {\n+                    String headerValue = headers.getAsString(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS);\n+\n+                    for (WebSocketServerExtension extension : validExtensions) {\n+                        WebSocketExtensionData extensionData = extension.newReponseData();\n+                        headerValue = WebSocketExtensionUtil.appendExtension(headerValue,\n+                                                                             extensionData.name(),\n+                                                                             extensionData.parameters());\n                     }\n+                    promise.addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture future) {\n+                            if (future.isSuccess()) {\n+                                for (WebSocketServerExtension extension : validExtensions) {\n+                                    WebSocketExtensionDecoder decoder = extension.newExtensionDecoder();\n+                                    WebSocketExtensionEncoder encoder = extension.newExtensionEncoder();\n+                                    ctx.pipeline()\n+                                       .addAfter(ctx.name(), decoder.getClass().getName(), decoder)\n+                                       .addAfter(ctx.name(), encoder.getClass().getName(), encoder);\n+                                }\n+                            }\n+                        }\n+                    });\n \n-                    ctx.pipeline().remove(ctx.name());\n+                    if (headerValue != null) {\n+                        headers.set(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS, headerValue);\n+                    }\n                 }\n-            });\n \n-            if (headerValue != null) {\n-                response.headers().set(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS, headerValue);\n+                promise.addListener(new ChannelFutureListener() {\n+                    @Override\n+                    public void operationComplete(ChannelFuture future) {\n+                        if (future.isSuccess()) {\n+                            ctx.pipeline().remove(ctx.name());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI1ODE1OQ=="}, "originalCommit": {"oid": "1479c2e369864bbd6c5c171810a4599dd66178b7"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MjgxMDI0OnYy", "diffSide": "RIGHT", "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandlerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxMDoyNTo1N1rOFdSqLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNDowMjoyNlrOFdYdpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI1ODczMg==", "bodyText": "call ch.finish() and assert return value.", "url": "https://github.com/netty/netty/pull/9940#discussion_r366258732", "createdAt": "2020-01-14T10:25:57Z", "author": {"login": "normanmaurer"}, "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandlerTest.java", "diffHunk": "@@ -190,4 +198,28 @@ public void testNoneExtensionMatchingSuccess() {\n         verify(fallbackHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher(\"unknown\"));\n         verify(fallbackHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher(\"unknown2\"));\n     }\n+\n+    @Test\n+    public void testExtensionHandlerNotRemovedByFailureWritePromise() {\n+        // initialize\n+        when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(\"main\")))\n+                .thenReturn(mainExtensionMock);\n+\n+        // execute\n+        WebSocketServerExtensionHandler extensionHandler =\n+                new WebSocketServerExtensionHandler(mainHandshakerMock);\n+        EmbeddedChannel ch = new EmbeddedChannel(extensionHandler);\n+\n+        HttpRequest req = newUpgradeRequest(\"unknown, unknown2\");\n+        ch.writeInbound(req);\n+\n+        HttpResponse res = newUpgradeResponse(null);\n+        ChannelPromise failurePromise = ch.newPromise();\n+        ch.writeOneOutbound(res, failurePromise);\n+        failurePromise.setFailure(new IOException(\"Cannot write response\"));\n+\n+        // test\n+        assertNull(ch.readOutbound());\n+        assertNotNull(ch.pipeline().context(extensionHandler));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1479c2e369864bbd6c5c171810a4599dd66178b7"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM1MzgzMA==", "bodyText": "done", "url": "https://github.com/netty/netty/pull/9940#discussion_r366353830", "createdAt": "2020-01-14T14:02:26Z", "author": {"login": "amizurov"}, "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtensionHandlerTest.java", "diffHunk": "@@ -190,4 +198,28 @@ public void testNoneExtensionMatchingSuccess() {\n         verify(fallbackHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher(\"unknown\"));\n         verify(fallbackHandshakerMock).handshakeExtension(webSocketExtensionDataMatcher(\"unknown2\"));\n     }\n+\n+    @Test\n+    public void testExtensionHandlerNotRemovedByFailureWritePromise() {\n+        // initialize\n+        when(mainHandshakerMock.handshakeExtension(webSocketExtensionDataMatcher(\"main\")))\n+                .thenReturn(mainExtensionMock);\n+\n+        // execute\n+        WebSocketServerExtensionHandler extensionHandler =\n+                new WebSocketServerExtensionHandler(mainHandshakerMock);\n+        EmbeddedChannel ch = new EmbeddedChannel(extensionHandler);\n+\n+        HttpRequest req = newUpgradeRequest(\"unknown, unknown2\");\n+        ch.writeInbound(req);\n+\n+        HttpResponse res = newUpgradeResponse(null);\n+        ChannelPromise failurePromise = ch.newPromise();\n+        ch.writeOneOutbound(res, failurePromise);\n+        failurePromise.setFailure(new IOException(\"Cannot write response\"));\n+\n+        // test\n+        assertNull(ch.readOutbound());\n+        assertNotNull(ch.pipeline().context(extensionHandler));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI1ODczMg=="}, "originalCommit": {"oid": "1479c2e369864bbd6c5c171810a4599dd66178b7"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3526, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}