{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxMDk2NjM4", "number": 10492, "title": "Binary search based IpSubnetFilter", "bodyText": "Motivation:\nIpSubnetFilter uses Binary Search for IP Address search which is fast if we have large set of IP addresses to filter.\nModification:\nAdded IpSubnetFilter which takes IpSubnetFilterRule for filtering.\nResult:\nFaster IP address filter.", "createdAt": "2020-08-20T17:14:54Z", "url": "https://github.com/netty/netty/pull/10492", "merged": true, "mergeCommit": {"oid": "5d27a3d0bbf763ec49d2e08893f20d37d78b1195"}, "closed": true, "closedAt": "2020-09-01T09:07:52Z", "author": {"login": "hyperxpro"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAzbGwAH2gAyNDcxMDk2NjM4OmM0NzY1MDUxY2IwOTkyZjFlZjkyNWJlZjA5NTg5OGU3NTIyMzYzNWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdEg77SgH2gAyNDcxMDk2NjM4OjNmODRlNjQyZGM3ZGY4Yjc3MDA0YWFlZjQ5NTI2MDJkODRlZTk5YmM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/c4765051cb0992f1ef925bef095898e75223635d", "committedDate": "2020-08-20T17:12:00Z", "message": "Binary search based IpSubnetFilter for filtering IP addresses"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxODUwNDIw", "url": "https://github.com/netty/netty/pull/10492#pullrequestreview-471850420", "createdAt": "2020-08-20T17:50:59Z", "commit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzo1MDo1OVrOHEM31A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzo1MDo1OVrOHEM31A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NzI1Mg==", "bodyText": "We should consider adding IpSubnetFilterRuleComparator.INSTANCE, mark the constructor private and reuse the same instance everywhere", "url": "https://github.com/netty/netty/pull/10492#discussion_r474167252", "createdAt": "2020-08-20T17:50:59Z", "author": {"login": "normanmaurer"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxODQ1ODM2", "url": "https://github.com/netty/netty/pull/10492#pullrequestreview-471845836", "createdAt": "2020-08-20T17:44:35Z", "commit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzo0NDozNVrOHEMqEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxODowNjo0NlrOHENZsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzcyOQ==", "bodyText": "The rules are all Comparable, so we don't need the comparator, no?", "url": "https://github.com/netty/netty/pull/10492#discussion_r474163729", "createdAt": "2020-08-20T17:44:35Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NDI3NQ==", "bodyText": "Same here.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474164275", "createdAt": "2020-08-20T17:45:34Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3NTI2NQ==", "bodyText": "This is a rather strange comparator, that skimps on the reciprocity rule, and only kind of makes sense in this narrow use case. And then it also relies on the implementation details of Collections.binarySearch a bit. It's also not clear if it actually works as intended. I'd rather see a bespoke and well tested implementation of binary search as a helper method for IpSubnetFilter.accept, that incorporates the special comparison logic.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474175265", "createdAt": "2020-08-20T18:05:34Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRuleComparator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Comparator;\n+\n+final class IpSubnetFilterRuleComparator implements Comparator<Object> {\n+\n+    @Override\n+    public int compare(Object o1, Object o2) {\n+        if (o1 instanceof IpSubnetFilterRule) {\n+            if (o2 instanceof IpSubnetFilterRule) {\n+                return ((IpSubnetFilterRule) o1).compareTo((IpSubnetFilterRule) o2);\n+            } else if (o2 instanceof InetSocketAddress) {\n+                return ((IpSubnetFilterRule) o1).matches((InetSocketAddress) o2) ? 0 : -1;\n+            }\n+        }\n+        return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3NTkyMw==", "bodyText": "I wonder if we can implement a comparison without needing to keep this around, or if that adds too much overhead.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474175923", "createdAt": "2020-08-20T18:06:46Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,20 +68,35 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule o) {\n+        return getNetworkAddress().compareTo(o.getNetworkAddress());\n+    }\n+\n+    private BigInteger getNetworkAddress() {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return ((Ip4SubnetFilterRule) filterRule).networkAddressAsBigInteger;\n+        } else {\n+            return ((Ip6SubnetFilterRule) filterRule).networkAddress;\n+        }\n+    }\n+\n     private static final class Ip4SubnetFilterRule implements IpFilterRule {\n \n+        private final BigInteger networkAddressAsBigInteger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aecd97ed9541b5a8c7cbe7bd1866af628713b320", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/aecd97ed9541b5a8c7cbe7bd1866af628713b320", "committedDate": "2020-08-21T14:13:16Z", "message": "Fix comparator for effective search and added unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9210a7ad6db8a416a0271c37f28c12483957458", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/e9210a7ad6db8a416a0271c37f28c12483957458", "committedDate": "2020-08-22T06:10:35Z", "message": "Remove overlapping subnets and fix compareTo(InetSocketAddress)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8cb172db9f80478a610489ea0745d8ebbfe9095", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/c8cb172db9f80478a610489ea0745d8ebbfe9095", "committedDate": "2020-08-22T09:22:15Z", "message": "Use compareTo for searching instead of `matches` because we're comparing Integer either way"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/7201409e7c6a607ea5be91a424133760d8efe266", "committedDate": "2020-08-22T11:16:40Z", "message": "Allow default action to be set if rule is not found"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTM2Njcz", "url": "https://github.com/netty/netty/pull/10492#pullrequestreview-472936673", "createdAt": "2020-08-22T16:26:59Z", "commit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyNjo1OVrOHFGNNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyNjo1OVrOHFGNNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg==", "bodyText": "Both Integer.valueOf should think to a different way to handle this saving the Integer allocation (by saving/caching an int somewhere?)\nSame few lines below", "url": "https://github.com/netty/netty/pull/10492#discussion_r475106612", "createdAt": "2020-08-22T16:26:59Z", "author": {"login": "franz1981"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMjM3MTQw", "url": "https://github.com/netty/netty/pull/10492#pullrequestreview-473237140", "createdAt": "2020-08-24T08:49:35Z", "commit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo0OTozNlrOHFaYFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo1Njo0NVrOHFaogQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzNzA3Nw==", "bodyText": "Please do another hasNext check, instead of relying on catching NoSuchElementException.", "url": "https://github.com/netty/netty/pull/10492#discussion_r475437077", "createdAt": "2020-08-24T08:49:36Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MDcyMg==", "bodyText": "Instead of collecting a list of things to remove (or removing via Iterator.remove()), you can instead build up a new list of things you want to keep. This algorithm would be linear in time, instead of N*M from removeAll. You can then do the null-checking at the same time. Make this method take the list-to-be-filtered as a parameter, and return the new filtered list. Then you can do all of this at the this.rules field assignment.", "url": "https://github.com/netty/netty/pull/10492#discussion_r475440722", "createdAt": "2020-08-24T08:55:50Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }\n+\n+                // Take one more element out of Iterator, this will be childRule.\n+                IpSubnetFilterRule childRule = iterator.next();\n+\n+                // If parentRule matches childRule, schedule that Rule for deletion.\n+                if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                    toRemove.add(childRule);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MTI4MQ==", "bodyText": "If you follow my comment above, this part would also go away.", "url": "https://github.com/netty/netty/pull/10492#discussion_r475441281", "createdAt": "2020-08-24T08:56:45Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }\n+\n+                // Take one more element out of Iterator, this will be childRule.\n+                IpSubnetFilterRule childRule = iterator.next();\n+\n+                // If parentRule matches childRule, schedule that Rule for deletion.\n+                if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                    toRemove.add(childRule);\n+                } else {\n+                    // If parentRule does not matches childRule, this childRule will become new parentRule\n+                    // and we'll do the same again\n+                    parentRule = childRule;\n+                }\n+            }\n+        } catch (NoSuchElementException ex) {\n+            // Ignore\n+        }\n+\n+        rules.removeAll(toRemove);\n+        toRemove.clear();\n+        Collections.sort(rules); // Re-sort just to be sure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 148}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54e4167363a8416c37ca6fadc2b0949903e5534c", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/54e4167363a8416c37ca6fadc2b0949903e5534c", "committedDate": "2020-08-25T14:34:39Z", "message": "Filter without calling `List#get(int)` when all rules are of same type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6a5bbef34072fa12f0111fce8d0c86261e519cb", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/d6a5bbef34072fa12f0111fce8d0c86261e519cb", "committedDate": "2020-08-25T14:36:24Z", "message": "dont depend on `NoSuchElementException`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76373ff2a83001e977cfe9d20cc7ce27b2eceb16", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/76373ff2a83001e977cfe9d20cc7ce27b2eceb16", "committedDate": "2020-08-25T18:18:03Z", "message": "use compareInt(int, int) to compare integer`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "295e104c7ed9027584927777073ae9f2f81cc2df", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/295e104c7ed9027584927777073ae9f2f81cc2df", "committedDate": "2020-08-25T18:20:37Z", "message": "make compareInt(int, int) private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4aee1e4663f3d54386e4dccb5eb863d1b409f7b", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/a4aee1e4663f3d54386e4dccb5eb863d1b409f7b", "committedDate": "2020-08-26T11:11:22Z", "message": "use patch by @chrisvest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/ea2eea00724c226f95230a161537e0f64e94d79a", "committedDate": "2020-08-26T15:01:51Z", "message": "some minor fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NjEzMTQ4", "url": "https://github.com/netty/netty/pull/10492#pullrequestreview-475613148", "createdAt": "2020-08-26T15:36:19Z", "commit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTozNjoxOVrOHHR8bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTo0ODozMlrOHHSfdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM5NjA3Nw==", "bodyText": "We don't need to explicitly clear this list. The GC will take care of it.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477396077", "createdAt": "2020-08-26T15:36:19Z", "author": {"login": "chrisvest"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -141,6 +144,52 @@ public void testUniqueIpFilterHandler() {\n         Assert.assertTrue(ch4.isActive());\n     }\n \n+    @Test\n+    public void testBinarySearch() {\n+        List<IpSubnetFilterRule> ipSubnetFilterRuleList = new ArrayList<IpSubnetFilterRule>();\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.2.3.4\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.1.1.1\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));\n+\n+        // 1.0.0.0/8\n+        EmbeddedChannel ch1 = newEmbeddedInetChannel(\"1.1.1.1\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertFalse(ch1.isActive());\n+        Assert.assertTrue(ch1.close().isSuccess());\n+\n+        // Nothing applies here\n+        EmbeddedChannel ch2 = newEmbeddedInetChannel(\"2.2.2.2\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertTrue(ch2.isActive());\n+        Assert.assertTrue(ch2.close().isSuccess());\n+\n+        // 108.0.0.0/4\n+        EmbeddedChannel ch3 = newEmbeddedInetChannel(\"97.100.100.100\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertFalse(ch3.isActive());\n+        Assert.assertTrue(ch3.close().isSuccess());\n+\n+        // 200.200.200.200/32\n+        EmbeddedChannel ch4 = newEmbeddedInetChannel(\"200.200.200.200\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertFalse(ch4.isActive());\n+        Assert.assertTrue(ch4.close().isSuccess());\n+\n+        // Nothing applies here\n+        EmbeddedChannel ch5 = newEmbeddedInetChannel(\"127.0.0.1\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertTrue(ch5.isActive());\n+        Assert.assertTrue(ch5.close().isSuccess());\n+\n+        // 10.0.0.0/8\n+        EmbeddedChannel ch6 = newEmbeddedInetChannel(\"10.1.1.2\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertFalse(ch6.isActive());\n+        Assert.assertTrue(ch6.close().isSuccess());\n+\n+        ipSubnetFilterRuleList.clear(); // Because we're done with the list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM5NzQ0OQ==", "bodyText": "Would be good to also test IPv6, including testing with rule lists that is a mix of IPv4 and IPv6, and have them match on both IPv4 and IPv6 addresses.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477397449", "createdAt": "2020-08-26T15:38:11Z", "author": {"login": "chrisvest"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -141,6 +144,52 @@ public void testUniqueIpFilterHandler() {\n         Assert.assertTrue(ch4.isActive());\n     }\n \n+    @Test\n+    public void testBinarySearch() {\n+        List<IpSubnetFilterRule> ipSubnetFilterRuleList = new ArrayList<IpSubnetFilterRule>();\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.2.3.4\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.1.1.1\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwMjEzOQ==", "bodyText": "I don't think this clear() is necessary. GC should take care of it.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477402139", "createdAt": "2020-08-26T15:44:30Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+    private final IpFilterRuleType ipFilterRuleType;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        int numAccept = 0;\n+        int numReject = 0;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            if (ipSubnetFilterRule.ruleType() == IpFilterRuleType.ACCEPT) {\n+                numAccept++;\n+            } else {\n+                numReject++;\n+            }\n+        }\n+\n+        /*\n+         * If Number of accept rules are 0 and Number of reject rules is more than 0,\n+         * then all rules are of \"REJECT\" type.\n+         *\n+         * In this case, we'll set `ipFilterRuleType` to `IpFilterRuleType.REJECT`\n+         *\n+         * If Number of accept rules are more than 0 and number of reject rules are 0,\n+         * then all rules are of \"ACCEPT\" type.\n+         *\n+         */\n+        if (numAccept == 0 && numReject > 0) {\n+            ipFilterRuleType = IpFilterRuleType.REJECT;\n+        } else if (numAccept > 0 && numReject == 0) {\n+            ipFilterRuleType = IpFilterRuleType.ACCEPT;\n+        } else {\n+            ipFilterRuleType = null;\n+        }\n+\n+        this.rules = sortAndFilter(rules);\n+        rules.clear(); // Free-up old unsorted list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwMjU2OA==", "bodyText": "this is unnecessary.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477402568", "createdAt": "2020-08-26T15:45:01Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+    private final IpFilterRuleType ipFilterRuleType;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        int numAccept = 0;\n+        int numReject = 0;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            if (ipSubnetFilterRule.ruleType() == IpFilterRuleType.ACCEPT) {\n+                numAccept++;\n+            } else {\n+                numReject++;\n+            }\n+        }\n+\n+        /*\n+         * If Number of accept rules are 0 and Number of reject rules is more than 0,\n+         * then all rules are of \"REJECT\" type.\n+         *\n+         * In this case, we'll set `ipFilterRuleType` to `IpFilterRuleType.REJECT`\n+         *\n+         * If Number of accept rules are more than 0 and number of reject rules are 0,\n+         * then all rules are of \"ACCEPT\" type.\n+         *\n+         */\n+        if (numAccept == 0 && numReject > 0) {\n+            ipFilterRuleType = IpFilterRuleType.REJECT;\n+        } else if (numAccept > 0 && numReject == 0) {\n+            ipFilterRuleType = IpFilterRuleType.ACCEPT;\n+        } else {\n+            ipFilterRuleType = null;\n+        }\n+\n+        this.rules = sortAndFilter(rules);\n+        rules.clear(); // Free-up old unsorted list\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwMjg4OQ==", "bodyText": "this is unnecessary.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477402889", "createdAt": "2020-08-26T15:45:25Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+    private final IpFilterRuleType ipFilterRuleType;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        int numAccept = 0;\n+        int numReject = 0;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            if (ipSubnetFilterRule.ruleType() == IpFilterRuleType.ACCEPT) {\n+                numAccept++;\n+            } else {\n+                numReject++;\n+            }\n+        }\n+\n+        /*\n+         * If Number of accept rules are 0 and Number of reject rules is more than 0,\n+         * then all rules are of \"REJECT\" type.\n+         *\n+         * In this case, we'll set `ipFilterRuleType` to `IpFilterRuleType.REJECT`\n+         *\n+         * If Number of accept rules are more than 0 and number of reject rules are 0,\n+         * then all rules are of \"ACCEPT\" type.\n+         *\n+         */\n+        if (numAccept == 0 && numReject > 0) {\n+            ipFilterRuleType = IpFilterRuleType.REJECT;\n+        } else if (numAccept > 0 && numReject == 0) {\n+            ipFilterRuleType = IpFilterRuleType.ACCEPT;\n+        } else {\n+            ipFilterRuleType = null;\n+        }\n+\n+        this.rules = sortAndFilter(rules);\n+        rules.clear(); // Free-up old unsorted list\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            if (ipFilterRuleType == null) {\n+                return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwMzAzNQ==", "bodyText": "this is unnecessary.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477403035", "createdAt": "2020-08-26T15:45:38Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+    private final IpFilterRuleType ipFilterRuleType;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        int numAccept = 0;\n+        int numReject = 0;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            if (ipSubnetFilterRule.ruleType() == IpFilterRuleType.ACCEPT) {\n+                numAccept++;\n+            } else {\n+                numReject++;\n+            }\n+        }\n+\n+        /*\n+         * If Number of accept rules are 0 and Number of reject rules is more than 0,\n+         * then all rules are of \"REJECT\" type.\n+         *\n+         * In this case, we'll set `ipFilterRuleType` to `IpFilterRuleType.REJECT`\n+         *\n+         * If Number of accept rules are more than 0 and number of reject rules are 0,\n+         * then all rules are of \"ACCEPT\" type.\n+         *\n+         */\n+        if (numAccept == 0 && numReject > 0) {\n+            ipFilterRuleType = IpFilterRuleType.REJECT;\n+        } else if (numAccept > 0 && numReject == 0) {\n+            ipFilterRuleType = IpFilterRuleType.ACCEPT;\n+        } else {\n+            ipFilterRuleType = null;\n+        }\n+\n+        this.rules = sortAndFilter(rules);\n+        rules.clear(); // Free-up old unsorted list\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            if (ipFilterRuleType == null) {\n+                return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+            } else {\n+                return this.ipFilterRuleType == IpFilterRuleType.ACCEPT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwNTA0NA==", "bodyText": "This should say AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress) for the javadoc reference to work.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477405044", "createdAt": "2020-08-26T15:48:32Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fbdc61d9affe88bbf1700e20d07cae23f19a495", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/4fbdc61d9affe88bbf1700e20d07cae23f19a495", "committedDate": "2020-08-26T17:32:59Z", "message": "check for mix of IPv4/6 rules"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1ODYyNDUw", "url": "https://github.com/netty/netty/pull/10492#pullrequestreview-475862450", "createdAt": "2020-08-26T21:11:52Z", "commit": {"oid": "4fbdc61d9affe88bbf1700e20d07cae23f19a495"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMToxMTo1MlrOHHd5ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMToxMTo1MlrOHHd5ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5MjAwMw==", "bodyText": "Mixed version IPs should be in a separate test, as otherwise this test will now fail because of the new exception thrown from the constructor, right?", "url": "https://github.com/netty/netty/pull/10492#discussion_r477592003", "createdAt": "2020-08-26T21:11:52Z", "author": {"login": "chrisvest"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -152,6 +152,7 @@ public void testBinarySearch() {\n         ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n         ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n         ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"2001:db8:abcd:0000::\", 52));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbdc61d9affe88bbf1700e20d07cae23f19a495"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4892321278c0e7858c795a1660873f52c85a0ed", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/d4892321278c0e7858c795a1660873f52c85a0ed", "committedDate": "2020-08-27T03:26:04Z", "message": "fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTIwNjg4", "url": "https://github.com/netty/netty/pull/10492#pullrequestreview-476520688", "createdAt": "2020-08-27T08:58:17Z", "commit": {"oid": "d4892321278c0e7858c795a1660873f52c85a0ed"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTIyNDE2", "url": "https://github.com/netty/netty/pull/10492#pullrequestreview-476522416", "createdAt": "2020-08-27T09:00:27Z", "commit": {"oid": "d4892321278c0e7858c795a1660873f52c85a0ed"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6be92eb047fbd10b81be1982ca1d872def8195a1", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/6be92eb047fbd10b81be1982ca1d872def8195a1", "committedDate": "2020-08-27T10:05:20Z", "message": "add mixed ipv4 and ipv6 support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b003b068af00e7fe643bbfb46c56c74ddb343945", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/b003b068af00e7fe643bbfb46c56c74ddb343945", "committedDate": "2020-08-27T10:08:01Z", "message": "just a line fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3Njk5NTA0", "url": "https://github.com/netty/netty/pull/10492#pullrequestreview-477699504", "createdAt": "2020-08-28T12:48:51Z", "commit": {"oid": "b003b068af00e7fe643bbfb46c56c74ddb343945"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e25ed6dd78e09ab1ab7ddb17a815a555ecf4101c", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/e25ed6dd78e09ab1ab7ddb17a815a555ecf4101c", "committedDate": "2020-08-29T12:09:15Z", "message": "Just a line shift. No code change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a9eb062c8abe595bf08a4c041f7a22b5c4c0a4c", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/9a9eb062c8abe595bf08a4c041f7a22b5c4c0a4c", "committedDate": "2020-08-31T07:39:03Z", "message": "use NetUtils#ipv4AddressToInt(Inet4Address)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d51a76c7b1590c55b391b0e97777ec6a89f11dbb", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/d51a76c7b1590c55b391b0e97777ec6a89f11dbb", "committedDate": "2020-08-31T07:43:22Z", "message": "just line change. no code modified"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f84e642dc7df8b77004aaef4952602d84ee99bc", "author": {"user": {"login": "hyperxpro", "name": "Aayush Atharva"}}, "url": "https://github.com/netty/netty/commit/3f84e642dc7df8b77004aaef4952602d84ee99bc", "committedDate": "2020-09-01T05:55:21Z", "message": "Update JavaDoc. No code change."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4976, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}