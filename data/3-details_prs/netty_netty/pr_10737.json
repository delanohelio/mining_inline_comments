{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExMzYwMjc3", "number": 10737, "title": "Implement SWAR indexOf byte search", "bodyText": "Motivation:\nFaster indexOf\nModification:\nCreate generic SWAR indexOf that any ByteBuf implementation can use\nResult:\nFixes #10731", "createdAt": "2020-10-28T08:09:27Z", "url": "https://github.com/netty/netty/pull/10737", "merged": true, "mergeCommit": {"oid": "9a02832fdb10afbc09f144a462d604176fb11049"}, "closed": true, "closedAt": "2021-01-15T14:09:28Z", "author": {"login": "franz1981"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdW5LkwABqjM5Mjk5MjYyNTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdwZhBrAFqTU2OTI4OTYwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "129b8842b3621134d98aedbed95e96d83154397f", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/129b8842b3621134d98aedbed95e96d83154397f", "committedDate": "2020-10-28T08:07:58Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}, "afterCommit": {"oid": "808c7c594d99a9dab15280957407f5ba4a9a32e2", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/808c7c594d99a9dab15280957407f5ba4a9a32e2", "committedDate": "2020-10-28T08:20:36Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NDE1OTUy", "url": "https://github.com/netty/netty/pull/10737#pullrequestreview-518415952", "createdAt": "2020-10-28T08:23:33Z", "commit": {"oid": "808c7c594d99a9dab15280957407f5ba4a9a32e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoyMzozM1rOHpenAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoyMzozM1rOHpenAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NTE3MA==", "bodyText": "you can do this as long pattern = (byteToFind & 0xFFL) * 0x101010101010101L", "url": "https://github.com/netty/netty/pull/10737#discussion_r513255170", "createdAt": "2020-10-28T08:23:33Z", "author": {"login": "richardstartin"}, "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,6 +389,89 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static final long[] SEARCH_PATTERNS;\n+\n+        static {\n+            SEARCH_PATTERNS = new long[256];\n+            for (int i = 0; i < SEARCH_PATTERNS.length; ++i) {\n+                final byte b = (byte) (i - 128);\n+                SEARCH_PATTERNS[i] = compilePattern(b);\n+            }\n+        }\n+\n+        private static long compilePattern(byte byteToFind) {\n+            long pattern = byteToFind & 0xFFL;\n+            return pattern\n+                   | (pattern << 8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "808c7c594d99a9dab15280957407f5ba4a9a32e2"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NDE3NDky", "url": "https://github.com/netty/netty/pull/10737#pullrequestreview-518417492", "createdAt": "2020-10-28T08:25:41Z", "commit": {"oid": "808c7c594d99a9dab15280957407f5ba4a9a32e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoyNTo0MVrOHper4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoyNTo0MVrOHper4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NjQxOQ==", "bodyText": "Since you're doing a little endian check elsewhere, I would consider making little and big endian variants of this method, just because it makes it harder to mix and match", "url": "https://github.com/netty/netty/pull/10737#discussion_r513256419", "createdAt": "2020-10-28T08:25:41Z", "author": {"login": "richardstartin"}, "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,6 +389,89 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static final long[] SEARCH_PATTERNS;\n+\n+        static {\n+            SEARCH_PATTERNS = new long[256];\n+            for (int i = 0; i < SEARCH_PATTERNS.length; ++i) {\n+                final byte b = (byte) (i - 128);\n+                SEARCH_PATTERNS[i] = compilePattern(b);\n+            }\n+        }\n+\n+        private static long compilePattern(byte byteToFind) {\n+            long pattern = byteToFind & 0xFFL;\n+            return pattern\n+                   | (pattern << 8)\n+                   | (pattern << 16)\n+                   | (pattern << 24)\n+                   | (pattern << 32)\n+                   | (pattern << 40)\n+                   | (pattern << 48)\n+                   | (pattern << 56);\n+        }\n+\n+        private static long patternOf(byte b) {\n+            return SEARCH_PATTERNS[b + 128];\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, long pattern, boolean leading) {\n+            long tmp = (word & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | word | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "808c7c594d99a9dab15280957407f5ba4a9a32e2"}, "originalPosition": 44}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "808c7c594d99a9dab15280957407f5ba4a9a32e2", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/808c7c594d99a9dab15280957407f5ba4a9a32e2", "committedDate": "2020-10-28T08:20:36Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}, "afterCommit": {"oid": "35c1e254f9daf5d516ba40d4341788e8405ddf87", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/35c1e254f9daf5d516ba40d4341788e8405ddf87", "committedDate": "2020-10-28T08:25:34Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NDE4MjI3", "url": "https://github.com/netty/netty/pull/10737#pullrequestreview-518418227", "createdAt": "2020-10-28T08:26:36Z", "commit": {"oid": "808c7c594d99a9dab15280957407f5ba4a9a32e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoyNjo1NVrOHpeulw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwODoyNjo1NVrOHpeulw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NzExMQ==", "bodyText": "This is 2KB, but if you change this to the multiplication mentioned earlier, I don't see benefit from caching", "url": "https://github.com/netty/netty/pull/10737#discussion_r513257111", "createdAt": "2020-10-28T08:26:55Z", "author": {"login": "richardstartin"}, "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,6 +389,81 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static final long[] SEARCH_PATTERNS;\n+\n+        static {\n+            SEARCH_PATTERNS = new long[256];\n+            for (int i = 0; i < SEARCH_PATTERNS.length; ++i) {\n+                final byte b = (byte) (i - 128);\n+                SEARCH_PATTERNS[i] = compilePattern(b);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35c1e254f9daf5d516ba40d4341788e8405ddf87"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35c1e254f9daf5d516ba40d4341788e8405ddf87", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/35c1e254f9daf5d516ba40d4341788e8405ddf87", "committedDate": "2020-10-28T08:25:34Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}, "afterCommit": {"oid": "f09f5d56a5734fe7a9e941e8e28fb2487ff6403a", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/f09f5d56a5734fe7a9e941e8e28fb2487ff6403a", "committedDate": "2020-10-28T08:29:17Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f09f5d56a5734fe7a9e941e8e28fb2487ff6403a", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/f09f5d56a5734fe7a9e941e8e28fb2487ff6403a", "committedDate": "2020-10-28T08:29:17Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}, "afterCommit": {"oid": "cd47c9035f7bfbc60801dc061e8e6c728a696fab", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/cd47c9035f7bfbc60801dc061e8e6c728a696fab", "committedDate": "2020-10-28T11:30:29Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cd47c9035f7bfbc60801dc061e8e6c728a696fab", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/cd47c9035f7bfbc60801dc061e8e6c728a696fab", "committedDate": "2020-10-28T11:30:29Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}, "afterCommit": {"oid": "2ee1c68fa3da5a2252915d7f3b33e204d7555b6a", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/2ee1c68fa3da5a2252915d7f3b33e204d7555b6a", "committedDate": "2020-10-31T13:37:16Z", "message": "Move capacity() call to be a nearly monomorphic"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "39e4a2fd0c64508d64211cf6b57b43f7cc2ac908", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/39e4a2fd0c64508d64211cf6b57b43f7cc2ac908", "committedDate": "2020-11-01T08:08:26Z", "message": "Improved instanceof"}, "afterCommit": {"oid": "4582ff1209ef5f5091ec1af1116fddaacbabf06a", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/4582ff1209ef5f5091ec1af1116fddaacbabf06a", "committedDate": "2020-11-02T13:46:56Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4582ff1209ef5f5091ec1af1116fddaacbabf06a", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/4582ff1209ef5f5091ec1af1116fddaacbabf06a", "committedDate": "2020-11-02T13:46:56Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}, "afterCommit": {"oid": "6c949b582988cbf12a87f27bcadc64a101bd6c32", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/6c949b582988cbf12a87f27bcadc64a101bd6c32", "committedDate": "2020-11-02T13:50:44Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6c949b582988cbf12a87f27bcadc64a101bd6c32", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/6c949b582988cbf12a87f27bcadc64a101bd6c32", "committedDate": "2020-11-02T13:50:44Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}, "afterCommit": {"oid": "8f0e271210b9dfccef9435e81c60a89ced5cd94d", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/8f0e271210b9dfccef9435e81c60a89ced5cd94d", "committedDate": "2020-11-02T20:44:08Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MzY3NTAz", "url": "https://github.com/netty/netty/pull/10737#pullrequestreview-534367503", "createdAt": "2020-11-19T12:08:14Z", "commit": {"oid": "8f0e271210b9dfccef9435e81c60a89ced5cd94d"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjowODoxNFrOH2ae-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMjoyMzo0NlrOH2bWeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgxOTA2Ng==", "bodyText": "This method isn't used.", "url": "https://github.com/netty/netty/pull/10737#discussion_r526819066", "createdAt": "2020-11-19T12:08:14Z", "author": {"login": "chrisvest"}, "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static long compilePattern(byte byteToFind) {\n+            return (byteToFind & 0xFFL) * 0x101010101010101L;\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, boolean leading) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f0e271210b9dfccef9435e81c60a89ced5cd94d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyMTcxMA==", "bodyText": "Did you also try a small counted loop?", "url": "https://github.com/netty/netty/pull/10737#discussion_r526821710", "createdAt": "2020-11-19T12:10:12Z", "author": {"login": "chrisvest"}, "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static long compilePattern(byte byteToFind) {\n+            return (byteToFind & 0xFFL) * 0x101010101010101L;\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, boolean leading) {\n+            long tmp = (word & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | word | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+    }\n+\n+    private static int unrolledFirstIndexOf(AbstractByteBuf buffer, int fromIndex, int byteCount, byte value) {\n+        assert byteCount > 0 && byteCount < 8;\n+        if (buffer._getByte(fromIndex) == value) {\n+            return fromIndex;\n+        }\n+        if (byteCount == 1) {\n+            return -1;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f0e271210b9dfccef9435e81c60a89ced5cd94d"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyNTYzOA==", "bodyText": "I wonder if this class would make sense as a top-level ByteSearch class, and adopt more methods.", "url": "https://github.com/netty/netty/pull/10737#discussion_r526825638", "createdAt": "2020-11-19T12:13:17Z", "author": {"login": "chrisvest"}, "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f0e271210b9dfccef9435e81c60a89ced5cd94d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgyNzgyMA==", "bodyText": "Why would fromIndex ever be negative?", "url": "https://github.com/netty/netty/pull/10737#discussion_r526827820", "createdAt": "2020-11-19T12:15:00Z", "author": {"login": "chrisvest"}, "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static long compilePattern(byte byteToFind) {\n+            return (byteToFind & 0xFFL) * 0x101010101010101L;\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, boolean leading) {\n+            long tmp = (word & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | word | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+    }\n+\n+    private static int unrolledFirstIndexOf(AbstractByteBuf buffer, int fromIndex, int byteCount, byte value) {\n+        assert byteCount > 0 && byteCount < 8;\n+        if (buffer._getByte(fromIndex) == value) {\n+            return fromIndex;\n+        }\n+        if (byteCount == 1) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 1) == value) {\n+            return fromIndex + 1;\n+        }\n+        if (byteCount == 2) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 2) == value) {\n+            return fromIndex + 2;\n+        }\n+        if (byteCount == 3) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 3) == value) {\n+            return fromIndex + 3;\n+        }\n+        if (byteCount == 4) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 4) == value) {\n+            return fromIndex + 4;\n+        }\n+        if (byteCount == 5) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 5) == value) {\n+            return fromIndex + 5;\n+        }\n+        if (byteCount == 6) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 6) == value) {\n+            return fromIndex + 6;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * This is using a SWAR (SIMD Within A Register) batch read technique to minimize bound-checks and improve memory\n+     * usage while searching for {@code value}.\n+     */\n+    static int firstIndexOf(AbstractByteBuf buffer, int fromIndex, int toIndex, byte value) {\n+        fromIndex = Math.max(fromIndex, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f0e271210b9dfccef9435e81c60a89ced5cd94d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMjI5Nw==", "bodyText": "I suppose the first linearFirstIndexOf call for platforms that don't support unaligned access is because we have no idea what the underlying alignment of the buffer is. But do we need this unrolled call on platforms that do support unaligned access?", "url": "https://github.com/netty/netty/pull/10737#discussion_r526832297", "createdAt": "2020-11-19T12:22:06Z", "author": {"login": "chrisvest"}, "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static long compilePattern(byte byteToFind) {\n+            return (byteToFind & 0xFFL) * 0x101010101010101L;\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, boolean leading) {\n+            long tmp = (word & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | word | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+    }\n+\n+    private static int unrolledFirstIndexOf(AbstractByteBuf buffer, int fromIndex, int byteCount, byte value) {\n+        assert byteCount > 0 && byteCount < 8;\n+        if (buffer._getByte(fromIndex) == value) {\n+            return fromIndex;\n+        }\n+        if (byteCount == 1) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 1) == value) {\n+            return fromIndex + 1;\n+        }\n+        if (byteCount == 2) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 2) == value) {\n+            return fromIndex + 2;\n+        }\n+        if (byteCount == 3) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 3) == value) {\n+            return fromIndex + 3;\n+        }\n+        if (byteCount == 4) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 4) == value) {\n+            return fromIndex + 4;\n+        }\n+        if (byteCount == 5) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 5) == value) {\n+            return fromIndex + 5;\n+        }\n+        if (byteCount == 6) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 6) == value) {\n+            return fromIndex + 6;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * This is using a SWAR (SIMD Within A Register) batch read technique to minimize bound-checks and improve memory\n+     * usage while searching for {@code value}.\n+     */\n+    static int firstIndexOf(AbstractByteBuf buffer, int fromIndex, int toIndex, byte value) {\n+        fromIndex = Math.max(fromIndex, 0);\n+        if (fromIndex >= toIndex || buffer.capacity() == 0) {\n+            return -1;\n+        }\n+        final int length = toIndex - fromIndex;\n+        buffer.checkIndex(fromIndex, length);\n+        if (!PlatformDependent.isUnaligned()) {\n+            return linearFirstIndexOf(buffer, fromIndex, toIndex, value);\n+        }\n+        assert PlatformDependent.isUnaligned();\n+        int offset = fromIndex;\n+        final int byteCount = length & 7;\n+        if (byteCount > 0) {\n+            final int index = unrolledFirstIndexOf(buffer, fromIndex, byteCount, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f0e271210b9dfccef9435e81c60a89ced5cd94d"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMzI3Mw==", "bodyText": "Don't we need to handle a tail? Or is that what the initial unrolled call is for?", "url": "https://github.com/netty/netty/pull/10737#discussion_r526833273", "createdAt": "2020-11-19T12:23:46Z", "author": {"login": "chrisvest"}, "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -389,16 +389,132 @@ private static long compareUintBigEndianB(\n         return 0;\n     }\n \n+    private static final class SWARByteSearch {\n+\n+        private static long compilePattern(byte byteToFind) {\n+            return (byteToFind & 0xFFL) * 0x101010101010101L;\n+        }\n+\n+        private static int firstAnyPattern(long word, long pattern, boolean leading) {\n+            long input = word ^ pattern;\n+            long tmp = (input & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | input | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+\n+        // TODO: save using any pattern for the 0 search case, if we care\n+        private static int firstZeroByte(long word, boolean leading) {\n+            long tmp = (word & 0x7F7F7F7F7F7F7F7FL) + 0x7F7F7F7F7F7F7F7FL;\n+            tmp = ~(tmp | word | 0x7F7F7F7F7F7F7F7FL);\n+            final int binaryPosition = leading? Long.numberOfLeadingZeros(tmp) : Long.numberOfTrailingZeros(tmp);\n+            return binaryPosition >>> 3;\n+        }\n+    }\n+\n+    private static int unrolledFirstIndexOf(AbstractByteBuf buffer, int fromIndex, int byteCount, byte value) {\n+        assert byteCount > 0 && byteCount < 8;\n+        if (buffer._getByte(fromIndex) == value) {\n+            return fromIndex;\n+        }\n+        if (byteCount == 1) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 1) == value) {\n+            return fromIndex + 1;\n+        }\n+        if (byteCount == 2) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 2) == value) {\n+            return fromIndex + 2;\n+        }\n+        if (byteCount == 3) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 3) == value) {\n+            return fromIndex + 3;\n+        }\n+        if (byteCount == 4) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 4) == value) {\n+            return fromIndex + 4;\n+        }\n+        if (byteCount == 5) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 5) == value) {\n+            return fromIndex + 5;\n+        }\n+        if (byteCount == 6) {\n+            return -1;\n+        }\n+        if (buffer._getByte(fromIndex + 6) == value) {\n+            return fromIndex + 6;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * This is using a SWAR (SIMD Within A Register) batch read technique to minimize bound-checks and improve memory\n+     * usage while searching for {@code value}.\n+     */\n+    static int firstIndexOf(AbstractByteBuf buffer, int fromIndex, int toIndex, byte value) {\n+        fromIndex = Math.max(fromIndex, 0);\n+        if (fromIndex >= toIndex || buffer.capacity() == 0) {\n+            return -1;\n+        }\n+        final int length = toIndex - fromIndex;\n+        buffer.checkIndex(fromIndex, length);\n+        if (!PlatformDependent.isUnaligned()) {\n+            return linearFirstIndexOf(buffer, fromIndex, toIndex, value);\n+        }\n+        assert PlatformDependent.isUnaligned();\n+        int offset = fromIndex;\n+        final int byteCount = length & 7;\n+        if (byteCount > 0) {\n+            final int index = unrolledFirstIndexOf(buffer, fromIndex, byteCount, value);\n+            if (index != -1) {\n+                return index;\n+            }\n+            offset += byteCount;\n+            if (offset == toIndex) {\n+                return -1;\n+            }\n+        }\n+        final int longCount = length >>> 3;\n+        final ByteOrder nativeOrder = ByteOrder.nativeOrder();\n+        final boolean isNative = nativeOrder == buffer.order();\n+        final boolean useLE = nativeOrder == ByteOrder.LITTLE_ENDIAN;\n+        final long pattern = SWARByteSearch.compilePattern(value);\n+        for (int i = 0; i < longCount; i++) {\n+            // use the faster available getLong\n+            final long word = useLE? buffer._getLongLE(offset) : buffer._getLong(offset);\n+            int index = SWARByteSearch.firstAnyPattern(word, pattern, isNative);\n+            if (index < Long.BYTES) {\n+                return offset + index;\n+            }\n+            offset += Long.BYTES;\n+        }\n+        return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f0e271210b9dfccef9435e81c60a89ced5cd94d"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "330347cb56874daf6be077d588bf6d2d3e70868e", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/330347cb56874daf6be077d588bf6d2d3e70868e", "committedDate": "2020-12-09T09:26:07Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f0e271210b9dfccef9435e81c60a89ced5cd94d", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/8f0e271210b9dfccef9435e81c60a89ced5cd94d", "committedDate": "2020-11-02T20:44:08Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}, "afterCommit": {"oid": "330347cb56874daf6be077d588bf6d2d3e70868e", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/330347cb56874daf6be077d588bf6d2d3e70868e", "committedDate": "2020-12-09T09:26:07Z", "message": "Implement SWAR indexOf byte search\n\nMotivation:\n\nFaster indexOf\n\nModification:\n\nCreate generic SWAR indexOf that any ByteBuf implementation can use\n\nResult:\n\nFixes #10731"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5MjEzNzE0", "url": "https://github.com/netty/netty/pull/10737#pullrequestreview-569213714", "createdAt": "2021-01-15T12:23:28Z", "commit": {"oid": "330347cb56874daf6be077d588bf6d2d3e70868e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5Mjg5NjA3", "url": "https://github.com/netty/netty/pull/10737#pullrequestreview-569289607", "createdAt": "2021-01-15T14:09:18Z", "commit": {"oid": "330347cb56874daf6be077d588bf6d2d3e70868e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4954, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}