{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3ODg2NzM0", "number": 10294, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo1Mjo0MVrOD8cbmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTo0NDo1NVrOD8icjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzA2OTY4OnYy", "diffSide": "RIGHT", "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMTo1Mjo0MVrOGVYs1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMjoyOToxN1rOGVZ52g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzk3Mw==", "bodyText": "If you suppose that\n\"while the queue is drained we may notify the promise which may add again buffers to the queue\", the fix seems not correct enough.\nThrere is raise condition between incrementReadableBytes\nint nextReadableBytes = readableBytes + increment;\n...\nreadableBytes = nextReadableBytes;\n\nand decrementReadableBytes\nreadableBytes -= decrement;\nSeems to me #readableBytes should be AtomicInteger.\nassert readableBytes == 0; // looks cool", "url": "https://github.com/netty/netty/pull/10294#discussion_r425077973", "createdAt": "2020-05-14T11:52:41Z", "author": {"login": "progulin"}, "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "diffHunk": "@@ -221,28 +222,31 @@ public final void copyTo(AbstractCoalescingBufferQueue dest) {\n      * @param ctx The context to write all elements to.\n      */\n     public final void writeAndRemoveAll(ChannelHandlerContext ctx) {\n-        decrementReadableBytes(readableBytes);\n         Throwable pending = null;\n         ByteBuf previousBuf = null;\n         for (;;) {\n             Object entry = bufAndListenerPairs.poll();\n             try {\n                 if (entry == null) {\n                     if (previousBuf != null) {\n+                        decrementReadableBytes(previousBuf.readableBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "462dbb87b3552bfa143c992a305ee122a7aa5f1e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3OTAzMQ==", "bodyText": "@progulin maybe I am missing something but this is only meant to be used by a single thread. What race you are talking about ?", "url": "https://github.com/netty/netty/pull/10294#discussion_r425079031", "createdAt": "2020-05-14T11:54:52Z", "author": {"login": "normanmaurer"}, "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "diffHunk": "@@ -221,28 +222,31 @@ public final void copyTo(AbstractCoalescingBufferQueue dest) {\n      * @param ctx The context to write all elements to.\n      */\n     public final void writeAndRemoveAll(ChannelHandlerContext ctx) {\n-        decrementReadableBytes(readableBytes);\n         Throwable pending = null;\n         ByteBuf previousBuf = null;\n         for (;;) {\n             Object entry = bufAndListenerPairs.poll();\n             try {\n                 if (entry == null) {\n                     if (previousBuf != null) {\n+                        decrementReadableBytes(previousBuf.readableBytes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzk3Mw=="}, "originalCommit": {"oid": "462dbb87b3552bfa143c992a305ee122a7aa5f1e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA4NzMwNQ==", "bodyText": "I supposed writeAndRemoveAll/releaseAndCompleteAll is one thread and another which does add/addFirst.\nIf single thread is used, there is no sence to duplicate decrementReadableBytes() calls.\nUnpached version set readableBytes to zero decrementReadableBytes(readableBytes); and clear queue into cycle for (;;). The same does patched.", "url": "https://github.com/netty/netty/pull/10294#discussion_r425087305", "createdAt": "2020-05-14T12:10:48Z", "author": {"login": "progulin"}, "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "diffHunk": "@@ -221,28 +222,31 @@ public final void copyTo(AbstractCoalescingBufferQueue dest) {\n      * @param ctx The context to write all elements to.\n      */\n     public final void writeAndRemoveAll(ChannelHandlerContext ctx) {\n-        decrementReadableBytes(readableBytes);\n         Throwable pending = null;\n         ByteBuf previousBuf = null;\n         for (;;) {\n             Object entry = bufAndListenerPairs.poll();\n             try {\n                 if (entry == null) {\n                     if (previousBuf != null) {\n+                        decrementReadableBytes(previousBuf.readableBytes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzk3Mw=="}, "originalCommit": {"oid": "462dbb87b3552bfa143c992a305ee122a7aa5f1e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA5MTU3MQ==", "bodyText": "@progulin yes all is the single threaded... Sorry I have no idea what you are talking about. The problem is the promise may be notified and so the ChannelFutureListener may call add(...) while we are in the for loop. All of this is in the same thread. Just run the unit test with the unpatched version and you will see it fails.", "url": "https://github.com/netty/netty/pull/10294#discussion_r425091571", "createdAt": "2020-05-14T12:18:24Z", "author": {"login": "normanmaurer"}, "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "diffHunk": "@@ -221,28 +222,31 @@ public final void copyTo(AbstractCoalescingBufferQueue dest) {\n      * @param ctx The context to write all elements to.\n      */\n     public final void writeAndRemoveAll(ChannelHandlerContext ctx) {\n-        decrementReadableBytes(readableBytes);\n         Throwable pending = null;\n         ByteBuf previousBuf = null;\n         for (;;) {\n             Object entry = bufAndListenerPairs.poll();\n             try {\n                 if (entry == null) {\n                     if (previousBuf != null) {\n+                        decrementReadableBytes(previousBuf.readableBytes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzk3Mw=="}, "originalCommit": {"oid": "462dbb87b3552bfa143c992a305ee122a7aa5f1e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA5NzY5MA==", "bodyText": "ChannelFutureListener may call add(...)\n\nUgu! Now I see. Thank you. Great patch.", "url": "https://github.com/netty/netty/pull/10294#discussion_r425097690", "createdAt": "2020-05-14T12:29:17Z", "author": {"login": "progulin"}, "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "diffHunk": "@@ -221,28 +222,31 @@ public final void copyTo(AbstractCoalescingBufferQueue dest) {\n      * @param ctx The context to write all elements to.\n      */\n     public final void writeAndRemoveAll(ChannelHandlerContext ctx) {\n-        decrementReadableBytes(readableBytes);\n         Throwable pending = null;\n         ByteBuf previousBuf = null;\n         for (;;) {\n             Object entry = bufAndListenerPairs.poll();\n             try {\n                 if (entry == null) {\n                     if (previousBuf != null) {\n+                        decrementReadableBytes(previousBuf.readableBytes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzk3Mw=="}, "originalCommit": {"oid": "462dbb87b3552bfa143c992a305ee122a7aa5f1e"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODA1NTE5OnYy", "diffSide": "RIGHT", "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTo0NDo1NVrOGViiMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzoxODowMFrOGV5Riw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzOTA4OQ==", "bodyText": "consider just doing buffer.release() now that you have the cast, this code is in a try/catch and will ensure all elements are drained.", "url": "https://github.com/netty/netty/pull/10294#discussion_r425239089", "createdAt": "2020-05-14T15:44:55Z", "author": {"login": "Scottmitch"}, "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "diffHunk": "@@ -335,7 +338,9 @@ private void releaseAndCompleteAll(ChannelFuture future) {\n             }\n             try {\n                 if (entry instanceof ByteBuf) {\n-                    safeRelease(entry);\n+                    ByteBuf buffer = (ByteBuf) entry;\n+                    decrementReadableBytes(buffer.readableBytes());\n+                    safeRelease(buffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "462dbb87b3552bfa143c992a305ee122a7aa5f1e"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYxMTY1OQ==", "bodyText": "let's just keep it as it is for now to keep the changes to a minimum", "url": "https://github.com/netty/netty/pull/10294#discussion_r425611659", "createdAt": "2020-05-15T07:18:00Z", "author": {"login": "normanmaurer"}, "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "diffHunk": "@@ -335,7 +338,9 @@ private void releaseAndCompleteAll(ChannelFuture future) {\n             }\n             try {\n                 if (entry instanceof ByteBuf) {\n-                    safeRelease(entry);\n+                    ByteBuf buffer = (ByteBuf) entry;\n+                    decrementReadableBytes(buffer.readableBytes());\n+                    safeRelease(buffer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzOTA4OQ=="}, "originalCommit": {"oid": "462dbb87b3552bfa143c992a305ee122a7aa5f1e"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3454, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}