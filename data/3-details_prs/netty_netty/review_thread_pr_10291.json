{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3ODQwOTE0", "number": 10291, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowMToxMFrOD8hNnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxMDozMzoxMlrOD9FEFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Nzg1MzA5OnYy", "diffSide": "RIGHT", "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowMToxMFrOGVgiHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowMToxMFrOGVgiHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwNjMwMw==", "bodyText": "May want to reference this (instead of or in addition to Guava):\nhttps://en.wikipedia.org/wiki/Cycle_detection#Floyd's_Tortoise_and_Hare", "url": "https://github.com/netty/netty/pull/10291#discussion_r425206303", "createdAt": "2020-05-14T15:01:10Z", "author": {"login": "Bennett-Lynch"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -301,20 +300,24 @@ private String cnameResolveFromCache(String name) {\n     }\n \n     private String cnameResolveFromCacheLoop(DnsCnameCache cnameCache, String first, String mapping) {\n-        // Detect loops using a HashSet. We use this as last resort implementation to reduce allocations in the most\n-        // common cases.\n-        Set<String> cnames = new HashSet<String>(4);\n-        cnames.add(first);\n-        cnames.add(mapping);\n+        // Detect loops by advance only every other iteration. This is the same concept as used in guava", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79d510f80941cd77fcce782d898420d0dbf6daf2"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Nzg1MzU2OnYy", "diffSide": "RIGHT", "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowMToxNlrOGVgiZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo0NDoyM1rOGVlJ-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwNjM3Mw==", "bodyText": "Unrelated to this PR but does it make more sense to break or to throw?", "url": "https://github.com/netty/netty/pull/10291#discussion_r425206373", "createdAt": "2020-05-14T15:01:16Z", "author": {"login": "Bennett-Lynch"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -301,20 +300,24 @@ private String cnameResolveFromCache(String name) {\n     }\n \n     private String cnameResolveFromCacheLoop(DnsCnameCache cnameCache, String first, String mapping) {\n-        // Detect loops using a HashSet. We use this as last resort implementation to reduce allocations in the most\n-        // common cases.\n-        Set<String> cnames = new HashSet<String>(4);\n-        cnames.add(first);\n-        cnames.add(mapping);\n+        // Detect loops by advance only every other iteration. This is the same concept as used in guava\n+        String otherMapping = first;\n+        boolean advance = false;\n \n         String name = mapping;\n         // Resolve from cnameCache() until there is no more cname entry cached.\n         while ((mapping = cnameCache.get(hostnameWithDot(name))) != null) {\n-            if (!cnames.add(mapping)) {\n+            if (otherMapping.equals(mapping)) {\n                 // Follow CNAME from cache would loop. Lets break here.\n                 break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79d510f80941cd77fcce782d898420d0dbf6daf2"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4MjA0MA==", "bodyText": "good question. Let me do this in a followup... Most likely throw as it will fail the resolution anyway at the end", "url": "https://github.com/netty/netty/pull/10291#discussion_r425282040", "createdAt": "2020-05-14T16:44:23Z", "author": {"login": "normanmaurer"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -301,20 +300,24 @@ private String cnameResolveFromCache(String name) {\n     }\n \n     private String cnameResolveFromCacheLoop(DnsCnameCache cnameCache, String first, String mapping) {\n-        // Detect loops using a HashSet. We use this as last resort implementation to reduce allocations in the most\n-        // common cases.\n-        Set<String> cnames = new HashSet<String>(4);\n-        cnames.add(first);\n-        cnames.add(mapping);\n+        // Detect loops by advance only every other iteration. This is the same concept as used in guava\n+        String otherMapping = first;\n+        boolean advance = false;\n \n         String name = mapping;\n         // Resolve from cnameCache() until there is no more cname entry cached.\n         while ((mapping = cnameCache.get(hostnameWithDot(name))) != null) {\n-            if (!cnames.add(mapping)) {\n+            if (otherMapping.equals(mapping)) {\n                 // Follow CNAME from cache would loop. Lets break here.\n                 break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwNjM3Mw=="}, "originalCommit": {"oid": "79d510f80941cd77fcce782d898420d0dbf6daf2"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Nzg1ODgxOnYy", "diffSide": "RIGHT", "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowMjozMlrOGVgl4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTowMjozMlrOGVgl4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwNzI2NQ==", "bodyText": "Nit: I find advance = !advance (outside of the if block) a little more intuitive.", "url": "https://github.com/netty/netty/pull/10291#discussion_r425207265", "createdAt": "2020-05-14T15:02:32Z", "author": {"login": "Bennett-Lynch"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -301,20 +300,24 @@ private String cnameResolveFromCache(String name) {\n     }\n \n     private String cnameResolveFromCacheLoop(DnsCnameCache cnameCache, String first, String mapping) {\n-        // Detect loops using a HashSet. We use this as last resort implementation to reduce allocations in the most\n-        // common cases.\n-        Set<String> cnames = new HashSet<String>(4);\n-        cnames.add(first);\n-        cnames.add(mapping);\n+        // Detect loops by advance only every other iteration. This is the same concept as used in guava\n+        String otherMapping = first;\n+        boolean advance = false;\n \n         String name = mapping;\n         // Resolve from cnameCache() until there is no more cname entry cached.\n         while ((mapping = cnameCache.get(hostnameWithDot(name))) != null) {\n-            if (!cnames.add(mapping)) {\n+            if (otherMapping.equals(mapping)) {\n                 // Follow CNAME from cache would loop. Lets break here.\n                 break;\n             }\n             name = mapping;\n+            if (advance) {\n+                otherMapping = mapping;\n+                advance = false;\n+            } else {\n+                advance = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79d510f80941cd77fcce782d898420d0dbf6daf2"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzcyNjkyOnYy", "diffSide": "RIGHT", "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxMDozMzoxMlrOGWZnBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODowMTowMlrOGWrp1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE0MTQ0Nw==", "bodyText": "Just out of curiosity ,why you need field  otherMapping  to instead of first  which you never use .", "url": "https://github.com/netty/netty/pull/10291#discussion_r426141447", "createdAt": "2020-05-16T10:33:12Z", "author": {"login": "prgitpr"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -300,28 +300,31 @@ private String cnameResolveFromCache(String name) {\n         return cnameResolveFromCacheLoop(cnameCache, first, second);\n     }\n \n-    private String cnameResolveFromCacheLoop(DnsCnameCache cnameCache, String first, String mapping) {\n-        // Detect loops using a HashSet. We use this as last resort implementation to reduce allocations in the most\n-        // common cases.\n-        Set<String> cnames = new HashSet<String>(4);\n-        cnames.add(first);\n-        cnames.add(mapping);\n+    static String cnameResolveFromCacheLoop(DnsCnameCache cnameCache, String first, String mapping) {\n+        // Detect loops by advance only every other iteration.\n+        // See https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_Tortoise_and_Hare\n+        String otherMapping = first;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ee26f3c9579420be95e868471a3bf0f7888ef29"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNzA3Ng==", "bodyText": "@prgitpr yep we can simplify.", "url": "https://github.com/netty/netty/pull/10291#discussion_r426437076", "createdAt": "2020-05-18T08:01:02Z", "author": {"login": "normanmaurer"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -300,28 +300,31 @@ private String cnameResolveFromCache(String name) {\n         return cnameResolveFromCacheLoop(cnameCache, first, second);\n     }\n \n-    private String cnameResolveFromCacheLoop(DnsCnameCache cnameCache, String first, String mapping) {\n-        // Detect loops using a HashSet. We use this as last resort implementation to reduce allocations in the most\n-        // common cases.\n-        Set<String> cnames = new HashSet<String>(4);\n-        cnames.add(first);\n-        cnames.add(mapping);\n+    static String cnameResolveFromCacheLoop(DnsCnameCache cnameCache, String first, String mapping) {\n+        // Detect loops by advance only every other iteration.\n+        // See https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_Tortoise_and_Hare\n+        String otherMapping = first;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE0MTQ0Nw=="}, "originalCommit": {"oid": "1ee26f3c9579420be95e868471a3bf0f7888ef29"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3453, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}