{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzMDA4Njc1", "number": 10132, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMjozNToxOVrODrCu0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjowOTozOVrODsvx2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDYwMTEyOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMjozNToxOVrOF7KILA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNzowMTo1OFrOF7OK1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3NjIzNg==", "bodyText": "Optional idea:  If a user adds a wildcard domain *.netty.io,  it could be normalized to .netty.io, and stored in the map.  That would make it cheaper for this line to check if it's present, because no string concatenation would be needed.  You could just check the substring.\nI am not sure how fast you want it to go.", "url": "https://github.com/netty/netty/pull/10132#discussion_r397576236", "createdAt": "2020-03-25T02:35:19Z", "author": {"login": "carl-mastrangelo"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\")),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));\n+    }\n+\n+    private static final class ImmutableDomainWildcardMapping<V> implements Mapping<String, V> {\n+        private static final String REPR_HEADER = \"ImmutableDomainWildcardMapping(default: \";\n+        private static final String REPR_MAP_OPENING = \", map: \";\n+        private static final String REPR_MAP_CLOSING = \")\";\n+\n+        private final V defaultValue;\n+        private final Map<String, V> map;\n+\n+        ImmutableDomainWildcardMapping(V defaultValue, Map<String, V> map) {\n+            this.defaultValue = defaultValue;\n+            this.map = Collections.unmodifiableMap(map);\n+        }\n+\n+        @Override\n+        public V map(String hostname) {\n+            if (hostname != null) {\n+                hostname = normalize(hostname);\n+\n+                // Let's try an exact match first\n+                V value = map.get(hostname);\n+                if (value != null) {\n+                    return value;\n+                }\n+\n+                // No exact match, let's try a wildcard match.\n+                int idx = hostname.indexOf('.');\n+                if (idx != -1) {\n+                    value = map.get('*' + hostname.substring(idx));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0416fd93aaa6c2c57d0400a29c278b65f0a80b0"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY0MjQ1NQ==", "bodyText": "thats a good idea ... Let me do this", "url": "https://github.com/netty/netty/pull/10132#discussion_r397642455", "createdAt": "2020-03-25T07:01:58Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\")),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));\n+    }\n+\n+    private static final class ImmutableDomainWildcardMapping<V> implements Mapping<String, V> {\n+        private static final String REPR_HEADER = \"ImmutableDomainWildcardMapping(default: \";\n+        private static final String REPR_MAP_OPENING = \", map: \";\n+        private static final String REPR_MAP_CLOSING = \")\";\n+\n+        private final V defaultValue;\n+        private final Map<String, V> map;\n+\n+        ImmutableDomainWildcardMapping(V defaultValue, Map<String, V> map) {\n+            this.defaultValue = defaultValue;\n+            this.map = Collections.unmodifiableMap(map);\n+        }\n+\n+        @Override\n+        public V map(String hostname) {\n+            if (hostname != null) {\n+                hostname = normalize(hostname);\n+\n+                // Let's try an exact match first\n+                V value = map.get(hostname);\n+                if (value != null) {\n+                    return value;\n+                }\n+\n+                // No exact match, let's try a wildcard match.\n+                int idx = hostname.indexOf('.');\n+                if (idx != -1) {\n+                    value = map.get('*' + hostname.substring(idx));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3NjIzNg=="}, "originalCommit": {"oid": "b0416fd93aaa6c2c57d0400a29c278b65f0a80b0"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDYwNzU5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMjozOToxNFrOF7KL7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMjozOToxNFrOF7KL7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3NzE5Ng==", "bodyText": "s/.toString()//", "url": "https://github.com/netty/netty/pull/10132#discussion_r397577196", "createdAt": "2020-03-25T02:39:14Z", "author": {"login": "carl-mastrangelo"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\")),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));\n+    }\n+\n+    private static final class ImmutableDomainWildcardMapping<V> implements Mapping<String, V> {\n+        private static final String REPR_HEADER = \"ImmutableDomainWildcardMapping(default: \";\n+        private static final String REPR_MAP_OPENING = \", map: \";\n+        private static final String REPR_MAP_CLOSING = \")\";\n+\n+        private final V defaultValue;\n+        private final Map<String, V> map;\n+\n+        ImmutableDomainWildcardMapping(V defaultValue, Map<String, V> map) {\n+            this.defaultValue = defaultValue;\n+            this.map = Collections.unmodifiableMap(map);\n+        }\n+\n+        @Override\n+        public V map(String hostname) {\n+            if (hostname != null) {\n+                hostname = normalize(hostname);\n+\n+                // Let's try an exact match first\n+                V value = map.get(hostname);\n+                if (value != null) {\n+                    return value;\n+                }\n+\n+                // No exact match, let's try a wildcard match.\n+                int idx = hostname.indexOf('.');\n+                if (idx != -1) {\n+                    value = map.get('*' + hostname.substring(idx));\n+                    if (value != null) {\n+                        return value;\n+                    }\n+                }\n+            }\n+\n+            return defaultValue;\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        static String normalize(String hostname) {\n+            return DomainNameMapping.normalizeHostname(hostname);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return REPR_HEADER + defaultValue + REPR_MAP_OPENING + map.toString() + REPR_MAP_CLOSING;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0416fd93aaa6c2c57d0400a29c278b65f0a80b0"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NTExNzIxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNzozMzowNlrOF7O12A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNzo0MTo1N1rOF7PDkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MzQ2NA==", "bodyText": "check that charAt(1) is a . ? (and is also at least length 2)", "url": "https://github.com/netty/netty/pull/10132#discussion_r397653464", "createdAt": "2020-03-25T07:33:06Z", "author": {"login": "carl-mastrangelo"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -71,11 +71,22 @@ public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n      *                 when the specified host name matches the specified input host name\n      */\n     public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n-        map.put(ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\")),\n+        map.put(normalizeHostName(hostname),\n                 checkNotNull(output, \"output\"));\n         return this;\n     }\n \n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n+        }\n+        hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n+        if (hostname.charAt(0) == '*') {\n+            return hostname.substring(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8817fad436791e47b1c856a309ab435b045b824"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1Njk3OA==", "bodyText": "sure why not :)", "url": "https://github.com/netty/netty/pull/10132#discussion_r397656978", "createdAt": "2020-03-25T07:41:57Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -71,11 +71,22 @@ public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n      *                 when the specified host name matches the specified input host name\n      */\n     public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n-        map.put(ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\")),\n+        map.put(normalizeHostName(hostname),\n                 checkNotNull(output, \"output\"));\n         return this;\n     }\n \n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n+        }\n+        hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n+        if (hostname.charAt(0) == '*') {\n+            return hostname.substring(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MzQ2NA=="}, "originalCommit": {"oid": "d8817fad436791e47b1c856a309ab435b045b824"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NTE3MjA4OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNzo1NDowNFrOF7PXRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNzo1NjoxN1rOF7Pasg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MjAyMg==", "bodyText": "The order is reversed.   This might throw an IOOBE", "url": "https://github.com/netty/netty/pull/10132#discussion_r397662022", "createdAt": "2020-03-25T07:54:04Z", "author": {"login": "carl-mastrangelo"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -83,6 +83,9 @@ private String normalizeHostName(String hostname) {\n         }\n         hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n         if (hostname.charAt(0) == '*') {\n+            if (hostname.charAt(1) != '.' || hostname.length() < 3) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f23b375f6433c98517e06643e5c4c9a80346cbd8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2Mjg5OA==", "bodyText": "I am an idiot... fixed", "url": "https://github.com/netty/netty/pull/10132#discussion_r397662898", "createdAt": "2020-03-25T07:56:17Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -83,6 +83,9 @@ private String normalizeHostName(String hostname) {\n         }\n         hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n         if (hostname.charAt(0) == '*') {\n+            if (hostname.charAt(1) != '.' || hostname.length() < 3) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MjAyMg=="}, "originalCommit": {"oid": "f23b375f6433c98517e06643e5c4c9a80346cbd8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NDEzNTk1OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwNzozMTo0MlrOF8l2GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwODoyMDo1NlrOF8nEFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3ODkzNg==", "bodyText": "https://gist.github.com/apangin/7a9b7062a4bd0cd41fcc#file-hotspot-jvm-intrinsics-L66 : java 8 doesn't contain String::indexOf(char) in the list of String intrinsics, while the version using String, yes. Java 9 has introduced the version with char IIRC", "url": "https://github.com/netty/netty/pull/10132#discussion_r399078936", "createdAt": "2020-03-27T07:31:42Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(normalizeHostName(hostname),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n+        }\n+        hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n+        if (hostname.charAt(0) == '*') {\n+            if (hostname.length() < 3 || hostname.charAt(1) != '.') {\n+                throw new IllegalArgumentException(\"Wildcard Hostname '\" + hostname + \"'not valid\");\n+            }\n+            return hostname.substring(1);\n+        }\n+        return hostname;\n+    }\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));\n+    }\n+\n+    private static final class ImmutableDomainWildcardMapping<V> implements Mapping<String, V> {\n+        private static final String REPR_HEADER = \"ImmutableDomainWildcardMapping(default: \";\n+        private static final String REPR_MAP_OPENING = \", map: \";\n+        private static final String REPR_MAP_CLOSING = \")\";\n+\n+        private final V defaultValue;\n+        private final Map<String, V> map;\n+\n+        ImmutableDomainWildcardMapping(V defaultValue, Map<String, V> map) {\n+            this.defaultValue = defaultValue;\n+            this.map = Collections.unmodifiableMap(map);\n+        }\n+\n+        @Override\n+        public V map(String hostname) {\n+            if (hostname != null) {\n+                hostname = normalize(hostname);\n+\n+                // Let's try an exact match first\n+                V value = map.get(hostname);\n+                if (value != null) {\n+                    return value;\n+                }\n+\n+                // No exact match, let's try a wildcard match.\n+                int idx = hostname.indexOf('.');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16468626486b22dee57ac81c3b713431012e4e6"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MzU0Ng==", "bodyText": "sure we can also use String if you think it matters a lot...  WDYT @franz1981 ?", "url": "https://github.com/netty/netty/pull/10132#discussion_r399083546", "createdAt": "2020-03-27T07:44:31Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(normalizeHostName(hostname),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n+        }\n+        hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n+        if (hostname.charAt(0) == '*') {\n+            if (hostname.length() < 3 || hostname.charAt(1) != '.') {\n+                throw new IllegalArgumentException(\"Wildcard Hostname '\" + hostname + \"'not valid\");\n+            }\n+            return hostname.substring(1);\n+        }\n+        return hostname;\n+    }\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));\n+    }\n+\n+    private static final class ImmutableDomainWildcardMapping<V> implements Mapping<String, V> {\n+        private static final String REPR_HEADER = \"ImmutableDomainWildcardMapping(default: \";\n+        private static final String REPR_MAP_OPENING = \", map: \";\n+        private static final String REPR_MAP_CLOSING = \")\";\n+\n+        private final V defaultValue;\n+        private final Map<String, V> map;\n+\n+        ImmutableDomainWildcardMapping(V defaultValue, Map<String, V> map) {\n+            this.defaultValue = defaultValue;\n+            this.map = Collections.unmodifiableMap(map);\n+        }\n+\n+        @Override\n+        public V map(String hostname) {\n+            if (hostname != null) {\n+                hostname = normalize(hostname);\n+\n+                // Let's try an exact match first\n+                V value = map.get(hostname);\n+                if (value != null) {\n+                    return value;\n+                }\n+\n+                // No exact match, let's try a wildcard match.\n+                int idx = hostname.indexOf('.');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3ODkzNg=="}, "originalCommit": {"oid": "d16468626486b22dee57ac81c3b713431012e4e6"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5MzQ4MA==", "bodyText": "I've written a small bench to check if if it can really matter, will tell you soon :)", "url": "https://github.com/netty/netty/pull/10132#discussion_r399093480", "createdAt": "2020-03-27T08:08:45Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(normalizeHostName(hostname),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n+        }\n+        hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n+        if (hostname.charAt(0) == '*') {\n+            if (hostname.length() < 3 || hostname.charAt(1) != '.') {\n+                throw new IllegalArgumentException(\"Wildcard Hostname '\" + hostname + \"'not valid\");\n+            }\n+            return hostname.substring(1);\n+        }\n+        return hostname;\n+    }\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));\n+    }\n+\n+    private static final class ImmutableDomainWildcardMapping<V> implements Mapping<String, V> {\n+        private static final String REPR_HEADER = \"ImmutableDomainWildcardMapping(default: \";\n+        private static final String REPR_MAP_OPENING = \", map: \";\n+        private static final String REPR_MAP_CLOSING = \")\";\n+\n+        private final V defaultValue;\n+        private final Map<String, V> map;\n+\n+        ImmutableDomainWildcardMapping(V defaultValue, Map<String, V> map) {\n+            this.defaultValue = defaultValue;\n+            this.map = Collections.unmodifiableMap(map);\n+        }\n+\n+        @Override\n+        public V map(String hostname) {\n+            if (hostname != null) {\n+                hostname = normalize(hostname);\n+\n+                // Let's try an exact match first\n+                V value = map.get(hostname);\n+                if (value != null) {\n+                    return value;\n+                }\n+\n+                // No exact match, let's try a wildcard match.\n+                int idx = hostname.indexOf('.');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3ODkzNg=="}, "originalCommit": {"oid": "d16468626486b22dee57ac81c3b713431012e4e6"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5Nzg4NQ==", "bodyText": "Ok, for input Strings < 100, searching a String in whatever position is just slower then using indexOf(char), so better to left indexOf(char)", "url": "https://github.com/netty/netty/pull/10132#discussion_r399097885", "createdAt": "2020-03-27T08:18:41Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(normalizeHostName(hostname),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n+        }\n+        hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n+        if (hostname.charAt(0) == '*') {\n+            if (hostname.length() < 3 || hostname.charAt(1) != '.') {\n+                throw new IllegalArgumentException(\"Wildcard Hostname '\" + hostname + \"'not valid\");\n+            }\n+            return hostname.substring(1);\n+        }\n+        return hostname;\n+    }\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));\n+    }\n+\n+    private static final class ImmutableDomainWildcardMapping<V> implements Mapping<String, V> {\n+        private static final String REPR_HEADER = \"ImmutableDomainWildcardMapping(default: \";\n+        private static final String REPR_MAP_OPENING = \", map: \";\n+        private static final String REPR_MAP_CLOSING = \")\";\n+\n+        private final V defaultValue;\n+        private final Map<String, V> map;\n+\n+        ImmutableDomainWildcardMapping(V defaultValue, Map<String, V> map) {\n+            this.defaultValue = defaultValue;\n+            this.map = Collections.unmodifiableMap(map);\n+        }\n+\n+        @Override\n+        public V map(String hostname) {\n+            if (hostname != null) {\n+                hostname = normalize(hostname);\n+\n+                // Let's try an exact match first\n+                V value = map.get(hostname);\n+                if (value != null) {\n+                    return value;\n+                }\n+\n+                // No exact match, let's try a wildcard match.\n+                int idx = hostname.indexOf('.');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3ODkzNg=="}, "originalCommit": {"oid": "d16468626486b22dee57ac81c3b713431012e4e6"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5ODkwMg==", "bodyText": "ok then I think I am done...", "url": "https://github.com/netty/netty/pull/10132#discussion_r399098902", "createdAt": "2020-03-27T08:20:56Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(normalizeHostName(hostname),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n+        }\n+        hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n+        if (hostname.charAt(0) == '*') {\n+            if (hostname.length() < 3 || hostname.charAt(1) != '.') {\n+                throw new IllegalArgumentException(\"Wildcard Hostname '\" + hostname + \"'not valid\");\n+            }\n+            return hostname.substring(1);\n+        }\n+        return hostname;\n+    }\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));\n+    }\n+\n+    private static final class ImmutableDomainWildcardMapping<V> implements Mapping<String, V> {\n+        private static final String REPR_HEADER = \"ImmutableDomainWildcardMapping(default: \";\n+        private static final String REPR_MAP_OPENING = \", map: \";\n+        private static final String REPR_MAP_CLOSING = \")\";\n+\n+        private final V defaultValue;\n+        private final Map<String, V> map;\n+\n+        ImmutableDomainWildcardMapping(V defaultValue, Map<String, V> map) {\n+            this.defaultValue = defaultValue;\n+            this.map = Collections.unmodifiableMap(map);\n+        }\n+\n+        @Override\n+        public V map(String hostname) {\n+            if (hostname != null) {\n+                hostname = normalize(hostname);\n+\n+                // Let's try an exact match first\n+                V value = map.get(hostname);\n+                if (value != null) {\n+                    return value;\n+                }\n+\n+                // No exact match, let's try a wildcard match.\n+                int idx = hostname.indexOf('.');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3ODkzNg=="}, "originalCommit": {"oid": "d16468626486b22dee57ac81c3b713431012e4e6"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NDE0NjE0OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwNzozNjoxM1rOF8l8Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwNzo0NDo1NlrOF8mIrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MDQ5MQ==", "bodyText": "DomainWildcardMappingBuilder::build is alredy creating a fresh new map that would be owned by ImmutableDomainWildcardMapping: if you let the copy of DomainWildcardMappingBuilder::map to happen inside new ImmutableDomainWildcardMapping, you could save using an unmodifiableMap and the pointer chasing introduced by it", "url": "https://github.com/netty/netty/pull/10132#discussion_r399080491", "createdAt": "2020-03-27T07:36:13Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(normalizeHostName(hostname),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n+        }\n+        hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n+        if (hostname.charAt(0) == '*') {\n+            if (hostname.length() < 3 || hostname.charAt(1) != '.') {\n+                throw new IllegalArgumentException(\"Wildcard Hostname '\" + hostname + \"'not valid\");\n+            }\n+            return hostname.substring(1);\n+        }\n+        return hostname;\n+    }\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));\n+    }\n+\n+    private static final class ImmutableDomainWildcardMapping<V> implements Mapping<String, V> {\n+        private static final String REPR_HEADER = \"ImmutableDomainWildcardMapping(default: \";\n+        private static final String REPR_MAP_OPENING = \", map: \";\n+        private static final String REPR_MAP_CLOSING = \")\";\n+\n+        private final V defaultValue;\n+        private final Map<String, V> map;\n+\n+        ImmutableDomainWildcardMapping(V defaultValue, Map<String, V> map) {\n+            this.defaultValue = defaultValue;\n+            this.map = Collections.unmodifiableMap(map);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16468626486b22dee57ac81c3b713431012e4e6"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MzY5Mw==", "bodyText": "@franz1981 good point...", "url": "https://github.com/netty/netty/pull/10132#discussion_r399083693", "createdAt": "2020-03-27T07:44:56Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(normalizeHostName(hostname),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n+        }\n+        hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n+        if (hostname.charAt(0) == '*') {\n+            if (hostname.length() < 3 || hostname.charAt(1) != '.') {\n+                throw new IllegalArgumentException(\"Wildcard Hostname '\" + hostname + \"'not valid\");\n+            }\n+            return hostname.substring(1);\n+        }\n+        return hostname;\n+    }\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));\n+    }\n+\n+    private static final class ImmutableDomainWildcardMapping<V> implements Mapping<String, V> {\n+        private static final String REPR_HEADER = \"ImmutableDomainWildcardMapping(default: \";\n+        private static final String REPR_MAP_OPENING = \", map: \";\n+        private static final String REPR_MAP_CLOSING = \")\";\n+\n+        private final V defaultValue;\n+        private final Map<String, V> map;\n+\n+        ImmutableDomainWildcardMapping(V defaultValue, Map<String, V> map) {\n+            this.defaultValue = defaultValue;\n+            this.map = Collections.unmodifiableMap(map);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MDQ5MQ=="}, "originalCommit": {"oid": "d16468626486b22dee57ac81c3b713431012e4e6"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NDI3Mjc4OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwODoyMzowM1rOF8nH7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwODoyMzowM1rOF8nH7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA5OTg4Nw==", "bodyText": "you can pass directly map to the ImmutableDomainWildcardMapping constructor (it will make the copy internally)", "url": "https://github.com/netty/netty/pull/10132#discussion_r399099887", "createdAt": "2020-03-27T08:23:03Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(normalizeHostName(hostname),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n+        }\n+        hostname = ImmutableDomainWildcardMapping.normalize(checkNotNull(hostname, \"hostname\"));\n+        if (hostname.charAt(0) == '*') {\n+            if (hostname.length() < 3 || hostname.charAt(1) != '.') {\n+                throw new IllegalArgumentException(\"Wildcard Hostname '\" + hostname + \"'not valid\");\n+            }\n+            return hostname.substring(1);\n+        }\n+        return hostname;\n+    }\n+    /**\n+     * Creates a new instance of an immutable {@link Mapping}.\n+     *\n+     * @return new {@link Mapping} instance\n+     */\n+    public Mapping<String, V> build() {\n+        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73bd6b893d263f6fa7d68df172358827ea85dcfa"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MjQ1ODkzOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjowNzo0OFrOF9xMgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjowODo1NlrOF9xPtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMxMzQ3Mw==", "bodyText": "intentionally low default?", "url": "https://github.com/netty/netty/pull/10132#discussion_r400313473", "createdAt": "2020-03-30T16:07:48Z", "author": {"login": "johnou"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b1830ef855fc7e0996830abdcf21b099bb6d6e0"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMxNDI5Mg==", "bodyText": "yeah its what we use with our others as well...", "url": "https://github.com/netty/netty/pull/10132#discussion_r400314292", "createdAt": "2020-03-30T16:08:56Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMxMzQ3Mw=="}, "originalCommit": {"oid": "2b1830ef855fc7e0996830abdcf21b099bb6d6e0"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MjQ2NzQ2OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjowOTozOVrOF9xRug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjowOTozOVrOF9xRug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMxNDgxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");\n          \n          \n            \n                        throw new IllegalArgumentException(\"Hostname '\" + hostname + \"' not valid\");", "url": "https://github.com/netty/netty/pull/10132#discussion_r400314810", "createdAt": "2020-03-30T16:09:39Z", "author": {"login": "johnou"}, "path": "common/src/main/java/io/netty/util/DomainWildcardMappingBuilder.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+/**\n+ * Builder that allows to build {@link Mapping}s that support\n+ * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> matching.\n+ * @param <V> the type of the value that we map to.\n+ */\n+public class DomainWildcardMappingBuilder<V> {\n+\n+    private final V defaultValue;\n+    private final Map<String, V> map;\n+\n+    /**\n+     * Constructor with default initial capacity of the map holding the mappings\n+     *\n+     * @param defaultValue the default value for {@link Mapping#map(Object)} )} to return\n+     *                     when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(V defaultValue) {\n+        this(4, defaultValue);\n+    }\n+\n+    /**\n+     * Constructor with initial capacity of the map holding the mappings\n+     *\n+     * @param initialCapacity initial capacity for the internal map\n+     * @param defaultValue    the default value for {@link Mapping#map(Object)} to return\n+     *                        when nothing matches the input\n+     */\n+    public DomainWildcardMappingBuilder(int initialCapacity, V defaultValue) {\n+        this.defaultValue = checkNotNull(defaultValue, \"defaultValue\");\n+        map = new LinkedHashMap<String, V>(initialCapacity);\n+    }\n+\n+    /**\n+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.\n+     * {@code null} values are forbidden for both hostnames and values.\n+     * <p>\n+     * <a href=\"https://tools.ietf.org/search/rfc6125#section-6.4\">DNS wildcard</a> is supported as hostname. The\n+     * wildcard will only match one sub-domain deep and only when wildcard is used as the most-left label.\n+     *\n+     * For example:\n+     *\n+     * <p>\n+     *  *.netty.io will match xyz.netty.io but NOT abc.xyz.netty.io\n+     * </p>\n+     *\n+     * @param hostname the host name (optionally wildcard)\n+     * @param output   the output value that will be returned by {@link Mapping#map(Object)}\n+     *                 when the specified host name matches the specified input host name\n+     */\n+    public DomainWildcardMappingBuilder<V> add(String hostname, V output) {\n+        map.put(normalizeHostName(hostname),\n+                checkNotNull(output, \"output\"));\n+        return this;\n+    }\n+\n+    private String normalizeHostName(String hostname) {\n+        checkNotNull(hostname, \"hostname\");\n+        if (hostname.isEmpty() || hostname.charAt(0) == '.') {\n+            throw new IllegalArgumentException(\"Hostname '\" + hostname + \"'not valid\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b1830ef855fc7e0996830abdcf21b099bb6d6e0"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3362, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}