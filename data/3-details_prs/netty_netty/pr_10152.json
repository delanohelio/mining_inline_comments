{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2Mjk3ODkz", "number": 10152, "title": "Stomp over WebSocket Chat example", "bodyText": "Motivation:\nOften people want to use stomp-codec with WebSocket transport or other but cannot figure out how can do this staff on Netty.\nModification:\nCreate example for demonstrating integration between STOMP and WebSocket.\nInspired by https://github.com/jmesnil/stomp-websocket\nResult:\nFixes #9383", "createdAt": "2020-03-31T12:23:57Z", "url": "https://github.com/netty/netty/pull/10152", "merged": true, "mergeCommit": {"oid": "2b14775446f3f3937ddd6eb6bd7b22686810908f"}, "closed": true, "closedAt": "2020-04-08T10:04:49Z", "author": {"login": "amizurov"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTDglcgFqTM4NDc1ODA5Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTtnAzgH2gAyMzk2Mjk3ODkzOjNhMGM3OGJhYjRhMzU2ZDg3OWU0ZjYzZmFkNzNkNWZmZmZjNTM3YWU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NzU4MDky", "url": "https://github.com/netty/netty/pull/10152#pullrequestreview-384758092", "createdAt": "2020-03-31T13:55:57Z", "commit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMzo1NTo1N1rOF-XCfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMzo1NTo1N1rOF-XCfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzMzUwMA==", "bodyText": "wouldn't it be better to make this non static and create one instance of the handler that is shared at the end ? This way we ensure at least stuff can be GC'ed.", "url": "https://github.com/netty/netty/pull/10152#discussion_r400933500", "createdAt": "2020-03-31T13:55:57Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NzU4MzA5", "url": "https://github.com/netty/netty/pull/10152#pullrequestreview-384758309", "createdAt": "2020-03-31T13:56:09Z", "commit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMzo1NjowOVrOF-XDDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMzo1NjowOVrOF-XDDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzMzY0NA==", "bodyText": "ConcurrentMap...", "url": "https://github.com/netty/netty/pull/10152#discussion_r400933644", "createdAt": "2020-03-31T13:56:09Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NzU5MjA4", "url": "https://github.com/netty/netty/pull/10152#pullrequestreview-384759208", "createdAt": "2020-03-31T13:57:00Z", "commit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMzo1NzowMVrOF-XFvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMzo1NzowMVrOF-XFvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzNDMzNQ==", "bodyText": "List", "url": "https://github.com/netty/netty/pull/10152#discussion_r400934335", "createdAt": "2020-03-31T13:57:01Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompVersion.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.util.AttributeKey;\n+import io.netty.util.internal.StringUtil;\n+\n+import java.util.ArrayList;\n+\n+public enum StompVersion {\n+\n+    STOMP_V11(\"1.1\", \"v11.stomp\"),\n+\n+    STOMP_V12(\"1.2\", \"v12.stomp\");\n+\n+    public static final AttributeKey<StompVersion> CHANNEL_ATTRIBUTE_KEY = AttributeKey.valueOf(\"stomp_version\");\n+    public static final String SUB_PROTOCOLS;\n+\n+    static {\n+        ArrayList<String> subProtocols = new ArrayList<String>(values().length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MzMzOTUy", "url": "https://github.com/netty/netty/pull/10152#pullrequestreview-385333952", "createdAt": "2020-04-01T07:39:43Z", "commit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNzozOTo0NFrOF-0Xmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNzo0Njo1OFrOF-0nDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNDA0Mg==", "bodyText": "yep... that said in your example you call userEventTriggered two times ;)", "url": "https://github.com/netty/netty/pull/10152#discussion_r401414042", "createdAt": "2020-04-01T07:39:44Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzMzUwMA=="}, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNDU4Mw==", "bodyText": "nit: I would make ChannelHandlerContext the first argument for all methods to be consistent with the rest of netty.", "url": "https://github.com/netty/netty/pull/10152#discussion_r401414583", "createdAt": "2020-04-01T07:40:39Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNTE0Mw==", "bodyText": "can this ever be null ? I mean you use \u00b4.putIfAbsent\u00b4 just before.", "url": "https://github.com/netty/netty/pull/10152#discussion_r401415143", "createdAt": "2020-04-01T07:41:45Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNTg2MQ==", "bodyText": "imho you can just call write(...) and only flush at the end once you iterated over all of these.", "url": "https://github.com/netty/netty/pull/10152#discussion_r401415861", "createdAt": "2020-04-01T07:42:57Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjA4Mg==", "bodyText": "static ?", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416082", "createdAt": "2020-04-01T07:43:20Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String subscriptionId = inboundFrame.headers().getAsString(SUBSCRIPTION);\n+        for (Entry<String, Set<StompSubscription>> entry : CHAT_DESTINATIONS.entrySet()) {\n+            Iterator<StompSubscription> iterator = entry.getValue().iterator();\n+            while (iterator.hasNext()) {\n+                StompSubscription subscription = iterator.next();\n+                if (subscription.id().equals(subscriptionId) && subscription.channel().equals(ctx.channel())) {\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void onDisconnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId == null) {\n+            ctx.close();\n+            return;\n+        }\n+\n+        StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+        receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+        ctx.writeAndFlush(receiptFrame).addListener(ChannelFutureListener.CLOSE);\n+    }\n+\n+    private StompFrame transformToMessage(StompFrame sendFrame, StompSubscription subscription) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjE5NQ==", "bodyText": "static ?", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416195", "createdAt": "2020-04-01T07:43:31Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String subscriptionId = inboundFrame.headers().getAsString(SUBSCRIPTION);\n+        for (Entry<String, Set<StompSubscription>> entry : CHAT_DESTINATIONS.entrySet()) {\n+            Iterator<StompSubscription> iterator = entry.getValue().iterator();\n+            while (iterator.hasNext()) {\n+                StompSubscription subscription = iterator.next();\n+                if (subscription.id().equals(subscriptionId) && subscription.channel().equals(ctx.channel())) {\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void onDisconnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId == null) {\n+            ctx.close();\n+            return;\n+        }\n+\n+        StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+        receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+        ctx.writeAndFlush(receiptFrame).addListener(ChannelFutureListener.CLOSE);\n+    }\n+\n+    private StompFrame transformToMessage(StompFrame sendFrame, StompSubscription subscription) {\n+        StompFrame messageFrame = new DefaultStompFrame(StompCommand.MESSAGE, sendFrame.content().retainedDuplicate());\n+        String id = UUID.randomUUID().toString();\n+        messageFrame.headers()\n+                    .set(MESSAGE_ID, id)\n+                    .set(SUBSCRIPTION, subscription.id());\n+        return messageFrame;\n+    }\n+\n+    private void sendErrorFrame(String message, String description, ChannelHandlerContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjMzNw==", "bodyText": "you need to release the content.", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416337", "createdAt": "2020-04-01T07:43:48Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String subscriptionId = inboundFrame.headers().getAsString(SUBSCRIPTION);\n+        for (Entry<String, Set<StompSubscription>> entry : CHAT_DESTINATIONS.entrySet()) {\n+            Iterator<StompSubscription> iterator = entry.getValue().iterator();\n+            while (iterator.hasNext()) {\n+                StompSubscription subscription = iterator.next();\n+                if (subscription.id().equals(subscriptionId) && subscription.channel().equals(ctx.channel())) {\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void onDisconnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId == null) {\n+            ctx.close();\n+            return;\n+        }\n+\n+        StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+        receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+        ctx.writeAndFlush(receiptFrame).addListener(ChannelFutureListener.CLOSE);\n+    }\n+\n+    private StompFrame transformToMessage(StompFrame sendFrame, StompSubscription subscription) {\n+        StompFrame messageFrame = new DefaultStompFrame(StompCommand.MESSAGE, sendFrame.content().retainedDuplicate());\n+        String id = UUID.randomUUID().toString();\n+        messageFrame.headers()\n+                    .set(MESSAGE_ID, id)\n+                    .set(SUBSCRIPTION, subscription.id());\n+        return messageFrame;\n+    }\n+\n+    private void sendErrorFrame(String message, String description, ChannelHandlerContext ctx) {\n+        StompFrame errorFrame = new DefaultStompFrame(StompCommand.ERROR);\n+        errorFrame.headers().set(MESSAGE, message);\n+\n+        if (description != null) {\n+            ByteBuf content = encodeString(ctx.alloc(), CharBuffer.wrap(description), UTF_8);\n+            errorFrame.content().writeBytes(content);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjQ0MA==", "bodyText": "static", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416440", "createdAt": "2020-04-01T07:43:59Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String subscriptionId = inboundFrame.headers().getAsString(SUBSCRIPTION);\n+        for (Entry<String, Set<StompSubscription>> entry : CHAT_DESTINATIONS.entrySet()) {\n+            Iterator<StompSubscription> iterator = entry.getValue().iterator();\n+            while (iterator.hasNext()) {\n+                StompSubscription subscription = iterator.next();\n+                if (subscription.id().equals(subscriptionId) && subscription.channel().equals(ctx.channel())) {\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void onDisconnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjQ3MQ==", "bodyText": "static", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416471", "createdAt": "2020-04-01T07:44:02Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjUzNQ==", "bodyText": "static", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416535", "createdAt": "2020-04-01T07:44:07Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjU5Mg==", "bodyText": "static", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416592", "createdAt": "2020-04-01T07:44:14Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjYyOA==", "bodyText": "static", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416628", "createdAt": "2020-04-01T07:44:19Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNjczNA==", "bodyText": "final", "url": "https://github.com/netty/netty/pull/10152#discussion_r401416734", "createdAt": "2020-04-01T07:44:32Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompSubscription.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.Channel;\n+import io.netty.util.internal.ObjectUtil;\n+\n+public class StompSubscription {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNzU3MA==", "bodyText": "add private constructor and make it final", "url": "https://github.com/netty/netty/pull/10152#discussion_r401417570", "createdAt": "2020-04-01T07:46:02Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+import java.nio.CharBuffer;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNzk0OA==", "bodyText": "Why can't you use writeCharSequence(...) ?", "url": "https://github.com/netty/netty/pull/10152#discussion_r401417948", "createdAt": "2020-04-01T07:46:51Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+import java.nio.CharBuffer;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content()\n+                    .writeBytes(ByteBufUtil.encodeString(ctx.alloc(), CharBuffer.wrap(payload), CharsetUtil.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNzk5OA==", "bodyText": "static", "url": "https://github.com/netty/netty/pull/10152#discussion_r401417998", "createdAt": "2020-04-01T07:46:58Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+import java.nio.CharBuffer;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content()\n+                    .writeBytes(ByteBufUtil.encodeString(ctx.alloc(), CharBuffer.wrap(payload), CharsetUtil.UTF_8));\n+            HttpUtil.setContentLength(notFound, notFound.content().readableBytes());\n+            sendResponse(notFound, ctx, true);\n+        }\n+    }\n+\n+    private boolean sendResource(FullHttpRequest request, ChannelHandlerContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1NTQ1MDMw", "url": "https://github.com/netty/netty/pull/10152#pullrequestreview-385545030", "createdAt": "2020-04-01T12:42:08Z", "commit": {"oid": "798e4731a7608943f12609e8cb1feddd7f992e7d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjo0MjowOFrOF--wKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxMjo0Mjo1MVrOF--xug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4NDE2OA==", "bodyText": "I see.. that said I think we should check with get first and then call putIfAbstent to ensure we not allocate a new HashSet all the time", "url": "https://github.com/netty/netty/pull/10152#discussion_r401584168", "createdAt": "2020-04-01T12:42:08Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+import io.netty.util.CharsetUtil;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    private final ConcurrentMap<String, Set<StompSubscription>> chatDestinations =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(ctx, inboundFrame);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(ctx, inboundFrame);\n+            break;\n+        case SEND:\n+            onSend(ctx, inboundFrame);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(ctx, inboundFrame);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(ctx, inboundFrame);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onSubscribe(ChannelHandlerContext ctx, StompFrame inboundFrame) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                chatDestinations.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "798e4731a7608943f12609e8cb1feddd7f992e7d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4NDU3MA==", "bodyText": "You are right... sorry I missed that there a different Channels.", "url": "https://github.com/netty/netty/pull/10152#discussion_r401584570", "createdAt": "2020-04-01T12:42:51Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+\n+import java.nio.CharBuffer;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static io.netty.buffer.ByteBufUtil.*;\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+import static io.netty.util.CharsetUtil.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    static final StompChatHandler INSTANCE = new StompChatHandler();\n+\n+    private final ConcurrentHashMap<String, Set<StompSubscription>> CHAT_DESTINATIONS =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(inboundFrame, ctx);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(inboundFrame, ctx);\n+            break;\n+        case SEND:\n+            onSend(inboundFrame, ctx);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(inboundFrame, ctx);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(inboundFrame, ctx);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onConnect(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String acceptVersions = inboundFrame.headers().getAsString(ACCEPT_VERSION);\n+        StompVersion handshakeAcceptVersion = ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).get();\n+        if (acceptVersions == null || !acceptVersions.contains(handshakeAcceptVersion.version())) {\n+            sendErrorFrame(\"invalid version\",\n+                           \"Received invalid version, expected \" + handshakeAcceptVersion.version(), ctx);\n+            return;\n+        }\n+\n+        StompFrame connectedFrame = new DefaultStompFrame(StompCommand.CONNECTED);\n+        connectedFrame.headers()\n+                      .set(VERSION, handshakeAcceptVersion.version())\n+                      .set(SERVER, \"Netty-Server\")\n+                      .set(HEART_BEAT, \"0,0\");\n+        ctx.writeAndFlush(connectedFrame);\n+    }\n+\n+    private void onSubscribe(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions =\n+                CHAT_DESTINATIONS.putIfAbsent(destination, new HashSet<StompSubscription>());\n+        if (subscriptions == null) {\n+            subscriptions = CHAT_DESTINATIONS.get(destination);\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                CHAT_DESTINATIONS.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(StompFrame inboundFrame, ChannelHandlerContext ctx) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = CHAT_DESTINATIONS.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNTg2MQ=="}, "originalCommit": {"oid": "636aedd5eb323a3f40f4069593b56aae52886cf9"}, "originalPosition": 144}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "author": {"user": {"login": "amizurov", "name": "Andrey Mizurov"}}, "url": "https://github.com/netty/netty/commit/bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "committedDate": "2020-04-01T17:40:48Z", "message": "Stomp over WebSocket Chat example"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "09ab9569724341a87baf842b1240ca51c4cff9e9", "author": {"user": {"login": "amizurov", "name": "Andrey Mizurov"}}, "url": "https://github.com/netty/netty/commit/09ab9569724341a87baf842b1240ca51c4cff9e9", "committedDate": "2020-04-01T13:15:45Z", "message": "Fix HashMap allocation"}, "afterCommit": {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "author": {"user": {"login": "amizurov", "name": "Andrey Mizurov"}}, "url": "https://github.com/netty/netty/commit/bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9", "committedDate": "2020-04-01T17:40:48Z", "message": "Stomp over WebSocket Chat example"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MTcwMTEz", "url": "https://github.com/netty/netty/pull/10152#pullrequestreview-386170113", "createdAt": "2020-04-02T07:31:35Z", "commit": {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNzozMTozNVrOF_epeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNzo0MjozN1rOF_e_QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwNjc0NA==", "bodyText": "ni: there is no need to call get again... putIfAbsent will return the subscription already so just store it in another var and re-assign", "url": "https://github.com/netty/netty/pull/10152#discussion_r402106744", "createdAt": "2020-04-02T07:31:35Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+import io.netty.util.CharsetUtil;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    private final ConcurrentMap<String, Set<StompSubscription>> chatDestinations =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(ctx, inboundFrame);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(ctx, inboundFrame);\n+            break;\n+        case SEND:\n+            onSend(ctx, inboundFrame);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(ctx, inboundFrame);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(ctx, inboundFrame);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onSubscribe(ChannelHandlerContext ctx, StompFrame inboundFrame) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = chatDestinations.get(destination);\n+        if (subscriptions == null) {\n+            subscriptions = new HashSet<StompSubscription>();\n+            if (chatDestinations.putIfAbsent(destination, subscriptions) != null) {\n+                subscriptions = chatDestinations.get(destination);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwODY5Nw==", "bodyText": "nit: why specify an explicit name here ? We dont do this for the other handlers as well.", "url": "https://github.com/netty/netty/pull/10152#discussion_r402108697", "createdAt": "2020-04-02T07:35:26Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketChatServerInitializer.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\n+import io.netty.util.internal.ObjectUtil;\n+\n+public class StompWebSocketChatServerInitializer extends ChannelInitializer<SocketChannel> {\n+\n+    private final String chatPath;\n+    private final StompWebSocketProtocolCodec stompWebSocketProtocolCodec;\n+\n+    public StompWebSocketChatServerInitializer(String chatPath) {\n+        this.chatPath = ObjectUtil.checkNotNull(chatPath, \"chatPath\");\n+        stompWebSocketProtocolCodec = new StompWebSocketProtocolCodec();\n+    }\n+\n+    @Override\n+    protected void initChannel(SocketChannel channel) throws Exception {\n+        channel.pipeline()\n+               .addLast(new HttpServerCodec())\n+               .addLast(new HttpObjectAggregator(65536))\n+               .addLast(StompWebSocketClientPageHandler.INSTANCE)\n+               .addLast(new WebSocketServerProtocolHandler(chatPath, StompVersion.SUB_PROTOCOLS))\n+               .addLast(\"stompWebSocketProtocolCodec\", stompWebSocketProtocolCodec);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwOTI1Ng==", "bodyText": "why explicit use voidPromise here ?", "url": "https://github.com/netty/netty/pull/10152#discussion_r402109256", "createdAt": "2020-04-02T07:36:34Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public final class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    private StompWebSocketClientPageHandler() {\n+    }\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content().writeCharSequence(payload, CharsetUtil.UTF_8);\n+            HttpUtil.setContentLength(notFound, notFound.content().readableBytes());\n+            sendResponse(notFound, ctx, true);\n+        }\n+    }\n+\n+    private static boolean sendResource(FullHttpRequest request, ChannelHandlerContext ctx) {\n+        String requestResource = request.uri().substring(1);\n+        if (requestResource.isEmpty()) {\n+            requestResource = \"index.html\";\n+        }\n+\n+        URL resourceUrl = INSTANCE.getClass().getResource(requestResource);\n+        if (resourceUrl == null) {\n+            return false;\n+        }\n+\n+        RandomAccessFile raf = null;\n+        long fileLength = -1L;\n+        try {\n+            raf = new RandomAccessFile(resourceUrl.getFile(), \"r\");\n+            fileLength = raf.length();\n+        } catch (IOException io) {\n+            System.out.println(\"File not found \" + io.getMessage());\n+            return false;\n+        } finally {\n+            if (fileLength < 0 && raf != null) {\n+                try {\n+                    raf.close();\n+                } catch (Exception io) {\n+                    // Nothing to do\n+                }\n+            }\n+        }\n+\n+        HttpResponse response = new DefaultHttpResponse(request.protocolVersion(), OK);\n+        HttpUtil.setContentLength(response, fileLength);\n+\n+        String contentType = \"application/octet-stream\";\n+        if (requestResource.endsWith(\"html\")) {\n+            contentType = \"text/html; charset=UTF-8\";\n+        } else if (requestResource.endsWith(\"css\")) {\n+            contentType = \"text/css; charset=UTF-8\";\n+        } else if (requestResource.endsWith(\"js\")) {\n+            contentType = \"application/javascript\";\n+        }\n+\n+        response.headers().set(CONTENT_TYPE, contentType);\n+        sendResponse(response, ctx, false);\n+        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.voidPromise());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwOTYzNA==", "bodyText": "why specify a name when adding to the pipeline ? Consider just not doing this", "url": "https://github.com/netty/netty/pull/10152#discussion_r402109634", "createdAt": "2020-04-02T07:37:24Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketProtocolCodec.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToMessageCodec;\n+import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\n+import io.netty.handler.codec.http.websocketx.WebSocketFrame;\n+import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\n+import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler.HandshakeComplete;\n+import io.netty.handler.codec.stomp.StompSubframeAggregator;\n+import io.netty.handler.codec.stomp.StompSubframeDecoder;\n+import io.netty.handler.codec.stomp.StompSubframeEncoder;\n+\n+import java.util.List;\n+\n+@Sharable\n+public class StompWebSocketProtocolCodec extends MessageToMessageCodec<WebSocketFrame, ByteBuf> {\n+\n+    private final StompChatHandler stompChatHandler = new StompChatHandler();\n+\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+        if (evt instanceof WebSocketServerProtocolHandler.HandshakeComplete) {\n+            StompVersion stompVersion = StompVersion.findBySubProtocol(((HandshakeComplete) evt).selectedSubprotocol());\n+            ctx.channel().attr(StompVersion.CHANNEL_ATTRIBUTE_KEY).set(stompVersion);\n+            String ctxName = ctx.name();\n+            ctx.pipeline()\n+               .addAfter(ctxName, \"stompChatHandler\", stompChatHandler)\n+               .addAfter(ctxName, \"stompAggregator\", new StompSubframeAggregator(65536))\n+               .addAfter(ctxName, \"stompEncoder\", new StompSubframeEncoder())\n+               .addAfter(ctxName, \"stompDecoder\", new StompSubframeDecoder())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMTU1Mg==", "bodyText": "IOException", "url": "https://github.com/netty/netty/pull/10152#discussion_r402111552", "createdAt": "2020-04-02T07:41:08Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public final class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    private StompWebSocketClientPageHandler() {\n+    }\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content().writeCharSequence(payload, CharsetUtil.UTF_8);\n+            HttpUtil.setContentLength(notFound, notFound.content().readableBytes());\n+            sendResponse(notFound, ctx, true);\n+        }\n+    }\n+\n+    private static boolean sendResource(FullHttpRequest request, ChannelHandlerContext ctx) {\n+        String requestResource = request.uri().substring(1);\n+        if (requestResource.isEmpty()) {\n+            requestResource = \"index.html\";\n+        }\n+\n+        URL resourceUrl = INSTANCE.getClass().getResource(requestResource);\n+        if (resourceUrl == null) {\n+            return false;\n+        }\n+\n+        RandomAccessFile raf = null;\n+        long fileLength = -1L;\n+        try {\n+            raf = new RandomAccessFile(resourceUrl.getFile(), \"r\");\n+            fileLength = raf.length();\n+        } catch (IOException io) {\n+            System.out.println(\"File not found \" + io.getMessage());\n+            return false;\n+        } finally {\n+            if (fileLength < 0 && raf != null) {\n+                try {\n+                    raf.close();\n+                } catch (Exception io) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMTc2Nw==", "bodyText": "Should this be FileNotFoundException ?", "url": "https://github.com/netty/netty/pull/10152#discussion_r402111767", "createdAt": "2020-04-02T07:41:36Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public final class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    private StompWebSocketClientPageHandler() {\n+    }\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content().writeCharSequence(payload, CharsetUtil.UTF_8);\n+            HttpUtil.setContentLength(notFound, notFound.content().readableBytes());\n+            sendResponse(notFound, ctx, true);\n+        }\n+    }\n+\n+    private static boolean sendResource(FullHttpRequest request, ChannelHandlerContext ctx) {\n+        String requestResource = request.uri().substring(1);\n+        if (requestResource.isEmpty()) {\n+            requestResource = \"index.html\";\n+        }\n+\n+        URL resourceUrl = INSTANCE.getClass().getResource(requestResource);\n+        if (resourceUrl == null) {\n+            return false;\n+        }\n+\n+        RandomAccessFile raf = null;\n+        long fileLength = -1L;\n+        try {\n+            raf = new RandomAccessFile(resourceUrl.getFile(), \"r\");\n+            fileLength = raf.length();\n+        } catch (IOException io) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMjMyMA==", "bodyText": "I think we need to check that !....uri().isEmpty() as otherwise it may produce an IndexOutOfBoundsException above.", "url": "https://github.com/netty/netty/pull/10152#discussion_r402112320", "createdAt": "2020-04-02T07:42:37Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompWebSocketClientPageHandler.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.DefaultFileRegion;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultHttpResponse;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.util.CharsetUtil;\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.net.URL;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.*;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.*;\n+import static io.netty.handler.codec.http.HttpResponseStatus.*;\n+import static io.netty.handler.codec.http.HttpVersion.*;\n+\n+@Sharable\n+public final class StompWebSocketClientPageHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n+\n+    static final StompWebSocketClientPageHandler INSTANCE = new StompWebSocketClientPageHandler();\n+\n+    private StompWebSocketClientPageHandler() {\n+    }\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n+        if (request.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true)) {\n+            ctx.fireChannelRead(request.retain());\n+            return;\n+        }\n+\n+        if (!sendResource(request, ctx)) {\n+            FullHttpResponse notFound = new DefaultFullHttpResponse(request.protocolVersion(), NOT_FOUND);\n+            notFound.headers().set(CONTENT_TYPE, TEXT_PLAIN);\n+            String payload = \"Requested resource \" + request.uri() + \" not found\";\n+            notFound.content().writeCharSequence(payload, CharsetUtil.UTF_8);\n+            HttpUtil.setContentLength(notFound, notFound.content().readableBytes());\n+            sendResponse(notFound, ctx, true);\n+        }\n+    }\n+\n+    private static boolean sendResource(FullHttpRequest request, ChannelHandlerContext ctx) {\n+        String requestResource = request.uri().substring(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbd8bbce1f28e0f0cf542ec207e25503d6ca6ef9"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef5934ba9b6037941159f0c72605e5e0fb17886b", "author": {"user": {"login": "amizurov", "name": "Andrey Mizurov"}}, "url": "https://github.com/netty/netty/commit/ef5934ba9b6037941159f0c72605e5e0fb17886b", "committedDate": "2020-04-02T14:09:36Z", "message": "Fix PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NDcwNTk3", "url": "https://github.com/netty/netty/pull/10152#pullrequestreview-386470597", "createdAt": "2020-04-02T14:16:45Z", "commit": {"oid": "ef5934ba9b6037941159f0c72605e5e0fb17886b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDoxNjo0NVrOF_tX4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDoxNjo0NVrOF_tX4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM0ODAwMA==", "bodyText": "hmm... shouldn't this also take the destination somehow into account to match StompSubscription.equals(...) ?", "url": "https://github.com/netty/netty/pull/10152#discussion_r402348000", "createdAt": "2020-04-02T14:16:45Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/stomp/websocket/StompChatHandler.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.example.stomp.websocket;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.DecoderResult;\n+import io.netty.handler.codec.stomp.DefaultStompFrame;\n+import io.netty.handler.codec.stomp.StompCommand;\n+import io.netty.handler.codec.stomp.StompFrame;\n+import io.netty.util.CharsetUtil;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static io.netty.handler.codec.stomp.StompHeaders.*;\n+\n+@Sharable\n+public class StompChatHandler extends SimpleChannelInboundHandler<StompFrame> {\n+\n+    private final ConcurrentMap<String, Set<StompSubscription>> chatDestinations =\n+            new ConcurrentHashMap<String, Set<StompSubscription>>();\n+\n+    @Override\n+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame inboundFrame) throws Exception {\n+        DecoderResult decoderResult = inboundFrame.decoderResult();\n+        if (decoderResult.isFailure()) {\n+            sendErrorFrame(\"rejected frame\", decoderResult.toString(), ctx);\n+            return;\n+        }\n+\n+        switch (inboundFrame.command()) {\n+        case STOMP:\n+        case CONNECT:\n+            onConnect(ctx, inboundFrame);\n+            break;\n+        case SUBSCRIBE:\n+            onSubscribe(ctx, inboundFrame);\n+            break;\n+        case SEND:\n+            onSend(ctx, inboundFrame);\n+            break;\n+        case UNSUBSCRIBE:\n+            onUnsubscribe(ctx, inboundFrame);\n+            break;\n+        case DISCONNECT:\n+            onDisconnect(ctx, inboundFrame);\n+            break;\n+        default:\n+            sendErrorFrame(\"unsupported command\",\n+                           \"Received unsupported command \" + inboundFrame.command(), ctx);\n+        }\n+    }\n+\n+    private void onSubscribe(ChannelHandlerContext ctx, StompFrame inboundFrame) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        String subscriptionId = inboundFrame.headers().getAsString(ID);\n+\n+        if (destination == null || subscriptionId == null) {\n+            sendErrorFrame(\"missed header\", \"Required 'destination' or 'id' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = chatDestinations.get(destination);\n+        if (subscriptions == null) {\n+            subscriptions = new HashSet<StompSubscription>();\n+            Set<StompSubscription> previousSubscriptions = chatDestinations.putIfAbsent(destination, subscriptions);\n+            if (previousSubscriptions != null) {\n+                subscriptions = previousSubscriptions;\n+            }\n+        }\n+\n+        final StompSubscription subscription = new StompSubscription(subscriptionId, destination, ctx.channel());\n+        if (subscriptions.contains(subscription)) {\n+            sendErrorFrame(\"duplicate subscription\",\n+                           \"Received duplicate subscription id=\" + subscriptionId, ctx);\n+            return;\n+        }\n+\n+        subscriptions.add(subscription);\n+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) {\n+                chatDestinations.get(subscription.destination()).remove(subscription);\n+            }\n+        });\n+\n+        String receiptId = inboundFrame.headers().getAsString(RECEIPT);\n+        if (receiptId != null) {\n+            StompFrame receiptFrame = new DefaultStompFrame(StompCommand.RECEIPT);\n+            receiptFrame.headers().set(RECEIPT_ID, receiptId);\n+            ctx.writeAndFlush(receiptFrame);\n+        }\n+    }\n+\n+    private void onSend(ChannelHandlerContext ctx, StompFrame inboundFrame) {\n+        String destination = inboundFrame.headers().getAsString(DESTINATION);\n+        if (destination == null) {\n+            sendErrorFrame(\"missed header\", \"required 'destination' header missed\", ctx);\n+            return;\n+        }\n+\n+        Set<StompSubscription> subscriptions = chatDestinations.get(destination);\n+        for (StompSubscription subscription : subscriptions) {\n+            subscription.channel().writeAndFlush(transformToMessage(inboundFrame, subscription));\n+        }\n+    }\n+\n+    private void onUnsubscribe(ChannelHandlerContext ctx, StompFrame inboundFrame) {\n+        String subscriptionId = inboundFrame.headers().getAsString(SUBSCRIPTION);\n+        for (Entry<String, Set<StompSubscription>> entry : chatDestinations.entrySet()) {\n+            Iterator<StompSubscription> iterator = entry.getValue().iterator();\n+            while (iterator.hasNext()) {\n+                StompSubscription subscription = iterator.next();\n+                if (subscription.id().equals(subscriptionId) && subscription.channel().equals(ctx.channel())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef5934ba9b6037941159f0c72605e5e0fb17886b"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a0c78bab4a356d879e4f63fad73d5ffffc537ae", "author": {"user": {"login": "amizurov", "name": "Andrey Mizurov"}}, "url": "https://github.com/netty/netty/commit/3a0c78bab4a356d879e4f63fad73d5ffffc537ae", "committedDate": "2020-04-02T14:58:59Z", "message": "Fix checkstyle violation"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 222, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}