{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NTc1OTIw", "number": 10337, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzoxOTo0MlrOEB17sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzoxOTo0MlrOEB17sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMzY3NjY1OnYy", "diffSide": "RIGHT", "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzoxOTo0MlrOGd77Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzoxOTo0MlrOGd77Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MzY5MA==", "bodyText": "Consider the opposite approach: write a utility method that will wrap only if it's not an instance of RedirectAuthoritativeDnsServerCache. That will help to avoid allocation of a new object when it's already wrapped.", "url": "https://github.com/netty/netty/pull/10337#discussion_r434043690", "createdAt": "2020-06-02T17:19:42Z", "author": {"login": "idelpivnitskiy"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -498,34 +498,49 @@ public void operationComplete(final Future<List<InetAddress>> future) {\n                 }\n             }\n         });\n-        if (!DnsNameResolver.doResolveAllCached(nameServerName, additionals, resolverPromise, resolveCache(),\n+        DnsCache resolveCache = resolveCache();\n+        if (!DnsNameResolver.doResolveAllCached(nameServerName, additionals, resolverPromise, resolveCache,\n                 parent.resolvedInternetProtocolFamiliesUnsafe())) {\n-            final AuthoritativeDnsServerCache authoritativeDnsServerCache = authoritativeDnsServerCache();\n             new DnsAddressResolveContext(parent, originalPromise, nameServerName, additionals,\n-                                         parent.newNameServerAddressStream(nameServerName),\n-                                         resolveCache(), new AuthoritativeDnsServerCache() {\n-                @Override\n-                public DnsServerAddressStream get(String hostname) {\n-                    // To not risk falling into any loop, we will not use the cache while following redirects but only\n-                    // on the initial query.\n-                    return null;\n-                }\n+                                         parent.newNameServerAddressStream(nameServerName), resolveCache,\n+                                         new RedirectAuthoritativeDnsServerCache(authoritativeDnsServerCache()), false)\n+                    .resolve(resolverPromise);\n+        }\n+    }\n \n-                @Override\n-                public void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop) {\n-                    authoritativeDnsServerCache.cache(hostname, address, originalTtl, loop);\n-                }\n+    private static final class RedirectAuthoritativeDnsServerCache implements AuthoritativeDnsServerCache {\n+        private final AuthoritativeDnsServerCache wrapped;\n \n-                @Override\n-                public void clear() {\n-                    authoritativeDnsServerCache.clear();\n-                }\n+        RedirectAuthoritativeDnsServerCache(AuthoritativeDnsServerCache authoritativeDnsServerCache) {\n+            // Unwrap to prevent the possibility of an StackOverflowError when wrapping another\n+            // RedirectAuthoritativeDnsServerCache.\n+            if (authoritativeDnsServerCache instanceof RedirectAuthoritativeDnsServerCache) {\n+                this.wrapped = ((RedirectAuthoritativeDnsServerCache) authoritativeDnsServerCache).wrapped;\n+            } else {\n+                this.wrapped = authoritativeDnsServerCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a59f507f325c3a27fdbffd8a4aca1293d1ae648"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3807, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}