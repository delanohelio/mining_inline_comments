{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTE3MzQ1", "number": 10826, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo1MTo1MFrOE9Shmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMToyMzo0MVrOE-VPTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzAyMTA2OnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo1MTo1MFrOH55nUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo1MTo1MFrOH55nUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDgzNA==", "bodyText": "Do we need to also shrink the internal storage at some point ?", "url": "https://github.com/netty/netty/pull/10826#discussion_r530474834", "createdAt": "2020-11-25T15:51:50Z", "author": {"login": "normanmaurer"}, "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -643,4 +638,161 @@ static boolean isSubpage(long handle) {\n     static int bitmapIdx(long handle) {\n         return (int) handle;\n     }\n+\n+    private static final class LongLongHashMap {\n+        private static final int MAX_PROBE = 4;\n+        private int mask = 31;\n+        private long[] array = new long[mask + 1];\n+        private long zeroVal;\n+\n+        public long put(long key, long value) {\n+            if (key == 0) {\n+                long prev = zeroVal;\n+                zeroVal = value;\n+                return prev;\n+            }\n+\n+            for (;;) {\n+                int index = index(key);\n+                for (int i = 0; i < MAX_PROBE; i++) {\n+                    long existing = array[index];\n+                    if (existing == key || existing == 0) {\n+                        long prev = array[index + 1];\n+                        array[index] = key;\n+                        array[index + 1] = value;\n+                        return prev;\n+                    }\n+                    index = index + 2 & mask;\n+                }\n+                expand(); // Grow array and re-hash.\n+            }\n+        }\n+\n+        public void remove(long key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzAyMzM5OnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo1MjoxNlrOH55oqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo1MjoxNlrOH55oqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NTE3Ng==", "bodyText": "Do we also need to shrink the internal storage at some point ?", "url": "https://github.com/netty/netty/pull/10826#discussion_r530475176", "createdAt": "2020-11-25T15:52:16Z", "author": {"login": "normanmaurer"}, "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -643,4 +638,161 @@ static boolean isSubpage(long handle) {\n     static int bitmapIdx(long handle) {\n         return (int) handle;\n     }\n+\n+    private static final class LongLongHashMap {\n+        private static final int MAX_PROBE = 4;\n+        private int mask = 31;\n+        private long[] array = new long[mask + 1];\n+        private long zeroVal;\n+\n+        public long put(long key, long value) {\n+            if (key == 0) {\n+                long prev = zeroVal;\n+                zeroVal = value;\n+                return prev;\n+            }\n+\n+            for (;;) {\n+                int index = index(key);\n+                for (int i = 0; i < MAX_PROBE; i++) {\n+                    long existing = array[index];\n+                    if (existing == key || existing == 0) {\n+                        long prev = array[index + 1];\n+                        array[index] = key;\n+                        array[index + 1] = value;\n+                        return prev;\n+                    }\n+                    index = index + 2 & mask;\n+                }\n+                expand(); // Grow array and re-hash.\n+            }\n+        }\n+\n+        public void remove(long key) {\n+            if (key == 0) {\n+                zeroVal = 0;\n+                return;\n+            }\n+            int index = index(key);\n+            for (int i = 0; i < MAX_PROBE; i++) {\n+                long existing = array[index];\n+                if (existing == key) {\n+                    array[index] = 0;\n+                    array[index + 1] = 0;\n+                    break;\n+                }\n+                index = index + 2 & mask;\n+            }\n+        }\n+\n+        public long get(long key) {\n+            if (key == 0) {\n+                return zeroVal;\n+            }\n+            int index = index(key);\n+            for (int i = 0; i < MAX_PROBE; i++) {\n+                long existing = array[index];\n+                if (existing == key) {\n+                    return array[index + 1];\n+                }\n+                index = index + 2 & mask;\n+            }\n+            return -1;\n+        }\n+\n+        private int index(long key) {\n+            return (int) (key << 1 & mask);\n+        }\n+\n+        private void expand() {\n+            long[] prev = array;\n+            int newSize = prev.length * 2;\n+            mask = newSize - 1;\n+            array = new long[newSize];\n+            for (int i = 0; i < prev.length >> 1; i += 2) {\n+                long key = prev[i];\n+                long val = prev[i + 1];\n+                put(key, val);\n+            }\n+        }\n+    }\n+\n+    private static final class LongPriorityQueue {\n+        private long[] array = new long[9];\n+        private int size;\n+\n+        public void offer(long handle) {\n+            size++;\n+            if (size == array.length) {\n+                // Grow queue capacity.\n+                array = Arrays.copyOf(array, 1 + (array.length - 1) * 2);\n+            }\n+            array[size] = handle;\n+            lift();\n+        }\n+\n+        public void remove(long value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzE3MTQ1OnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjoyNDoyNVrOH57B7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjoyNDoyNVrOH57B7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5ODAzMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (nextRun == 0) {\n          \n          \n            \n                        if (nextRun == -1) {\n          \n      \n    \n    \n  \n\n== 0 seems like a bug", "url": "https://github.com/netty/netty/pull/10826#discussion_r530498030", "createdAt": "2020-11-25T16:24:25Z", "author": {"login": "normanmaurer"}, "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -531,8 +526,8 @@ private long collapseNext(long handle) {\n             int runOffset = runOffset(handle);\n             int runPages = runPages(handle);\n \n-            Long nextRun = getAvailRunByOffset(runOffset + runPages);\n-            if (nextRun == null) {\n+            long nextRun = getAvailRunByOffset(runOffset + runPages);\n+            if (nextRun == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzE3NDI5OnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjoyNTowNFrOH57Drw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjoyNTowNFrOH57Drw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5ODQ3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (pastRun == 0) {\n          \n          \n            \n                        if (pastRun == -1) {\n          \n      \n    \n    \n  \n\n== 0 seems incorrect", "url": "https://github.com/netty/netty/pull/10826#discussion_r530498479", "createdAt": "2020-11-25T16:25:04Z", "author": {"login": "normanmaurer"}, "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -507,8 +502,8 @@ private long collapsePast(long handle) {\n             int runOffset = runOffset(handle);\n             int runPages = runPages(handle);\n \n-            Long pastRun = getAvailRunByOffset(runOffset - 1);\n-            if (pastRun == null) {\n+            long pastRun = getAvailRunByOffset(runOffset - 1);\n+            if (pastRun == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzE4MDM4OnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjoyNjoyMlrOH57HfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjoyNzozNVrOH57K3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTQ1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            return 0;\n          \n          \n            \n                            return -1;\n          \n      \n    \n    \n  \n\nI think -1 is better as 0 is a valid value for offer", "url": "https://github.com/netty/netty/pull/10826#discussion_r530499452", "createdAt": "2020-11-25T16:26:22Z", "author": {"login": "normanmaurer"}, "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -643,4 +638,161 @@ static boolean isSubpage(long handle) {\n     static int bitmapIdx(long handle) {\n         return (int) handle;\n     }\n+\n+    private static final class LongLongHashMap {\n+        private static final int MAX_PROBE = 4;\n+        private int mask = 31;\n+        private long[] array = new long[mask + 1];\n+        private long zeroVal;\n+\n+        public long put(long key, long value) {\n+            if (key == 0) {\n+                long prev = zeroVal;\n+                zeroVal = value;\n+                return prev;\n+            }\n+\n+            for (;;) {\n+                int index = index(key);\n+                for (int i = 0; i < MAX_PROBE; i++) {\n+                    long existing = array[index];\n+                    if (existing == key || existing == 0) {\n+                        long prev = array[index + 1];\n+                        array[index] = key;\n+                        array[index + 1] = value;\n+                        return prev;\n+                    }\n+                    index = index + 2 & mask;\n+                }\n+                expand(); // Grow array and re-hash.\n+            }\n+        }\n+\n+        public void remove(long key) {\n+            if (key == 0) {\n+                zeroVal = 0;\n+                return;\n+            }\n+            int index = index(key);\n+            for (int i = 0; i < MAX_PROBE; i++) {\n+                long existing = array[index];\n+                if (existing == key) {\n+                    array[index] = 0;\n+                    array[index + 1] = 0;\n+                    break;\n+                }\n+                index = index + 2 & mask;\n+            }\n+        }\n+\n+        public long get(long key) {\n+            if (key == 0) {\n+                return zeroVal;\n+            }\n+            int index = index(key);\n+            for (int i = 0; i < MAX_PROBE; i++) {\n+                long existing = array[index];\n+                if (existing == key) {\n+                    return array[index + 1];\n+                }\n+                index = index + 2 & mask;\n+            }\n+            return -1;\n+        }\n+\n+        private int index(long key) {\n+            return (int) (key << 1 & mask);\n+        }\n+\n+        private void expand() {\n+            long[] prev = array;\n+            int newSize = prev.length * 2;\n+            mask = newSize - 1;\n+            array = new long[newSize];\n+            for (int i = 0; i < prev.length >> 1; i += 2) {\n+                long key = prev[i];\n+                long val = prev[i + 1];\n+                put(key, val);\n+            }\n+        }\n+    }\n+\n+    private static final class LongPriorityQueue {\n+        private long[] array = new long[9];\n+        private int size;\n+\n+        public void offer(long handle) {\n+            size++;\n+            if (size == array.length) {\n+                // Grow queue capacity.\n+                array = Arrays.copyOf(array, 1 + (array.length - 1) * 2);\n+            }\n+            array[size] = handle;\n+            lift();\n+        }\n+\n+        public void remove(long value) {\n+            for (int i = 1; i <= size; i++) {\n+                if (array[i] == value) {\n+                    if (i == size) {\n+                        array[i] = 0;\n+                    } else {\n+                        array[i] = array[size];\n+                        sink(i);\n+                    }\n+                    size--;\n+                    return;\n+                }\n+            }\n+        }\n+\n+        public long poll() {\n+            if (size == 0) {\n+                return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwMDMxNw==", "bodyText": "If we do this change we also need to adjust a few other places that check for == 0", "url": "https://github.com/netty/netty/pull/10826#discussion_r530500317", "createdAt": "2020-11-25T16:27:35Z", "author": {"login": "normanmaurer"}, "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -643,4 +638,161 @@ static boolean isSubpage(long handle) {\n     static int bitmapIdx(long handle) {\n         return (int) handle;\n     }\n+\n+    private static final class LongLongHashMap {\n+        private static final int MAX_PROBE = 4;\n+        private int mask = 31;\n+        private long[] array = new long[mask + 1];\n+        private long zeroVal;\n+\n+        public long put(long key, long value) {\n+            if (key == 0) {\n+                long prev = zeroVal;\n+                zeroVal = value;\n+                return prev;\n+            }\n+\n+            for (;;) {\n+                int index = index(key);\n+                for (int i = 0; i < MAX_PROBE; i++) {\n+                    long existing = array[index];\n+                    if (existing == key || existing == 0) {\n+                        long prev = array[index + 1];\n+                        array[index] = key;\n+                        array[index + 1] = value;\n+                        return prev;\n+                    }\n+                    index = index + 2 & mask;\n+                }\n+                expand(); // Grow array and re-hash.\n+            }\n+        }\n+\n+        public void remove(long key) {\n+            if (key == 0) {\n+                zeroVal = 0;\n+                return;\n+            }\n+            int index = index(key);\n+            for (int i = 0; i < MAX_PROBE; i++) {\n+                long existing = array[index];\n+                if (existing == key) {\n+                    array[index] = 0;\n+                    array[index + 1] = 0;\n+                    break;\n+                }\n+                index = index + 2 & mask;\n+            }\n+        }\n+\n+        public long get(long key) {\n+            if (key == 0) {\n+                return zeroVal;\n+            }\n+            int index = index(key);\n+            for (int i = 0; i < MAX_PROBE; i++) {\n+                long existing = array[index];\n+                if (existing == key) {\n+                    return array[index + 1];\n+                }\n+                index = index + 2 & mask;\n+            }\n+            return -1;\n+        }\n+\n+        private int index(long key) {\n+            return (int) (key << 1 & mask);\n+        }\n+\n+        private void expand() {\n+            long[] prev = array;\n+            int newSize = prev.length * 2;\n+            mask = newSize - 1;\n+            array = new long[newSize];\n+            for (int i = 0; i < prev.length >> 1; i += 2) {\n+                long key = prev[i];\n+                long val = prev[i + 1];\n+                put(key, val);\n+            }\n+        }\n+    }\n+\n+    private static final class LongPriorityQueue {\n+        private long[] array = new long[9];\n+        private int size;\n+\n+        public void offer(long handle) {\n+            size++;\n+            if (size == array.length) {\n+                // Grow queue capacity.\n+                array = Arrays.copyOf(array, 1 + (array.length - 1) * 2);\n+            }\n+            array[size] = handle;\n+            lift();\n+        }\n+\n+        public void remove(long value) {\n+            for (int i = 1; i <= size; i++) {\n+                if (array[i] == value) {\n+                    if (i == size) {\n+                        array[i] = 0;\n+                    } else {\n+                        array[i] = array[size];\n+                        sink(i);\n+                    }\n+                    size--;\n+                    return;\n+                }\n+            }\n+        }\n+\n+        public long poll() {\n+            if (size == 0) {\n+                return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5OTQ1Mg=="}, "originalCommit": {"oid": "718f29c4d43a962c79faaef7f3a443ff5a90bb2b"}, "originalPosition": 263}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTQ5NjA2OnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/PoolArena.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoyMTo1OFrOH6jY1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxODowMDowNFrOH6kPvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1OTI1Mw==", "bodyText": "let's put a proper assert with monitor check", "url": "https://github.com/netty/netty/pull/10826#discussion_r531159253", "createdAt": "2020-11-26T17:21:58Z", "author": {"login": "franz1981"}, "path": "buffer/src/main/java/io/netty/buffer/PoolArena.java", "diffHunk": "@@ -190,7 +190,7 @@ private void tcacheAllocateNormal(PoolThreadCache cache, PooledByteBuf<T> buf, f\n         }\n     }\n \n-    // Method must be called inside synchronized(this) { ... }\u00a0block\n+    // Method must be called inside synchronized(this) { ... } block", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee73dfc355359fae184a9e5a6d9afdeca6933640"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE3MzMwOA==", "bodyText": "Lets do this as a follow up as its not related to the PR", "url": "https://github.com/netty/netty/pull/10826#discussion_r531173308", "createdAt": "2020-11-26T18:00:04Z", "author": {"login": "normanmaurer"}, "path": "buffer/src/main/java/io/netty/buffer/PoolArena.java", "diffHunk": "@@ -190,7 +190,7 @@ private void tcacheAllocateNormal(PoolThreadCache cache, PooledByteBuf<T> buf, f\n         }\n     }\n \n-    // Method must be called inside synchronized(this) { ... }\u00a0block\n+    // Method must be called inside synchronized(this) { ... } block", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1OTI1Mw=="}, "originalCommit": {"oid": "ee73dfc355359fae184a9e5a6d9afdeca6933640"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTYwMjA1OnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxODowMzozMVrOH6kUVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxODowMzozMVrOH6kUVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE3NDQ4Ng==", "bodyText": "what is the reason for returning 0 and not -1 here ? IMHO -1 would be what I expect for a non existing key as handles will always be positive.", "url": "https://github.com/netty/netty/pull/10826#discussion_r531174486", "createdAt": "2020-11-26T18:03:31Z", "author": {"login": "normanmaurer"}, "path": "buffer/src/main/java/io/netty/buffer/PoolChunk.java", "diffHunk": "@@ -245,18 +239,18 @@ private void insertAvailRun(int runOffset, int pages, Long handle) {\n         }\n     }\n \n-    private void insertAvailRun0(int runOffset, Long handle) {\n-        Long pre = runsAvailMap.put(runOffset, handle);\n-        assert pre == null;\n+    private void insertAvailRun0(int runOffset, long handle) {\n+        long pre = runsAvailMap.put(runOffset, handle);\n+        assert pre == 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee73dfc355359fae184a9e5a6d9afdeca6933640"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNzkzOTExOnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMTowNTo0MlrOH7eZ-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMDoyMToyOVrOH70cnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjIwMA==", "bodyText": "Curious why the special handling of key 0?", "url": "https://github.com/netty/netty/pull/10826#discussion_r532126200", "createdAt": "2020-11-29T01:05:42Z", "author": {"login": "njhill"}, "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+/**\n+ * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link\n+ * PoolChunk}.\n+ */\n+final class LongLongHashMap {\n+    private static final int MASK_TEMPLATE = ~1;\n+    private int mask;\n+    private long[] array;\n+    private int maxProbe;\n+    private long zeroVal;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "584552c2b33f952131abc9702c65c6651d98adad"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ4NzMyNQ==", "bodyText": "Zero is used as a marker in the array, that an entry is unused. So we need to handle them specially because those keys cannot be stored in the array.", "url": "https://github.com/netty/netty/pull/10826#discussion_r532487325", "createdAt": "2020-11-30T10:21:29Z", "author": {"login": "chrisvest"}, "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+/**\n+ * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link\n+ * PoolChunk}.\n+ */\n+final class LongLongHashMap {\n+    private static final int MASK_TEMPLATE = ~1;\n+    private int mask;\n+    private long[] array;\n+    private int maxProbe;\n+    private long zeroVal;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjIwMA=="}, "originalCommit": {"oid": "584552c2b33f952131abc9702c65c6651d98adad"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNzk0MDk3OnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMTowODozOFrOH7eayA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMTowODozOFrOH7eayA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjQwOA==", "bodyText": "Since this is special purpose how about just hard-coding this to -1? Might allow bit more compiler optimization (non-static final is untrusted)", "url": "https://github.com/netty/netty/pull/10826#discussion_r532126408", "createdAt": "2020-11-29T01:08:38Z", "author": {"login": "njhill"}, "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+/**\n+ * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link\n+ * PoolChunk}.\n+ */\n+final class LongLongHashMap {\n+    private static final int MASK_TEMPLATE = ~1;\n+    private int mask;\n+    private long[] array;\n+    private int maxProbe;\n+    private long zeroVal;\n+    private final long emptyVal;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "584552c2b33f952131abc9702c65c6651d98adad"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNzk0OTc4OnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMToyMToyMFrOH7eemw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMToyMToyMFrOH7eemw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNzM4Nw==", "bodyText": "nit: no need for var", "url": "https://github.com/netty/netty/pull/10826#discussion_r532127387", "createdAt": "2020-11-29T01:21:20Z", "author": {"login": "njhill"}, "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+/**\n+ * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link\n+ * PoolChunk}.\n+ */\n+final class LongLongHashMap {\n+    private static final int MASK_TEMPLATE = ~1;\n+    private int mask;\n+    private long[] array;\n+    private int maxProbe;\n+    private long zeroVal;\n+    private final long emptyVal;\n+\n+    LongLongHashMap(long emptyVal) {\n+        this.emptyVal = emptyVal;\n+        zeroVal = emptyVal;\n+        int initialSize = 32;\n+        array = new long[initialSize];\n+        mask = initialSize - 1;\n+        computeMaskAndProbe();\n+    }\n+\n+    public long put(long key, long value) {\n+        if (key == 0) {\n+            long prev = zeroVal;\n+            zeroVal = value;\n+            return prev;\n+        }\n+\n+        for (;;) {\n+            int index = index(key);\n+            for (int i = 0; i < maxProbe; i++) {\n+                long existing = array[index];\n+                if (existing == key || existing == 0) {\n+                    long prev = existing == 0? emptyVal : array[index + 1];\n+                    array[index] = key;\n+                    array[index + 1] = value;\n+                    for (; i < maxProbe; i++) { // Nerf any existing misplaced entries.\n+                        index = index + 2 & mask;\n+                        if (array[index] == key) {\n+                            array[index] = 0;\n+                            prev = array[index + 1];\n+                            break;\n+                        }\n+                    }\n+                    return prev;\n+                }\n+                index = index + 2 & mask;\n+            }\n+            expand(); // Grow array and re-hash.\n+        }\n+    }\n+\n+    public void remove(long key) {\n+        if (key == 0) {\n+            zeroVal = emptyVal;\n+            return;\n+        }\n+        int index = index(key);\n+        for (int i = 0; i < maxProbe; i++) {\n+            long existing = array[index];\n+            if (existing == key) {\n+                array[index] = 0;\n+                break;\n+            }\n+            index = index + 2 & mask;\n+        }\n+    }\n+\n+    public long get(long key) {\n+        if (key == 0) {\n+            return zeroVal;\n+        }\n+        int index = index(key);\n+        for (int i = 0; i < maxProbe; i++) {\n+            long existing = array[index];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "584552c2b33f952131abc9702c65c6651d98adad"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNzk1MTUxOnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwMToyMzo0MVrOH7efYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMDoyMjoyNVrOH70fKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNzU4Nw==", "bodyText": "How about filling the array with -1 here ... could eliminate some branches in the other methods", "url": "https://github.com/netty/netty/pull/10826#discussion_r532127587", "createdAt": "2020-11-29T01:23:41Z", "author": {"login": "njhill"}, "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+/**\n+ * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link\n+ * PoolChunk}.\n+ */\n+final class LongLongHashMap {\n+    private static final int MASK_TEMPLATE = ~1;\n+    private int mask;\n+    private long[] array;\n+    private int maxProbe;\n+    private long zeroVal;\n+    private final long emptyVal;\n+\n+    LongLongHashMap(long emptyVal) {\n+        this.emptyVal = emptyVal;\n+        zeroVal = emptyVal;\n+        int initialSize = 32;\n+        array = new long[initialSize];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "584552c2b33f952131abc9702c65c6651d98adad"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ4Nzk3OA==", "bodyText": "Branch predictors are really good these days. Meanwhile, initialising an array is not free, and would happen at resize events where we already have a spike in service time. So I think this is a better trade off.", "url": "https://github.com/netty/netty/pull/10826#discussion_r532487978", "createdAt": "2020-11-30T10:22:25Z", "author": {"login": "chrisvest"}, "path": "buffer/src/main/java/io/netty/buffer/LongLongHashMap.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+/**\n+ * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link\n+ * PoolChunk}.\n+ */\n+final class LongLongHashMap {\n+    private static final int MASK_TEMPLATE = ~1;\n+    private int mask;\n+    private long[] array;\n+    private int maxProbe;\n+    private long zeroVal;\n+    private final long emptyVal;\n+\n+    LongLongHashMap(long emptyVal) {\n+        this.emptyVal = emptyVal;\n+        zeroVal = emptyVal;\n+        int initialSize = 32;\n+        array = new long[initialSize];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNzU4Nw=="}, "originalCommit": {"oid": "584552c2b33f952131abc9702c65c6651d98adad"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3554, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}