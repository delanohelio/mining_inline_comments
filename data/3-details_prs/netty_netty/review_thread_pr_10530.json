{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4Nzg4MjE1", "number": 10530, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODozOTo1NFrOEgHMUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDowNTozNFrOEpwqOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTA3NzI4OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODozOTo1NFrOHMzE5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODozOTo1NFrOHMzE5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MTc5OQ==", "bodyText": "nit: ;;", "url": "https://github.com/netty/netty/pull/10530#discussion_r483181799", "createdAt": "2020-09-03T18:39:54Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTA3ODc3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0MDoxOVrOHMzFvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0MDoxOVrOHMzFvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MjAxNQ==", "bodyText": "nit: you can remove the else", "url": "https://github.com/netty/netty/pull/10530#discussion_r483182015", "createdAt": "2020-09-03T18:40:19Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTA4NDY1OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0MjowN1rOHMzJdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0MjowN1rOHMzJdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4Mjk2NA==", "bodyText": "nit: merge with above line", "url": "https://github.com/netty/netty/pull/10530#discussion_r483182964", "createdAt": "2020-09-03T18:42:07Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {\n+                    attribute = attributes.get(key);\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+            } else {\n+                attribute = attributes.putIfAbsent(key, newAttribute);\n+                if (attribute == null) {\n+                    return newAttribute;\n                 }\n-                curr = next;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n             // no attribute exists\n             return false;\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n-\n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        return attribute != null & !attribute.removed();\n     }\n \n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes,\n+                         AttributeKey<T> key) {\n+            this.attributes = attributes;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTA4NTcwOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0MjoyN1rOHMzKFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0MjoyN1rOHMzKFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MzEyNQ==", "bodyText": "nit: merge with above line", "url": "https://github.com/netty/netty/pull/10530#discussion_r483183125", "createdAt": "2020-09-03T18:42:27Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {\n+                    attribute = attributes.get(key);\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+            } else {\n+                attribute = attributes.putIfAbsent(key, newAttribute);\n+                if (attribute == null) {\n+                    return newAttribute;\n                 }\n-                curr = next;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n             // no attribute exists\n             return false;\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n-\n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        return attribute != null & !attribute.removed();\n     }\n \n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes,\n+                         AttributeKey<T> key) {\n+            this.attributes = attributes;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+        }\n+\n+        @Override\n+        public T getAndSet(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return null;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTA4Njc5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0Mjo1MFrOHMzKxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0Mjo1MFrOHMzKxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MzMwMA==", "bodyText": "nit: merge with above line", "url": "https://github.com/netty/netty/pull/10530#discussion_r483183300", "createdAt": "2020-09-03T18:42:50Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {\n+                    attribute = attributes.get(key);\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+            } else {\n+                attribute = attributes.putIfAbsent(key, newAttribute);\n+                if (attribute == null) {\n+                    return newAttribute;\n                 }\n-                curr = next;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n             // no attribute exists\n             return false;\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n-\n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        return attribute != null & !attribute.removed();\n     }\n \n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes,\n+                         AttributeKey<T> key) {\n+            this.attributes = attributes;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+        }\n+\n+        @Override\n+        public T getAndSet(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return null;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+            return (T) old;\n         }\n \n         @Override\n         public T setIfAbsent(T value) {\n-            while (!compareAndSet(null, value)) {\n-                T old = get();\n+            do {\n+                final Object old = this.value;\n                 if (old != null) {\n-                    return old;\n+                    if (old == REMOVED) {\n+                        // a subsequent get should return null regardless the current value\n+                        // given that remove has been called\n+                        return null;\n+                    }\n+                    return (T) old;\n                 }\n             }\n+            while (!compareAndSet(null, value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDY1NTcxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjozMjoyNVrOHNUspA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjozMjoyNVrOHNUspA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMjY0NA==", "bodyText": "nit: could inline", "url": "https://github.com/netty/netty/pull/10530#discussion_r483732644", "createdAt": "2020-09-04T16:32:25Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDY1NjgzOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjozMjozOVrOHNUtUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjozMjozOVrOHNUtUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMjgxOA==", "bodyText": "nit: inline", "url": "https://github.com/netty/netty/pull/10530#discussion_r483732818", "createdAt": "2020-09-04T16:32:39Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();\n+            } else {\n+                DefaultAttribute attribute1 = (DefaultAttribute) t1;\n+                keyId = attribute1.key.id();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDY2MDIxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjozMzoyMlrOHNUvUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjo0Mjo1N1rOHNVK_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMzMzMQ==", "bodyText": "nit: return Integer.compare(attributeKeyId, keyId);", "url": "https://github.com/netty/netty/pull/10530#discussion_r483733331", "createdAt": "2020-09-04T16:33:22Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();\n+            } else {\n+                DefaultAttribute attribute1 = (DefaultAttribute) t1;\n+                keyId = attribute1.key.id();\n+            }\n+            return attributeKeyId < keyId? -1 : (attributeKeyId == keyId? 0 : 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczODMyMQ==", "bodyText": "Netty 4 won't allow java 8 specific methods", "url": "https://github.com/netty/netty/pull/10530#discussion_r483738321", "createdAt": "2020-09-04T16:39:42Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();\n+            } else {\n+                DefaultAttribute attribute1 = (DefaultAttribute) t1;\n+                keyId = attribute1.key.id();\n+            }\n+            return attributeKeyId < keyId? -1 : (attributeKeyId == keyId? 0 : 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMzMzMQ=="}, "originalCommit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0MDQxNA==", "bodyText": "ah \ud83d\udc4d good point", "url": "https://github.com/netty/netty/pull/10530#discussion_r483740414", "createdAt": "2020-09-04T16:42:57Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();\n+            } else {\n+                DefaultAttribute attribute1 = (DefaultAttribute) t1;\n+                keyId = attribute1.key.id();\n+            }\n+            return attributeKeyId < keyId? -1 : (attributeKeyId == keyId? 0 : 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMzMzMQ=="}, "originalCommit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1ODIwNTE5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTozOTo1NFrOHSICxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwNzo0NTo1M1rOHUjmmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODE5OQ==", "bodyText": "Just curious, why change from extending AtomicReference?", "url": "https://github.com/netty/netty/pull/10530#discussion_r488768199", "createdAt": "2020-09-15T15:39:54Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4NjcyNQ==", "bodyText": "Because the old semantic wasn't documenting how to manage a removed state and now it doesn't match anymore the atomic reference one eg Attribute::get was === with AtomicReference::get. I have strengthened the new semantic to reduce the size of the default attribute instance ;)", "url": "https://github.com/netty/netty/pull/10530#discussion_r488786725", "createdAt": "2020-09-15T16:05:52Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODE5OQ=="}, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNjQxNw==", "bodyText": "OK sure, though I think you could still have just overridden those and used super.get() etc? Only for a slight simplification i.e. avoid needing the ARFU. Fine to leave as-is too", "url": "https://github.com/netty/netty/pull/10530#discussion_r490436417", "createdAt": "2020-09-17T17:30:45Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODE5OQ=="}, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMxNjg5MA==", "bodyText": "I have chosen to not do that because at the beginning I have already tried it and found that the whole thing was compiling fine but failing some tests because of the ARFU existing implementation: it tooks me a bit to fine the issue so I have thought was a kind of semantic code smell and fixing it was I have currently done :)", "url": "https://github.com/netty/netty/pull/10530#discussion_r491316890", "createdAt": "2020-09-19T07:45:53Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODE5OQ=="}, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1ODIwOTA4OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTo0MDo0NVrOHSIFNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTo0MDo0NVrOHSIFNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODgyMg==", "bodyText": "nit: space before ?", "url": "https://github.com/netty/netty/pull/10530#discussion_r488768822", "createdAt": "2020-09-15T15:40:45Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final DefaultAttributeMap attributeMap;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(DefaultAttributeMap attributeMap,\n+                         AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1ODI1NTMzOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTo1MDozNFrOHSIhZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNjowOTo0MFrOHSJVKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NjAzOA==", "bodyText": "Is this the same as the old behavior? i.e. if the attribute was already removed from the map would its value still be set", "url": "https://github.com/netty/netty/pull/10530#discussion_r488776038", "createdAt": "2020-09-15T15:50:34Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final DefaultAttributeMap attributeMap;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(DefaultAttributeMap attributeMap,\n+                         AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            } while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+        }\n+\n+        @Override\n+        public T getAndSet(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4OTI4OA==", "bodyText": "Nope but there was no documentation about it so I have changed it into something that would reduce the memory footprint of the instance while keeping a consistent behaviour", "url": "https://github.com/netty/netty/pull/10530#discussion_r488789288", "createdAt": "2020-09-15T16:09:40Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final DefaultAttributeMap attributeMap;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(DefaultAttributeMap attributeMap,\n+                         AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            } while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+        }\n+\n+        @Override\n+        public T getAndSet(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NjAzOA=="}, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODYyNjg1OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxOTo1NlrOHTtcdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNjozNVrOHTvz3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyOTU1Nw==", "bodyText": "might be a nit, but did you consider binary searching to find the insertion point, and then use System.arraycopy to move the daat around for the slot?  I am curious if this more easily intrinsifies this for loop copy.", "url": "https://github.com/netty/netty/pull/10530#discussion_r490429557", "createdAt": "2020-09-17T17:19:56Z", "author": {"login": "carl-mastrangelo"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODMxOQ==", "bodyText": "As a general rule of thumb, yes, you're right, here I have taken advantage of the domain logic where latest addition of attributes tends to have higher IDs (due to the incremental logic on constants).", "url": "https://github.com/netty/netty/pull/10530#discussion_r490468319", "createdAt": "2020-09-17T18:26:35Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyOTU1Nw=="}, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODY2ODA4OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozMDoyN1rOHTt2aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozMDoyN1rOHTt2aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNjIwMw==", "bodyText": "This doesn't seem to take advantage of the index which should be the insertion point.    I would suspect after a few attrs, avoiding the excess copies would become expensive.    It feels like the index should be passed into orderedCopyOnInsert", "url": "https://github.com/netty/netty/pull/10530#discussion_r490436203", "createdAt": "2020-09-17T17:30:27Z", "author": {"login": "carl-mastrangelo"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTY2MTgxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjozNjoxNFrOHbiemA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjo1NzozNVrOHbi4gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzODQ4OA==", "bodyText": "remove public and rename to isRemoved() ?", "url": "https://github.com/netty/netty/pull/10530#discussion_r498638488", "createdAt": "2020-10-02T06:36:14Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n+            }\n+        }\n+\n+        return -(low + 1);\n+    }\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n+            }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n+        }\n+    }\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n-            }\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n-            }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n     private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n \n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, DefaultAttributeMap> MAP_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class,\n+                                                       DefaultAttributeMap.class, \"attributeMap\");\n         private static final long serialVersionUID = -2661411462200283011L;\n \n+        private volatile DefaultAttributeMap attributeMap;\n         // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n         private final AttributeKey<T> key;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n-\n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n-\n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n+        DefaultAttribute(DefaultAttributeMap attributeMap, AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n             this.key = key;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n-        }\n-\n         @Override\n         public AttributeKey<T> key() {\n             return key;\n         }\n \n+        public boolean removed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35fbf91263835189670822d4e03fe30f2615443d"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NTEyMg==", "bodyText": "done!", "url": "https://github.com/netty/netty/pull/10530#discussion_r498645122", "createdAt": "2020-10-02T06:57:35Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n+            }\n+        }\n+\n+        return -(low + 1);\n+    }\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n+            }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n+        }\n+    }\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n-            }\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n-            }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n     private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n \n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, DefaultAttributeMap> MAP_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class,\n+                                                       DefaultAttributeMap.class, \"attributeMap\");\n         private static final long serialVersionUID = -2661411462200283011L;\n \n+        private volatile DefaultAttributeMap attributeMap;\n         // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n         private final AttributeKey<T> key;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n-\n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n-\n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n+        DefaultAttribute(DefaultAttributeMap attributeMap, AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n             this.key = key;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n-        }\n-\n         @Override\n         public AttributeKey<T> key() {\n             return key;\n         }\n \n+        public boolean removed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzODQ4OA=="}, "originalCommit": {"oid": "35fbf91263835189670822d4e03fe30f2615443d"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjEzMDE1OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOToyNTo1OFrOHbnCeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDozNjozOVrOHbo_Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMzIwOA==", "bodyText": "If they're the same object, there's no way their id can be different.", "url": "https://github.com/netty/netty/pull/10530#discussion_r498713208", "createdAt": "2020-10-02T09:25:58Z", "author": {"login": "chrisvest"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0NTEyNw==", "bodyText": "ooops!", "url": "https://github.com/netty/netty/pull/10530#discussion_r498745127", "createdAt": "2020-10-02T10:36:39Z", "author": {"login": "franz1981"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMzIwOA=="}, "originalCommit": {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjE0MDgzOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOToyOTozM1rOHbnJIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOToyOTozM1rOHbnJIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxNDkxMw==", "bodyText": "The fromIndex is always 0, and toIndex is always the length of the sortedAttributes, so there's no need to take them as parameters.", "url": "https://github.com/netty/netty/pull/10530#discussion_r498714913", "createdAt": "2020-10-02T09:29:33Z", "author": {"login": "chrisvest"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjI0MzE1OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDowNTozNFrOHboJmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDowNTozNFrOHboJmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczMTQxNg==", "bodyText": "This comment is now obsolete.", "url": "https://github.com/netty/netty/pull/10530#discussion_r498731416", "createdAt": "2020-10-02T10:05:34Z", "author": {"login": "chrisvest"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n+            }\n+        }\n+\n+        return -(low + 1);\n+    }\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n+            }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n+        }\n+    }\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n-            }\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n-            }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.isRemoved()) {\n+                    return attribute;\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n     private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n \n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, DefaultAttributeMap> MAP_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class,\n+                                                       DefaultAttributeMap.class, \"attributeMap\");\n         private static final long serialVersionUID = -2661411462200283011L;\n \n+        private volatile DefaultAttributeMap attributeMap;\n         // The head of the linked-list this attribute belongs to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1"}, "originalPosition": 228}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3695, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}