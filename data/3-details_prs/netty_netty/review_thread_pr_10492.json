{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxMDk2NjM4", "number": 10492, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzo0NDozNVrOEapDGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMToxMTo1MlrOEcv_jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzcwOTcxOnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzo0NDozNVrOHEMqEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMzo1Njo1N1rOHEuRVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzcyOQ==", "bodyText": "The rules are all Comparable, so we don't need the comparator, no?", "url": "https://github.com/netty/netty/pull/10492#discussion_r474163729", "createdAt": "2020-08-20T17:44:35Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3OTUzNQ==", "bodyText": "Collections#binarySearch requires Comparator. Can't skip.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474179535", "createdAt": "2020-08-20T18:13:33Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzcyOQ=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzNjYzNw==", "bodyText": "I mean, for the sort method calls.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474436637", "createdAt": "2020-08-21T06:35:31Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzcyOQ=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU2MDA3Mg==", "bodyText": "IpSubnetFilterRuleComparator can be static field.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474560072", "createdAt": "2020-08-21T09:12:28Z", "author": {"login": "johnou"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzcyOQ=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcxNDQ1NA==", "bodyText": "Fixed", "url": "https://github.com/netty/netty/pull/10492#discussion_r474714454", "createdAt": "2020-08-21T13:56:57Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzcyOQ=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzcxMzM4OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzo0NTozNFrOHEMsMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMzo1NzowOVrOHEuRvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NDI3NQ==", "bodyText": "Same here.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474164275", "createdAt": "2020-08-20T17:45:34Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcxNDU1OA==", "bodyText": "Fixed", "url": "https://github.com/netty/netty/pull/10492#discussion_r474714558", "createdAt": "2020-08-21T13:57:09Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NDI3NQ=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzczMjA5OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzo1MDo1OVrOHEM31A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNDoyODoxOFrOHEvdYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NzI1Mg==", "bodyText": "We should consider adding IpSubnetFilterRuleComparator.INSTANCE, mark the constructor private and reuse the same instance everywhere", "url": "https://github.com/netty/netty/pull/10492#discussion_r474167252", "createdAt": "2020-08-20T17:50:59Z", "author": {"login": "normanmaurer"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3ODkzMg==", "bodyText": "I'll do that.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474178932", "createdAt": "2020-08-20T18:12:23Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NzI1Mg=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDczMzkyMw==", "bodyText": "Done", "url": "https://github.com/netty/netty/pull/10492#discussion_r474733923", "createdAt": "2020-08-21T14:28:18Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules = new ArrayList<IpSubnetFilterRule>();\n+\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        // Iterate over rules and check for `null` and add them to List\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            this.rules.add(ipSubnetFilterRule);\n+        }\n+\n+        Collections.sort(this.rules, new IpSubnetFilterRuleComparator());\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, new IpSubnetFilterRuleComparator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NzI1Mg=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mzc4MjgwOnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRuleComparator.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxODowNTozNFrOHENXIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMzo0NToxOVrOHEt28A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3NTI2NQ==", "bodyText": "This is a rather strange comparator, that skimps on the reciprocity rule, and only kind of makes sense in this narrow use case. And then it also relies on the implementation details of Collections.binarySearch a bit. It's also not clear if it actually works as intended. I'd rather see a bespoke and well tested implementation of binary search as a helper method for IpSubnetFilter.accept, that incorporates the special comparison logic.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474175265", "createdAt": "2020-08-20T18:05:34Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRuleComparator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Comparator;\n+\n+final class IpSubnetFilterRuleComparator implements Comparator<Object> {\n+\n+    @Override\n+    public int compare(Object o1, Object o2) {\n+        if (o1 instanceof IpSubnetFilterRule) {\n+            if (o2 instanceof IpSubnetFilterRule) {\n+                return ((IpSubnetFilterRule) o1).compareTo((IpSubnetFilterRule) o2);\n+            } else if (o2 instanceof InetSocketAddress) {\n+                return ((IpSubnetFilterRule) o1).matches((InetSocketAddress) o2) ? 0 : -1;\n+            }\n+        }\n+        return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5MzI0MA==", "bodyText": "Binary search requires me to pass same class type as key. So if I wanna search InetSocketAddress in list of IpSubnetFilterRule, it's not possible. So I used Object here.\no1 will always be IpSubnetFilterRule.\no2 will be:\n\n\nIpSubnetFilterRule if we're sorting. (It'll use networkAddress for sort)\n\n\nInetSocketAddress if we're searching. (It'll simply use 'matches' method).\n\n\nYou have a better approach for this?", "url": "https://github.com/netty/netty/pull/10492#discussion_r474193240", "createdAt": "2020-08-20T18:38:34Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRuleComparator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Comparator;\n+\n+final class IpSubnetFilterRuleComparator implements Comparator<Object> {\n+\n+    @Override\n+    public int compare(Object o1, Object o2) {\n+        if (o1 instanceof IpSubnetFilterRule) {\n+            if (o2 instanceof IpSubnetFilterRule) {\n+                return ((IpSubnetFilterRule) o1).compareTo((IpSubnetFilterRule) o2);\n+            } else if (o2 instanceof InetSocketAddress) {\n+                return ((IpSubnetFilterRule) o1).matches((InetSocketAddress) o2) ? 0 : -1;\n+            }\n+        }\n+        return -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3NTI2NQ=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0NzQwNQ==", "bodyText": "Yes, this particular use of binary search is a little unusual. That's why I suggested to either reimplement a bespoke binary search, that captures and handles the special comparison logic. Or, since the Collections.sort method has an overload that relies on Comparable rather than Comparator, we move or inline this Comparator to the accept (the only place it's used at that point) and simplify it (since o1 is now always a filter, and o2 is always an address).", "url": "https://github.com/netty/netty/pull/10492#discussion_r474547405", "createdAt": "2020-08-21T08:58:28Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRuleComparator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Comparator;\n+\n+final class IpSubnetFilterRuleComparator implements Comparator<Object> {\n+\n+    @Override\n+    public int compare(Object o1, Object o2) {\n+        if (o1 instanceof IpSubnetFilterRule) {\n+            if (o2 instanceof IpSubnetFilterRule) {\n+                return ((IpSubnetFilterRule) o1).compareTo((IpSubnetFilterRule) o2);\n+            } else if (o2 instanceof InetSocketAddress) {\n+                return ((IpSubnetFilterRule) o1).matches((InetSocketAddress) o2) ? 0 : -1;\n+            }\n+        }\n+        return -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3NTI2NQ=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0ODY3MQ==", "bodyText": "Also, I'd like to see a unit test that verifies that the accept method filters correctly; so everything works as intended.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474548671", "createdAt": "2020-08-21T08:59:47Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRuleComparator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Comparator;\n+\n+final class IpSubnetFilterRuleComparator implements Comparator<Object> {\n+\n+    @Override\n+    public int compare(Object o1, Object o2) {\n+        if (o1 instanceof IpSubnetFilterRule) {\n+            if (o2 instanceof IpSubnetFilterRule) {\n+                return ((IpSubnetFilterRule) o1).compareTo((IpSubnetFilterRule) o2);\n+            } else if (o2 instanceof InetSocketAddress) {\n+                return ((IpSubnetFilterRule) o1).matches((InetSocketAddress) o2) ? 0 : -1;\n+            }\n+        }\n+        return -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3NTI2NQ=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNzY5Ng==", "bodyText": "Now Integer.compareTo and BigInteger.compareTo is used if matches returns false.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474707696", "createdAt": "2020-08-21T13:45:19Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRuleComparator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Comparator;\n+\n+final class IpSubnetFilterRuleComparator implements Comparator<Object> {\n+\n+    @Override\n+    public int compare(Object o1, Object o2) {\n+        if (o1 instanceof IpSubnetFilterRule) {\n+            if (o2 instanceof IpSubnetFilterRule) {\n+                return ((IpSubnetFilterRule) o1).compareTo((IpSubnetFilterRule) o2);\n+            } else if (o2 instanceof InetSocketAddress) {\n+                return ((IpSubnetFilterRule) o1).matches((InetSocketAddress) o2) ? 0 : -1;\n+            }\n+        }\n+        return -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3NTI2NQ=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mzc4NzA5OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxODowNjo0NlrOHENZsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxODoxNDoxNVrOHENpTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3NTkyMw==", "bodyText": "I wonder if we can implement a comparison without needing to keep this around, or if that adds too much overhead.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474175923", "createdAt": "2020-08-20T18:06:46Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,20 +68,35 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule o) {\n+        return getNetworkAddress().compareTo(o.getNetworkAddress());\n+    }\n+\n+    private BigInteger getNetworkAddress() {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return ((Ip4SubnetFilterRule) filterRule).networkAddressAsBigInteger;\n+        } else {\n+            return ((Ip6SubnetFilterRule) filterRule).networkAddress;\n+        }\n+    }\n+\n     private static final class Ip4SubnetFilterRule implements IpFilterRule {\n \n+        private final BigInteger networkAddressAsBigInteger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3OTkxNg==", "bodyText": "Yeah, I'll use Integer directly here now.", "url": "https://github.com/netty/netty/pull/10492#discussion_r474179916", "createdAt": "2020-08-20T18:14:15Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,20 +68,35 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule o) {\n+        return getNetworkAddress().compareTo(o.getNetworkAddress());\n+    }\n+\n+    private BigInteger getNetworkAddress() {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return ((Ip4SubnetFilterRule) filterRule).networkAddressAsBigInteger;\n+        } else {\n+            return ((Ip6SubnetFilterRule) filterRule).networkAddress;\n+        }\n+    }\n+\n     private static final class Ip4SubnetFilterRule implements IpFilterRule {\n \n+        private final BigInteger networkAddressAsBigInteger;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3NTkyMw=="}, "originalCommit": {"oid": "c4765051cb0992f1ef925bef095898e75223635d"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg3MzkzOnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "isResolved": true, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyNjo1OVrOHFGNNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODoxODoyN1rOHGkQ7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg==", "bodyText": "Both Integer.valueOf should think to a different way to handle this saving the Integer allocation (by saving/caching an int somewhere?)\nSame few lines below", "url": "https://github.com/netty/netty/pull/10492#discussion_r475106612", "createdAt": "2020-08-22T16:26:59Z", "author": {"login": "franz1981"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE3NDQxMQ==", "bodyText": "Should I change Ip4SubnetFilterRule#networkAddress from int to Integer? But AFAIK, Integer has overhead compared to  int.", "url": "https://github.com/netty/netty/pull/10492#discussion_r475174411", "createdAt": "2020-08-23T05:50:14Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE5MTM3Nw==", "bodyText": "The idea Is to save any Integer allocation in such hot path", "url": "https://github.com/netty/netty/pull/10492#discussion_r475191377", "createdAt": "2020-08-23T08:41:57Z", "author": {"login": "franz1981"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwNDY3Ng==", "bodyText": "I see that networkAddress is already an int, why you are translating it into an Integer just to be unboxed as an int again?", "url": "https://github.com/netty/netty/pull/10492#discussion_r476504676", "createdAt": "2020-08-25T14:43:12Z", "author": {"login": "franz1981"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwNzkxNA==", "bodyText": "Sorry, forgot to take a look here.\nInteger#compareTo(int, int) is documented for 1.7+. I get this error. So I've to call Integer#value(int) to do it in the old style.", "url": "https://github.com/netty/netty/pull/10492#discussion_r476507914", "createdAt": "2020-08-25T14:47:27Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwOTA3Mw==", "bodyText": "As per https://github.com/netty/netty#how-to-build, We need Java 7 or higher to build Netty. But why IntelliJ is set to Java 6?", "url": "https://github.com/netty/netty/pull/10492#discussion_r476509073", "createdAt": "2020-08-25T14:49:05Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3MzA1Mw==", "bodyText": "Yeah, Netty 4.1 is meant to work on Java 6 at runtime.", "url": "https://github.com/netty/netty/pull/10492#discussion_r476573053", "createdAt": "2020-08-25T16:18:42Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3NDM0Mw==", "bodyText": "That's the thing. Can't use Integer#compareTo(int, int) in Java 6. Maybe I should manually implement Integer#compareTo(int, int). How does it sound?", "url": "https://github.com/netty/netty/pull/10492#discussion_r476574343", "createdAt": "2020-08-25T16:20:36Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYyODkyMg==", "bodyText": "+1", "url": "https://github.com/netty/netty/pull/10492#discussion_r476628922", "createdAt": "2020-08-25T17:45:11Z", "author": {"login": "franz1981"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0NzY2MQ==", "bodyText": "Done", "url": "https://github.com/netty/netty/pull/10492#discussion_r476647661", "createdAt": "2020-08-25T18:18:27Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java", "diffHunk": "@@ -68,6 +71,43 @@ public IpFilterRuleType ruleType() {\n         return filterRule.ruleType();\n     }\n \n+    @Override\n+    public int compareTo(IpSubnetFilterRule ipSubnetFilterRule) {\n+        if (filterRule instanceof Ip4SubnetFilterRule) {\n+            return Integer.valueOf(((Ip4SubnetFilterRule) filterRule).networkAddress)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYxMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjM2MDM3OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo0OTozNlrOHFaYFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNDoyMToxMVrOHGafTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzNzA3Nw==", "bodyText": "Please do another hasNext check, instead of relying on catching NoSuchElementException.", "url": "https://github.com/netty/netty/pull/10492#discussion_r475437077", "createdAt": "2020-08-24T08:49:36Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4NzUwMw==", "bodyText": "hasNext is already done in while(Iterator#hasNext()) so no need to do the same here but I'll do it in other ones.", "url": "https://github.com/netty/netty/pull/10492#discussion_r476487503", "createdAt": "2020-08-25T14:21:11Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzNzA3Nw=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjM4NDU5OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo1NTo1MFrOHFamUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMToxMDozMlrOHHHLrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MDcyMg==", "bodyText": "Instead of collecting a list of things to remove (or removing via Iterator.remove()), you can instead build up a new list of things you want to keep. This algorithm would be linear in time, instead of N*M from removeAll. You can then do the null-checking at the same time. Make this method take the list-to-be-filtered as a parameter, and return the new filtered list. Then you can do all of this at the this.rules field assignment.", "url": "https://github.com/netty/netty/pull/10492#discussion_r475440722", "createdAt": "2020-08-24T08:55:50Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }\n+\n+                // Take one more element out of Iterator, this will be childRule.\n+                IpSubnetFilterRule childRule = iterator.next();\n+\n+                // If parentRule matches childRule, schedule that Rule for deletion.\n+                if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                    toRemove.add(childRule);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwNTc5OQ==", "bodyText": "I added code that checks if all rules belong to the same type while checking for null rules inside the user-supplied list of rules. If I try to move these inside sorting codes, it'll be a complete mess.\nThe reason behind adding this: We don't have to call List#get(int) because we already know if the list of rule contains the same IpFilterRuleType.\nPTAL at the latest code and revert back. :D", "url": "https://github.com/netty/netty/pull/10492#discussion_r476505799", "createdAt": "2020-08-25T14:44:40Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }\n+\n+                // Take one more element out of Iterator, this will be childRule.\n+                IpSubnetFilterRule childRule = iterator.next();\n+\n+                // If parentRule matches childRule, schedule that Rule for deletion.\n+                if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                    toRemove.add(childRule);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MDcyMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4MDQ5NA==", "bodyText": "I mean something like this:\nIndex: handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java\t(revision 295e104c7ed9027584927777073ae9f2f81cc2df)\n+++ handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java\t(date 1598435434667)\n@@ -86,14 +86,14 @@\n      * @param rules            {@link IpSubnetFilterRule} as {@link List}\n      */\n     public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n-        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n         this.acceptIfNotFound = acceptIfNotFound;\n \n         int numAccept = 0;\n         int numReject = 0;\n \n         // Iterate over rules and check for `null` rule.\n-        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n             ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n             if (ipSubnetFilterRule.ruleType() == IpFilterRuleType.ACCEPT) {\n                 numAccept++;\n@@ -120,7 +120,7 @@\n             ipFilterRuleType = null;\n         }\n \n-        sortAndFilter();\n+        this.rules = sortAndFilter(rules);\n     }\n \n     @Override\n@@ -143,39 +143,27 @@\n      *     <li> Sort the list again </li>\n      * </ol>\n      */\n-    private void sortAndFilter() {\n-        Collections.sort(this.rules);\n+    private static List<IpSubnetFilterRule> sortAndFilter(List<IpSubnetFilterRule> rules) {\n+        Collections.sort(rules);\n         Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n-        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+        List<IpSubnetFilterRule> toKeep = new ArrayList<IpSubnetFilterRule>();\n \n-        IpSubnetFilterRule parentRule = null;\n+        IpSubnetFilterRule parentRule = iterator.hasNext() ? iterator.next() : null;\n+        if (parentRule != null) {\n+            toKeep.add(parentRule);\n+        }\n         while (iterator.hasNext()) {\n-\n-            // If parentRule is null, take first element out of Iterator.\n-            if (parentRule == null) {\n-                parentRule = iterator.next();\n-            }\n-\n-            // If we don't have any more rule, we're done now.\n-            if (!iterator.hasNext()) {\n-                break;\n-            }\n-\n-            // Take one more element out of Iterator, this will be childRule.\n+            // Grab a potential child rule.\n             IpSubnetFilterRule childRule = iterator.next();\n \n-            // If parentRule matches childRule, schedule that Rule for deletion.\n-            if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n-                toRemove.add(childRule);\n-            } else {\n-                // If parentRule does not matches childRule, this childRule will become new parentRule\n-                // and we'll do the same again\n+            // If parentRule matches childRule, then there's no need to keep the child rule.\n+            // Otherwise, the rules are distinct and we need both.\n+            if (!parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                toKeep.add(childRule);\n+                // Then we'll keep the child rule around as the parent for the next round.\n                 parentRule = childRule;\n             }\n         }\n-\n-        rules.removeAll(toRemove);\n-        toRemove.clear();\n-        Collections.sort(rules); // Re-sort just to be sure\n+        return toKeep;\n     }\n }", "url": "https://github.com/netty/netty/pull/10492#discussion_r477180494", "createdAt": "2020-08-26T09:53:55Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }\n+\n+                // Take one more element out of Iterator, this will be childRule.\n+                IpSubnetFilterRule childRule = iterator.next();\n+\n+                // If parentRule matches childRule, schedule that Rule for deletion.\n+                if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                    toRemove.add(childRule);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MDcyMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4NDc4MQ==", "bodyText": "@hyperxpro Not sure if I have access to directly push to this PR, but I can give it a go if you like.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477184781", "createdAt": "2020-08-26T10:01:23Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }\n+\n+                // Take one more element out of Iterator, this will be childRule.\n+                IpSubnetFilterRule childRule = iterator.next();\n+\n+                // If parentRule matches childRule, schedule that Rule for deletion.\n+                if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                    toRemove.add(childRule);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MDcyMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5MjA5Mw==", "bodyText": "Just create a gist of updated source and I will copy from there. :p", "url": "https://github.com/netty/netty/pull/10492#discussion_r477192093", "createdAt": "2020-08-26T10:14:51Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }\n+\n+                // Take one more element out of Iterator, this will be childRule.\n+                IpSubnetFilterRule childRule = iterator.next();\n+\n+                // If parentRule matches childRule, schedule that Rule for deletion.\n+                if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                    toRemove.add(childRule);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MDcyMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5NjgxNQ==", "bodyText": "If you use Intellij you can also copy the snippet above and click VCS\u2192Apply Patch from Clipboard\u2026", "url": "https://github.com/netty/netty/pull/10492#discussion_r477196815", "createdAt": "2020-08-26T10:24:12Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }\n+\n+                // Take one more element out of Iterator, this will be childRule.\n+                IpSubnetFilterRule childRule = iterator.next();\n+\n+                // If parentRule matches childRule, schedule that Rule for deletion.\n+                if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                    toRemove.add(childRule);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MDcyMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxOTc1OA==", "bodyText": "NVM, Did it myself. Thanks for helping a noob. :p", "url": "https://github.com/netty/netty/pull/10492#discussion_r477219758", "createdAt": "2020-08-26T11:10:32Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }\n+\n+                // Take one more element out of Iterator, this will be childRule.\n+                IpSubnetFilterRule childRule = iterator.next();\n+\n+                // If parentRule matches childRule, schedule that Rule for deletion.\n+                if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                    toRemove.add(childRule);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MDcyMg=="}, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjM4ODQ0OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo1Njo0NVrOHFaogQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo1Njo0NVrOHFaogQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MTI4MQ==", "bodyText": "If you follow my comment above, this part would also go away.", "url": "https://github.com/netty/netty/pull/10492#discussion_r475441281", "createdAt": "2020-08-24T08:56:45Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : this.rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+        }\n+\n+        sortAndFilter();\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+        }\n+        return acceptIfNotFound;\n+    }\n+\n+    /**\n+     * <ol>\n+     *     <li> Sort the list </li>\n+     *     <li> Remove over-lapping subnet </li>\n+     *     <li> Sort the list again </li>\n+     * </ol>\n+     */\n+    private void sortAndFilter() {\n+        Collections.sort(this.rules);\n+        Iterator<IpSubnetFilterRule> iterator = rules.iterator();\n+        List<IpSubnetFilterRule> toRemove = new ArrayList<IpSubnetFilterRule>();\n+\n+        try {\n+            IpSubnetFilterRule parentRule = null;\n+            while (iterator.hasNext()) {\n+\n+                // If parentRule is null, take first element out of Iterator.\n+                if (parentRule == null) {\n+                    parentRule = iterator.next();\n+                }\n+\n+                // Take one more element out of Iterator, this will be childRule.\n+                IpSubnetFilterRule childRule = iterator.next();\n+\n+                // If parentRule matches childRule, schedule that Rule for deletion.\n+                if (parentRule.matches(new InetSocketAddress(childRule.getIpAddress(), 1))) {\n+                    toRemove.add(childRule);\n+                } else {\n+                    // If parentRule does not matches childRule, this childRule will become new parentRule\n+                    // and we'll do the same again\n+                    parentRule = childRule;\n+                }\n+            }\n+        } catch (NoSuchElementException ex) {\n+            // Ignore\n+        }\n+\n+        rules.removeAll(toRemove);\n+        toRemove.clear();\n+        Collections.sort(rules); // Re-sort just to be sure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7201409e7c6a607ea5be91a424133760d8efe266"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDU5MDY3OnYy", "diffSide": "RIGHT", "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTozNjoxOVrOHHR8bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTozNjoxOVrOHHR8bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM5NjA3Nw==", "bodyText": "We don't need to explicitly clear this list. The GC will take care of it.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477396077", "createdAt": "2020-08-26T15:36:19Z", "author": {"login": "chrisvest"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -141,6 +144,52 @@ public void testUniqueIpFilterHandler() {\n         Assert.assertTrue(ch4.isActive());\n     }\n \n+    @Test\n+    public void testBinarySearch() {\n+        List<IpSubnetFilterRule> ipSubnetFilterRuleList = new ArrayList<IpSubnetFilterRule>();\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.2.3.4\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.1.1.1\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));\n+\n+        // 1.0.0.0/8\n+        EmbeddedChannel ch1 = newEmbeddedInetChannel(\"1.1.1.1\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertFalse(ch1.isActive());\n+        Assert.assertTrue(ch1.close().isSuccess());\n+\n+        // Nothing applies here\n+        EmbeddedChannel ch2 = newEmbeddedInetChannel(\"2.2.2.2\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertTrue(ch2.isActive());\n+        Assert.assertTrue(ch2.close().isSuccess());\n+\n+        // 108.0.0.0/4\n+        EmbeddedChannel ch3 = newEmbeddedInetChannel(\"97.100.100.100\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertFalse(ch3.isActive());\n+        Assert.assertTrue(ch3.close().isSuccess());\n+\n+        // 200.200.200.200/32\n+        EmbeddedChannel ch4 = newEmbeddedInetChannel(\"200.200.200.200\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertFalse(ch4.isActive());\n+        Assert.assertTrue(ch4.close().isSuccess());\n+\n+        // Nothing applies here\n+        EmbeddedChannel ch5 = newEmbeddedInetChannel(\"127.0.0.1\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertTrue(ch5.isActive());\n+        Assert.assertTrue(ch5.close().isSuccess());\n+\n+        // 10.0.0.0/8\n+        EmbeddedChannel ch6 = newEmbeddedInetChannel(\"10.1.1.2\", new IpSubnetFilter(ipSubnetFilterRuleList));\n+        Assert.assertFalse(ch6.isActive());\n+        Assert.assertTrue(ch6.close().isSuccess());\n+\n+        ipSubnetFilterRuleList.clear(); // Because we're done with the list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDU5OTAxOnYy", "diffSide": "RIGHT", "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTozODoxMVrOHHSByQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNzozMzoyMlrOHHWh3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM5NzQ0OQ==", "bodyText": "Would be good to also test IPv6, including testing with rule lists that is a mix of IPv4 and IPv6, and have them match on both IPv4 and IPv6 addresses.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477397449", "createdAt": "2020-08-26T15:38:11Z", "author": {"login": "chrisvest"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -141,6 +144,52 @@ public void testUniqueIpFilterHandler() {\n         Assert.assertTrue(ch4.isActive());\n     }\n \n+    @Test\n+    public void testBinarySearch() {\n+        List<IpSubnetFilterRule> ipSubnetFilterRuleList = new ArrayList<IpSubnetFilterRule>();\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.2.3.4\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.1.1.1\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNDc0Ng==", "bodyText": "And here we go again, Comparator tries to compare IPv4 and IPv6. How about explicitly defining the IP version type?", "url": "https://github.com/netty/netty/pull/10492#discussion_r477424746", "createdAt": "2020-08-26T16:18:04Z", "author": {"login": "hyperxpro"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -141,6 +144,52 @@ public void testUniqueIpFilterHandler() {\n         Assert.assertTrue(ch4.isActive());\n     }\n \n+    @Test\n+    public void testBinarySearch() {\n+        List<IpSubnetFilterRule> ipSubnetFilterRuleList = new ArrayList<IpSubnetFilterRule>();\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.2.3.4\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.1.1.1\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM5NzQ0OQ=="}, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzg0Ng==", "bodyText": "Yeah, that could work. If we ensure that the list never contain both types, it would side-step a lot of trouble.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477427846", "createdAt": "2020-08-26T16:23:03Z", "author": {"login": "chrisvest"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -141,6 +144,52 @@ public void testUniqueIpFilterHandler() {\n         Assert.assertTrue(ch4.isActive());\n     }\n \n+    @Test\n+    public void testBinarySearch() {\n+        List<IpSubnetFilterRule> ipSubnetFilterRuleList = new ArrayList<IpSubnetFilterRule>();\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.2.3.4\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.1.1.1\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM5NzQ0OQ=="}, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyOTE0Ng==", "bodyText": "The comparator, or the accept method, would still need to test that the address being checked is of the correct type, though. But that should be simple enough.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477429146", "createdAt": "2020-08-26T16:25:00Z", "author": {"login": "chrisvest"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -141,6 +144,52 @@ public void testUniqueIpFilterHandler() {\n         Assert.assertTrue(ch4.isActive());\n     }\n \n+    @Test\n+    public void testBinarySearch() {\n+        List<IpSubnetFilterRule> ipSubnetFilterRuleList = new ArrayList<IpSubnetFilterRule>();\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.2.3.4\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.1.1.1\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM5NzQ0OQ=="}, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MzMyMw==", "bodyText": "Added IPv4/6 count check. It'll throw an exception like this:\njava.lang.IllegalArgumentException: Mixed IP version rules are not allowed. Number of IPv4 rules: 5, IPv6 rules: 1", "url": "https://github.com/netty/netty/pull/10492#discussion_r477463323", "createdAt": "2020-08-26T17:20:10Z", "author": {"login": "hyperxpro"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -141,6 +144,52 @@ public void testUniqueIpFilterHandler() {\n         Assert.assertTrue(ch4.isActive());\n     }\n \n+    @Test\n+    public void testBinarySearch() {\n+        List<IpSubnetFilterRule> ipSubnetFilterRuleList = new ArrayList<IpSubnetFilterRule>();\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.2.3.4\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.1.1.1\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM5NzQ0OQ=="}, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3MTE5OA==", "bodyText": "@chrisvest PTAL at the latest code.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477471198", "createdAt": "2020-08-26T17:33:22Z", "author": {"login": "hyperxpro"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -141,6 +144,52 @@ public void testUniqueIpFilterHandler() {\n         Assert.assertTrue(ch4.isActive());\n     }\n \n+    @Test\n+    public void testBinarySearch() {\n+        List<IpSubnetFilterRule> ipSubnetFilterRuleList = new ArrayList<IpSubnetFilterRule>();\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.2.3.4\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"1.1.1.1\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM5NzQ0OQ=="}, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDYyOTYzOnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTo0NDozMFrOHHSUGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTo0NDozMFrOHHSUGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwMjEzOQ==", "bodyText": "I don't think this clear() is necessary. GC should take care of it.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477402139", "createdAt": "2020-08-26T15:44:30Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+    private final IpFilterRuleType ipFilterRuleType;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        int numAccept = 0;\n+        int numReject = 0;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            if (ipSubnetFilterRule.ruleType() == IpFilterRuleType.ACCEPT) {\n+                numAccept++;\n+            } else {\n+                numReject++;\n+            }\n+        }\n+\n+        /*\n+         * If Number of accept rules are 0 and Number of reject rules is more than 0,\n+         * then all rules are of \"REJECT\" type.\n+         *\n+         * In this case, we'll set `ipFilterRuleType` to `IpFilterRuleType.REJECT`\n+         *\n+         * If Number of accept rules are more than 0 and number of reject rules are 0,\n+         * then all rules are of \"ACCEPT\" type.\n+         *\n+         */\n+        if (numAccept == 0 && numReject > 0) {\n+            ipFilterRuleType = IpFilterRuleType.REJECT;\n+        } else if (numAccept > 0 && numReject == 0) {\n+            ipFilterRuleType = IpFilterRuleType.ACCEPT;\n+        } else {\n+            ipFilterRuleType = null;\n+        }\n+\n+        this.rules = sortAndFilter(rules);\n+        rules.clear(); // Free-up old unsorted list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDYzMjYzOnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTo0NTowMVrOHHSVyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTo0NTowMVrOHHSVyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwMjU2OA==", "bodyText": "this is unnecessary.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477402568", "createdAt": "2020-08-26T15:45:01Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+    private final IpFilterRuleType ipFilterRuleType;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        int numAccept = 0;\n+        int numReject = 0;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            if (ipSubnetFilterRule.ruleType() == IpFilterRuleType.ACCEPT) {\n+                numAccept++;\n+            } else {\n+                numReject++;\n+            }\n+        }\n+\n+        /*\n+         * If Number of accept rules are 0 and Number of reject rules is more than 0,\n+         * then all rules are of \"REJECT\" type.\n+         *\n+         * In this case, we'll set `ipFilterRuleType` to `IpFilterRuleType.REJECT`\n+         *\n+         * If Number of accept rules are more than 0 and number of reject rules are 0,\n+         * then all rules are of \"ACCEPT\" type.\n+         *\n+         */\n+        if (numAccept == 0 && numReject > 0) {\n+            ipFilterRuleType = IpFilterRuleType.REJECT;\n+        } else if (numAccept > 0 && numReject == 0) {\n+            ipFilterRuleType = IpFilterRuleType.ACCEPT;\n+        } else {\n+            ipFilterRuleType = null;\n+        }\n+\n+        this.rules = sortAndFilter(rules);\n+        rules.clear(); // Free-up old unsorted list\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDYzNDY1OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTo0NToyNVrOHHSXCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTo0NToyNVrOHHSXCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwMjg4OQ==", "bodyText": "this is unnecessary.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477402889", "createdAt": "2020-08-26T15:45:25Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+    private final IpFilterRuleType ipFilterRuleType;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        int numAccept = 0;\n+        int numReject = 0;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            if (ipSubnetFilterRule.ruleType() == IpFilterRuleType.ACCEPT) {\n+                numAccept++;\n+            } else {\n+                numReject++;\n+            }\n+        }\n+\n+        /*\n+         * If Number of accept rules are 0 and Number of reject rules is more than 0,\n+         * then all rules are of \"REJECT\" type.\n+         *\n+         * In this case, we'll set `ipFilterRuleType` to `IpFilterRuleType.REJECT`\n+         *\n+         * If Number of accept rules are more than 0 and number of reject rules are 0,\n+         * then all rules are of \"ACCEPT\" type.\n+         *\n+         */\n+        if (numAccept == 0 && numReject > 0) {\n+            ipFilterRuleType = IpFilterRuleType.REJECT;\n+        } else if (numAccept > 0 && numReject == 0) {\n+            ipFilterRuleType = IpFilterRuleType.ACCEPT;\n+        } else {\n+            ipFilterRuleType = null;\n+        }\n+\n+        this.rules = sortAndFilter(rules);\n+        rules.clear(); // Free-up old unsorted list\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            if (ipFilterRuleType == null) {\n+                return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDYzNTY0OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTo0NTozOFrOHHSXmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTo0NTozOFrOHHSXmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwMzAzNQ==", "bodyText": "this is unnecessary.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477403035", "createdAt": "2020-08-26T15:45:38Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>\n+ * <p> This filter uses Binary Search for faster filtering so it's a good practice to remove\n+ * overlapping subnet rules and also entries should be arranged in incremental order.</p>\n+ */\n+@Sharable\n+public class IpSubnetFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+    private final List<IpSubnetFilterRule> rules;\n+    private final boolean acceptIfNotFound;\n+    private final IpFilterRuleType ipFilterRuleType;\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(IpSubnetFilterRule... rules) {\n+        this(true, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as array\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as array\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, IpSubnetFilterRule... rules) {\n+        this(acceptIfNotFound, Arrays.asList(ObjectUtil.checkNotNull(rules, \"rules\")));\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}. </p>\n+     * <p> {@code acceptIfNotFound} is set to {@code true} </p>\n+     *\n+     * @param rules {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(List<IpSubnetFilterRule> rules) {\n+        this(true, rules);\n+    }\n+\n+    /**\n+     * <p> Create new {@link IpSubnetFilter} Instance with specified {@link IpSubnetFilterRule} as {@link List}\n+     * and specify if we'll accept a connection if we don't find it in the rule(s). </p>\n+     *\n+     * @param acceptIfNotFound {@code true} if we'll accept connection if not found in rule(s).\n+     * @param rules            {@link IpSubnetFilterRule} as {@link List}\n+     */\n+    public IpSubnetFilter(boolean acceptIfNotFound, List<IpSubnetFilterRule> rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+        this.acceptIfNotFound = acceptIfNotFound;\n+\n+        int numAccept = 0;\n+        int numReject = 0;\n+\n+        // Iterate over rules and check for `null` rule.\n+        for (IpSubnetFilterRule ipSubnetFilterRule : rules) {\n+            ObjectUtil.checkNotNull(ipSubnetFilterRule, \"rule\");\n+            if (ipSubnetFilterRule.ruleType() == IpFilterRuleType.ACCEPT) {\n+                numAccept++;\n+            } else {\n+                numReject++;\n+            }\n+        }\n+\n+        /*\n+         * If Number of accept rules are 0 and Number of reject rules is more than 0,\n+         * then all rules are of \"REJECT\" type.\n+         *\n+         * In this case, we'll set `ipFilterRuleType` to `IpFilterRuleType.REJECT`\n+         *\n+         * If Number of accept rules are more than 0 and number of reject rules are 0,\n+         * then all rules are of \"ACCEPT\" type.\n+         *\n+         */\n+        if (numAccept == 0 && numReject > 0) {\n+            ipFilterRuleType = IpFilterRuleType.REJECT;\n+        } else if (numAccept > 0 && numReject == 0) {\n+            ipFilterRuleType = IpFilterRuleType.ACCEPT;\n+        } else {\n+            ipFilterRuleType = null;\n+        }\n+\n+        this.rules = sortAndFilter(rules);\n+        rules.clear(); // Free-up old unsorted list\n+    }\n+\n+    @Override\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {\n+        int indexOf = Collections.binarySearch(this.rules, remoteAddress, IpSubnetFilterRuleComparator.INSTANCE);\n+        if (indexOf >= 0) {\n+            if (ipFilterRuleType == null) {\n+                return this.rules.get(indexOf).ruleType() == IpFilterRuleType.ACCEPT;\n+            } else {\n+                return this.ipFilterRuleType == IpFilterRuleType.ACCEPT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDY0ODMwOnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNTo0ODozMlrOHHSfdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjowMjoyOFrOHHTE-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwNTA0NA==", "bodyText": "This should say AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress) for the javadoc reference to work.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477405044", "createdAt": "2020-08-26T15:48:32Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQxNDY0OQ==", "bodyText": "Actually this is coming from \n  \n    \n      netty/handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java\n    \n    \n         Line 32\n      in\n      4be9387\n    \n    \n    \n    \n\n        \n          \n            * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.", "url": "https://github.com/netty/netty/pull/10492#discussion_r477414649", "createdAt": "2020-08-26T16:02:28Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.ipfilter;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * This class allows one to filter new {@link Channel}s based on the\n+ * {@link IpSubnetFilter}s passed to its constructor. If no rules are provided, all connections\n+ * will be accepted.\n+ * </p>\n+ * <p>\n+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}. </p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQwNTA0NA=="}, "originalCommit": {"oid": "ea2eea00724c226f95230a161537e0f64e94d79a"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTgxOTAwOnYy", "diffSide": "RIGHT", "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMToxMTo1MlrOHHd5ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMzoyMjozN1rOHH4hTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5MjAwMw==", "bodyText": "Mixed version IPs should be in a separate test, as otherwise this test will now fail because of the new exception thrown from the constructor, right?", "url": "https://github.com/netty/netty/pull/10492#discussion_r477592003", "createdAt": "2020-08-26T21:11:52Z", "author": {"login": "chrisvest"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -152,6 +152,7 @@ public void testBinarySearch() {\n         ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n         ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n         ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"2001:db8:abcd:0000::\", 52));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fbdc61d9affe88bbf1700e20d07cae23f19a495"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAyODExMQ==", "bodyText": "Forgot to remove :p", "url": "https://github.com/netty/netty/pull/10492#discussion_r478028111", "createdAt": "2020-08-27T03:22:37Z", "author": {"login": "hyperxpro"}, "path": "handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java", "diffHunk": "@@ -152,6 +152,7 @@ public void testBinarySearch() {\n         ipSubnetFilterRuleList.add(buildRejectIP(\"200.200.200.200\", 32));\n         ipSubnetFilterRuleList.add(buildRejectIP(\"108.0.0.0\", 4));\n         ipSubnetFilterRuleList.add(buildRejectIP(\"10.10.10.10\", 8));\n+        ipSubnetFilterRuleList.add(buildRejectIP(\"2001:db8:abcd:0000::\", 52));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU5MjAwMw=="}, "originalCommit": {"oid": "4fbdc61d9affe88bbf1700e20d07cae23f19a495"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3666, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}