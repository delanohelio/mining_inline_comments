{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMzQ0OTMw", "number": 9955, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMToxOTo1MVrODc8T5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzozNzowM1rODeiz5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNjc0ODUzOnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMToxOTo1MVrOFlQlYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxOTo1OTo1M1rOFnzpgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxMzM0NQ==", "bodyText": "have you tried inspecting ASM here? Look if there is any PlatformDependent method that can save bound checks there.", "url": "https://github.com/netty/netty/pull/9955#discussion_r374613345", "createdAt": "2020-02-04T11:19:51Z", "author": {"login": "franz1981"}, "path": "buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+ package io.netty.buffer.search;\n+\n+/**\n+ * Implements Shifting Bit Mask string search algorithm as {@link io.netty.util.ByteProcessor}.\n+ * @see SearchProcessorFactory\n+ */\n+public class ShiftingBitMaskSearchProcessor implements SearchProcessor {\n+\n+    private final long[] bitMasks;\n+    private final long successBit;\n+    private long currentMask;\n+\n+    ShiftingBitMaskSearchProcessor(long[] bitMasks, long successBit) {\n+        this.bitMasks = bitMasks;\n+        this.successBit = successBit;\n+    }\n+\n+    @Override\n+    public boolean process(byte value) {\n+        currentMask = ((currentMask << 1) | 1) & bitMasks[value & 0xff];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MTM5OA==", "bodyText": "@franz1981 I've checked the assembly, also tried Byte.toUnsignedInt (which I think intrinsics to movzbl), nothing has helped to eliminate the bounds check. JDK 8 / 11 / 13 / GraalVM.\nLooks like PlatformDependent.getLong is something worth trying, thanks for the tip - will update later.", "url": "https://github.com/netty/netty/pull/9955#discussion_r374641398", "createdAt": "2020-02-04T12:28:15Z", "author": {"login": "linasm"}, "path": "buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+ package io.netty.buffer.search;\n+\n+/**\n+ * Implements Shifting Bit Mask string search algorithm as {@link io.netty.util.ByteProcessor}.\n+ * @see SearchProcessorFactory\n+ */\n+public class ShiftingBitMaskSearchProcessor implements SearchProcessor {\n+\n+    private final long[] bitMasks;\n+    private final long successBit;\n+    private long currentMask;\n+\n+    ShiftingBitMaskSearchProcessor(long[] bitMasks, long successBit) {\n+        this.bitMasks = bitMasks;\n+        this.successBit = successBit;\n+    }\n+\n+    @Override\n+    public boolean process(byte value) {\n+        currentMask = ((currentMask << 1) | 1) & bitMasks[value & 0xff];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxMzM0NQ=="}, "originalCommit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MzQ0Ng==", "bodyText": "So, adding this to PlatformDependent0:\n    static long getLong(long[] data, int index) {\n        return UNSAFE.getLong(data, LONG_ARRAY_BASE_OFFSET + LONG_ARRAY_INDEX_SCALE * index);\n    }\nand using it in ShiftingBitMaskSearchProcessor gives 2-8% improvement.\nAssembly with Array (process method is inlined and 4x loop-unrolled, so I'm only pasting one unroll piece here):\n  2.36%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c791e: movzx  r9d,BYTE PTR [rbx+rcx*1+0x12]\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ;*iand\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@17 (line 37)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  0.70%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c7924: mov    rax,rdx\n  2.69%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c7927: shl    rax,1\n  0.78%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c792a: mov    r8d,r10d\n  1.85%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c792d: add    r8d,0x2            ;*iinc\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@21 (line 1335)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  0.91%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c7931: or     rax,0x1            ;*lor  ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@8 (line 37)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502  \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  2.84%  \u2502  \u2502 \u2502\u2502  \u2502      0x000000010a0c7935: cmp    r9d,esi\n         \u2502  \u2502 \u2502\u2502\u256d \u2502      0x000000010a0c7938: jae    0x000000010a0c79ef  ;*laload\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@18 (line 37)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  0.53%  \u2502  \u2502 \u2502\u2502\u2502 \u2502      0x000000010a0c793e: and    rax,QWORD PTR [rbp+r9*8+0x10]\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ;*land\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@19 (line 37)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  2.55%  \u2502  \u2502 \u2502\u2502\u2502 \u2502      0x000000010a0c7943: mov    r9,rax\n  0.81%  \u2502  \u2502 \u2502\u2502\u2502 \u2502      0x000000010a0c7946: and    r9,r13             ;*land\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@31 (line 38)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502                                                    ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  3.31%  \u2502  \u2502 \u2502\u2502\u2502 \u2502      0x000000010a0c7949: test   r9,r9\n         \u2502  \u2502 \u2502\u2502\u2502 \u2502      0x000000010a0c794c: jne    0x000000010a0c7a43  ;*ifne\n\n(bound check is cmp r9d,esi; jae)\nAssembly with Unsafe (again, 1/4 piece of loop unroll):\n  6.95%  \u2502     \u2502    0x000000010c2cc973: shl    rbx,1\n  0.33%  \u2502     \u2502    0x000000010c2cc976: movsxd rax,r10d\n  0.26%  \u2502     \u2502    0x000000010c2cc979: movzx  esi,BYTE PTR [rdi+rax*1+0x11]\n         \u2502     \u2502                                                  ;*iand\n         \u2502     \u2502                                                  ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@17 (line 36)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502     \u2502                                                  ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  0.11%  \u2502     \u2502    0x000000010c2cc97e: or     rbx,0x1\n  6.88%  \u2502     \u2502    0x000000010c2cc982: and    rbx,QWORD PTR [rdx+rsi*8+0x10]\n         \u2502     \u2502                                                  ;*land\n         \u2502     \u2502                                                  ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@21 (line 36)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502     \u2502                                                  ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  1.56%  \u2502     \u2502    0x000000010c2cc987: mov    rsi,rbx\n  0.42%  \u2502     \u2502    0x000000010c2cc98a: and    rsi,r8             ;*land\n         \u2502     \u2502                                                  ; - io.netty.buffer.search.ShiftingBitMaskSearchProcessor::process@33 (line 38)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByteAsc0@11 (line 1336)\n         \u2502     \u2502                                                  ; - io.netty.buffer.AbstractByteBuf::forEachByte@14 (line 1316)\n         \u2502     \u2502                                                  ; - io.netty.microbench.search.SearchBenchmark::shiftingBitMask@11 (line 197)\n  6.74%  \u2502     \u2502    0x000000010c2cc98d: test   rsi,rsi\n         \u2502   \u256d \u2502    0x000000010c2cc990: jne    0x000000010c2cca19  ;*ifne\n\n(which looks really good to me, except for maybe some instruction ordering)\nOf course, same change could be done for KMP and Aho-Corasic (requiring to add getInt and getObject to PlatformDependent).", "url": "https://github.com/netty/netty/pull/9955#discussion_r375193446", "createdAt": "2020-02-05T11:08:42Z", "author": {"login": "linasm"}, "path": "buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+ package io.netty.buffer.search;\n+\n+/**\n+ * Implements Shifting Bit Mask string search algorithm as {@link io.netty.util.ByteProcessor}.\n+ * @see SearchProcessorFactory\n+ */\n+public class ShiftingBitMaskSearchProcessor implements SearchProcessor {\n+\n+    private final long[] bitMasks;\n+    private final long successBit;\n+    private long currentMask;\n+\n+    ShiftingBitMaskSearchProcessor(long[] bitMasks, long successBit) {\n+        this.bitMasks = bitMasks;\n+        this.successBit = successBit;\n+    }\n+\n+    @Override\n+    public boolean process(byte value) {\n+        currentMask = ((currentMask << 1) | 1) & bitMasks[value & 0xff];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxMzM0NQ=="}, "originalCommit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4NDk5NA==", "bodyText": "Tried PlatformDependent with all algos. Up to 8% improvement for Shifting bit mask, up to +21% for KMP, no measurable change for Aho-Corasic. Looks like Aho-Corasic is hitting some hard CPU pipeline limit, caused by tight traversal of this 2 level cyclic memory access indirection (object -> array -> object). Currently trying to resolve this issue, with promising results. Once done, will update with full table of results (want to avoid excess noise here).", "url": "https://github.com/netty/netty/pull/9955#discussion_r377284994", "createdAt": "2020-02-10T19:59:53Z", "author": {"login": "linasm"}, "path": "buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+ package io.netty.buffer.search;\n+\n+/**\n+ * Implements Shifting Bit Mask string search algorithm as {@link io.netty.util.ByteProcessor}.\n+ * @see SearchProcessorFactory\n+ */\n+public class ShiftingBitMaskSearchProcessor implements SearchProcessor {\n+\n+    private final long[] bitMasks;\n+    private final long successBit;\n+    private long currentMask;\n+\n+    ShiftingBitMaskSearchProcessor(long[] bitMasks, long successBit) {\n+        this.bitMasks = bitMasks;\n+        this.successBit = successBit;\n+    }\n+\n+    @Override\n+    public boolean process(byte value) {\n+        currentMask = ((currentMask << 1) | 1) & bitMasks[value & 0xff];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxMzM0NQ=="}, "originalCommit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzU0MjE1OnYy", "diffSide": "RIGHT", "path": "microbench/src/main/java/io/netty/microbench/search/SearchBenchmark.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzozNzowM1rOFnvMVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTo0NTo0NlrOFqBvBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMTk5MQ==", "bodyText": "It cannot be made less GC hungry by caching the search processor?\neach benchmarked method could include the jump table initialization and needle clone too (thinking of kmp here)\nEscape analysis probably won't even kick-in due to the size of needle array", "url": "https://github.com/netty/netty/pull/9955#discussion_r377211991", "createdAt": "2020-02-10T17:37:03Z", "author": {"login": "franz1981"}, "path": "microbench/src/main/java/io/netty/microbench/search/SearchBenchmark.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.microbench.search;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.search.MultiSearchProcessorFactory;\n+import io.netty.buffer.search.SearchProcessorFactory;\n+import io.netty.microbench.util.AbstractMicrobenchmark;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.CompilerControl.Mode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n+@Fork(1)\n+public class SearchBenchmark extends AbstractMicrobenchmark {\n+\n+    private static final long SEED = 123;\n+\n+    public enum ByteBufType {\n+        HEAP {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                return Unpooled.wrappedBuffer(bytes, 0, bytes.length);\n+            }\n+        },\n+        COMPOSITE {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                CompositeByteBuf buf = Unpooled.compositeBuffer();\n+                int length = bytes.length;\n+                int offset = 0;\n+                int capacity = length / 8; // 8 buffers per composite\n+\n+                while (length > 0) {\n+                    buf.addComponent(true, Unpooled.wrappedBuffer(bytes, offset, Math.min(length, capacity)));\n+                    length -= capacity;\n+                    offset += capacity;\n+                }\n+                return buf;\n+            }\n+        },\n+        DIRECT {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                return Unpooled.directBuffer(bytes.length).writeBytes(bytes);\n+            }\n+        };\n+        abstract ByteBuf newBuffer(byte[] bytes);\n+    }\n+\n+    public enum Input {\n+        RANDOM_256B {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return new byte[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 256, ' ', 127);\n+            }\n+        },\n+        RANDOM_2KB {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return new byte[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 2048, ' ', 127);\n+            }\n+        },\n+        PREDICTABLE {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                // all 0s\n+                return new byte[64];\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                // no 0s except in the very end\n+                byte[] bytes = randomBytes(rnd, 2048, 1, 255);\n+                Arrays.fill(bytes, bytes.length - 64, bytes.length, (byte) 0);\n+                return bytes;\n+            }\n+        },\n+        UNPREDICTABLE {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return randomBytes(rnd, 64, 0, 1);\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 2048, 0, 1);\n+            }\n+        },\n+        WORST_CASE { // ShiftingBitMask will fail on it because the needle is >64 bytes long\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                // aa(...)aab\n+                byte[] needle = new byte[1024];\n+                Arrays.fill(needle, (byte) 'a');\n+                needle[needle.length - 1] = 'b';\n+                return needle;\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                // aa(...)aaa\n+                byte[] haystack = new byte[2048];\n+                Arrays.fill(haystack, (byte) 'a');\n+                return haystack;\n+            }\n+        };\n+\n+        abstract byte[] getNeedle(Random rnd);\n+        abstract byte[] getHaystack(Random rnd);\n+    }\n+\n+    @Param\n+    public Input input;\n+\n+    @Param\n+    public ByteBufType bufferType;\n+\n+    private Random rnd;\n+    private ByteBuf needle, haystack;\n+    private byte[] needleBytes, haystackBytes;\n+    private SearchProcessorFactory kmpFactory, shiftingBitMaskFactory, ahoCorasicFactory;\n+\n+    @Setup\n+    public void setup() {\n+        rnd = new Random(SEED);\n+\n+        needleBytes = input.getNeedle(rnd);\n+        haystackBytes = input.getHaystack(rnd);\n+\n+        needle = Unpooled.wrappedBuffer(needleBytes);\n+        haystack = bufferType.newBuffer(haystackBytes);\n+\n+        kmpFactory = SearchProcessorFactory.newKmpSearchProcessorFactory(needleBytes);\n+        ahoCorasicFactory = MultiSearchProcessorFactory.newAhoCorasicSearchProcessorFactory(needleBytes);\n+\n+        if (needleBytes.length <= 64) {\n+            shiftingBitMaskFactory = SearchProcessorFactory.newShiftingBitMaskSearchProcessorFactory(needleBytes);\n+        }\n+    }\n+\n+    @TearDown\n+    public void teardown() {\n+        needle.release();\n+        haystack.release();\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(Mode.DONT_INLINE)\n+    public int indexOf() {\n+        return ByteBufUtil.indexOf(needle, haystack);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(Mode.DONT_INLINE)\n+    public int kmp() {\n+        return haystack.forEachByte(kmpFactory.newSearchProcessor());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4NzIyOQ==", "bodyText": "Sure, I can make the runs allocation free by reusing the search processor (resetting its state is trivial for all algos). Or is it something else that you had in mind?", "url": "https://github.com/netty/netty/pull/9955#discussion_r377287229", "createdAt": "2020-02-10T20:04:44Z", "author": {"login": "linasm"}, "path": "microbench/src/main/java/io/netty/microbench/search/SearchBenchmark.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.microbench.search;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.search.MultiSearchProcessorFactory;\n+import io.netty.buffer.search.SearchProcessorFactory;\n+import io.netty.microbench.util.AbstractMicrobenchmark;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.CompilerControl.Mode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n+@Fork(1)\n+public class SearchBenchmark extends AbstractMicrobenchmark {\n+\n+    private static final long SEED = 123;\n+\n+    public enum ByteBufType {\n+        HEAP {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                return Unpooled.wrappedBuffer(bytes, 0, bytes.length);\n+            }\n+        },\n+        COMPOSITE {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                CompositeByteBuf buf = Unpooled.compositeBuffer();\n+                int length = bytes.length;\n+                int offset = 0;\n+                int capacity = length / 8; // 8 buffers per composite\n+\n+                while (length > 0) {\n+                    buf.addComponent(true, Unpooled.wrappedBuffer(bytes, offset, Math.min(length, capacity)));\n+                    length -= capacity;\n+                    offset += capacity;\n+                }\n+                return buf;\n+            }\n+        },\n+        DIRECT {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                return Unpooled.directBuffer(bytes.length).writeBytes(bytes);\n+            }\n+        };\n+        abstract ByteBuf newBuffer(byte[] bytes);\n+    }\n+\n+    public enum Input {\n+        RANDOM_256B {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return new byte[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 256, ' ', 127);\n+            }\n+        },\n+        RANDOM_2KB {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return new byte[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 2048, ' ', 127);\n+            }\n+        },\n+        PREDICTABLE {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                // all 0s\n+                return new byte[64];\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                // no 0s except in the very end\n+                byte[] bytes = randomBytes(rnd, 2048, 1, 255);\n+                Arrays.fill(bytes, bytes.length - 64, bytes.length, (byte) 0);\n+                return bytes;\n+            }\n+        },\n+        UNPREDICTABLE {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return randomBytes(rnd, 64, 0, 1);\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 2048, 0, 1);\n+            }\n+        },\n+        WORST_CASE { // ShiftingBitMask will fail on it because the needle is >64 bytes long\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                // aa(...)aab\n+                byte[] needle = new byte[1024];\n+                Arrays.fill(needle, (byte) 'a');\n+                needle[needle.length - 1] = 'b';\n+                return needle;\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                // aa(...)aaa\n+                byte[] haystack = new byte[2048];\n+                Arrays.fill(haystack, (byte) 'a');\n+                return haystack;\n+            }\n+        };\n+\n+        abstract byte[] getNeedle(Random rnd);\n+        abstract byte[] getHaystack(Random rnd);\n+    }\n+\n+    @Param\n+    public Input input;\n+\n+    @Param\n+    public ByteBufType bufferType;\n+\n+    private Random rnd;\n+    private ByteBuf needle, haystack;\n+    private byte[] needleBytes, haystackBytes;\n+    private SearchProcessorFactory kmpFactory, shiftingBitMaskFactory, ahoCorasicFactory;\n+\n+    @Setup\n+    public void setup() {\n+        rnd = new Random(SEED);\n+\n+        needleBytes = input.getNeedle(rnd);\n+        haystackBytes = input.getHaystack(rnd);\n+\n+        needle = Unpooled.wrappedBuffer(needleBytes);\n+        haystack = bufferType.newBuffer(haystackBytes);\n+\n+        kmpFactory = SearchProcessorFactory.newKmpSearchProcessorFactory(needleBytes);\n+        ahoCorasicFactory = MultiSearchProcessorFactory.newAhoCorasicSearchProcessorFactory(needleBytes);\n+\n+        if (needleBytes.length <= 64) {\n+            shiftingBitMaskFactory = SearchProcessorFactory.newShiftingBitMaskSearchProcessorFactory(needleBytes);\n+        }\n+    }\n+\n+    @TearDown\n+    public void teardown() {\n+        needle.release();\n+        haystack.release();\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(Mode.DONT_INLINE)\n+    public int indexOf() {\n+        return ByteBufUtil.indexOf(needle, haystack);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(Mode.DONT_INLINE)\n+    public int kmp() {\n+        return haystack.forEachByte(kmpFactory.newSearchProcessor());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMTk5MQ=="}, "originalCommit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxMjkzNA==", "bodyText": "My new benchmark suite will reuse (reset) the SearchProcessor so each invocation will be allocation free.", "url": "https://github.com/netty/netty/pull/9955#discussion_r379612934", "createdAt": "2020-02-14T19:45:46Z", "author": {"login": "linasm"}, "path": "microbench/src/main/java/io/netty/microbench/search/SearchBenchmark.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.microbench.search;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.search.MultiSearchProcessorFactory;\n+import io.netty.buffer.search.SearchProcessorFactory;\n+import io.netty.microbench.util.AbstractMicrobenchmark;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.CompilerControl.Mode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n+@Fork(1)\n+public class SearchBenchmark extends AbstractMicrobenchmark {\n+\n+    private static final long SEED = 123;\n+\n+    public enum ByteBufType {\n+        HEAP {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                return Unpooled.wrappedBuffer(bytes, 0, bytes.length);\n+            }\n+        },\n+        COMPOSITE {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                CompositeByteBuf buf = Unpooled.compositeBuffer();\n+                int length = bytes.length;\n+                int offset = 0;\n+                int capacity = length / 8; // 8 buffers per composite\n+\n+                while (length > 0) {\n+                    buf.addComponent(true, Unpooled.wrappedBuffer(bytes, offset, Math.min(length, capacity)));\n+                    length -= capacity;\n+                    offset += capacity;\n+                }\n+                return buf;\n+            }\n+        },\n+        DIRECT {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                return Unpooled.directBuffer(bytes.length).writeBytes(bytes);\n+            }\n+        };\n+        abstract ByteBuf newBuffer(byte[] bytes);\n+    }\n+\n+    public enum Input {\n+        RANDOM_256B {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return new byte[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 256, ' ', 127);\n+            }\n+        },\n+        RANDOM_2KB {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return new byte[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 2048, ' ', 127);\n+            }\n+        },\n+        PREDICTABLE {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                // all 0s\n+                return new byte[64];\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                // no 0s except in the very end\n+                byte[] bytes = randomBytes(rnd, 2048, 1, 255);\n+                Arrays.fill(bytes, bytes.length - 64, bytes.length, (byte) 0);\n+                return bytes;\n+            }\n+        },\n+        UNPREDICTABLE {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return randomBytes(rnd, 64, 0, 1);\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 2048, 0, 1);\n+            }\n+        },\n+        WORST_CASE { // ShiftingBitMask will fail on it because the needle is >64 bytes long\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                // aa(...)aab\n+                byte[] needle = new byte[1024];\n+                Arrays.fill(needle, (byte) 'a');\n+                needle[needle.length - 1] = 'b';\n+                return needle;\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                // aa(...)aaa\n+                byte[] haystack = new byte[2048];\n+                Arrays.fill(haystack, (byte) 'a');\n+                return haystack;\n+            }\n+        };\n+\n+        abstract byte[] getNeedle(Random rnd);\n+        abstract byte[] getHaystack(Random rnd);\n+    }\n+\n+    @Param\n+    public Input input;\n+\n+    @Param\n+    public ByteBufType bufferType;\n+\n+    private Random rnd;\n+    private ByteBuf needle, haystack;\n+    private byte[] needleBytes, haystackBytes;\n+    private SearchProcessorFactory kmpFactory, shiftingBitMaskFactory, ahoCorasicFactory;\n+\n+    @Setup\n+    public void setup() {\n+        rnd = new Random(SEED);\n+\n+        needleBytes = input.getNeedle(rnd);\n+        haystackBytes = input.getHaystack(rnd);\n+\n+        needle = Unpooled.wrappedBuffer(needleBytes);\n+        haystack = bufferType.newBuffer(haystackBytes);\n+\n+        kmpFactory = SearchProcessorFactory.newKmpSearchProcessorFactory(needleBytes);\n+        ahoCorasicFactory = MultiSearchProcessorFactory.newAhoCorasicSearchProcessorFactory(needleBytes);\n+\n+        if (needleBytes.length <= 64) {\n+            shiftingBitMaskFactory = SearchProcessorFactory.newShiftingBitMaskSearchProcessorFactory(needleBytes);\n+        }\n+    }\n+\n+    @TearDown\n+    public void teardown() {\n+        needle.release();\n+        haystack.release();\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(Mode.DONT_INLINE)\n+    public int indexOf() {\n+        return ByteBufUtil.indexOf(needle, haystack);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(Mode.DONT_INLINE)\n+    public int kmp() {\n+        return haystack.forEachByte(kmpFactory.newSearchProcessor());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMTk5MQ=="}, "originalCommit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "originalPosition": 191}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3533, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}