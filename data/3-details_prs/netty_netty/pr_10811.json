{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1MTQ1MzYw", "number": 10811, "title": "Allow blocking calls inside SingleThreadEventExecutor.addTask", "bodyText": "Motivation:\nGlobalEventExecutor.addTask was rightfully allowed to block by commit\n09d38c8. However the same should have been done for\nSingleThreadEventExecutor.addTask.\nBlockHound is currently intercepting that call, and as a consequence,\nit prevents SingleThreadEventExecutor from working properly, if addTask is\ncalled from a thread that cannot block.\nThe interception is due to LinkedBlockingQueue.offer implementation,\nwhich uses a ReentrantLock internally.\nModifications:\n\nAdded one BlockHound exception to\nio.netty.util.internal.Hidden.NettyBlockHoundIntegration for\nSingleThreadEventExecutor.addTask.\nAlso added unit tests for both SingleThreadEventExecutor.addTask\nand GlobalEventExecutor.addTask.\n\nResult:\nSingleThreadEventExecutor.addTask can now be invoked from any thread\nwhen BlockHound is activated.", "createdAt": "2020-11-21T15:28:17Z", "url": "https://github.com/netty/netty/pull/10811", "merged": true, "mergeCommit": {"oid": "02cd85181aef2502c2f90b978453d210d08781ef"}, "closed": true, "closedAt": "2020-11-23T18:20:18Z", "author": {"login": "adutra"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdfSvjPgFqTUzNjM0OTQ4NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfYSYOgBqjQwMjg3MzA2MTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2MzQ5NDg0", "url": "https://github.com/netty/netty/pull/10811#pullrequestreview-536349484", "createdAt": "2020-11-23T10:39:06Z", "commit": {"oid": "df3a1e0727989df4be9f777394232a2a10128982"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDozOTowN1rOH4HuEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDozOTowN1rOH4HuEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwODc4Ng==", "bodyText": "using reflection will not really work with Java9+. So I think we need to come up with something different here.", "url": "https://github.com/netty/netty/pull/10811#discussion_r528608786", "createdAt": "2020-11-23T10:39:07Z", "author": {"login": "normanmaurer"}, "path": "transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java", "diffHunk": "@@ -127,6 +130,50 @@ private static void testEventExecutorTakeTask(EventExecutor eventExecutor) throw\n         latch.await();\n     }\n \n+    @Test(timeout = 5000L)\n+    public void testGlobalEventExecutorAddTask() throws Exception {\n+        testEventExecutorAddTask(GlobalEventExecutor.INSTANCE, GlobalEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    @Test(timeout = 5000L)\n+    public void testSingleThreadEventExecutorAddTask() throws Exception {\n+        SingleThreadEventExecutor executor =\n+                new SingleThreadEventExecutor(null, new DefaultThreadFactory(\"test\"), true) {\n+                    @Override\n+                    protected void run() {\n+                        while (!confirmShutdown()) {\n+                            Runnable task = takeTask();\n+                            if (task != null) {\n+                                task.run();\n+                            }\n+                        }\n+                    }\n+                };\n+        testEventExecutorAddTask(executor, SingleThreadEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    private void testEventExecutorAddTask(EventExecutor executor, Field taskQueueField) throws Exception {\n+        // artificially acquire taskQueue.putLock\n+        taskQueueField.setAccessible(true);\n+        LinkedBlockingQueue<?> taskQueue = (LinkedBlockingQueue<?>) taskQueueField.get(executor);\n+        Field putLockField = LinkedBlockingQueue.class.getDeclaredField(\"putLock\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df3a1e0727989df4be9f777394232a2a10128982"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2MzUwMjkx", "url": "https://github.com/netty/netty/pull/10811#pullrequestreview-536350291", "createdAt": "2020-11-23T10:40:14Z", "commit": {"oid": "df3a1e0727989df4be9f777394232a2a10128982"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NjYxNDk3", "url": "https://github.com/netty/netty/pull/10811#pullrequestreview-536661497", "createdAt": "2020-11-23T16:49:10Z", "commit": {"oid": "8a475b5b687da2307f192b01b509d806fb3dc10a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7934f46a35f2f3a37068c42af481737b7ed4118", "author": {"user": {"login": "adutra", "name": "Alexandre Dutra"}}, "url": "https://github.com/netty/netty/commit/c7934f46a35f2f3a37068c42af481737b7ed4118", "committedDate": "2020-11-23T17:03:49Z", "message": "Allow blocking calls inside SingleThreadEventExecutor.addTask\n\nMotivation:\n\nGlobalEventExecutor.addTask was rightfully allowed to block by commit\n09d38c8. However the same should have been done for\nSingleThreadEventExecutor.addTask.\n\nBlockHound is currently intercepting that call, and as a consequence,\nit prevents SingleThreadEventExecutor from working properly, if addTask is\ncalled from a thread that cannot block.\n\nThe interception is due to LinkedBlockingQueue.offer implementation,\nwhich uses a ReentrantLock internally.\n\nModifications:\n\n* Added one BlockHound exception to\nio.netty.util.internal.Hidden.NettyBlockHoundIntegration for\nSingleThreadEventExecutor.addTask.\n* Also added unit tests for both SingleThreadEventExecutor.addTask\nand GlobalEventExecutor.addTask.\n\nResult:\n\nSingleThreadEventExecutor.addTask can now be invoked from any thread\nwhen BlockHound is activated."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8a475b5b687da2307f192b01b509d806fb3dc10a", "author": {"user": {"login": "adutra", "name": "Alexandre Dutra"}}, "url": "https://github.com/netty/netty/commit/8a475b5b687da2307f192b01b509d806fb3dc10a", "committedDate": "2020-11-23T13:37:43Z", "message": "[fixup] Redesign tests and remove reflection"}, "afterCommit": {"oid": "c7934f46a35f2f3a37068c42af481737b7ed4118", "author": {"user": {"login": "adutra", "name": "Alexandre Dutra"}}, "url": "https://github.com/netty/netty/commit/c7934f46a35f2f3a37068c42af481737b7ed4118", "committedDate": "2020-11-23T17:03:49Z", "message": "Allow blocking calls inside SingleThreadEventExecutor.addTask\n\nMotivation:\n\nGlobalEventExecutor.addTask was rightfully allowed to block by commit\n09d38c8. However the same should have been done for\nSingleThreadEventExecutor.addTask.\n\nBlockHound is currently intercepting that call, and as a consequence,\nit prevents SingleThreadEventExecutor from working properly, if addTask is\ncalled from a thread that cannot block.\n\nThe interception is due to LinkedBlockingQueue.offer implementation,\nwhich uses a ReentrantLock internally.\n\nModifications:\n\n* Added one BlockHound exception to\nio.netty.util.internal.Hidden.NettyBlockHoundIntegration for\nSingleThreadEventExecutor.addTask.\n* Also added unit tests for both SingleThreadEventExecutor.addTask\nand GlobalEventExecutor.addTask.\n\nResult:\n\nSingleThreadEventExecutor.addTask can now be invoked from any thread\nwhen BlockHound is activated."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4852, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}