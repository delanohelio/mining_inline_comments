{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwMTM4OTQ3", "number": 10171, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOTo1OTozOFrODvfO9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOTo1OTozOFrODvfO9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTIxMzk5OnYy", "diffSide": "RIGHT", "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOTo1OTozOFrOGB8I5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDoxOTozMlrOGB83Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzA3Ng==", "bodyText": "@minwoox I wonder if a better approach would be to ensure we propagate cancellation by attaching a FutureListener to original promise and call promise.cancel(...) if needed. WDYT ?", "url": "https://github.com/netty/netty/pull/10171#discussion_r404687076", "createdAt": "2020-04-07T09:59:38Z", "author": {"login": "normanmaurer"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -352,7 +354,7 @@ private void query(final DnsServerAddressStream nameServerAddrStream,\n                        final Promise<List<T>> promise,\n                        final Throwable cause) {\n         if (completeEarly || nameServerAddrStreamIndex >= nameServerAddrStream.size() ||\n-                allowedQueries == 0 || promise.isCancelled()) {\n+                allowedQueries == 0 || originalPromise.isCancelled() || promise.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61de103075758e9ca4b03feb346948bdc724448f"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NTUyOQ==", "bodyText": "Ah, that was actually my first thought but it makes a little complicated in some cases. For example:\n1. Call resolve(String inetHost, Promise<T> promise); // The promise here is the original promise\n2. Call doResolveUncached() in DnsNameResolver. // A new allPromise is newly created and passed.\n3. Call DnsAddressResolveContext.resolve(promise). // The promise here is the allPromise which created in #2.\n4. In resolve() searchDomainPromise is created and used.\n\nIn this flow, there are three Promises involved (originalPromise, allPromise and searchDomainPromise), so we have to add two listerers.\nSo that's the reason that I have chosen this way, but if you think adding listerner is better, then I can change it. \ud83d\ude04", "url": "https://github.com/netty/netty/pull/10171#discussion_r404695529", "createdAt": "2020-04-07T10:13:48Z", "author": {"login": "minwoox"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -352,7 +354,7 @@ private void query(final DnsServerAddressStream nameServerAddrStream,\n                        final Promise<List<T>> promise,\n                        final Throwable cause) {\n         if (completeEarly || nameServerAddrStreamIndex >= nameServerAddrStream.size() ||\n-                allowedQueries == 0 || promise.isCancelled()) {\n+                allowedQueries == 0 || originalPromise.isCancelled() || promise.isCancelled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzA3Ng=="}, "originalCommit": {"oid": "61de103075758e9ca4b03feb346948bdc724448f"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5ODg5MQ==", "bodyText": "@minwoox makes sense.. was just an idea but I guess what you did here is good enough and is less complex.", "url": "https://github.com/netty/netty/pull/10171#discussion_r404698891", "createdAt": "2020-04-07T10:19:32Z", "author": {"login": "normanmaurer"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -352,7 +354,7 @@ private void query(final DnsServerAddressStream nameServerAddrStream,\n                        final Promise<List<T>> promise,\n                        final Throwable cause) {\n         if (completeEarly || nameServerAddrStreamIndex >= nameServerAddrStream.size() ||\n-                allowedQueries == 0 || promise.isCancelled()) {\n+                allowedQueries == 0 || originalPromise.isCancelled() || promise.isCancelled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzA3Ng=="}, "originalCommit": {"oid": "61de103075758e9ca4b03feb346948bdc724448f"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3390, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}