{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3NjkwNTk4", "number": 10527, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMToyMTo0NlrOEfaKMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNzo1OToyOVrOEuxUQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzY5OTA1OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMToyMTo0NlrOHLqj2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMToyMTo0NlrOHLqj2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5MzY5MQ==", "bodyText": "This is a non-compatible change as a user may have override the method with the throws Exception declaration", "url": "https://github.com/netty/netty/pull/10527#discussion_r481993691", "createdAt": "2020-09-02T11:21:46Z", "author": {"login": "normanmaurer"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -24,29 +24,41 @@\n import java.net.SocketAddress;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n  */\n @Sharable\n public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n \n     private final IpFilterRule[] rules;\n \n-    public RuleBasedIpFilter(IpFilterRule... rules) {\n+    /**\n+     * Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied.\n+     *\n+     * @param rules An array of {@link IpFilterRule} containing all rules.\n+     * @throws NullPointerException If {@code rules} array or {@code rule} in\n+     *                              {@code rules} array is {@code null}.\n+     */\n+    public RuleBasedIpFilter(IpFilterRule... rules) throws NullPointerException {\n         this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        for (IpFilterRule rule : this.rules) {\n+            ObjectUtil.checkNotNull(rule, \"rule\");\n+        }\n     }\n \n     @Override\n-    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c03c78690fa3e8bf7eeae4089421ce1711a0af0"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzcwMDc3OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMToyMjoxMlrOHLqk5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDoyNTowMlrOHLxsYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Mzk1OQ==", "bodyText": "This is a non compatible change in behaviour imho...", "url": "https://github.com/netty/netty/pull/10527#discussion_r481993959", "createdAt": "2020-09-02T11:22:12Z", "author": {"login": "normanmaurer"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -24,29 +24,41 @@\n import java.net.SocketAddress;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n  */\n @Sharable\n public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n \n     private final IpFilterRule[] rules;\n \n-    public RuleBasedIpFilter(IpFilterRule... rules) {\n+    /**\n+     * Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied.\n+     *\n+     * @param rules An array of {@link IpFilterRule} containing all rules.\n+     * @throws NullPointerException If {@code rules} array or {@code rule} in\n+     *                              {@code rules} array is {@code null}.\n+     */\n+    public RuleBasedIpFilter(IpFilterRule... rules) throws NullPointerException {\n         this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        for (IpFilterRule rule : this.rules) {\n+            ObjectUtil.checkNotNull(rule, \"rule\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c03c78690fa3e8bf7eeae4089421ce1711a0af0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5NTM0Ng==", "bodyText": "So how to tackle this? By removing throws NullPointerException?", "url": "https://github.com/netty/netty/pull/10527#discussion_r481995346", "createdAt": "2020-09-02T11:24:45Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -24,29 +24,41 @@\n import java.net.SocketAddress;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n  */\n @Sharable\n public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n \n     private final IpFilterRule[] rules;\n \n-    public RuleBasedIpFilter(IpFilterRule... rules) {\n+    /**\n+     * Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied.\n+     *\n+     * @param rules An array of {@link IpFilterRule} containing all rules.\n+     * @throws NullPointerException If {@code rules} array or {@code rule} in\n+     *                              {@code rules} array is {@code null}.\n+     */\n+    public RuleBasedIpFilter(IpFilterRule... rules) throws NullPointerException {\n         this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        for (IpFilterRule rule : this.rules) {\n+            ObjectUtil.checkNotNull(rule, \"rule\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Mzk1OQ=="}, "originalCommit": {"oid": "4c03c78690fa3e8bf7eeae4089421ce1711a0af0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5NTg4Mg==", "bodyText": "Since we're already throwing NullPointerException, I can remove throws NullPointerException and let it throw NullPointerException normally.", "url": "https://github.com/netty/netty/pull/10527#discussion_r481995882", "createdAt": "2020-09-02T11:25:42Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -24,29 +24,41 @@\n import java.net.SocketAddress;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n  */\n @Sharable\n public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n \n     private final IpFilterRule[] rules;\n \n-    public RuleBasedIpFilter(IpFilterRule... rules) {\n+    /**\n+     * Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied.\n+     *\n+     * @param rules An array of {@link IpFilterRule} containing all rules.\n+     * @throws NullPointerException If {@code rules} array or {@code rule} in\n+     *                              {@code rules} array is {@code null}.\n+     */\n+    public RuleBasedIpFilter(IpFilterRule... rules) throws NullPointerException {\n         this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        for (IpFilterRule rule : this.rules) {\n+            ObjectUtil.checkNotNull(rule, \"rule\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Mzk1OQ=="}, "originalCommit": {"oid": "4c03c78690fa3e8bf7eeae4089421ce1711a0af0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwNjQ3NA==", "bodyText": "It's sort of a strange behaviour that rule processing stops at the first null element.\nYou can scan the array to see if there are any nulls, and if so, replace the array with its first non-null sub-sequence. Assuming the mutability of the array is not part of the API. It's not clear.", "url": "https://github.com/netty/netty/pull/10527#discussion_r482106474", "createdAt": "2020-09-02T14:19:46Z", "author": {"login": "chrisvest"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -24,29 +24,41 @@\n import java.net.SocketAddress;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n  */\n @Sharable\n public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n \n     private final IpFilterRule[] rules;\n \n-    public RuleBasedIpFilter(IpFilterRule... rules) {\n+    /**\n+     * Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied.\n+     *\n+     * @param rules An array of {@link IpFilterRule} containing all rules.\n+     * @throws NullPointerException If {@code rules} array or {@code rule} in\n+     *                              {@code rules} array is {@code null}.\n+     */\n+    public RuleBasedIpFilter(IpFilterRule... rules) throws NullPointerException {\n         this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        for (IpFilterRule rule : this.rules) {\n+            ObjectUtil.checkNotNull(rule, \"rule\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Mzk1OQ=="}, "originalCommit": {"oid": "4c03c78690fa3e8bf7eeae4089421ce1711a0af0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExMDU2Mg==", "bodyText": "Yeah, I think this will work. We should remove not null rules.", "url": "https://github.com/netty/netty/pull/10527#discussion_r482110562", "createdAt": "2020-09-02T14:25:02Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -24,29 +24,41 @@\n import java.net.SocketAddress;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n  */\n @Sharable\n public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n \n     private final IpFilterRule[] rules;\n \n-    public RuleBasedIpFilter(IpFilterRule... rules) {\n+    /**\n+     * Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied.\n+     *\n+     * @param rules An array of {@link IpFilterRule} containing all rules.\n+     * @throws NullPointerException If {@code rules} array or {@code rule} in\n+     *                              {@code rules} array is {@code null}.\n+     */\n+    public RuleBasedIpFilter(IpFilterRule... rules) throws NullPointerException {\n         this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        for (IpFilterRule rule : this.rules) {\n+            ObjectUtil.checkNotNull(rule, \"rule\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Mzk1OQ=="}, "originalCommit": {"oid": "4c03c78690fa3e8bf7eeae4089421ce1711a0af0"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NjMyNjMxOnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMjoxMzoxMFrOHiEu5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxMjoyMToxNlrOHiFBmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MTE3NA==", "bodyText": "nit: I would remove \"super fast\" here... what does this even mean ?", "url": "https://github.com/netty/netty/pull/10527#discussion_r505491174", "createdAt": "2020-10-15T12:13:10Z", "author": {"login": "normanmaurer"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -22,36 +22,71 @@\n \n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n+ *\n+ * <p> You can also consider using {@link IpSubnetFilter} which uses Binary Search Algorithm\n+ * for super fast IP Address filtering. </p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "384954c7afa0d164aadd8c47f1eb1b30dbd52022"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5NTA1MA==", "bodyText": "RuleBasedIpFilter uses a for-each loop but IpSubnetFilter uses Binary Search which is a lot faster and should be considered over RuleBasedIpFilter that's why I added \"Super fast\" there.\nShould I remove?", "url": "https://github.com/netty/netty/pull/10527#discussion_r505495050", "createdAt": "2020-10-15T12:19:49Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -22,36 +22,71 @@\n \n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n+ *\n+ * <p> You can also consider using {@link IpSubnetFilter} which uses Binary Search Algorithm\n+ * for super fast IP Address filtering. </p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MTE3NA=="}, "originalCommit": {"oid": "384954c7afa0d164aadd8c47f1eb1b30dbd52022"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5NTk2MA==", "bodyText": "Maybe just use something like:\nConsider using {@link IpSubnetFilter} for better performance while not as general purpose as this filter.", "url": "https://github.com/netty/netty/pull/10527#discussion_r505495960", "createdAt": "2020-10-15T12:21:16Z", "author": {"login": "normanmaurer"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -22,36 +22,71 @@\n \n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n+ *\n+ * <p> You can also consider using {@link IpSubnetFilter} which uses Binary Search Algorithm\n+ * for super fast IP Address filtering. </p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MTE3NA=="}, "originalCommit": {"oid": "384954c7afa0d164aadd8c47f1eb1b30dbd52022"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDc3OTUzOnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNzo1OToyOVrOHjYaLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwODowNzozN1rOHjYvMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MjEyNw==", "bodyText": "nit: Please do use new ArrayList(rules.length)", "url": "https://github.com/netty/netty/pull/10527#discussion_r506862127", "createdAt": "2020-10-17T07:59:29Z", "author": {"login": "normanmaurer"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -22,36 +22,71 @@\n \n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n+ *\n+ * <p> Consider using {@link IpSubnetFilter} for better performance while not as\n+ * general purpose as this filter. </p>\n  */\n @Sharable\n public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n \n-    private final IpFilterRule[] rules;\n+    private final boolean acceptIfNotFound;\n+    private final List<IpFilterRule> rules;\n \n+    /**\n+     * <p> Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied. </p>\n+     *\n+     * <p> {@code acceptIfNotFound} is set to {@code true}. </p>\n+     *\n+     * @param rules An array of {@link IpFilterRule} containing all rules.\n+     */\n     public RuleBasedIpFilter(IpFilterRule... rules) {\n-        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this(true, rules);\n     }\n \n-    @Override\n-    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+    /**\n+     * Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied.\n+     *\n+     * @param acceptIfNotFound If {@code true} then accept connection from IP Address if it\n+     *                         doesn't match any rule.\n+     * @param rules            An array of {@link IpFilterRule} containing all rules.\n+     */\n+    public RuleBasedIpFilter(boolean acceptIfNotFound, IpFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        this.acceptIfNotFound = acceptIfNotFound;\n+        this.rules = new ArrayList<IpFilterRule>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b849bdfcdfe1f80441976c70e0c3de3d938a9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MjgzOA==", "bodyText": "If the rules array contains null, we will waste Arraylist capacity because we filter null rules later on.", "url": "https://github.com/netty/netty/pull/10527#discussion_r506862838", "createdAt": "2020-10-17T08:02:11Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -22,36 +22,71 @@\n \n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n+ *\n+ * <p> Consider using {@link IpSubnetFilter} for better performance while not as\n+ * general purpose as this filter. </p>\n  */\n @Sharable\n public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n \n-    private final IpFilterRule[] rules;\n+    private final boolean acceptIfNotFound;\n+    private final List<IpFilterRule> rules;\n \n+    /**\n+     * <p> Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied. </p>\n+     *\n+     * <p> {@code acceptIfNotFound} is set to {@code true}. </p>\n+     *\n+     * @param rules An array of {@link IpFilterRule} containing all rules.\n+     */\n     public RuleBasedIpFilter(IpFilterRule... rules) {\n-        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this(true, rules);\n     }\n \n-    @Override\n-    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+    /**\n+     * Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied.\n+     *\n+     * @param acceptIfNotFound If {@code true} then accept connection from IP Address if it\n+     *                         doesn't match any rule.\n+     * @param rules            An array of {@link IpFilterRule} containing all rules.\n+     */\n+    public RuleBasedIpFilter(boolean acceptIfNotFound, IpFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        this.acceptIfNotFound = acceptIfNotFound;\n+        this.rules = new ArrayList<IpFilterRule>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MjEyNw=="}, "originalCommit": {"oid": "0f8b849bdfcdfe1f80441976c70e0c3de3d938a9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2NTA5NA==", "bodyText": "its very unlikely it contains null... so better use the length so we not need to \"grow\" the list.", "url": "https://github.com/netty/netty/pull/10527#discussion_r506865094", "createdAt": "2020-10-17T08:05:22Z", "author": {"login": "normanmaurer"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -22,36 +22,71 @@\n \n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n+ *\n+ * <p> Consider using {@link IpSubnetFilter} for better performance while not as\n+ * general purpose as this filter. </p>\n  */\n @Sharable\n public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n \n-    private final IpFilterRule[] rules;\n+    private final boolean acceptIfNotFound;\n+    private final List<IpFilterRule> rules;\n \n+    /**\n+     * <p> Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied. </p>\n+     *\n+     * <p> {@code acceptIfNotFound} is set to {@code true}. </p>\n+     *\n+     * @param rules An array of {@link IpFilterRule} containing all rules.\n+     */\n     public RuleBasedIpFilter(IpFilterRule... rules) {\n-        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this(true, rules);\n     }\n \n-    @Override\n-    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+    /**\n+     * Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied.\n+     *\n+     * @param acceptIfNotFound If {@code true} then accept connection from IP Address if it\n+     *                         doesn't match any rule.\n+     * @param rules            An array of {@link IpFilterRule} containing all rules.\n+     */\n+    public RuleBasedIpFilter(boolean acceptIfNotFound, IpFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        this.acceptIfNotFound = acceptIfNotFound;\n+        this.rules = new ArrayList<IpFilterRule>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MjEyNw=="}, "originalCommit": {"oid": "0f8b849bdfcdfe1f80441976c70e0c3de3d938a9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2NzUwNg==", "bodyText": "Done", "url": "https://github.com/netty/netty/pull/10527#discussion_r506867506", "createdAt": "2020-10-17T08:07:37Z", "author": {"login": "hyperxpro"}, "path": "handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java", "diffHunk": "@@ -22,36 +22,71 @@\n \n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n+ * <p>\n  * This class allows one to filter new {@link Channel}s based on the\n  * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections\n  * will be accepted.\n+ * </p>\n  *\n+ * <p>\n  * If you would like to explicitly take action on rejected {@link Channel}s, you should override\n  * {@link AbstractRemoteAddressFilter#channelRejected(ChannelHandlerContext, SocketAddress)}.\n+ * </p>\n+ *\n+ * <p> Consider using {@link IpSubnetFilter} for better performance while not as\n+ * general purpose as this filter. </p>\n  */\n @Sharable\n public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n \n-    private final IpFilterRule[] rules;\n+    private final boolean acceptIfNotFound;\n+    private final List<IpFilterRule> rules;\n \n+    /**\n+     * <p> Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied. </p>\n+     *\n+     * <p> {@code acceptIfNotFound} is set to {@code true}. </p>\n+     *\n+     * @param rules An array of {@link IpFilterRule} containing all rules.\n+     */\n     public RuleBasedIpFilter(IpFilterRule... rules) {\n-        this.rules = ObjectUtil.checkNotNull(rules, \"rules\");\n+        this(true, rules);\n     }\n \n-    @Override\n-    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+    /**\n+     * Create new Instance of {@link RuleBasedIpFilter} and filter incoming connections\n+     * based on their IP address and {@code rules} applied.\n+     *\n+     * @param acceptIfNotFound If {@code true} then accept connection from IP Address if it\n+     *                         doesn't match any rule.\n+     * @param rules            An array of {@link IpFilterRule} containing all rules.\n+     */\n+    public RuleBasedIpFilter(boolean acceptIfNotFound, IpFilterRule... rules) {\n+        ObjectUtil.checkNotNull(rules, \"rules\");\n+\n+        this.acceptIfNotFound = acceptIfNotFound;\n+        this.rules = new ArrayList<IpFilterRule>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MjEyNw=="}, "originalCommit": {"oid": "0f8b849bdfcdfe1f80441976c70e0c3de3d938a9"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3687, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}