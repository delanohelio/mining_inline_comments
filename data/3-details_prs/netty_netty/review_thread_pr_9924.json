{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMTM3MTc1", "number": 9924, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjo0OTowN1rODZkBYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDoxMzowMFrODbO_Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTMxMTcwOnYy", "diffSide": "RIGHT", "path": "codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjo0OTowN1rOFgBOFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxODo0OTozOFrOFgE7kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTExODc0MQ==", "bodyText": "Can you add to the doc describing what 0 does?", "url": "https://github.com/netty/netty/pull/9924#discussion_r369118741", "createdAt": "2020-01-21T16:49:07Z", "author": {"login": "carl-mastrangelo"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java", "diffHunk": "@@ -35,7 +35,17 @@\n      * @throws DecompressionException if failed to initialize zlib\n      */\n     public JZlibDecoder() {\n-        this(ZlibWrapper.ZLIB);\n+        this(ZlibWrapper.ZLIB, 0);\n+    }\n+\n+    /**\n+     * Creates a new instance with the default wrapper ({@link ZlibWrapper#ZLIB})\n+     * and specified maximum buffer allocation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE3OTUzNw==", "bodyText": "+1", "url": "https://github.com/netty/netty/pull/9924#discussion_r369179537", "createdAt": "2020-01-21T18:49:38Z", "author": {"login": "njhill"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java", "diffHunk": "@@ -35,7 +35,17 @@\n      * @throws DecompressionException if failed to initialize zlib\n      */\n     public JZlibDecoder() {\n-        this(ZlibWrapper.ZLIB);\n+        this(ZlibWrapper.ZLIB, 0);\n+    }\n+\n+    /**\n+     * Creates a new instance with the default wrapper ({@link ZlibWrapper#ZLIB})\n+     * and specified maximum buffer allocation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTExODc0MQ=="}, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTMxMjM3OnYy", "diffSide": "RIGHT", "path": "codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjo0OToxOVrOFgBOgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjo0OToxOVrOFgBOgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTExODg1MA==", "bodyText": "same comment", "url": "https://github.com/netty/netty/pull/9924#discussion_r369118850", "createdAt": "2020-01-21T16:49:19Z", "author": {"login": "carl-mastrangelo"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java", "diffHunk": "@@ -44,6 +54,17 @@ public JZlibDecoder() {\n      * @throws DecompressionException if failed to initialize zlib\n      */\n     public JZlibDecoder(ZlibWrapper wrapper) {\n+        this(wrapper, 0);\n+    }\n+\n+    /**\n+     * Creates a new instance with the specified wrapper and maximum buffer allocation.\n+     *\n+     * @throws DecompressionException if failed to initialize zlib\n+     */\n+    public JZlibDecoder(ZlibWrapper wrapper, int maxAllocation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTMyMzAwOnYy", "diffSide": "RIGHT", "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjo1MjoxNlrOFgBVMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoxNDo0M1rOFhLRwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEyMDU2Mw==", "bodyText": "can this be private/final?", "url": "https://github.com/netty/netty/pull/9924#discussion_r369120563", "createdAt": "2020-01-21T16:52:16Z", "author": {"login": "carl-mastrangelo"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzMjA5OA==", "bodyText": "I'll make it final but leave it as protected in case a subclass wants to read it for any reason.", "url": "https://github.com/netty/netty/pull/9924#discussion_r370332098", "createdAt": "2020-01-23T20:14:43Z", "author": {"login": "rdicroce"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEyMDU2Mw=="}, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTMyNzQ1OnYy", "diffSide": "RIGHT", "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjo1MzoyM1rOFgBX8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDoyNjo1OVrOFhLmcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEyMTI2NA==", "bodyText": "optional: check preferredSize is non-negative?", "url": "https://github.com/netty/netty/pull/9924#discussion_r369121264", "createdAt": "2020-01-21T16:53:23Z", "author": {"login": "carl-mastrangelo"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {\n+                return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE4NTg1NQ==", "bodyText": "For consistency shouldn't maxAllocationReached be called here in the preferredSize < maxAllocation case?", "url": "https://github.com/netty/netty/pull/9924#discussion_r369185855", "createdAt": "2020-01-21T19:02:29Z", "author": {"login": "njhill"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {\n+                return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEyMTI2NA=="}, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyNDUwNA==", "bodyText": "preferredSize was not checked by the existing code, and adding a check will actually duplicate the check because ByteBuf or ByteBufAllocator (whichever is ultimately called) will check that it's non-negative.\nAbout the preferredSize < maxAllocation case, I'm not following you. preferredSize will often be less than maxAllocation since preferredSize is a guesstimate of how much more space is needed to finish decompressing the input. So e.g. maxAllocation might be set to 1 MiB but the decoder estimates it only needs 10 KiB to finish decompressing.", "url": "https://github.com/netty/netty/pull/9924#discussion_r370324504", "createdAt": "2020-01-23T19:56:49Z", "author": {"login": "rdicroce"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {\n+                return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEyMTI2NA=="}, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzMzcxNg==", "bodyText": "@rdicroce apologies, I meant preferredSize > maxAllocation", "url": "https://github.com/netty/netty/pull/9924#discussion_r370333716", "createdAt": "2020-01-23T20:18:24Z", "author": {"login": "njhill"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {\n+                return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEyMTI2NA=="}, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNzM5NA==", "bodyText": "Since preferredSize is a guesstimate of how much space is needed, it's possible that the compression ratio is poor and we don't need that much space. So e.g. the compressed size could be 100 KiB, and so JdkZlibDecoder and ZlibDecoder estimate they need 200 KiB to decompress. So they pass preferredSize = 200 KiB but then it turns out the decompressed data is only 150 KiB in size. If maxAllocation is 175 KiB, then decompression ought to succeed since 150 < 175, even though 200 > 175.", "url": "https://github.com/netty/netty/pull/9924#discussion_r370337394", "createdAt": "2020-01-23T20:26:59Z", "author": {"login": "rdicroce"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {\n+                return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEyMTI2NA=="}, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTY5NzY0OnYy", "diffSide": "RIGHT", "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxODo1MTowN1rOFgE-gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxODo1MTowN1rOFgE-gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE4MDI4OQ==", "bodyText": "nit: else block not needed", "url": "https://github.com/netty/netty/pull/9924#discussion_r369180289", "createdAt": "2020-01-21T18:51:07Z", "author": {"login": "njhill"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTcxMzk4OnYy", "diffSide": "RIGHT", "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxODo1Njo0M1rOFgFJMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDo1MToxM1rOFhMOOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE4MzAyNQ==", "bodyText": "I think either the second ensureWritable param should be false or the return should be compared to 3 rather than 1?", "url": "https://github.com/netty/netty/pull/9924#discussion_r369183025", "createdAt": "2020-01-21T18:56:43Z", "author": {"login": "njhill"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {\n+                return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);\n+            }\n+        }\n+\n+        if (buffer.ensureWritable(preferredSize, true) == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyNzEyNg==", "bodyText": "I'm pretty sure this is correct as-is. The desired behavior is that if capacity < maxAllocation, we want to expand the buffer, even if we can't expand it by the preferredSize. Any expansion at all makes it possible that the decoder will successfully complete the decompression, since preferredSize is just a guesstimate. Hence we want to expand even if the expansion is less than what we'd prefer. If it turns out that's not enough space, then this method will be called again, and the buffer will already have capacity = maxAllocation and remaining = 0, and we'll fail at that point.", "url": "https://github.com/netty/netty/pull/9924#discussion_r370327126", "createdAt": "2020-01-23T20:02:42Z", "author": {"login": "rdicroce"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {\n+                return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);\n+            }\n+        }\n+\n+        if (buffer.ensureWritable(preferredSize, true) == 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE4MzAyNQ=="}, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NzU3Ng==", "bodyText": "OK I follow now, I missed that subtlety of ensureWritable, thinking that 1 would only apply to the force == false case. This is the same confusion as the comment above and I see that your logic there is consistent. Sorry!\nIt probably wouldn't harm to add a comment noting that one \"final\" attempt will always still be made with the buffer at maxAllocation even if that is < preferredSize.", "url": "https://github.com/netty/netty/pull/9924#discussion_r370347576", "createdAt": "2020-01-23T20:51:13Z", "author": {"login": "njhill"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {\n+                return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);\n+            }\n+        }\n+\n+        if (buffer.ensureWritable(preferredSize, true) == 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE4MzAyNQ=="}, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTc0NDExOnYy", "diffSide": "RIGHT", "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOTowNzowOFrOFgFcjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMDowOTozN1rOFhLJew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE4Nzk4Mw==", "bodyText": "Not sure that the semantics of the method are clear... if it's overridden to not throw then what state will the provided buffer be in, what is the impl expected to do with it and what is it expected to return? Maybe it would make most sense to pass false for the force param of ensureWritable above so that the buffer isn't changed, and also pass preferredSize and ctx to this method as additional parameters?\nnit: and maybe clearer method name would be something like decompressionBufferExhausted?", "url": "https://github.com/netty/netty/pull/9924#discussion_r369187983", "createdAt": "2020-01-21T19:07:08Z", "author": {"login": "njhill"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {\n+                return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);\n+            }\n+        }\n+\n+        if (buffer.ensureWritable(preferredSize, true) == 1) {\n+            return maxAllocationReached(buffer);\n+        }\n+\n+        return buffer;\n+    }\n+\n+    /**\n+     * Called when the decompression buffer cannot be expanded further.\n+     * Default implementation throws an exception, but subclasses can override to change behavior.\n+     */\n+    protected ByteBuf maxAllocationReached(ByteBuf buffer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTk3OQ==", "bodyText": "You're right that this probably shouldn't return anything - I'll change that. Can't remember exactly what I was thinking when I did that. My use case for wanting to override this is so that I can potentially log the data that has been decompressed so far before throwing the exception.", "url": "https://github.com/netty/netty/pull/9924#discussion_r370329979", "createdAt": "2020-01-23T20:09:37Z", "author": {"login": "rdicroce"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,72 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {\n+        if (maxAllocation < 0) {\n+            throw new IllegalArgumentException(\"maxAllocation must be >= 0\");\n+        }\n+        this.maxAllocation = maxAllocation;\n+    }\n+\n     /**\n      * Returns {@code true} if and only if the end of the compressed stream\n      * has been reached.\n      */\n     public abstract boolean isClosed();\n+\n+    /**\n+     * Allocate or expand the decompression buffer, without exceeding the maximum allocation.\n+     * Calls {@link #maxAllocationReached(ByteBuf)} if the buffer is full and cannot be expanded further.\n+     */\n+    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf buffer, int preferredSize) {\n+        if (buffer == null) {\n+            if (maxAllocation == 0) {\n+                return ctx.alloc().heapBuffer(preferredSize);\n+            } else {\n+                return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);\n+            }\n+        }\n+\n+        if (buffer.ensureWritable(preferredSize, true) == 1) {\n+            return maxAllocationReached(buffer);\n+        }\n+\n+        return buffer;\n+    }\n+\n+    /**\n+     * Called when the decompression buffer cannot be expanded further.\n+     * Default implementation throws an exception, but subclasses can override to change behavior.\n+     */\n+    protected ByteBuf maxAllocationReached(ByteBuf buffer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE4Nzk4Mw=="}, "originalCommit": {"oid": "57e272aa5dbad10cc0dfd38a92f8eabdbb2131e0"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODgzMDcwOnYy", "diffSide": "RIGHT", "path": "codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDoxMToyMlrOFimVYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDoxMToyMlrOFimVYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyMzk2OQ==", "bodyText": "nit: final", "url": "https://github.com/netty/netty/pull/9924#discussion_r371823969", "createdAt": "2020-01-28T14:11:22Z", "author": {"login": "normanmaurer"}, "path": "codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java", "diffHunk": "@@ -360,4 +381,34 @@ public void testZLIB_OR_NONE3() throws Exception {\n         stream.close();\n         return out.toByteArray();\n     }\n+\n+    private static class TestByteBufAllocator extends AbstractByteBufAllocator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf4389f333cc1a8647e05ce3b1d07bb0aa9b387"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODgzMjQ4OnYy", "diffSide": "RIGHT", "path": "codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDoxMTo1MlrOFimWhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNDo0MjoyMVrOFjKzpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyNDI2Mw==", "bodyText": "call chDecoder.finish() and assert the return value", "url": "https://github.com/netty/netty/pull/9924#discussion_r371824263", "createdAt": "2020-01-28T14:11:52Z", "author": {"login": "normanmaurer"}, "path": "codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java", "diffHunk": "@@ -345,6 +351,21 @@ public void testZLIB_OR_NONE3() throws Exception {\n         testCompressLarge(ZlibWrapper.GZIP, ZlibWrapper.ZLIB_OR_NONE);\n     }\n \n+    @Test\n+    public void testMaxAllocation() throws Exception {\n+        int maxAllocation = 1024;\n+        EmbeddedChannel chDecoder = new EmbeddedChannel(createDecoder(ZlibWrapper.NONE, maxAllocation));\n+        TestByteBufAllocator alloc = new TestByteBufAllocator(chDecoder.alloc());\n+        chDecoder.config().setAllocator(alloc);\n+\n+        try {\n+            chDecoder.writeInbound(Unpooled.copiedBuffer(BYTES_LARGE));\n+            fail(\"decompressed size > maxAllocation, so should have thrown exception\");\n+        } catch (DecompressionException e) {\n+            assertEquals(maxAllocation, alloc.getMaxAllocation());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf4389f333cc1a8647e05ce3b1d07bb0aa9b387"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyMTU0Mw==", "bodyText": "Good catch - finish() was throwing an exception because the input buffer wasn't being consumed and the decoders weren't marking themselves as finished, so another attempt was being made to read the buffer. I've updated JZlibDecoder and JdkZlibDecoder to consume the buffer and mark themselves as finished at the same time they release the decompression buffer.", "url": "https://github.com/netty/netty/pull/9924#discussion_r372421543", "createdAt": "2020-01-29T14:42:21Z", "author": {"login": "rdicroce"}, "path": "codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java", "diffHunk": "@@ -345,6 +351,21 @@ public void testZLIB_OR_NONE3() throws Exception {\n         testCompressLarge(ZlibWrapper.GZIP, ZlibWrapper.ZLIB_OR_NONE);\n     }\n \n+    @Test\n+    public void testMaxAllocation() throws Exception {\n+        int maxAllocation = 1024;\n+        EmbeddedChannel chDecoder = new EmbeddedChannel(createDecoder(ZlibWrapper.NONE, maxAllocation));\n+        TestByteBufAllocator alloc = new TestByteBufAllocator(chDecoder.alloc());\n+        chDecoder.config().setAllocator(alloc);\n+\n+        try {\n+            chDecoder.writeInbound(Unpooled.copiedBuffer(BYTES_LARGE));\n+            fail(\"decompressed size > maxAllocation, so should have thrown exception\");\n+        } catch (DecompressionException e) {\n+            assertEquals(maxAllocation, alloc.getMaxAllocation());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyNDI2Mw=="}, "originalCommit": {"oid": "5cf4389f333cc1a8647e05ce3b1d07bb0aa9b387"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODgzNjk2OnYy", "diffSide": "RIGHT", "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDoxMjo1NlrOFimZIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDoxMjo1NlrOFimZIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyNDkzMA==", "bodyText": "nit: protected (as this is an abstract class)", "url": "https://github.com/netty/netty/pull/9924#discussion_r371824930", "createdAt": "2020-01-28T14:12:56Z", "author": {"login": "normanmaurer"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,75 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected final int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf4389f333cc1a8647e05ce3b1d07bb0aa9b387"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODgzNzExOnYy", "diffSide": "RIGHT", "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDoxMzowMFrOFimZQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNDoxMzowMFrOFimZQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyNDk2MQ==", "bodyText": "nit: protected (as this is an abstract class)", "url": "https://github.com/netty/netty/pull/9924#discussion_r371824961", "createdAt": "2020-01-28T14:13:00Z", "author": {"login": "normanmaurer"}, "path": "codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java", "diffHunk": "@@ -16,16 +16,75 @@\n package io.netty.handler.codec.compression;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n /**\n  * Decompresses a {@link ByteBuf} using the deflate algorithm.\n  */\n public abstract class ZlibDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Maximum allowed size of the decompression buffer.\n+     */\n+    protected final int maxAllocation;\n+\n+    /**\n+     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.\n+     */\n+    public ZlibDecoder() {\n+        this(0);\n+    }\n+\n+    /**\n+     * Construct a new ZlibDecoder.\n+     * @param maxAllocation\n+     *          Maximum size of the decompression buffer. Must be &gt;= 0.\n+     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.\n+     */\n+    public ZlibDecoder(int maxAllocation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf4389f333cc1a8647e05ce3b1d07bb0aa9b387"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3519, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}