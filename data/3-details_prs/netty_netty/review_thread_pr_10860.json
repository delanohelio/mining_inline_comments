{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM3MDI0MzYw", "number": 10860, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODo1MDoyNlrOFEHnbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTowMDowM1rOFEH5Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODYzNDA1OnYy", "diffSide": "RIGHT", "path": "handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODo1MDoyNlrOIEFjRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODo1MDoyNlrOIEFjRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE1NjE2Nw==", "bodyText": "Consider having 2 independent queues for client and server to make sure both of them see the same number if events.", "url": "https://github.com/netty/netty/pull/10860#discussion_r541156167", "createdAt": "2020-12-11T18:50:26Z", "author": {"login": "idelpivnitskiy"}, "path": "handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java", "diffHunk": "@@ -1482,4 +1482,102 @@ protected void initChannel(Channel ch) {\n         }\n     }\n \n+    @Test\n+    public void testHandshakeEventsTls12JDK() throws Exception {\n+        testHandshakeEvents(SslProvider.JDK, SslUtils.PROTOCOL_TLS_V1_2);\n+    }\n+\n+    @Test\n+    public void testHandshakeEventsTls12Openssl() throws Exception {\n+        assumeTrue(OpenSsl.isAvailable());\n+        testHandshakeEvents(SslProvider.OPENSSL, SslUtils.PROTOCOL_TLS_V1_2);\n+    }\n+\n+    @Test\n+    public void testHandshakeEventsTls13JDK() throws Exception {\n+        assumeTrue(SslProvider.isTlsv13Supported(SslProvider.JDK));\n+        testHandshakeEvents(SslProvider.JDK, SslUtils.PROTOCOL_TLS_V1_3);\n+    }\n+\n+    @Test\n+    public void testHandshakeEventsTls13Openssl() throws Exception {\n+        assumeTrue(OpenSsl.isAvailable());\n+        assumeTrue(SslProvider.isTlsv13Supported(SslProvider.OPENSSL));\n+        testHandshakeEvents(SslProvider.OPENSSL, SslUtils.PROTOCOL_TLS_V1_3);\n+    }\n+\n+    private void testHandshakeEvents(SslProvider provider, String protocol) throws Exception {\n+        final SslContext sslClientCtx = SslContextBuilder.forClient()\n+                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n+                .protocols(protocol)\n+                .sslProvider(provider).build();\n+\n+        final SelfSignedCertificate cert = new SelfSignedCertificate();\n+        final SslContext sslServerCtx = SslContextBuilder.forServer(cert.key(), cert.cert())\n+                .protocols(protocol)\n+                .sslProvider(provider).build();\n+\n+        EventLoopGroup group = new NioEventLoopGroup();\n+\n+        final LinkedBlockingQueue<SslHandshakeCompletionEvent> completionEvents =\n+                new LinkedBlockingQueue<SslHandshakeCompletionEvent>();\n+        final ChannelHandler completionEventHandler = new ChannelInboundHandlerAdapter() {\n+            @Override\n+            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+                if (evt instanceof SslHandshakeCompletionEvent) {\n+                    completionEvents.add((SslHandshakeCompletionEvent) evt);\n+                }\n+            }\n+\n+            @Override\n+            public boolean isSharable() {\n+                return true;\n+            }\n+        };\n+        try {\n+            Channel sc = new ServerBootstrap()\n+                    .group(group)\n+                    .channel(NioServerSocketChannel.class)\n+                    .childHandler(new ChannelInitializer<Channel>() {\n+                        @Override\n+                        protected void initChannel(Channel ch) throws Exception {\n+                            ch.pipeline().addLast(sslServerCtx.newHandler(UnpooledByteBufAllocator.DEFAULT));\n+                            ch.pipeline().addLast(completionEventHandler);\n+                        }\n+                    })\n+                    .bind(new InetSocketAddress(0)).syncUninterruptibly().channel();\n+\n+            Bootstrap bs = new Bootstrap()\n+                    .group(group)\n+                    .channel(NioSocketChannel.class)\n+                    .handler(new ChannelInitializer<Channel>() {\n+                        @Override\n+                        protected void initChannel(Channel ch) {\n+                            ch.pipeline().addLast(sslClientCtx.newHandler(\n+                                    UnpooledByteBufAllocator.DEFAULT, \"netty.io\", 9999));\n+                            ch.pipeline().addLast(completionEventHandler);\n+                        }\n+                    })\n+                    .remoteAddress(sc.localAddress());\n+\n+            Channel cc1 = bs.connect().sync().channel();\n+            Channel cc2 = bs.connect().sync().channel();\n+\n+            // We expect 4 events as we have 2 connections and for each connection there should be one event\n+            // on the server-side and one on the client-side.\n+            for (int i = 0; i < 4; i++) {\n+                SslHandshakeCompletionEvent event = completionEvents.take();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e21ba63d8ffa5009d5836713804484faeb8112c2"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODY3OTk4OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/ssl/SslHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTowMDowM1rOIEF_4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMDoyMDozMFrOIFmGag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MzQ4OA==", "bodyText": "Is engineType == SslEngineType.JDK is necessary here? I think we can have only notified || !SslUtils.PROTOCOL_TLS_V1_3.equals(session.getProtocol()).\nAlso, IIUC in case of renegotiation netty initializes a new handshakePromise. So, the notified will also be true for renegotiation.", "url": "https://github.com/netty/netty/pull/10860#discussion_r541163488", "createdAt": "2020-12-11T19:00:03Z", "author": {"login": "idelpivnitskiy"}, "path": "handler/src/main/java/io/netty/handler/ssl/SslHandler.java", "diffHunk": "@@ -1800,17 +1800,24 @@ private boolean setHandshakeSuccessIfStillHandshaking() {\n      * Notify all the handshake futures about the successfully handshake\n      */\n     private void setHandshakeSuccess() {\n-        handshakePromise.trySuccess(ctx.channel());\n-\n-        if (logger.isDebugEnabled()) {\n-            SSLSession session = engine.getSession();\n-            logger.debug(\n-              \"{} HANDSHAKEN: protocol:{} cipher suite:{}\",\n-              ctx.channel(),\n-              session.getProtocol(),\n-              session.getCipherSuite());\n+        boolean notified = handshakePromise.trySuccess(ctx.channel());\n+        SSLSession session = engine.getSession();\n+\n+        // There seems to be a bug in the SSLEngineImpl that is part of the OpenJDK that results in returning\n+        // HandshakeStatus.FINISHED multiple times which is not expected. This only happens in TLSv1.3 so lets\n+        // ensure we only notify once in this case.\n+        //\n+        // This is safe as TLSv1.3 does not support renegotiation and so we should never see two handshake events.\n+        if (notified || engineType == SslEngineType.JDK && !SslUtils.PROTOCOL_TLS_V1_3.equals(session.getProtocol())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e21ba63d8ffa5009d5836713804484faeb8112c2"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczODAyNg==", "bodyText": "I guess yeah we can simplify. This won't harm", "url": "https://github.com/netty/netty/pull/10860#discussion_r542738026", "createdAt": "2020-12-14T20:20:30Z", "author": {"login": "normanmaurer"}, "path": "handler/src/main/java/io/netty/handler/ssl/SslHandler.java", "diffHunk": "@@ -1800,17 +1800,24 @@ private boolean setHandshakeSuccessIfStillHandshaking() {\n      * Notify all the handshake futures about the successfully handshake\n      */\n     private void setHandshakeSuccess() {\n-        handshakePromise.trySuccess(ctx.channel());\n-\n-        if (logger.isDebugEnabled()) {\n-            SSLSession session = engine.getSession();\n-            logger.debug(\n-              \"{} HANDSHAKEN: protocol:{} cipher suite:{}\",\n-              ctx.channel(),\n-              session.getProtocol(),\n-              session.getCipherSuite());\n+        boolean notified = handshakePromise.trySuccess(ctx.channel());\n+        SSLSession session = engine.getSession();\n+\n+        // There seems to be a bug in the SSLEngineImpl that is part of the OpenJDK that results in returning\n+        // HandshakeStatus.FINISHED multiple times which is not expected. This only happens in TLSv1.3 so lets\n+        // ensure we only notify once in this case.\n+        //\n+        // This is safe as TLSv1.3 does not support renegotiation and so we should never see two handshake events.\n+        if (notified || engineType == SslEngineType.JDK && !SslUtils.PROTOCOL_TLS_V1_3.equals(session.getProtocol())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MzQ4OA=="}, "originalCommit": {"oid": "e21ba63d8ffa5009d5836713804484faeb8112c2"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3562, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}