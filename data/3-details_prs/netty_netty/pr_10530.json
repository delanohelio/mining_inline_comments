{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4Nzg4MjE1", "number": 10530, "title": "Reduce DefaultAttributeMap cost", "bodyText": "Motivation:\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\nModification:\nReplace the existing fixed bucket table with a locked intrusive linked list\nwith JCTools NonBlockingIdentityHashMap\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions", "createdAt": "2020-09-03T17:46:55Z", "url": "https://github.com/netty/netty/pull/10530", "merged": true, "mergeCommit": {"oid": "69b44c6d06d4449920b6b8990b0f6e0473f3532b"}, "closed": true, "closedAt": "2020-10-02T16:24:35Z", "author": {"login": "franz1981"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFUaqkgBqjM3MjU5MDU5OTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOmQ0IABqjM4MzQwNTQ1OTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9299051cc8b4d5bd6e846e3c32771839b3bfb330", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/9299051cc8b4d5bd6e846e3c32771839b3bfb330", "committedDate": "2020-09-03T17:40:36Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table with a locked intrusive linked list\nwith JCTools NonBlockingIdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}, "afterCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/550fde8c43ea72486b764c9f64c1a03ad0871c80", "committedDate": "2020-09-03T17:53:37Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table with a locked intrusive linked list\nwith JCTools NonBlockingIdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMTA3NjA3", "url": "https://github.com/netty/netty/pull/10530#pullrequestreview-482107607", "createdAt": "2020-09-03T18:39:54Z", "commit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODozOTo1NFrOHMzE5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxODo0Mjo1MFrOHMzKxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MTc5OQ==", "bodyText": "nit: ;;", "url": "https://github.com/netty/netty/pull/10530#discussion_r483181799", "createdAt": "2020-09-03T18:39:54Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MjAxNQ==", "bodyText": "nit: you can remove the else", "url": "https://github.com/netty/netty/pull/10530#discussion_r483182015", "createdAt": "2020-09-03T18:40:19Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4Mjk2NA==", "bodyText": "nit: merge with above line", "url": "https://github.com/netty/netty/pull/10530#discussion_r483182964", "createdAt": "2020-09-03T18:42:07Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {\n+                    attribute = attributes.get(key);\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+            } else {\n+                attribute = attributes.putIfAbsent(key, newAttribute);\n+                if (attribute == null) {\n+                    return newAttribute;\n                 }\n-                curr = next;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n             // no attribute exists\n             return false;\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n-\n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        return attribute != null & !attribute.removed();\n     }\n \n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes,\n+                         AttributeKey<T> key) {\n+            this.attributes = attributes;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MzEyNQ==", "bodyText": "nit: merge with above line", "url": "https://github.com/netty/netty/pull/10530#discussion_r483183125", "createdAt": "2020-09-03T18:42:27Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {\n+                    attribute = attributes.get(key);\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+            } else {\n+                attribute = attributes.putIfAbsent(key, newAttribute);\n+                if (attribute == null) {\n+                    return newAttribute;\n                 }\n-                curr = next;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n             // no attribute exists\n             return false;\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n-\n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        return attribute != null & !attribute.removed();\n     }\n \n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes,\n+                         AttributeKey<T> key) {\n+            this.attributes = attributes;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+        }\n+\n+        @Override\n+        public T getAndSet(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return null;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MzMwMA==", "bodyText": "nit: merge with above line", "url": "https://github.com/netty/netty/pull/10530#discussion_r483183300", "createdAt": "2020-09-03T18:42:50Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {\n+                    attribute = attributes.get(key);\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+            } else {\n+                attribute = attributes.putIfAbsent(key, newAttribute);\n+                if (attribute == null) {\n+                    return newAttribute;\n                 }\n-                curr = next;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n             // no attribute exists\n             return false;\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n-\n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        return attribute != null & !attribute.removed();\n     }\n \n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes,\n+                         AttributeKey<T> key) {\n+            this.attributes = attributes;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+        }\n+\n+        @Override\n+        public T getAndSet(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return null;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+            return (T) old;\n         }\n \n         @Override\n         public T setIfAbsent(T value) {\n-            while (!compareAndSet(null, value)) {\n-                T old = get();\n+            do {\n+                final Object old = this.value;\n                 if (old != null) {\n-                    return old;\n+                    if (old == REMOVED) {\n+                        // a subsequent get should return null regardless the current value\n+                        // given that remove has been called\n+                        return null;\n+                    }\n+                    return (T) old;\n                 }\n             }\n+            while (!compareAndSet(null, value));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80"}, "originalPosition": 242}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/550fde8c43ea72486b764c9f64c1a03ad0871c80", "committedDate": "2020-09-03T17:53:37Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table with a locked intrusive linked list\nwith JCTools NonBlockingIdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}, "afterCommit": {"oid": "014723678b39a2f17be393b60ce95642fdc8ec0b", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/014723678b39a2f17be393b60ce95642fdc8ec0b", "committedDate": "2020-09-03T19:09:13Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith JCTools NonBlockingIdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "014723678b39a2f17be393b60ce95642fdc8ec0b", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/014723678b39a2f17be393b60ce95642fdc8ec0b", "committedDate": "2020-09-03T19:09:13Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith JCTools NonBlockingIdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}, "afterCommit": {"oid": "54da1139e36598fecdfea30d4d866ff6fc38a350", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/54da1139e36598fecdfea30d4d866ff6fc38a350", "committedDate": "2020-09-03T19:34:15Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith JCTools NonBlockingIdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "837af3defca88b83a3e28ae4eb7365a6f2c1976b", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/837af3defca88b83a3e28ae4eb7365a6f2c1976b", "committedDate": "2020-09-03T21:33:42Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write IdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}, "afterCommit": {"oid": "dc4dc072b755efc9b0f4a6a6289c5543dce0df97", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/dc4dc072b755efc9b0f4a6a6289c5543dce0df97", "committedDate": "2020-09-04T07:41:19Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write IdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "da8ddc62a955513c6752eb53245a87c9b7396c6b", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/da8ddc62a955513c6752eb53245a87c9b7396c6b", "committedDate": "2020-09-04T13:27:45Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered matrix\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}, "afterCommit": {"oid": "b2d755fdde3f53e1cb9595bcd93fc642324f57cc", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/b2d755fdde3f53e1cb9595bcd93fc642324f57cc", "committedDate": "2020-09-04T15:10:47Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered matrix\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b2d755fdde3f53e1cb9595bcd93fc642324f57cc", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/b2d755fdde3f53e1cb9595bcd93fc642324f57cc", "committedDate": "2020-09-04T15:10:47Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered matrix\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}, "afterCommit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/b6200e59d5efaf513aaabdba014c9764c0f08d6d", "committedDate": "2020-09-04T16:06:01Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered matrix\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyODAxOTU2", "url": "https://github.com/netty/netty/pull/10530#pullrequestreview-482801956", "createdAt": "2020-09-04T16:32:24Z", "commit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjozMjoyNVrOHNUspA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjozMzoyMlrOHNUvUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMjY0NA==", "bodyText": "nit: could inline", "url": "https://github.com/netty/netty/pull/10530#discussion_r483732644", "createdAt": "2020-09-04T16:32:25Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMjgxOA==", "bodyText": "nit: inline", "url": "https://github.com/netty/netty/pull/10530#discussion_r483732818", "createdAt": "2020-09-04T16:32:39Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();\n+            } else {\n+                DefaultAttribute attribute1 = (DefaultAttribute) t1;\n+                keyId = attribute1.key.id();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMzMzMQ==", "bodyText": "nit: return Integer.compare(attributeKeyId, keyId);", "url": "https://github.com/netty/netty/pull/10530#discussion_r483733331", "createdAt": "2020-09-04T16:33:22Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();\n+            } else {\n+                DefaultAttribute attribute1 = (DefaultAttribute) t1;\n+                keyId = attribute1.key.id();\n+            }\n+            return attributeKeyId < keyId? -1 : (attributeKeyId == keyId? 0 : 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d"}, "originalPosition": 45}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/b6200e59d5efaf513aaabdba014c9764c0f08d6d", "committedDate": "2020-09-04T16:06:01Z", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered matrix\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions"}, "afterCommit": {"oid": "51f3b65464fd2b04337f901dc3671990350d0b1b", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/51f3b65464fd2b04337f901dc3671990350d0b1b", "committedDate": "2020-09-14T09:53:26Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51f3b65464fd2b04337f901dc3671990350d0b1b", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/51f3b65464fd2b04337f901dc3671990350d0b1b", "committedDate": "2020-09-14T09:53:26Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}, "afterCommit": {"oid": "f35156469aba90faf8a2271b0b8708187fc36cf8", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/f35156469aba90faf8a2271b0b8708187fc36cf8", "committedDate": "2020-09-14T11:17:23Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f35156469aba90faf8a2271b0b8708187fc36cf8", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/f35156469aba90faf8a2271b0b8708187fc36cf8", "committedDate": "2020-09-14T11:17:23Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}, "afterCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/9a33c7618ef949bf1ac9b3923ac79f9c54174780", "committedDate": "2020-09-14T14:58:11Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4ODE2ODMw", "url": "https://github.com/netty/netty/pull/10530#pullrequestreview-488816830", "createdAt": "2020-09-15T15:39:53Z", "commit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTozOTo1NFrOHSICxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTo1MDozNFrOHSIhZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODE5OQ==", "bodyText": "Just curious, why change from extending AtomicReference?", "url": "https://github.com/netty/netty/pull/10530#discussion_r488768199", "createdAt": "2020-09-15T15:39:54Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODgyMg==", "bodyText": "nit: space before ?", "url": "https://github.com/netty/netty/pull/10530#discussion_r488768822", "createdAt": "2020-09-15T15:40:45Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final DefaultAttributeMap attributeMap;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(DefaultAttributeMap attributeMap,\n+                         AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NjAzOA==", "bodyText": "Is this the same as the old behavior? i.e. if the attribute was already removed from the map would its value still be set", "url": "https://github.com/netty/netty/pull/10530#discussion_r488776038", "createdAt": "2020-09-15T15:50:34Z", "author": {"login": "njhill"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final DefaultAttributeMap attributeMap;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(DefaultAttributeMap attributeMap,\n+                         AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            } while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+        }\n+\n+        @Override\n+        public T getAndSet(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 290}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwODIzMzkw", "url": "https://github.com/netty/netty/pull/10530#pullrequestreview-490823390", "createdAt": "2020-09-17T17:19:56Z", "commit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxOTo1NlrOHTtcdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxOTo1NlrOHTtcdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyOTU1Nw==", "bodyText": "might be a nit, but did you consider binary searching to find the insertion point, and then use System.arraycopy to move the daat around for the slot?  I am curious if this more easily intrinsifies this for loop copy.", "url": "https://github.com/netty/netty/pull/10530#discussion_r490429557", "createdAt": "2020-09-17T17:19:56Z", "author": {"login": "carl-mastrangelo"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwODMyNDYx", "url": "https://github.com/netty/netty/pull/10530#pullrequestreview-490832461", "createdAt": "2020-09-17T17:30:27Z", "commit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozMDoyN1rOHTt2aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozMDoyN1rOHTt2aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNjIwMw==", "bodyText": "This doesn't seem to take advantage of the index which should be the insertion point.    I would suspect after a few attrs, avoiding the excess copies would become expensive.    It feels like the index should be passed into orderedCopyOnInsert", "url": "https://github.com/netty/netty/pull/10530#discussion_r490436203", "createdAt": "2020-09-17T17:30:27Z", "author": {"login": "carl-mastrangelo"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwOTU1ODM2", "url": "https://github.com/netty/netty/pull/10530#pullrequestreview-490955836", "createdAt": "2020-09-17T20:16:41Z", "commit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/9a33c7618ef949bf1ac9b3923ac79f9c54174780", "committedDate": "2020-09-14T14:58:11Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}, "afterCommit": {"oid": "35fbf91263835189670822d4e03fe30f2615443d", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/35fbf91263835189670822d4e03fe30f2615443d", "committedDate": "2020-09-21T13:49:47Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODg3MjQz", "url": "https://github.com/netty/netty/pull/10530#pullrequestreview-500887243", "createdAt": "2020-10-02T06:36:13Z", "commit": {"oid": "35fbf91263835189670822d4e03fe30f2615443d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjozNjoxNFrOHbiemA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNjozNjoxNFrOHbiemA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzODQ4OA==", "bodyText": "remove public and rename to isRemoved() ?", "url": "https://github.com/netty/netty/pull/10530#discussion_r498638488", "createdAt": "2020-10-02T06:36:14Z", "author": {"login": "normanmaurer"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n+            }\n+        }\n+\n+        return -(low + 1);\n+    }\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n+            }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n+        }\n+    }\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n-            }\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n-            }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n     private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n \n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, DefaultAttributeMap> MAP_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class,\n+                                                       DefaultAttributeMap.class, \"attributeMap\");\n         private static final long serialVersionUID = -2661411462200283011L;\n \n+        private volatile DefaultAttributeMap attributeMap;\n         // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n         private final AttributeKey<T> key;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n-\n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n-\n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n+        DefaultAttribute(DefaultAttributeMap attributeMap, AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n             this.key = key;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n-        }\n-\n         @Override\n         public AttributeKey<T> key() {\n             return key;\n         }\n \n+        public boolean removed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35fbf91263835189670822d4e03fe30f2615443d"}, "originalPosition": 257}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35fbf91263835189670822d4e03fe30f2615443d", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/35fbf91263835189670822d4e03fe30f2615443d", "committedDate": "2020-09-21T13:49:47Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}, "afterCommit": {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/cd22863a4064cb5038857f630b96a89f75886ba1", "committedDate": "2020-10-02T06:57:01Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwOTg2NTA0", "url": "https://github.com/netty/netty/pull/10530#pullrequestreview-500986504", "createdAt": "2020-10-02T09:25:58Z", "commit": {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwOToyNTo1OFrOHbnCeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDowNTozNFrOHboJmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMzIwOA==", "bodyText": "If they're the same object, there's no way their id can be different.", "url": "https://github.com/netty/netty/pull/10530#discussion_r498713208", "createdAt": "2020-10-02T09:25:58Z", "author": {"login": "chrisvest"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxNDkxMw==", "bodyText": "The fromIndex is always 0, and toIndex is always the length of the sortedAttributes, so there's no need to take them as parameters.", "url": "https://github.com/netty/netty/pull/10530#discussion_r498714913", "createdAt": "2020-10-02T09:29:33Z", "author": {"login": "chrisvest"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczMTQxNg==", "bodyText": "This comment is now obsolete.", "url": "https://github.com/netty/netty/pull/10530#discussion_r498731416", "createdAt": "2020-10-02T10:05:34Z", "author": {"login": "chrisvest"}, "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n+            }\n+        }\n+\n+        return -(low + 1);\n+    }\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n+            }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n+        }\n+    }\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n-            }\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n-            }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.isRemoved()) {\n+                    return attribute;\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n     private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n \n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, DefaultAttributeMap> MAP_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class,\n+                                                       DefaultAttributeMap.class, \"attributeMap\");\n         private static final long serialVersionUID = -2661411462200283011L;\n \n+        private volatile DefaultAttributeMap attributeMap;\n         // The head of the linked-list this attribute belongs to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1"}, "originalPosition": 228}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0ebd302475bd4cb3b87f0cd0636293bb34f05fb", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/c0ebd302475bd4cb3b87f0cd0636293bb34f05fb", "committedDate": "2020-10-02T13:46:39Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/cd22863a4064cb5038857f630b96a89f75886ba1", "committedDate": "2020-10-02T06:57:01Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}, "afterCommit": {"oid": "c0ebd302475bd4cb3b87f0cd0636293bb34f05fb", "author": {"user": {"login": "franz1981", "name": "Francesco Nigro"}}, "url": "https://github.com/netty/netty/commit/c0ebd302475bd4cb3b87f0cd0636293bb34f05fb", "committedDate": "2020-10-02T13:46:39Z", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}