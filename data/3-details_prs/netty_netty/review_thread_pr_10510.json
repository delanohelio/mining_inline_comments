{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MDUxMDEy", "number": 10510, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNjowMDo1M1rOEdfFjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxODoxMzozNFrOEi5bUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzUzNDg1OnYy", "diffSide": "RIGHT", "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNjowMDo1M1rOHIqj9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoyNzozM1rOHJQdew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg0Nzk5MQ==", "bodyText": "Lets first check if it\u2019s done yet and only if this is not true try to fail it. This will reduce the overhead in most cases as we will not create the extra exception", "url": "https://github.com/netty/netty/pull/10510#discussion_r478847991", "createdAt": "2020-08-28T06:00:53Z", "author": {"login": "normanmaurer"}, "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java", "diffHunk": "@@ -70,6 +70,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         applyHandshakeTimeout();\n     }\n \n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        handshakePromise.tryFailure(new WebSocketHandshakeException(\"channel closed with handshake in progress\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "668626675009be4c7793a2a4df498c58c2b71b2e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2ODkyMw==", "bodyText": "Done.", "url": "https://github.com/netty/netty/pull/10510#discussion_r479468923", "createdAt": "2020-08-28T18:27:33Z", "author": {"login": "divijvaidya"}, "path": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java", "diffHunk": "@@ -70,6 +70,12 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         applyHandshakeTimeout();\n     }\n \n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        handshakePromise.tryFailure(new WebSocketHandshakeException(\"channel closed with handshake in progress\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg0Nzk5MQ=="}, "originalCommit": {"oid": "668626675009be4c7793a2a4df498c58c2b71b2e"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NjQ5Njk2OnYy", "diffSide": "RIGHT", "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNDoxNzowM1rOHJISIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoyOToxOFrOHJQghA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMzNDk0Ng==", "bodyText": "Sorry maybe I miss something, how server can send close websocket frame if handshake is not complete yet.", "url": "https://github.com/netty/netty/pull/10510#discussion_r479334946", "createdAt": "2020-08-28T14:17:03Z", "author": {"login": "amizurov"}, "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java", "diffHunk": "@@ -184,6 +184,35 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except\n         }\n     }\n \n+    /**\n+     * Tests a scenario when channel is closed while the handshake is in progress. Validates that the handshake\n+     * future is notified in such cases.\n+     */\n+    @Test\n+    public void testHandshakeFutureIsNotifiedOnChannelClose() throws Exception {\n+        EmbeddedChannel clientChannel = createClientChannel(null);\n+        EmbeddedChannel serverChannel = createServerChannel(null);\n+\n+        // Start handshake from client to server but don't complete the handshake for the purpose of this test.\n+        transferAllDataWithMerge(clientChannel, serverChannel);\n+\n+        final WebSocketClientProtocolHandler clientWsHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandler.class);\n+        final WebSocketClientProtocolHandshakeHandler clientWsHandshakeHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandshakeHandler.class);\n+\n+        final ChannelHandlerContext ctx = clientChannel.pipeline().context(WebSocketClientProtocolHandler.class);\n+\n+        // Close the channel while the handshake is in progress. This close could be initiated by the server by\n+        // sending the CloseWebSocket frame. To reproduce the test scenario for this test case,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "668626675009be4c7793a2a4df498c58c2b71b2e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2OTcwMA==", "bodyText": "You are right. This is a bad example of a scenario for a channel close. I have changed the comment to remove this description. However, apart from this incorrect example, there can be number of cases when the channel might be closed before the handshake is complete. I have provide an example where SSL handshake fails below in the other comment.", "url": "https://github.com/netty/netty/pull/10510#discussion_r479469700", "createdAt": "2020-08-28T18:29:18Z", "author": {"login": "divijvaidya"}, "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java", "diffHunk": "@@ -184,6 +184,35 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except\n         }\n     }\n \n+    /**\n+     * Tests a scenario when channel is closed while the handshake is in progress. Validates that the handshake\n+     * future is notified in such cases.\n+     */\n+    @Test\n+    public void testHandshakeFutureIsNotifiedOnChannelClose() throws Exception {\n+        EmbeddedChannel clientChannel = createClientChannel(null);\n+        EmbeddedChannel serverChannel = createServerChannel(null);\n+\n+        // Start handshake from client to server but don't complete the handshake for the purpose of this test.\n+        transferAllDataWithMerge(clientChannel, serverChannel);\n+\n+        final WebSocketClientProtocolHandler clientWsHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandler.class);\n+        final WebSocketClientProtocolHandshakeHandler clientWsHandshakeHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandshakeHandler.class);\n+\n+        final ChannelHandlerContext ctx = clientChannel.pipeline().context(WebSocketClientProtocolHandler.class);\n+\n+        // Close the channel while the handshake is in progress. This close could be initiated by the server by\n+        // sending the CloseWebSocket frame. To reproduce the test scenario for this test case,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMzNDk0Ng=="}, "originalCommit": {"oid": "668626675009be4c7793a2a4df498c58c2b71b2e"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MDI3OTIwOnYy", "diffSide": "RIGHT", "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxODoxMzozNFrOHQ-SHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMjo0NDoxOVrOHRueIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1OTcxMA==", "bodyText": "Also call clientChannel.finishAndReleaseAll() and serverChannel.finishAndReleaseAll() otherwise we have leaks", "url": "https://github.com/netty/netty/pull/10510#discussion_r487559710", "createdAt": "2020-09-13T18:13:34Z", "author": {"login": "normanmaurer"}, "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java", "diffHunk": "@@ -184,6 +184,35 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except\n         }\n     }\n \n+    /**\n+     * Tests a scenario when channel is closed while the handshake is in progress. Validates that the handshake\n+     * future is notified in such cases.\n+     */\n+    @Test\n+    public void testHandshakeFutureIsNotifiedOnChannelClose() throws Exception {\n+        EmbeddedChannel clientChannel = createClientChannel(null);\n+        EmbeddedChannel serverChannel = createServerChannel(null);\n+\n+        // Start handshake from client to server but don't complete the handshake for the purpose of this test.\n+        transferAllDataWithMerge(clientChannel, serverChannel);\n+\n+        final WebSocketClientProtocolHandler clientWsHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandler.class);\n+        final WebSocketClientProtocolHandshakeHandler clientWsHandshakeHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandshakeHandler.class);\n+\n+        final ChannelHandlerContext ctx = clientChannel.pipeline().context(WebSocketClientProtocolHandler.class);\n+\n+        // Close the channel while the handshake is in progress. The channel could be closed before the handshake is\n+        // complete due to a number of varied reasons. To reproduce the test scenario for this test case,\n+        // we would manually close the channel.\n+        clientWsHandler.close(ctx, ctx.newPromise());\n+\n+        // At this stage handshake is incomplete but the handshake future should be completed exceptionally since\n+        // channel is closed.\n+        assertTrue(clientWsHandshakeHandler.getHandshakeFuture().isDone());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d0bef774c4efa2e41e54f630ef20e5756590fca"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM0OTIxNg==", "bodyText": "updated", "url": "https://github.com/netty/netty/pull/10510#discussion_r488349216", "createdAt": "2020-09-15T02:44:19Z", "author": {"login": "divijvaidya"}, "path": "codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketHandshakeHandOverTest.java", "diffHunk": "@@ -184,6 +184,35 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except\n         }\n     }\n \n+    /**\n+     * Tests a scenario when channel is closed while the handshake is in progress. Validates that the handshake\n+     * future is notified in such cases.\n+     */\n+    @Test\n+    public void testHandshakeFutureIsNotifiedOnChannelClose() throws Exception {\n+        EmbeddedChannel clientChannel = createClientChannel(null);\n+        EmbeddedChannel serverChannel = createServerChannel(null);\n+\n+        // Start handshake from client to server but don't complete the handshake for the purpose of this test.\n+        transferAllDataWithMerge(clientChannel, serverChannel);\n+\n+        final WebSocketClientProtocolHandler clientWsHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandler.class);\n+        final WebSocketClientProtocolHandshakeHandler clientWsHandshakeHandler =\n+                clientChannel.pipeline().get(WebSocketClientProtocolHandshakeHandler.class);\n+\n+        final ChannelHandlerContext ctx = clientChannel.pipeline().context(WebSocketClientProtocolHandler.class);\n+\n+        // Close the channel while the handshake is in progress. The channel could be closed before the handshake is\n+        // complete due to a number of varied reasons. To reproduce the test scenario for this test case,\n+        // we would manually close the channel.\n+        clientWsHandler.close(ctx, ctx.newPromise());\n+\n+        // At this stage handshake is incomplete but the handshake future should be completed exceptionally since\n+        // channel is closed.\n+        assertTrue(clientWsHandshakeHandler.getHandshakeFuture().isDone());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU1OTcxMA=="}, "originalCommit": {"oid": "1d0bef774c4efa2e41e54f630ef20e5756590fca"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3682, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}