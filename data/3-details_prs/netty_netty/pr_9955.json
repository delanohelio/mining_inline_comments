{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMzQ0OTMw", "number": 9955, "title": "Efficient BytBuf search algorithms (#9914)", "bodyText": "Motivation:\nWe have found out that ByteBufUtil.indexOf can be inefficient for substring search on\nByteBuf, both in terms of algorithm complexity (worst case O(needle.readableBytes * haystack.readableBytes)), and in constant factor (esp. on Composite buffers).\nWith implementation of more performant search algorithms we have seen improvements on\nthe order of magnitude.\nModifications:\nThis change introduces three search algorithms:\n\nKnuth Morris Pratt - classical textbook algorithm, a good default choice.\nBit mask based algorithm - stable performance on any input, but limited to maximum\nsearch substring (the needle) length of 64 bytes.\nAho\u2013Corasick - worse performance and higher memory consumption than [1] and [2], but it supports multiple substring (the needles)\nsearch simultaneously, by inspecting every byte of the haystack only once.\n\nEach algorithm processes every byte of underlying buffer only once, they are implemented\nas ByteProcessor.\nResult:\nEfficient search algorithms with linear time complexity available in Netty (I will share\nbenchmark results in a comment on a PR).\nFixes #9914.", "createdAt": "2020-01-15T21:25:53Z", "url": "https://github.com/netty/netty/pull/9955", "merged": true, "mergeCommit": {"oid": "fb5e2cd3aa5644c294905fce3b45c2278f17e15d"}, "closed": true, "closedAt": "2020-04-15T08:21:25Z", "author": {"login": "linasm"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6sToSAH2gAyMzYzMzQ0OTMwOmVlNWJmODQ1ZmI1ZDQxZTkzYWE4ZTQ5MDMxMjY3NDc3MmFlNGYwOGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXMSapgFqTM5MjA3MDQwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ee5bf845fb5d41e93aa8e490312674772ae4f08c", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/ee5bf845fb5d41e93aa8e490312674772ae4f08c", "committedDate": "2020-01-15T21:19:48Z", "message": "Efficient BytBuf search algorithms (#9914)\n\nMotivation:\n\nWe have found out that ByteBufUtil.indexOf can be inefficient for substring search on\nByteBuf, both in terms of algorithm complexity (worst case O(needle.readableBytes *\nhaystack.readableBytes)), and in constant factor (esp. on Composite buffers).\nWith implementation of more performant search algorithms we have seen improvements on\nthe order of magnitude.\n\nModifications:\n\nThis change introduces three search algorithms:\n1. Knuth Morris Pratt - classical textbook algorithm, a good default choice.\n2. Bit mask based algorithm - stable performance on any input, but limited to maximum\nsearch substring (the needle) length of 64 bytes.\n3. Aho\u2013Corasick - worse performance and higher memory consumption than [1] and [2], but\nit supports multiple substring (the needles) search simultaneously, by inspecting every\nbyte of the haystack only once.\n\nEach algorithm processes every byte of underlying buffer only once, they are implemented\nas ByteProcessor.\n\nResult:\n\nEfficient search algorithms with linear time complexity available in Netty (I will share\nbenchmark results in a comment on a PR)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "894cb3ccb91c7b578f11228974a488d8d9fca9a3", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/894cb3ccb91c7b578f11228974a488d8d9fca9a3", "committedDate": "2020-01-18T05:22:19Z", "message": "Improved benchmarks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdf1f3be4106c10a6afe20e620e81bc8147be7ef", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/fdf1f3be4106c10a6afe20e620e81bc8147be7ef", "committedDate": "2020-01-20T08:08:34Z", "message": "Added PREDICTABLE and UNPREDICTABLE benchmark inputs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3849c0c3966f1a87a83b0eb3fe26c7a481e81cb7", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/3849c0c3966f1a87a83b0eb3fe26c7a481e81cb7", "committedDate": "2020-01-22T07:07:57Z", "message": "Adjusted some benchmark inputs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acbee05bfb6c00d560d7ac2ef85f2df6a7d34ea2", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/acbee05bfb6c00d560d7ac2ef85f2df6a7d34ea2", "committedDate": "2020-01-23T11:13:10Z", "message": "Minor polishing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "057676d519c6e438ec17fa3ec6dbc30f84ab659e", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/057676d519c6e438ec17fa3ec6dbc30f84ab659e", "committedDate": "2020-01-24T11:54:35Z", "message": "Rename next to jumpTable in KMP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/200b9aea18d7ec4684b6af7af41c18c85024e0c1", "committedDate": "2020-02-04T07:00:32Z", "message": "Cleaner AhoCorasic (no change in benchmarks)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyOTAwMDAz", "url": "https://github.com/netty/netty/pull/9955#pullrequestreview-352900003", "createdAt": "2020-02-04T11:19:51Z", "commit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMToxOTo1MVrOFlQlYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxMToxOTo1MVrOFlQlYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxMzM0NQ==", "bodyText": "have you tried inspecting ASM here? Look if there is any PlatformDependent method that can save bound checks there.", "url": "https://github.com/netty/netty/pull/9955#discussion_r374613345", "createdAt": "2020-02-04T11:19:51Z", "author": {"login": "franz1981"}, "path": "buffer/src/main/java/io/netty/buffer/search/ShiftingBitMaskSearchProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+ package io.netty.buffer.search;\n+\n+/**\n+ * Implements Shifting Bit Mask string search algorithm as {@link io.netty.util.ByteProcessor}.\n+ * @see SearchProcessorFactory\n+ */\n+public class ShiftingBitMaskSearchProcessor implements SearchProcessor {\n+\n+    private final long[] bitMasks;\n+    private final long successBit;\n+    private long currentMask;\n+\n+    ShiftingBitMaskSearchProcessor(long[] bitMasks, long successBit) {\n+        this.bitMasks = bitMasks;\n+        this.successBit = successBit;\n+    }\n+\n+    @Override\n+    public boolean process(byte value) {\n+        currentMask = ((currentMask << 1) | 1) & bitMasks[value & 0xff];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9880833965621b2be1ecc1a2b73cd9547205d3c0", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/9880833965621b2be1ecc1a2b73cd9547205d3c0", "committedDate": "2020-02-06T19:36:01Z", "message": "PlatformDependent same type array based getInt and getLong"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MTMwNDk4", "url": "https://github.com/netty/netty/pull/9955#pullrequestreview-356130498", "createdAt": "2020-02-10T17:37:03Z", "commit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzozNzowM1rOFnvMVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzozNzowM1rOFnvMVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMTk5MQ==", "bodyText": "It cannot be made less GC hungry by caching the search processor?\neach benchmarked method could include the jump table initialization and needle clone too (thinking of kmp here)\nEscape analysis probably won't even kick-in due to the size of needle array", "url": "https://github.com/netty/netty/pull/9955#discussion_r377211991", "createdAt": "2020-02-10T17:37:03Z", "author": {"login": "franz1981"}, "path": "microbench/src/main/java/io/netty/microbench/search/SearchBenchmark.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.microbench.search;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.buffer.search.MultiSearchProcessorFactory;\n+import io.netty.buffer.search.SearchProcessorFactory;\n+import io.netty.microbench.util.AbstractMicrobenchmark;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.CompilerControl.Mode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5)\n+@Measurement(iterations = 5)\n+@Fork(1)\n+public class SearchBenchmark extends AbstractMicrobenchmark {\n+\n+    private static final long SEED = 123;\n+\n+    public enum ByteBufType {\n+        HEAP {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                return Unpooled.wrappedBuffer(bytes, 0, bytes.length);\n+            }\n+        },\n+        COMPOSITE {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                CompositeByteBuf buf = Unpooled.compositeBuffer();\n+                int length = bytes.length;\n+                int offset = 0;\n+                int capacity = length / 8; // 8 buffers per composite\n+\n+                while (length > 0) {\n+                    buf.addComponent(true, Unpooled.wrappedBuffer(bytes, offset, Math.min(length, capacity)));\n+                    length -= capacity;\n+                    offset += capacity;\n+                }\n+                return buf;\n+            }\n+        },\n+        DIRECT {\n+            @Override\n+            ByteBuf newBuffer(byte[] bytes) {\n+                return Unpooled.directBuffer(bytes.length).writeBytes(bytes);\n+            }\n+        };\n+        abstract ByteBuf newBuffer(byte[] bytes);\n+    }\n+\n+    public enum Input {\n+        RANDOM_256B {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return new byte[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 256, ' ', 127);\n+            }\n+        },\n+        RANDOM_2KB {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return new byte[] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' };\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 2048, ' ', 127);\n+            }\n+        },\n+        PREDICTABLE {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                // all 0s\n+                return new byte[64];\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                // no 0s except in the very end\n+                byte[] bytes = randomBytes(rnd, 2048, 1, 255);\n+                Arrays.fill(bytes, bytes.length - 64, bytes.length, (byte) 0);\n+                return bytes;\n+            }\n+        },\n+        UNPREDICTABLE {\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                return randomBytes(rnd, 64, 0, 1);\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                return randomBytes(rnd, 2048, 0, 1);\n+            }\n+        },\n+        WORST_CASE { // ShiftingBitMask will fail on it because the needle is >64 bytes long\n+            @Override\n+            byte[] getNeedle(Random rnd) {\n+                // aa(...)aab\n+                byte[] needle = new byte[1024];\n+                Arrays.fill(needle, (byte) 'a');\n+                needle[needle.length - 1] = 'b';\n+                return needle;\n+            }\n+            @Override\n+            byte[] getHaystack(Random rnd) {\n+                // aa(...)aaa\n+                byte[] haystack = new byte[2048];\n+                Arrays.fill(haystack, (byte) 'a');\n+                return haystack;\n+            }\n+        };\n+\n+        abstract byte[] getNeedle(Random rnd);\n+        abstract byte[] getHaystack(Random rnd);\n+    }\n+\n+    @Param\n+    public Input input;\n+\n+    @Param\n+    public ByteBufType bufferType;\n+\n+    private Random rnd;\n+    private ByteBuf needle, haystack;\n+    private byte[] needleBytes, haystackBytes;\n+    private SearchProcessorFactory kmpFactory, shiftingBitMaskFactory, ahoCorasicFactory;\n+\n+    @Setup\n+    public void setup() {\n+        rnd = new Random(SEED);\n+\n+        needleBytes = input.getNeedle(rnd);\n+        haystackBytes = input.getHaystack(rnd);\n+\n+        needle = Unpooled.wrappedBuffer(needleBytes);\n+        haystack = bufferType.newBuffer(haystackBytes);\n+\n+        kmpFactory = SearchProcessorFactory.newKmpSearchProcessorFactory(needleBytes);\n+        ahoCorasicFactory = MultiSearchProcessorFactory.newAhoCorasicSearchProcessorFactory(needleBytes);\n+\n+        if (needleBytes.length <= 64) {\n+            shiftingBitMaskFactory = SearchProcessorFactory.newShiftingBitMaskSearchProcessorFactory(needleBytes);\n+        }\n+    }\n+\n+    @TearDown\n+    public void teardown() {\n+        needle.release();\n+        haystack.release();\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(Mode.DONT_INLINE)\n+    public int indexOf() {\n+        return ByteBufUtil.indexOf(needle, haystack);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(Mode.DONT_INLINE)\n+    public int kmp() {\n+        return haystack.forEachByte(kmpFactory.newSearchProcessor());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "200b9aea18d7ec4684b6af7af41c18c85024e0c1"}, "originalPosition": 191}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "316415241a7e179555c2f5467c4b280385d4a11d", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/316415241a7e179555c2f5467c4b280385d4a11d", "committedDate": "2020-02-11T19:08:32Z", "message": "ShiftingBitMask and KMP using PlatformDependent instead of array"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8182d78887e1f07b09772caebe4c2499b5e3c106", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/8182d78887e1f07b09772caebe4c2499b5e3c106", "committedDate": "2020-02-11T21:18:50Z", "message": "Rewrite Aho-Corasic for better performance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba3242bd9e7982994f395de5046925749e3f773c", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/ba3242bd9e7982994f395de5046925749e3f773c", "committedDate": "2020-02-12T12:18:45Z", "message": "SearchProcessor.reset method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a0b6998612bf9c36094ee1fdc89d19424cf3b28", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/2a0b6998612bf9c36094ee1fdc89d19424cf3b28", "committedDate": "2020-02-13T08:38:51Z", "message": "Missed one array access in KMP - replace with PlatformDependent.getByte"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6e85d895cbe5a98172a94aa2117888ccbf75f8b", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/e6e85d895cbe5a98172a94aa2117888ccbf75f8b", "committedDate": "2020-02-13T19:26:31Z", "message": "Use PlatformDependent.getXX with long index in all string search algos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b0a8d041c2239924cfeb91a8591efe7fb6151ce", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/3b0a8d041c2239924cfeb91a8591efe7fb6151ce", "committedDate": "2020-02-13T20:24:03Z", "message": "Expand byte to long instead of int in AhoCorasic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32fff4f707a277aa9ba2187acd5b42255ca2720e", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/32fff4f707a277aa9ba2187acd5b42255ca2720e", "committedDate": "2020-02-15T09:34:25Z", "message": "A new benchmark suite - SearchRealDataBenchmark"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31d573d116a6d7ef8148ab83a621b159d3fa6edf", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/31d573d116a6d7ef8148ab83a621b159d3fa6edf", "committedDate": "2020-02-15T10:59:23Z", "message": "Do not reuse SearchProcessor in SearchRealDataBenchmark"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dde7c44856c2b0fe1cd2306ae52f891dfa2b71a1", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/dde7c44856c2b0fe1cd2306ae52f891dfa2b71a1", "committedDate": "2020-02-28T09:58:09Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6db9de31ba4543afc0424a3bf8f2124617877b5b", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/6db9de31ba4543afc0424a3bf8f2124617877b5b", "committedDate": "2020-03-01T20:35:45Z", "message": "Rename ShiftingBitMask to Bitap (as known in the industry)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8972d65c8fc3473f3bc372185d8d3ef66340ff20", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/8972d65c8fc3473f3bc372185d8d3ef66340ff20", "committedDate": "2020-03-02T06:52:09Z", "message": "Nest SearchProcessor classes in their Factories for a more compact code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMTMyNTQ4", "url": "https://github.com/netty/netty/pull/9955#pullrequestreview-381132548", "createdAt": "2020-03-25T13:13:44Z", "commit": {"oid": "8972d65c8fc3473f3bc372185d8d3ef66340ff20"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c1d4d6bb85b119707fcfe8afeb7c06d350aad3e", "author": {"user": {"login": "linasm", "name": "Linas Med\u017ei\u016bnas"}}, "url": "https://github.com/netty/netty/commit/8c1d4d6bb85b119707fcfe8afeb7c06d350aad3e", "committedDate": "2020-03-28T20:33:07Z", "message": "Additional test cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzc3OTMy", "url": "https://github.com/netty/netty/pull/9955#pullrequestreview-391377932", "createdAt": "2020-04-10T10:31:01Z", "commit": {"oid": "8c1d4d6bb85b119707fcfe8afeb7c06d350aad3e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMDcwNDA2", "url": "https://github.com/netty/netty/pull/9955#pullrequestreview-392070406", "createdAt": "2020-04-13T10:25:19Z", "commit": {"oid": "8c1d4d6bb85b119707fcfe8afeb7c06d350aad3e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 443, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}