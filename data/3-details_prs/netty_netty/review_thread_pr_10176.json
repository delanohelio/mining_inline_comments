{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMjQ5NTk2", "number": 10176, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODoxNjoyNlrODwTXeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODoyNDo1OFrODwTjgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTc1NTQ0OnYy", "diffSide": "LEFT", "path": "transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODoxNjoyNlrOGDOVqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODoxNzowNVrOGDOXOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMzgzMg==", "bodyText": "Best way to solve the stacktrace inspecting issue :)", "url": "https://github.com/netty/netty/pull/10176#discussion_r406033832", "createdAt": "2020-04-09T08:16:26Z", "author": {"login": "slandelle"}, "path": "transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java", "diffHunk": "@@ -814,39 +814,6 @@ private static void notifyOutboundHandlerException(Throwable cause, ChannelPromi\n         PromiseNotificationUtil.tryFailure(promise, cause, promise instanceof VoidChannelPromise ? null : logger);\n     }\n \n-    private void notifyHandlerException(Throwable cause) {\n-        if (inExceptionCaught(cause)) {\n-            if (logger.isWarnEnabled()) {\n-                logger.warn(\n-                        \"An exception was thrown by a user handler \" +\n-                                \"while handling an exceptionCaught event\", cause);\n-            }\n-            return;\n-        }\n-\n-        invokeExceptionCaught(cause);\n-    }\n-\n-    private static boolean inExceptionCaught(Throwable cause) {\n-        do {\n-            StackTraceElement[] trace = cause.getStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4665bebfbe5c5f954e7465e094cf193393616d44"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNDIzMw==", "bodyText": "@slandelle exactly :D ... no code is the best code.", "url": "https://github.com/netty/netty/pull/10176#discussion_r406034233", "createdAt": "2020-04-09T08:17:05Z", "author": {"login": "normanmaurer"}, "path": "transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java", "diffHunk": "@@ -814,39 +814,6 @@ private static void notifyOutboundHandlerException(Throwable cause, ChannelPromi\n         PromiseNotificationUtil.tryFailure(promise, cause, promise instanceof VoidChannelPromise ? null : logger);\n     }\n \n-    private void notifyHandlerException(Throwable cause) {\n-        if (inExceptionCaught(cause)) {\n-            if (logger.isWarnEnabled()) {\n-                logger.warn(\n-                        \"An exception was thrown by a user handler \" +\n-                                \"while handling an exceptionCaught event\", cause);\n-            }\n-            return;\n-        }\n-\n-        invokeExceptionCaught(cause);\n-    }\n-\n-    private static boolean inExceptionCaught(Throwable cause) {\n-        do {\n-            StackTraceElement[] trace = cause.getStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMzgzMg=="}, "originalCommit": {"oid": "4665bebfbe5c5f954e7465e094cf193393616d44"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTc4NjI2OnYy", "diffSide": "RIGHT", "path": "transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODoyNDo1OFrOGDOo8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODoyNTozMVrOGDOqPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzODc2OQ==", "bodyText": "@trustin @slandelle this is the interesting part in terms of bug-fixing.", "url": "https://github.com/netty/netty/pull/10176#discussion_r406038769", "createdAt": "2020-04-09T08:24:58Z", "author": {"login": "normanmaurer"}, "path": "transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java", "diffHunk": "@@ -333,6 +334,87 @@ public void testChannelHandlerContextNavigation() {\n         verifyContextNumber(pipeline, HANDLER_ARRAY_LEN * 2);\n     }\n \n+    @Test(timeout = 3000)\n+    public void testThrowInExceptionCaught() throws InterruptedException {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicInteger counter = new AtomicInteger();\n+        Channel channel = new LocalChannel();\n+        try {\n+            group.register(channel).syncUninterruptibly();\n+            channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                class TestException extends Exception { }\n+\n+                @Override\n+                public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+                    throw new TestException();\n+                }\n+\n+                @Override\n+                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+                    if (cause instanceof TestException) {\n+                        ctx.executor().execute(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                latch.countDown();\n+                            }\n+                        });\n+                    }\n+                    counter.incrementAndGet();\n+                    throw new Exception();\n+                }\n+            });\n+\n+            channel.pipeline().fireChannelReadComplete();\n+            latch.await();\n+            assertEquals(1, counter.get());\n+        } finally {\n+            channel.close().syncUninterruptibly();\n+        }\n+    }\n+\n+    @Test(timeout = 3000)\n+    public void testThrowInOtherHandlerAfterInvokedFromExceptionCaught() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4665bebfbe5c5f954e7465e094cf193393616d44"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzOTEwMw==", "bodyText": "This test fails before the change .", "url": "https://github.com/netty/netty/pull/10176#discussion_r406039103", "createdAt": "2020-04-09T08:25:31Z", "author": {"login": "normanmaurer"}, "path": "transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java", "diffHunk": "@@ -333,6 +334,87 @@ public void testChannelHandlerContextNavigation() {\n         verifyContextNumber(pipeline, HANDLER_ARRAY_LEN * 2);\n     }\n \n+    @Test(timeout = 3000)\n+    public void testThrowInExceptionCaught() throws InterruptedException {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicInteger counter = new AtomicInteger();\n+        Channel channel = new LocalChannel();\n+        try {\n+            group.register(channel).syncUninterruptibly();\n+            channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                class TestException extends Exception { }\n+\n+                @Override\n+                public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+                    throw new TestException();\n+                }\n+\n+                @Override\n+                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+                    if (cause instanceof TestException) {\n+                        ctx.executor().execute(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                latch.countDown();\n+                            }\n+                        });\n+                    }\n+                    counter.incrementAndGet();\n+                    throw new Exception();\n+                }\n+            });\n+\n+            channel.pipeline().fireChannelReadComplete();\n+            latch.await();\n+            assertEquals(1, counter.get());\n+        } finally {\n+            channel.close().syncUninterruptibly();\n+        }\n+    }\n+\n+    @Test(timeout = 3000)\n+    public void testThrowInOtherHandlerAfterInvokedFromExceptionCaught() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzODc2OQ=="}, "originalCommit": {"oid": "4665bebfbe5c5f954e7465e094cf193393616d44"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3400, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}