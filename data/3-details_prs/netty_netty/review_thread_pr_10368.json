{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4Mzg5MTI1", "number": 10368, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMjozMToyMlrOEQ0fZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMjozMToyMlrOEQ0fZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDcyNjc2OnYy", "diffSide": "RIGHT", "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMjozMToyMlrOG1MJXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMjozMToyMlrOG1MJXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNjcxOQ==", "bodyText": "nit: I know it was there before, but could get rid of written here and just use len directly in it's place", "url": "https://github.com/netty/netty/pull/10368#discussion_r458426719", "createdAt": "2020-07-21T22:31:22Z", "author": {"login": "njhill"}, "path": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java", "diffHunk": "@@ -723,32 +807,32 @@ public static ByteBuf writeAscii(ByteBufAllocator alloc, CharSequence seq) {\n      */\n     public static int writeAscii(ByteBuf buf, CharSequence seq) {\n         // ASCII uses 1 byte per char\n-        final int len = seq.length();\n-        if (seq instanceof AsciiString) {\n-            AsciiString asciiString = (AsciiString) seq;\n-            buf.writeBytes(asciiString.array(), asciiString.arrayOffset(), len);\n-        } else {\n-            for (;;) {\n-                if (buf instanceof WrappedCompositeByteBuf) {\n-                    // WrappedCompositeByteBuf is a sub-class of AbstractByteBuf so it needs special handling.\n-                    buf = buf.unwrap();\n-                } else if (buf instanceof AbstractByteBuf) {\n-                    AbstractByteBuf byteBuf = (AbstractByteBuf) buf;\n-                    byteBuf.ensureWritable0(len);\n-                    int written = writeAscii(byteBuf, byteBuf.writerIndex, seq, len);\n-                    byteBuf.writerIndex += written;\n-                    return written;\n-                } else if (buf instanceof WrappedByteBuf) {\n-                    // Unwrap as the wrapped buffer may be an AbstractByteBuf and so we can use fast-path.\n-                    buf = buf.unwrap();\n+        for (;;) {\n+            if (buf instanceof WrappedCompositeByteBuf) {\n+                // WrappedCompositeByteBuf is a sub-class of AbstractByteBuf so it needs special handling.\n+                buf = buf.unwrap();\n+            } else if (buf instanceof AbstractByteBuf) {\n+                final int len = seq.length();\n+                AbstractByteBuf byteBuf = (AbstractByteBuf) buf;\n+                byteBuf.ensureWritable0(len);\n+                int written;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49345b2bcdfecebe6a11bb72e1ac2c13f89f1d50"}, "originalPosition": 164}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3823, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}