{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM3MDI0MzYw", "number": 10860, "title": "Workaround possible JDK bug in SSLEngineImpl when using TLSv1.3 that \u2026", "bodyText": "\u2026lead to multiple notifications\nMotivation:\nWhen using the JDKs SSLEngineImpl with TLSv1.3 it sometimes returns HandshakeResult.FINISHED multiple times. This can lead to have SslHandshakeCompletionEvents to be fired multiple times.\nModifications:\n\nKeep track of if we notified before and if so not do so again if we use TLSv1.3\nAdd unit test\n\nResult:\nConsistent usage of events", "createdAt": "2020-12-11T15:34:50Z", "url": "https://github.com/netty/netty/pull/10860", "merged": true, "mergeCommit": {"oid": "dd6ef486f42bf23e2fb1f4214f01a0abfa767949"}, "closed": true, "closedAt": "2020-12-15T06:53:15Z", "author": {"login": "normanmaurer"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdlJug1gH2gAyNTM3MDI0MzYwOmUyMWJhNjNkOGZmYTUwMDlkNTgzNjcxMzgwNDQ4NGZhZWI4MTEyYzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmNAltAFqTU1MTkyNTk2Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e21ba63d8ffa5009d5836713804484faeb8112c2", "author": {"user": {"login": "normanmaurer", "name": "Norman Maurer"}}, "url": "https://github.com/netty/netty/commit/e21ba63d8ffa5009d5836713804484faeb8112c2", "committedDate": "2020-12-11T15:32:23Z", "message": "Workaround possible JDK bug in SSLEngineImpl when using TLSv1.3 that lead to multiple notifications\n\nMotivation:\n\nWhen using the JDKs SSLEngineImpl with TLSv1.3 it sometimes returns HandshakeResult.FINISHED multiple times. This can lead to have SslHandshakeCompletionEvents to be fired multiple times.\n\nModifications:\n\n- Keep track of if we notified before and if so not do so again if we use TLSv1.3\n- Add unit test\n\nResult:\n\nConsistent usage of events"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNDY4MDU2", "url": "https://github.com/netty/netty/pull/10860#pullrequestreview-550468056", "createdAt": "2020-12-11T18:50:25Z", "commit": {"oid": "e21ba63d8ffa5009d5836713804484faeb8112c2"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODo1MDoyNlrOIEFjRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTowMDowM1rOIEF_4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE1NjE2Nw==", "bodyText": "Consider having 2 independent queues for client and server to make sure both of them see the same number if events.", "url": "https://github.com/netty/netty/pull/10860#discussion_r541156167", "createdAt": "2020-12-11T18:50:26Z", "author": {"login": "idelpivnitskiy"}, "path": "handler/src/test/java/io/netty/handler/ssl/SslHandlerTest.java", "diffHunk": "@@ -1482,4 +1482,102 @@ protected void initChannel(Channel ch) {\n         }\n     }\n \n+    @Test\n+    public void testHandshakeEventsTls12JDK() throws Exception {\n+        testHandshakeEvents(SslProvider.JDK, SslUtils.PROTOCOL_TLS_V1_2);\n+    }\n+\n+    @Test\n+    public void testHandshakeEventsTls12Openssl() throws Exception {\n+        assumeTrue(OpenSsl.isAvailable());\n+        testHandshakeEvents(SslProvider.OPENSSL, SslUtils.PROTOCOL_TLS_V1_2);\n+    }\n+\n+    @Test\n+    public void testHandshakeEventsTls13JDK() throws Exception {\n+        assumeTrue(SslProvider.isTlsv13Supported(SslProvider.JDK));\n+        testHandshakeEvents(SslProvider.JDK, SslUtils.PROTOCOL_TLS_V1_3);\n+    }\n+\n+    @Test\n+    public void testHandshakeEventsTls13Openssl() throws Exception {\n+        assumeTrue(OpenSsl.isAvailable());\n+        assumeTrue(SslProvider.isTlsv13Supported(SslProvider.OPENSSL));\n+        testHandshakeEvents(SslProvider.OPENSSL, SslUtils.PROTOCOL_TLS_V1_3);\n+    }\n+\n+    private void testHandshakeEvents(SslProvider provider, String protocol) throws Exception {\n+        final SslContext sslClientCtx = SslContextBuilder.forClient()\n+                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n+                .protocols(protocol)\n+                .sslProvider(provider).build();\n+\n+        final SelfSignedCertificate cert = new SelfSignedCertificate();\n+        final SslContext sslServerCtx = SslContextBuilder.forServer(cert.key(), cert.cert())\n+                .protocols(protocol)\n+                .sslProvider(provider).build();\n+\n+        EventLoopGroup group = new NioEventLoopGroup();\n+\n+        final LinkedBlockingQueue<SslHandshakeCompletionEvent> completionEvents =\n+                new LinkedBlockingQueue<SslHandshakeCompletionEvent>();\n+        final ChannelHandler completionEventHandler = new ChannelInboundHandlerAdapter() {\n+            @Override\n+            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n+                if (evt instanceof SslHandshakeCompletionEvent) {\n+                    completionEvents.add((SslHandshakeCompletionEvent) evt);\n+                }\n+            }\n+\n+            @Override\n+            public boolean isSharable() {\n+                return true;\n+            }\n+        };\n+        try {\n+            Channel sc = new ServerBootstrap()\n+                    .group(group)\n+                    .channel(NioServerSocketChannel.class)\n+                    .childHandler(new ChannelInitializer<Channel>() {\n+                        @Override\n+                        protected void initChannel(Channel ch) throws Exception {\n+                            ch.pipeline().addLast(sslServerCtx.newHandler(UnpooledByteBufAllocator.DEFAULT));\n+                            ch.pipeline().addLast(completionEventHandler);\n+                        }\n+                    })\n+                    .bind(new InetSocketAddress(0)).syncUninterruptibly().channel();\n+\n+            Bootstrap bs = new Bootstrap()\n+                    .group(group)\n+                    .channel(NioSocketChannel.class)\n+                    .handler(new ChannelInitializer<Channel>() {\n+                        @Override\n+                        protected void initChannel(Channel ch) {\n+                            ch.pipeline().addLast(sslClientCtx.newHandler(\n+                                    UnpooledByteBufAllocator.DEFAULT, \"netty.io\", 9999));\n+                            ch.pipeline().addLast(completionEventHandler);\n+                        }\n+                    })\n+                    .remoteAddress(sc.localAddress());\n+\n+            Channel cc1 = bs.connect().sync().channel();\n+            Channel cc2 = bs.connect().sync().channel();\n+\n+            // We expect 4 events as we have 2 connections and for each connection there should be one event\n+            // on the server-side and one on the client-side.\n+            for (int i = 0; i < 4; i++) {\n+                SslHandshakeCompletionEvent event = completionEvents.take();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e21ba63d8ffa5009d5836713804484faeb8112c2"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MzQ4OA==", "bodyText": "Is engineType == SslEngineType.JDK is necessary here? I think we can have only notified || !SslUtils.PROTOCOL_TLS_V1_3.equals(session.getProtocol()).\nAlso, IIUC in case of renegotiation netty initializes a new handshakePromise. So, the notified will also be true for renegotiation.", "url": "https://github.com/netty/netty/pull/10860#discussion_r541163488", "createdAt": "2020-12-11T19:00:03Z", "author": {"login": "idelpivnitskiy"}, "path": "handler/src/main/java/io/netty/handler/ssl/SslHandler.java", "diffHunk": "@@ -1800,17 +1800,24 @@ private boolean setHandshakeSuccessIfStillHandshaking() {\n      * Notify all the handshake futures about the successfully handshake\n      */\n     private void setHandshakeSuccess() {\n-        handshakePromise.trySuccess(ctx.channel());\n-\n-        if (logger.isDebugEnabled()) {\n-            SSLSession session = engine.getSession();\n-            logger.debug(\n-              \"{} HANDSHAKEN: protocol:{} cipher suite:{}\",\n-              ctx.channel(),\n-              session.getProtocol(),\n-              session.getCipherSuite());\n+        boolean notified = handshakePromise.trySuccess(ctx.channel());\n+        SSLSession session = engine.getSession();\n+\n+        // There seems to be a bug in the SSLEngineImpl that is part of the OpenJDK that results in returning\n+        // HandshakeStatus.FINISHED multiple times which is not expected. This only happens in TLSv1.3 so lets\n+        // ensure we only notify once in this case.\n+        //\n+        // This is safe as TLSv1.3 does not support renegotiation and so we should never see two handshake events.\n+        if (notified || engineType == SslEngineType.JDK && !SslUtils.PROTOCOL_TLS_V1_3.equals(session.getProtocol())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e21ba63d8ffa5009d5836713804484faeb8112c2"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75ec3eedb876ced05238ec2d38e2a5cb220d1a48", "author": {"user": {"login": "normanmaurer", "name": "Norman Maurer"}}, "url": "https://github.com/netty/netty/commit/75ec3eedb876ced05238ec2d38e2a5cb220d1a48", "committedDate": "2020-12-14T20:33:10Z", "message": "Address comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxOTI1OTYy", "url": "https://github.com/netty/netty/pull/10860#pullrequestreview-551925962", "createdAt": "2020-12-14T21:55:46Z", "commit": {"oid": "75ec3eedb876ced05238ec2d38e2a5cb220d1a48"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4869, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}