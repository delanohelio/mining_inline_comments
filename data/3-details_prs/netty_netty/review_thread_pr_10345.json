{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNTU4Nzg3", "number": 10345, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMToyMzo1NVrOELpUpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMToyMzo1NVrOELpUpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjQ2ODIyOnYy", "diffSide": "RIGHT", "path": "example/src/main/java/io/netty/example/smtp/SmtpClientHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMToyMzo1NVrOGtTUmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwNjowOToxNVrOGtwVUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE1NTY3NQ==", "bodyText": "@yuanrw I think it would be better to just expose CompletionStage in general. WDYT ?", "url": "https://github.com/netty/netty/pull/10345#discussion_r450155675", "createdAt": "2020-07-06T11:23:55Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/smtp/SmtpClientHandler.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package io.netty.example.smtp;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.smtp.DefaultLastSmtpContent;\n+import io.netty.handler.codec.smtp.SmtpRequest;\n+import io.netty.handler.codec.smtp.SmtpResponse;\n+import io.netty.util.concurrent.EventExecutor;\n+import io.netty.util.concurrent.FutureCompletionStage;\n+import io.netty.util.concurrent.Promise;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An example smtp client handler\n+ */\n+public class SmtpClientHandler extends SimpleChannelInboundHandler<SmtpResponse> {\n+\n+    private ChannelHandlerContext ctx;\n+    private final AtomicReference<Promise<SmtpResponse>> responseFuture = new AtomicReference<>();\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.ctx = ctx;\n+    }\n+\n+    @Override\n+    protected void messageReceived(ChannelHandlerContext ctx, SmtpResponse response) throws Exception {\n+        Promise<SmtpResponse> promise = responseFuture.get();\n+        if (promise == null) {\n+            throw new RuntimeException(\"Unexpected response received: \" + response);\n+        } else {\n+            if (response.code() >= 500) {\n+                throw new RuntimeException(\"receive an error: \" + response);\n+            }\n+            printResponse(response);\n+            promise.setSuccess(response);\n+            responseFuture.set(null);\n+        }\n+    }\n+\n+    private static void printResponse(SmtpResponse response) {\n+        System.out.println(response);\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        cause.printStackTrace();\n+        responseFuture.get().setFailure(cause);\n+        ctx.close();\n+    }\n+\n+    public FutureCompletionStage<SmtpResponse> send(SmtpRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f4a51d2992aa3cf567e50e3de3ce21ffd684a4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYzMDk5Mg==", "bodyText": "@normanmaurer Sometimes we may want to block on the result. So I need to get the underlying Future.\nhandler.send(req(EHLO, \"localhost\"))\n        .thenCompose(r -> handler.send(req(AUTH, \"login\")))\n        .future().await();", "url": "https://github.com/netty/netty/pull/10345#discussion_r450630992", "createdAt": "2020-07-07T06:09:15Z", "author": {"login": "yuanrw"}, "path": "example/src/main/java/io/netty/example/smtp/SmtpClientHandler.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package io.netty.example.smtp;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.smtp.DefaultLastSmtpContent;\n+import io.netty.handler.codec.smtp.SmtpRequest;\n+import io.netty.handler.codec.smtp.SmtpResponse;\n+import io.netty.util.concurrent.EventExecutor;\n+import io.netty.util.concurrent.FutureCompletionStage;\n+import io.netty.util.concurrent.Promise;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An example smtp client handler\n+ */\n+public class SmtpClientHandler extends SimpleChannelInboundHandler<SmtpResponse> {\n+\n+    private ChannelHandlerContext ctx;\n+    private final AtomicReference<Promise<SmtpResponse>> responseFuture = new AtomicReference<>();\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.ctx = ctx;\n+    }\n+\n+    @Override\n+    protected void messageReceived(ChannelHandlerContext ctx, SmtpResponse response) throws Exception {\n+        Promise<SmtpResponse> promise = responseFuture.get();\n+        if (promise == null) {\n+            throw new RuntimeException(\"Unexpected response received: \" + response);\n+        } else {\n+            if (response.code() >= 500) {\n+                throw new RuntimeException(\"receive an error: \" + response);\n+            }\n+            printResponse(response);\n+            promise.setSuccess(response);\n+            responseFuture.set(null);\n+        }\n+    }\n+\n+    private static void printResponse(SmtpResponse response) {\n+        System.out.println(response);\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        cause.printStackTrace();\n+        responseFuture.get().setFailure(cause);\n+        ctx.close();\n+    }\n+\n+    public FutureCompletionStage<SmtpResponse> send(SmtpRequest request) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE1NTY3NQ=="}, "originalCommit": {"oid": "36f4a51d2992aa3cf567e50e3de3ce21ffd684a4"}, "originalPosition": 68}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3813, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}