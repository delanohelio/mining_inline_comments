{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxNjE0NTcx", "number": 10542, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToxOToxM1rOEhYdeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxODoyNzowNFrOEipahg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDM5MjI0OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToxOToxM1rOHOqwFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjo0ODoxOVrOHO5BwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjU1MA==", "bodyText": "It looks correct that we are getting the completion queue tail with volatile, but previously the volatile load was on the head. Can we have a double-check and justify to ourselves that this is right?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485142550", "createdAt": "2020-09-08T19:19:13Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,44 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTg2OA==", "bodyText": "I think this is right... agree it would be good for others to confirm :)", "url": "https://github.com/netty/netty/pull/10542#discussion_r485179868", "createdAt": "2020-09-08T20:32:52Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,44 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjU1MA=="}, "originalCommit": {"oid": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMyNzY5Nw==", "bodyText": "I dont think you that we need  head double check, as io_uring wouldn't never change the cqe head", "url": "https://github.com/netty/netty/pull/10542#discussion_r485327697", "createdAt": "2020-09-09T04:18:23Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,44 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjU1MA=="}, "originalCommit": {"oid": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3NjQ0OA==", "bodyText": "@nitsanw can you have a look as well to ensure that we are ok in terms with memory barriers etc ?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485376448", "createdAt": "2020-09-09T06:48:19Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,44 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjU1MA=="}, "originalCommit": {"oid": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDQwNDkxOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToyMjo0MFrOHOq3lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToyMjo0MFrOHOq3lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0NDQ3MA==", "bodyText": "This can also be modelled as a do-while.", "url": "https://github.com/netty/netty/pull/10542#discussion_r485144470", "createdAt": "2020-09-08T19:22:40Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -110,9 +110,29 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n+            for (;;) {\n+                // avoid blocking for as long as possible\n+                completionQueue.process(this);\n+                boolean ranTasks = runAllTasks();\n+                if (!ranTasks) {\n+                    break;\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk2NDgwOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjo1NDo0NVrOHO5NzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwODowNjowNFrOHO7kLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3OTUzMg==", "bodyText": "I would make this volatile for clarity", "url": "https://github.com/netty/netty/pull/10542#discussion_r485379532", "createdAt": "2020-09-09T06:54:45Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQxODAyOA==", "bodyText": "do you mean both variables should be volatile or getIntVolatile, however I would prefer getIntVolatile :)", "url": "https://github.com/netty/netty/pull/10542#discussion_r485418028", "createdAt": "2020-09-09T08:06:04Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3OTUzMg=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk2ODgyOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjo1NTo1OVrOHO5QIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwODowNzo1MlrOHO7ocw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MDEyOA==", "bodyText": "I assume cqe is entryAddress?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485380128", "createdAt": "2020-09-09T06:55:59Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqe = (ringHead & ringMask) * CQE_SIZE + completionQueueArrayAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQxOTEyMw==", "bodyText": "exactly", "url": "https://github.com/netty/netty/pull/10542#discussion_r485419123", "createdAt": "2020-09-09T08:07:52Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqe = (ringHead & ringMask) * CQE_SIZE + completionQueueArrayAddress;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MDEyOA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk3NzU1OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjo1OTowMVrOHO5Vig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDo1NDo1OFrOHPi6iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTUxNA==", "bodyText": "we should submit here, at least at the end of the loop", "url": "https://github.com/netty/netty/pull/10542#discussion_r485381514", "createdAt": "2020-09-09T06:59:01Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -153,29 +173,7 @@ protected void run() {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n-\n-            // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-            submissionQueue.submit();\n-            clearUsedIovArrays();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-                    submissionQueue.submit();\n-                    clearUsedIovArrays();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n-                    }\n-                }\n-            } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                clearUsedIovArrays();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQwMDM4Mw==", "bodyText": "WDYT?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485400383", "createdAt": "2020-09-09T07:36:15Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -153,29 +173,7 @@ protected void run() {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n-\n-            // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-            submissionQueue.submit();\n-            clearUsedIovArrays();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-                    submissionQueue.submit();\n-                    clearUsedIovArrays();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n-                    }\n-                }\n-            } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                clearUsedIovArrays();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTUxNA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg4NjYzNQ==", "bodyText": "@1Jo1 but this is right after submitting (the submitAndWait() above)? Unless we skipped it because more work was found, but that's just an edge case (we would have remained in the inner loop anyhow).\nLooking again I just realized that there is a (pre-existing) bug here though... the hasTasks() check should be inside the try/finally, will fix that.", "url": "https://github.com/netty/netty/pull/10542#discussion_r485886635", "createdAt": "2020-09-09T19:59:52Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -153,29 +173,7 @@ protected void run() {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n-\n-            // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-            submissionQueue.submit();\n-            clearUsedIovArrays();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-                    submissionQueue.submit();\n-                    clearUsedIovArrays();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n-                    }\n-                }\n-            } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                clearUsedIovArrays();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTUxNA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2MjcyOQ==", "bodyText": "@1Jo1 but this is right after submitting (the submitAndWait() above)? Unless we skipped it because more work was found, but that's just an edge case (we would have remained in the inner loop anyhow).\n\nexactly that's what I thought :)", "url": "https://github.com/netty/netty/pull/10542#discussion_r486062729", "createdAt": "2020-09-10T04:54:58Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -153,29 +173,7 @@ protected void run() {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n-\n-            // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-            submissionQueue.submit();\n-            clearUsedIovArrays();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-                    submissionQueue.submit();\n-                    clearUsedIovArrays();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n-                    }\n-                }\n-            } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                clearUsedIovArrays();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTUxNA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk3ODA1OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjo1OTowOVrOHO5V0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjo1OTowOVrOHO5V0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTU4Ng==", "bodyText": "The completion queue is single consumer I assume, so this is fine. I would still split this into 2 lines.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      PlatformDependent.putIntOrdered(kHeadAddress, ++ringHead);\n          \n          \n            \n                      ringHead++;\n          \n          \n            \n                      PlatformDependent.putIntOrdered(kHeadAddress, ringHead);", "url": "https://github.com/netty/netty/pull/10542#discussion_r485381586", "createdAt": "2020-09-09T06:59:09Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqe = (ringHead & ringMask) * CQE_SIZE + completionQueueArrayAddress;\n+\n+          long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n+          int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n+          int flags = PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD);\n+\n+          //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n+          PlatformDependent.putIntOrdered(kHeadAddress, ++ringHead);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk4MzkxOnYy", "diffSide": "LEFT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzowMToxMFrOHO5ZpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDo0ODozNlrOHPizZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjU2NA==", "bodyText": "This is not present in the new code?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485382564", "createdAt": "2020-09-09T07:01:10Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcxMjQ5OA==", "bodyText": "I think it was redundant. The method returns count of completions processed, so didn't see a reason for converting 0 to -1, maybe @1Jo1 can confirm?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485712498", "createdAt": "2020-09-09T15:41:27Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjU2NA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2MDkwMA==", "bodyText": "@njhill yeah it is redundant, it looks fine to me, just replace -1 to 0 :)", "url": "https://github.com/netty/netty/pull/10542#discussion_r486060900", "createdAt": "2020-09-10T04:48:36Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjU2NA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTk5MTIzOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzowMzo0NlrOHO5eNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNTo1NDozMlrOHPOF9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzczMw==", "bodyText": "should be &&?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485383733", "createdAt": "2020-09-09T07:03:46Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcyMTU5MA==", "bodyText": "@nitsanw this is probably more in your wheelhouse but my understanding was that non-short-circuit variants of boolean ops are preferable when the operands are trivial (eliminates a branch I think)? I've seen it used in other places but agree it looks odd.", "url": "https://github.com/netty/netty/pull/10542#discussion_r485721590", "createdAt": "2020-09-09T15:54:32Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzczMw=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNjAwMTgxOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzowNzoyNVrOHO5ksQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODoxNDo1NFrOHPUGvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        boolean maybeMoreIo;\n          \n          \n            \n                        do {\n          \n          \n            \n                            maybeMoreIo = completionQueue.process(this) != 0;\n          \n          \n            \n                            if (!maybeMoreIo & !maybeMoreTasks) {\n          \n          \n            \n                                break; // no need to check tasks again here\n          \n          \n            \n                            }\n          \n          \n            \n                            maybeMoreTasks = runAllTasks();\n          \n          \n            \n                            try {\n          \n          \n            \n                                if (isShuttingDown()) {\n          \n          \n            \n                                    closeAll();\n          \n          \n            \n                                    if (confirmShutdown()) {\n          \n          \n            \n                                        return;\n          \n          \n            \n                                    }\n          \n          \n            \n                                }\n          \n          \n            \n                            } catch (Throwable t) {\n          \n          \n            \n                                logger.info(\"Exception error: {}\", t);\n          \n          \n            \n                            }\n          \n          \n            \n                        } while (maybeMoreIo | maybeMoreTasks);\n          \n          \n            \n                        boolean maybeMoreIo = completionQueue.process(this) != 0;\n          \n          \n            \n                        while (maybeMoreIo || maybeMoreTasks) {\n          \n          \n            \n                            maybeMoreTasks = runAllTasks();\n          \n          \n            \n                            try {\n          \n          \n            \n                                if (isShuttingDown()) {\n          \n          \n            \n                                    closeAll();\n          \n          \n            \n                                    if (confirmShutdown()) {\n          \n          \n            \n                                        return;\n          \n          \n            \n                                    }\n          \n          \n            \n                                }\n          \n          \n            \n                            } catch (Throwable t) {\n          \n          \n            \n                                logger.info(\"Exception error: {}\", t);\n          \n          \n            \n                            }\n          \n          \n            \n                            maybeMoreIo = completionQueue.process(this) != 0;\n          \n          \n            \n                        }", "url": "https://github.com/netty/netty/pull/10542#discussion_r485385393", "createdAt": "2020-09-09T07:07:25Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);\n+                }\n+            } while (maybeMoreIo | maybeMoreTasks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyNDY2Nw==", "bodyText": "@nitsanw I like your suggested change \ud83d\udc4d I think it's cleaner to avoid break's", "url": "https://github.com/netty/netty/pull/10542#discussion_r485424667", "createdAt": "2020-09-09T08:17:07Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);\n+                }\n+            } while (maybeMoreIo | maybeMoreTasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2NDgwOA==", "bodyText": "Yeah, the do-while only made sense when we had the simple loop previously.", "url": "https://github.com/netty/netty/pull/10542#discussion_r485564808", "createdAt": "2020-09-09T12:17:10Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);\n+                }\n+            } while (maybeMoreIo | maybeMoreTasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwNDczOA==", "bodyText": "I was aiming to allow breaking out after either the tasks run or the io run, since there could be a redundant attempt otherwise (for example some tasks run, then CQ is empty, then no tasks are run - the proposed version will attempt to process the CQ again unnecessarily). In practice I guess it wouldn't make noticeable difference, so maybe fine to stick with slightly simpler logic?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485804738", "createdAt": "2020-09-09T17:46:48Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);\n+                }\n+            } while (maybeMoreIo | maybeMoreTasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyMDA5NA==", "bodyText": "let's follow \"KISS\" rule here and keep it simple", "url": "https://github.com/netty/netty/pull/10542#discussion_r485820094", "createdAt": "2020-09-09T18:14:54Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);\n+                }\n+            } while (maybeMoreIo | maybeMoreTasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzEzNjI0OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjoxNDoyNlrOHPEbTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNTo1Njo0N1rOHPOMKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2MzIxNA==", "bodyText": "Checkstyle seems to complain about trailing whitespace on this line.", "url": "https://github.com/netty/netty/pull/10542#discussion_r485563214", "createdAt": "2020-09-09T12:14:26Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -39,6 +39,9 @@\n   private final int ringSize;\n   private final long ringAddress;\n   private final int ringFd;\n+  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcyMzE3OQ==", "bodyText": "\ud83d\udc4d I hadn't been running these through checkstyle up to now but will do and make sure it passes", "url": "https://github.com/netty/netty/pull/10542#discussion_r485723179", "createdAt": "2020-09-09T15:56:47Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -39,6 +39,9 @@\n   private final int ringSize;\n   private final long ringAddress;\n   private final int ringFd;\n+  ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2MzIxNA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzE3MTc0OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjoyNDoyNlrOHPExAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjoxNToyNlrOHPPNHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2ODc2OA==", "bodyText": "I think the exception should say something about \"Caught exception when shutting down event loop\" or something. This part, including the error handling, could also be extracted to a separate method, so it looks like \"if (blabla()) { return; }`", "url": "https://github.com/netty/netty/pull/10542#discussion_r485568768", "createdAt": "2020-09-09T12:24:26Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTczNzUyNQ==", "bodyText": "@chrisvest agree this needs more changes but I had just moved this part from lower down. I think there's a fair amount still to be done for error handling in general so maybe best for another PR(s)?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485737525", "createdAt": "2020-09-09T16:12:53Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2ODc2OA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTczOTgwNg==", "bodyText": "Sounds good.", "url": "https://github.com/netty/netty/pull/10542#discussion_r485739806", "createdAt": "2020-09-09T16:15:26Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2ODc2OA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTk1NDA1OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMDoxMzo0M1rOHQZBww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNDoxNjo1NlrOHQgunA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ==", "bodyText": "I'm not sure if a Or bitwise operator would make sense here, what about ||?", "url": "https://github.com/netty/netty/pull/10542#discussion_r486949315", "createdAt": "2020-09-11T10:13:43Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2ODQ0MA==", "bodyText": "the difference here is (IMHO) that with | it will run both commands while with || it will run only the first. If | is really what we want we should at least clarify this in a comment as at the first look it seems suspicious.", "url": "https://github.com/netty/netty/pull/10542#discussion_r486968440", "createdAt": "2020-09-11T10:54:30Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MTc4OA==", "bodyText": "okay that makes sense :)", "url": "https://github.com/netty/netty/pull/10542#discussion_r486971788", "createdAt": "2020-09-11T11:01:58Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNTM1OQ==", "bodyText": "Yeah, either a comment, or a change the code to make it obvious that we wish to run both.", "url": "https://github.com/netty/netty/pull/10542#discussion_r487025359", "createdAt": "2020-09-11T12:55:01Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3NTQ4NA==", "bodyText": "Yep agreed a comment would be good!", "url": "https://github.com/netty/netty/pull/10542#discussion_r487075484", "createdAt": "2020-09-11T14:16:56Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjQyNjM3OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo0ODozNVrOHQdcOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo0MzoyMFrOHQkHMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTYyNw==", "bodyText": "Not specifically related to this PR, but I just noticed that this considers the CQE processed and consumed when handle returns false. Further turns out that this doesn't matter in practice because handle always returns true, except in one test. \ud83e\udd37", "url": "https://github.com/netty/netty/pull/10542#discussion_r487021627", "createdAt": "2020-09-11T12:48:35Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,37 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getIntVolatile(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getIntVolatile(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqeAddress = completionQueueArrayAddress + (ringHead & ringMask) * CQE_SIZE;\n+\n+          long udata = PlatformDependent.getLong(cqeAddress + CQE_USER_DATA_FIELD);\n+          int res = PlatformDependent.getInt(cqeAddress + CQE_RES_FIELD);\n+          int flags = PlatformDependent.getInt(cqeAddress + CQE_FLAGS_FIELD);\n+\n+          //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n+          ringHead++;\n+          PlatformDependent.putIntOrdered(kHeadAddress, ringHead);\n+\n+          int fd = (int) (udata >>> 32);\n+          int opMask = (int) (udata & 0xFFFFFFFFL);\n+          int op = opMask >>> 16;\n+          int mask = opMask & 0xffff;\n+\n+          i++;\n+          if (!callback.handle(fd, res, flags, op, mask)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3NzcxOQ==", "bodyText": "Will let @normanmaurer comment since I think he did this originally. It does look like it might be redundant now though... @normanmaurer wdyt about changing to void?", "url": "https://github.com/netty/netty/pull/10542#discussion_r487077719", "createdAt": "2020-09-11T14:20:26Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,37 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getIntVolatile(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getIntVolatile(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqeAddress = completionQueueArrayAddress + (ringHead & ringMask) * CQE_SIZE;\n+\n+          long udata = PlatformDependent.getLong(cqeAddress + CQE_USER_DATA_FIELD);\n+          int res = PlatformDependent.getInt(cqeAddress + CQE_RES_FIELD);\n+          int flags = PlatformDependent.getInt(cqeAddress + CQE_FLAGS_FIELD);\n+\n+          //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n+          ringHead++;\n+          PlatformDependent.putIntOrdered(kHeadAddress, ringHead);\n+\n+          int fd = (int) (udata >>> 32);\n+          int opMask = (int) (udata & 0xFFFFFFFFL);\n+          int op = opMask >>> 16;\n+          int mask = opMask & 0xffff;\n+\n+          i++;\n+          if (!callback.handle(fd, res, flags, op, mask)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTYyNw=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA5MjE1MQ==", "bodyText": "@chrisvest  good point, void would make more sense I guess", "url": "https://github.com/netty/netty/pull/10542#discussion_r487092151", "createdAt": "2020-09-11T14:41:40Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,37 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getIntVolatile(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getIntVolatile(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqeAddress = completionQueueArrayAddress + (ringHead & ringMask) * CQE_SIZE;\n+\n+          long udata = PlatformDependent.getLong(cqeAddress + CQE_USER_DATA_FIELD);\n+          int res = PlatformDependent.getInt(cqeAddress + CQE_RES_FIELD);\n+          int flags = PlatformDependent.getInt(cqeAddress + CQE_FLAGS_FIELD);\n+\n+          //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n+          ringHead++;\n+          PlatformDependent.putIntOrdered(kHeadAddress, ringHead);\n+\n+          int fd = (int) (udata >>> 32);\n+          int opMask = (int) (udata & 0xFFFFFFFFL);\n+          int op = opMask >>> 16;\n+          int mask = opMask & 0xffff;\n+\n+          i++;\n+          if (!callback.handle(fd, res, flags, op, mask)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTYyNw=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzMDkzMA==", "bodyText": "I added it original to limit the number of processed events per loop but i guess void is fine for now", "url": "https://github.com/netty/netty/pull/10542#discussion_r487130930", "createdAt": "2020-09-11T15:43:20Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,37 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getIntVolatile(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getIntVolatile(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqeAddress = completionQueueArrayAddress + (ringHead & ringMask) * CQE_SIZE;\n+\n+          long udata = PlatformDependent.getLong(cqeAddress + CQE_USER_DATA_FIELD);\n+          int res = PlatformDependent.getInt(cqeAddress + CQE_RES_FIELD);\n+          int flags = PlatformDependent.getInt(cqeAddress + CQE_FLAGS_FIELD);\n+\n+          //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n+          ringHead++;\n+          PlatformDependent.putIntOrdered(kHeadAddress, ringHead);\n+\n+          int fd = (int) (udata >>> 32);\n+          int opMask = (int) (udata & 0xFFFFFFFFL);\n+          int op = opMask >>> 16;\n+          int mask = opMask & 0xffff;\n+\n+          i++;\n+          if (!callback.handle(fd, res, flags, op, mask)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTYyNw=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjQ1ODkyOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo1Nzo0M1rOHQdwpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNToxMjowMlrOHQi8nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNjg1Mw==", "bodyText": "Oof! Can we add a trip-counter or something (with reset on successful trips) so we only do this when there are many consecutive errors? This could be moved to some rate-limited error reporter component.", "url": "https://github.com/netty/netty/pull/10542#discussion_r487026853", "createdAt": "2020-09-11T12:57:43Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();\n+                    } finally {\n+                        // Always handle shutdown even if the loop processing threw an exception\n+                        try {\n+                            if (isShuttingDown()) {\n+                                closeAll();\n+                                if (confirmShutdown()) {\n+                                    return;\n+                                }\n+                                if (!maybeMoreWork) {\n+                                    maybeMoreWork = hasTasks() || completionQueue.hasCompletions();\n+                                }\n+                            }\n+                        } catch (Throwable t) {\n+                            handleLoopException(t);\n+                        }\n                     }\n-                }\n+                } while (maybeMoreWork);\n             } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                handleLoopException(t);\n             }\n         }\n     }\n \n+    /**\n+     * Visible only for testing!\n+     */\n+    void handleLoopException(Throwable t) {\n+        logger.warn(\"Unexpected exception in the io_uring event loop\", t);\n+\n+        // Prevent possible consecutive immediate failures that lead to\n+        // excessive CPU consumption.\n+        try {\n+            Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4MDgxOA==", "bodyText": "This was lifted straight from EpollEventLoop https://github.com/netty/netty/blob/4.1/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java#L410-L423 where it's lived for a long time.\nI think that any exceptions are expected to be caught before reaching this point, so it indicates something is very wrong. I don't recall ever seeing this hit myself so extra complexity might not be worth it. Will defer to @normanmaurer again... :)", "url": "https://github.com/netty/netty/pull/10542#discussion_r487080818", "createdAt": "2020-09-11T14:25:12Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();\n+                    } finally {\n+                        // Always handle shutdown even if the loop processing threw an exception\n+                        try {\n+                            if (isShuttingDown()) {\n+                                closeAll();\n+                                if (confirmShutdown()) {\n+                                    return;\n+                                }\n+                                if (!maybeMoreWork) {\n+                                    maybeMoreWork = hasTasks() || completionQueue.hasCompletions();\n+                                }\n+                            }\n+                        } catch (Throwable t) {\n+                            handleLoopException(t);\n+                        }\n                     }\n-                }\n+                } while (maybeMoreWork);\n             } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                handleLoopException(t);\n             }\n         }\n     }\n \n+    /**\n+     * Visible only for testing!\n+     */\n+    void handleLoopException(Throwable t) {\n+        logger.warn(\"Unexpected exception in the io_uring event loop\", t);\n+\n+        // Prevent possible consecutive immediate failures that lead to\n+        // excessive CPU consumption.\n+        try {\n+            Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNjg1Mw=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMTgzOQ==", "bodyText": "Ok, in that case I won't hold it against this PR.", "url": "https://github.com/netty/netty/pull/10542#discussion_r487111839", "createdAt": "2020-09-11T15:12:02Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();\n+                    } finally {\n+                        // Always handle shutdown even if the loop processing threw an exception\n+                        try {\n+                            if (isShuttingDown()) {\n+                                closeAll();\n+                                if (confirmShutdown()) {\n+                                    return;\n+                                }\n+                                if (!maybeMoreWork) {\n+                                    maybeMoreWork = hasTasks() || completionQueue.hasCompletions();\n+                                }\n+                            }\n+                        } catch (Throwable t) {\n+                            handleLoopException(t);\n+                        }\n                     }\n-                }\n+                } while (maybeMoreWork);\n             } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                handleLoopException(t);\n             }\n         }\n     }\n \n+    /**\n+     * Visible only for testing!\n+     */\n+    void handleLoopException(Throwable t) {\n+        logger.warn(\"Unexpected exception in the io_uring event loop\", t);\n+\n+        // Prevent possible consecutive immediate failures that lead to\n+        // excessive CPU consumption.\n+        try {\n+            Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNjg1Mw=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjQ3MjU0OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzowMTo0NlrOHQd5Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjozNTozNFrOHQl4YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg==", "bodyText": "Guarding for negative submit counts? When would that happen?", "url": "https://github.com/netty/netty/pull/10542#discussion_r487029082", "createdAt": "2020-09-11T13:01:46Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -188,17 +188,33 @@ public boolean addClose(int fd) {\n     public void submit() {\n         int submit = tail - head;\n         if (submit > 0) {\n-            PlatformDependent.putIntOrdered(kTailAddress, tail); // release memory barrier\n-            int ret = Native.ioUringEnter(ringFd, submit, 0, 0);\n-            head = PlatformDependent.getIntVolatile(kHeadAddress); // acquire memory barrier\n-            if (ret != submit) {\n-                if (ret < 0) {\n-                    throw new RuntimeException(\"ioUringEnter syscall\");\n-                }\n-                logger.warn(\"Not all submissions succeeded\");\n+            submit(submit, 0, 0);\n+        }\n+    }\n+\n+    public void submitAndWait() {\n+        int submit = tail - head;\n+        if (submit > 0) {\n+            submit(submit, 1, Native.IORING_ENTER_GETEVENTS);\n+        } else {\n+            int ret = Native.ioUringEnter(ringFd, 0, 1, Native.IORING_ENTER_GETEVENTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4NjU4Mg==", "bodyText": "I think that would entail a nasty bug but I guess it wouldn't harm to check.", "url": "https://github.com/netty/netty/pull/10542#discussion_r487086582", "createdAt": "2020-09-11T14:34:08Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -188,17 +188,33 @@ public boolean addClose(int fd) {\n     public void submit() {\n         int submit = tail - head;\n         if (submit > 0) {\n-            PlatformDependent.putIntOrdered(kTailAddress, tail); // release memory barrier\n-            int ret = Native.ioUringEnter(ringFd, submit, 0, 0);\n-            head = PlatformDependent.getIntVolatile(kHeadAddress); // acquire memory barrier\n-            if (ret != submit) {\n-                if (ret < 0) {\n-                    throw new RuntimeException(\"ioUringEnter syscall\");\n-                }\n-                logger.warn(\"Not all submissions succeeded\");\n+            submit(submit, 0, 0);\n+        }\n+    }\n+\n+    public void submitAndWait() {\n+        int submit = tail - head;\n+        if (submit > 0) {\n+            submit(submit, 1, Native.IORING_ENTER_GETEVENTS);\n+        } else {\n+            int ret = Native.ioUringEnter(ringFd, 0, 1, Native.IORING_ENTER_GETEVENTS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEwMjUwMQ==", "bodyText": "On second thoughts I don't think there's really a need to \"guard\" for this here, since we still take the \"correct\" action i.e. don't submit and wait for completions. But I will add a check to where we trigger submit when the SQ ring is full, since if for some reason that returns 0 we should not move to the next SQE slot.", "url": "https://github.com/netty/netty/pull/10542#discussion_r487102501", "createdAt": "2020-09-11T14:57:03Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -188,17 +188,33 @@ public boolean addClose(int fd) {\n     public void submit() {\n         int submit = tail - head;\n         if (submit > 0) {\n-            PlatformDependent.putIntOrdered(kTailAddress, tail); // release memory barrier\n-            int ret = Native.ioUringEnter(ringFd, submit, 0, 0);\n-            head = PlatformDependent.getIntVolatile(kHeadAddress); // acquire memory barrier\n-            if (ret != submit) {\n-                if (ret < 0) {\n-                    throw new RuntimeException(\"ioUringEnter syscall\");\n-                }\n-                logger.warn(\"Not all submissions succeeded\");\n+            submit(submit, 0, 0);\n+        }\n+    }\n+\n+    public void submitAndWait() {\n+        int submit = tail - head;\n+        if (submit > 0) {\n+            submit(submit, 1, Native.IORING_ENTER_GETEVENTS);\n+        } else {\n+            int ret = Native.ioUringEnter(ringFd, 0, 1, Native.IORING_ENTER_GETEVENTS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMDE2MQ==", "bodyText": "Yeah, that's my thinking. The dance seems unnecessary, but I'm not entirely certain. Things like overflow is hard to reason about.", "url": "https://github.com/netty/netty/pull/10542#discussion_r487110161", "createdAt": "2020-09-11T15:09:18Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -188,17 +188,33 @@ public boolean addClose(int fd) {\n     public void submit() {\n         int submit = tail - head;\n         if (submit > 0) {\n-            PlatformDependent.putIntOrdered(kTailAddress, tail); // release memory barrier\n-            int ret = Native.ioUringEnter(ringFd, submit, 0, 0);\n-            head = PlatformDependent.getIntVolatile(kHeadAddress); // acquire memory barrier\n-            if (ret != submit) {\n-                if (ret < 0) {\n-                    throw new RuntimeException(\"ioUringEnter syscall\");\n-                }\n-                logger.warn(\"Not all submissions succeeded\");\n+            submit(submit, 0, 0);\n+        }\n+    }\n+\n+    public void submitAndWait() {\n+        int submit = tail - head;\n+        if (submit > 0) {\n+            submit(submit, 1, Native.IORING_ENTER_GETEVENTS);\n+        } else {\n+            int ret = Native.ioUringEnter(ringFd, 0, 1, Native.IORING_ENTER_GETEVENTS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1OTkwNA==", "bodyText": "Good candidate for assert?", "url": "https://github.com/netty/netty/pull/10542#discussion_r487159904", "createdAt": "2020-09-11T16:35:34Z", "author": {"login": "johnou"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -188,17 +188,33 @@ public boolean addClose(int fd) {\n     public void submit() {\n         int submit = tail - head;\n         if (submit > 0) {\n-            PlatformDependent.putIntOrdered(kTailAddress, tail); // release memory barrier\n-            int ret = Native.ioUringEnter(ringFd, submit, 0, 0);\n-            head = PlatformDependent.getIntVolatile(kHeadAddress); // acquire memory barrier\n-            if (ret != submit) {\n-                if (ret < 0) {\n-                    throw new RuntimeException(\"ioUringEnter syscall\");\n-                }\n-                logger.warn(\"Not all submissions succeeded\");\n+            submit(submit, 0, 0);\n+        }\n+    }\n+\n+    public void submitAndWait() {\n+        int submit = tail - head;\n+        if (submit > 0) {\n+            submit(submit, 1, Native.IORING_ENTER_GETEVENTS);\n+        } else {\n+            int ret = Native.ioUringEnter(ringFd, 0, 1, Native.IORING_ENTER_GETEVENTS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzY0NTIwOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxODoyNDowM1rOHQpQyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxOToxNjowOVrOHQqyBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw==", "bodyText": "Hmm it\u2019s kind of odd to expose a package-private class in a public method imho", "url": "https://github.com/netty/netty/pull/10542#discussion_r487215307", "createdAt": "2020-09-11T18:24:03Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -163,6 +163,11 @@ public FileDescriptor fd() {\n     @Override\n     protected abstract AbstractUringUnsafe newUnsafe();\n \n+    @Override\n+    public AbstractUringUnsafe unsafe() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIyMjA0OA==", "bodyText": "@normanmaurer sure I can revert this if you prefer. I don't think it's really exposed though since the AbstractIOUringChannel class itself is also package-private. So anyone calling from outside would be operating on the superclass version of it anyhow which returns Unsafe and so would not see or be aware of this... wdyt?", "url": "https://github.com/netty/netty/pull/10542#discussion_r487222048", "createdAt": "2020-09-11T18:38:05Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -163,6 +163,11 @@ public FileDescriptor fd() {\n     @Override\n     protected abstract AbstractUringUnsafe newUnsafe();\n \n+    @Override\n+    public AbstractUringUnsafe unsafe() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw=="}, "originalCommit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIyODI3Nw==", "bodyText": "... or could add a separate package-private ioUringUnsafe() method if you think that's better? Just seems preferable to casting everywhere", "url": "https://github.com/netty/netty/pull/10542#discussion_r487228277", "createdAt": "2020-09-11T18:51:21Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -163,6 +163,11 @@ public FileDescriptor fd() {\n     @Override\n     protected abstract AbstractUringUnsafe newUnsafe();\n \n+    @Override\n+    public AbstractUringUnsafe unsafe() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw=="}, "originalCommit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIyOTgxMw==", "bodyText": "Yeah let\u2019s do that", "url": "https://github.com/netty/netty/pull/10542#discussion_r487229813", "createdAt": "2020-09-11T18:54:45Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -163,6 +163,11 @@ public FileDescriptor fd() {\n     @Override\n     protected abstract AbstractUringUnsafe newUnsafe();\n \n+    @Override\n+    public AbstractUringUnsafe unsafe() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw=="}, "originalCommit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI0MDE5Ng==", "bodyText": "done", "url": "https://github.com/netty/netty/pull/10542#discussion_r487240196", "createdAt": "2020-09-11T19:16:09Z", "author": {"login": "njhill"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -163,6 +163,11 @@ public FileDescriptor fd() {\n     @Override\n     protected abstract AbstractUringUnsafe newUnsafe();\n \n+    @Override\n+    public AbstractUringUnsafe unsafe() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw=="}, "originalCommit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzY1NTc0OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxODoyNzowNFrOHQpXKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMDoyMjowMVrOHQ0Nog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNjkzOQ==", "bodyText": "Just as a followup we should better access the fields directly from JNI as calling methods is expensive", "url": "https://github.com/netty/netty/pull/10542#discussion_r487216939", "createdAt": "2020-09-11T18:27:04Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -231,6 +250,8 @@ public void release() {\n         PlatformDependent.freeMemory(timeoutMemoryAddress);\n     }\n \n+    // The getters below are called from JNI code\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5NDcyMg==", "bodyText": "@normanmaurer I think it shouldn't be big issue as the methods are called when we close the RingBuffer, however it would be cleaner to access the fields directly, I'll create followup PR today", "url": "https://github.com/netty/netty/pull/10542#discussion_r487394722", "createdAt": "2020-09-12T10:22:01Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -231,6 +250,8 @@ public void release() {\n         PlatformDependent.freeMemory(timeoutMemoryAddress);\n     }\n \n+    // The getters below are called from JNI code\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNjkzOQ=="}, "originalCommit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3707, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}