{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5MzI4NTk4", "number": 10588, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODo1MDo0NFrOElNZNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzo1ODowM1rOEmM6Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NDUyMjE1OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODo1MDo0NFrOHUkyZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODo1MDo0NFrOHUkyZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMzNjI5NQ==", "bodyText": "nit: Copyright 2020", "url": "https://github.com/netty/netty/pull/10588#discussion_r491336295", "createdAt": "2020-09-19T08:50:44Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Copyright 2014 The Netty Project", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a453c50120306ef72ef369ab0e8ce96a32a20"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NDUyMzUxOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannelConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODo1MToyMFrOHUkzSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODo1MToyMFrOHUkzSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMzNjUyMg==", "bodyText": "nit: 2020", "url": "https://github.com/netty/netty/pull/10588#discussion_r491336522", "createdAt": "2020-09-19T08:51:20Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannelConfig.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/*\n+ * Copyright 2012 The Netty Project", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a453c50120306ef72ef369ab0e8ce96a32a20"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDc4NDE5OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/Iov.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzoyMDoyMVrOHWEnNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzoyMDoyMVrOHWEnNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkwNjI5Mg==", "bodyText": "I think size_t and void* usually have the same size, and it looks like we intend to support 32-bit platforms.", "url": "https://github.com/netty/netty/pull/10588#discussion_r492906292", "createdAt": "2020-09-22T17:20:21Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/Iov.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.util.internal.PlatformDependent;\n+\n+final class Iov {\n+\n+    private Iov() { }\n+\n+    static void write(long iovAddress, long bufferAddress, int length) {\n+        PlatformDependent.putLong(iovAddress + Native.IOVEC_OFFSETOF_IOV_BASE, bufferAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c188e697e14f8b8e2573ebb7c0501b673155d0d0"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDc4ODcyOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/MsgHdr.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzoyMToyNVrOHWEp4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzoyMToyNVrOHWEp4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkwNjk3OA==", "bodyText": "I really like that we have a copy of the struct we're modelling, in the javadoc. We could do that for Iov as well.", "url": "https://github.com/netty/netty/pull/10588#discussion_r492906978", "createdAt": "2020-09-22T17:21:25Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/MsgHdr.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.util.internal.PlatformDependent;\n+\n+/**\n+ * struct msghdr {\n+ *     void         *msg_name;       // optional address\n+ *     socklen_t    msg_namelen;     // size of address\n+ *     struct       iovec*msg_iov;   // scatter/gather array\n+ *     size_t       msg_iovlen;      // # elements in msg_iov\n+ *     void*        msg_control;     // ancillary data, see below\n+ *     size_t       msg_controllen;  // ancillary data buffer len\n+ *     int          msg_flags;       // flags on received message\n+ * };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c188e697e14f8b8e2573ebb7c0501b673155d0d0"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NDkyODQzOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzo1ODowM1rOHWGATw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjoxODozMFrOHWX77w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkyOTEwMw==", "bodyText": "Why is this necessary? It's only called from doDisconnect after the socket is closed?", "url": "https://github.com/netty/netty/pull/10588#discussion_r492929103", "createdAt": "2020-09-22T17:58:03Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -286,56 +282,53 @@ private void scheduleWrite(ChannelOutboundBuffer in) {\n         if (msgCount == 0) {\n             return;\n         }\n-        ByteBuf msg = (ByteBuf) in.current();\n-        if (msgCount > 1 ||\n-                // We also need some special handling for CompositeByteBuf\n-                msg.nioBufferCount() > 1) {\n-            doWriteMultiple(in);\n-        } else if (msgCount == 1) {\n-            doWriteSingle(msg);\n-        }\n-    }\n-\n-     private void doWriteMultiple(ChannelOutboundBuffer in) {\n-         final IovArray iovecArray = ((IOUringEventLoop) eventLoop()).iovArray();\n-         try {\n-             int offset = iovecArray.count();\n-             in.forEachFlushedMessage(iovecArray);\n-             submissionQueue().addWritev(socket.intValue(),\n-                     iovecArray.memoryAddress(offset), iovecArray.count() - offset);\n-             ioState |= WRITE_SCHEDULED;\n-         } catch (Exception e) {\n-             // This should never happen, anyway fallback to single write.\n-             doWriteSingle((ByteBuf) in.current());\n-         }\n-     }\n-\n-    protected final void doWriteSingle(ByteBuf buf) {\n+        Object msg = in.current();\n+\n         assert (ioState & WRITE_SCHEDULED) == 0;\n-        IOUringSubmissionQueue submissionQueue = submissionQueue();\n-        submissionQueue.addWrite(socket.intValue(), buf.memoryAddress(), buf.readerIndex(),\n-                buf.writerIndex());\n+        if (msgCount > 1) {\n+            ioUringUnsafe().scheduleWriteMultiple(in);\n+        } else if ((msg instanceof ByteBuf) && ((ByteBuf) msg).nioBufferCount() > 1 ||\n+                    ((msg instanceof ByteBufHolder) && ((ByteBufHolder) msg).content().nioBufferCount() > 1)) {\n+            // We also need some special handling for CompositeByteBuf\n+            ioUringUnsafe().scheduleWriteMultiple(in);\n+        } else {\n+            ioUringUnsafe().scheduleWriteSingle(msg);\n+        }\n         ioState |= WRITE_SCHEDULED;\n     }\n \n-    //POLLOUT\n     private void schedulePollOut() {\n         assert (ioState & POLL_OUT_SCHEDULED) == 0;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addPollOut(socket.intValue());\n         ioState |= POLL_OUT_SCHEDULED;\n     }\n \n-    void schedulePollRdHup() {\n+    final void schedulePollRdHup() {\n         assert (ioState & POLL_RDHUP_SCHEDULED) == 0;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addPollRdHup(fd().intValue());\n         ioState |= POLL_RDHUP_SCHEDULED;\n     }\n \n+    final void resetCachedAddresses() {\n+        local = socket.localAddress();\n+        remote = socket.remoteAddress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c188e697e14f8b8e2573ebb7c0501b673155d0d0"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMjg5NQ==", "bodyText": "with datagram there is a difference between close and disconnect. It's possible that a datagram fd is connected / disconnected multiple times without closing the underlying fd. Thats why we need to reset the cached addresses.", "url": "https://github.com/netty/netty/pull/10588#discussion_r493222895", "createdAt": "2020-09-23T06:18:30Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -286,56 +282,53 @@ private void scheduleWrite(ChannelOutboundBuffer in) {\n         if (msgCount == 0) {\n             return;\n         }\n-        ByteBuf msg = (ByteBuf) in.current();\n-        if (msgCount > 1 ||\n-                // We also need some special handling for CompositeByteBuf\n-                msg.nioBufferCount() > 1) {\n-            doWriteMultiple(in);\n-        } else if (msgCount == 1) {\n-            doWriteSingle(msg);\n-        }\n-    }\n-\n-     private void doWriteMultiple(ChannelOutboundBuffer in) {\n-         final IovArray iovecArray = ((IOUringEventLoop) eventLoop()).iovArray();\n-         try {\n-             int offset = iovecArray.count();\n-             in.forEachFlushedMessage(iovecArray);\n-             submissionQueue().addWritev(socket.intValue(),\n-                     iovecArray.memoryAddress(offset), iovecArray.count() - offset);\n-             ioState |= WRITE_SCHEDULED;\n-         } catch (Exception e) {\n-             // This should never happen, anyway fallback to single write.\n-             doWriteSingle((ByteBuf) in.current());\n-         }\n-     }\n-\n-    protected final void doWriteSingle(ByteBuf buf) {\n+        Object msg = in.current();\n+\n         assert (ioState & WRITE_SCHEDULED) == 0;\n-        IOUringSubmissionQueue submissionQueue = submissionQueue();\n-        submissionQueue.addWrite(socket.intValue(), buf.memoryAddress(), buf.readerIndex(),\n-                buf.writerIndex());\n+        if (msgCount > 1) {\n+            ioUringUnsafe().scheduleWriteMultiple(in);\n+        } else if ((msg instanceof ByteBuf) && ((ByteBuf) msg).nioBufferCount() > 1 ||\n+                    ((msg instanceof ByteBufHolder) && ((ByteBufHolder) msg).content().nioBufferCount() > 1)) {\n+            // We also need some special handling for CompositeByteBuf\n+            ioUringUnsafe().scheduleWriteMultiple(in);\n+        } else {\n+            ioUringUnsafe().scheduleWriteSingle(msg);\n+        }\n         ioState |= WRITE_SCHEDULED;\n     }\n \n-    //POLLOUT\n     private void schedulePollOut() {\n         assert (ioState & POLL_OUT_SCHEDULED) == 0;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addPollOut(socket.intValue());\n         ioState |= POLL_OUT_SCHEDULED;\n     }\n \n-    void schedulePollRdHup() {\n+    final void schedulePollRdHup() {\n         assert (ioState & POLL_RDHUP_SCHEDULED) == 0;\n         IOUringSubmissionQueue submissionQueue = submissionQueue();\n         submissionQueue.addPollRdHup(fd().intValue());\n         ioState |= POLL_RDHUP_SCHEDULED;\n     }\n \n+    final void resetCachedAddresses() {\n+        local = socket.localAddress();\n+        remote = socket.remoteAddress();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkyOTEwMw=="}, "originalCommit": {"oid": "c188e697e14f8b8e2573ebb7c0501b673155d0d0"}, "originalPosition": 99}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3765, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}