{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5NTM0OTY5", "number": 10221, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDozMzoyMVrOD2t19g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDozMzoyMVrOD2t19g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzAwNzkwOnYy", "diffSide": "RIGHT", "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDozMzoyMVrOGMmYFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNTo1NjozNFrOGMq0rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2NDg1Mg==", "bodyText": "Just code style, so not necessary: I would pack this \"uncommon case\" in a separate method", "url": "https://github.com/netty/netty/pull/10221#discussion_r415864852", "createdAt": "2020-04-27T14:33:21Z", "author": {"login": "franz1981"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -276,15 +276,48 @@ private static String hostnameWithDot(String name) {\n         return name + '.';\n     }\n \n-    private void internalResolve(String name, Promise<List<T>> promise) {\n-        for (;;) {\n-            // Resolve from cnameCache() until there is no more cname entry cached.\n-            String mapping = cnameCache().get(hostnameWithDot(name));\n-            if (mapping == null) {\n+    // Resolve the final name from the CNAME cache until there is nothing to follow anymore. This also\n+    // guards against loops in the cache but early return once a loop is detected.\n+    private String cnameResolveFromCache(String name) {\n+        DnsCnameCache cnameCache = cnameCache();\n+        String first = cnameCache.get(hostnameWithDot(name));\n+        if (first == null) {\n+            // Nothing in the cache at all\n+            return name;\n+        }\n+\n+        String mapping = cnameCache.get(hostnameWithDot(first));\n+        if (mapping == null) {\n+            // Nothing else to follow, return first match.\n+            return first;\n+        }\n+\n+        if (first.equals(mapping)) {\n+            // Loop detected.... early return.\n+            return first;\n+        }\n+\n+        // Detect loops using a HashSet. We use this as last resort implementation to reduce allocations in the most", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d28b37a1195a2760f49e4dd3b011a3b59b005eb"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkzNzcwOQ==", "bodyText": "@franz1981 done... PTAL again", "url": "https://github.com/netty/netty/pull/10221#discussion_r415937709", "createdAt": "2020-04-27T15:56:34Z", "author": {"login": "normanmaurer"}, "path": "resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java", "diffHunk": "@@ -276,15 +276,48 @@ private static String hostnameWithDot(String name) {\n         return name + '.';\n     }\n \n-    private void internalResolve(String name, Promise<List<T>> promise) {\n-        for (;;) {\n-            // Resolve from cnameCache() until there is no more cname entry cached.\n-            String mapping = cnameCache().get(hostnameWithDot(name));\n-            if (mapping == null) {\n+    // Resolve the final name from the CNAME cache until there is nothing to follow anymore. This also\n+    // guards against loops in the cache but early return once a loop is detected.\n+    private String cnameResolveFromCache(String name) {\n+        DnsCnameCache cnameCache = cnameCache();\n+        String first = cnameCache.get(hostnameWithDot(name));\n+        if (first == null) {\n+            // Nothing in the cache at all\n+            return name;\n+        }\n+\n+        String mapping = cnameCache.get(hostnameWithDot(first));\n+        if (mapping == null) {\n+            // Nothing else to follow, return first match.\n+            return first;\n+        }\n+\n+        if (first.equals(mapping)) {\n+            // Loop detected.... early return.\n+            return first;\n+        }\n+\n+        // Detect loops using a HashSet. We use this as last resort implementation to reduce allocations in the most", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2NDg1Mg=="}, "originalCommit": {"oid": "7d28b37a1195a2760f49e4dd3b011a3b59b005eb"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3416, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}