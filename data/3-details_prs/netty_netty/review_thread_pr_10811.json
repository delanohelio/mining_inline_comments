{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1MTQ1MzYw", "number": 10811, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDozOTowN1rOE8KHnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDozOTowN1rOE8KHnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNTE1ODA0OnYy", "diffSide": "RIGHT", "path": "transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDozOTowN1rOH4HuEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzozOToyMlrOH4N12A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwODc4Ng==", "bodyText": "using reflection will not really work with Java9+. So I think we need to come up with something different here.", "url": "https://github.com/netty/netty/pull/10811#discussion_r528608786", "createdAt": "2020-11-23T10:39:07Z", "author": {"login": "normanmaurer"}, "path": "transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java", "diffHunk": "@@ -127,6 +130,50 @@ private static void testEventExecutorTakeTask(EventExecutor eventExecutor) throw\n         latch.await();\n     }\n \n+    @Test(timeout = 5000L)\n+    public void testGlobalEventExecutorAddTask() throws Exception {\n+        testEventExecutorAddTask(GlobalEventExecutor.INSTANCE, GlobalEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    @Test(timeout = 5000L)\n+    public void testSingleThreadEventExecutorAddTask() throws Exception {\n+        SingleThreadEventExecutor executor =\n+                new SingleThreadEventExecutor(null, new DefaultThreadFactory(\"test\"), true) {\n+                    @Override\n+                    protected void run() {\n+                        while (!confirmShutdown()) {\n+                            Runnable task = takeTask();\n+                            if (task != null) {\n+                                task.run();\n+                            }\n+                        }\n+                    }\n+                };\n+        testEventExecutorAddTask(executor, SingleThreadEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    private void testEventExecutorAddTask(EventExecutor executor, Field taskQueueField) throws Exception {\n+        // artificially acquire taskQueue.putLock\n+        taskQueueField.setAccessible(true);\n+        LinkedBlockingQueue<?> taskQueue = (LinkedBlockingQueue<?>) taskQueueField.get(executor);\n+        Field putLockField = LinkedBlockingQueue.class.getDeclaredField(\"putLock\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df3a1e0727989df4be9f777394232a2a10128982"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY0NDA5OQ==", "bodyText": "That might be impossible I'm afraid, but I'll investigate. I think that's why 09d38c8 did not introduce any test for this.", "url": "https://github.com/netty/netty/pull/10811#discussion_r528644099", "createdAt": "2020-11-23T11:44:01Z", "author": {"login": "adutra"}, "path": "transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java", "diffHunk": "@@ -127,6 +130,50 @@ private static void testEventExecutorTakeTask(EventExecutor eventExecutor) throw\n         latch.await();\n     }\n \n+    @Test(timeout = 5000L)\n+    public void testGlobalEventExecutorAddTask() throws Exception {\n+        testEventExecutorAddTask(GlobalEventExecutor.INSTANCE, GlobalEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    @Test(timeout = 5000L)\n+    public void testSingleThreadEventExecutorAddTask() throws Exception {\n+        SingleThreadEventExecutor executor =\n+                new SingleThreadEventExecutor(null, new DefaultThreadFactory(\"test\"), true) {\n+                    @Override\n+                    protected void run() {\n+                        while (!confirmShutdown()) {\n+                            Runnable task = takeTask();\n+                            if (task != null) {\n+                                task.run();\n+                            }\n+                        }\n+                    }\n+                };\n+        testEventExecutorAddTask(executor, SingleThreadEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    private void testEventExecutorAddTask(EventExecutor executor, Field taskQueueField) throws Exception {\n+        // artificially acquire taskQueue.putLock\n+        taskQueueField.setAccessible(true);\n+        LinkedBlockingQueue<?> taskQueue = (LinkedBlockingQueue<?>) taskQueueField.get(executor);\n+        Field putLockField = LinkedBlockingQueue.class.getDeclaredField(\"putLock\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwODc4Ng=="}, "originalCommit": {"oid": "df3a1e0727989df4be9f777394232a2a10128982"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY0NjIxMg==", "bodyText": "If thats the case then we may need to bite the bullet and just remove the test.", "url": "https://github.com/netty/netty/pull/10811#discussion_r528646212", "createdAt": "2020-11-23T11:47:59Z", "author": {"login": "normanmaurer"}, "path": "transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java", "diffHunk": "@@ -127,6 +130,50 @@ private static void testEventExecutorTakeTask(EventExecutor eventExecutor) throw\n         latch.await();\n     }\n \n+    @Test(timeout = 5000L)\n+    public void testGlobalEventExecutorAddTask() throws Exception {\n+        testEventExecutorAddTask(GlobalEventExecutor.INSTANCE, GlobalEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    @Test(timeout = 5000L)\n+    public void testSingleThreadEventExecutorAddTask() throws Exception {\n+        SingleThreadEventExecutor executor =\n+                new SingleThreadEventExecutor(null, new DefaultThreadFactory(\"test\"), true) {\n+                    @Override\n+                    protected void run() {\n+                        while (!confirmShutdown()) {\n+                            Runnable task = takeTask();\n+                            if (task != null) {\n+                                task.run();\n+                            }\n+                        }\n+                    }\n+                };\n+        testEventExecutorAddTask(executor, SingleThreadEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    private void testEventExecutorAddTask(EventExecutor executor, Field taskQueueField) throws Exception {\n+        // artificially acquire taskQueue.putLock\n+        taskQueueField.setAccessible(true);\n+        LinkedBlockingQueue<?> taskQueue = (LinkedBlockingQueue<?>) taskQueueField.get(executor);\n+        Field putLockField = LinkedBlockingQueue.class.getDeclaredField(\"putLock\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwODc4Ng=="}, "originalCommit": {"oid": "df3a1e0727989df4be9f777394232a2a10128982"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcwOTA4MA==", "bodyText": "I came up with a little something that works for SingleThreadEventExecutor, but not for GlobalEventExecutor. So I suggest that we leave GlobalEventExecutor untested. Let me know if it's looking better this way.", "url": "https://github.com/netty/netty/pull/10811#discussion_r528709080", "createdAt": "2020-11-23T13:39:22Z", "author": {"login": "adutra"}, "path": "transport-blockhound-tests/src/test/java/io/netty/util/internal/NettyBlockHoundIntegrationTest.java", "diffHunk": "@@ -127,6 +130,50 @@ private static void testEventExecutorTakeTask(EventExecutor eventExecutor) throw\n         latch.await();\n     }\n \n+    @Test(timeout = 5000L)\n+    public void testGlobalEventExecutorAddTask() throws Exception {\n+        testEventExecutorAddTask(GlobalEventExecutor.INSTANCE, GlobalEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    @Test(timeout = 5000L)\n+    public void testSingleThreadEventExecutorAddTask() throws Exception {\n+        SingleThreadEventExecutor executor =\n+                new SingleThreadEventExecutor(null, new DefaultThreadFactory(\"test\"), true) {\n+                    @Override\n+                    protected void run() {\n+                        while (!confirmShutdown()) {\n+                            Runnable task = takeTask();\n+                            if (task != null) {\n+                                task.run();\n+                            }\n+                        }\n+                    }\n+                };\n+        testEventExecutorAddTask(executor, SingleThreadEventExecutor.class.getDeclaredField(\"taskQueue\"));\n+    }\n+\n+    private void testEventExecutorAddTask(EventExecutor executor, Field taskQueueField) throws Exception {\n+        // artificially acquire taskQueue.putLock\n+        taskQueueField.setAccessible(true);\n+        LinkedBlockingQueue<?> taskQueue = (LinkedBlockingQueue<?>) taskQueueField.get(executor);\n+        Field putLockField = LinkedBlockingQueue.class.getDeclaredField(\"putLock\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwODc4Ng=="}, "originalCommit": {"oid": "df3a1e0727989df4be9f777394232a2a10128982"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3543, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}