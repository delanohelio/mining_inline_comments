{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxODk1MzY3", "number": 10549, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTowMzo0MlrOEhJtyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMzozNjowOVrOEhQCyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTk3NjQwOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTowMzo0MlrOHOTttA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTowMzo0MlrOHOTttA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2NTEwOA==", "bodyText": "happem", "url": "https://github.com/netty/netty/pull/10549#discussion_r484765108", "createdAt": "2020-09-08T09:03:42Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -304,23 +302,17 @@ protected void doWrite(ChannelOutboundBuffer in) {\n     }\n \n      private void doWriteMultiple(ChannelOutboundBuffer in) {\n-\n-         final IovecArrayPool iovecArray = ((IOUringEventLoop) eventLoop()).getIovecArrayPool();\n-\n-         iovecMemoryAddress = iovecArray.createNewIovecMemoryAddress();\n-         if (iovecMemoryAddress != -1) {\n-             try {\n-                 in.forEachFlushedMessage(iovecArray);\n-             } catch (Exception e) {\n-                 // This should never happem, anyway fallback to single write.\n-                 doWriteSingle((ByteBuf) in.current());\n-             }\n-             submissionQueue().addWritev(socket.intValue(), iovecMemoryAddress, iovecArray.count());\n+         final IovArray iovecArray = ((IOUringEventLoop) eventLoop()).iovArray();\n+         try {\n+             int offset = iovecArray.count();\n+             in.forEachFlushedMessage(iovecArray);\n+             submissionQueue().addWritev(socket.intValue(), iovecArray.memoryAddress(offset), iovecArray.count() - offset);\n              ioState |= WRITE_SCHEDULED;\n-         } else {\n-             // We were not be able to create a new iovec, fallback to single write.\n+         } catch (Exception e) {\n+             // This should never happem, anyway fallback to single write.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67d9e4c006002dd39388cd1a2871a340c2ae7e03"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMjA3Mzg1OnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOToyOToxMVrOHOUqRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMDo1OTo1OFrOHOXwFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4MDYxMw==", "bodyText": "one drawback would be that we reduce submission batch size when a lot of channel writing in the same time especially with a bigger message size, one solution would be: to make the capacity configurable, default iovec array size is only 1024 as far as I know", "url": "https://github.com/netty/netty/pull/10549#discussion_r484780613", "createdAt": "2020-09-08T09:29:11Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -268,7 +278,12 @@ protected void wakeup(boolean inEventLoop) {\n         }\n     }\n \n-    public IovecArrayPool getIovecArrayPool() {\n-        return iovecArrayPool;\n+    public IovArray iovArray() {\n+        // Check if its full and if so submit so we can reuse it.\n+        if (iovArray.isFull()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67d9e4c006002dd39388cd1a2871a340c2ae7e03"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzMTI1Mw==", "bodyText": "yep I am aware of this... thats why I added some \"we may want to adjust this later comment\"... That said let me run some benchmarks for now first", "url": "https://github.com/netty/netty/pull/10549#discussion_r484831253", "createdAt": "2020-09-08T10:59:58Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -268,7 +278,12 @@ protected void wakeup(boolean inEventLoop) {\n         }\n     }\n \n-    public IovecArrayPool getIovecArrayPool() {\n-        return iovecArrayPool;\n+    public IovArray iovArray() {\n+        // Check if its full and if so submit so we can reuse it.\n+        if (iovArray.isFull()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4MDYxMw=="}, "originalCommit": {"oid": "67d9e4c006002dd39388cd1a2871a340c2ae7e03"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMzAxMzIwOnYy", "diffSide": "RIGHT", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMzozNjowOVrOHOdhSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNToyMDoyM1rOHOiT-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyNTc2OQ==", "bodyText": "we could even make this more optimal by writing a custom IovArray implementation. But for now this seems to work well enough and allows us for code-reuse.", "url": "https://github.com/netty/netty/pull/10549#discussion_r484925769", "createdAt": "2020-09-08T13:36:09Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -46,18 +47,26 @@\n     //    other value T    when EL is waiting with wakeup scheduled at time T\n     private final AtomicLong nextWakeupNanos = new AtomicLong(AWAKE);\n     private final FileDescriptor eventfd;\n-    private final IovecArrayPool iovecArrayPool;\n+\n+    private final IovArray[] iovArrays;\n+    private int iovArrayIdx;\n \n     private long prevDeadlineNanos = NONE;\n     private boolean pendingWakeup;\n \n     IOUringEventLoop(final EventLoopGroup parent, final Executor executor, final boolean addTaskWakesUp) {\n         super(parent, executor, addTaskWakesUp);\n+        // Ensure that we load all native bits as otherwise it may fail when try to use native methods in IovArray\n+        IOUring.ensureAvailability();\n \n+        // Let's hard code this to 8 IovArrays to keep the memory overhead kind of small.\n+        iovArrays = new IovArray[8];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75ef1d74c4ad317778a731247ca68674f8976128"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAwNDI4MA==", "bodyText": "I like that, 8 we should take it as default value when it's configurable", "url": "https://github.com/netty/netty/pull/10549#discussion_r485004280", "createdAt": "2020-09-08T15:20:23Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -46,18 +47,26 @@\n     //    other value T    when EL is waiting with wakeup scheduled at time T\n     private final AtomicLong nextWakeupNanos = new AtomicLong(AWAKE);\n     private final FileDescriptor eventfd;\n-    private final IovecArrayPool iovecArrayPool;\n+\n+    private final IovArray[] iovArrays;\n+    private int iovArrayIdx;\n \n     private long prevDeadlineNanos = NONE;\n     private boolean pendingWakeup;\n \n     IOUringEventLoop(final EventLoopGroup parent, final Executor executor, final boolean addTaskWakesUp) {\n         super(parent, executor, addTaskWakesUp);\n+        // Ensure that we load all native bits as otherwise it may fail when try to use native methods in IovArray\n+        IOUring.ensureAvailability();\n \n+        // Let's hard code this to 8 IovArrays to keep the memory overhead kind of small.\n+        iovArrays = new IovArray[8];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkyNTc2OQ=="}, "originalCommit": {"oid": "75ef1d74c4ad317778a731247ca68674f8976128"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3716, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}