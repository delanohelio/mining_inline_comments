{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1Mzg4MTMx", "number": 9960, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjozMDoxN1rODZjmLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjozMDoxN1rODZjmLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTI0MjA3OnYy", "diffSide": "RIGHT", "path": "handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjozMDoxN1rOFgAiAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNjozMDoxN1rOFgAiAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNzQ1Ng==", "bodyText": "\u2764\ufe0f", "url": "https://github.com/netty/netty/pull/9960#discussion_r369107456", "createdAt": "2020-01-21T16:30:17Z", "author": {"login": "franz1981"}, "path": "handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java", "diffHunk": "@@ -261,61 +261,39 @@ private void doFlush(final ChannelHandlerContext ctx) {\n                     message = Unpooled.EMPTY_BUFFER;\n                 }\n \n-                ChannelFuture f = ctx.write(message);\n+                // Flush each chunk to conserve memory\n+                ChannelFuture f = ctx.writeAndFlush(message);\n                 if (endOfInput) {\n                     queue.remove();\n \n-                    // Register a listener which will close the input once the write is complete.\n-                    // This is needed because the Chunk may have some resource bound that can not\n-                    // be closed before its not written.\n-                    //\n-                    // See https://github.com/netty/netty/issues/303\n-                    f.addListener(new ChannelFutureListener() {\n-                        @Override\n-                        public void operationComplete(ChannelFuture future) throws Exception {\n-                            if (!future.isSuccess()) {\n-                                closeInput(chunks);\n-                                currentWrite.fail(future.cause());\n-                            } else {\n-                                // read state of the input in local variables before closing it\n-                                long inputProgress = chunks.progress();\n-                                long inputLength = chunks.length();\n-                                closeInput(chunks);\n-                                currentWrite.progress(inputProgress, inputLength);\n-                                currentWrite.success(inputLength);\n-                            }\n-                        }\n-                    });\n-                } else if (channel.isWritable()) {\n-                    f.addListener(new ChannelFutureListener() {\n-                        @Override\n-                        public void operationComplete(ChannelFuture future) throws Exception {\n-                            if (!future.isSuccess()) {\n-                                closeInput(chunks);\n-                                currentWrite.fail(future.cause());\n-                            } else {\n-                                currentWrite.progress(chunks.progress(), chunks.length());\n+                    if (f.isDone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97a5839fb07f42f7ba001135e70f34cb87cb4449"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3535, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}