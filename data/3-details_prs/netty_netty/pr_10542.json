{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxNjE0NTcx", "number": 10542, "title": "Further reduce io_uring syscalls", "bodyText": "Motivation\nIOUringEventLoop can be streamlined to further reduce io_uring_enter calls in some cases\nModification\n\nDon't prepare to block-wait until all available work is exhausted\nCombine submission with GETEVENTS\n\nResult\nHopefully faster", "createdAt": "2020-09-07T19:39:41Z", "url": "https://github.com/netty/netty/pull/10542", "merged": true, "mergeCommit": {"oid": "907a71c9305b5b0248c7c22fec14c76881fb7a96"}, "closed": true, "closedAt": "2020-09-13T13:46:40Z", "author": {"login": "njhill"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdGyMtbgFqTQ4Mzg1MTQ4Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdIHtpAgFqTQ4NzIyMTczOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzODUxNDgz", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-483851483", "createdAt": "2020-09-08T07:09:55Z", "commit": {"oid": "e98e6640f1d2e4f48d4a3358542ff8903d5cf5e5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDI2MDI4", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-484426028", "createdAt": "2020-09-08T19:19:12Z", "commit": {"oid": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToxOToxM1rOHOqwFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToyMjo0MFrOHOq3lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjU1MA==", "bodyText": "It looks correct that we are getting the completion queue tail with volatile, but previously the volatile load was on the head. Can we have a double-check and justify to ourselves that this is right?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485142550", "createdAt": "2020-09-08T19:19:13Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,44 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0NDQ3MA==", "bodyText": "This can also be modelled as a do-while.", "url": "https://github.com/netty/netty/pull/10542#discussion_r485144470", "createdAt": "2020-09-08T19:22:40Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -110,9 +110,29 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n+            for (;;) {\n+                // avoid blocking for as long as possible\n+                completionQueue.process(this);\n+                boolean ranTasks = runAllTasks();\n+                if (!ranTasks) {\n+                    break;\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad"}, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e98e6640f1d2e4f48d4a3358542ff8903d5cf5e5", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/e98e6640f1d2e4f48d4a3358542ff8903d5cf5e5", "committedDate": "2020-09-05T16:58:42Z", "message": "Adjust inner event loop to better interleave task/completion processing"}, "afterCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/08cfa017a767924500c700bf16c120155673d054", "committedDate": "2020-09-08T20:32:59Z", "message": "Change to do/while per @chrisvest's suggestion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NzEwMTU2", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-484710156", "createdAt": "2020-09-09T06:54:45Z", "commit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjo1NDo0NVrOHO5NzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzowNzoyNVrOHO5ksQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3OTUzMg==", "bodyText": "I would make this volatile for clarity", "url": "https://github.com/netty/netty/pull/10542#discussion_r485379532", "createdAt": "2020-09-09T06:54:45Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MDEyOA==", "bodyText": "I assume cqe is entryAddress?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485380128", "createdAt": "2020-09-09T06:55:59Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqe = (ringHead & ringMask) * CQE_SIZE + completionQueueArrayAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTU4Ng==", "bodyText": "The completion queue is single consumer I assume, so this is fine. I would still split this into 2 lines.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      PlatformDependent.putIntOrdered(kHeadAddress, ++ringHead);\n          \n          \n            \n                      ringHead++;\n          \n          \n            \n                      PlatformDependent.putIntOrdered(kHeadAddress, ringHead);", "url": "https://github.com/netty/netty/pull/10542#discussion_r485381586", "createdAt": "2020-09-09T06:59:09Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqe = (ringHead & ringMask) * CQE_SIZE + completionQueueArrayAddress;\n+\n+          long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n+          int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n+          int flags = PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD);\n+\n+          //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n+          PlatformDependent.putIntOrdered(kHeadAddress, ++ringHead);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MjU2NA==", "bodyText": "This is not present in the new code?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485382564", "createdAt": "2020-09-09T07:01:10Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzczMw==", "bodyText": "should be &&?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485383733", "createdAt": "2020-09-09T07:03:46Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        boolean maybeMoreIo;\n          \n          \n            \n                        do {\n          \n          \n            \n                            maybeMoreIo = completionQueue.process(this) != 0;\n          \n          \n            \n                            if (!maybeMoreIo & !maybeMoreTasks) {\n          \n          \n            \n                                break; // no need to check tasks again here\n          \n          \n            \n                            }\n          \n          \n            \n                            maybeMoreTasks = runAllTasks();\n          \n          \n            \n                            try {\n          \n          \n            \n                                if (isShuttingDown()) {\n          \n          \n            \n                                    closeAll();\n          \n          \n            \n                                    if (confirmShutdown()) {\n          \n          \n            \n                                        return;\n          \n          \n            \n                                    }\n          \n          \n            \n                                }\n          \n          \n            \n                            } catch (Throwable t) {\n          \n          \n            \n                                logger.info(\"Exception error: {}\", t);\n          \n          \n            \n                            }\n          \n          \n            \n                        } while (maybeMoreIo | maybeMoreTasks);\n          \n          \n            \n                        boolean maybeMoreIo = completionQueue.process(this) != 0;\n          \n          \n            \n                        while (maybeMoreIo || maybeMoreTasks) {\n          \n          \n            \n                            maybeMoreTasks = runAllTasks();\n          \n          \n            \n                            try {\n          \n          \n            \n                                if (isShuttingDown()) {\n          \n          \n            \n                                    closeAll();\n          \n          \n            \n                                    if (confirmShutdown()) {\n          \n          \n            \n                                        return;\n          \n          \n            \n                                    }\n          \n          \n            \n                                }\n          \n          \n            \n                            } catch (Throwable t) {\n          \n          \n            \n                                logger.info(\"Exception error: {}\", t);\n          \n          \n            \n                            }\n          \n          \n            \n                            maybeMoreIo = completionQueue.process(this) != 0;\n          \n          \n            \n                        }", "url": "https://github.com/netty/netty/pull/10542#discussion_r485385393", "createdAt": "2020-09-09T07:07:25Z", "author": {"login": "nitsanw"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);\n+                }\n+            } while (maybeMoreIo | maybeMoreTasks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NjQ5NTk0", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-484649594", "createdAt": "2020-09-09T04:18:23Z", "commit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNDoxODoyM1rOHO2DUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwODowNzo1MlrOHO7ocw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMyNzY5Nw==", "bodyText": "I dont think you that we need  head double check, as io_uring wouldn't never change the cqe head", "url": "https://github.com/netty/netty/pull/10542#discussion_r485327697", "createdAt": "2020-09-09T04:18:23Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,44 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjU1MA=="}, "originalCommit": {"oid": "8f2cf9e78e4bc6c2c1354e63ac46bb3f7f27c9ad"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTUxNA==", "bodyText": "we should submit here, at least at the end of the loop", "url": "https://github.com/netty/netty/pull/10542#discussion_r485381514", "createdAt": "2020-09-09T06:59:01Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -153,29 +173,7 @@ protected void run() {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n-\n-            // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-            submissionQueue.submit();\n-            clearUsedIovArrays();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-                    submissionQueue.submit();\n-                    clearUsedIovArrays();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n-                    }\n-                }\n-            } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                clearUsedIovArrays();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQwMDM4Mw==", "bodyText": "WDYT?", "url": "https://github.com/netty/netty/pull/10542#discussion_r485400383", "createdAt": "2020-09-09T07:36:15Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -153,29 +173,7 @@ protected void run() {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n-\n-            // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-            submissionQueue.submit();\n-            clearUsedIovArrays();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    // Once we submitted its safe to clear the iovArray and so be able to re-use it.\n-                    submissionQueue.submit();\n-                    clearUsedIovArrays();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n-                    }\n-                }\n-            } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                clearUsedIovArrays();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MTUxNA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQxODAyOA==", "bodyText": "do you mean both variables should be volatile or getIntVolatile, however I would prefer getIntVolatile :)", "url": "https://github.com/netty/netty/pull/10542#discussion_r485418028", "createdAt": "2020-09-09T08:06:04Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3OTUzMg=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQxOTEyMw==", "bodyText": "exactly", "url": "https://github.com/netty/netty/pull/10542#discussion_r485419123", "createdAt": "2020-09-09T08:07:52Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,36 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getInt(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getInt(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqe = (ringHead & ringMask) * CQE_SIZE + completionQueueArrayAddress;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MDEyOA=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0OTQ1MDYy", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-484945062", "createdAt": "2020-09-09T12:14:26Z", "commit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjoxNDoyNlrOHPEbTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMjoyNDoyNlrOHPExAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2MzIxNA==", "bodyText": "Checkstyle seems to complain about trailing whitespace on this line.", "url": "https://github.com/netty/netty/pull/10542#discussion_r485563214", "createdAt": "2020-09-09T12:14:26Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -39,6 +39,9 @@\n   private final int ringSize;\n   private final long ringAddress;\n   private final int ringFd;\n+  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2NDgwOA==", "bodyText": "Yeah, the do-while only made sense when we had the simple loop previously.", "url": "https://github.com/netty/netty/pull/10542#discussion_r485564808", "createdAt": "2020-09-09T12:17:10Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);\n+                }\n+            } while (maybeMoreIo | maybeMoreTasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4NTM5Mw=="}, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU2ODc2OA==", "bodyText": "I think the exception should say something about \"Caught exception when shutting down event loop\" or something. This part, including the error handling, could also be extracted to a separate method, so it looks like \"if (blabla()) { return; }`", "url": "https://github.com/netty/netty/pull/10542#discussion_r485568768", "createdAt": "2020-09-09T12:24:26Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -120,10 +120,31 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         submissionQueue.addPollIn(eventfd.intValue());\n-        submissionQueue.submit();\n \n         for (;;) {\n             logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n+            // avoid blocking for as long as possible - loop until two consecutive \"empty\" results\n+            boolean maybeMoreTasks = true;\n+            boolean maybeMoreIo;\n+            do {\n+                maybeMoreIo = completionQueue.process(this) != 0;\n+                if (!maybeMoreIo & !maybeMoreTasks) {\n+                    break; // no need to check tasks again here\n+                }\n+                maybeMoreTasks = runAllTasks();\n+                try {\n+                    if (isShuttingDown()) {\n+                        closeAll();\n+                        if (confirmShutdown()) {\n+                            return;\n+                        }\n+                    }\n+                } catch (Throwable t) {\n+                    logger.info(\"Exception error: {}\", t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08cfa017a767924500c700bf16c120155673d054"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2c2bc3edeb2f172e87a8856c16a1771bcc9a738", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/a2c2bc3edeb2f172e87a8856c16a1771bcc9a738", "committedDate": "2020-09-09T22:57:56Z", "message": "Incorporate suggestions, move inner loop to bottom, move hasTasks check"}, "afterCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/ac7a03ccc35dc2ddccb3dae289829424c83fcf08", "committedDate": "2020-09-10T20:43:04Z", "message": "Make sure there is a try/catch around each event loop iteration\n\nand refine inner loop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NjgxNDA2", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-486681406", "createdAt": "2020-09-11T10:13:43Z", "commit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMDoxMzo0M1rOHQZBww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMDoxMzo0M1rOHQZBww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ==", "bodyText": "I'm not sure if a Or bitwise operator would make sense here, what about ||?", "url": "https://github.com/netty/netty/pull/10542#discussion_r486949315", "createdAt": "2020-09-11T10:13:43Z", "author": {"login": "1Jo1"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2Nzc0NjE0", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-486774614", "createdAt": "2020-09-11T12:48:35Z", "commit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo0ODozNVrOHQdcOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzowMTo0NlrOHQd5Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyMTYyNw==", "bodyText": "Not specifically related to this PR, but I just noticed that this considers the CQE processed and consumed when handle returns false. Further turns out that this doesn't matter in practice because handle always returns true, except in one test. \ud83e\udd37", "url": "https://github.com/netty/netty/pull/10542#discussion_r487021627", "createdAt": "2020-09-11T12:48:35Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -51,37 +54,37 @@\n     this.ringSize = ringSize;\n     this.ringAddress = ringAddress;\n     this.ringFd = ringFd;\n+\n+    this.ringMask = PlatformDependent.getIntVolatile(kringMaskAddress);\n+    this.ringHead = PlatformDependent.getIntVolatile(kHeadAddress);\n+  }\n+\n+  public boolean hasCompletions() {\n+      return ringHead != PlatformDependent.getIntVolatile(kTailAddress);\n   }\n \n   public int process(IOUringCompletionQueueCallback callback) {\n+      int tail = PlatformDependent.getIntVolatile(kTailAddress);\n       int i = 0;\n-      for (;;) {\n-          long head = toUnsignedLong(PlatformDependent.getIntVolatile(kHeadAddress));\n-          if (head != toUnsignedLong(PlatformDependent.getInt(kTailAddress))) {\n-              long index = head & toUnsignedLong(PlatformDependent.getInt(kringMaskAddress));\n-              long cqe = index * CQE_SIZE + completionQueueArrayAddress;\n-\n-              long udata = PlatformDependent.getLong(cqe + CQE_USER_DATA_FIELD);\n-              int res = PlatformDependent.getInt(cqe + CQE_RES_FIELD);\n-              long flags = toUnsignedLong(PlatformDependent.getInt(cqe + CQE_FLAGS_FIELD));\n-\n-              //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n-              PlatformDependent.putIntOrdered(kHeadAddress, (int) (head + 1));\n-\n-              int fd = (int) (udata >> 32);\n-              int opMask = (int) udata;\n-              short op = (short) (opMask >> 16);\n-              short mask = (short) opMask;\n-\n-              i++;\n-              if (!callback.handle(fd, res, flags, op, mask)) {\n-                  break;\n-              }\n-          } else {\n-              if (i == 0) {\n-                  return -1;\n-              }\n-              return i;\n+      while (ringHead != tail) {\n+          long cqeAddress = completionQueueArrayAddress + (ringHead & ringMask) * CQE_SIZE;\n+\n+          long udata = PlatformDependent.getLong(cqeAddress + CQE_USER_DATA_FIELD);\n+          int res = PlatformDependent.getInt(cqeAddress + CQE_RES_FIELD);\n+          int flags = PlatformDependent.getInt(cqeAddress + CQE_FLAGS_FIELD);\n+\n+          //Ensure that the kernel only sees the new value of the head index after the CQEs have been read.\n+          ringHead++;\n+          PlatformDependent.putIntOrdered(kHeadAddress, ringHead);\n+\n+          int fd = (int) (udata >>> 32);\n+          int opMask = (int) (udata & 0xFFFFFFFFL);\n+          int op = opMask >>> 16;\n+          int mask = opMask & 0xffff;\n+\n+          i++;\n+          if (!callback.handle(fd, res, flags, op, mask)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNTM1OQ==", "bodyText": "Yeah, either a comment, or a change the code to make it obvious that we wish to run both.", "url": "https://github.com/netty/netty/pull/10542#discussion_r487025359", "createdAt": "2020-09-11T12:55:01Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTMxNQ=="}, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNjg1Mw==", "bodyText": "Oof! Can we add a trip-counter or something (with reset on successful trips) so we only do this when there are many consecutive errors? This could be moved to some rate-limited error reporter component.", "url": "https://github.com/netty/netty/pull/10542#discussion_r487026853", "createdAt": "2020-09-11T12:57:43Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringEventLoop.java", "diffHunk": "@@ -125,62 +125,83 @@ protected void run() {\n \n         // Lets add the eventfd related events before starting to do any real work.\n         addEventFdRead(submissionQueue);\n-        submissionQueue.submit();\n \n         for (;;) {\n-            logger.trace(\"Run IOUringEventLoop {}\", this.toString());\n-            long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n-            if (curDeadlineNanos == -1L) {\n-                curDeadlineNanos = NONE; // nothing on the calendar\n-            }\n-            nextWakeupNanos.set(curDeadlineNanos);\n+            try {\n+                logger.trace(\"Run IOUringEventLoop {}\", this);\n \n-            // Only submit a timeout if there are no tasks to process and do a blocking operation\n-            // on the completionQueue.\n-            if (!hasTasks()) {\n-                try {\n-                    if (curDeadlineNanos != prevDeadlineNanos) {\n-                        prevDeadlineNanos = curDeadlineNanos;\n-                        submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n-                        submissionQueue.submit();\n-                    }\n+                // Prepare to block wait\n+                long curDeadlineNanos = nextScheduledTaskDeadlineNanos();\n+                if (curDeadlineNanos == -1L) {\n+                    curDeadlineNanos = NONE; // nothing on the calendar\n+                }\n+                nextWakeupNanos.set(curDeadlineNanos);\n \n-                    // Check there were any completion events to process\n-                    if (completionQueue.process(this) == -1) {\n-                        // Block if there is nothing to process after this try again to call process(....)\n-                        logger.trace(\"ioUringWaitCqe {}\", this.toString());\n-                        completionQueue.ioUringWaitCqe();\n+                // Only submit a timeout if there are no tasks to process and do a blocking operation\n+                // on the completionQueue.\n+                try {\n+                    if (!hasTasks()) {\n+                        if (curDeadlineNanos != prevDeadlineNanos) {\n+                            prevDeadlineNanos = curDeadlineNanos;\n+                            submissionQueue.addTimeout(deadlineToDelayNanos(curDeadlineNanos));\n+                        }\n+\n+                        // Check there were any completion events to process\n+                        if (!completionQueue.hasCompletions()) {\n+                            // Block if there is nothing to process after this try again to call process(....)\n+                            logger.trace(\"submitAndWait {}\", this);\n+                            submissionQueue.submitAndWait();\n+                        }\n                     }\n-                } catch (Throwable t) {\n-                    //Todo handle exception\n                 } finally {\n                     if (nextWakeupNanos.get() == AWAKE || nextWakeupNanos.getAndSet(AWAKE) == AWAKE) {\n                         pendingWakeup = true;\n                     }\n                 }\n-            }\n-\n-            completionQueue.process(this);\n-\n-            // Always call runAllTasks() as it will also fetch the scheduled tasks that are ready.\n-            runAllTasks();\n \n-            submissionQueue.submit();\n-            try {\n-                if (isShuttingDown()) {\n-                    closeAll();\n-                    submissionQueue.submit();\n-\n-                    if (confirmShutdown()) {\n-                        break;\n+                // avoid blocking for as long as possible - loop until available work exhausted\n+                boolean maybeMoreWork = true;\n+                do {\n+                    try {\n+                        maybeMoreWork = completionQueue.process(this) != 0 | runAllTasks();\n+                    } finally {\n+                        // Always handle shutdown even if the loop processing threw an exception\n+                        try {\n+                            if (isShuttingDown()) {\n+                                closeAll();\n+                                if (confirmShutdown()) {\n+                                    return;\n+                                }\n+                                if (!maybeMoreWork) {\n+                                    maybeMoreWork = hasTasks() || completionQueue.hasCompletions();\n+                                }\n+                            }\n+                        } catch (Throwable t) {\n+                            handleLoopException(t);\n+                        }\n                     }\n-                }\n+                } while (maybeMoreWork);\n             } catch (Throwable t) {\n-                logger.info(\"Exception error: {}\", t);\n+                handleLoopException(t);\n             }\n         }\n     }\n \n+    /**\n+     * Visible only for testing!\n+     */\n+    void handleLoopException(Throwable t) {\n+        logger.warn(\"Unexpected exception in the io_uring event loop\", t);\n+\n+        // Prevent possible consecutive immediate failures that lead to\n+        // excessive CPU consumption.\n+        try {\n+            Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTA4Mg==", "bodyText": "Guarding for negative submit counts? When would that happen?", "url": "https://github.com/netty/netty/pull/10542#discussion_r487029082", "createdAt": "2020-09-11T13:01:46Z", "author": {"login": "chrisvest"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -188,17 +188,33 @@ public boolean addClose(int fd) {\n     public void submit() {\n         int submit = tail - head;\n         if (submit > 0) {\n-            PlatformDependent.putIntOrdered(kTailAddress, tail); // release memory barrier\n-            int ret = Native.ioUringEnter(ringFd, submit, 0, 0);\n-            head = PlatformDependent.getIntVolatile(kHeadAddress); // acquire memory barrier\n-            if (ret != submit) {\n-                if (ret < 0) {\n-                    throw new RuntimeException(\"ioUringEnter syscall\");\n-                }\n-                logger.warn(\"Not all submissions succeeded\");\n+            submit(submit, 0, 0);\n+        }\n+    }\n+\n+    public void submitAndWait() {\n+        int submit = tail - head;\n+        if (submit > 0) {\n+            submit(submit, 1, Native.IORING_ENTER_GETEVENTS);\n+        } else {\n+            int ret = Native.ioUringEnter(ringFd, 0, 1, Native.IORING_ENTER_GETEVENTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac7a03ccc35dc2ddccb3dae289829424c83fcf08"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2ODk5MjY2", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-486899266", "createdAt": "2020-09-11T15:17:22Z", "commit": {"oid": "fe5136646caafbfa1f2f80428b806709d15782f2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e14343d415d3e51db6e2bc162376c10413c10c38", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/e14343d415d3e51db6e2bc162376c10413c10c38", "committedDate": "2020-09-11T16:33:41Z", "message": "Further reduce io_uring syscalls\n\nMotivation\n\nIOUringEventLoop can be streamlined to further reduce io_uring_enter\ncalls\n\nModification\n\n- Don't prepare to block-wait until all available work is exhausted\n- Combine submission with GETEVENTS\n\nResult\n\nHopefully faster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d7c9776294b8ddc98c13ccd991aa651e1c15d79", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/5d7c9776294b8ddc98c13ccd991aa651e1c15d79", "committedDate": "2020-09-11T16:33:41Z", "message": "minor simplification to IOUringCompletionQueue#process method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eff2ea6b8c5cd380c4152d93968711569f7abf5", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/7eff2ea6b8c5cd380c4152d93968711569f7abf5", "committedDate": "2020-09-11T16:33:41Z", "message": "Move shutdown check into inner loop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4180c38ab7f1f348c665b958a8e83182ef1968c8", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/4180c38ab7f1f348c665b958a8e83182ef1968c8", "committedDate": "2020-09-11T16:33:41Z", "message": "Fix eventloop shutdown logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28907dbc9fa7624dd865fdd4a35b9f119ad0b304", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/28907dbc9fa7624dd865fdd4a35b9f119ad0b304", "committedDate": "2020-09-11T16:33:42Z", "message": "Adjust inner event loop to better interleave task/completion processing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0cf1c985491b232b5b324d98581f2a1af933663", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/d0cf1c985491b232b5b324d98581f2a1af933663", "committedDate": "2020-09-11T16:33:42Z", "message": "Change to do/while per @chrisvest's suggestion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87ba9ce4db9bf717dfbdc9fdf9107bd77a49eb56", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/87ba9ce4db9bf717dfbdc9fdf9107bd77a49eb56", "committedDate": "2020-09-11T16:33:42Z", "message": "Incorporate suggestions, move inner loop to bottom, move hasTasks check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ab9871dd3b2e52c473afa7c8aa9faecfba41d5a", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/5ab9871dd3b2e52c473afa7c8aa9faecfba41d5a", "committedDate": "2020-09-11T16:33:42Z", "message": "Make sure there is a try/catch around each event loop iteration\n\nand refine inner loop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6df3f3718c212f7d6e573a2250ef87ef948ab35f", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/6df3f3718c212f7d6e573a2250ef87ef948ab35f", "committedDate": "2020-09-11T16:33:42Z", "message": "Address some comments, other small refinements\n\nAdjust try/catch blocks some more to ensure that exceptions are logged\nin order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/425b95ed92ef6bdd44c05db395fca50a5337fd00", "committedDate": "2020-09-11T16:50:58Z", "message": "Simplify completion queue handle() and related methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fe5136646caafbfa1f2f80428b806709d15782f2", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/fe5136646caafbfa1f2f80428b806709d15782f2", "committedDate": "2020-09-11T15:04:30Z", "message": "Address some comments, other small refinements\n\nAdjust try/catch blocks some more to ensure that exceptions are logged\nin order"}, "afterCommit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/425b95ed92ef6bdd44c05db395fca50a5337fd00", "committedDate": "2020-09-11T16:50:58Z", "message": "Simplify completion queue handle() and related methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MDA5MDcw", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-487009070", "createdAt": "2020-09-11T17:54:43Z", "commit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MDI4MDk0", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-487028094", "createdAt": "2020-09-11T18:24:03Z", "commit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxODoyNDowM1rOHQpQyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxODoyNzowNFrOHQpXKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNTMwNw==", "bodyText": "Hmm it\u2019s kind of odd to expose a package-private class in a public method imho", "url": "https://github.com/netty/netty/pull/10542#discussion_r487215307", "createdAt": "2020-09-11T18:24:03Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -163,6 +163,11 @@ public FileDescriptor fd() {\n     @Override\n     protected abstract AbstractUringUnsafe newUnsafe();\n \n+    @Override\n+    public AbstractUringUnsafe unsafe() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxNjkzOQ==", "bodyText": "Just as a followup we should better access the fields directly from JNI as calling methods is expensive", "url": "https://github.com/netty/netty/pull/10542#discussion_r487216939", "createdAt": "2020-09-11T18:27:04Z", "author": {"login": "normanmaurer"}, "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -231,6 +250,8 @@ public void release() {\n         PlatformDependent.freeMemory(timeoutMemoryAddress);\n     }\n \n+    // The getters below are called from JNI code\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425b95ed92ef6bdd44c05db395fca50a5337fd00"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68217514ca8c6aa8be523bfc36476dec8316650b", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/netty/netty/commit/68217514ca8c6aa8be523bfc36476dec8316650b", "committedDate": "2020-09-11T19:15:10Z", "message": "Use dedicated pkg-private AbstractIOUringChannel#ioUringUnsafe() method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MjIxNzM5", "url": "https://github.com/netty/netty/pull/10542#pullrequestreview-487221739", "createdAt": "2020-09-12T10:47:49Z", "commit": {"oid": "68217514ca8c6aa8be523bfc36476dec8316650b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 13, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}