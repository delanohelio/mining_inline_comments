{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwODczMjk5", "number": 10175, "title": "Add support for HAProxyMessageEncoder", "bodyText": "Motivation:\nAdd support for HAProxyMessageEncoder.\nThis should help java based HAProxy server implementations propagate proxy information.\nModification:\nAdd public constructors for HAProxyMessage, HAProxyTLV, HAProxySSLTLV.\nAdd additional argument checks for HAProxyMessage and modify exceptions thrown when creating via public constructors directly.\nIntroduce a @Sharable HAProxyMessageEncoder which encodes a HAProxyMessage into a byte array.\nAdd an example HAProxyServer and HAProxyClient to io.netty.example\nResult:\nFixes #10164", "createdAt": "2020-04-08T14:08:31Z", "url": "https://github.com/netty/netty/pull/10175", "merged": true, "mergeCommit": {"oid": "37948bc9debb3646150365e21da5d38342bbb3c5"}, "closed": true, "closedAt": "2020-04-16T07:35:07Z", "author": {"login": "jrhee17"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVoSBpgH2gAyNDAwODczMjk5Ojc5MGU3MWZhMzYyZDRkOWI2NDRmMmNmY2YzY2I2NWY0MWUwMWYxYjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYAB2SgH2gAyNDAwODczMjk5OjBkODExNDA0OTA5ODZiOGJhYjFkZDgxNmMxOTM4YmZlNmJlOWUxMzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "committedDate": "2020-04-08T13:54:23Z", "message": "add basic support for haproxy encoder"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMDEyNTQz", "url": "https://github.com/netty/netty/pull/10175#pullrequestreview-390012543", "createdAt": "2020-04-08T14:10:52Z", "commit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDoxMDo1MlrOGCxH9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDoyMTo1N1rOGCxn1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1NTE4OA==", "bodyText": "shouldn't address.length() > 108 be good enough ?", "url": "https://github.com/netty/netty/pull/10175#discussion_r405555188", "createdAt": "2020-04-08T14:10:52Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java", "diffHunk": "@@ -395,18 +416,21 @@ private static int portStringToInt(String value) {\n      *\n      * @param address                    human-readable address\n      * @param addrFamily                 the {@link AddressFamily} to check the address against\n-     * @throws HAProxyProtocolException  if the address is invalid\n+     * @throws IllegalArgumentException  if the address is invalid\n      */\n     private static void checkAddress(String address, AddressFamily addrFamily) {\n         ObjectUtil.checkNotNull(addrFamily, \"addrFamily\");\n \n         switch (addrFamily) {\n             case AF_UNSPEC:\n                 if (address != null) {\n-                    throw new HAProxyProtocolException(\"unable to validate an AF_UNSPEC address: \" + address);\n+                    throw new IllegalArgumentException(\"unable to validate an AF_UNSPEC address: \" + address);\n                 }\n                 return;\n             case AF_UNIX:\n+                if (address == null || address.getBytes(CharsetUtil.US_ASCII).length > 108) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1NjM0Mw==", "bodyText": "As this one is @Sharable should we add a private constructor, mark it final and expose a static instance that the user can use ?", "url": "https://github.com/netty/netty/pull/10175#discussion_r405556343", "createdAt": "2020-04-08T14:12:31Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1Njk3OA==", "bodyText": "why we dont write stuff directly to the ByteBuf ? We can use out.writeCharSequence(...)", "url": "https://github.com/netty/netty/pull/10175#discussion_r405556978", "createdAt": "2020-04-08T14:13:21Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1NzY2MA==", "bodyText": "consider using a switch as replacement for all the if ... else if ... else.", "url": "https://github.com/netty/netty/pull/10175#discussion_r405557660", "createdAt": "2020-04-08T14:14:11Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1ODEyMw==", "bodyText": "Can we make this 216 an static field and add comments on what this is about ?", "url": "https://github.com/netty/netty/pull/10175#discussion_r405558123", "createdAt": "2020-04-08T14:14:49Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {\n+            byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+            byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+            out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+            out.writeBytes(sourceAddress);\n+            out.writeBytes(destinationAddress);\n+            out.writeShort(msg.sourcePort());\n+            out.writeShort(msg.destinationPort());\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNIX) {\n+            out.writeShort(216 + msg.tlvNumBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1ODM5MQ==", "bodyText": "again consider using out.writeCharSequence(...)", "url": "https://github.com/netty/netty/pull/10175#discussion_r405558391", "createdAt": "2020-04-08T14:15:11Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {\n+            byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+            byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+            out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+            out.writeBytes(sourceAddress);\n+            out.writeBytes(destinationAddress);\n+            out.writeShort(msg.sourcePort());\n+            out.writeShort(msg.destinationPort());\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNIX) {\n+            out.writeShort(216 + msg.tlvNumBytes());\n+            byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(srcAddressBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1ODUyMg==", "bodyText": "same comment as above.", "url": "https://github.com/netty/netty/pull/10175#discussion_r405558522", "createdAt": "2020-04-08T14:15:23Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {\n+            byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+            byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+            out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+            out.writeBytes(sourceAddress);\n+            out.writeBytes(destinationAddress);\n+            out.writeShort(msg.sourcePort());\n+            out.writeShort(msg.destinationPort());\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNIX) {\n+            out.writeShort(216 + msg.tlvNumBytes());\n+            byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(srcAddressBytes);\n+            out.writeBytes(new byte[108 - srcAddressBytes.length]);\n+            byte[] dstAddressBytes = msg.destinationAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(dstAddressBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1ODc1Mw==", "bodyText": "please make this 108 an static field and add comments what this is about.", "url": "https://github.com/netty/netty/pull/10175#discussion_r405558753", "createdAt": "2020-04-08T14:15:41Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {\n+            byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+            byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+            out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+            out.writeBytes(sourceAddress);\n+            out.writeBytes(destinationAddress);\n+            out.writeShort(msg.sourcePort());\n+            out.writeShort(msg.destinationPort());\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNIX) {\n+            out.writeShort(216 + msg.tlvNumBytes());\n+            byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(srcAddressBytes);\n+            out.writeBytes(new byte[108 - srcAddressBytes.length]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTIyMA==", "bodyText": "closing using index based for loop to eliminate GC pressure", "url": "https://github.com/netty/netty/pull/10175#discussion_r405559220", "createdAt": "2020-04-08T14:16:19Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {\n+            byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+            byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+            out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+            out.writeBytes(sourceAddress);\n+            out.writeBytes(destinationAddress);\n+            out.writeShort(msg.sourcePort());\n+            out.writeShort(msg.destinationPort());\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNIX) {\n+            out.writeShort(216 + msg.tlvNumBytes());\n+            byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(srcAddressBytes);\n+            out.writeBytes(new byte[108 - srcAddressBytes.length]);\n+            byte[] dstAddressBytes = msg.destinationAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(dstAddressBytes);\n+            out.writeBytes(new byte[108 - dstAddressBytes.length]);\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNSPEC) {\n+            out.writeShort(0);\n+        }\n+    }\n+\n+    private static void encodeTlv(HAProxyTLV haProxyTLV, ByteBuf out) {\n+        if (haProxyTLV instanceof HAProxySSLTLV) {\n+            HAProxySSLTLV ssltlv = (HAProxySSLTLV) haProxyTLV;\n+            out.writeByte(haProxyTLV.typeByteValue());\n+            out.writeShort(ssltlv.contentNumBytes());\n+            out.writeByte(ssltlv.client());\n+            out.writeInt(ssltlv.verify());\n+            encodeTlvs(ssltlv.encapsulatedTLVs(), out);\n+        } else {\n+            out.writeByte(haProxyTLV.typeByteValue());\n+            ByteBuf value = haProxyTLV.content();\n+            int readableBytes = value.readableBytes();\n+            out.writeShort(readableBytes);\n+            out.writeBytes(value.readSlice(readableBytes));\n+        }\n+    }\n+\n+    private static void encodeTlvs(List<HAProxyTLV> haProxyTLVs, ByteBuf out) {\n+        for (HAProxyTLV tlv: haProxyTLVs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTM5OQ==", "bodyText": "please add javadocs", "url": "https://github.com/netty/netty/pull/10175#discussion_r405559399", "createdAt": "2020-04-08T14:16:36Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxySSLTLV.java", "diffHunk": "@@ -69,6 +83,9 @@ public boolean isPP2ClientCertSess() {\n         return (clientBitField & 0x4) != 0;\n     }\n \n+    public byte client() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTUxNw==", "bodyText": "add empty line above", "url": "https://github.com/netty/netty/pull/10175#discussion_r405559517", "createdAt": "2020-04-08T14:16:45Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxySSLTLV.java", "diffHunk": "@@ -69,6 +83,9 @@ public boolean isPP2ClientCertSess() {\n         return (clientBitField & 0x4) != 0;\n     }\n \n+    public byte client() {\n+        return clientBitField;\n+    }\n     /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTc2Mg==", "bodyText": "Just use normal string concats...", "url": "https://github.com/netty/netty/pull/10175#discussion_r405559762", "createdAt": "2020-04-08T14:17:06Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxySSLTLV.java", "diffHunk": "@@ -83,4 +100,24 @@ public int verify() {\n         return tlvs;\n     }\n \n+    @Override\n+    int contentNumBytes() {\n+        int tlvNumBytes = 0;\n+        for (int i = 0; i < tlvs.size(); i++) {\n+            tlvNumBytes += tlvs.get(i).totalNumBytes();\n+        }\n+        return 5 + tlvNumBytes; // clientBit(1) + verify(4) + tlvs\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(128)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MDE3Nw==", "bodyText": "please add javadocs and consider removing final to be more consistent", "url": "https://github.com/netty/netty/pull/10175#discussion_r405560177", "createdAt": "2020-04-08T14:17:36Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java", "diffHunk": "@@ -74,6 +87,45 @@ public static Type typeForByteValue(final byte byteValue) {\n                 return OTHER;\n             }\n         }\n+\n+        public static byte byteValueForType(final Type type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MDUzOA==", "bodyText": "same comment as above... consider just using normal string concat", "url": "https://github.com/netty/netty/pull/10175#discussion_r405560538", "createdAt": "2020-04-08T14:18:01Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java", "diffHunk": "@@ -146,4 +198,15 @@ public HAProxyTLV touch(Object hint) {\n         super.touch(hint);\n         return this;\n     }\n+\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(256)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTIzNA==", "bodyText": "you should call msg.retain() as SimpleChannelInboundHandler will release the msg after channelRead0 returns", "url": "https://github.com/netty/netty/pull/10175#discussion_r405561234", "createdAt": "2020-04-08T14:19:00Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.DefaultEventLoopGroup;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.channel.local.LocalChannel;\n+import io.netty.channel.local.LocalServerChannel;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.Assert.*;\n+\n+public class HAProxyIntegrationTest {\n+\n+    @Test\n+    public void testBasicCase() throws Exception {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicReference<HAProxyMessage> msgHolder = new AtomicReference<HAProxyMessage>();\n+\n+        EventLoopGroup group = new DefaultEventLoopGroup();\n+        ServerBootstrap sb = new ServerBootstrap();\n+        sb.channel(LocalServerChannel.class)\n+          .group(group)\n+          .childHandler(new ChannelInitializer() {\n+              @Override\n+              protected void initChannel(Channel ch) throws Exception {\n+                  ch.pipeline().addLast(new HAProxyMessageDecoder());\n+                  ch.pipeline().addLast(new SimpleChannelInboundHandler<HAProxyMessage>() {\n+                      @Override\n+                      protected void channelRead0(ChannelHandlerContext ctx, HAProxyMessage msg) throws Exception {\n+                          msgHolder.set(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTQ2Mw==", "bodyText": "call readMessage.release() in a finally block", "url": "https://github.com/netty/netty/pull/10175#discussion_r405561463", "createdAt": "2020-04-08T14:19:18Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.DefaultEventLoopGroup;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.channel.local.LocalChannel;\n+import io.netty.channel.local.LocalServerChannel;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.Assert.*;\n+\n+public class HAProxyIntegrationTest {\n+\n+    @Test\n+    public void testBasicCase() throws Exception {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicReference<HAProxyMessage> msgHolder = new AtomicReference<HAProxyMessage>();\n+\n+        EventLoopGroup group = new DefaultEventLoopGroup();\n+        ServerBootstrap sb = new ServerBootstrap();\n+        sb.channel(LocalServerChannel.class)\n+          .group(group)\n+          .childHandler(new ChannelInitializer() {\n+              @Override\n+              protected void initChannel(Channel ch) throws Exception {\n+                  ch.pipeline().addLast(new HAProxyMessageDecoder());\n+                  ch.pipeline().addLast(new SimpleChannelInboundHandler<HAProxyMessage>() {\n+                      @Override\n+                      protected void channelRead0(ChannelHandlerContext ctx, HAProxyMessage msg) throws Exception {\n+                          msgHolder.set(msg);\n+                          latch.countDown();\n+                      }\n+                  });\n+              }\n+          });\n+\n+        LocalAddress localAddress = new LocalAddress(\"HAProxyIntegrationTest\");\n+        sb.bind(localAddress).sync().channel();\n+\n+        Bootstrap b = new Bootstrap();\n+        Channel clientChannel = b.channel(LocalChannel.class)\n+                                 .handler(new HAProxyMessageEncoder())\n+                                 .group(group)\n+                                 .connect(localAddress).sync().channel();\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        clientChannel.writeAndFlush(message);\n+\n+        assertTrue(latch.await(5, TimeUnit.SECONDS));\n+        HAProxyMessage readMessage = msgHolder.get();\n+\n+        assertEquals(message.protocolVersion(), readMessage.protocolVersion());\n+        assertEquals(message.command(), readMessage.command());\n+        assertEquals(message.proxiedProtocol(), readMessage.proxiedProtocol());\n+        assertEquals(message.sourceAddress(), readMessage.sourceAddress());\n+        assertEquals(message.destinationAddress(), readMessage.destinationAddress());\n+        assertEquals(message.sourcePort(), readMessage.sourcePort());\n+        assertEquals(message.destinationPort(), readMessage.destinationPort());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTU4MA==", "bodyText": "add sync()", "url": "https://github.com/netty/netty/pull/10175#discussion_r405561580", "createdAt": "2020-04-08T14:19:27Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.DefaultEventLoopGroup;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.channel.local.LocalChannel;\n+import io.netty.channel.local.LocalServerChannel;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.Assert.*;\n+\n+public class HAProxyIntegrationTest {\n+\n+    @Test\n+    public void testBasicCase() throws Exception {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicReference<HAProxyMessage> msgHolder = new AtomicReference<HAProxyMessage>();\n+\n+        EventLoopGroup group = new DefaultEventLoopGroup();\n+        ServerBootstrap sb = new ServerBootstrap();\n+        sb.channel(LocalServerChannel.class)\n+          .group(group)\n+          .childHandler(new ChannelInitializer() {\n+              @Override\n+              protected void initChannel(Channel ch) throws Exception {\n+                  ch.pipeline().addLast(new HAProxyMessageDecoder());\n+                  ch.pipeline().addLast(new SimpleChannelInboundHandler<HAProxyMessage>() {\n+                      @Override\n+                      protected void channelRead0(ChannelHandlerContext ctx, HAProxyMessage msg) throws Exception {\n+                          msgHolder.set(msg);\n+                          latch.countDown();\n+                      }\n+                  });\n+              }\n+          });\n+\n+        LocalAddress localAddress = new LocalAddress(\"HAProxyIntegrationTest\");\n+        sb.bind(localAddress).sync().channel();\n+\n+        Bootstrap b = new Bootstrap();\n+        Channel clientChannel = b.channel(LocalChannel.class)\n+                                 .handler(new HAProxyMessageEncoder())\n+                                 .group(group)\n+                                 .connect(localAddress).sync().channel();\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        clientChannel.writeAndFlush(message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjA1OQ==", "bodyText": "also close the channels and shutdown the group in a finally block", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562059", "createdAt": "2020-04-08T14:20:05Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.DefaultEventLoopGroup;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.channel.local.LocalChannel;\n+import io.netty.channel.local.LocalServerChannel;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.Assert.*;\n+\n+public class HAProxyIntegrationTest {\n+\n+    @Test\n+    public void testBasicCase() throws Exception {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicReference<HAProxyMessage> msgHolder = new AtomicReference<HAProxyMessage>();\n+\n+        EventLoopGroup group = new DefaultEventLoopGroup();\n+        ServerBootstrap sb = new ServerBootstrap();\n+        sb.channel(LocalServerChannel.class)\n+          .group(group)\n+          .childHandler(new ChannelInitializer() {\n+              @Override\n+              protected void initChannel(Channel ch) throws Exception {\n+                  ch.pipeline().addLast(new HAProxyMessageDecoder());\n+                  ch.pipeline().addLast(new SimpleChannelInboundHandler<HAProxyMessage>() {\n+                      @Override\n+                      protected void channelRead0(ChannelHandlerContext ctx, HAProxyMessage msg) throws Exception {\n+                          msgHolder.set(msg);\n+                          latch.countDown();\n+                      }\n+                  });\n+              }\n+          });\n+\n+        LocalAddress localAddress = new LocalAddress(\"HAProxyIntegrationTest\");\n+        sb.bind(localAddress).sync().channel();\n+\n+        Bootstrap b = new Bootstrap();\n+        Channel clientChannel = b.channel(LocalChannel.class)\n+                                 .handler(new HAProxyMessageEncoder())\n+                                 .group(group)\n+                                 .connect(localAddress).sync().channel();\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        clientChannel.writeAndFlush(message);\n+\n+        assertTrue(latch.await(5, TimeUnit.SECONDS));\n+        HAProxyMessage readMessage = msgHolder.get();\n+\n+        assertEquals(message.protocolVersion(), readMessage.protocolVersion());\n+        assertEquals(message.command(), readMessage.command());\n+        assertEquals(message.proxiedProtocol(), readMessage.proxiedProtocol());\n+        assertEquals(message.sourceAddress(), readMessage.sourceAddress());\n+        assertEquals(message.destinationAddress(), readMessage.destinationAddress());\n+        assertEquals(message.sourcePort(), readMessage.sourcePort());\n+        assertEquals(message.destinationPort(), readMessage.destinationPort());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjU4Ng==", "bodyText": "call byteBuf.release(); and also add assertFalse(ch.finish());", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562586", "createdAt": "2020-04-08T14:20:51Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjcwMg==", "bodyText": "call byteBuf.release(); and also add assertFalse(ch.finish());", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562702", "createdAt": "2020-04-08T14:21:01Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjgyNA==", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562824", "createdAt": "2020-04-08T14:21:12Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjkxMQ==", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562911", "createdAt": "2020-04-08T14:21:19Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testIPv6EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x02, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(IPv6_ADDRESS_BYTES_LENGTH, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x20, (byte) 0x01, 0x0d, (byte) 0xb8,\n+                (byte) 0x85, (byte) 0xa3, 0x00, 0x00, 0x00, 0x00, (byte) 0x8a, 0x2e,\n+                0x03, 0x70, 0x73, 0x34}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 32, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x10, (byte) 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x05, 0x06, 0x00, 0x30, 0x0c, 0x32, 0x6b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(48);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(50);\n+        assertEquals(443, destPort);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2Mjk5Ng==", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562996", "createdAt": "2020-04-08T14:21:27Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testIPv6EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x02, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(IPv6_ADDRESS_BYTES_LENGTH, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x20, (byte) 0x01, 0x0d, (byte) 0xb8,\n+                (byte) 0x85, (byte) 0xa3, 0x00, 0x00, 0x00, 0x00, (byte) 0x8a, 0x2e,\n+                0x03, 0x70, 0x73, 0x34}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 32, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x10, (byte) 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x05, 0x06, 0x00, 0x30, 0x0c, 0x32, 0x6b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(48);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(50);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testUnixEncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.UNIX_STREAM,\n+                \"/var/run/src.sock\", \"/var/run/dst.sock\", 0, 0);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x03, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(216, sourceAddrLength);\n+\n+        // source address\n+        int srcAddrEnd = byteBuf.forEachByte(16, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/src.sock\",\n+                     byteBuf.slice(16, srcAddrEnd - 16).toString(CharsetUtil.US_ASCII));\n+\n+        // destination address\n+        int dstAddrEnd = byteBuf.forEachByte(124, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/dst.sock\",\n+                     byteBuf.slice(124, dstAddrEnd - 124).toString(CharsetUtil.US_ASCII));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MzEyMw==", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "url": "https://github.com/netty/netty/pull/10175#discussion_r405563123", "createdAt": "2020-04-08T14:21:39Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testIPv6EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x02, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(IPv6_ADDRESS_BYTES_LENGTH, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x20, (byte) 0x01, 0x0d, (byte) 0xb8,\n+                (byte) 0x85, (byte) 0xa3, 0x00, 0x00, 0x00, 0x00, (byte) 0x8a, 0x2e,\n+                0x03, 0x70, 0x73, 0x34}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 32, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x10, (byte) 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x05, 0x06, 0x00, 0x30, 0x0c, 0x32, 0x6b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(48);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(50);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testUnixEncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.UNIX_STREAM,\n+                \"/var/run/src.sock\", \"/var/run/dst.sock\", 0, 0);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x03, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(216, sourceAddrLength);\n+\n+        // source address\n+        int srcAddrEnd = byteBuf.forEachByte(16, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/src.sock\",\n+                     byteBuf.slice(16, srcAddrEnd - 16).toString(CharsetUtil.US_ASCII));\n+\n+        // destination address\n+        int dstAddrEnd = byteBuf.forEachByte(124, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/dst.sock\",\n+                     byteBuf.slice(124, dstAddrEnd - 124).toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testTLVEncodeProxy() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        List<HAProxyTLV> tlvs = new ArrayList<HAProxyTLV>();\n+\n+        ByteBuf helloWorld = Unpooled.copiedBuffer(\"hello world\", CharsetUtil.US_ASCII);\n+        HAProxyTLV alpnTlv = new HAProxyTLV(Type.PP2_TYPE_ALPN, (byte) 0x01, helloWorld.copy());\n+        tlvs.add(alpnTlv);\n+\n+        ByteBuf arbitrary = Unpooled.copiedBuffer(\"an arbitrary string\", CharsetUtil.US_ASCII);\n+        HAProxyTLV authorityTlv = new HAProxyTLV(Type.PP2_TYPE_AUTHORITY, (byte) 0x01, arbitrary.copy());\n+        tlvs.add(authorityTlv);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443, tlvs);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // length\n+        assertEquals(byteBuf.getUnsignedShort(14), byteBuf.readableBytes() - V2_HEADER_BYTES_LENGTH);\n+\n+        // skip to tlv section\n+        ByteBuf tlv = byteBuf.skipBytes(V2_HEADER_BYTES_LENGTH + IPv4_ADDRESS_BYTES_LENGTH);\n+\n+        // alpn tlv\n+        assertEquals(alpnTlv.typeByteValue(), tlv.readByte());\n+        short bufLength = tlv.readShort();\n+        assertEquals(helloWorld.array().length, bufLength);\n+        assertEquals(helloWorld, tlv.readBytes(bufLength));\n+\n+        // authority tlv\n+        assertEquals(authorityTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(arbitrary.array().length, bufLength);\n+        assertEquals(arbitrary, tlv.readBytes(bufLength));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MzI1OQ==", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "url": "https://github.com/netty/netty/pull/10175#discussion_r405563259", "createdAt": "2020-04-08T14:21:48Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testIPv6EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x02, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(IPv6_ADDRESS_BYTES_LENGTH, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x20, (byte) 0x01, 0x0d, (byte) 0xb8,\n+                (byte) 0x85, (byte) 0xa3, 0x00, 0x00, 0x00, 0x00, (byte) 0x8a, 0x2e,\n+                0x03, 0x70, 0x73, 0x34}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 32, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x10, (byte) 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x05, 0x06, 0x00, 0x30, 0x0c, 0x32, 0x6b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(48);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(50);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testUnixEncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.UNIX_STREAM,\n+                \"/var/run/src.sock\", \"/var/run/dst.sock\", 0, 0);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x03, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(216, sourceAddrLength);\n+\n+        // source address\n+        int srcAddrEnd = byteBuf.forEachByte(16, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/src.sock\",\n+                     byteBuf.slice(16, srcAddrEnd - 16).toString(CharsetUtil.US_ASCII));\n+\n+        // destination address\n+        int dstAddrEnd = byteBuf.forEachByte(124, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/dst.sock\",\n+                     byteBuf.slice(124, dstAddrEnd - 124).toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testTLVEncodeProxy() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        List<HAProxyTLV> tlvs = new ArrayList<HAProxyTLV>();\n+\n+        ByteBuf helloWorld = Unpooled.copiedBuffer(\"hello world\", CharsetUtil.US_ASCII);\n+        HAProxyTLV alpnTlv = new HAProxyTLV(Type.PP2_TYPE_ALPN, (byte) 0x01, helloWorld.copy());\n+        tlvs.add(alpnTlv);\n+\n+        ByteBuf arbitrary = Unpooled.copiedBuffer(\"an arbitrary string\", CharsetUtil.US_ASCII);\n+        HAProxyTLV authorityTlv = new HAProxyTLV(Type.PP2_TYPE_AUTHORITY, (byte) 0x01, arbitrary.copy());\n+        tlvs.add(authorityTlv);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443, tlvs);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // length\n+        assertEquals(byteBuf.getUnsignedShort(14), byteBuf.readableBytes() - V2_HEADER_BYTES_LENGTH);\n+\n+        // skip to tlv section\n+        ByteBuf tlv = byteBuf.skipBytes(V2_HEADER_BYTES_LENGTH + IPv4_ADDRESS_BYTES_LENGTH);\n+\n+        // alpn tlv\n+        assertEquals(alpnTlv.typeByteValue(), tlv.readByte());\n+        short bufLength = tlv.readShort();\n+        assertEquals(helloWorld.array().length, bufLength);\n+        assertEquals(helloWorld, tlv.readBytes(bufLength));\n+\n+        // authority tlv\n+        assertEquals(authorityTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(arbitrary.array().length, bufLength);\n+        assertEquals(arbitrary, tlv.readBytes(bufLength));\n+    }\n+\n+    @Test\n+    public void testSslTLVEncodeProxy() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        List<HAProxyTLV> tlvs = new ArrayList<HAProxyTLV>();\n+\n+        ByteBuf helloWorld = Unpooled.copiedBuffer(\"hello world\", CharsetUtil.US_ASCII);\n+        HAProxyTLV alpnTlv = new HAProxyTLV(Type.PP2_TYPE_ALPN, (byte) 0x01, helloWorld.copy());\n+        tlvs.add(alpnTlv);\n+\n+        ByteBuf arbitrary = Unpooled.copiedBuffer(\"an arbitrary string\", CharsetUtil.US_ASCII);\n+        HAProxyTLV authorityTlv = new HAProxyTLV(Type.PP2_TYPE_AUTHORITY, (byte) 0x01, arbitrary.copy());\n+        tlvs.add(authorityTlv);\n+\n+        ByteBuf sslContent = Unpooled.copiedBuffer(\"some ssl content\", CharsetUtil.US_ASCII);\n+        HAProxySSLTLV haProxySSLTLV = new HAProxySSLTLV(1, (byte) 0x01, tlvs, sslContent.copy());\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443,\n+                Collections.<HAProxyTLV>singletonList(haProxySSLTLV));\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(byteBuf.getUnsignedShort(14), byteBuf.readableBytes() - V2_HEADER_BYTES_LENGTH);\n+        ByteBuf tlv = byteBuf.skipBytes(V2_HEADER_BYTES_LENGTH + IPv4_ADDRESS_BYTES_LENGTH);\n+\n+        // ssl tlv type\n+        assertEquals(haProxySSLTLV.typeByteValue(), tlv.readByte());\n+\n+        // length\n+        int bufLength = tlv.readUnsignedShort();\n+        assertEquals(bufLength, tlv.readableBytes());\n+\n+        // client, verify\n+        assertEquals(0x01, byteBuf.readByte());\n+        assertEquals(1, byteBuf.readInt());\n+\n+        // alpn tlv\n+        assertEquals(alpnTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(helloWorld.array().length, bufLength);\n+        assertEquals(helloWorld, tlv.readBytes(bufLength));\n+\n+        // authority tlv\n+        assertEquals(authorityTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(arbitrary.array().length, bufLength);\n+        assertEquals(arbitrary, tlv.readBytes(bufLength));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MzM0OA==", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "url": "https://github.com/netty/netty/pull/10175#discussion_r405563348", "createdAt": "2020-04-08T14:21:57Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testIPv6EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x02, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(IPv6_ADDRESS_BYTES_LENGTH, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x20, (byte) 0x01, 0x0d, (byte) 0xb8,\n+                (byte) 0x85, (byte) 0xa3, 0x00, 0x00, 0x00, 0x00, (byte) 0x8a, 0x2e,\n+                0x03, 0x70, 0x73, 0x34}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 32, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x10, (byte) 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x05, 0x06, 0x00, 0x30, 0x0c, 0x32, 0x6b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(48);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(50);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testUnixEncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.UNIX_STREAM,\n+                \"/var/run/src.sock\", \"/var/run/dst.sock\", 0, 0);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x03, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(216, sourceAddrLength);\n+\n+        // source address\n+        int srcAddrEnd = byteBuf.forEachByte(16, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/src.sock\",\n+                     byteBuf.slice(16, srcAddrEnd - 16).toString(CharsetUtil.US_ASCII));\n+\n+        // destination address\n+        int dstAddrEnd = byteBuf.forEachByte(124, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/dst.sock\",\n+                     byteBuf.slice(124, dstAddrEnd - 124).toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testTLVEncodeProxy() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        List<HAProxyTLV> tlvs = new ArrayList<HAProxyTLV>();\n+\n+        ByteBuf helloWorld = Unpooled.copiedBuffer(\"hello world\", CharsetUtil.US_ASCII);\n+        HAProxyTLV alpnTlv = new HAProxyTLV(Type.PP2_TYPE_ALPN, (byte) 0x01, helloWorld.copy());\n+        tlvs.add(alpnTlv);\n+\n+        ByteBuf arbitrary = Unpooled.copiedBuffer(\"an arbitrary string\", CharsetUtil.US_ASCII);\n+        HAProxyTLV authorityTlv = new HAProxyTLV(Type.PP2_TYPE_AUTHORITY, (byte) 0x01, arbitrary.copy());\n+        tlvs.add(authorityTlv);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443, tlvs);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // length\n+        assertEquals(byteBuf.getUnsignedShort(14), byteBuf.readableBytes() - V2_HEADER_BYTES_LENGTH);\n+\n+        // skip to tlv section\n+        ByteBuf tlv = byteBuf.skipBytes(V2_HEADER_BYTES_LENGTH + IPv4_ADDRESS_BYTES_LENGTH);\n+\n+        // alpn tlv\n+        assertEquals(alpnTlv.typeByteValue(), tlv.readByte());\n+        short bufLength = tlv.readShort();\n+        assertEquals(helloWorld.array().length, bufLength);\n+        assertEquals(helloWorld, tlv.readBytes(bufLength));\n+\n+        // authority tlv\n+        assertEquals(authorityTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(arbitrary.array().length, bufLength);\n+        assertEquals(arbitrary, tlv.readBytes(bufLength));\n+    }\n+\n+    @Test\n+    public void testSslTLVEncodeProxy() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        List<HAProxyTLV> tlvs = new ArrayList<HAProxyTLV>();\n+\n+        ByteBuf helloWorld = Unpooled.copiedBuffer(\"hello world\", CharsetUtil.US_ASCII);\n+        HAProxyTLV alpnTlv = new HAProxyTLV(Type.PP2_TYPE_ALPN, (byte) 0x01, helloWorld.copy());\n+        tlvs.add(alpnTlv);\n+\n+        ByteBuf arbitrary = Unpooled.copiedBuffer(\"an arbitrary string\", CharsetUtil.US_ASCII);\n+        HAProxyTLV authorityTlv = new HAProxyTLV(Type.PP2_TYPE_AUTHORITY, (byte) 0x01, arbitrary.copy());\n+        tlvs.add(authorityTlv);\n+\n+        ByteBuf sslContent = Unpooled.copiedBuffer(\"some ssl content\", CharsetUtil.US_ASCII);\n+        HAProxySSLTLV haProxySSLTLV = new HAProxySSLTLV(1, (byte) 0x01, tlvs, sslContent.copy());\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443,\n+                Collections.<HAProxyTLV>singletonList(haProxySSLTLV));\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(byteBuf.getUnsignedShort(14), byteBuf.readableBytes() - V2_HEADER_BYTES_LENGTH);\n+        ByteBuf tlv = byteBuf.skipBytes(V2_HEADER_BYTES_LENGTH + IPv4_ADDRESS_BYTES_LENGTH);\n+\n+        // ssl tlv type\n+        assertEquals(haProxySSLTLV.typeByteValue(), tlv.readByte());\n+\n+        // length\n+        int bufLength = tlv.readUnsignedShort();\n+        assertEquals(bufLength, tlv.readableBytes());\n+\n+        // client, verify\n+        assertEquals(0x01, byteBuf.readByte());\n+        assertEquals(1, byteBuf.readInt());\n+\n+        // alpn tlv\n+        assertEquals(alpnTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(helloWorld.array().length, bufLength);\n+        assertEquals(helloWorld, tlv.readBytes(bufLength));\n+\n+        // authority tlv\n+        assertEquals(authorityTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(arbitrary.array().length, bufLength);\n+        assertEquals(arbitrary, tlv.readBytes(bufLength));\n+    }\n+\n+    @Test\n+    public void testEncodeLocalProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.LOCAL, HAProxyProxiedProtocol.UNKNOWN,\n+                null, null, 0, 0);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = new byte[12];\n+        byteBuf.readBytes(headerBytes);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.readByte();\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x00, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.readByte();\n+        assertEquals(0x00, transportByte);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.readUnsignedShort();\n+        assertEquals(0, sourceAddrLength);\n+\n+        assertFalse(byteBuf.isReadable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0"}, "originalPosition": 336}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b86a6c2e49c37b4872f075debddc06a9adcc4670", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/b86a6c2e49c37b4872f075debddc06a9adcc4670", "committedDate": "2020-04-08T15:21:50Z", "message": "add missing javadocs, ensure tests are cleaned up, etc."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjUwMTk1", "url": "https://github.com/netty/netty/pull/10175#pullrequestreview-390250195", "createdAt": "2020-04-08T19:02:12Z", "commit": {"oid": "b86a6c2e49c37b4872f075debddc06a9adcc4670"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOTowMjoxM1rOGC84aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOTowNzo0NVrOGC9ENA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0NzgxNw==", "bodyText": "I wonder why even need the StringBuilder at all. Cant you just directly write all of this to the ByteBuf step-by-step ?...", "url": "https://github.com/netty/netty/pull/10175#discussion_r405747817", "createdAt": "2020-04-08T19:02:13Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeCharSequence(sb.toString(), CharsetUtil.US_ASCII);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86a6c2e49c37b4872f075debddc06a9adcc4670"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0OTA0MQ==", "bodyText": "why you can't just use writeCharSequence(...) here ? It seems there is no need to convert to byte[] first. Same comment is true for other places.", "url": "https://github.com/netty/netty/pull/10175#discussion_r405749041", "createdAt": "2020-04-08T19:04:16Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeCharSequence(sb.toString(), CharsetUtil.US_ASCII);\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        switch (msg.proxiedProtocol().addressFamily()) {\n+            case AF_IPv4:\n+            case AF_IPv6:\n+                byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+                byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+                out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+                out.writeBytes(sourceAddress);\n+                out.writeBytes(destinationAddress);\n+                out.writeShort(msg.sourcePort());\n+                out.writeShort(msg.destinationPort());\n+                encodeTlvs(msg.tlvs(), out);\n+                break;\n+            case AF_UNIX:\n+                out.writeShort(TOTAL_UNIX_ADDRESS_BYTES_LENGTH + msg.tlvNumBytes());\n+                byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+                out.writeBytes(srcAddressBytes);\n+                out.writeBytes(new byte[UNIX_ADDRESS_BYTES_LENGTH - srcAddressBytes.length]);\n+                byte[] dstAddressBytes = msg.destinationAddress().getBytes(CharsetUtil.US_ASCII);\n+                out.writeBytes(dstAddressBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86a6c2e49c37b4872f075debddc06a9adcc4670"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0OTI4Nw==", "bodyText": "also wouldn't it be better to use out.writeZero(...) ? There is no need for this extra allocation.", "url": "https://github.com/netty/netty/pull/10175#discussion_r405749287", "createdAt": "2020-04-08T19:04:43Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeCharSequence(sb.toString(), CharsetUtil.US_ASCII);\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        switch (msg.proxiedProtocol().addressFamily()) {\n+            case AF_IPv4:\n+            case AF_IPv6:\n+                byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+                byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+                out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+                out.writeBytes(sourceAddress);\n+                out.writeBytes(destinationAddress);\n+                out.writeShort(msg.sourcePort());\n+                out.writeShort(msg.destinationPort());\n+                encodeTlvs(msg.tlvs(), out);\n+                break;\n+            case AF_UNIX:\n+                out.writeShort(TOTAL_UNIX_ADDRESS_BYTES_LENGTH + msg.tlvNumBytes());\n+                byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+                out.writeBytes(srcAddressBytes);\n+                out.writeBytes(new byte[UNIX_ADDRESS_BYTES_LENGTH - srcAddressBytes.length]);\n+                byte[] dstAddressBytes = msg.destinationAddress().getBytes(CharsetUtil.US_ASCII);\n+                out.writeBytes(dstAddressBytes);\n+                out.writeBytes(new byte[UNIX_ADDRESS_BYTES_LENGTH - dstAddressBytes.length]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86a6c2e49c37b4872f075debddc06a9adcc4670"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MDI0Nw==", "bodyText": "consider using SimpleChannelInboundHandler and just consume the message in channelRead0. This way it is correctly released without hitting the tail of the pipeline", "url": "https://github.com/netty/netty/pull/10175#discussion_r405750247", "createdAt": "2020-04-08T19:06:36Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/haproxy/HAProxyServer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.example.haproxy;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+\n+public final class HAProxyServer {\n+\n+    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n+\n+    public static void main(String[] args) throws Exception {\n+        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n+        EventLoopGroup workerGroup = new NioEventLoopGroup();\n+        try {\n+            ServerBootstrap b = new ServerBootstrap();\n+            b.group(bossGroup, workerGroup)\n+             .channel(NioServerSocketChannel.class)\n+             .handler(new LoggingHandler(LogLevel.INFO))\n+             .childHandler(new HAProxyServerInitializer());\n+            b.bind(PORT).sync().channel().closeFuture().sync();\n+        } finally {\n+            bossGroup.shutdownGracefully();\n+            workerGroup.shutdownGracefully();\n+        }\n+    }\n+\n+    static class HAProxyServerInitializer extends ChannelInitializer<SocketChannel> {\n+        @Override\n+        public void initChannel(SocketChannel ch) throws Exception {\n+            ch.pipeline().addLast(\n+                    new LoggingHandler(LogLevel.DEBUG),\n+                    new HAProxyMessageDecoder(),\n+                    new ChannelInboundHandlerAdapter() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86a6c2e49c37b4872f075debddc06a9adcc4670"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MDYyNg==", "bodyText": "imho it should just be write(...)....", "url": "https://github.com/netty/netty/pull/10175#discussion_r405750626", "createdAt": "2020-04-08T19:07:21Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/haproxy/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.example.haproxy;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProtocolException;\n+\n+public class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        if (!(msg instanceof HAProxyMessage)) {\n+            super.write(ctx, msg, promise);\n+            return;\n+        }\n+\n+        ctx.writeAndFlush(msg, promise).addListener(new ChannelFutureListener() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86a6c2e49c37b4872f075debddc06a9adcc4670"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MDgzNg==", "bodyText": "this throw makes no sense as it will be not propagated at all.", "url": "https://github.com/netty/netty/pull/10175#discussion_r405750836", "createdAt": "2020-04-08T19:07:45Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/haproxy/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.example.haproxy;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProtocolException;\n+\n+public class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        if (!(msg instanceof HAProxyMessage)) {\n+            super.write(ctx, msg, promise);\n+            return;\n+        }\n+\n+        ctx.writeAndFlush(msg, promise).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (future.isSuccess()) {\n+                    ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    ctx.pipeline().remove(HAProxyHandler.this);\n+                } else {\n+                    throw new HAProxyProtocolException(\"failed to write HAProxy message\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b86a6c2e49c37b4872f075debddc06a9adcc4670"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c51b8179281ed3b6eef2f81d5f3cd7567a97643", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/6c51b8179281ed3b6eef2f81d5f3cd7567a97643", "committedDate": "2020-04-09T13:00:00Z", "message": "prefer writeCharSequence, handle message/exception properly for test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42440498ffe755701aa883009d6916f6ee01dc97", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/42440498ffe755701aa883009d6916f6ee01dc97", "committedDate": "2020-04-09T14:07:51Z", "message": "prefer writeCharSequence for writing addresses"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwODI5MDQy", "url": "https://github.com/netty/netty/pull/10175#pullrequestreview-390829042", "createdAt": "2020-04-09T14:11:16Z", "commit": {"oid": "42440498ffe755701aa883009d6916f6ee01dc97"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNDoxMToxN1rOGDagdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNDoxMToxN1rOGDagdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMzIwNQ==", "bodyText": "you would be better of to write bytes for the know things as this will be cheaper then doing a conversation:\nout.writeByte((byte) ' ');\n\nSame comment for others.", "url": "https://github.com/netty/netty/pull/10175#discussion_r406233205", "createdAt": "2020-04-09T14:11:17Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        out.writeCharSequence(\"PROXY \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(msg.proxiedProtocol().name(), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\" \", CharsetUtil.US_ASCII);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42440498ffe755701aa883009d6916f6ee01dc97"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwODI5OTUz", "url": "https://github.com/netty/netty/pull/10175#pullrequestreview-390829953", "createdAt": "2020-04-09T14:12:15Z", "commit": {"oid": "42440498ffe755701aa883009d6916f6ee01dc97"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNDoxMjoxNVrOGDajMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNDoxMjoxNVrOGDajMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMzkwNQ==", "bodyText": "can you add a comment what the 4 is about ?", "url": "https://github.com/netty/netty/pull/10175#discussion_r406233905", "createdAt": "2020-04-09T14:12:15Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        out.writeCharSequence(\"PROXY \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(msg.proxiedProtocol().name(), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\" \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(msg.sourceAddress(), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\" \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(msg.destinationAddress(), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\" \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(String.valueOf(msg.sourcePort()), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\" \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(String.valueOf(msg.destinationPort()), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\"\\r\\n\", CharsetUtil.US_ASCII);\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        switch (msg.proxiedProtocol().addressFamily()) {\n+            case AF_IPv4:\n+            case AF_IPv6:\n+                byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+                byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+                out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42440498ffe755701aa883009d6916f6ee01dc97"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2699088dbba8bd30bb907056f70feaec0f064b31", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/2699088dbba8bd30bb907056f70feaec0f064b31", "committedDate": "2020-04-09T14:17:59Z", "message": "add comment for port length, prefer bytes for known constants"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzMxMDg4", "url": "https://github.com/netty/netty/pull/10175#pullrequestreview-392731088", "createdAt": "2020-04-14T08:55:59Z", "commit": {"oid": "2699088dbba8bd30bb907056f70feaec0f064b31"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwODo1NTo1OVrOGFEyjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOTowNTozMVrOGFFKbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3NDU0Mw==", "bodyText": "nit: not really your PRs fault but either the if statement is incorrect or the exception message in terms of allowed port range.", "url": "https://github.com/netty/netty/pull/10175#discussion_r407974543", "createdAt": "2020-04-14T08:55:59Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java", "diffHunk": "@@ -415,28 +441,41 @@ private static void checkAddress(String address, AddressFamily addrFamily) {\n         switch (addrFamily) {\n             case AF_IPv4:\n                 if (!NetUtil.isValidIpV4Address(address)) {\n-                    throw new HAProxyProtocolException(\"invalid IPv4 address: \" + address);\n+                    throw new IllegalArgumentException(\"invalid IPv4 address: \" + address);\n                 }\n                 break;\n             case AF_IPv6:\n                 if (!NetUtil.isValidIpV6Address(address)) {\n-                    throw new HAProxyProtocolException(\"invalid IPv6 address: \" + address);\n+                    throw new IllegalArgumentException(\"invalid IPv6 address: \" + address);\n                 }\n                 break;\n             default:\n-                throw new Error();\n+                throw new IllegalArgumentException(\"unexpected addrFamily: \" + addrFamily);\n         }\n     }\n \n     /**\n-     * Validate a UDP/TCP port\n+     * Validate the port depending on the addrFamily.\n      *\n      * @param port                       the UDP/TCP port\n-     * @throws HAProxyProtocolException  if the port is out of range (0-65535 inclusive)\n+     * @throws IllegalArgumentException  if the port is out of range (0-65535 inclusive)\n      */\n-    private static void checkPort(int port) {\n-        if (port < 0 || port > 65535) {\n-            throw new HAProxyProtocolException(\"invalid port: \" + port + \" (expected: 1 ~ 65535)\");\n+    private static void checkPort(int port, AddressFamily addrFamily) {\n+        switch (addrFamily) {\n+        case AF_IPv6:\n+        case AF_IPv4:\n+            if (port < 0 || port > 65535) {\n+                throw new IllegalArgumentException(\"invalid port: \" + port + \" (expected: 1 ~ 65535)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2699088dbba8bd30bb907056f70feaec0f064b31"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3NTEyNw==", "bodyText": "nit: you could move the for loop into this block as there is no need to do the loop when its empty anyway", "url": "https://github.com/netty/netty/pull/10175#discussion_r407975127", "createdAt": "2020-04-14T08:56:53Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java", "diffHunk": "@@ -556,4 +603,26 @@ protected void deallocate() {\n             }\n         }\n     }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(256)\n+                .append(StringUtil.simpleClassName(this))\n+                .append(\"(protocolVersion: \").append(protocolVersion)\n+                .append(\", command: \").append(command)\n+                .append(\", proxiedProtocol: \").append(proxiedProtocol)\n+                .append(\", sourceAddress: \").append(sourceAddress)\n+                .append(\", destinationAddress: \").append(destinationAddress)\n+                .append(\", sourcePort: \").append(sourcePort)\n+                .append(\", destinationPort: \").append(destinationPort)\n+                .append(\", tlvs: [\");\n+        for (HAProxyTLV tlv: tlvs) {\n+            sb.append(tlv).append(\", \");\n+        }\n+        if (!tlvs.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2699088dbba8bd30bb907056f70feaec0f064b31"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3NTYyNQ==", "bodyText": "nit: consider replacing by a switch statement.", "url": "https://github.com/netty/netty/pull/10175#discussion_r407975625", "createdAt": "2020-04-14T08:57:42Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2699088dbba8bd30bb907056f70feaec0f064b31"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3ODI5NQ==", "bodyText": "nit: remove final as we usually not it for params", "url": "https://github.com/netty/netty/pull/10175#discussion_r407978295", "createdAt": "2020-04-14T09:01:40Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java", "diffHunk": "@@ -74,6 +87,52 @@ public static Type typeForByteValue(final byte byteValue) {\n                 return OTHER;\n             }\n         }\n+\n+        /**\n+         * Returns the byte value for the {@link Type} as defined in the PROXY protocol 1.5 spec.\n+         *\n+         * @param type the {@link Type}\n+         *\n+         * @return the byte value of the {@link Type}.\n+         */\n+        public static byte byteValueForType(Type type) {\n+            switch (type) {\n+            case PP2_TYPE_ALPN:\n+                return 0x01;\n+            case PP2_TYPE_AUTHORITY:\n+                return 0x02;\n+            case PP2_TYPE_SSL:\n+                return 0x20;\n+            case PP2_TYPE_SSL_VERSION:\n+                return 0x21;\n+            case PP2_TYPE_SSL_CN:\n+                return 0x22;\n+            case PP2_TYPE_NETNS:\n+                return 0x30;\n+            default:\n+                throw new IllegalArgumentException(\"unknown type: \" + type);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new HAProxyTLV\n+     *\n+     * @param typeByteValue the byteValue of the TLV. This is especially important if non-standard TLVs are used\n+     * @param content the raw content of the TLV\n+     */\n+    public HAProxyTLV(final byte typeByteValue, final ByteBuf content) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2699088dbba8bd30bb907056f70feaec0f064b31"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3ODM4MA==", "bodyText": "nit: remove final as we usually not it for params", "url": "https://github.com/netty/netty/pull/10175#discussion_r407978380", "createdAt": "2020-04-14T09:01:46Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java", "diffHunk": "@@ -74,6 +87,52 @@ public static Type typeForByteValue(final byte byteValue) {\n                 return OTHER;\n             }\n         }\n+\n+        /**\n+         * Returns the byte value for the {@link Type} as defined in the PROXY protocol 1.5 spec.\n+         *\n+         * @param type the {@link Type}\n+         *\n+         * @return the byte value of the {@link Type}.\n+         */\n+        public static byte byteValueForType(Type type) {\n+            switch (type) {\n+            case PP2_TYPE_ALPN:\n+                return 0x01;\n+            case PP2_TYPE_AUTHORITY:\n+                return 0x02;\n+            case PP2_TYPE_SSL:\n+                return 0x20;\n+            case PP2_TYPE_SSL_VERSION:\n+                return 0x21;\n+            case PP2_TYPE_SSL_CN:\n+                return 0x22;\n+            case PP2_TYPE_NETNS:\n+                return 0x30;\n+            default:\n+                throw new IllegalArgumentException(\"unknown type: \" + type);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new HAProxyTLV\n+     *\n+     * @param typeByteValue the byteValue of the TLV. This is especially important if non-standard TLVs are used\n+     * @param content the raw content of the TLV\n+     */\n+    public HAProxyTLV(final byte typeByteValue, final ByteBuf content) {\n+        this(Type.typeForByteValue(typeByteValue), typeByteValue, content);\n+    }\n+\n+    /**\n+     * Creates a new HAProxyTLV\n+     *\n+     * @param type the {@link Type} of the TLV\n+     * @param content the raw content of the TLV\n+     */\n+    public HAProxyTLV(Type type, final ByteBuf content) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2699088dbba8bd30bb907056f70feaec0f064b31"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3OTcyOA==", "bodyText": "nit you could also simplify this as:\npublic void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n    ChannelFuture future = ctx.write(msg, promise);\n    if (msg instanceof HAProxyMessage) {\n        future.addListener(...)\n    }\n}", "url": "https://github.com/netty/netty/pull/10175#discussion_r407979728", "createdAt": "2020-04-14T09:03:58Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/haproxy/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.example.haproxy;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProtocolException;\n+\n+public class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        if (!(msg instanceof HAProxyMessage)) {\n+            super.write(ctx, msg, promise);\n+            return;\n+        }\n+\n+        ctx.write(msg, promise).addListener(new ChannelFutureListener() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2699088dbba8bd30bb907056f70feaec0f064b31"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4MDY1NA==", "bodyText": "I would remove this... the user will know that it failed because we fail the promise", "url": "https://github.com/netty/netty/pull/10175#discussion_r407980654", "createdAt": "2020-04-14T09:05:31Z", "author": {"login": "normanmaurer"}, "path": "example/src/main/java/io/netty/example/haproxy/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.example.haproxy;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProtocolException;\n+\n+public class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        if (!(msg instanceof HAProxyMessage)) {\n+            super.write(ctx, msg, promise);\n+            return;\n+        }\n+\n+        ctx.write(msg, promise).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (future.isSuccess()) {\n+                    ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    ctx.pipeline().remove(HAProxyHandler.this);\n+                } else {\n+                    ctx.fireExceptionCaught(new HAProxyProtocolException(\"failed to write HAProxy message\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2699088dbba8bd30bb907056f70feaec0f064b31"}, "originalPosition": 50}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e275b31d3761656af57ae8c14fd50118e2c028c8", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/e275b31d3761656af57ae8c14fd50118e2c028c8", "committedDate": "2020-04-14T13:08:53Z", "message": "better code style, prefer switch case"}, "afterCommit": {"oid": "9eab0e7e668cb1db1b396f88741c0b2076410bad", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/9eab0e7e668cb1db1b396f88741c0b2076410bad", "committedDate": "2020-04-14T13:17:05Z", "message": "no final in public params, prefer switch case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ae4b8236b5ab7d68d711a90562794436801e709", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/7ae4b8236b5ab7d68d711a90562794436801e709", "committedDate": "2020-04-14T13:24:52Z", "message": "prefer no final in public params, prefer switch case"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9eab0e7e668cb1db1b396f88741c0b2076410bad", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/9eab0e7e668cb1db1b396f88741c0b2076410bad", "committedDate": "2020-04-14T13:17:05Z", "message": "no final in public params, prefer switch case"}, "afterCommit": {"oid": "7ae4b8236b5ab7d68d711a90562794436801e709", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/7ae4b8236b5ab7d68d711a90562794436801e709", "committedDate": "2020-04-14T13:24:52Z", "message": "prefer no final in public params, prefer switch case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMDkyNzMw", "url": "https://github.com/netty/netty/pull/10175#pullrequestreview-393092730", "createdAt": "2020-04-14T16:23:42Z", "commit": {"oid": "7ae4b8236b5ab7d68d711a90562794436801e709"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjoyMzo0MlrOGFWwFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjoyMzo0MlrOGFWwFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2ODgyMg==", "bodyText": "@jrhee17 one question... isn't TEXT_PREFIX a better name ?", "url": "https://github.com/netty/netty/pull/10175#discussion_r408268822", "createdAt": "2020-04-14T16:23:42Z", "author": {"login": "normanmaurer"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyConstants.java", "diffHunk": "@@ -56,5 +56,31 @@\n     static final byte TPAF_UNIX_STREAM_BYTE = 0x31;\n     static final byte TPAF_UNIX_DGRAM_BYTE = 0x32;\n \n+    /**\n+     * V2 protocol binary header prefix\n+     */\n+    static final byte[] BINARY_PREFIX = {\n+            (byte) 0x0D,\n+            (byte) 0x0A,\n+            (byte) 0x0D,\n+            (byte) 0x0A,\n+            (byte) 0x00,\n+            (byte) 0x0D,\n+            (byte) 0x0A,\n+            (byte) 0x51,\n+            (byte) 0x55,\n+            (byte) 0x49,\n+            (byte) 0x54,\n+            (byte) 0x0A\n+    };\n+\n+    static final byte[] PROXY_PREFIX = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae4b8236b5ab7d68d711a90562794436801e709"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fccf4bf86f90f5af1180155b43edb7ea4f0185d4", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/fccf4bf86f90f5af1180155b43edb7ea4f0185d4", "committedDate": "2020-04-14T16:25:44Z", "message": "rename proxy prefix to test prefix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzOTQ3NTA3", "url": "https://github.com/netty/netty/pull/10175#pullrequestreview-393947507", "createdAt": "2020-04-15T16:38:42Z", "commit": {"oid": "fccf4bf86f90f5af1180155b43edb7ea4f0185d4"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjozODo0MlrOGGCPBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjozODo0MlrOGGCPBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4MTI1Mg==", "bodyText": "Should this catch RuntimeException?", "url": "https://github.com/netty/netty/pull/10175#discussion_r408981252", "createdAt": "2020-04-15T16:38:42Z", "author": {"login": "carl-mastrangelo"}, "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java", "diffHunk": "@@ -329,9 +347,13 @@ static HAProxyMessage decodeHeader(String header) {\n             throw new HAProxyProtocolException(\"invalid TCP4/6 header: \" + header + \" (expected: 6 parts)\");\n         }\n \n-        return new HAProxyMessage(\n-                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY,\n-                protAndFam, parts[2], parts[3], parts[4], parts[5]);\n+        try {\n+            return new HAProxyMessage(\n+                    HAProxyProtocolVersion.V1, HAProxyCommand.PROXY,\n+                    protAndFam, parts[2], parts[3], parts[4], parts[5]);\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fccf4bf86f90f5af1180155b43edb7ea4f0185d4"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d81140490986b8bab1dd816c1938bfe6be9e135", "author": {"user": {"login": "jrhee17", "name": "jrhee17"}}, "url": "https://github.com/netty/netty/commit/0d81140490986b8bab1dd816c1938bfe6be9e135", "committedDate": "2020-04-15T22:42:17Z", "message": "catch runtime exception on message creation"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 243, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}