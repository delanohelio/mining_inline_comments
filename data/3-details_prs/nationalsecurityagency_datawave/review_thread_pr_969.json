{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4MzE3OTgw", "number": 969, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDowMTo0OFrOE27oZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDowMTo0OFrOE27oZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MDM1NTU4OnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDowMTo0OFrOHv_f1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDowMTo0OFrOHv_f1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA4NTQ2MA==", "bodyText": "As it turns out, the initial implementation wraps the call to getLiteralValue with a try-catch block.  This was allowing us to handle FIELD1 =~ FIELD2 constructs correctly.  Now this visitor will simply throw an exception in that case which is not what we want.  I am fixing this in the master branch.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/969#discussion_r520085460", "createdAt": "2020-11-09T20:01:48Z", "author": {"login": "ivakegg"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java", "diffHunk": "@@ -69,22 +59,64 @@ public Object visit(ASTERNode node, Object data) {\n      */\n     @Override\n     public Object visit(ASTNRNode node, Object data) {\n-        Object literalValue;\n+        parseAndPutPattern(node);\n+        return data;\n+    }\n+    \n+    /**\n+     * Visit an ASTFunctionNode to catch cases like #INCLUDE or #EXCLUDE that accept a regex as an argument\n+     * \n+     * @param node\n+     *            - an ASTFunctionNode\n+     * @param data\n+     *            - the data\n+     * @return\n+     */\n+    @Override\n+    public Object visit(ASTFunctionNode node, Object data) {\n         \n-        // Catch the situation where a user might enter FIELD1 !~ VALUE1\n-        try {\n-            literalValue = JexlASTHelper.getLiteralValue(node);\n-        } catch (NoSuchElementException e) {\n-            return data;\n+        // Should pull back an EvaluationPhaseFilterFunctionsDescriptor\n+        JexlArgumentDescriptor descriptor = JexlFunctionArgumentDescriptorFactory.F.getArgumentDescriptor(node);\n+        if (descriptor == null) {\n+            throw new IllegalStateException(\"Could not get descriptor for ASTFunctionNode\");\n         }\n         \n+        if (descriptor.regexArguments()) {\n+            // Extract the args for this function\n+            FunctionJexlNodeVisitor functionVisitor = new FunctionJexlNodeVisitor();\n+            functionVisitor.visit(node, null);\n+            List<JexlNode> args = functionVisitor.args();\n+            for (JexlNode arg : args) {\n+                // Only take the literals\n+                if (arg instanceof ASTStringLiteral) {\n+                    parseAndPutPattern(arg);\n+                }\n+            }\n+        }\n+        // Do not descend to children, the ValidPatternVisitor views a function node as a leaf node.\n+        return data;\n+    }\n+    \n+    /**\n+     * Parse a literal value and put into the pattern cache if it does not exist.\n+     *\n+     * @param node\n+     */\n+    public void parseAndPutPattern(JexlNode node) {\n+        // Catch the situation where a user might enter FIELD1 !~ VALUE1\n+        Object literalValue = JexlASTHelper.getLiteralValue(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bafe13164594a73bc72fb5ba862ec00eb42e4ee"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4462, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}