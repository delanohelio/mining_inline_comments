{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MjI4NjM2", "number": 818, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDo0NToyMlrOD6qoig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjoyOToxOVrOD6szUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODQyNTA2OnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDo0NToyMlrOGSoH2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDo0NToyMlrOGSoH2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4NDkyMw==", "bodyText": "typo: computer", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422184923", "createdAt": "2020-05-08T14:45:22Z", "author": {"login": "keith-ratcliffe"}, "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f39f0deda142118eb78dce2c4c240f061dcfbd8"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODQzMDY5OnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDo0Njo0N1rOGSoLBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDo0Njo0N1rOGSoLBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4NTczNQ==", "bodyText": "typo: computer", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422185735", "createdAt": "2020-05-08T14:46:47Z", "author": {"login": "keith-ratcliffe"}, "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRanges(queryGeometry, byteArrayRanges, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f39f0deda142118eb78dce2c4c240f061dcfbd8"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODQzODU0OnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDo0ODo1N1rOGSoPzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDo0ODo1N1rOGSoPzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4Njk1OQ==", "bodyText": "same typo, although 'computer' as a verb is actually starting to grow on me.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422186959", "createdAt": "2020-05-08T14:48:57Z", "author": {"login": "keith-ratcliffe"}, "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRanges(queryGeometry, byteArrayRanges, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> optimizedRanges = new ArrayList<>();\n+        for (ByteArrayRange byteArrayRange : byteArrayRanges) {\n+            if (!byteArrayRange.isSingleValue()) {\n+                optimizedRanges.addAll(optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, longBuffer));\n+            } else {\n+                optimizedRanges.add(byteArrayRange);\n+            }\n+        }\n+        return optimizedRanges;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f39f0deda142118eb78dce2c4c240f061dcfbd8"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODQ1NDk1OnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDo1MzoxNFrOGSoZug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODowNToxMVrOGSueBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4OTQ5OA==", "bodyText": "same :)", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422189498", "createdAt": "2020-05-08T14:53:14Z", "author": {"login": "keith-ratcliffe"}, "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRanges(queryGeometry, byteArrayRanges, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> optimizedRanges = new ArrayList<>();\n+        for (ByteArrayRange byteArrayRange : byteArrayRanges) {\n+            if (!byteArrayRange.isSingleValue()) {\n+                optimizedRanges.addAll(optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, longBuffer));\n+            } else {\n+                optimizedRanges.add(byteArrayRange);\n+            }\n+        }\n+        return optimizedRanges;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRange(Geometry queryGeometry, ByteArrayRange byteArrayRange, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f39f0deda142118eb78dce2c4c240f061dcfbd8"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4ODkwMg==", "bodyText": "I think I'm computering the right spelling now.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422288902", "createdAt": "2020-05-08T18:05:11Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRanges(queryGeometry, byteArrayRanges, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> optimizedRanges = new ArrayList<>();\n+        for (ByteArrayRange byteArrayRange : byteArrayRanges) {\n+            if (!byteArrayRange.isSingleValue()) {\n+                optimizedRanges.addAll(optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, longBuffer));\n+            } else {\n+                optimizedRanges.add(byteArrayRange);\n+            }\n+        }\n+        return optimizedRanges;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRange(Geometry queryGeometry, ByteArrayRange byteArrayRange, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4OTQ5OA=="}, "originalCommit": {"oid": "5f39f0deda142118eb78dce2c4c240f061dcfbd8"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODc4MDMyOnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNjoyOToxOVrOGSriMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxODowNDozNlrOGSuc6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MDgxOA==", "bodyText": "Wondering if all the instances of this pattern could be consolidated into one or two helper methods, similar to your positionToGeometry function", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422240818", "createdAt": "2020-05-08T16:29:19Z", "author": {"login": "keith-ratcliffe"}, "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRanges(queryGeometry, byteArrayRanges, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> optimizedRanges = new ArrayList<>();\n+        for (ByteArrayRange byteArrayRange : byteArrayRanges) {\n+            if (!byteArrayRange.isSingleValue()) {\n+                optimizedRanges.addAll(optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, longBuffer));\n+            } else {\n+                optimizedRanges.add(byteArrayRange);\n+            }\n+        }\n+        return optimizedRanges;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRange(Geometry queryGeometry, ByteArrayRange byteArrayRange, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRange(Geometry queryGeometry, ByteArrayRange byteArrayRange, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        GeometryFactory gf = new GeometryFactory();\n+        List<ByteArrayRange> byteArrayRanges = new ArrayList<>();\n+        \n+        int tier = decodeTier(byteArrayRange.getStart());\n+        if (tier == 0) {\n+            byteArrayRanges.add(byteArrayRange);\n+        } else {\n+            longBuffer = initLongBuffer(longBuffer);\n+            \n+            long min = decodePosition(byteArrayRange.getStart(), longBuffer);\n+            long max = decodePosition(byteArrayRange.getEnd(), longBuffer);\n+            long range = max - min + 1;\n+            \n+            // It's too expensive to check every geohash in the range to see if it\n+            // intersects with the original query geometry, so we will attempt to project\n+            // this range to an equivalent range at a lower granularity tier to minimize\n+            // the number of geohashes we need to check. By doing this, we can adjust\n+            // the level of granularity used to prune our ranges.\n+            // This is controlled by modifying the chunks per range. Higher chunks per\n+            // range will achieve greater pruning, but will be more expensive to compute,\n+            // and will introduce more query ranges (which has performance implications\n+            // as well).\n+            for (int curTier = 0; curTier <= tier; curTier++) {\n+                long scale = (long) Math.pow(2.0, 2.0 * (tier - curTier));\n+                \n+                if (range >= scale) {\n+                    long scaledMin = (long) Math.ceil((double) min / scale);\n+                    long scaledMax = max / scale;\n+                    \n+                    if ((scaledMax - scaledMin + 1) >= rangeSplitThreshold) {\n+                        boolean simplifiedRanges = false;\n+                        long subRangeMin = scaledMin * scale;\n+                        long subRangeMax = Long.MIN_VALUE;\n+                        \n+                        for (long scaledPos = scaledMin; scaledPos <= scaledMax; scaledPos++) {\n+                            long nextSubRangeMax = (scaledPos * scale + scale - 1);\n+                            \n+                            if (nextSubRangeMax <= max) {\n+                                simplifiedRanges = true;\n+                                subRangeMax = nextSubRangeMax;\n+                                \n+                                // make sure that this condensed hash is within the bounds of the map\n+                                ByteArrayId scaledId = createByteArrayId(curTier, scaledPos, longBuffer);\n+                                MultiDimensionalNumericData scaledBounds = GeometryNormalizer.indexStrategy.getRangeForId(scaledId);\n+                                \n+                                // make sure that the scaled id is within the bounds of the map\n+                                // note: all cells for tiers 0 and 1 are within the bounds of the map\n+                                if (curTier <= 1 || inBounds(scaledBounds)) {\n+                                    \n+                                    Geometry scaledGeom = null;\n+                                    if (curTier <= 1) {\n+                                        // @formatter:off\n+                                        scaledGeom = gf.toGeometry(\n+                                                new Envelope(\n+                                                        scaledBounds.getMinValuesPerDimension()[0],\n+                                                        scaledBounds.getMaxValuesPerDimension()[0],\n+                                                        Math.max(-90, scaledBounds.getMinValuesPerDimension()[1]),\n+                                                        Math.min(90, scaledBounds.getMaxValuesPerDimension()[1])));\n+                                        // @formatter:on\n+                                    } else {\n+                                        // @formatter:off\n+                                        scaledGeom = gf.toGeometry(\n+                                                new Envelope(\n+                                                        scaledBounds.getMinValuesPerDimension()[0],\n+                                                        scaledBounds.getMaxValuesPerDimension()[0],\n+                                                        scaledBounds.getMinValuesPerDimension()[1],\n+                                                        scaledBounds.getMaxValuesPerDimension()[1]));\n+                                        // @formatter:on\n+                                    }\n+                                    \n+                                    // make sure that the scaled geometry intersects the original query geometry\n+                                    if (scaledGeom.intersects(queryGeometry)) {\n+                                        byteArrayRanges.add(createByteArrayRange(tier, scaledPos * scale, scaledPos * scale + scale - 1, longBuffer));\n+                                    }\n+                                }\n+                            } else {\n+                                break;\n+                            }\n+                        }\n+                        \n+                        if (simplifiedRanges) {\n+                            if (min < subRangeMin && rangeToGeometry(tier, min, subRangeMin - 1).intersects(queryGeometry)) {\n+                                byteArrayRanges.add(createByteArrayRange(tier, min, subRangeMin - 1, longBuffer));\n+                            }\n+                            \n+                            if (max > subRangeMax && rangeToGeometry(tier, subRangeMax + 1, max).intersects(queryGeometry)) {\n+                                byteArrayRanges.add(createByteArrayRange(tier, subRangeMax + 1, max, longBuffer));\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            \n+            if (byteArrayRanges.isEmpty()) {\n+                if (rangeToGeometry(tier, min, max).intersects(queryGeometry))\n+                    byteArrayRanges.add(byteArrayRange);\n+            } else {\n+                if (byteArrayRanges.size() > 1)\n+                    byteArrayRanges = mergeContiguousRanges(byteArrayRanges, longBuffer);\n+                if (!byteArrayRanges.isEmpty())\n+                    byteArrayRanges = splitLargeRanges(byteArrayRanges, queryGeometry, maxRangeOverlap, longBuffer);\n+            }\n+        }\n+        \n+        return byteArrayRanges;\n+    }\n+    \n+    /**\n+     * Merges contiguous ranges in the list - assumes that the list of ranges is already sorted\n+     * \n+     * @param byteArrayRanges\n+     *            the sorted list of ranges to merge\n+     * @return a list of merged ranges\n+     */\n+    public static List<ByteArrayRange> mergeContiguousRanges(List<ByteArrayRange> byteArrayRanges) {\n+        return mergeContiguousRanges(byteArrayRanges, null);\n+    }\n+    \n+    /**\n+     * Merges contiguous ranges in the list - assumes that the list of ranges is already sorted\n+     * \n+     * @param byteArrayRanges\n+     *            the sorted list of ranges to merge\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of merged ranges\n+     */\n+    public static List<ByteArrayRange> mergeContiguousRanges(List<ByteArrayRange> byteArrayRanges, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> mergedByteArrayRanges = new ArrayList<>(byteArrayRanges.size());\n+        ByteArrayRange currentRange = null;\n+        \n+        for (ByteArrayRange range : byteArrayRanges) {\n+            if (currentRange == null) {\n+                currentRange = range;\n+            } else {\n+                long currentMax = decodePosition(currentRange.getEnd(), longBuffer);\n+                long nextMin = decodePosition(range.getStart(), longBuffer);\n+                \n+                if ((currentMax + 1) == nextMin) {\n+                    currentRange = new ByteArrayRange(currentRange.getStart(), range.getEnd(), false);\n+                } else {\n+                    mergedByteArrayRanges.add(currentRange);\n+                    currentRange = range;\n+                }\n+            }\n+        }\n+        \n+        if (currentRange != null) {\n+            mergedByteArrayRanges.add(currentRange);\n+        }\n+        \n+        return mergedByteArrayRanges;\n+    }\n+    \n+    /**\n+     * Splits ranges whose area overlaps more than maxRangeOverlap of the area of the queryGeometry envelope.\n+     * \n+     * @param byteArrayRanges\n+     *            the list of ranges to split\n+     * @param queryGeometry\n+     *            the original query geometry\n+     * @param maxRangeOverlap\n+     *            the maximum percentage overlap allowed for a range compared to the envelope of the original query geometry\n+     * @return a list of ranges, each of which overlaps less than maxRangeOverlap of the original query geometry\n+     */\n+    public static List<ByteArrayRange> splitLargeRanges(List<ByteArrayRange> byteArrayRanges, Geometry queryGeometry, double maxRangeOverlap) {\n+        return splitLargeRanges(byteArrayRanges, queryGeometry, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Splits ranges whose area overlaps more than maxRangeOverlap of the area of the queryGeometry envelope.\n+     * \n+     * @param byteArrayRanges\n+     *            the list of ranges to split\n+     * @param queryGeometry\n+     *            the original query geometry\n+     * @param maxRangeOverlap\n+     *            the maximum percentage overlap allowed for a range compared to the envelope of the original query geometry\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of ranges, each of which overlaps less than maxRangeOverlap of the original query geometry\n+     */\n+    public static List<ByteArrayRange> splitLargeRanges(List<ByteArrayRange> byteArrayRanges, Geometry queryGeometry, double maxRangeOverlap,\n+                    ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> splitByteArrayRanges = new ArrayList<>();\n+        \n+        for (ByteArrayRange range : byteArrayRanges) {\n+            int tier = decodeTier(range.getStart());\n+            long min = decodePosition(range.getStart(), longBuffer);\n+            long max = decodePosition(range.getEnd(), longBuffer);\n+            \n+            Geometry rangeGeometry = rangeToGeometry(tier, min, max);\n+            if (rangeGeometry.getArea() > maxRangeOverlap * queryGeometry.getEnvelope().getArea()) {\n+                int numSubRanges = (int) (rangeGeometry.getArea() / (maxRangeOverlap * queryGeometry.getEnvelope().getArea())) + 1;\n+                long offset = (max - min) / numSubRanges;\n+                \n+                for (int i = 0; i < numSubRanges; i++) {\n+                    long subMax = ((i + 1) == numSubRanges) ? max : min + (i + 1) * offset - 1;\n+                    splitByteArrayRanges.add(createByteArrayRange(tier, min + i * offset, subMax, longBuffer));\n+                }\n+            } else {\n+                splitByteArrayRanges.add(range);\n+            }\n+        }\n+        return splitByteArrayRanges;\n+    }\n+    \n+    /**\n+     * Extracts the tier from the GeoWave geohash\n+     *\n+     * @param geohash\n+     * @return\n+     */\n+    public static int decodeTier(String geohash) {\n+        return Integer.parseInt(geohash.substring(0, 2), 16);\n+    }\n+    \n+    /**\n+     * Extracts the tier from the byteArrayId\n+     * \n+     * @param byteArrayId\n+     * @return\n+     */\n+    public static int decodeTier(ByteArrayId byteArrayId) {\n+        return byteArrayId.getBytes()[0];\n+    }\n+    \n+    /**\n+     * Extracts the position from the GeoWave geohash\n+     * \n+     * @param geohash\n+     * @return\n+     */\n+    public static long decodePosition(String geohash) {\n+        return geohash.equals(\"00\") ? 0L : Long.parseLong(geohash.substring(2), 16);\n+    }\n+    \n+    /**\n+     * Extracts the position from the byteArrayId\n+     * \n+     * @param byteArrayId\n+     * @return\n+     */\n+    public static long decodePosition(ByteArrayId byteArrayId) {\n+        return decodePosition(byteArrayId, null);\n+    }\n+    \n+    /**\n+     * Extracts the position from the byteArrayId\n+     * \n+     * @param byteArrayId\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static long decodePosition(ByteArrayId byteArrayId, ByteBuffer longBuffer) {\n+        if (byteArrayId.getBytes()[0] != (byte) 0) {\n+            longBuffer = initLongBuffer(longBuffer);\n+            \n+            for (int i = 0; i < (Long.BYTES - (byteArrayId.getBytes().length - 1)); i++)\n+                longBuffer.put((byte) 0);\n+            \n+            longBuffer.put(byteArrayId.getBytes(), 1, byteArrayId.getBytes().length - 1);\n+            return longBuffer.getLong(0);\n+        } else {\n+            return 0L;\n+        }\n+    }\n+    \n+    /**\n+     * Determines the number of hex characters needed to represent a position at a given tier. This excludes the byte reserved for the tier identifier.\n+     * \n+     * @param tier\n+     * @return\n+     */\n+    public static int hexCharsPerTier(int tier) {\n+        String hexString = String.format(\"%X\", ((long) Math.pow(2.0, tier) - 1));\n+        if (Long.parseLong(hexString, 16) == 0)\n+            return 0;\n+        else\n+            return hexString.length() * 2;\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given GeoWave geohash\n+     * \n+     * @param geohash\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(String geohash) {\n+        return createByteArrayId(geohash, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given tier and position\n+     *\n+     * @param tier\n+     * @param position\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(int tier, long position) {\n+        return createByteArrayId(tier, position, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given GeoWave geohash\n+     * \n+     * @param geohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(String geohash, ByteBuffer longBuffer) {\n+        return createByteArrayId(decodeTier(geohash), decodePosition(geohash), longBuffer);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given tier and position\n+     * \n+     * @param tier\n+     * @param position\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(int tier, long position, ByteBuffer longBuffer) {\n+        if (tier != 0) {\n+            longBuffer = initLongBuffer(longBuffer);\n+            \n+            ByteBuffer buffer = ByteBuffer.allocate(hexCharsPerTier(tier) / 2 + 1);\n+            buffer.put((byte) tier);\n+            longBuffer.putLong(position);\n+            buffer.put(longBuffer.array(), longBuffer.capacity() - buffer.remaining(), buffer.remaining());\n+            \n+            return new ByteArrayId(buffer.array());\n+        } else {\n+            return new ByteArrayId(new byte[] {0});\n+        }\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given start and end GeoWave geohashes\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(String startGeohash, String endGeohash) {\n+        return createByteArrayRange(startGeohash, endGeohash, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given tier, and min and max positions\n+     * \n+     * @param tier\n+     * @param min\n+     * @param max\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(int tier, long min, long max) {\n+        return createByteArrayRange(tier, min, max, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given start and end GeoWave geohashes\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(String startGeohash, String endGeohash, ByteBuffer longBuffer) {\n+        return createByteArrayRange(decodeTier(startGeohash), decodePosition(startGeohash), decodePosition(endGeohash), longBuffer);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given tier, and min and max positions\n+     * \n+     * @param tier\n+     * @param min\n+     * @param max\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(int tier, long min, long max, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        return new ByteArrayRange(createByteArrayId(tier, min, longBuffer), createByteArrayId(tier, max, longBuffer), min == max);\n+    }\n+    \n+    /**\n+     * Determines whether the given bounds are within the bounds of the map.\n+     * \n+     * @param bounds\n+     * @return\n+     */\n+    private static boolean inBounds(MultiDimensionalNumericData bounds) {\n+        // @formatter:off\n+        return bounds.getMinValuesPerDimension()[0] >= -180 && bounds.getMinValuesPerDimension()[0] <= 180 &&\n+                bounds.getMaxValuesPerDimension()[0] >= -180 && bounds.getMaxValuesPerDimension()[0] <= 180 &&\n+                bounds.getMinValuesPerDimension()[1] >= -90 && bounds.getMinValuesPerDimension()[1] <= 90 &&\n+                bounds.getMaxValuesPerDimension()[1] >= -90 && bounds.getMaxValuesPerDimension()[1] <= 90;\n+        // @formatter:on\n+    }\n+    \n+    /**\n+     * Given a GeoWave geohash position, this will generate a Geometry which represents that position.\n+     * \n+     * @param geohash\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(String geohash) {\n+        return positionToGeometry(geohash, null);\n+    }\n+    \n+    /**\n+     * Given a position at a given tier, this will generate a Geometry which represents that position.\n+     * \n+     * @param tier\n+     * @param position\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(int tier, long position) {\n+        return positionToGeometry(tier, position, null);\n+    }\n+    \n+    /**\n+     * Given a GeoWave geohash position, this will generate a Geometry which represents that position.\n+     * \n+     * @param geohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(String geohash, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        return positionToGeometry(createByteArrayId(geohash, longBuffer));\n+    }\n+    \n+    /**\n+     * Given a position at a given tier, this will generate a Geometry which represents that position.\n+     * \n+     * @param tier\n+     * @param position\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(int tier, long position, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        return positionToGeometry(createByteArrayId(tier, position, longBuffer));\n+    }\n+    \n+    /**\n+     * Given a byteArrayId, this will generate a Geometry which represents that position.\n+     * \n+     * @param byteArrayId\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(ByteArrayId byteArrayId) {\n+        MultiDimensionalNumericData bounds = GeometryNormalizer.indexStrategy.getRangeForId(byteArrayId);\n+        \n+        if (decodeTier(byteArrayId) <= 1) {\n+            // @formatter:off\n+            return new GeometryFactory().toGeometry(\n+                    new Envelope(\n+                            bounds.getMinValuesPerDimension()[0],\n+                            bounds.getMaxValuesPerDimension()[0],\n+                            Math.max(-90, bounds.getMinValuesPerDimension()[1]),\n+                            Math.min(90, bounds.getMaxValuesPerDimension()[1])));\n+            // @formatter:on\n+        } else {\n+            // @formatter:off\n+            return new GeometryFactory().toGeometry(\n+                    new Envelope(\n+                            bounds.getMinValuesPerDimension()[0],\n+                            bounds.getMaxValuesPerDimension()[0],\n+                            bounds.getMinValuesPerDimension()[1],\n+                            bounds.getMaxValuesPerDimension()[1]));\n+            // @formatter:on\n+        }\n+    }\n+    \n+    /**\n+     * Given a range defined by the start and end geohashes, this will generate a Geometry which represents that range.\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(String startGeohash, String endGeohash) {\n+        return rangeToGeometry(startGeohash, endGeohash, null);\n+    }\n+    \n+    /**\n+     * Given a range defined by the start and end geohashes, this will generate a Geometry which represents that range.\n+     * \n+     * @param byteArrayRange\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(ByteArrayRange byteArrayRange) {\n+        return rangeToGeometry(byteArrayRange, null);\n+    }\n+    \n+    /**\n+     * Given a range at a given tier, this will generate a Geometry which represents that range.\n+     *\n+     * @param tier\n+     * @param start\n+     * @param end\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(int tier, long start, long end) {\n+        return rangeToGeometry(tier, start, end, null);\n+    }\n+    \n+    /**\n+     * Given a range defined by the start and end geohashes, this will generate a Geometry which represents that range.\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(String startGeohash, String endGeohash, ByteBuffer longBuffer) {\n+        return rangeToGeometry(decodeTier(startGeohash), decodePosition(startGeohash), decodePosition(endGeohash), longBuffer);\n+    }\n+    \n+    /**\n+     * Given a range defined by byteArrayRange, this will generate a Geometry which represents that range.\n+     * \n+     * @param byteArrayRange\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(ByteArrayRange byteArrayRange, ByteBuffer longBuffer) {\n+        return rangeToGeometry(decodeTier(byteArrayRange.getStart()), decodePosition(byteArrayRange.getStart()), decodePosition(byteArrayRange.getEnd()),\n+                        longBuffer);\n+    }\n+    \n+    /**\n+     * Given a range at a given tier, this will generate a Geometry which represents that range.\n+     * \n+     * @param tier\n+     * @param start\n+     * @param end\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(int tier, long start, long end, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        GeometryFactory gf = new GeometryFactory();\n+        \n+        List<ByteArrayId> byteArrayIds = decomposeRange(tier, start, end, longBuffer);\n+        \n+        List<Geometry> geometries = new ArrayList<>(byteArrayIds.size());\n+        for (ByteArrayId byteArrayId : byteArrayIds) {\n+            MultiDimensionalNumericData bounds = GeometryNormalizer.indexStrategy.getRangeForId(byteArrayId);\n+            \n+            if (decodeTier(byteArrayId) <= 1) {\n+                // @formatter:off\n+                geometries.add(gf.toGeometry(\n+                        new Envelope(\n+                                bounds.getMinValuesPerDimension()[0],\n+                                bounds.getMaxValuesPerDimension()[0],\n+                                Math.max(-90, bounds.getMinValuesPerDimension()[1]),\n+                                Math.min(90, bounds.getMaxValuesPerDimension()[1]))));\n+                // @formatter:on\n+            } else if (inBounds(bounds)) {\n+                // @formatter:off\n+                geometries.add(gf.toGeometry(\n+                        new Envelope(\n+                                bounds.getMinValuesPerDimension()[0],\n+                                bounds.getMaxValuesPerDimension()[0],\n+                                bounds.getMinValuesPerDimension()[1],\n+                                bounds.getMaxValuesPerDimension()[1])));\n+                // @formatter:on\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f39f0deda142118eb78dce2c4c240f061dcfbd8"}, "originalPosition": 740}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4ODYxOQ==", "bodyText": "I think the latest commit has this covered.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/818#discussion_r422288619", "createdAt": "2020-05-08T18:04:36Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/util/GeoWaveUtils.java", "diffHunk": "@@ -0,0 +1,860 @@\n+package datawave.query.util;\n+\n+import com.vividsolutions.jts.geom.Envelope;\n+import com.vividsolutions.jts.geom.Geometry;\n+import com.vividsolutions.jts.geom.GeometryCollection;\n+import com.vividsolutions.jts.geom.GeometryFactory;\n+import com.vividsolutions.jts.geom.Polygon;\n+import datawave.data.normalizer.GeometryNormalizer;\n+import mil.nga.giat.geowave.core.index.ByteArrayId;\n+import mil.nga.giat.geowave.core.index.ByteArrayRange;\n+import mil.nga.giat.geowave.core.index.sfc.data.MultiDimensionalNumericData;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * This utility class contains a variety of methods perform operations on GeoWave ranges.\n+ *\n+ * These methods assume that a full incremental tiered index strategy is being used, with a maximum of 31 bits per dimension, and using the Hilbert\n+ * Space-Filling Curve. No guarantees are made as to the effectiveness or accuracy of these methods given any other configuration.\n+ */\n+public class GeoWaveUtils {\n+    \n+    /**\n+     * This is a convenience class used within decomposeRange.\n+     */\n+    private static class TierMinMax {\n+        public int tier;\n+        public long min;\n+        public long max;\n+        \n+        public TierMinMax(int tier, long min, long max) {\n+            this.tier = tier;\n+            this.min = min;\n+            this.max = max;\n+        }\n+    }\n+    \n+    /**\n+     * Ensures that the byte buffer is the right size, and has been cleared.\n+     * \n+     * @param longBuffer\n+     * @return\n+     */\n+    private static ByteBuffer initLongBuffer(ByteBuffer longBuffer) {\n+        longBuffer = (longBuffer != null && longBuffer.array().length == Long.BYTES) ? longBuffer : ByteBuffer.allocate(Long.BYTES);\n+        longBuffer.clear();\n+        \n+        return longBuffer;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRanges(queryGeometry, byteArrayRanges, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRanges\n+     *            the original byte array ranges generated for the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRanges(Geometry queryGeometry, List<ByteArrayRange> byteArrayRanges, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> optimizedRanges = new ArrayList<>();\n+        for (ByteArrayRange byteArrayRange : byteArrayRanges) {\n+            if (!byteArrayRange.isSingleValue()) {\n+                optimizedRanges.addAll(optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, longBuffer));\n+            } else {\n+                optimizedRanges.add(byteArrayRange);\n+            }\n+        }\n+        return optimizedRanges;\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     *\n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRange(Geometry queryGeometry, ByteArrayRange byteArrayRange, int rangeSplitThreshold,\n+                    double maxRangeOverlap) {\n+        return optimizeByteArrayRange(queryGeometry, byteArrayRange, rangeSplitThreshold, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Optimizes the list of byte array ranges needed to query the desired area. Portions of each range which do not intersect the original query polygon will\n+     * be pruned out.\n+     * \n+     * @param queryGeometry\n+     *            the original query geometry used to create the list of byte array ranges\n+     * @param byteArrayRange\n+     *            a byte array range representing a portion of the query geometry\n+     * @param rangeSplitThreshold\n+     *            used to determine the minimum number of segments to break a range into - higher values will take longer to computer, but will yield tighter\n+     *            ranges\n+     * @param maxRangeOverlap\n+     *            the maximum amount of overlap a range is allowed to have compared to the envelope of the query geometry - expressed as a double between 0 and\n+     *            1.\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of optimized byte array ranges\n+     */\n+    public static List<ByteArrayRange> optimizeByteArrayRange(Geometry queryGeometry, ByteArrayRange byteArrayRange, int rangeSplitThreshold,\n+                    double maxRangeOverlap, ByteBuffer longBuffer) {\n+        GeometryFactory gf = new GeometryFactory();\n+        List<ByteArrayRange> byteArrayRanges = new ArrayList<>();\n+        \n+        int tier = decodeTier(byteArrayRange.getStart());\n+        if (tier == 0) {\n+            byteArrayRanges.add(byteArrayRange);\n+        } else {\n+            longBuffer = initLongBuffer(longBuffer);\n+            \n+            long min = decodePosition(byteArrayRange.getStart(), longBuffer);\n+            long max = decodePosition(byteArrayRange.getEnd(), longBuffer);\n+            long range = max - min + 1;\n+            \n+            // It's too expensive to check every geohash in the range to see if it\n+            // intersects with the original query geometry, so we will attempt to project\n+            // this range to an equivalent range at a lower granularity tier to minimize\n+            // the number of geohashes we need to check. By doing this, we can adjust\n+            // the level of granularity used to prune our ranges.\n+            // This is controlled by modifying the chunks per range. Higher chunks per\n+            // range will achieve greater pruning, but will be more expensive to compute,\n+            // and will introduce more query ranges (which has performance implications\n+            // as well).\n+            for (int curTier = 0; curTier <= tier; curTier++) {\n+                long scale = (long) Math.pow(2.0, 2.0 * (tier - curTier));\n+                \n+                if (range >= scale) {\n+                    long scaledMin = (long) Math.ceil((double) min / scale);\n+                    long scaledMax = max / scale;\n+                    \n+                    if ((scaledMax - scaledMin + 1) >= rangeSplitThreshold) {\n+                        boolean simplifiedRanges = false;\n+                        long subRangeMin = scaledMin * scale;\n+                        long subRangeMax = Long.MIN_VALUE;\n+                        \n+                        for (long scaledPos = scaledMin; scaledPos <= scaledMax; scaledPos++) {\n+                            long nextSubRangeMax = (scaledPos * scale + scale - 1);\n+                            \n+                            if (nextSubRangeMax <= max) {\n+                                simplifiedRanges = true;\n+                                subRangeMax = nextSubRangeMax;\n+                                \n+                                // make sure that this condensed hash is within the bounds of the map\n+                                ByteArrayId scaledId = createByteArrayId(curTier, scaledPos, longBuffer);\n+                                MultiDimensionalNumericData scaledBounds = GeometryNormalizer.indexStrategy.getRangeForId(scaledId);\n+                                \n+                                // make sure that the scaled id is within the bounds of the map\n+                                // note: all cells for tiers 0 and 1 are within the bounds of the map\n+                                if (curTier <= 1 || inBounds(scaledBounds)) {\n+                                    \n+                                    Geometry scaledGeom = null;\n+                                    if (curTier <= 1) {\n+                                        // @formatter:off\n+                                        scaledGeom = gf.toGeometry(\n+                                                new Envelope(\n+                                                        scaledBounds.getMinValuesPerDimension()[0],\n+                                                        scaledBounds.getMaxValuesPerDimension()[0],\n+                                                        Math.max(-90, scaledBounds.getMinValuesPerDimension()[1]),\n+                                                        Math.min(90, scaledBounds.getMaxValuesPerDimension()[1])));\n+                                        // @formatter:on\n+                                    } else {\n+                                        // @formatter:off\n+                                        scaledGeom = gf.toGeometry(\n+                                                new Envelope(\n+                                                        scaledBounds.getMinValuesPerDimension()[0],\n+                                                        scaledBounds.getMaxValuesPerDimension()[0],\n+                                                        scaledBounds.getMinValuesPerDimension()[1],\n+                                                        scaledBounds.getMaxValuesPerDimension()[1]));\n+                                        // @formatter:on\n+                                    }\n+                                    \n+                                    // make sure that the scaled geometry intersects the original query geometry\n+                                    if (scaledGeom.intersects(queryGeometry)) {\n+                                        byteArrayRanges.add(createByteArrayRange(tier, scaledPos * scale, scaledPos * scale + scale - 1, longBuffer));\n+                                    }\n+                                }\n+                            } else {\n+                                break;\n+                            }\n+                        }\n+                        \n+                        if (simplifiedRanges) {\n+                            if (min < subRangeMin && rangeToGeometry(tier, min, subRangeMin - 1).intersects(queryGeometry)) {\n+                                byteArrayRanges.add(createByteArrayRange(tier, min, subRangeMin - 1, longBuffer));\n+                            }\n+                            \n+                            if (max > subRangeMax && rangeToGeometry(tier, subRangeMax + 1, max).intersects(queryGeometry)) {\n+                                byteArrayRanges.add(createByteArrayRange(tier, subRangeMax + 1, max, longBuffer));\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            \n+            if (byteArrayRanges.isEmpty()) {\n+                if (rangeToGeometry(tier, min, max).intersects(queryGeometry))\n+                    byteArrayRanges.add(byteArrayRange);\n+            } else {\n+                if (byteArrayRanges.size() > 1)\n+                    byteArrayRanges = mergeContiguousRanges(byteArrayRanges, longBuffer);\n+                if (!byteArrayRanges.isEmpty())\n+                    byteArrayRanges = splitLargeRanges(byteArrayRanges, queryGeometry, maxRangeOverlap, longBuffer);\n+            }\n+        }\n+        \n+        return byteArrayRanges;\n+    }\n+    \n+    /**\n+     * Merges contiguous ranges in the list - assumes that the list of ranges is already sorted\n+     * \n+     * @param byteArrayRanges\n+     *            the sorted list of ranges to merge\n+     * @return a list of merged ranges\n+     */\n+    public static List<ByteArrayRange> mergeContiguousRanges(List<ByteArrayRange> byteArrayRanges) {\n+        return mergeContiguousRanges(byteArrayRanges, null);\n+    }\n+    \n+    /**\n+     * Merges contiguous ranges in the list - assumes that the list of ranges is already sorted\n+     * \n+     * @param byteArrayRanges\n+     *            the sorted list of ranges to merge\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of merged ranges\n+     */\n+    public static List<ByteArrayRange> mergeContiguousRanges(List<ByteArrayRange> byteArrayRanges, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> mergedByteArrayRanges = new ArrayList<>(byteArrayRanges.size());\n+        ByteArrayRange currentRange = null;\n+        \n+        for (ByteArrayRange range : byteArrayRanges) {\n+            if (currentRange == null) {\n+                currentRange = range;\n+            } else {\n+                long currentMax = decodePosition(currentRange.getEnd(), longBuffer);\n+                long nextMin = decodePosition(range.getStart(), longBuffer);\n+                \n+                if ((currentMax + 1) == nextMin) {\n+                    currentRange = new ByteArrayRange(currentRange.getStart(), range.getEnd(), false);\n+                } else {\n+                    mergedByteArrayRanges.add(currentRange);\n+                    currentRange = range;\n+                }\n+            }\n+        }\n+        \n+        if (currentRange != null) {\n+            mergedByteArrayRanges.add(currentRange);\n+        }\n+        \n+        return mergedByteArrayRanges;\n+    }\n+    \n+    /**\n+     * Splits ranges whose area overlaps more than maxRangeOverlap of the area of the queryGeometry envelope.\n+     * \n+     * @param byteArrayRanges\n+     *            the list of ranges to split\n+     * @param queryGeometry\n+     *            the original query geometry\n+     * @param maxRangeOverlap\n+     *            the maximum percentage overlap allowed for a range compared to the envelope of the original query geometry\n+     * @return a list of ranges, each of which overlaps less than maxRangeOverlap of the original query geometry\n+     */\n+    public static List<ByteArrayRange> splitLargeRanges(List<ByteArrayRange> byteArrayRanges, Geometry queryGeometry, double maxRangeOverlap) {\n+        return splitLargeRanges(byteArrayRanges, queryGeometry, maxRangeOverlap, null);\n+    }\n+    \n+    /**\n+     * Splits ranges whose area overlaps more than maxRangeOverlap of the area of the queryGeometry envelope.\n+     * \n+     * @param byteArrayRanges\n+     *            the list of ranges to split\n+     * @param queryGeometry\n+     *            the original query geometry\n+     * @param maxRangeOverlap\n+     *            the maximum percentage overlap allowed for a range compared to the envelope of the original query geometry\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return a list of ranges, each of which overlaps less than maxRangeOverlap of the original query geometry\n+     */\n+    public static List<ByteArrayRange> splitLargeRanges(List<ByteArrayRange> byteArrayRanges, Geometry queryGeometry, double maxRangeOverlap,\n+                    ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        List<ByteArrayRange> splitByteArrayRanges = new ArrayList<>();\n+        \n+        for (ByteArrayRange range : byteArrayRanges) {\n+            int tier = decodeTier(range.getStart());\n+            long min = decodePosition(range.getStart(), longBuffer);\n+            long max = decodePosition(range.getEnd(), longBuffer);\n+            \n+            Geometry rangeGeometry = rangeToGeometry(tier, min, max);\n+            if (rangeGeometry.getArea() > maxRangeOverlap * queryGeometry.getEnvelope().getArea()) {\n+                int numSubRanges = (int) (rangeGeometry.getArea() / (maxRangeOverlap * queryGeometry.getEnvelope().getArea())) + 1;\n+                long offset = (max - min) / numSubRanges;\n+                \n+                for (int i = 0; i < numSubRanges; i++) {\n+                    long subMax = ((i + 1) == numSubRanges) ? max : min + (i + 1) * offset - 1;\n+                    splitByteArrayRanges.add(createByteArrayRange(tier, min + i * offset, subMax, longBuffer));\n+                }\n+            } else {\n+                splitByteArrayRanges.add(range);\n+            }\n+        }\n+        return splitByteArrayRanges;\n+    }\n+    \n+    /**\n+     * Extracts the tier from the GeoWave geohash\n+     *\n+     * @param geohash\n+     * @return\n+     */\n+    public static int decodeTier(String geohash) {\n+        return Integer.parseInt(geohash.substring(0, 2), 16);\n+    }\n+    \n+    /**\n+     * Extracts the tier from the byteArrayId\n+     * \n+     * @param byteArrayId\n+     * @return\n+     */\n+    public static int decodeTier(ByteArrayId byteArrayId) {\n+        return byteArrayId.getBytes()[0];\n+    }\n+    \n+    /**\n+     * Extracts the position from the GeoWave geohash\n+     * \n+     * @param geohash\n+     * @return\n+     */\n+    public static long decodePosition(String geohash) {\n+        return geohash.equals(\"00\") ? 0L : Long.parseLong(geohash.substring(2), 16);\n+    }\n+    \n+    /**\n+     * Extracts the position from the byteArrayId\n+     * \n+     * @param byteArrayId\n+     * @return\n+     */\n+    public static long decodePosition(ByteArrayId byteArrayId) {\n+        return decodePosition(byteArrayId, null);\n+    }\n+    \n+    /**\n+     * Extracts the position from the byteArrayId\n+     * \n+     * @param byteArrayId\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static long decodePosition(ByteArrayId byteArrayId, ByteBuffer longBuffer) {\n+        if (byteArrayId.getBytes()[0] != (byte) 0) {\n+            longBuffer = initLongBuffer(longBuffer);\n+            \n+            for (int i = 0; i < (Long.BYTES - (byteArrayId.getBytes().length - 1)); i++)\n+                longBuffer.put((byte) 0);\n+            \n+            longBuffer.put(byteArrayId.getBytes(), 1, byteArrayId.getBytes().length - 1);\n+            return longBuffer.getLong(0);\n+        } else {\n+            return 0L;\n+        }\n+    }\n+    \n+    /**\n+     * Determines the number of hex characters needed to represent a position at a given tier. This excludes the byte reserved for the tier identifier.\n+     * \n+     * @param tier\n+     * @return\n+     */\n+    public static int hexCharsPerTier(int tier) {\n+        String hexString = String.format(\"%X\", ((long) Math.pow(2.0, tier) - 1));\n+        if (Long.parseLong(hexString, 16) == 0)\n+            return 0;\n+        else\n+            return hexString.length() * 2;\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given GeoWave geohash\n+     * \n+     * @param geohash\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(String geohash) {\n+        return createByteArrayId(geohash, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given tier and position\n+     *\n+     * @param tier\n+     * @param position\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(int tier, long position) {\n+        return createByteArrayId(tier, position, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given GeoWave geohash\n+     * \n+     * @param geohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(String geohash, ByteBuffer longBuffer) {\n+        return createByteArrayId(decodeTier(geohash), decodePosition(geohash), longBuffer);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayId from the given tier and position\n+     * \n+     * @param tier\n+     * @param position\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayId createByteArrayId(int tier, long position, ByteBuffer longBuffer) {\n+        if (tier != 0) {\n+            longBuffer = initLongBuffer(longBuffer);\n+            \n+            ByteBuffer buffer = ByteBuffer.allocate(hexCharsPerTier(tier) / 2 + 1);\n+            buffer.put((byte) tier);\n+            longBuffer.putLong(position);\n+            buffer.put(longBuffer.array(), longBuffer.capacity() - buffer.remaining(), buffer.remaining());\n+            \n+            return new ByteArrayId(buffer.array());\n+        } else {\n+            return new ByteArrayId(new byte[] {0});\n+        }\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given start and end GeoWave geohashes\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(String startGeohash, String endGeohash) {\n+        return createByteArrayRange(startGeohash, endGeohash, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given tier, and min and max positions\n+     * \n+     * @param tier\n+     * @param min\n+     * @param max\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(int tier, long min, long max) {\n+        return createByteArrayRange(tier, min, max, null);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given start and end GeoWave geohashes\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(String startGeohash, String endGeohash, ByteBuffer longBuffer) {\n+        return createByteArrayRange(decodeTier(startGeohash), decodePosition(startGeohash), decodePosition(endGeohash), longBuffer);\n+    }\n+    \n+    /**\n+     * Creates a ByteArrayRange from the given tier, and min and max positions\n+     * \n+     * @param tier\n+     * @param min\n+     * @param max\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static ByteArrayRange createByteArrayRange(int tier, long min, long max, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        return new ByteArrayRange(createByteArrayId(tier, min, longBuffer), createByteArrayId(tier, max, longBuffer), min == max);\n+    }\n+    \n+    /**\n+     * Determines whether the given bounds are within the bounds of the map.\n+     * \n+     * @param bounds\n+     * @return\n+     */\n+    private static boolean inBounds(MultiDimensionalNumericData bounds) {\n+        // @formatter:off\n+        return bounds.getMinValuesPerDimension()[0] >= -180 && bounds.getMinValuesPerDimension()[0] <= 180 &&\n+                bounds.getMaxValuesPerDimension()[0] >= -180 && bounds.getMaxValuesPerDimension()[0] <= 180 &&\n+                bounds.getMinValuesPerDimension()[1] >= -90 && bounds.getMinValuesPerDimension()[1] <= 90 &&\n+                bounds.getMaxValuesPerDimension()[1] >= -90 && bounds.getMaxValuesPerDimension()[1] <= 90;\n+        // @formatter:on\n+    }\n+    \n+    /**\n+     * Given a GeoWave geohash position, this will generate a Geometry which represents that position.\n+     * \n+     * @param geohash\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(String geohash) {\n+        return positionToGeometry(geohash, null);\n+    }\n+    \n+    /**\n+     * Given a position at a given tier, this will generate a Geometry which represents that position.\n+     * \n+     * @param tier\n+     * @param position\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(int tier, long position) {\n+        return positionToGeometry(tier, position, null);\n+    }\n+    \n+    /**\n+     * Given a GeoWave geohash position, this will generate a Geometry which represents that position.\n+     * \n+     * @param geohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(String geohash, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        return positionToGeometry(createByteArrayId(geohash, longBuffer));\n+    }\n+    \n+    /**\n+     * Given a position at a given tier, this will generate a Geometry which represents that position.\n+     * \n+     * @param tier\n+     * @param position\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(int tier, long position, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        return positionToGeometry(createByteArrayId(tier, position, longBuffer));\n+    }\n+    \n+    /**\n+     * Given a byteArrayId, this will generate a Geometry which represents that position.\n+     * \n+     * @param byteArrayId\n+     * @return\n+     */\n+    public static Geometry positionToGeometry(ByteArrayId byteArrayId) {\n+        MultiDimensionalNumericData bounds = GeometryNormalizer.indexStrategy.getRangeForId(byteArrayId);\n+        \n+        if (decodeTier(byteArrayId) <= 1) {\n+            // @formatter:off\n+            return new GeometryFactory().toGeometry(\n+                    new Envelope(\n+                            bounds.getMinValuesPerDimension()[0],\n+                            bounds.getMaxValuesPerDimension()[0],\n+                            Math.max(-90, bounds.getMinValuesPerDimension()[1]),\n+                            Math.min(90, bounds.getMaxValuesPerDimension()[1])));\n+            // @formatter:on\n+        } else {\n+            // @formatter:off\n+            return new GeometryFactory().toGeometry(\n+                    new Envelope(\n+                            bounds.getMinValuesPerDimension()[0],\n+                            bounds.getMaxValuesPerDimension()[0],\n+                            bounds.getMinValuesPerDimension()[1],\n+                            bounds.getMaxValuesPerDimension()[1]));\n+            // @formatter:on\n+        }\n+    }\n+    \n+    /**\n+     * Given a range defined by the start and end geohashes, this will generate a Geometry which represents that range.\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(String startGeohash, String endGeohash) {\n+        return rangeToGeometry(startGeohash, endGeohash, null);\n+    }\n+    \n+    /**\n+     * Given a range defined by the start and end geohashes, this will generate a Geometry which represents that range.\n+     * \n+     * @param byteArrayRange\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(ByteArrayRange byteArrayRange) {\n+        return rangeToGeometry(byteArrayRange, null);\n+    }\n+    \n+    /**\n+     * Given a range at a given tier, this will generate a Geometry which represents that range.\n+     *\n+     * @param tier\n+     * @param start\n+     * @param end\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(int tier, long start, long end) {\n+        return rangeToGeometry(tier, start, end, null);\n+    }\n+    \n+    /**\n+     * Given a range defined by the start and end geohashes, this will generate a Geometry which represents that range.\n+     * \n+     * @param startGeohash\n+     * @param endGeohash\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(String startGeohash, String endGeohash, ByteBuffer longBuffer) {\n+        return rangeToGeometry(decodeTier(startGeohash), decodePosition(startGeohash), decodePosition(endGeohash), longBuffer);\n+    }\n+    \n+    /**\n+     * Given a range defined by byteArrayRange, this will generate a Geometry which represents that range.\n+     * \n+     * @param byteArrayRange\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(ByteArrayRange byteArrayRange, ByteBuffer longBuffer) {\n+        return rangeToGeometry(decodeTier(byteArrayRange.getStart()), decodePosition(byteArrayRange.getStart()), decodePosition(byteArrayRange.getEnd()),\n+                        longBuffer);\n+    }\n+    \n+    /**\n+     * Given a range at a given tier, this will generate a Geometry which represents that range.\n+     * \n+     * @param tier\n+     * @param start\n+     * @param end\n+     * @param longBuffer\n+     *            a reusable byte buffer of Long.BYTES length\n+     * @return\n+     */\n+    public static Geometry rangeToGeometry(int tier, long start, long end, ByteBuffer longBuffer) {\n+        longBuffer = initLongBuffer(longBuffer);\n+        \n+        GeometryFactory gf = new GeometryFactory();\n+        \n+        List<ByteArrayId> byteArrayIds = decomposeRange(tier, start, end, longBuffer);\n+        \n+        List<Geometry> geometries = new ArrayList<>(byteArrayIds.size());\n+        for (ByteArrayId byteArrayId : byteArrayIds) {\n+            MultiDimensionalNumericData bounds = GeometryNormalizer.indexStrategy.getRangeForId(byteArrayId);\n+            \n+            if (decodeTier(byteArrayId) <= 1) {\n+                // @formatter:off\n+                geometries.add(gf.toGeometry(\n+                        new Envelope(\n+                                bounds.getMinValuesPerDimension()[0],\n+                                bounds.getMaxValuesPerDimension()[0],\n+                                Math.max(-90, bounds.getMinValuesPerDimension()[1]),\n+                                Math.min(90, bounds.getMaxValuesPerDimension()[1]))));\n+                // @formatter:on\n+            } else if (inBounds(bounds)) {\n+                // @formatter:off\n+                geometries.add(gf.toGeometry(\n+                        new Envelope(\n+                                bounds.getMinValuesPerDimension()[0],\n+                                bounds.getMaxValuesPerDimension()[0],\n+                                bounds.getMinValuesPerDimension()[1],\n+                                bounds.getMaxValuesPerDimension()[1])));\n+                // @formatter:on\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MDgxOA=="}, "originalCommit": {"oid": "5f39f0deda142118eb78dce2c4c240f061dcfbd8"}, "originalPosition": 740}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4383, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}