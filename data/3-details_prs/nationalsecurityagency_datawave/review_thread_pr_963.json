{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MTE5OTcw", "number": 963, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxOTozNzoyOVrOEwcMjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoxODoxNlrOEwdsmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjI5MDY5OnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeCoalescingVisitor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxOTozNzoyOVrOHmAdyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDozMTozN1rOHmDz0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTYxNTU2MA==", "bodyText": "I don't think you need this call.  When the parent node is visited by this visitor (which extends RebuildingVisitor) it will be 'rebuilt' and any children will be reparented to the rebuilt node.  Short answer is that this functionality should already be handled by the parent RebuildingVisitor class.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/963#discussion_r509615560", "createdAt": "2020-10-21T19:37:29Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeCoalescingVisitor.java", "diffHunk": "@@ -90,12 +50,12 @@ public Object visit(ASTAndNode node, Object data) {\n             JexlNodes.ensureCapacity(andNode, node.jjtGetNumChildren());\n             for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n                 JexlNode newChild = (JexlNode) node.jjtGetChild(i).jjtAccept(this, data);\n-                \n                 andNode.jjtAddChild(newChild, i);\n                 newChild.jjtSetParent(andNode);\n             }\n         }\n         \n+        JexlNodes.replaceChild(node.jjtGetParent(), node, andNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572f2045950821d23992cdc0f30b293103f893fc"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY1NzQwNg==", "bodyText": "I tested this change locally, and tests still pass perfectly without this line.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/963#discussion_r509657406", "createdAt": "2020-10-21T20:17:02Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeCoalescingVisitor.java", "diffHunk": "@@ -90,12 +50,12 @@ public Object visit(ASTAndNode node, Object data) {\n             JexlNodes.ensureCapacity(andNode, node.jjtGetNumChildren());\n             for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n                 JexlNode newChild = (JexlNode) node.jjtGetChild(i).jjtAccept(this, data);\n-                \n                 andNode.jjtAddChild(newChild, i);\n                 newChild.jjtSetParent(andNode);\n             }\n         }\n         \n+        JexlNodes.replaceChild(node.jjtGetParent(), node, andNode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTYxNTU2MA=="}, "originalCommit": {"oid": "572f2045950821d23992cdc0f30b293103f893fc"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3MDM1NQ==", "bodyText": "Fixed.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/963#discussion_r509670355", "createdAt": "2020-10-21T20:31:37Z", "author": {"login": "lbschanno"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeCoalescingVisitor.java", "diffHunk": "@@ -90,12 +50,12 @@ public Object visit(ASTAndNode node, Object data) {\n             JexlNodes.ensureCapacity(andNode, node.jjtGetNumChildren());\n             for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n                 JexlNode newChild = (JexlNode) node.jjtGetChild(i).jjtAccept(this, data);\n-                \n                 andNode.jjtAddChild(newChild, i);\n                 newChild.jjtSetParent(andNode);\n             }\n         }\n         \n+        JexlNodes.replaceChild(node.jjtGetParent(), node, andNode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTYxNTU2MA=="}, "originalCommit": {"oid": "572f2045950821d23992cdc0f30b293103f893fc"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjUxMTYzOnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/RangeCoalescingVisitorTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoxNToxMFrOHmC1qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToyMDoxN1rOHmGGPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY1NDQ0MQ==", "bodyText": "This is 100% not required for this PR, but I would LOVE to see us validate the lineage of the originalScript after running the visitor as well.  In my opinion, a rebuilding visitor should not be destructive.  That is to say that the originalScript that's passed in should not be modified in any way by any of our rebuilding visitors.  The changes should be evident in the rebuilt actualScript only.\nI will also add that this is definitely NOT the case with many of our rebuilding visitors.  They are certainly destructive (I know, because I've written a few that way, d'oh!).  I'm hoping that this is something that we can move away from.  If you're not feeling up to that for this PR, please do me a favor and make a separate issue so that we can track that as well.\nBTW, I loaded up your PR and added the validateLineage step against the originalScript...  This is definitely a destructive rebuilding visitor.  FYI.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/963#discussion_r509654441", "createdAt": "2020-10-21T20:15:10Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/RangeCoalescingVisitorTest.java", "diffHunk": "@@ -113,11 +85,48 @@ public void testCoalesceManyNestedAndUnorderedTermsWithAnchorTerm() throws Parse\n         String expectedQuery1 = \"TACO == 'tacocat' && NUM3 == '+aE3' && (NUM2 >= '+aE2' && NUM2 <= '+aE4') && (NUM >= '+aE1' && NUM <= '+aE5')\";\n         String expectedQuery2 = \"TACO == 'tacocat' && NUM3 == '+aE3' && (NUM >= '+aE1' && NUM <= '+aE5') && (NUM2 >= '+aE2' && NUM2 <= '+aE4')\";\n         \n-        ASTJexlScript script = JexlASTHelper.parseJexlQuery(originalQuery);\n-        ASTJexlScript newScript = RangeCoalescingVisitor.coalesceRanges(script);\n+        assertVisitorResult(originalQuery, expectedQuery1, expectedQuery2);\n+    }\n+    \n+    private void assertVisitorResult(String original, String expected) throws ParseException {\n+        ASTJexlScript originalScript = JexlASTHelper.parseJexlQuery(original);\n+        ASTJexlScript expectedScript = JexlASTHelper.parseJexlQuery(expected);\n+        ASTJexlScript actualScript = RangeCoalescingVisitor.coalesceRanges(originalScript);\n         \n-        String newQuery = JexlStringBuildingVisitor.buildQuery(newScript);\n-        assertTrue(\"Expected [\" + expectedQuery1 + \"] or [\" + expectedQuery2 + \"] but was \" + newQuery,\n-                        (expectedQuery1.equals(newQuery) || expectedQuery2.equalsIgnoreCase(newQuery)));\n+        assertScriptEquality(actualScript, expectedScript);\n+        assertTrue(JexlASTHelper.validateLineage(actualScript, true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572f2045950821d23992cdc0f30b293103f893fc"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3MzQxNA==", "bodyText": "I will create a separate ticket to encapsulate this request to make it easier to track the effort for it across the relevant visitors.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/963#discussion_r509673414", "createdAt": "2020-10-21T20:36:07Z", "author": {"login": "lbschanno"}, "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/RangeCoalescingVisitorTest.java", "diffHunk": "@@ -113,11 +85,48 @@ public void testCoalesceManyNestedAndUnorderedTermsWithAnchorTerm() throws Parse\n         String expectedQuery1 = \"TACO == 'tacocat' && NUM3 == '+aE3' && (NUM2 >= '+aE2' && NUM2 <= '+aE4') && (NUM >= '+aE1' && NUM <= '+aE5')\";\n         String expectedQuery2 = \"TACO == 'tacocat' && NUM3 == '+aE3' && (NUM >= '+aE1' && NUM <= '+aE5') && (NUM2 >= '+aE2' && NUM2 <= '+aE4')\";\n         \n-        ASTJexlScript script = JexlASTHelper.parseJexlQuery(originalQuery);\n-        ASTJexlScript newScript = RangeCoalescingVisitor.coalesceRanges(script);\n+        assertVisitorResult(originalQuery, expectedQuery1, expectedQuery2);\n+    }\n+    \n+    private void assertVisitorResult(String original, String expected) throws ParseException {\n+        ASTJexlScript originalScript = JexlASTHelper.parseJexlQuery(original);\n+        ASTJexlScript expectedScript = JexlASTHelper.parseJexlQuery(expected);\n+        ASTJexlScript actualScript = RangeCoalescingVisitor.coalesceRanges(originalScript);\n         \n-        String newQuery = JexlStringBuildingVisitor.buildQuery(newScript);\n-        assertTrue(\"Expected [\" + expectedQuery1 + \"] or [\" + expectedQuery2 + \"] but was \" + newQuery,\n-                        (expectedQuery1.equals(newQuery) || expectedQuery2.equalsIgnoreCase(newQuery)));\n+        assertScriptEquality(actualScript, expectedScript);\n+        assertTrue(JexlASTHelper.validateLineage(actualScript, true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY1NDQ0MQ=="}, "originalCommit": {"oid": "572f2045950821d23992cdc0f30b293103f893fc"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5MjQ0MA==", "bodyText": "Thanks!", "url": "https://github.com/NationalSecurityAgency/datawave/pull/963#discussion_r509692440", "createdAt": "2020-10-21T21:00:17Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/RangeCoalescingVisitorTest.java", "diffHunk": "@@ -113,11 +85,48 @@ public void testCoalesceManyNestedAndUnorderedTermsWithAnchorTerm() throws Parse\n         String expectedQuery1 = \"TACO == 'tacocat' && NUM3 == '+aE3' && (NUM2 >= '+aE2' && NUM2 <= '+aE4') && (NUM >= '+aE1' && NUM <= '+aE5')\";\n         String expectedQuery2 = \"TACO == 'tacocat' && NUM3 == '+aE3' && (NUM >= '+aE1' && NUM <= '+aE5') && (NUM2 >= '+aE2' && NUM2 <= '+aE4')\";\n         \n-        ASTJexlScript script = JexlASTHelper.parseJexlQuery(originalQuery);\n-        ASTJexlScript newScript = RangeCoalescingVisitor.coalesceRanges(script);\n+        assertVisitorResult(originalQuery, expectedQuery1, expectedQuery2);\n+    }\n+    \n+    private void assertVisitorResult(String original, String expected) throws ParseException {\n+        ASTJexlScript originalScript = JexlASTHelper.parseJexlQuery(original);\n+        ASTJexlScript expectedScript = JexlASTHelper.parseJexlQuery(expected);\n+        ASTJexlScript actualScript = RangeCoalescingVisitor.coalesceRanges(originalScript);\n         \n-        String newQuery = JexlStringBuildingVisitor.buildQuery(newScript);\n-        assertTrue(\"Expected [\" + expectedQuery1 + \"] or [\" + expectedQuery2 + \"] but was \" + newQuery,\n-                        (expectedQuery1.equals(newQuery) || expectedQuery2.equalsIgnoreCase(newQuery)));\n+        assertScriptEquality(actualScript, expectedScript);\n+        assertTrue(JexlASTHelper.validateLineage(actualScript, true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY1NDQ0MQ=="}, "originalCommit": {"oid": "572f2045950821d23992cdc0f30b293103f893fc"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNzgzNg==", "bodyText": "I didn't see an issue yet, so I created one.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/963#discussion_r509707836", "createdAt": "2020-10-21T21:20:17Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/test/java/datawave/query/jexl/visitors/RangeCoalescingVisitorTest.java", "diffHunk": "@@ -113,11 +85,48 @@ public void testCoalesceManyNestedAndUnorderedTermsWithAnchorTerm() throws Parse\n         String expectedQuery1 = \"TACO == 'tacocat' && NUM3 == '+aE3' && (NUM2 >= '+aE2' && NUM2 <= '+aE4') && (NUM >= '+aE1' && NUM <= '+aE5')\";\n         String expectedQuery2 = \"TACO == 'tacocat' && NUM3 == '+aE3' && (NUM >= '+aE1' && NUM <= '+aE5') && (NUM2 >= '+aE2' && NUM2 <= '+aE4')\";\n         \n-        ASTJexlScript script = JexlASTHelper.parseJexlQuery(originalQuery);\n-        ASTJexlScript newScript = RangeCoalescingVisitor.coalesceRanges(script);\n+        assertVisitorResult(originalQuery, expectedQuery1, expectedQuery2);\n+    }\n+    \n+    private void assertVisitorResult(String original, String expected) throws ParseException {\n+        ASTJexlScript originalScript = JexlASTHelper.parseJexlQuery(original);\n+        ASTJexlScript expectedScript = JexlASTHelper.parseJexlQuery(expected);\n+        ASTJexlScript actualScript = RangeCoalescingVisitor.coalesceRanges(originalScript);\n         \n-        String newQuery = JexlStringBuildingVisitor.buildQuery(newScript);\n-        assertTrue(\"Expected [\" + expectedQuery1 + \"] or [\" + expectedQuery2 + \"] but was \" + newQuery,\n-                        (expectedQuery1.equals(newQuery) || expectedQuery2.equalsIgnoreCase(newQuery)));\n+        assertScriptEquality(actualScript, expectedScript);\n+        assertTrue(JexlASTHelper.validateLineage(actualScript, true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY1NDQ0MQ=="}, "originalCommit": {"oid": "572f2045950821d23992cdc0f30b293103f893fc"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjUzNjU3OnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeCoalescingVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoxODoxNlrOHmDHdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDozMTo0NVrOHmD0CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY1ODk5OA==", "bodyText": "This reparenting is also not needed as reparenting is handled by the base RebuildingVisitor.\nI tested this change locally as well, and tests still pass perfectly if you simply return newNode.jjtGetChild(0).", "url": "https://github.com/NationalSecurityAgency/datawave/pull/963#discussion_r509658998", "createdAt": "2020-10-21T20:18:16Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeCoalescingVisitor.java", "diffHunk": "@@ -137,8 +99,9 @@ protected JexlNode coalesceBoundedRanges(Map<LiteralRange<?>,List<JexlNode>> ran\n         \n         // If we had no other nodes than this bounded range, we can strip out the original parent\n         if (newNode.jjtGetNumChildren() == 1) {\n-            newNode.jjtGetChild(0).jjtSetParent(newNode.jjtGetParent());\n-            return newNode.jjtGetChild(0);\n+            JexlNode child = newNode.jjtGetChild(0);\n+            JexlNodes.replaceChild(newNode.jjtGetParent(), newNode, child);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572f2045950821d23992cdc0f30b293103f893fc"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3MDQwOA==", "bodyText": "Fixed.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/963#discussion_r509670408", "createdAt": "2020-10-21T20:31:45Z", "author": {"login": "lbschanno"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeCoalescingVisitor.java", "diffHunk": "@@ -137,8 +99,9 @@ protected JexlNode coalesceBoundedRanges(Map<LiteralRange<?>,List<JexlNode>> ran\n         \n         // If we had no other nodes than this bounded range, we can strip out the original parent\n         if (newNode.jjtGetNumChildren() == 1) {\n-            newNode.jjtGetChild(0).jjtSetParent(newNode.jjtGetParent());\n-            return newNode.jjtGetChild(0);\n+            JexlNode child = newNode.jjtGetChild(0);\n+            JexlNodes.replaceChild(newNode.jjtGetParent(), newNode, child);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY1ODk5OA=="}, "originalCommit": {"oid": "572f2045950821d23992cdc0f30b293103f893fc"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4460, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}