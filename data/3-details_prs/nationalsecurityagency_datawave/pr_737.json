{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMDI3OTQw", "number": 737, "title": "Fixes #703 - Created query wizard in Quickstart WebUI", "bodyText": "Created a three step query wizard in the Quickstart WebUI (https://localhost:8443/DataWave/doc).\nIt creates the specific form required for each query type.  Although the \"begin\" and \"end\" options in the form may appear in the optional parameter section they should usually be filled in ( use values: 19700101, 20990101).   Also make sure that the proper query syntax is selected in the optional parameter section.  This feature is accessed in by selecting the \"Datawave\" main menu item and then selecting the \"Basic Query\" submenu item.  The  \"auths\" and \"visibilities\" are pre-populated for ease of use and can be edited.", "createdAt": "2020-02-04T20:09:49Z", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737", "merged": true, "mergeCommit": {"oid": "16778179d019e42395a6eb678c747d38a980ee97"}, "closed": true, "closedAt": "2020-02-20T18:47:11Z", "author": {"login": "jzgithub1"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBE-QxAH2gAyMzcxMDI3OTQwOmE5MTNhODhiZDFlMjE5MTUwZDU3OWZlMWU1ZDNiMmZkZmZhMmFjNDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGPsGDAFqTM2MjE0NDQ0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a913a88bd1e219150d579fe1e5d3b2fdffa2ac44", "author": {"user": {"login": "jzgithub1", "name": "Jeffrey Zeiberg"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/a913a88bd1e219150d579fe1e5d3b2fdffa2ac44", "committedDate": "2020-02-04T17:27:38Z", "message": "Created query form page for all query types in Quickstart WebUI"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzc0NzE4", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#pullrequestreview-353374718", "createdAt": "2020-02-04T23:25:26Z", "commit": {"oid": "a913a88bd1e219150d579fe1e5d3b2fdffa2ac44"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMzoyNToyNlrOFlnDkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMzoyNToyNlrOFlnDkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4MTUyMg==", "bodyText": "When I ran this, I got a \"Datawave could not generate a plan for the query\" message when I tried ContentQuery logic type, which makes sense, because non-ShardQueryLogic types like ContentQuery typically won't have a planner involved. But in this case, you get stuck on the /showQueryWizardStep3 page with no way to retrieve the content result.\nTo replicate, do an EventQuery to pull back wikipedia records (e.g., \"anarchy\" unfielded should work, if you have the default data loaded), copy the RECORD_ID field's value (e.g., 20130305_0/enwiki/ibrtlu.qead3h.uz468c), then just plug that value into the query field for a ContentQuery", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r374981522", "createdAt": "2020-02-04T23:25:26Z", "author": {"login": "keith-ratcliffe"}, "path": "web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package datawave.webservice.query.runner;\n+\n+import com.codahale.metrics.annotation.Timed;\n+import datawave.annotation.GenerateQuerySessionId;\n+import datawave.annotation.Required;\n+import datawave.configuration.DatawaveEmbeddedProjectStageHolder;\n+import datawave.interceptor.RequiredInterceptor;\n+import datawave.interceptor.ResponseInterceptor;\n+import datawave.resteasy.interceptor.CreateQuerySessionIDFilter;\n+import datawave.security.authorization.DatawavePrincipal;\n+import datawave.webservice.query.Query;\n+import datawave.webservice.query.QueryImpl;\n+import datawave.webservice.query.exception.QueryException;\n+import datawave.webservice.query.logic.QueryLogic;\n+import datawave.webservice.query.logic.QueryLogicFactory;\n+import datawave.webservice.query.result.logic.QueryLogicDescription;\n+import datawave.webservice.result.BaseQueryResponse;\n+import datawave.webservice.result.GenericResponse;\n+import datawave.webservice.result.QueryWizardResultResponse;\n+import datawave.webservice.result.QueryWizardStep1Response;\n+import datawave.webservice.result.QueryWizardStep2Response;\n+import datawave.webservice.result.QueryWizardStep3Response;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.deltaspike.core.api.config.ConfigProperty;\n+import org.apache.deltaspike.core.api.exclude.Exclude;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.annotation.Resource;\n+import javax.annotation.security.DeclareRoles;\n+import javax.annotation.security.RolesAllowed;\n+\n+import javax.ejb.EJBContext;\n+import javax.ejb.LocalBean;\n+import javax.ejb.SessionContext;\n+import javax.ejb.Stateless;\n+import javax.ejb.TransactionAttribute;\n+import javax.ejb.TransactionAttributeType;\n+import javax.ejb.TransactionManagement;\n+import javax.ejb.TransactionManagementType;\n+import javax.inject.Inject;\n+import javax.interceptor.Interceptors;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.lang.reflect.Method;\n+import java.security.Principal;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import datawave.security.util.AuthorizationsUtil;\n+\n+@Path(\"/BasicQuery\")\n+@RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@DeclareRoles({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@Stateless\n+@LocalBean\n+@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)\n+@TransactionManagement(TransactionManagementType.BEAN)\n+@Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n+public class BasicQueryBean {\n+    \n+    private static final String PRIVILEGED_USER = \"PrivilegedUser\";\n+    \n+    /**\n+     * Used when getting a plan prior to creating a query\n+     */\n+    public static final String EXPAND_VALUES = \"expand.values\";\n+    public static final String EXPAND_FIELDS = \"expand.fields\";\n+    \n+    private final Logger log = Logger.getLogger(BasicQueryBean.class);\n+    \n+    @Inject\n+    private QueryLogicFactory queryLogicFactory;\n+    \n+    @Inject\n+    private QueryExecutorBean queryExecutor;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.jquery.uri\", defaultValue = \"/jquery.min.js\")\n+    private String jqueryUri;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.dataTables.uri\", defaultValue = \"/jquery.dataTables.min.js\")\n+    private String dataTablesUri;\n+    \n+    @Resource\n+    private EJBContext ctx;\n+    \n+    @Resource\n+    private SessionContext sessionContext;\n+    \n+    @PostConstruct\n+    public void init() {\n+        \n+    }\n+    \n+    @PreDestroy\n+    public void close() {\n+        \n+    }\n+    \n+    /**\n+     * Display the first step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep1Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizard\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @GET\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizard\", absolute = true)\n+    public QueryWizardStep1Response showQueryWizardStep1() {\n+        QueryWizardStep1Response response = new QueryWizardStep1Response();\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        List<QueryLogicDescription> logicConfigurationList = new ArrayList<>();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                d.setAuditType(l.getAuditType(null).toString());\n+                d.setLogicDescription(l.getLogicDescription());\n+                \n+                Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                if (optionalQueryParameters != null) {\n+                    d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                }\n+                Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                if (requiredQueryParameters != null) {\n+                    d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                }\n+                Set<String> exampleQueries = l.getExampleQueries();\n+                if (exampleQueries != null) {\n+                    d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                }\n+                Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                if (requiredRoles != null) {\n+                    List<String> requiredRolesList = new ArrayList<>();\n+                    requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                    d.setRequiredRoles(requiredRolesList);\n+                }\n+                \n+                try {\n+                    d.setResponseClass(l.getResponseClass(q));\n+                } catch (QueryException e) {\n+                    log.error(e, e);\n+                    response.addException(e);\n+                    d.setResponseClass(\"unknown\");\n+                }\n+                \n+                List<String> querySyntax = new ArrayList<>();\n+                try {\n+                    Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                    Object result = m.invoke(l);\n+                    if (result instanceof Map<?,?>) {\n+                        Map<?,?> map = (Map<?,?>) result;\n+                        for (Object o : map.keySet())\n+                            querySyntax.add(o.toString());\n+                    }\n+                } catch (Exception e) {\n+                    log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                }\n+                if (querySyntax.isEmpty()) {\n+                    querySyntax.add(\"CUSTOM\");\n+                }\n+                d.setQuerySyntax(querySyntax);\n+                \n+                logicConfigurationList.add(d);\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        Collections.sort(logicConfigurationList, Comparator.comparing(QueryLogicDescription::getName));\n+        response.setQueryLogicList(logicConfigurationList);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the second step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep2Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizardStep2\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @POST\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep2\", absolute = true)\n+    public QueryWizardStep2Response showQueryWizardStep2(MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        QueryWizardStep2Response response = new QueryWizardStep2Response();\n+        String queryType = queryParameters.getFirst(\"queryType\");\n+        QueryLogicDescription theQld = null;\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                \n+                if (l.getLogicName().equals(queryType)) {\n+                    \n+                    QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                    d.setAuditType(l.getAuditType(null).toString());\n+                    d.setLogicDescription(l.getLogicDescription());\n+                    theQld = d;\n+                    \n+                    Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                    if (optionalQueryParameters != null) {\n+                        d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                    }\n+                    Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                    if (requiredQueryParameters != null) {\n+                        d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                    }\n+                    Set<String> exampleQueries = l.getExampleQueries();\n+                    if (exampleQueries != null) {\n+                        d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                    }\n+                    Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                    if (requiredRoles != null) {\n+                        List<String> requiredRolesList = new ArrayList<>();\n+                        requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                        d.setRequiredRoles(requiredRolesList);\n+                    }\n+                    \n+                    try {\n+                        d.setResponseClass(l.getResponseClass(q));\n+                    } catch (QueryException e) {\n+                        log.error(e, e);\n+                        response.addException(e);\n+                        d.setResponseClass(\"unknown\");\n+                    }\n+                    \n+                    List<String> querySyntax = new ArrayList<>();\n+                    try {\n+                        Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                        Object result = m.invoke(l);\n+                        if (result instanceof Map<?,?>) {\n+                            Map<?,?> map = (Map<?,?>) result;\n+                            for (Object o : map.keySet())\n+                                querySyntax.add(o.toString());\n+                        }\n+                    } catch (Exception e) {\n+                        log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                    }\n+                    if (querySyntax.isEmpty()) {\n+                        querySyntax.add(\"CUSTOM\");\n+                    }\n+                    d.setQuerySyntax(querySyntax);\n+                    \n+                    break;\n+                    \n+                }\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        \n+        Principal p = ctx.getCallerPrincipal();\n+        String authSting = AuthorizationsUtil.buildUserAuthorizationString(p);\n+        response.setAuthString(authSting);\n+        response.setTheQueryLogicDescription(theQld);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the query plan and link to basic query results for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep3Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @POST\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @Path(\"/{logicName}/showQueryWizardStep3\")\n+    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/BasicQuery/\")\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep3\", absolute = true)\n+    public QueryWizardStep3Response showQueryWizardStep3(@Required(\"logicName\") @PathParam(\"logicName\") String logicName,\n+                    MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+        GenericResponse<String> createResponse;\n+        QueryWizardStep3Response queryWizardStep3Response = new QueryWizardStep3Response();\n+        try {\n+            createResponse = queryExecutor.createQuery(logicName, queryParameters, httpHeaders);\n+        } catch (Exception e) {\n+            queryWizardStep3Response.setErrorMessage(e.getMessage());\n+            return queryWizardStep3Response;\n+        }\n+        String queryId = createResponse.getResult();\n+        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+        queryWizardStep3Response.setQueryId(queryId);\n+        GenericResponse<String> planResponse;\n+        try {\n+            planResponse = queryExecutor.plan(queryId);\n+        } catch (Exception e) {\n+            queryWizardStep3Response.setErrorMessage(e.getMessage());\n+            return queryWizardStep3Response;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a913a88bd1e219150d579fe1e5d3b2fdffa2ac44"}, "originalPosition": 334}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ea81610429b40946aba323acd74388f92dafe18", "author": {"user": {"login": "jzgithub1", "name": "Jeffrey Zeiberg"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/0ea81610429b40946aba323acd74388f92dafe18", "committedDate": "2020-02-05T15:50:27Z", "message": "ContentQuery improvements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2OTQ3ODY4", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#pullrequestreview-356947868", "createdAt": "2020-02-11T19:51:36Z", "commit": {"oid": "0ea81610429b40946aba323acd74388f92dafe18"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo1MTozNlrOFoW4gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxOTo1MTozNlrOFoW4gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg2MjI3NA==", "bodyText": "Why BasicQuery vs just Query?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r377862274", "createdAt": "2020-02-11T19:51:36Z", "author": {"login": "ivakegg"}, "path": "web-services/deploy/docs/docs/index.html", "diffHunk": "@@ -32,6 +32,7 @@\n                         <li><a href=\"/DataWave/DataDictionary\">Data Dictionary</a></li>\n                         <li><a href=\"/DataWave/EdgeDictionary\">Edge Dictionary</a></li>\n                         <li><a href=\"/DataWave/Query/listQueryLogic\">Deployed Query Logics</a></li>\n+                        <li><a href=\"/DataWave/BasicQuery/showQueryWizard\">Basic Query</a></li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ea81610429b40946aba323acd74388f92dafe18"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MDcwODkw", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#pullrequestreview-357070890", "createdAt": "2020-02-11T23:26:03Z", "commit": {"oid": "0ea81610429b40946aba323acd74388f92dafe18"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMzoyNjowM1rOFoc3Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMzoyNjowM1rOFoc3Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MDIyNg==", "bodyText": "Sorry, finally getting back to reviewing this. For the comparison here, it would be better to use your queryLogicFactory instance to get the logicClass, rather than use the logicName. The name is subject to change based on user preference. For example, the user might decide they like the name \"ContentLookup\" better and reconfigure QLF.xml. But if we rename datawave.query.tables.content.ContentQueryTable that'd at least get caught by the compiler here\nSecond issue: I did try out the update, and I did get past the original issue that I reported, but I then noticed the ContentQuery response fields get truncated to just a few visible chars in the results view. However, the d-column entries in this case are not well-suited for row/col table viewing anyway....because they can be huge, they're base64 encoded, etc. So, I think I'm fine with leaving that problem for another release down the road", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r377960226", "createdAt": "2020-02-11T23:26:03Z", "author": {"login": "keith-ratcliffe"}, "path": "web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java", "diffHunk": "@@ -0,0 +1,388 @@\n+package datawave.webservice.query.runner;\n+\n+import com.codahale.metrics.annotation.Timed;\n+import datawave.annotation.GenerateQuerySessionId;\n+import datawave.annotation.Required;\n+import datawave.configuration.DatawaveEmbeddedProjectStageHolder;\n+import datawave.interceptor.RequiredInterceptor;\n+import datawave.interceptor.ResponseInterceptor;\n+import datawave.resteasy.interceptor.CreateQuerySessionIDFilter;\n+import datawave.security.authorization.DatawavePrincipal;\n+import datawave.webservice.query.Query;\n+import datawave.webservice.query.QueryImpl;\n+import datawave.webservice.query.exception.QueryException;\n+import datawave.webservice.query.logic.QueryLogic;\n+import datawave.webservice.query.logic.QueryLogicFactory;\n+import datawave.webservice.query.result.logic.QueryLogicDescription;\n+import datawave.webservice.result.BaseQueryResponse;\n+import datawave.webservice.result.GenericResponse;\n+import datawave.webservice.result.QueryWizardResultResponse;\n+import datawave.webservice.result.QueryWizardStep1Response;\n+import datawave.webservice.result.QueryWizardStep2Response;\n+import datawave.webservice.result.QueryWizardStep3Response;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.deltaspike.core.api.config.ConfigProperty;\n+import org.apache.deltaspike.core.api.exclude.Exclude;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.annotation.Resource;\n+import javax.annotation.security.DeclareRoles;\n+import javax.annotation.security.RolesAllowed;\n+\n+import javax.ejb.EJBContext;\n+import javax.ejb.LocalBean;\n+import javax.ejb.SessionContext;\n+import javax.ejb.Stateless;\n+import javax.ejb.TransactionAttribute;\n+import javax.ejb.TransactionAttributeType;\n+import javax.ejb.TransactionManagement;\n+import javax.ejb.TransactionManagementType;\n+import javax.inject.Inject;\n+import javax.interceptor.Interceptors;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.lang.reflect.Method;\n+import java.security.Principal;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import datawave.security.util.AuthorizationsUtil;\n+\n+@Path(\"/BasicQuery\")\n+@RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@DeclareRoles({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@Stateless\n+@LocalBean\n+@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)\n+@TransactionManagement(TransactionManagementType.BEAN)\n+@Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n+public class BasicQueryBean {\n+    \n+    private static final String PRIVILEGED_USER = \"PrivilegedUser\";\n+    \n+    /**\n+     * Used when getting a plan prior to creating a query\n+     */\n+    public static final String EXPAND_VALUES = \"expand.values\";\n+    public static final String EXPAND_FIELDS = \"expand.fields\";\n+    \n+    private final Logger log = Logger.getLogger(BasicQueryBean.class);\n+    \n+    @Inject\n+    private QueryLogicFactory queryLogicFactory;\n+    \n+    @Inject\n+    private QueryExecutorBean queryExecutor;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.jquery.uri\", defaultValue = \"/jquery.min.js\")\n+    private String jqueryUri;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.dataTables.uri\", defaultValue = \"/jquery.dataTables.min.js\")\n+    private String dataTablesUri;\n+    \n+    @Resource\n+    private EJBContext ctx;\n+    \n+    @Resource\n+    private SessionContext sessionContext;\n+    \n+    @PostConstruct\n+    public void init() {\n+        \n+    }\n+    \n+    @PreDestroy\n+    public void close() {\n+        \n+    }\n+    \n+    /**\n+     * Display the first step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep1Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizard\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @GET\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizard\", absolute = true)\n+    public QueryWizardStep1Response showQueryWizardStep1() {\n+        QueryWizardStep1Response response = new QueryWizardStep1Response();\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        List<QueryLogicDescription> logicConfigurationList = new ArrayList<>();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                d.setAuditType(l.getAuditType(null).toString());\n+                d.setLogicDescription(l.getLogicDescription());\n+                \n+                Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                if (optionalQueryParameters != null) {\n+                    d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                }\n+                Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                if (requiredQueryParameters != null) {\n+                    d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                }\n+                Set<String> exampleQueries = l.getExampleQueries();\n+                if (exampleQueries != null) {\n+                    d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                }\n+                Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                if (requiredRoles != null) {\n+                    List<String> requiredRolesList = new ArrayList<>();\n+                    requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                    d.setRequiredRoles(requiredRolesList);\n+                }\n+                \n+                try {\n+                    d.setResponseClass(l.getResponseClass(q));\n+                } catch (QueryException e) {\n+                    log.error(e, e);\n+                    response.addException(e);\n+                    d.setResponseClass(\"unknown\");\n+                }\n+                \n+                List<String> querySyntax = new ArrayList<>();\n+                try {\n+                    Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                    Object result = m.invoke(l);\n+                    if (result instanceof Map<?,?>) {\n+                        Map<?,?> map = (Map<?,?>) result;\n+                        for (Object o : map.keySet())\n+                            querySyntax.add(o.toString());\n+                    }\n+                } catch (Exception e) {\n+                    log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                }\n+                if (querySyntax.isEmpty()) {\n+                    querySyntax.add(\"CUSTOM\");\n+                }\n+                d.setQuerySyntax(querySyntax);\n+                \n+                logicConfigurationList.add(d);\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        Collections.sort(logicConfigurationList, Comparator.comparing(QueryLogicDescription::getName));\n+        response.setQueryLogicList(logicConfigurationList);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the second step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep2Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizardStep2\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @POST\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep2\", absolute = true)\n+    public QueryWizardStep2Response showQueryWizardStep2(MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        QueryWizardStep2Response response = new QueryWizardStep2Response();\n+        String queryType = queryParameters.getFirst(\"queryType\");\n+        QueryLogicDescription theQld = null;\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                \n+                if (l.getLogicName().equals(queryType)) {\n+                    \n+                    QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                    d.setAuditType(l.getAuditType(null).toString());\n+                    d.setLogicDescription(l.getLogicDescription());\n+                    theQld = d;\n+                    \n+                    Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                    if (optionalQueryParameters != null) {\n+                        d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                    }\n+                    Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                    if (requiredQueryParameters != null) {\n+                        d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                    }\n+                    Set<String> exampleQueries = l.getExampleQueries();\n+                    if (exampleQueries != null) {\n+                        d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                    }\n+                    Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                    if (requiredRoles != null) {\n+                        List<String> requiredRolesList = new ArrayList<>();\n+                        requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                        d.setRequiredRoles(requiredRolesList);\n+                    }\n+                    \n+                    try {\n+                        d.setResponseClass(l.getResponseClass(q));\n+                    } catch (QueryException e) {\n+                        log.error(e, e);\n+                        response.addException(e);\n+                        d.setResponseClass(\"unknown\");\n+                    }\n+                    \n+                    List<String> querySyntax = new ArrayList<>();\n+                    try {\n+                        Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                        Object result = m.invoke(l);\n+                        if (result instanceof Map<?,?>) {\n+                            Map<?,?> map = (Map<?,?>) result;\n+                            for (Object o : map.keySet())\n+                                querySyntax.add(o.toString());\n+                        }\n+                    } catch (Exception e) {\n+                        log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                    }\n+                    if (querySyntax.isEmpty()) {\n+                        querySyntax.add(\"CUSTOM\");\n+                    }\n+                    d.setQuerySyntax(querySyntax);\n+                    \n+                    break;\n+                    \n+                }\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        \n+        Principal p = ctx.getCallerPrincipal();\n+        String authSting = AuthorizationsUtil.buildUserAuthorizationString(p);\n+        response.setAuthString(authSting);\n+        response.setTheQueryLogicDescription(theQld);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the query plan and link to basic query results for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep3Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @POST\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @Path(\"/{logicName}/showQueryWizardStep3\")\n+    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/BasicQuery/\")\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep3\", absolute = true)\n+    public QueryWizardStep3Response showQueryWizardStep3(@Required(\"logicName\") @PathParam(\"logicName\") String logicName,\n+                    MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+        GenericResponse<String> createResponse;\n+        QueryWizardStep3Response queryWizardStep3Response = new QueryWizardStep3Response();\n+        try {\n+            createResponse = queryExecutor.createQuery(logicName, queryParameters, httpHeaders);\n+        } catch (Exception e) {\n+            queryWizardStep3Response.setErrorMessage(e.getMessage());\n+            return queryWizardStep3Response;\n+        }\n+        String queryId = createResponse.getResult();\n+        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+        queryWizardStep3Response.setQueryId(queryId);\n+        \n+        if (!logicName.equals(\"ContentQuery\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ea81610429b40946aba323acd74388f92dafe18"}, "originalPosition": 329}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3460462429b47c9da9329d64acd4d9961588679b", "author": {"user": {"login": "jzgithub1", "name": "Jeffrey Zeiberg"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/3460462429b47c9da9329d64acd4d9961588679b", "committedDate": "2020-02-19T21:35:01Z", "message": "Fixes #703 - Compare against BasicQueryLogic classname during query planning"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDgyNzgx", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#pullrequestreview-361482781", "createdAt": "2020-02-19T22:22:51Z", "commit": {"oid": "3460462429b47c9da9329d64acd4d9961588679b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMjoyMjo1MVrOFr51sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMjoyNTo0NlrOFr561g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU4MDcyMg==", "bodyText": "Change to:\nqueryWizardStep3Response.setQueryPlan(\"No plan required for this query\");", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r381580722", "createdAt": "2020-02-19T22:22:51Z", "author": {"login": "keith-ratcliffe"}, "path": "web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java", "diffHunk": "@@ -0,0 +1,408 @@\n+package datawave.webservice.query.runner;\n+\n+import com.codahale.metrics.annotation.Timed;\n+import datawave.annotation.GenerateQuerySessionId;\n+import datawave.annotation.Required;\n+import datawave.configuration.DatawaveEmbeddedProjectStageHolder;\n+import datawave.interceptor.RequiredInterceptor;\n+import datawave.interceptor.ResponseInterceptor;\n+import datawave.resteasy.interceptor.CreateQuerySessionIDFilter;\n+import datawave.security.authorization.DatawavePrincipal;\n+import datawave.webservice.query.Query;\n+import datawave.webservice.query.QueryImpl;\n+import datawave.webservice.query.exception.QueryException;\n+import datawave.webservice.query.logic.BaseQueryLogic;\n+import datawave.webservice.query.logic.QueryLogic;\n+import datawave.webservice.query.logic.QueryLogicFactory;\n+import datawave.webservice.query.result.logic.QueryLogicDescription;\n+import datawave.webservice.result.BaseQueryResponse;\n+import datawave.webservice.result.GenericResponse;\n+import datawave.webservice.result.QueryWizardResultResponse;\n+import datawave.webservice.result.QueryWizardStep1Response;\n+import datawave.webservice.result.QueryWizardStep2Response;\n+import datawave.webservice.result.QueryWizardStep3Response;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.deltaspike.core.api.config.ConfigProperty;\n+import org.apache.deltaspike.core.api.exclude.Exclude;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.annotation.Resource;\n+import javax.annotation.security.DeclareRoles;\n+import javax.annotation.security.RolesAllowed;\n+\n+import javax.ejb.EJBContext;\n+import javax.ejb.LocalBean;\n+import javax.ejb.SessionContext;\n+import javax.ejb.Stateless;\n+import javax.ejb.TransactionAttribute;\n+import javax.ejb.TransactionAttributeType;\n+import javax.ejb.TransactionManagement;\n+import javax.ejb.TransactionManagementType;\n+import javax.inject.Inject;\n+import javax.interceptor.Interceptors;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.lang.reflect.Method;\n+import java.security.Principal;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import datawave.security.util.AuthorizationsUtil;\n+\n+@Path(\"/BasicQuery\")\n+@RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@DeclareRoles({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@Stateless\n+@LocalBean\n+@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)\n+@TransactionManagement(TransactionManagementType.BEAN)\n+@Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n+public class BasicQueryBean {\n+    \n+    private static final String PRIVILEGED_USER = \"PrivilegedUser\";\n+    \n+    /**\n+     * Used when getting a plan prior to creating a query\n+     */\n+    public static final String EXPAND_VALUES = \"expand.values\";\n+    public static final String EXPAND_FIELDS = \"expand.fields\";\n+    \n+    private final Logger log = Logger.getLogger(BasicQueryBean.class);\n+    \n+    @Inject\n+    private QueryLogicFactory queryLogicFactory;\n+    \n+    @Inject\n+    private QueryExecutorBean queryExecutor;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.jquery.uri\", defaultValue = \"/jquery.min.js\")\n+    private String jqueryUri;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.dataTables.uri\", defaultValue = \"/jquery.dataTables.min.js\")\n+    private String dataTablesUri;\n+    \n+    @Resource\n+    private EJBContext ctx;\n+    \n+    @Resource\n+    private SessionContext sessionContext;\n+    \n+    @PostConstruct\n+    public void init() {\n+        \n+    }\n+    \n+    @PreDestroy\n+    public void close() {\n+        \n+    }\n+    \n+    /**\n+     * Display the first step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep1Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizard\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @GET\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizard\", absolute = true)\n+    public QueryWizardStep1Response showQueryWizardStep1() {\n+        QueryWizardStep1Response response = new QueryWizardStep1Response();\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        List<QueryLogicDescription> logicConfigurationList = new ArrayList<>();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                d.setAuditType(l.getAuditType(null).toString());\n+                d.setLogicDescription(l.getLogicDescription());\n+                \n+                Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                if (optionalQueryParameters != null) {\n+                    d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                }\n+                Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                if (requiredQueryParameters != null) {\n+                    d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                }\n+                Set<String> exampleQueries = l.getExampleQueries();\n+                if (exampleQueries != null) {\n+                    d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                }\n+                Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                if (requiredRoles != null) {\n+                    List<String> requiredRolesList = new ArrayList<>();\n+                    requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                    d.setRequiredRoles(requiredRolesList);\n+                }\n+                \n+                try {\n+                    d.setResponseClass(l.getResponseClass(q));\n+                } catch (QueryException e) {\n+                    log.error(e, e);\n+                    response.addException(e);\n+                    d.setResponseClass(\"unknown\");\n+                }\n+                \n+                List<String> querySyntax = new ArrayList<>();\n+                try {\n+                    Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                    Object result = m.invoke(l);\n+                    if (result instanceof Map<?,?>) {\n+                        Map<?,?> map = (Map<?,?>) result;\n+                        for (Object o : map.keySet())\n+                            querySyntax.add(o.toString());\n+                    }\n+                } catch (Exception e) {\n+                    log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                }\n+                if (querySyntax.isEmpty()) {\n+                    querySyntax.add(\"CUSTOM\");\n+                }\n+                d.setQuerySyntax(querySyntax);\n+                \n+                logicConfigurationList.add(d);\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        Collections.sort(logicConfigurationList, Comparator.comparing(QueryLogicDescription::getName));\n+        response.setQueryLogicList(logicConfigurationList);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the second step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep2Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizardStep2\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @POST\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep2\", absolute = true)\n+    public QueryWizardStep2Response showQueryWizardStep2(MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        QueryWizardStep2Response response = new QueryWizardStep2Response();\n+        String queryType = queryParameters.getFirst(\"queryType\");\n+        QueryLogicDescription theQld = null;\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                \n+                if (l.getLogicName().equals(queryType)) {\n+                    \n+                    QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                    d.setAuditType(l.getAuditType(null).toString());\n+                    d.setLogicDescription(l.getLogicDescription());\n+                    theQld = d;\n+                    \n+                    Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                    if (optionalQueryParameters != null) {\n+                        d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                    }\n+                    Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                    if (requiredQueryParameters != null) {\n+                        d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                    }\n+                    Set<String> exampleQueries = l.getExampleQueries();\n+                    if (exampleQueries != null) {\n+                        d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                    }\n+                    Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                    if (requiredRoles != null) {\n+                        List<String> requiredRolesList = new ArrayList<>();\n+                        requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                        d.setRequiredRoles(requiredRolesList);\n+                    }\n+                    \n+                    try {\n+                        d.setResponseClass(l.getResponseClass(q));\n+                    } catch (QueryException e) {\n+                        log.error(e, e);\n+                        response.addException(e);\n+                        d.setResponseClass(\"unknown\");\n+                    }\n+                    \n+                    List<String> querySyntax = new ArrayList<>();\n+                    try {\n+                        Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                        Object result = m.invoke(l);\n+                        if (result instanceof Map<?,?>) {\n+                            Map<?,?> map = (Map<?,?>) result;\n+                            for (Object o : map.keySet())\n+                                querySyntax.add(o.toString());\n+                        }\n+                    } catch (Exception e) {\n+                        log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                    }\n+                    if (querySyntax.isEmpty()) {\n+                        querySyntax.add(\"CUSTOM\");\n+                    }\n+                    d.setQuerySyntax(querySyntax);\n+                    \n+                    break;\n+                    \n+                }\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        \n+        Principal p = ctx.getCallerPrincipal();\n+        String authSting = AuthorizationsUtil.buildUserAuthorizationString(p);\n+        response.setAuthString(authSting);\n+        response.setTheQueryLogicDescription(theQld);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the query plan and link to basic query results for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep3Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @POST\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @Path(\"/{logicName}/showQueryWizardStep3\")\n+    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/BasicQuery/\")\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep3\", absolute = true)\n+    public QueryWizardStep3Response showQueryWizardStep3(@Required(\"logicName\") @PathParam(\"logicName\") String logicName,\n+                    MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+        GenericResponse<String> createResponse;\n+        QueryWizardStep3Response queryWizardStep3Response = new QueryWizardStep3Response();\n+        try {\n+            createResponse = queryExecutor.createQuery(logicName, queryParameters, httpHeaders);\n+        } catch (Exception e) {\n+            queryWizardStep3Response.setErrorMessage(e.getMessage());\n+            return queryWizardStep3Response;\n+        }\n+        String queryId = createResponse.getResult();\n+        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+        queryWizardStep3Response.setQueryId(queryId);\n+        \n+        BaseQueryLogic logic = getQueryLogic(logicName);\n+        if (logic != null && !(logic.getClass().getName().equals(\"datawave.query.tables.content.ContentQueryTable\"))) {\n+            GenericResponse<String> planResponse;\n+            try {\n+                planResponse = queryExecutor.plan(queryId);\n+            } catch (Exception e) {\n+                queryWizardStep3Response.setErrorMessage(e.getMessage());\n+                return queryWizardStep3Response;\n+            }\n+            \n+            queryWizardStep3Response.setQueryPlan(planResponse.getResult());\n+        } else\n+            queryWizardStep3Response.setQueryPlan(\" No query plan for is required for this query\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3460462429b47c9da9329d64acd4d9961588679b"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU4MjAzOA==", "bodyText": "Typo: determi\"ne", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#discussion_r381582038", "createdAt": "2020-02-19T22:25:46Z", "author": {"login": "keith-ratcliffe"}, "path": "web-services/query/src/main/java/datawave/webservice/query/runner/BasicQueryBean.java", "diffHunk": "@@ -0,0 +1,408 @@\n+package datawave.webservice.query.runner;\n+\n+import com.codahale.metrics.annotation.Timed;\n+import datawave.annotation.GenerateQuerySessionId;\n+import datawave.annotation.Required;\n+import datawave.configuration.DatawaveEmbeddedProjectStageHolder;\n+import datawave.interceptor.RequiredInterceptor;\n+import datawave.interceptor.ResponseInterceptor;\n+import datawave.resteasy.interceptor.CreateQuerySessionIDFilter;\n+import datawave.security.authorization.DatawavePrincipal;\n+import datawave.webservice.query.Query;\n+import datawave.webservice.query.QueryImpl;\n+import datawave.webservice.query.exception.QueryException;\n+import datawave.webservice.query.logic.BaseQueryLogic;\n+import datawave.webservice.query.logic.QueryLogic;\n+import datawave.webservice.query.logic.QueryLogicFactory;\n+import datawave.webservice.query.result.logic.QueryLogicDescription;\n+import datawave.webservice.result.BaseQueryResponse;\n+import datawave.webservice.result.GenericResponse;\n+import datawave.webservice.result.QueryWizardResultResponse;\n+import datawave.webservice.result.QueryWizardStep1Response;\n+import datawave.webservice.result.QueryWizardStep2Response;\n+import datawave.webservice.result.QueryWizardStep3Response;\n+import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.deltaspike.core.api.config.ConfigProperty;\n+import org.apache.deltaspike.core.api.exclude.Exclude;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.annotation.Resource;\n+import javax.annotation.security.DeclareRoles;\n+import javax.annotation.security.RolesAllowed;\n+\n+import javax.ejb.EJBContext;\n+import javax.ejb.LocalBean;\n+import javax.ejb.SessionContext;\n+import javax.ejb.Stateless;\n+import javax.ejb.TransactionAttribute;\n+import javax.ejb.TransactionAttributeType;\n+import javax.ejb.TransactionManagement;\n+import javax.ejb.TransactionManagementType;\n+import javax.inject.Inject;\n+import javax.interceptor.Interceptors;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.lang.reflect.Method;\n+import java.security.Principal;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import datawave.security.util.AuthorizationsUtil;\n+\n+@Path(\"/BasicQuery\")\n+@RolesAllowed({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@DeclareRoles({\"AuthorizedUser\", \"AuthorizedQueryServer\", \"PrivilegedUser\", \"InternalUser\", \"Administrator\", \"JBossAdministrator\"})\n+@Stateless\n+@LocalBean\n+@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)\n+@TransactionManagement(TransactionManagementType.BEAN)\n+@Exclude(ifProjectStage = DatawaveEmbeddedProjectStageHolder.DatawaveEmbedded.class)\n+public class BasicQueryBean {\n+    \n+    private static final String PRIVILEGED_USER = \"PrivilegedUser\";\n+    \n+    /**\n+     * Used when getting a plan prior to creating a query\n+     */\n+    public static final String EXPAND_VALUES = \"expand.values\";\n+    public static final String EXPAND_FIELDS = \"expand.fields\";\n+    \n+    private final Logger log = Logger.getLogger(BasicQueryBean.class);\n+    \n+    @Inject\n+    private QueryLogicFactory queryLogicFactory;\n+    \n+    @Inject\n+    private QueryExecutorBean queryExecutor;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.jquery.uri\", defaultValue = \"/jquery.min.js\")\n+    private String jqueryUri;\n+    \n+    @Inject\n+    @ConfigProperty(name = \"dw.cdn.dataTables.uri\", defaultValue = \"/jquery.dataTables.min.js\")\n+    private String dataTablesUri;\n+    \n+    @Resource\n+    private EJBContext ctx;\n+    \n+    @Resource\n+    private SessionContext sessionContext;\n+    \n+    @PostConstruct\n+    public void init() {\n+        \n+    }\n+    \n+    @PreDestroy\n+    public void close() {\n+        \n+    }\n+    \n+    /**\n+     * Display the first step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep1Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizard\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @GET\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizard\", absolute = true)\n+    public QueryWizardStep1Response showQueryWizardStep1() {\n+        QueryWizardStep1Response response = new QueryWizardStep1Response();\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        List<QueryLogicDescription> logicConfigurationList = new ArrayList<>();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                d.setAuditType(l.getAuditType(null).toString());\n+                d.setLogicDescription(l.getLogicDescription());\n+                \n+                Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                if (optionalQueryParameters != null) {\n+                    d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                }\n+                Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                if (requiredQueryParameters != null) {\n+                    d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                }\n+                Set<String> exampleQueries = l.getExampleQueries();\n+                if (exampleQueries != null) {\n+                    d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                }\n+                Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                if (requiredRoles != null) {\n+                    List<String> requiredRolesList = new ArrayList<>();\n+                    requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                    d.setRequiredRoles(requiredRolesList);\n+                }\n+                \n+                try {\n+                    d.setResponseClass(l.getResponseClass(q));\n+                } catch (QueryException e) {\n+                    log.error(e, e);\n+                    response.addException(e);\n+                    d.setResponseClass(\"unknown\");\n+                }\n+                \n+                List<String> querySyntax = new ArrayList<>();\n+                try {\n+                    Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                    Object result = m.invoke(l);\n+                    if (result instanceof Map<?,?>) {\n+                        Map<?,?> map = (Map<?,?>) result;\n+                        for (Object o : map.keySet())\n+                            querySyntax.add(o.toString());\n+                    }\n+                } catch (Exception e) {\n+                    log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                }\n+                if (querySyntax.isEmpty()) {\n+                    querySyntax.add(\"CUSTOM\");\n+                }\n+                d.setQuerySyntax(querySyntax);\n+                \n+                logicConfigurationList.add(d);\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        Collections.sort(logicConfigurationList, Comparator.comparing(QueryLogicDescription::getName));\n+        response.setQueryLogicList(logicConfigurationList);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the second step for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep2Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @Path(\"/showQueryWizardStep2\")\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @POST\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep2\", absolute = true)\n+    public QueryWizardStep2Response showQueryWizardStep2(MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        QueryWizardStep2Response response = new QueryWizardStep2Response();\n+        String queryType = queryParameters.getFirst(\"queryType\");\n+        QueryLogicDescription theQld = null;\n+        List<QueryLogic<?>> logicList = queryLogicFactory.getQueryLogicList();\n+        \n+        // reference query necessary to avoid NPEs in getting the Transformer and BaseResponse\n+        Query q = new QueryImpl();\n+        Date now = new Date();\n+        q.setExpirationDate(now);\n+        q.setQuery(\"test\");\n+        q.setQueryAuthorizations(\"ALL\");\n+        \n+        for (QueryLogic<?> l : logicList) {\n+            try {\n+                \n+                if (l.getLogicName().equals(queryType)) {\n+                    \n+                    QueryLogicDescription d = new QueryLogicDescription(l.getLogicName());\n+                    d.setAuditType(l.getAuditType(null).toString());\n+                    d.setLogicDescription(l.getLogicDescription());\n+                    theQld = d;\n+                    \n+                    Set<String> optionalQueryParameters = l.getOptionalQueryParameters();\n+                    if (optionalQueryParameters != null) {\n+                        d.setSupportedParams(new ArrayList<>(optionalQueryParameters));\n+                    }\n+                    Set<String> requiredQueryParameters = l.getRequiredQueryParameters();\n+                    if (requiredQueryParameters != null) {\n+                        d.setRequiredParams(new ArrayList<>(requiredQueryParameters));\n+                    }\n+                    Set<String> exampleQueries = l.getExampleQueries();\n+                    if (exampleQueries != null) {\n+                        d.setExampleQueries(new ArrayList<>(exampleQueries));\n+                    }\n+                    Set<String> requiredRoles = l.getRoleManager().getRequiredRoles();\n+                    if (requiredRoles != null) {\n+                        List<String> requiredRolesList = new ArrayList<>();\n+                        requiredRolesList.addAll(l.getRoleManager().getRequiredRoles());\n+                        d.setRequiredRoles(requiredRolesList);\n+                    }\n+                    \n+                    try {\n+                        d.setResponseClass(l.getResponseClass(q));\n+                    } catch (QueryException e) {\n+                        log.error(e, e);\n+                        response.addException(e);\n+                        d.setResponseClass(\"unknown\");\n+                    }\n+                    \n+                    List<String> querySyntax = new ArrayList<>();\n+                    try {\n+                        Method m = l.getClass().getMethod(\"getQuerySyntaxParsers\");\n+                        Object result = m.invoke(l);\n+                        if (result instanceof Map<?,?>) {\n+                            Map<?,?> map = (Map<?,?>) result;\n+                            for (Object o : map.keySet())\n+                                querySyntax.add(o.toString());\n+                        }\n+                    } catch (Exception e) {\n+                        log.warn(\"Unable to get query syntax for query logic: \" + l.getClass().getCanonicalName());\n+                    }\n+                    if (querySyntax.isEmpty()) {\n+                        querySyntax.add(\"CUSTOM\");\n+                    }\n+                    d.setQuerySyntax(querySyntax);\n+                    \n+                    break;\n+                    \n+                }\n+            } catch (Exception e) {\n+                log.error(\"Error setting query logic description\", e);\n+            }\n+        }\n+        \n+        Principal p = ctx.getCallerPrincipal();\n+        String authSting = AuthorizationsUtil.buildUserAuthorizationString(p);\n+        response.setAuthString(authSting);\n+        response.setTheQueryLogicDescription(theQld);\n+        \n+        return response;\n+    }\n+    \n+    /**\n+     * Display the query plan and link to basic query results for a simple query web UI in the quickstart\n+     *\n+     * @HTTP 200 Success\n+     * @return datawave.webservice.result.QueryWizardStep3Response\n+     * @RequestHeader X-ProxiedEntitiesChain use when proxying request for user, by specifying a chain of DNs of the identities to proxy\n+     * @RequestHeader X-ProxiedIssuersChain required when using X-ProxiedEntitiesChain, specify one issuer DN per subject DN listed in X-ProxiedEntitiesChain\n+     * @ResponseHeader X-OperationTimeInMS time spent on the server performing the operation, does not account for network or result serialization\n+     */\n+    @POST\n+    @Produces({\"application/xml\", \"text/xml\", \"application/json\", \"text/yaml\", \"text/x-yaml\", \"application/x-yaml\", \"text/html\"})\n+    @Path(\"/{logicName}/showQueryWizardStep3\")\n+    @GenerateQuerySessionId(cookieBasePath = \"/DataWave/BasicQuery/\")\n+    @Interceptors({ResponseInterceptor.class})\n+    @Timed(name = \"dw.query.showQueryWizardStep3\", absolute = true)\n+    public QueryWizardStep3Response showQueryWizardStep3(@Required(\"logicName\") @PathParam(\"logicName\") String logicName,\n+                    MultivaluedMap<String,String> queryParameters, @Context HttpHeaders httpHeaders) {\n+        CreateQuerySessionIDFilter.QUERY_ID.set(null);\n+        GenericResponse<String> createResponse;\n+        QueryWizardStep3Response queryWizardStep3Response = new QueryWizardStep3Response();\n+        try {\n+            createResponse = queryExecutor.createQuery(logicName, queryParameters, httpHeaders);\n+        } catch (Exception e) {\n+            queryWizardStep3Response.setErrorMessage(e.getMessage());\n+            return queryWizardStep3Response;\n+        }\n+        String queryId = createResponse.getResult();\n+        CreateQuerySessionIDFilter.QUERY_ID.set(queryId);\n+        queryWizardStep3Response.setQueryId(queryId);\n+        \n+        BaseQueryLogic logic = getQueryLogic(logicName);\n+        if (logic != null && !(logic.getClass().getName().equals(\"datawave.query.tables.content.ContentQueryTable\"))) {\n+            GenericResponse<String> planResponse;\n+            try {\n+                planResponse = queryExecutor.plan(queryId);\n+            } catch (Exception e) {\n+                queryWizardStep3Response.setErrorMessage(e.getMessage());\n+                return queryWizardStep3Response;\n+            }\n+            \n+            queryWizardStep3Response.setQueryPlan(planResponse.getResult());\n+        } else\n+            queryWizardStep3Response.setQueryPlan(\" No query plan for is required for this query\");\n+        \n+        return queryWizardStep3Response;\n+    }\n+    \n+    /**\n+     * Gets the next page of results from the query object. If the object is no longer alive, meaning that the current session has expired, then this fail. The\n+     * response object type is dynamic, see the listQueryLogic operation to determi\"ne what the response type object will be.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3460462429b47c9da9329d64acd4d9961588679b"}, "originalPosition": 349}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da99ca296b50a92e4c8dc720185af0e84469f973", "author": {"user": {"login": "jzgithub1", "name": "Jeffrey Zeiberg"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/da99ca296b50a92e4c8dc720185af0e84469f973", "committedDate": "2020-02-20T15:18:55Z", "message": "Merge branch 'master' into datawave-703-final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24e70aa563f74f7c59f640fafcf42f0ccc1e052d", "author": {"user": {"login": "jzgithub1", "name": "Jeffrey Zeiberg"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/24e70aa563f74f7c59f640fafcf42f0ccc1e052d", "committedDate": "2020-02-20T15:34:09Z", "message": "Fixed some strings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9646d29cb80c37ebfbba839ac47e4ef84621b742", "author": {"user": {"login": "jzgithub1", "name": "Jeffrey Zeiberg"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/9646d29cb80c37ebfbba839ac47e4ef84621b742", "committedDate": "2020-02-20T17:56:50Z", "message": "Added NO_PLAN_REQUIRED string list that can be appended to later on"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMTE0ODQ2", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#pullrequestreview-362114846", "createdAt": "2020-02-20T18:00:49Z", "commit": {"oid": "9646d29cb80c37ebfbba839ac47e4ef84621b742"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMTQ0NDQ5", "url": "https://github.com/NationalSecurityAgency/datawave/pull/737#pullrequestreview-362144449", "createdAt": "2020-02-20T18:46:22Z", "commit": {"oid": "9646d29cb80c37ebfbba839ac47e4ef84621b742"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1119, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}