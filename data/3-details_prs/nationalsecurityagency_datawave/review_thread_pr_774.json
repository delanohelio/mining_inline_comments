{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMTU1MTI5", "number": 774, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1NDoxNVrODlEz4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1NDoxNVrODlEz4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjAyNzIzOnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/TreeFlatteningRebuilder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDo1NDoxNVrOFxwa7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNTozOTozMVrOF0UuAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxNzg2OA==", "bodyText": "Make the operation precedence obvious between the initial || and the subsequent &&", "url": "https://github.com/NationalSecurityAgency/datawave/pull/774#discussion_r387717868", "createdAt": "2020-03-04T14:54:15Z", "author": {"login": "ivakegg"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/TreeFlatteningRebuilder.java", "diffHunk": "@@ -182,6 +190,32 @@ private JexlNode copyTree(JexlNode node, Deque<JexlNode> postOrderDeque) {\n         return copiedNode;\n     }\n     \n+    private List<JexlNode> getAndOrLeaves(JexlNode node) {\n+        LinkedList<JexlNode> children = new LinkedList<>();\n+        LinkedList<JexlNode> stack = new LinkedList<>();\n+        stack.push(node);\n+        \n+        while (!stack.isEmpty()) {\n+            JexlNode currNode = stack.pop();\n+            \n+            // only add children if\n+            // 1) this is the original node, or\n+            // 2) this node is the same type as the root node and\n+            // -- a) this is an OR node, or\n+            // -- b) this is an AND node (but not a bounded range)\n+            if (currNode == node || node.getClass().isInstance(currNode)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ddfe852272fcd92482a530cfd6ca742101d978e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM4OTQ5NA==", "bodyText": "So... an extra set of parens???  I thought the comment made it obvious.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/774#discussion_r388389494", "createdAt": "2020-03-05T15:59:28Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/TreeFlatteningRebuilder.java", "diffHunk": "@@ -182,6 +190,32 @@ private JexlNode copyTree(JexlNode node, Deque<JexlNode> postOrderDeque) {\n         return copiedNode;\n     }\n     \n+    private List<JexlNode> getAndOrLeaves(JexlNode node) {\n+        LinkedList<JexlNode> children = new LinkedList<>();\n+        LinkedList<JexlNode> stack = new LinkedList<>();\n+        stack.push(node);\n+        \n+        while (!stack.isEmpty()) {\n+            JexlNode currNode = stack.pop();\n+            \n+            // only add children if\n+            // 1) this is the original node, or\n+            // 2) this node is the same type as the root node and\n+            // -- a) this is an OR node, or\n+            // -- b) this is an AND node (but not a bounded range)\n+            if (currNode == node || node.getClass().isInstance(currNode)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxNzg2OA=="}, "originalCommit": {"oid": "5ddfe852272fcd92482a530cfd6ca742101d978e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwOTczMQ==", "bodyText": "Fixed.  What more do you want from me!!!???  I seek your approval!", "url": "https://github.com/NationalSecurityAgency/datawave/pull/774#discussion_r390409731", "createdAt": "2020-03-10T15:39:31Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/TreeFlatteningRebuilder.java", "diffHunk": "@@ -182,6 +190,32 @@ private JexlNode copyTree(JexlNode node, Deque<JexlNode> postOrderDeque) {\n         return copiedNode;\n     }\n     \n+    private List<JexlNode> getAndOrLeaves(JexlNode node) {\n+        LinkedList<JexlNode> children = new LinkedList<>();\n+        LinkedList<JexlNode> stack = new LinkedList<>();\n+        stack.push(node);\n+        \n+        while (!stack.isEmpty()) {\n+            JexlNode currNode = stack.pop();\n+            \n+            // only add children if\n+            // 1) this is the original node, or\n+            // 2) this node is the same type as the root node and\n+            // -- a) this is an OR node, or\n+            // -- b) this is an AND node (but not a bounded range)\n+            if (currNode == node || node.getClass().isInstance(currNode)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxNzg2OA=="}, "originalCommit": {"oid": "5ddfe852272fcd92482a530cfd6ca742101d978e"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4504, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}