{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNzIxNTk2", "number": 942, "title": "Fixed!  Added a flatten step to EdgeQueryLogic.configureRanges to showcase te\u2026", "bodyText": "\u2026st errors in ExtendedEdgeQueryLogicTest and EdgeQueryFunctionalTest.  The test failures occur because EdgeTableRangeBuildingVisitor cannot handle a flattened tree.\nThis is broke... as a joke!", "createdAt": "2020-10-15T00:09:08Z", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942", "merged": true, "mergeCommit": {"oid": "a0623a8bbaebf2920a4f4a26746b1e17aef2e241"}, "closed": true, "closedAt": "2020-10-19T19:25:57Z", "author": {"login": "jwomeara"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSmVOhgH2gAyNTAzNzIxNTk2OmQ2MDBhYzhiOWY0OWNhMWIyMTJkNDBkZjEzNTU4ODM1ZjMzZTYwZWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUI-sDAFqTUxMjA2MTM5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d600ac8b9f49ca1b212d40df13558835f33e60ee", "author": {"user": {"login": "jwomeara", "name": "Whitney O'Meara"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/d600ac8b9f49ca1b212d40df13558835f33e60ee", "committedDate": "2020-10-15T00:07:27Z", "message": "Added a flatten step to EdgeQueryLogic.configureRanges to showcase test errors in ExtendedEdgeQueryLogicTest and EdgeQueryFunctionalTest.  The test failures occur because EdgeTableRangeBuildingVisitor cannot handle a flattened tree."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faa333a3df39777411f16c212afe524c5e34bdc8", "author": {"user": {"login": "jwomeara", "name": "Whitney O'Meara"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/faa333a3df39777411f16c212afe524c5e34bdc8", "committedDate": "2020-10-15T02:41:30Z", "message": "Updated the EdgeTableRangeBuildingVisitor to be able to operate on a flattened query tree."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64bc7815015e48756bf4ab4b521d5065539615e2", "author": {"user": {"login": "jwomeara", "name": "Whitney O'Meara"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/64bc7815015e48756bf4ab4b521d5065539615e2", "committedDate": "2020-10-15T04:12:14Z", "message": "oops"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzgwODAx", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#pullrequestreview-509780801", "createdAt": "2020-10-15T20:26:24Z", "commit": {"oid": "64bc7815015e48756bf4ab4b521d5065539615e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyNjoyNVrOHiYr5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyNjoyNVrOHiYr5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxODA4Nw==", "bodyText": "need a continue here", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r505818087", "createdAt": "2020-10-15T20:26:25Z", "author": {"login": "ivakegg"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;\n+            } else if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) mergedContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) childContext);\n+                }\n+                \n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) childContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) mergedContext);\n                 }\n-                return contexts1;\n-            } else if (((List<QueryContext>) contexts2).get(0).getRowContext() != null) {\n-                for (QueryContext qContext : ((List<QueryContext>) contexts2)) {\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts1), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                \n+                mergedContext = childContext;\n+                /*\n+                 * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' &&\n+                 * ((TYPE == 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n+                 * \n+                 * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n+                 * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited\n+                 * support has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not\n+                 * allowed.\n+                 */\n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                // Assumes that if the first query context does not have a row context then they all don't\n+                if (((List<QueryContext>) childContext).get(0).getRowContext() != null) {\n+                    // The size of the list for contexts1 is usually going to be 1\n+                    for (QueryContext qContext : ((List<QueryContext>) childContext)) {\n+                        // Combine the query contexts if anything fails blame the user\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) mergedContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n+                    }\n+                    mergedContext = childContext;\n+                    continue;\n+                } else if (((List<QueryContext>) mergedContext).get(0).getRowContext() != null) {\n+                    for (QueryContext qContext : ((List<QueryContext>) mergedContext)) {\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) childContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n                     }\n                 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64bc7815015e48756bf4ab4b521d5065539615e2"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzgyNDgz", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#pullrequestreview-509782483", "createdAt": "2020-10-15T20:27:23Z", "commit": {"oid": "64bc7815015e48756bf4ab4b521d5065539615e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyNzoyM1rOHiYt0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyNzoyM1rOHiYt0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxODU3Ng==", "bodyText": "how about set \"processed = true\" as well and then test it at the error message below.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r505818576", "createdAt": "2020-10-15T20:27:23Z", "author": {"login": "ivakegg"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64bc7815015e48756bf4ab4b521d5065539615e2"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66148dd369deaf3e5978aa0dd710c0c36261743c", "author": {"user": {"login": "jwomeara", "name": "Whitney O'Meara"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/66148dd369deaf3e5978aa0dd710c0c36261743c", "committedDate": "2020-10-15T20:43:27Z", "message": "oops again"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjkwODIy", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#pullrequestreview-510690822", "createdAt": "2020-10-16T17:59:20Z", "commit": {"oid": "66148dd369deaf3e5978aa0dd710c0c36261743c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3ef07fadde51f16780336447c69d7088222c6ee", "author": {"user": {"login": "jwomeara", "name": "Whitney O'Meara"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/a3ef07fadde51f16780336447c69d7088222c6ee", "committedDate": "2020-10-16T18:01:09Z", "message": "Merge branch 'release/version2.9' into bugfix/edgeQueryStackOverflow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ded9518ad3648d135807cb7ca922da4969905c66", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/ded9518ad3648d135807cb7ca922da4969905c66", "committedDate": "2020-10-19T18:18:28Z", "message": "Merge branch 'release/version2.9' into bugfix/edgeQueryStackOverflow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4582481816bab297685d0726e52220fceb6d3b9d", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/4582481816bab297685d0726e52220fceb6d3b9d", "committedDate": "2020-10-19T18:44:59Z", "message": "Merge branch 'release/version2.9' into bugfix/edgeQueryStackOverflow"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDYxMzky", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#pullrequestreview-512061392", "createdAt": "2020-10-19T18:47:30Z", "commit": {"oid": "ded9518ad3648d135807cb7ca922da4969905c66"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo0ODowMVrOHkc9ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo0ODowMVrOHkc9ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NTI1OA==", "bodyText": "Instead of repeating the message Error: problem with query syntax everywhere, could we give any additional information that may allow the receiver of this error to troubleshoot the problem", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r507985258", "createdAt": "2020-10-19T18:48:01Z", "author": {"login": "drewfarris"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;\n+            } else if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) mergedContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) childContext);\n+                }\n+                \n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) childContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) mergedContext);\n                 }\n-                return contexts1;\n-            } else if (((List<QueryContext>) contexts2).get(0).getRowContext() != null) {\n-                for (QueryContext qContext : ((List<QueryContext>) contexts2)) {\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts1), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                \n+                mergedContext = childContext;\n+                /*\n+                 * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' &&\n+                 * ((TYPE == 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n+                 * \n+                 * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n+                 * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited\n+                 * support has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not\n+                 * allowed.\n+                 */\n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                // Assumes that if the first query context does not have a row context then they all don't\n+                if (((List<QueryContext>) childContext).get(0).getRowContext() != null) {\n+                    // The size of the list for contexts1 is usually going to be 1\n+                    for (QueryContext qContext : ((List<QueryContext>) childContext)) {\n+                        // Combine the query contexts if anything fails blame the user\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) mergedContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n+                    }\n+                    mergedContext = childContext;\n+                } else if (((List<QueryContext>) mergedContext).get(0).getRowContext() != null) {\n+                    for (QueryContext qContext : ((List<QueryContext>) mergedContext)) {\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) childContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n                     }\n+                } else {\n+                    log.error(\"Problem parsing query\");\n+                    throw new IllegalArgumentException(\"Error: problem with query syntax\");\n                 }\n-                return contexts2;\n+            } else {\n+                \n+                log.error(\"And node had unexpected return type\");\n+                throw new IllegalArgumentException(\"Error: problem with query syntax\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4582481816bab297685d0726e52220fceb6d3b9d"}, "originalPosition": 149}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1065, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}