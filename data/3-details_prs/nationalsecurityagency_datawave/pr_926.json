{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0MTcxOTM4", "number": 926, "title": "Change to mark bounded ranges in JEXL", "bodyText": "The initial symptom was that we simply drop bounded ranges for the same field when they are and'ed together.  To alleviate this, we determined that bounded ranges need to be explicitly marked in JEXL to parallel the explicit bounded range construct in LUCENE.  So the primary changes are:\n\nBounded ranges in JEXL now look like this :  ((BoundedRange = true) && (x < a && x > b))\nWe no longer coalesce bounds for the same field into bounded range constructs\n\nOther changes that came with this are:\n\nReworked the getBoundedRanges in the JexlASTHelper to use a builder pattern to avoid the excessive number of variants.\nJexlASTHelper getIdentifiers and getLiterals will avoid getting the identifier and literal from assignments\nUpdated the JexlNodeFactory.createExpression to only create one if needed.  This avoid many of the extra parens showing up.\nA bounded range that expands to nothing is now replaced with a FALSE literal which is now handled appropriately by the QueryPruningVisitor which was just enabled by default in 2.9.10.\nAn UnmarkedBoundedRangeDetectionVisitor was added to fail if marked bounded ranges are found that are not valid ranges, and to find bounded ranges that are unmarked.  The later was primarily to find any test cases that needed to mark ranges.  It is debatable whether that part should be left.\nA flag was added to the configuration called \"generatePlanOnly\" which is used when requesting a plan.  Previously the range stream was being created even when values or fields were not being expanded which now that bounded ranges are being processed correctly would result in plans requiring full table scans.  This flag allows the getPlan endpoint to avoid that.", "createdAt": "2020-09-28T14:11:36Z", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926", "merged": true, "mergeCommit": {"oid": "fe4fdb45cbb61fcd4b9a88df73ee673caab13283"}, "closed": true, "closedAt": "2020-12-21T14:22:55Z", "author": {"login": "ivakegg"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOWcNfABqjM4MzEwODI1NzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdndjMPAH2gAyNDk0MTcxOTM4OjZjNjE3ZTQ5NmYwMDIwYmNlNTA5OWU1YjM2OWVjMTVjOWRlMTkwMzY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e041e1a29cc9c0c01e6c5fa498306842714aa2de", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/e041e1a29cc9c0c01e6c5fa498306842714aa2de", "committedDate": "2020-10-01T17:18:26Z", "message": "re #902: formatting"}, "afterCommit": {"oid": "e947c218927e2fb162a7d9f701dcdb40ffb0e44b", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/e947c218927e2fb162a7d9f701dcdb40ffb0e44b", "committedDate": "2020-10-01T17:28:10Z", "message": "re #902: formatting"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e947c218927e2fb162a7d9f701dcdb40ffb0e44b", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/e947c218927e2fb162a7d9f701dcdb40ffb0e44b", "committedDate": "2020-10-01T17:28:10Z", "message": "re #902: formatting"}, "afterCommit": {"oid": "59a903a9cc9ee77886a3309bc807436a2d66faaa", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/59a903a9cc9ee77886a3309bc807436a2d66faaa", "committedDate": "2020-10-02T13:31:13Z", "message": "re #902: formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxOTIzOTQ5", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#pullrequestreview-521923949", "createdAt": "2020-11-02T19:17:00Z", "commit": {"oid": "2bfbaeb558c97cde50dc66243bbb5ee61862bbf5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxOToxNzowMFrOHsSTsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxOToxNzowMFrOHsSTsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE5OTM0Ng==", "bodyText": "shouldn't these be LT/LTE and GT/GTE in order to detect a bounded range?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516199346", "createdAt": "2020-11-02T19:17:00Z", "author": {"login": "FineAndDandy"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/BoundedRangeDetectionVisitor.java", "diffHunk": "@@ -28,29 +38,45 @@ public static boolean mustExpandBoundedRange(ShardQueryConfiguration config, Met\n     }\n     \n     @Override\n-    public Object visit(ASTERNode node, Object data) {\n-        if (null != data) {\n-            AtomicBoolean hasBounded = (AtomicBoolean) data;\n-            hasBounded.set(true);\n+    public Object visit(ASTReference node, Object data) {\n+        if (BoundedRange.instanceOf(node)) {\n+            LiteralRange range = JexlASTHelper.findRange().getRange(node);\n+            try {\n+                if (helper.getNonEventFields(config.getDatatypeFilter()).contains(range.getFieldName())) {\n+                    if (null != data) {\n+                        AtomicBoolean hasBounded = (AtomicBoolean) data;\n+                        hasBounded.set(true);\n+                    }\n+                }\n+            } catch (TableNotFoundException e) {\n+                throw new DatawaveFatalQueryException(\"Cannot access metadata\", e);\n+            }\n+            \n+            return false;\n+        } else {\n+            return super.visit(node, data);\n         }\n-        \n-        return false;\n-        \n     }\n     \n     @Override\n-    public Object visit(ASTNRNode node, Object data) {\n-        if (null != data) {\n-            AtomicBoolean hasBounded = (AtomicBoolean) data;\n-            hasBounded.set(true);\n+    public Object visit(ASTERNode node, Object data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bfbaeb558c97cde50dc66243bbb5ee61862bbf5"}, "originalPosition": 67}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2bfbaeb558c97cde50dc66243bbb5ee61862bbf5", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/2bfbaeb558c97cde50dc66243bbb5ee61862bbf5", "committedDate": "2020-10-08T17:30:21Z", "message": "re #902: Updated to use all normalizers for bounded range expansion"}, "afterCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/317e8815eb1948375ec4445c768189d25e789e01", "committedDate": "2020-11-02T18:14:14Z", "message": "re #902: Change JEXL to enforce using a BoundedRange marker for bounded ranges.\n * Added a visitor to detect invalid marked bounded ranges and ranges that are not marked.\n * Unexpanded bounded ranges not ivarated are non-executable (from an index point of view)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNjYzMDYy", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#pullrequestreview-522663062", "createdAt": "2020-11-03T16:20:03Z", "commit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjoyMDowM1rOHs2aWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjo0OToyN1rOHs3smA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5MDg3Mw==", "bodyText": "Looks like there are four different instances of a method with this name. Is there a need to maintain different copies? If so, what is unique about this instance?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516790873", "createdAt": "2020-11-03T16:20:03Z", "author": {"login": "apmoriarty"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ExpandMultiNormalizedTerms.java", "diffHunk": "@@ -356,4 +290,20 @@ protected JexlNode expandNodeForNormalizers(JexlNode node, Object data) {\n         }\n         return nodeToReturn;\n     }\n+    \n+    /**\n+     * method to return if the current node is an instance of a delayed predicate\n+     *\n+     * @param currNode\n+     * @return\n+     */\n+    protected boolean isDelayedPredicate(JexlNode currNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMDYxNA==", "bodyText": "Looks like this import and commented code can get removed.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516800614", "createdAt": "2020-11-03T16:33:35Z", "author": {"login": "apmoriarty"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/QueryPruningVisitor.java", "diffHunk": "@@ -253,6 +253,11 @@ public Object visit(ASTOrNode node, Object data) {\n     \n     @Override\n     public Object visit(ASTAndNode node, Object data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMjQ4OQ==", "bodyText": "Should this be log.error?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516802489", "createdAt": "2020-11-03T16:36:16Z", "author": {"login": "apmoriarty"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeConjunctionRebuildingVisitor.java", "diffHunk": "@@ -117,335 +111,43 @@ public Object visit(ASTReference node, Object data) {\n                 ExceededValueThresholdMarkerJexlNode.class, ExceededTermThresholdMarkerJexlNode.class, ExceededOrThresholdMarkerJexlNode.class});\n         if (QueryPropertyMarkerVisitor.instanceOf(node, markers, null)) {\n             return node;\n-        } else\n-            return super.visit(node, data);\n-    }\n-    \n-    @Override\n-    public Object visit(ASTLTNode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTGTNode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTLENode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTGENode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTAndNode node, Object data) {\n-        List<JexlNode> leaves = new ArrayList<>();\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = JexlASTHelper.getBoundedRanges(node, this.config.getDatatypeFilter(), this.helper, leaves, false);\n-        \n-        JexlNode andNode = JexlNodes.newInstanceOfType(node);\n-        andNode.image = node.image;\n-        andNode.jjtSetParent(node.jjtGetParent());\n-        \n-        // We have a bounded range completely inside of an AND/OR\n-        if (!ranges.isEmpty()) {\n-            andNode = expandIndexBoundedRange(ranges, leaves, node, andNode, data);\n-        } else {\n-            // We have no bounded range to replace, just proceed as normal\n-            JexlNodes.ensureCapacity(andNode, node.jjtGetNumChildren());\n-            for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n-                JexlNode newChild = (JexlNode) node.jjtGetChild(i).jjtAccept(this, data);\n-                \n-                andNode.jjtAddChild(newChild, i);\n-                newChild.jjtSetParent(andNode);\n+        } else if (BoundedRange.instanceOf(node)) {\n+            LiteralRange range = JexlASTHelper.findRange().indexedOnly(this.config.getDatatypeFilter(), this.helper).notDelayed().getRange(node);\n+            if (range != null) {\n+                return expandIndexBoundedRange(range, node);\n+            } else {\n+                return super.visit(node, data);\n             }\n+        } else {\n+            return super.visit(node, data);\n         }\n-        \n-        return andNode;\n     }\n     \n-    protected JexlNode expandIndexBoundedRange(Map<LiteralRange<?>,List<JexlNode>> ranges, List<JexlNode> leaves, ASTAndNode currentNode, JexlNode newNode,\n-                    Object data) {\n-        // Add all children in this AND/OR which are not a part of the range\n-        JexlNodes.ensureCapacity(newNode, leaves.size() + ranges.size());\n-        int index = 0;\n-        for (; index < leaves.size(); index++) {\n-            log.debug(leaves.get(index).image);\n-            // Add each child which is not a part of the bounded range, visiting them first\n-            JexlNode visitedChild = (JexlNode) leaves.get(index).jjtAccept(this, null);\n-            newNode.jjtAddChild(visitedChild, index);\n-            visitedChild.jjtSetParent(newNode);\n-        }\n-        \n-        // Sanity check to ensure that we found some nodes (redundant since we couldn't have made a bounded LiteralRange in the first\n-        // place if we had found not range nodes)\n-        if (ranges.isEmpty()) {\n+    protected JexlNode expandIndexBoundedRange(LiteralRange range, ASTReference currentNode) {\n+        // Sanity check to ensure that we found a range (redundant since we couldn't have made a bounded LiteralRange in the first\n+        // place if we had found no range nodes)\n+        if (range == null) {\n             log.debug(\"Cannot find range operator nodes that encompass this query. Not proceeding with range expansion for this node.\");\n             return currentNode;\n         }\n         \n-        for (Map.Entry<LiteralRange<?>,List<JexlNode>> range : ranges.entrySet()) {\n-            IndexLookup lookup = ShardIndexQueryTableStaticMethods.expandRange(range.getKey());\n-            \n-            IndexLookupMap fieldsToTerms = null;\n-            \n-            try {\n-                fieldsToTerms = lookup.lookup(config, scannerFactory, config.getMaxIndexScanTimeMillis());\n-            } catch (IllegalRangeArgumentException e) {\n-                log.info(\"Cannot expand \"\n-                                + range\n-                                + \" because it creates an invalid Accumulo Range. This is likely due to bad user input or failed normalization. This range will be ignored.\");\n-                return RebuildingVisitor.copy(currentNode);\n-            }\n-            \n-            // If we have any terms that we expanded, wrap them in parens and add them to the parent\n-            ASTAndNode onlyRangeNodes = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-            \n-            JexlNodes.ensureCapacity(onlyRangeNodes, range.getValue().size());\n-            for (int i = 0; i < range.getValue().size(); i++) {\n-                onlyRangeNodes.jjtAddChild(range.getValue().get(i), i);\n-            }\n-            \n-            JexlNode orNode = JexlNodeFactory.createNodeTreeFromFieldsToValues(JexlNodeFactory.ContainerType.OR_NODE, new ASTEQNode(\n-                            ParserTreeConstants.JJTEQNODE), onlyRangeNodes, fieldsToTerms, expandFields, expandValues, false);\n-            \n-            // Set the parent and child pointers accordingly\n-            orNode.jjtSetParent(newNode);\n-            newNode.jjtAddChild(orNode, index++);\n-            \n-        }\n+        IndexLookup lookup = ShardIndexQueryTableStaticMethods.expandRange(range);\n         \n-        // If we had no other nodes than this bounded range, we can strip out the original parent\n-        if (newNode.jjtGetNumChildren() == 1) {\n-            newNode.jjtGetChild(0).jjtSetParent(newNode.jjtGetParent());\n-            return newNode.jjtGetChild(0);\n-        }\n+        IndexLookupMap fieldsToTerms = null;\n         \n-        return newNode;\n-    }\n-    \n-    /**\n-     * We only want to expand a range if it is more selective than a node it is ANDed with.\n-     *\n-     * @param node\n-     * @param range\n-     * @return\n-     */\n-    public boolean shouldExpandRangeBasedOnSelectivity(JexlNode node, LiteralRange<?> range) {\n-        return shouldExpandRangeBasedOnSelectivity(node, range, IndexStatsClient.DEFAULT_VALUE);\n-    }\n-    \n-    /**\n-     * We only want to expand a range if it is more selective than a node it is ANDed with.\n-     *\n-     * @param node\n-     * @param range\n-     * @param rangeSelectivity\n-     * @return\n-     */\n-    protected boolean shouldExpandRangeBasedOnSelectivity(JexlNode node, LiteralRange<?> range, Double rangeSelectivity) {\n-        switch (id(node)) {\n-            case ParserTreeConstants.JJTGENODE:\n-            case ParserTreeConstants.JJTGTNODE:\n-            case ParserTreeConstants.JJTLENODE:\n-            case ParserTreeConstants.JJTLTNODE:\n-            case ParserTreeConstants.JJTREFERENCE:\n-            case ParserTreeConstants.JJTREFERENCEEXPRESSION:\n-                // recurse up the tree\n-                return shouldExpandRangeBasedOnSelectivity(node.jjtGetParent(), range, rangeSelectivity);\n-            case ParserTreeConstants.JJTANDNODE:\n-                boolean foundChildSelectivity = false;\n-                if (rangeSelectivity.equals(IndexStatsClient.DEFAULT_VALUE)) {\n-                    // only want to fetch the range selectivity once\n-                    rangeSelectivity = JexlASTHelper.getNodeSelectivity(Sets.newHashSet(range.getFieldName()), config, stats);\n-                    if (log.isDebugEnabled())\n-                        log.debug(\"Range selectivity:\" + rangeSelectivity);\n-                }\n-                for (JexlNode child : JexlASTHelper.getEQNodes(node)) {\n-                    // Try to get selectivity for each child\n-                    Double childSelectivity = JexlASTHelper.getNodeSelectivity(child, config, stats);\n-                    \n-                    if (childSelectivity.equals(IndexStatsClient.DEFAULT_VALUE)) {\n-                        continue;\n-                    } else {\n-                        foundChildSelectivity = true;\n-                    }\n-                    \n-                    if (log.isDebugEnabled() && foundChildSelectivity)\n-                        log.debug(\"Max Child selectivity: \" + childSelectivity);\n-                    \n-                    // If the child is an EQ node, is indexed, and is more\n-                    // selective than the regex we don't need to process the regex\n-                    if (JexlASTHelper.getIdentifierOpLiteral(child) != null && JexlASTHelper.isIndexed(child, config) && rangeSelectivity < childSelectivity) {\n-                        return false;\n-                    }\n-                }\n-                \n-                return shouldExpandRangeBasedOnSelectivity(node.jjtGetParent(), range, rangeSelectivity);\n-            default:\n-                return true;\n-        }\n-    }\n-    \n-    /**\n-     * Walks up an AST and evaluates subtrees as needed. This method will fail fast if we determine we do not have to process a regex, otherwise the entire tree\n-     * will be evaluated.\n-     * \n-     * This method recurses upwards, searching for an AND or OR node in the lineage. Once of those nodes is found, then the subtree rooted at that node is\n-     * evaluated. The visit map is used to cache already evaluated subtrees, so moving to a parent will not cause a subtree to be evaluated along with its\n-     * unevaluated siblings.\n-     * \n-     * @param node\n-     *            - node to consider\n-     * \n-     * @param visited\n-     *            - a visit list that contains the computed values for subtrees already visited, in case they are needed\n-     * \n-     * @return true - if a regex has to be expanded false - if a regex doesn't have to be expanded\n-     */\n-    private boolean ascendTree(JexlNode node, Map<JexlNode,Boolean> visited) {\n-        if (node == null) {\n-            return true;\n-        } else {\n-            switch (id(node)) {\n-                case ParserTreeConstants.JJTORNODE:\n-                case ParserTreeConstants.JJTANDNODE: {\n-                    boolean expand = descendIntoSubtree(node, visited);\n-                    if (expand) {\n-                        return ascendTree(node.jjtGetParent(), visited);\n-                    } else {\n-                        return expand;\n-                    }\n-                }\n-                default:\n-                    return ascendTree(node.jjtGetParent(), visited);\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * Evaluates a subtree to see if it can prevent the expansion of a regular expression.\n-     * \n-     * This method recurses down under three conditions:\n-     * \n-     * 1) An OR is encountered. In this case the result of recursing down the subtrees rooted at each child is OR'd together and returned. 2) An AND is\n-     * encountered. In this case the result of recursing down the subtrees rooted at each child is AND'd together and returned. 3) Any node that is not an EQ\n-     * node and has only 1 child. If there are multiple children, this method returns true, indicating that the subtree cannot defeat a regex expansion.\n-     * \n-     * If an EQ node is encountered, we check if it can defeat an expansion by returning the value of a call to `doesNodeSupportRegexExpansion` on the node.\n-     * \n-     * @param node\n-     * \n-     * @return true - if a regex has to be expanded false - if a regex doesn't have to be expanded\n-     */\n-    private boolean descendIntoSubtree(JexlNode node, Map<JexlNode,Boolean> visited) {\n-        switch (id(node)) {\n-            case ParserTreeConstants.JJTORNODE: {\n-                return computeExpansionForSubtree(node, Join.OR, visited);\n-            }\n-            case ParserTreeConstants.JJTANDNODE: {\n-                return computeExpansionForSubtree(node, Join.AND, visited);\n-            }\n-            case ParserTreeConstants.JJTEQNODE: {\n-                boolean expand = doesNodeSupportRegexExpansion(node);\n-                visited.put(node, expand);\n-                return expand;\n-            }\n-            default: {\n-                JexlNode[] children = children(node);\n-                if (children.length == 1) {\n-                    boolean expand = descendIntoSubtree(children[0], visited);\n-                    visited.put(node, expand);\n-                    return expand;\n-                } else {\n-                    return true;\n-                }\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * If we have a literal equality on an indexed field, then this can be used to defeat a wild card expansion.\n-     * \n-     * @return `true` if we should expand a regular expression node given this subtree `false` if we should not expand a regular expression node given this\n-     *         subtree\n-     */\n-    private boolean doesNodeSupportRegexExpansion(JexlNode node) {\n-        return !(node instanceof ASTEQNode && JexlASTHelper.getIdentifierOpLiteral(node) != null && JexlASTHelper.isIndexed(node, config));\n-    }\n-    \n-    /**\n-     * Abstraction to indicate whether to use {@code `&=` or `|=`} when processing a node's subtrees.\n-     */\n-    enum Join {\n-        AND, OR\n-    }\n-    \n-    /**\n-     * The cases for OR and AND in `descendIntoSubtree` were almost equal, save for the initial value for expand and the operator used to join the results of\n-     * each child. I made this little macro doohickey to allow the differences between the two processes to be abstracted away.\n-     * \n-     */\n-    private boolean computeExpansionForSubtree(JexlNode node, Join join, Map<JexlNode,Boolean> visited) {\n-        boolean expand = Join.AND.equals(join);\n-        for (JexlNode child : children(node)) {\n-            Boolean computedValue = visited.get(child);\n-            if (computedValue == null) {\n-                computedValue = descendIntoSubtree(child, visited);\n-                visited.put(child, computedValue);\n-            }\n-            switch (join) {\n-                case AND:\n-                    expand &= computedValue;\n-                    break;\n-                case OR:\n-                    expand |= computedValue;\n-            }\n-        }\n-        visited.put(node, expand);\n-        return expand;\n-    }\n-    \n-    public void collapseAndSubtrees(ASTAndNode node, List<JexlNode> subTrees) {\n-        for (JexlNode child : children(node)) {\n-            if (ParserTreeConstants.JJTANDNODE == id(child)) {\n-                collapseAndSubtrees((ASTAndNode) child, subTrees);\n-            } else {\n-                subTrees.add(child);\n-            }\n+        try {\n+            fieldsToTerms = lookup.lookup(config, scannerFactory, config.getMaxIndexScanTimeMillis());\n+        } catch (IllegalRangeArgumentException e) {\n+            log.info(\"Cannot expand \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxMDAwMw==", "bodyText": "Is it temporary or not?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516810003", "createdAt": "2020-11-03T16:46:52Z", "author": {"login": "apmoriarty"}, "path": "warehouse/query-core/src/main/java/datawave/query/planner/DefaultQueryPlanner.java", "diffHunk": "@@ -670,6 +676,11 @@ protected ASTJexlScript updateQueryTree(ScannerFactory scannerFactory, MetadataH\n         \n         stopwatch.stop();\n         \n+        // TEMPORARY?: CHECK FOR UNMARKED BOUNDED RANGES", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxMTQ3MQ==", "bodyText": "stray import", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516811471", "createdAt": "2020-11-03T16:48:48Z", "author": {"login": "apmoriarty"}, "path": "warehouse/query-core/src/test/java/datawave/query/DelayedIndexOnlyQueryTest.java", "diffHunk": "@@ -7,6 +7,7 @@\n import datawave.query.testframework.DataTypeHadoopConfig;\n import datawave.query.testframework.FieldConfig;\n import datawave.query.testframework.GenericCityFields;\n+import org.apache.log4j.Level;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxMTkyOA==", "bodyText": "Founded is such a fun word.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516811928", "createdAt": "2020-11-03T16:49:27Z", "author": {"login": "apmoriarty"}, "path": "warehouse/query-core/src/test/java/datawave/query/GroupedFlattenQueryTest.java", "diffHunk": "@@ -114,13 +114,26 @@ public void testCounty() throws Exception {\n     }\n     \n     @Test\n-    public void testFoundedRange() throws Exception {\n+    public void testFoundedRangeUnbounded() throws Exception {\n         log.info(\"------  testFoundedRange  ------\");\n         String start = \"1850\";\n         String end = \"1860\";\n         String city = \"'AuStiN'\";\n-        String query = GroupedField.CITY.name() + EQ_OP + city + AND_OP + \"(\" + GroupedField.FOUNDED.name() + GT_OP + start + AND_OP\n-                        + GroupedField.FOUNDED.name() + LT_OP + end + \")\";\n+        String query = GroupedField.CITY.name() + EQ_OP + city + AND_OP + GroupedField.FOUNDED.name() + GT_OP + start + AND_OP + GroupedField.FOUNDED.name()\n+                        + LT_OP + end;\n+        // all entries have at least one founded less than end and one founded greater than start, just not the same value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNTgxNDI4", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#pullrequestreview-522581428", "createdAt": "2020-11-03T14:58:38Z", "commit": {"oid": "2bfbaeb558c97cde50dc66243bbb5ee61862bbf5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNTowNjoxOFrOHszEOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzoyMzo1N1rOHs5GPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczNjA1OA==", "bodyText": "reuse JexlASTHelper.isDelayedPredicate()", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516736058", "createdAt": "2020-11-03T15:06:18Z", "author": {"login": "FineAndDandy"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ExpandMultiNormalizedTerms.java", "diffHunk": "@@ -356,4 +290,20 @@ protected JexlNode expandNodeForNormalizers(JexlNode node, Object data) {\n         }\n         return nodeToReturn;\n     }\n+    \n+    /**\n+     * method to return if the current node is an instance of a delayed predicate\n+     *\n+     * @param currNode\n+     * @return\n+     */\n+    protected boolean isDelayedPredicate(JexlNode currNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MTI4MQ==", "bodyText": "LiteralRange already includes Key. Do we need to do the conversions to string here?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516771281", "createdAt": "2020-11-03T15:52:49Z", "author": {"login": "FineAndDandy"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/PushdownLargeFieldedListsVisitor.java", "diffHunk": "@@ -216,15 +218,10 @@ private void copyChildren(Collection<JexlNode> children, Collection<JexlNode> co\n     }\n     \n     protected Range rangeNodeToRange(JexlNode node) {\n-        if (ExceededValueThresholdMarkerJexlNode.instanceOf(node)) {\n-            return rangeNodeToRange(ExceededValueThresholdMarkerJexlNode.getExceededValueThresholdSource(node));\n-        } else if ((node.jjtGetNumChildren() == 1) && (node instanceof ASTReferenceExpression || node instanceof ASTReference || node instanceof ASTAndNode)) {\n-            return rangeNodeToRange(node.jjtGetChild(0));\n-        } else if ((node.jjtGetNumChildren() == 2) && node instanceof ASTAndNode) {\n-            JexlNode leftChild = node.jjtGetChild(0);\n-            JexlNode rightChild = node.jjtGetChild(1);\n-            return new Range(new Key(String.valueOf(JexlASTHelper.getLiteralValue(leftChild))), leftChild instanceof ASTGENode, new Key(\n-                            String.valueOf(JexlASTHelper.getLiteralValue(rightChild))), rightChild instanceof ASTLENode);\n+        LiteralRange range = JexlASTHelper.findRange().getRange(node);\n+        if (range != null) {\n+            return new Range(new Key(String.valueOf(range.getLower())), range.isLowerInclusive(), new Key(String.valueOf(range.getUpper())),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc4NDQ4Mg==", "bodyText": "did you mean to revisit this? Or should this comment be removed?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516784482", "createdAt": "2020-11-03T16:10:54Z", "author": {"login": "FineAndDandy"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/QueryPruningVisitor.java", "diffHunk": "@@ -253,6 +253,11 @@ public Object visit(ASTOrNode node, Object data) {\n     \n     @Override\n     public Object visit(ASTAndNode node, Object data) {\n+        // do not process query property markers\n+        // if (QueryPropertyMarker.instanceOf(node, null)) {\n+        // return TruthState.UNKNOWN;\n+        // }\n+        ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwNDU2Ng==", "bodyText": "can lookup ever be null?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516804566", "createdAt": "2020-11-03T16:39:11Z", "author": {"login": "FineAndDandy"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/RangeConjunctionRebuildingVisitor.java", "diffHunk": "@@ -117,335 +111,43 @@ public Object visit(ASTReference node, Object data) {\n                 ExceededValueThresholdMarkerJexlNode.class, ExceededTermThresholdMarkerJexlNode.class, ExceededOrThresholdMarkerJexlNode.class});\n         if (QueryPropertyMarkerVisitor.instanceOf(node, markers, null)) {\n             return node;\n-        } else\n-            return super.visit(node, data);\n-    }\n-    \n-    @Override\n-    public Object visit(ASTLTNode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTGTNode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTLENode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTGENode node, Object data) {\n-        return node;\n-    }\n-    \n-    @Override\n-    public Object visit(ASTAndNode node, Object data) {\n-        List<JexlNode> leaves = new ArrayList<>();\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = JexlASTHelper.getBoundedRanges(node, this.config.getDatatypeFilter(), this.helper, leaves, false);\n-        \n-        JexlNode andNode = JexlNodes.newInstanceOfType(node);\n-        andNode.image = node.image;\n-        andNode.jjtSetParent(node.jjtGetParent());\n-        \n-        // We have a bounded range completely inside of an AND/OR\n-        if (!ranges.isEmpty()) {\n-            andNode = expandIndexBoundedRange(ranges, leaves, node, andNode, data);\n-        } else {\n-            // We have no bounded range to replace, just proceed as normal\n-            JexlNodes.ensureCapacity(andNode, node.jjtGetNumChildren());\n-            for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n-                JexlNode newChild = (JexlNode) node.jjtGetChild(i).jjtAccept(this, data);\n-                \n-                andNode.jjtAddChild(newChild, i);\n-                newChild.jjtSetParent(andNode);\n+        } else if (BoundedRange.instanceOf(node)) {\n+            LiteralRange range = JexlASTHelper.findRange().indexedOnly(this.config.getDatatypeFilter(), this.helper).notDelayed().getRange(node);\n+            if (range != null) {\n+                return expandIndexBoundedRange(range, node);\n+            } else {\n+                return super.visit(node, data);\n             }\n+        } else {\n+            return super.visit(node, data);\n         }\n-        \n-        return andNode;\n     }\n     \n-    protected JexlNode expandIndexBoundedRange(Map<LiteralRange<?>,List<JexlNode>> ranges, List<JexlNode> leaves, ASTAndNode currentNode, JexlNode newNode,\n-                    Object data) {\n-        // Add all children in this AND/OR which are not a part of the range\n-        JexlNodes.ensureCapacity(newNode, leaves.size() + ranges.size());\n-        int index = 0;\n-        for (; index < leaves.size(); index++) {\n-            log.debug(leaves.get(index).image);\n-            // Add each child which is not a part of the bounded range, visiting them first\n-            JexlNode visitedChild = (JexlNode) leaves.get(index).jjtAccept(this, null);\n-            newNode.jjtAddChild(visitedChild, index);\n-            visitedChild.jjtSetParent(newNode);\n-        }\n-        \n-        // Sanity check to ensure that we found some nodes (redundant since we couldn't have made a bounded LiteralRange in the first\n-        // place if we had found not range nodes)\n-        if (ranges.isEmpty()) {\n+    protected JexlNode expandIndexBoundedRange(LiteralRange range, ASTReference currentNode) {\n+        // Sanity check to ensure that we found a range (redundant since we couldn't have made a bounded LiteralRange in the first\n+        // place if we had found no range nodes)\n+        if (range == null) {\n             log.debug(\"Cannot find range operator nodes that encompass this query. Not proceeding with range expansion for this node.\");\n             return currentNode;\n         }\n         \n-        for (Map.Entry<LiteralRange<?>,List<JexlNode>> range : ranges.entrySet()) {\n-            IndexLookup lookup = ShardIndexQueryTableStaticMethods.expandRange(range.getKey());\n-            \n-            IndexLookupMap fieldsToTerms = null;\n-            \n-            try {\n-                fieldsToTerms = lookup.lookup(config, scannerFactory, config.getMaxIndexScanTimeMillis());\n-            } catch (IllegalRangeArgumentException e) {\n-                log.info(\"Cannot expand \"\n-                                + range\n-                                + \" because it creates an invalid Accumulo Range. This is likely due to bad user input or failed normalization. This range will be ignored.\");\n-                return RebuildingVisitor.copy(currentNode);\n-            }\n-            \n-            // If we have any terms that we expanded, wrap them in parens and add them to the parent\n-            ASTAndNode onlyRangeNodes = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-            \n-            JexlNodes.ensureCapacity(onlyRangeNodes, range.getValue().size());\n-            for (int i = 0; i < range.getValue().size(); i++) {\n-                onlyRangeNodes.jjtAddChild(range.getValue().get(i), i);\n-            }\n-            \n-            JexlNode orNode = JexlNodeFactory.createNodeTreeFromFieldsToValues(JexlNodeFactory.ContainerType.OR_NODE, new ASTEQNode(\n-                            ParserTreeConstants.JJTEQNODE), onlyRangeNodes, fieldsToTerms, expandFields, expandValues, false);\n-            \n-            // Set the parent and child pointers accordingly\n-            orNode.jjtSetParent(newNode);\n-            newNode.jjtAddChild(orNode, index++);\n-            \n-        }\n+        IndexLookup lookup = ShardIndexQueryTableStaticMethods.expandRange(range);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwODcyMQ==", "bodyText": "can you explain this case?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516808721", "createdAt": "2020-11-03T16:45:17Z", "author": {"login": "FineAndDandy"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/UnmarkedBoundedRangeDetectionVisitor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import datawave.query.jexl.nodes.BoundedRange;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class UnmarkedBoundedRangeDetectionVisitor extends BaseVisitor {\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public static boolean findUnmarkedBoundedRanges(JexlNode script) {\n+        UnmarkedBoundedRangeDetectionVisitor visitor = new UnmarkedBoundedRangeDetectionVisitor();\n+        \n+        AtomicBoolean unmarked = new AtomicBoolean(false);\n+        script.jjtAccept(visitor, unmarked);\n+        \n+        return unmarked.get();\n+    }\n+    \n+    @Override\n+    public Object visit(ASTReference node, Object data) {\n+        if (BoundedRange.instanceOf(node)) {\n+            if (!JexlASTHelper.findRange().isRange(node)) {\n+                if (null != data) {\n+                    AtomicBoolean hasBounded = (AtomicBoolean) data;\n+                    hasBounded.set(true);\n+                }\n+            }\n+            \n+            return false;\n+        } else if (JexlASTHelper.findRange().notDelayed().notMarked().isRange(node)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxMTEyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \n          \n          \n            \n            boolean isBounded = !lowerWildcard && !upperWildcard;\n          \n          \n            \n            if (isBounded) { \n          \n          \n            \n                sb.append(\"((BoundedRange = true) && \");\n          \n          \n            \n            }        \n          \n          \n            \n            ...\n          \n          \n            \n            \n          \n          \n            \n            if (isBounded){\n          \n          \n            \n                sb.append(\")\");\n          \n          \n            \n            }", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516811123", "createdAt": "2020-11-03T16:48:17Z", "author": {"login": "FineAndDandy"}, "path": "warehouse/query-core/src/main/java/datawave/query/language/parser/jexl/JexlRangeNode.java", "diffHunk": "@@ -37,6 +37,10 @@ public String toString() {\n         boolean lowerWildcard = beginRange.equals(\"*\");\n         boolean upperWildcard = endRange.equals(\"*\");\n         ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyOTg0MQ==", "bodyText": "why has this case changed?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516829841", "createdAt": "2020-11-03T17:16:15Z", "author": {"login": "FineAndDandy"}, "path": "warehouse/query-core/src/test/java/datawave/query/RangeQueryTest.java", "diffHunk": "@@ -131,26 +139,28 @@ public void testSingleValueAndMultiFieldWithParens() throws Exception {\n         }\n     }\n     \n-    @Test\n+    @Test(expected = FullTableScansDisallowedException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNDg3OQ==", "bodyText": "test lower is 1 and upper is 5? also inclusive/exclusive flags?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r516834879", "createdAt": "2020-11-03T17:23:57Z", "author": {"login": "FineAndDandy"}, "path": "warehouse/query-core/src/test/java/datawave/query/jexl/JexlASTHelperTest.java", "diffHunk": "@@ -247,38 +249,81 @@ public void testApplyNormalization() throws Throwable {\n     }\n     \n     @Test\n-    public void testNonRangeNodeNegation() throws Exception {\n-        ASTJexlScript script = JexlASTHelper.parseJexlQuery(\"A < 'b' && A > 'a' && !(FOO == 'bar')\");\n+    public void testFindRange() throws Exception {\n+        ASTJexlScript script = JexlASTHelper.parseJexlQuery(\"((BoundedRange = true) && (A < 'b' && A > 'a')) && !(FOO == 'bar')\");\n         \n-        List<JexlNode> nonRangeChildNodes = new ArrayList<>();\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = JexlASTHelper\n-                        .getBoundedRangesIndexAgnostic((ASTAndNode) (script.jjtGetChild(0)), nonRangeChildNodes, true);\n+        LiteralRange range = JexlASTHelper.findRange().getRange(script.jjtGetChild(0));\n         \n-        Assert.assertEquals(1, ranges.size());\n-        Assert.assertEquals(2, ranges.values().iterator().next().size());\n-        Assert.assertEquals(1, nonRangeChildNodes.size());\n-        Assert.assertEquals(ASTNotNode.class, nonRangeChildNodes.get(0).getClass());\n+        Assert.assertNull(range);\n         \n-        script = JexlASTHelper.parseJexlQuery(\"A < 5 && A > 1 && !(FOO == 'bar' && !(BAR == 'foo') && BAR != 'foo')\");\n+        script = JexlASTHelper.parseJexlQuery(\"(A < 5 && A > 1)\");\n         \n-        nonRangeChildNodes.clear();\n-        ranges = JexlASTHelper.getBoundedRangesIndexAgnostic((ASTAndNode) (script.jjtGetChild(0)), nonRangeChildNodes, true);\n+        range = JexlASTHelper.findRange().getRange(script.jjtGetChild(0));\n         \n-        Assert.assertEquals(1, ranges.size());\n-        Assert.assertEquals(2, ranges.values().iterator().next().size());\n-        Assert.assertEquals(1, nonRangeChildNodes.size());\n-        Assert.assertEquals(ASTNotNode.class, nonRangeChildNodes.get(0).getClass());\n+        Assert.assertNull(range);\n         \n-        script = JexlASTHelper\n-                        .parseJexlQuery(\"A < 5 && A > 1 && !(FOO == 'term' && !(BAR =~ 'regex') && BAR !~ 'regex' && (BAR != 'term') && ! (BAR == 'term') && FOO =~ 'regex')\");\n+        script = JexlASTHelper.parseJexlQuery(\"((BoundedRange = true) && (A < 5 && A > 1))\");\n         \n-        nonRangeChildNodes.clear();\n-        ranges = JexlASTHelper.getBoundedRangesIndexAgnostic((ASTAndNode) (script.jjtGetChild(0)), nonRangeChildNodes, true);\n+        range = JexlASTHelper.findRange().getRange(script.jjtGetChild(0));\n         \n-        Assert.assertEquals(1, ranges.size());\n-        Assert.assertEquals(2, ranges.values().iterator().next().size());\n-        Assert.assertEquals(1, nonRangeChildNodes.size());\n-        Assert.assertEquals(ASTNotNode.class, nonRangeChildNodes.get(0).getClass());\n+        Assert.assertNotNull(range);\n+        Assert.assertNotNull(range.getLowerNode());\n+        Assert.assertNotNull(range.getUpperNode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/1913c941c58dd01d84a7ea384d8356054a855778", "committedDate": "2020-12-17T23:16:33Z", "message": "re #902: Change JEXL to enforce using a BoundedRange marker for bounded ranges.\n * Added a visitor to detect invalid marked bounded ranges and ranges that are not marked.\n * Unexpanded bounded ranges not ivarated are non-executable (from an index point of view)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/317e8815eb1948375ec4445c768189d25e789e01", "committedDate": "2020-11-02T18:14:14Z", "message": "re #902: Change JEXL to enforce using a BoundedRange marker for bounded ranges.\n * Added a visitor to detect invalid marked bounded ranges and ranges that are not marked.\n * Unexpanded bounded ranges not ivarated are non-executable (from an index point of view)"}, "afterCommit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/1913c941c58dd01d84a7ea384d8356054a855778", "committedDate": "2020-12-17T23:16:33Z", "message": "re #902: Change JEXL to enforce using a BoundedRange marker for bounded ranges.\n * Added a visitor to detect invalid marked bounded ranges and ranges that are not marked.\n * Unexpanded bounded ranges not ivarated are non-executable (from an index point of view)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b61bebef50e12079a2d6d9bb23091dacd4570f00", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/b61bebef50e12079a2d6d9bb23091dacd4570f00", "committedDate": "2020-12-18T15:01:55Z", "message": "spotbug fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjA2ODQw", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#pullrequestreview-555606840", "createdAt": "2020-12-18T15:52:43Z", "commit": {"oid": "b61bebef50e12079a2d6d9bb23091dacd4570f00"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo1Mjo0M1rOIIokoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo1Mjo0M1rOIIokoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkyNDI1Ng==", "bodyText": "Maybe 'literal' and 'literal2' to avoid 'l1'?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545924256", "createdAt": "2020-12-18T15:52:43Z", "author": {"login": "apmoriarty"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/JexlASTHelper.java", "diffHunk": "@@ -793,492 +798,364 @@ private static void getERNodes(JexlNode node, List<ASTERNode> erNodes) {\n     }\n     \n     /**\n-     * Get the bounded ranges (index only terms).\n-     *\n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n+     * Ranges: A range prior to being \"tagged\" must be of the form \"(term1 &amp;&amp; term2)\" where term1 and term2 refer to the same field and denote two sides\n+     * of the range ((LE or LT) and (GE or GT)). A tagged range is of the form \"(BoundedRange=true) &amp;&amp; (term1 &amp;&amp; term2))\"\n      */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed, int maxDepth) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, maxDepth);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n+    public static RangeFinder findRange() {\n+        return new RangeFinder();\n     }\n     \n-    /**\n-     * Get the bounded ranges (index only terms).\n-     * \n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, -1);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     *\n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed,\n-                    int maxDepth) {\n-        List<JexlNode> rangeNodes = getRangeOperatorNodes(root, otherNodes, includeDelayed, maxDepth);\n-        return JexlASTHelper.getBoundedRanges(rangeNodes, null, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     * \n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed) {\n-        return getBoundedRangesIndexAgnostic(root, otherNodes, includeDelayed, -1);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> nonIndexedRangeNodes,\n-                    List<JexlNode> otherNodes) {\n-        \n-        // if the non-indexed range nodes were split out, then lets group them back into their AND expressions and put them in the\n-        // other node list (see getBoundedRanges vs. getBoundedRangesIndexAgnostic)\n-        if (nonIndexedRangeNodes != null && otherNodes != null) {\n-            Map<LiteralRange<?>,List<JexlNode>> ranges = getBoundedRanges(nonIndexedRangeNodes, otherNodes);\n-            for (List<JexlNode> range : ranges.values()) {\n-                // create a ref -> ref_exp -> and -> <range nodes>\n-                ASTAndNode andNode = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-                andNode = JexlNodes.children(andNode, range.get(0), range.get(1));\n-                ASTReferenceExpression refExpNode = JexlNodes.wrap(andNode);\n-                ASTReference refNode = JexlNodes.makeRef(refExpNode);\n-                otherNodes.add(refNode);\n+    public static class RangeFinder {\n+        boolean includeDelayed = true;\n+        MetadataHelper helper = null;\n+        Set<String> dataTypeFilter = null;\n+        boolean recursive = false;\n+        boolean withMarker = true;\n+        \n+        public RangeFinder notDelayed() {\n+            includeDelayed = false;\n+            return this;\n+        }\n+        \n+        public RangeFinder indexedOnly(Set<String> dataTypeFilter, MetadataHelper helper) {\n+            this.dataTypeFilter = dataTypeFilter;\n+            this.helper = helper;\n+            return this;\n+        }\n+        \n+        public RangeFinder recursively() {\n+            this.recursive = true;\n+            return this;\n+        }\n+        \n+        public RangeFinder notMarked() {\n+            this.withMarker = false;\n+            return this;\n+        }\n+        \n+        public boolean isRange(JexlNode node) {\n+            return getRange(node) != null;\n+        }\n+        \n+        public LiteralRange getRange(JexlNode node) {\n+            LiteralRange range = _getRange(node);\n+            if (range == null && recursive) {\n+                for (int i = 0; range == null && i < node.jjtGetNumChildren(); i++) {\n+                    range = getRange(node.jjtGetChild(i));\n+                }\n             }\n+            return range;\n         }\n-        return getBoundedRanges(rangeNodes, otherNodes);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> otherNodes) {\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = new HashMap<>();\n         \n-        while (!rangeNodes.isEmpty()) {\n-            JexlNode firstNode = rangeNodes.get(0);\n-            String fieldName = JexlASTHelper.getIdentifier(firstNode);\n-            Object literal = JexlASTHelper.getLiteralValue(firstNode);\n+        private LiteralRange _getRange(JexlNode node) {\n+            boolean marked = BoundedRange.instanceOf(node);\n+            \n+            // first unwrap any delayed expression except for a tag\n+            if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {\n+                node = QueryPropertyMarker.getQueryPropertySource(node, null);\n+                marked = BoundedRange.instanceOf(node);\n+            }\n+            \n+            // It must be marked\n+            if (withMarker && !marked) {\n+                return null;\n+            }\n+            \n+            // remove the marker\n+            if (marked) {\n+                node = BoundedRange.getBoundedRangeSource(node);\n+            }\n+            \n+            // remove reference and expression nodes\n+            node = dereference(node);\n+            \n+            // must be an and node at this point\n+            if (!(node instanceof ASTAndNode)) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain an AND node with two bounds\");\n+                return null;\n+            }\n+            \n+            // and has exactly two children\n+            if (node.jjtGetNumChildren() != 2) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds\");\n+                return null;\n+            }\n+            \n+            JexlNode child1 = dereference(node.jjtGetChild(0));\n+            JexlNode child2 = dereference(node.jjtGetChild(1));\n+            \n+            // and the fieldnames match\n+            String fieldName1 = null;\n+            String fieldName2 = null;\n+            try {\n+                fieldName1 = JexlASTHelper.getIdentifier(child1);\n+                fieldName2 = JexlASTHelper.getIdentifier(child2);\n+            } catch (NoSuchElementException e) {}\n+            if (fieldName1 == null || fieldName2 == null || !fieldName1.equals(fieldName2)) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds against the same field\");\n+                return null;\n+            }\n+            \n+            // and is indexed (if we care) {\n+            try {\n+                if (helper != null && !helper.isIndexed(fieldName1, dataTypeFilter)) {\n+                    return null;\n+                }\n+            } catch (TableNotFoundException tnfe) {\n+                NotFoundQueryException qe = new NotFoundQueryException(DatawaveErrorCode.TABLE_NOT_FOUND, tnfe);\n+                throw new DatawaveFatalQueryException(qe);\n+            }\n+            \n+            Object literal1 = null;\n+            Object literal2 = null;\n+            try {\n+                literal1 = JexlASTHelper.getLiteralValue(child1);\n+                literal2 = JexlASTHelper.getLiteralValue(child2);\n+            } catch (NoSuchElementException e) {}\n+            \n+            if (literal1 == null || literal2 == null) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds with literals\");\n+                return null;\n+            }\n             \n             LiteralRange<?> range = null;\n-            List<JexlNode> thisRangesNodes = new ArrayList<>();\n-            if (literal instanceof String) {\n-                range = getStringBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof Integer) {\n-                range = getIntegerBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof Long) {\n-                range = getLongBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof BigInteger) {\n-                range = getBigIntegerBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof Float) {\n-                range = getFloatBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof Double) {\n-                range = getDoubleBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n-            } else if (literal instanceof BigDecimal) {\n-                range = getBigDecimalBoundedRange(rangeNodes, thisRangesNodes, new LiteralRange<>(fieldName, LiteralRange.NodeOperand.AND));\n+            JexlNode[] children = new JexlNode[] {child1, child2};\n+            if (literal1 instanceof String || literal2 instanceof String) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b61bebef50e12079a2d6d9bb23091dacd4570f00"}, "originalPosition": 273}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3f764c18b3b56405cf296cbdcacc03000b9612a", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/a3f764c18b3b56405cf296cbdcacc03000b9612a", "committedDate": "2020-12-18T17:43:44Z", "message": "re #902: Updated per review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2df4a4a08dccd327f73a7c32d255b49895eb81d1", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/2df4a4a08dccd327f73a7c32d255b49895eb81d1", "committedDate": "2020-12-18T17:58:20Z", "message": "re #902: better test case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjIwODkz", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#pullrequestreview-555620893", "createdAt": "2020-12-18T16:10:46Z", "commit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNjoxMDo0NlrOIIpOBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoxOToxNVrOIItrkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkzNDg1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean success = true;\n          \n          \n            \n                    if (node instanceof ASTAndNode)\n          \n          \n            \n                        for (int i = 0; i < node.jjtGetNumChildren(); i++)\n          \n          \n            \n                            success &= this.jexlNodeListLowerBound.contains(node.jjtGetChild(i)) || this.jexlNodeListUpperBound.contains(node.jjtGetChild(i));\n          \n          \n            \n                    LiteralRange range = JexlASTHelper.findRange().getRange(node);\n          \n          \n            \n                    if (range != null)\n          \n          \n            \n                        success &= this.jexlNodeListLowerBound.contains(range.getLowerNode()) && this.jexlNodeListUpperBound.contains(range.getUpperNode());\n          \n          \n            \n                    boolean success;\n          \n          \n            \n                    LiteralRange range = JexlASTHelper.findRange().getRange(node);\n          \n          \n            \n                    if (range != null)\n          \n          \n            \n                        success = this.jexlNodeListLowerBound.contains(range.getLowerNode()) && this.jexlNodeListUpperBound.contains(range.getUpperNode());", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545934853", "createdAt": "2020-12-18T16:10:46Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/composite/CompositeRange.java", "diffHunk": "@@ -305,9 +308,9 @@ public boolean isValid() {\n     \n     public boolean contains(JexlNode node) {\n         boolean success = true;\n-        if (node instanceof ASTAndNode)\n-            for (int i = 0; i < node.jjtGetNumChildren(); i++)\n-                success &= this.jexlNodeListLowerBound.contains(node.jjtGetChild(i)) || this.jexlNodeListUpperBound.contains(node.jjtGetChild(i));\n+        LiteralRange range = JexlASTHelper.findRange().getRange(node);\n+        if (range != null)\n+            success &= this.jexlNodeListLowerBound.contains(range.getLowerNode()) && this.jexlNodeListUpperBound.contains(range.getUpperNode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkzNTA0MQ==", "bodyText": "fix my bad code, please!", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545935041", "createdAt": "2020-12-18T16:11:09Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/composite/CompositeRange.java", "diffHunk": "@@ -305,9 +308,9 @@ public boolean isValid() {\n     \n     public boolean contains(JexlNode node) {\n         boolean success = true;\n-        if (node instanceof ASTAndNode)\n-            for (int i = 0; i < node.jjtGetNumChildren(); i++)\n-                success &= this.jexlNodeListLowerBound.contains(node.jjtGetChild(i)) || this.jexlNodeListUpperBound.contains(node.jjtGetChild(i));\n+        LiteralRange range = JexlASTHelper.findRange().getRange(node);\n+        if (range != null)\n+            success &= this.jexlNodeListLowerBound.contains(range.getLowerNode()) && this.jexlNodeListUpperBound.contains(range.getUpperNode());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkzNDg1Mw=="}, "originalCommit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0MTg2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {\n          \n          \n            \n                        if (includeDelayed && !marked && QueryPropertyMarker.instanceOf(node, null)) {\n          \n      \n    \n    \n  \n\nIf we already know that it's marked, let's not visit the tree a second time.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545941864", "createdAt": "2020-12-18T16:22:25Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/JexlASTHelper.java", "diffHunk": "@@ -793,492 +798,365 @@ private static void getERNodes(JexlNode node, List<ASTERNode> erNodes) {\n     }\n     \n     /**\n-     * Get the bounded ranges (index only terms).\n-     *\n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n+     * Ranges: A range prior to being \"tagged\" must be of the form \"(term1 &amp;&amp; term2)\" where term1 and term2 refer to the same field and denote two sides\n+     * of the range ((LE or LT) and (GE or GT)). A tagged range is of the form \"(BoundedRange=true) &amp;&amp; (term1 &amp;&amp; term2))\"\n      */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed, int maxDepth) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, maxDepth);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n+    public static RangeFinder findRange() {\n+        return new RangeFinder();\n     }\n     \n-    /**\n-     * Get the bounded ranges (index only terms).\n-     * \n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, -1);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     *\n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed,\n-                    int maxDepth) {\n-        List<JexlNode> rangeNodes = getRangeOperatorNodes(root, otherNodes, includeDelayed, maxDepth);\n-        return JexlASTHelper.getBoundedRanges(rangeNodes, null, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     * \n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed) {\n-        return getBoundedRangesIndexAgnostic(root, otherNodes, includeDelayed, -1);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> nonIndexedRangeNodes,\n-                    List<JexlNode> otherNodes) {\n-        \n-        // if the non-indexed range nodes were split out, then lets group them back into their AND expressions and put them in the\n-        // other node list (see getBoundedRanges vs. getBoundedRangesIndexAgnostic)\n-        if (nonIndexedRangeNodes != null && otherNodes != null) {\n-            Map<LiteralRange<?>,List<JexlNode>> ranges = getBoundedRanges(nonIndexedRangeNodes, otherNodes);\n-            for (List<JexlNode> range : ranges.values()) {\n-                // create a ref -> ref_exp -> and -> <range nodes>\n-                ASTAndNode andNode = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-                andNode = JexlNodes.children(andNode, range.get(0), range.get(1));\n-                ASTReferenceExpression refExpNode = JexlNodes.wrap(andNode);\n-                ASTReference refNode = JexlNodes.makeRef(refExpNode);\n-                otherNodes.add(refNode);\n+    public static class RangeFinder {\n+        boolean includeDelayed = true;\n+        MetadataHelper helper = null;\n+        Set<String> dataTypeFilter = null;\n+        boolean recursive = false;\n+        boolean withMarker = true;\n+        \n+        public RangeFinder notDelayed() {\n+            includeDelayed = false;\n+            return this;\n+        }\n+        \n+        public RangeFinder indexedOnly(Set<String> dataTypeFilter, MetadataHelper helper) {\n+            this.dataTypeFilter = dataTypeFilter;\n+            this.helper = helper;\n+            return this;\n+        }\n+        \n+        public RangeFinder recursively() {\n+            this.recursive = true;\n+            return this;\n+        }\n+        \n+        public RangeFinder notMarked() {\n+            this.withMarker = false;\n+            return this;\n+        }\n+        \n+        public boolean isRange(JexlNode node) {\n+            return getRange(node) != null;\n+        }\n+        \n+        public LiteralRange getRange(JexlNode node) {\n+            LiteralRange range = _getRange(node);\n+            if (range == null && recursive) {\n+                for (int i = 0; range == null && i < node.jjtGetNumChildren(); i++) {\n+                    range = getRange(node.jjtGetChild(i));\n+                }\n             }\n+            return range;\n         }\n-        return getBoundedRanges(rangeNodes, otherNodes);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> otherNodes) {\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = new HashMap<>();\n         \n-        while (!rangeNodes.isEmpty()) {\n-            JexlNode firstNode = rangeNodes.get(0);\n-            String fieldName = JexlASTHelper.getIdentifier(firstNode);\n-            Object literal = JexlASTHelper.getLiteralValue(firstNode);\n+        private LiteralRange _getRange(JexlNode node) {\n+            boolean marked = BoundedRange.instanceOf(node);\n+            \n+            // first unwrap any delayed expression except for a tag\n+            if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0MjkyMQ==", "bodyText": "Also, at some point we should update the QueryPropertyMarker.instanceOf method to return the marker class that was found if null is passed in for the type.  That way we can do a single pass and know exactly what we're dealing with.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545942921", "createdAt": "2020-12-18T16:24:05Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/JexlASTHelper.java", "diffHunk": "@@ -793,492 +798,365 @@ private static void getERNodes(JexlNode node, List<ASTERNode> erNodes) {\n     }\n     \n     /**\n-     * Get the bounded ranges (index only terms).\n-     *\n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n+     * Ranges: A range prior to being \"tagged\" must be of the form \"(term1 &amp;&amp; term2)\" where term1 and term2 refer to the same field and denote two sides\n+     * of the range ((LE or LT) and (GE or GT)). A tagged range is of the form \"(BoundedRange=true) &amp;&amp; (term1 &amp;&amp; term2))\"\n      */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed, int maxDepth) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, maxDepth);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n+    public static RangeFinder findRange() {\n+        return new RangeFinder();\n     }\n     \n-    /**\n-     * Get the bounded ranges (index only terms).\n-     * \n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, -1);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     *\n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed,\n-                    int maxDepth) {\n-        List<JexlNode> rangeNodes = getRangeOperatorNodes(root, otherNodes, includeDelayed, maxDepth);\n-        return JexlASTHelper.getBoundedRanges(rangeNodes, null, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     * \n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed) {\n-        return getBoundedRangesIndexAgnostic(root, otherNodes, includeDelayed, -1);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> nonIndexedRangeNodes,\n-                    List<JexlNode> otherNodes) {\n-        \n-        // if the non-indexed range nodes were split out, then lets group them back into their AND expressions and put them in the\n-        // other node list (see getBoundedRanges vs. getBoundedRangesIndexAgnostic)\n-        if (nonIndexedRangeNodes != null && otherNodes != null) {\n-            Map<LiteralRange<?>,List<JexlNode>> ranges = getBoundedRanges(nonIndexedRangeNodes, otherNodes);\n-            for (List<JexlNode> range : ranges.values()) {\n-                // create a ref -> ref_exp -> and -> <range nodes>\n-                ASTAndNode andNode = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-                andNode = JexlNodes.children(andNode, range.get(0), range.get(1));\n-                ASTReferenceExpression refExpNode = JexlNodes.wrap(andNode);\n-                ASTReference refNode = JexlNodes.makeRef(refExpNode);\n-                otherNodes.add(refNode);\n+    public static class RangeFinder {\n+        boolean includeDelayed = true;\n+        MetadataHelper helper = null;\n+        Set<String> dataTypeFilter = null;\n+        boolean recursive = false;\n+        boolean withMarker = true;\n+        \n+        public RangeFinder notDelayed() {\n+            includeDelayed = false;\n+            return this;\n+        }\n+        \n+        public RangeFinder indexedOnly(Set<String> dataTypeFilter, MetadataHelper helper) {\n+            this.dataTypeFilter = dataTypeFilter;\n+            this.helper = helper;\n+            return this;\n+        }\n+        \n+        public RangeFinder recursively() {\n+            this.recursive = true;\n+            return this;\n+        }\n+        \n+        public RangeFinder notMarked() {\n+            this.withMarker = false;\n+            return this;\n+        }\n+        \n+        public boolean isRange(JexlNode node) {\n+            return getRange(node) != null;\n+        }\n+        \n+        public LiteralRange getRange(JexlNode node) {\n+            LiteralRange range = _getRange(node);\n+            if (range == null && recursive) {\n+                for (int i = 0; range == null && i < node.jjtGetNumChildren(); i++) {\n+                    range = getRange(node.jjtGetChild(i));\n+                }\n             }\n+            return range;\n         }\n-        return getBoundedRanges(rangeNodes, otherNodes);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> otherNodes) {\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = new HashMap<>();\n         \n-        while (!rangeNodes.isEmpty()) {\n-            JexlNode firstNode = rangeNodes.get(0);\n-            String fieldName = JexlASTHelper.getIdentifier(firstNode);\n-            Object literal = JexlASTHelper.getLiteralValue(firstNode);\n+        private LiteralRange _getRange(JexlNode node) {\n+            boolean marked = BoundedRange.instanceOf(node);\n+            \n+            // first unwrap any delayed expression except for a tag\n+            if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0MTg2NA=="}, "originalCommit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0NjUzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (NoSuchElementException e) {}\n          \n          \n            \n                        } catch (NoSuchElementException ignored) {}\n          \n      \n    \n    \n  \n\nThis removes the warning in intellij.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545946530", "createdAt": "2020-12-18T16:30:14Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/JexlASTHelper.java", "diffHunk": "@@ -793,492 +798,365 @@ private static void getERNodes(JexlNode node, List<ASTERNode> erNodes) {\n     }\n     \n     /**\n-     * Get the bounded ranges (index only terms).\n-     *\n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n+     * Ranges: A range prior to being \"tagged\" must be of the form \"(term1 &amp;&amp; term2)\" where term1 and term2 refer to the same field and denote two sides\n+     * of the range ((LE or LT) and (GE or GT)). A tagged range is of the form \"(BoundedRange=true) &amp;&amp; (term1 &amp;&amp; term2))\"\n      */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed, int maxDepth) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, maxDepth);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n+    public static RangeFinder findRange() {\n+        return new RangeFinder();\n     }\n     \n-    /**\n-     * Get the bounded ranges (index only terms).\n-     * \n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, -1);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     *\n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed,\n-                    int maxDepth) {\n-        List<JexlNode> rangeNodes = getRangeOperatorNodes(root, otherNodes, includeDelayed, maxDepth);\n-        return JexlASTHelper.getBoundedRanges(rangeNodes, null, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     * \n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed) {\n-        return getBoundedRangesIndexAgnostic(root, otherNodes, includeDelayed, -1);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> nonIndexedRangeNodes,\n-                    List<JexlNode> otherNodes) {\n-        \n-        // if the non-indexed range nodes were split out, then lets group them back into their AND expressions and put them in the\n-        // other node list (see getBoundedRanges vs. getBoundedRangesIndexAgnostic)\n-        if (nonIndexedRangeNodes != null && otherNodes != null) {\n-            Map<LiteralRange<?>,List<JexlNode>> ranges = getBoundedRanges(nonIndexedRangeNodes, otherNodes);\n-            for (List<JexlNode> range : ranges.values()) {\n-                // create a ref -> ref_exp -> and -> <range nodes>\n-                ASTAndNode andNode = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-                andNode = JexlNodes.children(andNode, range.get(0), range.get(1));\n-                ASTReferenceExpression refExpNode = JexlNodes.wrap(andNode);\n-                ASTReference refNode = JexlNodes.makeRef(refExpNode);\n-                otherNodes.add(refNode);\n+    public static class RangeFinder {\n+        boolean includeDelayed = true;\n+        MetadataHelper helper = null;\n+        Set<String> dataTypeFilter = null;\n+        boolean recursive = false;\n+        boolean withMarker = true;\n+        \n+        public RangeFinder notDelayed() {\n+            includeDelayed = false;\n+            return this;\n+        }\n+        \n+        public RangeFinder indexedOnly(Set<String> dataTypeFilter, MetadataHelper helper) {\n+            this.dataTypeFilter = dataTypeFilter;\n+            this.helper = helper;\n+            return this;\n+        }\n+        \n+        public RangeFinder recursively() {\n+            this.recursive = true;\n+            return this;\n+        }\n+        \n+        public RangeFinder notMarked() {\n+            this.withMarker = false;\n+            return this;\n+        }\n+        \n+        public boolean isRange(JexlNode node) {\n+            return getRange(node) != null;\n+        }\n+        \n+        public LiteralRange getRange(JexlNode node) {\n+            LiteralRange range = _getRange(node);\n+            if (range == null && recursive) {\n+                for (int i = 0; range == null && i < node.jjtGetNumChildren(); i++) {\n+                    range = getRange(node.jjtGetChild(i));\n+                }\n             }\n+            return range;\n         }\n-        return getBoundedRanges(rangeNodes, otherNodes);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> otherNodes) {\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = new HashMap<>();\n         \n-        while (!rangeNodes.isEmpty()) {\n-            JexlNode firstNode = rangeNodes.get(0);\n-            String fieldName = JexlASTHelper.getIdentifier(firstNode);\n-            Object literal = JexlASTHelper.getLiteralValue(firstNode);\n+        private LiteralRange _getRange(JexlNode node) {\n+            boolean marked = BoundedRange.instanceOf(node);\n+            \n+            // first unwrap any delayed expression except for a tag\n+            if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {\n+                node = QueryPropertyMarker.getQueryPropertySource(node, null);\n+                marked = BoundedRange.instanceOf(node);\n+            }\n+            \n+            // It must be marked\n+            if (withMarker && !marked) {\n+                return null;\n+            }\n+            \n+            // remove the marker\n+            if (marked) {\n+                node = BoundedRange.getBoundedRangeSource(node);\n+            }\n+            \n+            // remove reference and expression nodes\n+            node = dereference(node);\n+            \n+            // must be an and node at this point\n+            if (!(node instanceof ASTAndNode)) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain an AND node with two bounds\");\n+                return null;\n+            }\n+            \n+            // and has exactly two children\n+            if (node.jjtGetNumChildren() != 2) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds\");\n+                return null;\n+            }\n+            \n+            JexlNode child1 = dereference(node.jjtGetChild(0));\n+            JexlNode child2 = dereference(node.jjtGetChild(1));\n+            \n+            // and the fieldnames match\n+            String fieldName1 = null;\n+            String fieldName2 = null;\n+            try {\n+                fieldName1 = JexlASTHelper.getIdentifier(child1);\n+                fieldName2 = JexlASTHelper.getIdentifier(child2);\n+            } catch (NoSuchElementException e) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk0Njg5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (NoSuchElementException e) {}\n          \n          \n            \n                        } catch (NoSuchElementException ignored) {}", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r545946890", "createdAt": "2020-12-18T16:30:49Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/JexlASTHelper.java", "diffHunk": "@@ -793,492 +798,365 @@ private static void getERNodes(JexlNode node, List<ASTERNode> erNodes) {\n     }\n     \n     /**\n-     * Get the bounded ranges (index only terms).\n-     *\n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n+     * Ranges: A range prior to being \"tagged\" must be of the form \"(term1 &amp;&amp; term2)\" where term1 and term2 refer to the same field and denote two sides\n+     * of the range ((LE or LT) and (GE or GT)). A tagged range is of the form \"(BoundedRange=true) &amp;&amp; (term1 &amp;&amp; term2))\"\n      */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed, int maxDepth) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, maxDepth);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n+    public static RangeFinder findRange() {\n+        return new RangeFinder();\n     }\n     \n-    /**\n-     * Get the bounded ranges (index only terms).\n-     * \n-     * @param root\n-     *            The root and node\n-     * @param helper\n-     *            The metadata helper\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(JexlNode root, Set<String> datatypeFilterSet, MetadataHelper helper,\n-                    List<JexlNode> otherNodes, boolean includeDelayed) {\n-        List<JexlNode> nonIndexedRangeNodes = new ArrayList<>();\n-        List<JexlNode> rangeNodes = getIndexRangeOperatorNodes(root, datatypeFilterSet, helper, nonIndexedRangeNodes, otherNodes, includeDelayed, -1);\n-        return getBoundedRanges(rangeNodes, nonIndexedRangeNodes, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     *\n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @param maxDepth\n-     *            The maximum depth to traverse the tree. -1 represents unlimited depth.\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed,\n-                    int maxDepth) {\n-        List<JexlNode> rangeNodes = getRangeOperatorNodes(root, otherNodes, includeDelayed, maxDepth);\n-        return JexlASTHelper.getBoundedRanges(rangeNodes, null, otherNodes);\n-    }\n-    \n-    /**\n-     * Get the bounded ranges.\n-     * \n-     * @param root\n-     *            The root node\n-     * @param otherNodes\n-     *            If not null, then this is filled with all nodes not used to make the ranges (minimal node list, minimal tree depth)\n-     * @return The ranges, all bounded.\n-     */\n-    @SuppressWarnings(\"rawtypes\")\n-    public static Map<LiteralRange<?>,List<JexlNode>> getBoundedRangesIndexAgnostic(JexlNode root, List<JexlNode> otherNodes, boolean includeDelayed) {\n-        return getBoundedRangesIndexAgnostic(root, otherNodes, includeDelayed, -1);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> nonIndexedRangeNodes,\n-                    List<JexlNode> otherNodes) {\n-        \n-        // if the non-indexed range nodes were split out, then lets group them back into their AND expressions and put them in the\n-        // other node list (see getBoundedRanges vs. getBoundedRangesIndexAgnostic)\n-        if (nonIndexedRangeNodes != null && otherNodes != null) {\n-            Map<LiteralRange<?>,List<JexlNode>> ranges = getBoundedRanges(nonIndexedRangeNodes, otherNodes);\n-            for (List<JexlNode> range : ranges.values()) {\n-                // create a ref -> ref_exp -> and -> <range nodes>\n-                ASTAndNode andNode = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-                andNode = JexlNodes.children(andNode, range.get(0), range.get(1));\n-                ASTReferenceExpression refExpNode = JexlNodes.wrap(andNode);\n-                ASTReference refNode = JexlNodes.makeRef(refExpNode);\n-                otherNodes.add(refNode);\n+    public static class RangeFinder {\n+        boolean includeDelayed = true;\n+        MetadataHelper helper = null;\n+        Set<String> dataTypeFilter = null;\n+        boolean recursive = false;\n+        boolean withMarker = true;\n+        \n+        public RangeFinder notDelayed() {\n+            includeDelayed = false;\n+            return this;\n+        }\n+        \n+        public RangeFinder indexedOnly(Set<String> dataTypeFilter, MetadataHelper helper) {\n+            this.dataTypeFilter = dataTypeFilter;\n+            this.helper = helper;\n+            return this;\n+        }\n+        \n+        public RangeFinder recursively() {\n+            this.recursive = true;\n+            return this;\n+        }\n+        \n+        public RangeFinder notMarked() {\n+            this.withMarker = false;\n+            return this;\n+        }\n+        \n+        public boolean isRange(JexlNode node) {\n+            return getRange(node) != null;\n+        }\n+        \n+        public LiteralRange getRange(JexlNode node) {\n+            LiteralRange range = _getRange(node);\n+            if (range == null && recursive) {\n+                for (int i = 0; range == null && i < node.jjtGetNumChildren(); i++) {\n+                    range = getRange(node.jjtGetChild(i));\n+                }\n             }\n+            return range;\n         }\n-        return getBoundedRanges(rangeNodes, otherNodes);\n-    }\n-    \n-    protected static Map<LiteralRange<?>,List<JexlNode>> getBoundedRanges(List<JexlNode> rangeNodes, List<JexlNode> otherNodes) {\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = new HashMap<>();\n         \n-        while (!rangeNodes.isEmpty()) {\n-            JexlNode firstNode = rangeNodes.get(0);\n-            String fieldName = JexlASTHelper.getIdentifier(firstNode);\n-            Object literal = JexlASTHelper.getLiteralValue(firstNode);\n+        private LiteralRange _getRange(JexlNode node) {\n+            boolean marked = BoundedRange.instanceOf(node);\n+            \n+            // first unwrap any delayed expression except for a tag\n+            if (includeDelayed && QueryPropertyMarker.instanceOf(node, null) && !marked) {\n+                node = QueryPropertyMarker.getQueryPropertySource(node, null);\n+                marked = BoundedRange.instanceOf(node);\n+            }\n+            \n+            // It must be marked\n+            if (withMarker && !marked) {\n+                return null;\n+            }\n+            \n+            // remove the marker\n+            if (marked) {\n+                node = BoundedRange.getBoundedRangeSource(node);\n+            }\n+            \n+            // remove reference and expression nodes\n+            node = dereference(node);\n+            \n+            // must be an and node at this point\n+            if (!(node instanceof ASTAndNode)) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain an AND node with two bounds\");\n+                return null;\n+            }\n+            \n+            // and has exactly two children\n+            if (node.jjtGetNumChildren() != 2) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds\");\n+                return null;\n+            }\n+            \n+            JexlNode child1 = dereference(node.jjtGetChild(0));\n+            JexlNode child2 = dereference(node.jjtGetChild(1));\n+            \n+            // and the fieldnames match\n+            String fieldName1 = null;\n+            String fieldName2 = null;\n+            try {\n+                fieldName1 = JexlASTHelper.getIdentifier(child1);\n+                fieldName2 = JexlASTHelper.getIdentifier(child2);\n+            } catch (NoSuchElementException e) {}\n+            if (fieldName1 == null || fieldName2 == null || !fieldName1.equals(fieldName2)) {\n+                if (marked)\n+                    throw new DatawaveFatalQueryException(\"A bounded range must contain two bounds against the same field\");\n+                return null;\n+            }\n+            \n+            // and is indexed (if we care) {\n+            try {\n+                if (helper != null && !helper.isIndexed(fieldName1, dataTypeFilter)) {\n+                    return null;\n+                }\n+            } catch (TableNotFoundException tnfe) {\n+                NotFoundQueryException qe = new NotFoundQueryException(DatawaveErrorCode.TABLE_NOT_FOUND, tnfe);\n+                throw new DatawaveFatalQueryException(qe);\n+            }\n+            \n+            Object literal1 = null;\n+            Object literal2 = null;\n+            try {\n+                literal1 = JexlASTHelper.getLiteralValue(child1);\n+                literal2 = JexlASTHelper.getLiteralValue(child2);\n+            } catch (NoSuchElementException e) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwMjgyNw==", "bodyText": "Previously, QueryPropertyMarkerVisitor.instanceOf(node, null) implied that we were searching for any delayed nodes.  Now that we have BoundedRange as an additional marker, it implies something different as that isn't delayed.  Are we sure that there aren't any other places in the code where we don't need to do a similar update to what you've done here to ensure that BoundedRange isn't treated as a delayed node?  Should we create some kind of isInstanceOfDelayed method to make this clearer?", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r546002827", "createdAt": "2020-12-18T18:11:18Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/PushdownMissingIndexRangeNodesVisitor.java", "diffHunk": "@@ -72,78 +74,43 @@ public PushdownMissingIndexRangeNodesVisitor(ShardQueryConfiguration config, Met\n     \n     @Override\n     public Object visit(ASTAndNode node, Object data) {\n-        List<JexlNode> leaves = new ArrayList<>();\n-        Map<LiteralRange<?>,List<JexlNode>> ranges = JexlASTHelper.getBoundedRanges(node, this.dataTypeFilter, this.helper, leaves, false);\n+        LiteralRange range = JexlASTHelper.findRange().indexedOnly(this.dataTypeFilter, this.helper).notDelayed().getRange(node);\n         \n-        JexlNode andNode = JexlNodes.newInstanceOfType(node);\n-        andNode.image = node.image;\n-        andNode.jjtSetParent(node.jjtGetParent());\n-        \n-        // We have a bounded range completely inside of an AND/OR\n-        if (!ranges.isEmpty()) {\n-            andNode = delayIndexBoundedRange(ranges, leaves, node, andNode, data);\n+        if (range != null) {\n+            return delayBoundedIndexHole(range, node, data);\n         } else {\n+            JexlNode andNode = JexlNodes.newInstanceOfType(node);\n+            andNode.image = node.image;\n+            andNode.jjtSetParent(node.jjtGetParent());\n+            \n             // We have no bounded range to replace, just proceed as normal\n             JexlNodes.ensureCapacity(andNode, node.jjtGetNumChildren());\n             for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n                 JexlNode newChild = (JexlNode) node.jjtGetChild(i).jjtAccept(this, data);\n                 andNode.jjtAddChild(newChild, i);\n                 newChild.jjtSetParent(andNode);\n             }\n+            return andNode;\n         }\n-        \n-        return andNode;\n     }\n     \n     /**\n      * Delay the ranges that overlap holes. The range map is expected to only be indexed ranges.\n      */\n-    protected JexlNode delayIndexBoundedRange(Map<LiteralRange<?>,List<JexlNode>> ranges, List<JexlNode> leaves, ASTAndNode currentNode, JexlNode newNode,\n-                    Object data) {\n-        // Add all children in this AND/OR which are not a part of the range\n-        JexlNodes.ensureCapacity(newNode, leaves.size() + ranges.size());\n-        int index = 0;\n-        for (; index < leaves.size(); index++) {\n-            log.debug(leaves.get(index).image);\n-            // Add each child which is not a part of the bounded range, visiting them first\n-            JexlNode visitedChild = (JexlNode) leaves.get(index).jjtAccept(this, null);\n-            newNode.jjtAddChild(visitedChild, index);\n-            visitedChild.jjtSetParent(newNode);\n-        }\n-        \n-        for (Map.Entry<LiteralRange<?>,List<JexlNode>> range : ranges.entrySet()) {\n-            // If we have any terms that we expanded, wrap them in parens and add them to the parent\n-            ASTAndNode rangeNodes = new ASTAndNode(ParserTreeConstants.JJTANDNODE);\n-            \n-            JexlNodes.ensureCapacity(rangeNodes, range.getValue().size());\n-            for (int i = 0; i < range.getValue().size(); i++) {\n-                rangeNodes.jjtAddChild(range.getValue().get(i), i);\n-            }\n-            \n-            JexlNode child = rangeNodes;\n-            if (missingIndexRange(range.getKey())) {\n-                child = IndexHoleMarkerJexlNode.create(rangeNodes);\n-            } else {\n-                child = JexlNodes.wrap(rangeNodes);\n-            }\n-            \n-            newNode.jjtAddChild(child, index++);\n-            child.jjtSetParent(newNode);\n-        }\n+    protected JexlNode delayBoundedIndexHole(LiteralRange range, ASTAndNode currentNode, Object data) {\n         \n-        // If we had no other nodes than this bounded range, we can strip out the original parent\n-        if (newNode.jjtGetNumChildren() == 1) {\n-            newNode.jjtGetChild(0).jjtSetParent(newNode.jjtGetParent());\n-            return newNode.jjtGetChild(0);\n+        if (missingIndexRange(range)) {\n+            return IndexHoleMarkerJexlNode.create(currentNode);\n+        } else {\n+            return currentNode;\n         }\n         \n-        return newNode;\n     }\n     \n     @Override\n     public Object visit(ASTReferenceExpression node, Object data) {\n         // if not already delayed somehow\n-        if (!QueryPropertyMarker.instanceOf(node, null)) {\n+        if (!QueryPropertyMarkerVisitor.instanceOfAnyExcept(node, Collections.singletonList(BoundedRange.class))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNTI3Mw==", "bodyText": "If I understand correctly, this case indicates that we have a bounded range, but it's not marked, and not delayed, whereas the previous case will find a bounded range that's already been marked.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r546005273", "createdAt": "2020-12-18T18:16:05Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/UnmarkedBoundedRangeDetectionVisitor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datawave.query.jexl.visitors;\n+\n+import datawave.query.jexl.JexlASTHelper;\n+import datawave.query.jexl.nodes.BoundedRange;\n+import org.apache.commons.jexl2.parser.ASTAndNode;\n+import org.apache.commons.jexl2.parser.ASTReference;\n+import org.apache.commons.jexl2.parser.JexlNode;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class UnmarkedBoundedRangeDetectionVisitor extends BaseVisitor {\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public static boolean findUnmarkedBoundedRanges(JexlNode script) {\n+        UnmarkedBoundedRangeDetectionVisitor visitor = new UnmarkedBoundedRangeDetectionVisitor();\n+        \n+        AtomicBoolean unmarked = new AtomicBoolean(false);\n+        script.jjtAccept(visitor, unmarked);\n+        \n+        return unmarked.get();\n+    }\n+    \n+    @Override\n+    public Object visit(ASTReference node, Object data) {\n+        if (BoundedRange.instanceOf(node)) {\n+            if (!JexlASTHelper.findRange().isRange(node)) {\n+                if (null != data) {\n+                    AtomicBoolean hasBounded = (AtomicBoolean) data;\n+                    hasBounded.set(true);\n+                }\n+            }\n+            \n+            return false;\n+        } else if (JexlASTHelper.findRange().notDelayed().notMarked().isRange(node)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwODcyMQ=="}, "originalCommit": {"oid": "317e8815eb1948375ec4445c768189d25e789e01"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzk1Mg==", "bodyText": "This is going to blow up our query plans for geo queries.  Gulp...", "url": "https://github.com/NationalSecurityAgency/datawave/pull/926#discussion_r546007952", "createdAt": "2020-12-18T18:19:15Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/test/java/datawave/query/jexl/functions/GeoFunctionsDescriptorTest.java", "diffHunk": "@@ -28,7 +29,7 @@ public void antiMeridianTest2() throws Exception {\n         JexlArgumentDescriptor argDesc = new GeoFunctionsDescriptor().getArgumentDescriptor((ASTFunctionNode) node.jjtGetChild(0).jjtGetChild(0));\n         JexlNode queryNode = argDesc.getIndexQuery(null, null, null, null);\n         Assert.assertEquals(\n-                        \"(((LON_FIELD >= '170.0' && LON_FIELD <= '180') && (LAT_FIELD >= '40.0' && LAT_FIELD <= '50.0')) && ((LON_FIELD >= '-180' && LON_FIELD <= '-170.0') && (LAT_FIELD >= '40.0' && LAT_FIELD <= '50.0')))\",\n+                        \"((((BoundedRange = true) && (LON_FIELD >= '170.0' && LON_FIELD <= '180')) && ((BoundedRange = true) && (LAT_FIELD >= '40.0' && LAT_FIELD <= '50.0'))) && (((BoundedRange = true) && (LON_FIELD >= '-180' && LON_FIELD <= '-170.0')) && ((BoundedRange = true) && (LAT_FIELD >= '40.0' && LAT_FIELD <= '50.0'))))\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1913c941c58dd01d84a7ea384d8356054a855778"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49915c9507a77707b1431b0ec4cecfa388e408d4", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/49915c9507a77707b1431b0ec4cecfa388e408d4", "committedDate": "2020-12-18T19:09:22Z", "message": "formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c617e496f0020bce5099e5b369ec15c9de19036", "author": {"user": {"login": "ivakegg", "name": "Ivan Bella"}}, "url": "https://github.com/NationalSecurityAgency/datawave/commit/6c617e496f0020bce5099e5b369ec15c9de19036", "committedDate": "2020-12-18T19:45:58Z", "message": "re #902: review updates"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1058, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}