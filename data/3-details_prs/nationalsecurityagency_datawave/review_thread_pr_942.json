{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNzIxNTk2", "number": 942, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyNjoyNVrOEuKP9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo0ODowMVrOEvdQig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODM3ODc2OnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyNjoyNVrOHiYr5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyNjoyNVrOHiYr5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxODA4Nw==", "bodyText": "need a continue here", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r505818087", "createdAt": "2020-10-15T20:26:25Z", "author": {"login": "ivakegg"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;\n+            } else if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) mergedContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) childContext);\n+                }\n+                \n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) childContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) mergedContext);\n                 }\n-                return contexts1;\n-            } else if (((List<QueryContext>) contexts2).get(0).getRowContext() != null) {\n-                for (QueryContext qContext : ((List<QueryContext>) contexts2)) {\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts1), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                \n+                mergedContext = childContext;\n+                /*\n+                 * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' &&\n+                 * ((TYPE == 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n+                 * \n+                 * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n+                 * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited\n+                 * support has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not\n+                 * allowed.\n+                 */\n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                // Assumes that if the first query context does not have a row context then they all don't\n+                if (((List<QueryContext>) childContext).get(0).getRowContext() != null) {\n+                    // The size of the list for contexts1 is usually going to be 1\n+                    for (QueryContext qContext : ((List<QueryContext>) childContext)) {\n+                        // Combine the query contexts if anything fails blame the user\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) mergedContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n+                    }\n+                    mergedContext = childContext;\n+                    continue;\n+                } else if (((List<QueryContext>) mergedContext).get(0).getRowContext() != null) {\n+                    for (QueryContext qContext : ((List<QueryContext>) mergedContext)) {\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) childContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n                     }\n                 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64bc7815015e48756bf4ab4b521d5065539615e2"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2ODM4MTcxOnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDoyNzoyM1rOHiYt0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMDo0NToyNlrOHiZnNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxODU3Ng==", "bodyText": "how about set \"processed = true\" as well and then test it at the error message below.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r505818576", "createdAt": "2020-10-15T20:27:23Z", "author": {"login": "ivakegg"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64bc7815015e48756bf4ab4b521d5065539615e2"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgzMzI3MQ==", "bodyText": "Check out my latest commit.  I think that by putting the thrown exception in an else statement we fix the issue and preserve the original functionality.", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r505833271", "createdAt": "2020-10-15T20:45:26Z", "author": {"login": "jwomeara"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxODU3Ng=="}, "originalCommit": {"oid": "64bc7815015e48756bf4ab4b521d5065539615e2"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTk3ODk4OnYy", "diffSide": "RIGHT", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxODo0ODowMVrOHkc9ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxOToyNTozOVrOHkeUnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NTI1OA==", "bodyText": "Instead of repeating the message Error: problem with query syntax everywhere, could we give any additional information that may allow the receiver of this error to troubleshoot the problem", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r507985258", "createdAt": "2020-10-19T18:48:01Z", "author": {"login": "drewfarris"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;\n+            } else if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) mergedContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) childContext);\n+                }\n+                \n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) childContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) mergedContext);\n                 }\n-                return contexts1;\n-            } else if (((List<QueryContext>) contexts2).get(0).getRowContext() != null) {\n-                for (QueryContext qContext : ((List<QueryContext>) contexts2)) {\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts1), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                \n+                mergedContext = childContext;\n+                /*\n+                 * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' &&\n+                 * ((TYPE == 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n+                 * \n+                 * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n+                 * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited\n+                 * support has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not\n+                 * allowed.\n+                 */\n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                // Assumes that if the first query context does not have a row context then they all don't\n+                if (((List<QueryContext>) childContext).get(0).getRowContext() != null) {\n+                    // The size of the list for contexts1 is usually going to be 1\n+                    for (QueryContext qContext : ((List<QueryContext>) childContext)) {\n+                        // Combine the query contexts if anything fails blame the user\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) mergedContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n+                    }\n+                    mergedContext = childContext;\n+                } else if (((List<QueryContext>) mergedContext).get(0).getRowContext() != null) {\n+                    for (QueryContext qContext : ((List<QueryContext>) mergedContext)) {\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) childContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n                     }\n+                } else {\n+                    log.error(\"Problem parsing query\");\n+                    throw new IllegalArgumentException(\"Error: problem with query syntax\");\n                 }\n-                return contexts2;\n+            } else {\n+                \n+                log.error(\"And node had unexpected return type\");\n+                throw new IllegalArgumentException(\"Error: problem with query syntax\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4582481816bab297685d0726e52220fceb6d3b9d"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODAwNzU4MQ==", "bodyText": "This is what was there before.....", "url": "https://github.com/NationalSecurityAgency/datawave/pull/942#discussion_r508007581", "createdAt": "2020-10-19T19:25:39Z", "author": {"login": "ivakegg"}, "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/EdgeTableRangeBuildingVisitor.java", "diffHunk": "@@ -168,75 +171,86 @@ public Object visit(ASTAndNode node, Object data) {\n             log.error(\"Query has too many terms\");\n             throw new IllegalArgumentException(\"Too many search terms \" + termCount);\n         }\n-        int numChildren = node.jjtGetNumChildren();\n         \n-        if (numChildren != 2) {\n-            log.error(\"AND node had unexpected number of children\" + numChildren);\n-            throw new RuntimeException(\"Problem parsing query\");\n+        // run the visitor against all of the children\n+        List<List<? extends EdgeContext>> childContexts = new ArrayList<>(node.jjtGetNumChildren());\n+        for (JexlNode child : children(node)) {\n+            childContexts.add((List<? extends EdgeContext>) child.jjtAccept(this, null));\n         }\n         \n-        List<? extends EdgeContext> contexts1 = (List<? extends EdgeContext>) node.jjtGetChild(0).jjtAccept(this, null);\n-        List<? extends EdgeContext> contexts2 = (List<? extends EdgeContext>) node.jjtGetChild(1).jjtAccept(this, null);\n+        if (childContexts.isEmpty()) {\n+            log.error(\"Unable to get edge context from AND node\");\n+            throw new IllegalArgumentException(\"Unable to get edge context from AND node\");\n+        }\n         \n-        if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            QueryContext qContext = new QueryContext();\n-            \n-            qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            \n-            ArrayList<QueryContext> aList = new ArrayList<>();\n-            aList.add(qContext);\n-            return aList;\n-        } else if ((contexts1.get(0) instanceof IdentityContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts2) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts1);\n-            }\n-            \n-            return contexts2;\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof IdentityContext)) {\n-            \n-            for (QueryContext qContext : (List<QueryContext>) contexts1) {\n-                qContext.packageIdentities((List<IdentityContext>) contexts2);\n-            }\n+        List<? extends EdgeContext> mergedContext = childContexts.remove(childContexts.size() - 1);\n+        \n+        // now merge the child contexts\n+        while (!childContexts.isEmpty()) {\n+            List<? extends EdgeContext> childContext = childContexts.remove(childContexts.size() - 1);\n             \n-            return contexts1;\n-            /*\n-             * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' && ((TYPE ==\n-             * 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n-             * \n-             * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n-             * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited support\n-             * has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not allowed.\n-             */\n-        } else if ((contexts1.get(0) instanceof QueryContext) && (contexts2.get(0) instanceof QueryContext)) {\n-            // Assumes that if the first query context does not have a row context then they all don't\n-            if (((List<QueryContext>) contexts1).get(0).getRowContext() != null) {\n-                // The size of the list for contexts1 is usually going to be 1\n-                for (QueryContext qContext : ((List<QueryContext>) contexts1)) {\n-                    // Combine the query contexts if anything fails blame the user\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts2), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n-                    }\n+            if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                QueryContext qContext = new QueryContext();\n+                \n+                qContext.packageIdentities((List<IdentityContext>) childContext);\n+                qContext.packageIdentities((List<IdentityContext>) mergedContext);\n+                \n+                ArrayList<QueryContext> aList = new ArrayList<>();\n+                aList.add(qContext);\n+                mergedContext = aList;\n+            } else if ((childContext.get(0) instanceof IdentityContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) mergedContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) childContext);\n+                }\n+                \n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof IdentityContext)) {\n+                \n+                for (QueryContext qContext : (List<QueryContext>) childContext) {\n+                    qContext.packageIdentities((List<IdentityContext>) mergedContext);\n                 }\n-                return contexts1;\n-            } else if (((List<QueryContext>) contexts2).get(0).getRowContext() != null) {\n-                for (QueryContext qContext : ((List<QueryContext>) contexts2)) {\n-                    if (!(qContext.combineQueryContexts(((List<QueryContext>) contexts1), false))) {\n-                        log.error(\"And node had unexpected return type\");\n-                        throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                \n+                mergedContext = childContext;\n+                /*\n+                 * On rare occasion a group of Query contexts without a source can get grouped together, this happens with queries like: SOURCE == 's1' &&\n+                 * ((TYPE == 't1' && RELATIONSHIP == 'r1') || (TYPE == 't2' && RELATIONSHIP == 'r2'))\n+                 * \n+                 * This probably was not supposed to be allowed, you should only be ANDing groups of sources with groups of other identifiers rather here it is\n+                 * ANDing source(s) with groups of expressions. Honestly it would be safer to split that type of query up into two separate ones but limited\n+                 * support has been included. However it can be dangerous if the user tries to use SINK in one of the grouped expressions so that is not\n+                 * allowed.\n+                 */\n+            } else if ((childContext.get(0) instanceof QueryContext) && (mergedContext.get(0) instanceof QueryContext)) {\n+                // Assumes that if the first query context does not have a row context then they all don't\n+                if (((List<QueryContext>) childContext).get(0).getRowContext() != null) {\n+                    // The size of the list for contexts1 is usually going to be 1\n+                    for (QueryContext qContext : ((List<QueryContext>) childContext)) {\n+                        // Combine the query contexts if anything fails blame the user\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) mergedContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n+                    }\n+                    mergedContext = childContext;\n+                } else if (((List<QueryContext>) mergedContext).get(0).getRowContext() != null) {\n+                    for (QueryContext qContext : ((List<QueryContext>) mergedContext)) {\n+                        if (!(qContext.combineQueryContexts(((List<QueryContext>) childContext), false))) {\n+                            log.error(\"And node had unexpected return type\");\n+                            throw new IllegalArgumentException(\"Error: problem with query syntax\");\n+                        }\n                     }\n+                } else {\n+                    log.error(\"Problem parsing query\");\n+                    throw new IllegalArgumentException(\"Error: problem with query syntax\");\n                 }\n-                return contexts2;\n+            } else {\n+                \n+                log.error(\"And node had unexpected return type\");\n+                throw new IllegalArgumentException(\"Error: problem with query syntax\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NTI1OA=="}, "originalCommit": {"oid": "4582481816bab297685d0726e52220fceb6d3b9d"}, "originalPosition": 149}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4436, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}