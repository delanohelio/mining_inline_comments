{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2ODA4Mzg3", "number": 2036, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzoyNTozN1rOEjXGpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzo1NToyNVrOEjXeWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTE0MTUxOnYy", "diffSide": "RIGHT", "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/BaseWaiterClassSpec.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzoyNTozN1rOHRq_mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMjo0NzowM1rOHSY5oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5MjI0OQ==", "bodyText": "Can this be move out of the switch? Looks like we always add except for status which doesn't use the result that's being built", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488292249", "createdAt": "2020-09-14T23:25:37Z", "author": {"login": "dagnir"}, "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/BaseWaiterClassSpec.java", "diffHunk": "@@ -294,4 +328,143 @@ private OperationModel operationModel(WaiterDefinition waiterDefinition) {\n     private String getWaiterMethodName(String waiterMethodName) {\n         return \"waitUntil\" + waiterMethodName;\n     }\n+\n+    private TypeName waiterAcceptorTypeName(WaiterDefinition waiterDefinition) {\n+        WildcardTypeName wildcardTypeName = WildcardTypeName.supertypeOf(fullyQualifiedResponseType(waiterDefinition));\n+\n+        return ParameterizedTypeName.get(ClassName.get(List.class),\n+                                         ParameterizedTypeName.get(ClassName.get(WaiterAcceptor.class), wildcardTypeName));\n+    }\n+\n+    private TypeName fullyQualifiedResponseType(WaiterDefinition waiterDefinition) {\n+        String modelPackage = model.getMetadata().getFullModelPackageName();\n+        String operationResponseType = model.getOperation(waiterDefinition.getOperation()).getReturnType().getReturnType();\n+        return ClassName.get(modelPackage, operationResponseType);\n+    }\n+\n+    private CodeBlock acceptor(Acceptor acceptor) {\n+        CodeBlock.Builder result = CodeBlock.builder();\n+\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                result.add(\"$T.success\", WaiterAcceptor.class);\n+                break;\n+            case \"failure\":\n+                result.add(\"$T.error\", WaiterAcceptor.class);\n+                break;\n+            case \"retry\":\n+                result.add(\"$T.retry\", WaiterAcceptor.class);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+\n+        switch (acceptor.getMatcher()) {\n+            case \"path\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAll\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAllAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAny\":\n+                result.add(\"OnResponseAcceptor(\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMzczMw==", "bodyText": "+1", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488833733", "createdAt": "2020-09-15T17:21:14Z", "author": {"login": "millems"}, "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/BaseWaiterClassSpec.java", "diffHunk": "@@ -294,4 +328,143 @@ private OperationModel operationModel(WaiterDefinition waiterDefinition) {\n     private String getWaiterMethodName(String waiterMethodName) {\n         return \"waitUntil\" + waiterMethodName;\n     }\n+\n+    private TypeName waiterAcceptorTypeName(WaiterDefinition waiterDefinition) {\n+        WildcardTypeName wildcardTypeName = WildcardTypeName.supertypeOf(fullyQualifiedResponseType(waiterDefinition));\n+\n+        return ParameterizedTypeName.get(ClassName.get(List.class),\n+                                         ParameterizedTypeName.get(ClassName.get(WaiterAcceptor.class), wildcardTypeName));\n+    }\n+\n+    private TypeName fullyQualifiedResponseType(WaiterDefinition waiterDefinition) {\n+        String modelPackage = model.getMetadata().getFullModelPackageName();\n+        String operationResponseType = model.getOperation(waiterDefinition.getOperation()).getReturnType().getReturnType();\n+        return ClassName.get(modelPackage, operationResponseType);\n+    }\n+\n+    private CodeBlock acceptor(Acceptor acceptor) {\n+        CodeBlock.Builder result = CodeBlock.builder();\n+\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                result.add(\"$T.success\", WaiterAcceptor.class);\n+                break;\n+            case \"failure\":\n+                result.add(\"$T.error\", WaiterAcceptor.class);\n+                break;\n+            case \"retry\":\n+                result.add(\"$T.retry\", WaiterAcceptor.class);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+\n+        switch (acceptor.getMatcher()) {\n+            case \"path\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAll\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAllAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAny\":\n+                result.add(\"OnResponseAcceptor(\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5MjI0OQ=="}, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA0NDM4NQ==", "bodyText": "Actually, the error path is different, so I can't do this.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r489044385", "createdAt": "2020-09-15T22:47:03Z", "author": {"login": "millems"}, "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/BaseWaiterClassSpec.java", "diffHunk": "@@ -294,4 +328,143 @@ private OperationModel operationModel(WaiterDefinition waiterDefinition) {\n     private String getWaiterMethodName(String waiterMethodName) {\n         return \"waitUntil\" + waiterMethodName;\n     }\n+\n+    private TypeName waiterAcceptorTypeName(WaiterDefinition waiterDefinition) {\n+        WildcardTypeName wildcardTypeName = WildcardTypeName.supertypeOf(fullyQualifiedResponseType(waiterDefinition));\n+\n+        return ParameterizedTypeName.get(ClassName.get(List.class),\n+                                         ParameterizedTypeName.get(ClassName.get(WaiterAcceptor.class), wildcardTypeName));\n+    }\n+\n+    private TypeName fullyQualifiedResponseType(WaiterDefinition waiterDefinition) {\n+        String modelPackage = model.getMetadata().getFullModelPackageName();\n+        String operationResponseType = model.getOperation(waiterDefinition.getOperation()).getReturnType().getReturnType();\n+        return ClassName.get(modelPackage, operationResponseType);\n+    }\n+\n+    private CodeBlock acceptor(Acceptor acceptor) {\n+        CodeBlock.Builder result = CodeBlock.builder();\n+\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                result.add(\"$T.success\", WaiterAcceptor.class);\n+                break;\n+            case \"failure\":\n+                result.add(\"$T.error\", WaiterAcceptor.class);\n+                break;\n+            case \"retry\":\n+                result.add(\"$T.retry\", WaiterAcceptor.class);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+\n+        switch (acceptor.getMatcher()) {\n+            case \"path\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAll\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAllAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAny\":\n+                result.add(\"OnResponseAcceptor(\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5MjI0OQ=="}, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTE0NDk1OnYy", "diffSide": "RIGHT", "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/BaseWaiterClassSpec.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzoyNzoxMVrOHRrBhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzoyMzoxNFrOHSMLQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5Mjc0Mw==", "bodyText": "minor: use addStatement instead of adding ; manually", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488292743", "createdAt": "2020-09-14T23:27:11Z", "author": {"login": "dagnir"}, "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/BaseWaiterClassSpec.java", "diffHunk": "@@ -294,4 +328,143 @@ private OperationModel operationModel(WaiterDefinition waiterDefinition) {\n     private String getWaiterMethodName(String waiterMethodName) {\n         return \"waitUntil\" + waiterMethodName;\n     }\n+\n+    private TypeName waiterAcceptorTypeName(WaiterDefinition waiterDefinition) {\n+        WildcardTypeName wildcardTypeName = WildcardTypeName.supertypeOf(fullyQualifiedResponseType(waiterDefinition));\n+\n+        return ParameterizedTypeName.get(ClassName.get(List.class),\n+                                         ParameterizedTypeName.get(ClassName.get(WaiterAcceptor.class), wildcardTypeName));\n+    }\n+\n+    private TypeName fullyQualifiedResponseType(WaiterDefinition waiterDefinition) {\n+        String modelPackage = model.getMetadata().getFullModelPackageName();\n+        String operationResponseType = model.getOperation(waiterDefinition.getOperation()).getReturnType().getReturnType();\n+        return ClassName.get(modelPackage, operationResponseType);\n+    }\n+\n+    private CodeBlock acceptor(Acceptor acceptor) {\n+        CodeBlock.Builder result = CodeBlock.builder();\n+\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                result.add(\"$T.success\", WaiterAcceptor.class);\n+                break;\n+            case \"failure\":\n+                result.add(\"$T.error\", WaiterAcceptor.class);\n+                break;\n+            case \"retry\":\n+                result.add(\"$T.retry\", WaiterAcceptor.class);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+\n+        switch (acceptor.getMatcher()) {\n+            case \"path\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAll\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAllAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAny\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAnyAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"status\":\n+                // Note: Ignores the result we've built so far because this uses a special acceptor implementation.\n+                int expected = Integer.parseInt(acceptor.getExpected().asText());\n+                return CodeBlock.of(\"new $T($L, $T.$L)\", WaitersRuntime.ResponseStatusAcceptor.class, expected,\n+                                    WaiterState.class, waiterState(acceptor));\n+            case \"error\":\n+                result.add(\"OnExceptionAcceptor(\")\n+                      .add(errorAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor matcher: \" + acceptor.getMatcher());\n+        }\n+\n+        return result.build();\n+    }\n+\n+    private String waiterState(Acceptor acceptor) {\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                return WaiterState.SUCCESS.name();\n+            case \"failure\":\n+                return WaiterState.FAILURE.name();\n+            case \"retry\":\n+                return WaiterState.RETRY.name();\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+    }\n+\n+    private CodeBlock pathAcceptorBody(Acceptor acceptor) {\n+        String expected = acceptor.getExpected().asText();\n+        String expectedType = acceptor.getExpected() instanceof JrsString ? \"$S\" : \"$L\";\n+        return CodeBlock.builder()\n+                        .add(\"response -> {\")\n+                        .add(\"$1T input = new $1T(response);\", WaitersRuntime.Value.class)\n+                        .add(\"return $T.equals(\", Objects.class)\n+                        .add(JmesPathInterpreter.interpret(acceptor.getArgument(), \"input\"))\n+                        .add(\".value(), \" + expectedType + \");\", expected)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNTkwNA==", "bodyText": "We're pretty inconsistent with this in general.\nI think on these 4 lines it would be a bit less readable, since the first line would be addStatement but the later ones wouldn't be (they're partial statements), so the code wouldn't line up nicely.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488835904", "createdAt": "2020-09-15T17:23:14Z", "author": {"login": "millems"}, "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/BaseWaiterClassSpec.java", "diffHunk": "@@ -294,4 +328,143 @@ private OperationModel operationModel(WaiterDefinition waiterDefinition) {\n     private String getWaiterMethodName(String waiterMethodName) {\n         return \"waitUntil\" + waiterMethodName;\n     }\n+\n+    private TypeName waiterAcceptorTypeName(WaiterDefinition waiterDefinition) {\n+        WildcardTypeName wildcardTypeName = WildcardTypeName.supertypeOf(fullyQualifiedResponseType(waiterDefinition));\n+\n+        return ParameterizedTypeName.get(ClassName.get(List.class),\n+                                         ParameterizedTypeName.get(ClassName.get(WaiterAcceptor.class), wildcardTypeName));\n+    }\n+\n+    private TypeName fullyQualifiedResponseType(WaiterDefinition waiterDefinition) {\n+        String modelPackage = model.getMetadata().getFullModelPackageName();\n+        String operationResponseType = model.getOperation(waiterDefinition.getOperation()).getReturnType().getReturnType();\n+        return ClassName.get(modelPackage, operationResponseType);\n+    }\n+\n+    private CodeBlock acceptor(Acceptor acceptor) {\n+        CodeBlock.Builder result = CodeBlock.builder();\n+\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                result.add(\"$T.success\", WaiterAcceptor.class);\n+                break;\n+            case \"failure\":\n+                result.add(\"$T.error\", WaiterAcceptor.class);\n+                break;\n+            case \"retry\":\n+                result.add(\"$T.retry\", WaiterAcceptor.class);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+\n+        switch (acceptor.getMatcher()) {\n+            case \"path\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAll\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAllAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAny\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAnyAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"status\":\n+                // Note: Ignores the result we've built so far because this uses a special acceptor implementation.\n+                int expected = Integer.parseInt(acceptor.getExpected().asText());\n+                return CodeBlock.of(\"new $T($L, $T.$L)\", WaitersRuntime.ResponseStatusAcceptor.class, expected,\n+                                    WaiterState.class, waiterState(acceptor));\n+            case \"error\":\n+                result.add(\"OnExceptionAcceptor(\")\n+                      .add(errorAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor matcher: \" + acceptor.getMatcher());\n+        }\n+\n+        return result.build();\n+    }\n+\n+    private String waiterState(Acceptor acceptor) {\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                return WaiterState.SUCCESS.name();\n+            case \"failure\":\n+                return WaiterState.FAILURE.name();\n+            case \"retry\":\n+                return WaiterState.RETRY.name();\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+    }\n+\n+    private CodeBlock pathAcceptorBody(Acceptor acceptor) {\n+        String expected = acceptor.getExpected().asText();\n+        String expectedType = acceptor.getExpected() instanceof JrsString ? \"$S\" : \"$L\";\n+        return CodeBlock.builder()\n+                        .add(\"response -> {\")\n+                        .add(\"$1T input = new $1T(response);\", WaitersRuntime.Value.class)\n+                        .add(\"return $T.equals(\", Objects.class)\n+                        .add(JmesPathInterpreter.interpret(acceptor.getArgument(), \"input\"))\n+                        .add(\".value(), \" + expectedType + \");\", expected)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5Mjc0Mw=="}, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTE1MTI0OnYy", "diffSide": "RIGHT", "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/BaseWaiterClassSpec.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzozMDowN1rOHRrFLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzoyNToxNlrOHSMTfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5MzY3Ng==", "bodyText": "minor: extract to helper method?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488293676", "createdAt": "2020-09-14T23:30:07Z", "author": {"login": "dagnir"}, "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/BaseWaiterClassSpec.java", "diffHunk": "@@ -294,4 +328,143 @@ private OperationModel operationModel(WaiterDefinition waiterDefinition) {\n     private String getWaiterMethodName(String waiterMethodName) {\n         return \"waitUntil\" + waiterMethodName;\n     }\n+\n+    private TypeName waiterAcceptorTypeName(WaiterDefinition waiterDefinition) {\n+        WildcardTypeName wildcardTypeName = WildcardTypeName.supertypeOf(fullyQualifiedResponseType(waiterDefinition));\n+\n+        return ParameterizedTypeName.get(ClassName.get(List.class),\n+                                         ParameterizedTypeName.get(ClassName.get(WaiterAcceptor.class), wildcardTypeName));\n+    }\n+\n+    private TypeName fullyQualifiedResponseType(WaiterDefinition waiterDefinition) {\n+        String modelPackage = model.getMetadata().getFullModelPackageName();\n+        String operationResponseType = model.getOperation(waiterDefinition.getOperation()).getReturnType().getReturnType();\n+        return ClassName.get(modelPackage, operationResponseType);\n+    }\n+\n+    private CodeBlock acceptor(Acceptor acceptor) {\n+        CodeBlock.Builder result = CodeBlock.builder();\n+\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                result.add(\"$T.success\", WaiterAcceptor.class);\n+                break;\n+            case \"failure\":\n+                result.add(\"$T.error\", WaiterAcceptor.class);\n+                break;\n+            case \"retry\":\n+                result.add(\"$T.retry\", WaiterAcceptor.class);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+\n+        switch (acceptor.getMatcher()) {\n+            case \"path\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAll\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAllAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAny\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAnyAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"status\":\n+                // Note: Ignores the result we've built so far because this uses a special acceptor implementation.\n+                int expected = Integer.parseInt(acceptor.getExpected().asText());\n+                return CodeBlock.of(\"new $T($L, $T.$L)\", WaitersRuntime.ResponseStatusAcceptor.class, expected,\n+                                    WaiterState.class, waiterState(acceptor));\n+            case \"error\":\n+                result.add(\"OnExceptionAcceptor(\")\n+                      .add(errorAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor matcher: \" + acceptor.getMatcher());\n+        }\n+\n+        return result.build();\n+    }\n+\n+    private String waiterState(Acceptor acceptor) {\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                return WaiterState.SUCCESS.name();\n+            case \"failure\":\n+                return WaiterState.FAILURE.name();\n+            case \"retry\":\n+                return WaiterState.RETRY.name();\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+    }\n+\n+    private CodeBlock pathAcceptorBody(Acceptor acceptor) {\n+        String expected = acceptor.getExpected().asText();\n+        String expectedType = acceptor.getExpected() instanceof JrsString ? \"$S\" : \"$L\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzODAxMg==", "bodyText": "I feel like customizing the type used in poet is unusual, so putting it away in a helper method would make the reader always have to go to that method to see what it's doing. It seems easier to understand inlined with the method, even if it's less dry.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488838012", "createdAt": "2020-09-15T17:25:16Z", "author": {"login": "millems"}, "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/BaseWaiterClassSpec.java", "diffHunk": "@@ -294,4 +328,143 @@ private OperationModel operationModel(WaiterDefinition waiterDefinition) {\n     private String getWaiterMethodName(String waiterMethodName) {\n         return \"waitUntil\" + waiterMethodName;\n     }\n+\n+    private TypeName waiterAcceptorTypeName(WaiterDefinition waiterDefinition) {\n+        WildcardTypeName wildcardTypeName = WildcardTypeName.supertypeOf(fullyQualifiedResponseType(waiterDefinition));\n+\n+        return ParameterizedTypeName.get(ClassName.get(List.class),\n+                                         ParameterizedTypeName.get(ClassName.get(WaiterAcceptor.class), wildcardTypeName));\n+    }\n+\n+    private TypeName fullyQualifiedResponseType(WaiterDefinition waiterDefinition) {\n+        String modelPackage = model.getMetadata().getFullModelPackageName();\n+        String operationResponseType = model.getOperation(waiterDefinition.getOperation()).getReturnType().getReturnType();\n+        return ClassName.get(modelPackage, operationResponseType);\n+    }\n+\n+    private CodeBlock acceptor(Acceptor acceptor) {\n+        CodeBlock.Builder result = CodeBlock.builder();\n+\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                result.add(\"$T.success\", WaiterAcceptor.class);\n+                break;\n+            case \"failure\":\n+                result.add(\"$T.error\", WaiterAcceptor.class);\n+                break;\n+            case \"retry\":\n+                result.add(\"$T.retry\", WaiterAcceptor.class);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+\n+        switch (acceptor.getMatcher()) {\n+            case \"path\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAll\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAllAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"pathAny\":\n+                result.add(\"OnResponseAcceptor(\")\n+                      .add(pathAnyAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            case \"status\":\n+                // Note: Ignores the result we've built so far because this uses a special acceptor implementation.\n+                int expected = Integer.parseInt(acceptor.getExpected().asText());\n+                return CodeBlock.of(\"new $T($L, $T.$L)\", WaitersRuntime.ResponseStatusAcceptor.class, expected,\n+                                    WaiterState.class, waiterState(acceptor));\n+            case \"error\":\n+                result.add(\"OnExceptionAcceptor(\")\n+                      .add(errorAcceptorBody(acceptor))\n+                      .add(\")\");\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor matcher: \" + acceptor.getMatcher());\n+        }\n+\n+        return result.build();\n+    }\n+\n+    private String waiterState(Acceptor acceptor) {\n+        switch (acceptor.getState()) {\n+            case \"success\":\n+                return WaiterState.SUCCESS.name();\n+            case \"failure\":\n+                return WaiterState.FAILURE.name();\n+            case \"retry\":\n+                return WaiterState.RETRY.name();\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported acceptor state: \" + acceptor.getState());\n+        }\n+    }\n+\n+    private CodeBlock pathAcceptorBody(Acceptor acceptor) {\n+        String expected = acceptor.getExpected().asText();\n+        String expectedType = acceptor.getExpected() instanceof JrsString ? \"$S\" : \"$L\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5MzY3Ng=="}, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTE5MzcxOnYy", "diffSide": "RIGHT", "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/JmesPathInterpreter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzo1MDo1OFrOHRrdbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzoyNjozOFrOHSMWZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5OTg4NA==", "bodyText": "Can we add more detail in this javadoc? I was confused at first thinking the statements are jut basic Java expressions, but looks like the output is an intermediate representation that is further interpreted by the Waiters Runtime.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488299884", "createdAt": "2020-09-14T23:50:58Z", "author": {"login": "dagnir"}, "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/JmesPathInterpreter.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.codegen.poet.waiters;\n+\n+import com.fasterxml.jackson.jr.stree.JrsBoolean;\n+import com.fasterxml.jackson.jr.stree.JrsValue;\n+import com.squareup.javapoet.CodeBlock;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.List;\n+import software.amazon.awssdk.codegen.jmespath.component.AndExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.BracketSpecifier;\n+import software.amazon.awssdk.codegen.jmespath.component.BracketSpecifierWithContents;\n+import software.amazon.awssdk.codegen.jmespath.component.BracketSpecifierWithQuestionMark;\n+import software.amazon.awssdk.codegen.jmespath.component.BracketSpecifierWithoutContents;\n+import software.amazon.awssdk.codegen.jmespath.component.ComparatorExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.CurrentNode;\n+import software.amazon.awssdk.codegen.jmespath.component.Expression;\n+import software.amazon.awssdk.codegen.jmespath.component.ExpressionType;\n+import software.amazon.awssdk.codegen.jmespath.component.FunctionArg;\n+import software.amazon.awssdk.codegen.jmespath.component.FunctionExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.IndexExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.Literal;\n+import software.amazon.awssdk.codegen.jmespath.component.MultiSelectHash;\n+import software.amazon.awssdk.codegen.jmespath.component.MultiSelectList;\n+import software.amazon.awssdk.codegen.jmespath.component.NotExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.OrExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.ParenExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.PipeExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.SliceExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.SubExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.SubExpressionRight;\n+import software.amazon.awssdk.codegen.jmespath.component.WildcardExpression;\n+import software.amazon.awssdk.codegen.jmespath.parser.JmesPathParser;\n+import software.amazon.awssdk.codegen.jmespath.parser.JmesPathVisitor;\n+import software.amazon.awssdk.core.SdkPojo;\n+import software.amazon.awssdk.core.waiters.WaitersRuntime;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * A code interpreter for JMESPath expressions.\n+ *\n+ * This can convert a JMESPath expression into a statement that executes against an {@link SdkPojo}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzODc1OQ==", "bodyText": "Will do! As some history, I tried to just emit java expressions, but it was way too difficult. The waiters runtime made it much easier.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488838759", "createdAt": "2020-09-15T17:26:38Z", "author": {"login": "millems"}, "path": "codegen/src/main/java/software/amazon/awssdk/codegen/poet/waiters/JmesPathInterpreter.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.codegen.poet.waiters;\n+\n+import com.fasterxml.jackson.jr.stree.JrsBoolean;\n+import com.fasterxml.jackson.jr.stree.JrsValue;\n+import com.squareup.javapoet.CodeBlock;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.List;\n+import software.amazon.awssdk.codegen.jmespath.component.AndExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.BracketSpecifier;\n+import software.amazon.awssdk.codegen.jmespath.component.BracketSpecifierWithContents;\n+import software.amazon.awssdk.codegen.jmespath.component.BracketSpecifierWithQuestionMark;\n+import software.amazon.awssdk.codegen.jmespath.component.BracketSpecifierWithoutContents;\n+import software.amazon.awssdk.codegen.jmespath.component.ComparatorExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.CurrentNode;\n+import software.amazon.awssdk.codegen.jmespath.component.Expression;\n+import software.amazon.awssdk.codegen.jmespath.component.ExpressionType;\n+import software.amazon.awssdk.codegen.jmespath.component.FunctionArg;\n+import software.amazon.awssdk.codegen.jmespath.component.FunctionExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.IndexExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.Literal;\n+import software.amazon.awssdk.codegen.jmespath.component.MultiSelectHash;\n+import software.amazon.awssdk.codegen.jmespath.component.MultiSelectList;\n+import software.amazon.awssdk.codegen.jmespath.component.NotExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.OrExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.ParenExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.PipeExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.SliceExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.SubExpression;\n+import software.amazon.awssdk.codegen.jmespath.component.SubExpressionRight;\n+import software.amazon.awssdk.codegen.jmespath.component.WildcardExpression;\n+import software.amazon.awssdk.codegen.jmespath.parser.JmesPathParser;\n+import software.amazon.awssdk.codegen.jmespath.parser.JmesPathVisitor;\n+import software.amazon.awssdk.core.SdkPojo;\n+import software.amazon.awssdk.core.waiters.WaitersRuntime;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * A code interpreter for JMESPath expressions.\n+ *\n+ * This can convert a JMESPath expression into a statement that executes against an {@link SdkPojo}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5OTg4NA=="}, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTE5NjY5OnYy", "diffSide": "RIGHT", "path": "codegen/src/test/java/software/amazon/awssdk/codegen/poet/waiters/JmesPathInterpreterTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzo1MjozOVrOHRrfTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzoyNjo1N1rOHSMXIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDM2NQ==", "bodyText": "Not a block but these are quite hard to read in line. Would be nice to move them to text files that are easier to read, especially if we end up writing more test cases (like when we support more JMESPath features).", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488300365", "createdAt": "2020-09-14T23:52:39Z", "author": {"login": "dagnir"}, "path": "codegen/src/test/java/software/amazon/awssdk/codegen/poet/waiters/JmesPathInterpreterTest.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.codegen.poet.waiters;\n+\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Test;\n+\n+public class JmesPathInterpreterTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzODk0NQ==", "bodyText": "Whoops, I meant do to that before publishing the review. Good catch.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488838945", "createdAt": "2020-09-15T17:26:57Z", "author": {"login": "millems"}, "path": "codegen/src/test/java/software/amazon/awssdk/codegen/poet/waiters/JmesPathInterpreterTest.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.codegen.poet.waiters;\n+\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.junit.Test;\n+\n+public class JmesPathInterpreterTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDM2NQ=="}, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTIwMjE5OnYy", "diffSide": "RIGHT", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaitersRuntime.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzo1NToyNVrOHRrifA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDoxNjoxNFrOHSS9ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMTE4MA==", "bodyText": "Can we add tests for the runtime?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488301180", "createdAt": "2020-09-14T23:55:25Z", "author": {"login": "dagnir"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaitersRuntime.java", "diffHunk": "@@ -0,0 +1,523 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import software.amazon.awssdk.annotations.SdkProtectedApi;\n+import software.amazon.awssdk.core.SdkPojo;\n+import software.amazon.awssdk.core.SdkResponse;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.utils.ToString;\n+\n+/**\n+ * Contains classes used at runtime by the code generator classes for waiter acceptors generated from JMESPath expressions.\n+ */\n+@SdkProtectedApi\n+public final class WaitersRuntime {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg0MDUyNw==", "bodyText": "That's a good idea, but I'm wondering how that will jive when we move the runtime to being copied into each of the service clients. I was hoping testing it in the context it's used (i.e. testing the generated waiters and making sure they worked, which indirectly tests the runtime) would be sufficient to side-step this problem. Do you have any ideas on how to make that work?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488840527", "createdAt": "2020-09-15T17:29:51Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaitersRuntime.java", "diffHunk": "@@ -0,0 +1,523 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import software.amazon.awssdk.annotations.SdkProtectedApi;\n+import software.amazon.awssdk.core.SdkPojo;\n+import software.amazon.awssdk.core.SdkResponse;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.utils.ToString;\n+\n+/**\n+ * Contains classes used at runtime by the code generator classes for waiter acceptors generated from JMESPath expressions.\n+ */\n+@SdkProtectedApi\n+public final class WaitersRuntime {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMTE4MA=="}, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0NTI5NQ==", "bodyText": "Do you have any ideas on how to make that work?\n\nI think if we just accessed a WaitersRuntime class from within codegen-generated-classes-test that could work.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488945295", "createdAt": "2020-09-15T20:12:52Z", "author": {"login": "dagnir"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaitersRuntime.java", "diffHunk": "@@ -0,0 +1,523 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import software.amazon.awssdk.annotations.SdkProtectedApi;\n+import software.amazon.awssdk.core.SdkPojo;\n+import software.amazon.awssdk.core.SdkResponse;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.utils.ToString;\n+\n+/**\n+ * Contains classes used at runtime by the code generator classes for waiter acceptors generated from JMESPath expressions.\n+ */\n+@SdkProtectedApi\n+public final class WaitersRuntime {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMTE4MA=="}, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0NzA0NQ==", "bodyText": "That makes sense \ud83d\udc4d", "url": "https://github.com/aws/aws-sdk-java-v2/pull/2036#discussion_r488947045", "createdAt": "2020-09-15T20:16:14Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaitersRuntime.java", "diffHunk": "@@ -0,0 +1,523 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import software.amazon.awssdk.annotations.SdkProtectedApi;\n+import software.amazon.awssdk.core.SdkPojo;\n+import software.amazon.awssdk.core.SdkResponse;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.exception.SdkServiceException;\n+import software.amazon.awssdk.utils.ToString;\n+\n+/**\n+ * Contains classes used at runtime by the code generator classes for waiter acceptors generated from JMESPath expressions.\n+ */\n+@SdkProtectedApi\n+public final class WaitersRuntime {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMTE4MA=="}, "originalCommit": {"oid": "0041c0b054c35ed23eb8bbf16e58097325e809f9"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4035, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}