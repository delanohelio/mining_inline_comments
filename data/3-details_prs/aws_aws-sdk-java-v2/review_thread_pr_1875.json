{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MTMzMTk4", "number": 1875, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjowMzo1MVrOEDHEEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjoxMDo1NlrOEDHIpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjk2OTEyOnYy", "diffSide": "RIGHT", "path": "docs/design/core/waiters/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjowMzo1MVrOGf-oQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjowNjoxNVrOGf-rGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4NTE1Mw==", "bodyText": "Until*?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1875#discussion_r436185153", "createdAt": "2020-06-05T22:03:51Z", "author": {"login": "millems"}, "path": "docs/design/core/waiters/README.md", "diffHunk": "@@ -0,0 +1,447 @@\n+**Design:** New Feature, **Status:** [Proposed](../../README.md)\n+\n+# Waiters\n+\n+\"Waiters\" are an abstraction used to poll a resource until a desired state is reached or until it is determined that\n+the resource will never enter into the desired state. This feature is supported in the AWS Java SDK 1.x and this document proposes \n+how waiters should be implemented in the Java SDK 2.x. \n+\n+## Introduction\n+\n+A waiter makes it easier for customers to wait for a resource to transition into a desired state. It comes handy when customers are\n+interacting with operations that are eventually consistent on the service side.\n+\n+For example, when you invoke `dynamodb#createTable`, the service immediately returns a response with a TableStatus of `CREATING`\n+and the table will not be available to perform write or read until the status has transitioned to `ACTIVE`. Waiters can be used to help \n+you handle the task of waiting for the table to become available.\n+\n+## Proposed APIs\n+\n+The SDK 2.x will support both sync and async waiters for service clients that have waiter-eligible operations. It will also provide a generic `Waiter` class\n+which makes it possible for customers to customize polling function, define expected sucess, failure and retry conditions as well as configurations such as `maxAttempts`. \n+\n+### Usage Examples\n+\n+#### Example 1: Using sync waiters\n+\n+```Java\n+DynamoDbClient client = DynamoDbClient.create();\n+\n+DescribeTableResponse response = client.waiter().waitUtilTableExists(b -> b.tableName(\"table\"));\n+```\n+\n+#### Example 2: Using async waiters\n+\n+```Java\n+DynamoDbAsyncClient asyncClient = DynamoDbAsyncClient.create();\n+\n+CompletableFuture<DescribeTableResponse> responseFuture = \n+    asyncClient.waiter().waitUtilTableExists(b -> b.tableName(\"table\"));\n+```\n+\n+*FAQ Below: \"Why not create waiter operations directly on the client?\"*\n+\n+#### Example 3: Using the generic waiter\n+\n+```Java\n+Waiter<DescribeTableResponse> waiter =\n+   Waiter.<DescribeTableResponse>builder()\n+        .addAcceptor(WaiterAcceptor.successAcceptor(r -> r.table().tableStatus().equals(TableStatus.ACTIVE)))\n+        .addAcceptor(WaiterAcceptor.retryAcceptor(t -> t instanceof ResourceNotFoundException))\n+        .addAcceptor(WaiterAcceptor.errorAcceptor(t -> t instanceof InternalServerErrorException))\n+        .maxAttempts(20)\n+        .backoffStrategy(BackoffStrategy.defaultStrategy())\n+        .build();\n+\n+// run synchronousely \n+DescribeTableResponse response = waiter.run(() -> client.describeTable(describeTableRequest));\n+\n+// run asychronousely\n+CompletableFuture<DescribeTableResponse> responseFuture =\n+      waiter.runAsync(() -> asyncClient.describeTable(describeTableRequest));\n+```\n+\n+### `{Service}Waiter` and `{Service}AsyncWaiter`\n+\n+Two classes will be created for each waiter-eligible service: `{Service}Waiter` and `{Service}AsyncWaiter` (e.g. `DynamoDbWaiter`, `DynamoDbAsyncWaiter`). \n+This follows the naming strategy established by the current `{Service}Client` and `{Service}Utilities` classes.\n+\n+#### Example\n+\n+```Java\n+/**\n+ * Waiter utility class that waits for a resource to transition to the desired state.\n+ */\n+@SdkPublicApi\n+@Generated(\"software.amazon.awssdk:codegen\")\n+public interface DynamoDbWaiter {\n+\n+    /**\n+     * Poller method that waits for the table status to transition to <code>ACTIVE</code> by\n+     * invoking {@link DynamoDbClient#describeTable}. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return {@link DescribeTableResponse}\n+     */\n+    default DescribeTableResponse waitUtilTableExists(DescribeTableRequest describeTableRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e78993f9d3c5dbb7f3e2952cde69fc8bee449771"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4NTg4MA==", "bodyText": "Oops! I blame intellij for not telling me.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1875#discussion_r436185880", "createdAt": "2020-06-05T22:06:15Z", "author": {"login": "zoewangg"}, "path": "docs/design/core/waiters/README.md", "diffHunk": "@@ -0,0 +1,447 @@\n+**Design:** New Feature, **Status:** [Proposed](../../README.md)\n+\n+# Waiters\n+\n+\"Waiters\" are an abstraction used to poll a resource until a desired state is reached or until it is determined that\n+the resource will never enter into the desired state. This feature is supported in the AWS Java SDK 1.x and this document proposes \n+how waiters should be implemented in the Java SDK 2.x. \n+\n+## Introduction\n+\n+A waiter makes it easier for customers to wait for a resource to transition into a desired state. It comes handy when customers are\n+interacting with operations that are eventually consistent on the service side.\n+\n+For example, when you invoke `dynamodb#createTable`, the service immediately returns a response with a TableStatus of `CREATING`\n+and the table will not be available to perform write or read until the status has transitioned to `ACTIVE`. Waiters can be used to help \n+you handle the task of waiting for the table to become available.\n+\n+## Proposed APIs\n+\n+The SDK 2.x will support both sync and async waiters for service clients that have waiter-eligible operations. It will also provide a generic `Waiter` class\n+which makes it possible for customers to customize polling function, define expected sucess, failure and retry conditions as well as configurations such as `maxAttempts`. \n+\n+### Usage Examples\n+\n+#### Example 1: Using sync waiters\n+\n+```Java\n+DynamoDbClient client = DynamoDbClient.create();\n+\n+DescribeTableResponse response = client.waiter().waitUtilTableExists(b -> b.tableName(\"table\"));\n+```\n+\n+#### Example 2: Using async waiters\n+\n+```Java\n+DynamoDbAsyncClient asyncClient = DynamoDbAsyncClient.create();\n+\n+CompletableFuture<DescribeTableResponse> responseFuture = \n+    asyncClient.waiter().waitUtilTableExists(b -> b.tableName(\"table\"));\n+```\n+\n+*FAQ Below: \"Why not create waiter operations directly on the client?\"*\n+\n+#### Example 3: Using the generic waiter\n+\n+```Java\n+Waiter<DescribeTableResponse> waiter =\n+   Waiter.<DescribeTableResponse>builder()\n+        .addAcceptor(WaiterAcceptor.successAcceptor(r -> r.table().tableStatus().equals(TableStatus.ACTIVE)))\n+        .addAcceptor(WaiterAcceptor.retryAcceptor(t -> t instanceof ResourceNotFoundException))\n+        .addAcceptor(WaiterAcceptor.errorAcceptor(t -> t instanceof InternalServerErrorException))\n+        .maxAttempts(20)\n+        .backoffStrategy(BackoffStrategy.defaultStrategy())\n+        .build();\n+\n+// run synchronousely \n+DescribeTableResponse response = waiter.run(() -> client.describeTable(describeTableRequest));\n+\n+// run asychronousely\n+CompletableFuture<DescribeTableResponse> responseFuture =\n+      waiter.runAsync(() -> asyncClient.describeTable(describeTableRequest));\n+```\n+\n+### `{Service}Waiter` and `{Service}AsyncWaiter`\n+\n+Two classes will be created for each waiter-eligible service: `{Service}Waiter` and `{Service}AsyncWaiter` (e.g. `DynamoDbWaiter`, `DynamoDbAsyncWaiter`). \n+This follows the naming strategy established by the current `{Service}Client` and `{Service}Utilities` classes.\n+\n+#### Example\n+\n+```Java\n+/**\n+ * Waiter utility class that waits for a resource to transition to the desired state.\n+ */\n+@SdkPublicApi\n+@Generated(\"software.amazon.awssdk:codegen\")\n+public interface DynamoDbWaiter {\n+\n+    /**\n+     * Poller method that waits for the table status to transition to <code>ACTIVE</code> by\n+     * invoking {@link DynamoDbClient#describeTable}. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return {@link DescribeTableResponse}\n+     */\n+    default DescribeTableResponse waitUtilTableExists(DescribeTableRequest describeTableRequest) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4NTE1Mw=="}, "originalCommit": {"oid": "e78993f9d3c5dbb7f3e2952cde69fc8bee449771"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjk3Njg0OnYy", "diffSide": "RIGHT", "path": "docs/design/core/waiters/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjowODoyMVrOGf-tTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjowODoyMVrOGf-tTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4NjQ0NA==", "bodyText": "Can we bikeshed on the name?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1875#discussion_r436186444", "createdAt": "2020-06-05T22:08:21Z", "author": {"login": "millems"}, "path": "docs/design/core/waiters/README.md", "diffHunk": "@@ -0,0 +1,447 @@\n+**Design:** New Feature, **Status:** [Proposed](../../README.md)\n+\n+# Waiters\n+\n+\"Waiters\" are an abstraction used to poll a resource until a desired state is reached or until it is determined that\n+the resource will never enter into the desired state. This feature is supported in the AWS Java SDK 1.x and this document proposes \n+how waiters should be implemented in the Java SDK 2.x. \n+\n+## Introduction\n+\n+A waiter makes it easier for customers to wait for a resource to transition into a desired state. It comes handy when customers are\n+interacting with operations that are eventually consistent on the service side.\n+\n+For example, when you invoke `dynamodb#createTable`, the service immediately returns a response with a TableStatus of `CREATING`\n+and the table will not be available to perform write or read until the status has transitioned to `ACTIVE`. Waiters can be used to help \n+you handle the task of waiting for the table to become available.\n+\n+## Proposed APIs\n+\n+The SDK 2.x will support both sync and async waiters for service clients that have waiter-eligible operations. It will also provide a generic `Waiter` class\n+which makes it possible for customers to customize polling function, define expected sucess, failure and retry conditions as well as configurations such as `maxAttempts`. \n+\n+### Usage Examples\n+\n+#### Example 1: Using sync waiters\n+\n+```Java\n+DynamoDbClient client = DynamoDbClient.create();\n+\n+DescribeTableResponse response = client.waiter().waitUtilTableExists(b -> b.tableName(\"table\"));\n+```\n+\n+#### Example 2: Using async waiters\n+\n+```Java\n+DynamoDbAsyncClient asyncClient = DynamoDbAsyncClient.create();\n+\n+CompletableFuture<DescribeTableResponse> responseFuture = \n+    asyncClient.waiter().waitUtilTableExists(b -> b.tableName(\"table\"));\n+```\n+\n+*FAQ Below: \"Why not create waiter operations directly on the client?\"*\n+\n+#### Example 3: Using the generic waiter\n+\n+```Java\n+Waiter<DescribeTableResponse> waiter =\n+   Waiter.<DescribeTableResponse>builder()\n+        .addAcceptor(WaiterAcceptor.successAcceptor(r -> r.table().tableStatus().equals(TableStatus.ACTIVE)))\n+        .addAcceptor(WaiterAcceptor.retryAcceptor(t -> t instanceof ResourceNotFoundException))\n+        .addAcceptor(WaiterAcceptor.errorAcceptor(t -> t instanceof InternalServerErrorException))\n+        .maxAttempts(20)\n+        .backoffStrategy(BackoffStrategy.defaultStrategy())\n+        .build();\n+\n+// run synchronousely \n+DescribeTableResponse response = waiter.run(() -> client.describeTable(describeTableRequest));\n+\n+// run asychronousely\n+CompletableFuture<DescribeTableResponse> responseFuture =\n+      waiter.runAsync(() -> asyncClient.describeTable(describeTableRequest));\n+```\n+\n+### `{Service}Waiter` and `{Service}AsyncWaiter`\n+\n+Two classes will be created for each waiter-eligible service: `{Service}Waiter` and `{Service}AsyncWaiter` (e.g. `DynamoDbWaiter`, `DynamoDbAsyncWaiter`). \n+This follows the naming strategy established by the current `{Service}Client` and `{Service}Utilities` classes.\n+\n+#### Example\n+\n+```Java\n+/**\n+ * Waiter utility class that waits for a resource to transition to the desired state.\n+ */\n+@SdkPublicApi\n+@Generated(\"software.amazon.awssdk:codegen\")\n+public interface DynamoDbWaiter {\n+\n+    /**\n+     * Poller method that waits for the table status to transition to <code>ACTIVE</code> by\n+     * invoking {@link DynamoDbClient#describeTable}. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return {@link DescribeTableResponse}\n+     */\n+    default DescribeTableResponse waitUtilTableExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default DescribeTableResponse waitUtilTableExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        return waitUtilTableExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+\n+    /**\n+     * Poller method that waits until the table does not exists by invoking {@link DynamoDbClient#describeTable}.\n+     * It returns when the resource enters into a desired state or it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     */\n+    default void waitUtilTableNotExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void waitUtilTableNotExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        waitUtilTableNotExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+}\n+\n+/**\n+ * Waiter utility class that waits for a resource to transition to the desired state asynchronously.\n+ */\n+@SdkPublicApi\n+@Generated(\"software.amazon.awssdk:codegen\")\n+public interface DynamoDbAsyncWaiter {\n+\n+    /**\n+     * Poller method that waits for the table status to transition to <code>ACTIVE</code> by\n+     * invoking {@link DynamoDbAsyncClient#describeTable}. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    default CompletableFuture<DescribeTableResponse> waitUtilTableExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default CompletableFuture<DescribeTableResponse> waitUtilTableExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        return waitUtilTableExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+\n+    /**\n+     * Poller method that waits until the table does not exists by invoking {@link DynamoDbAsyncClient#describeTable}.\n+     * It returns when the resource enters into a desired state or it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    default CompletableFuture<Void> waitUtilTableNotExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default CompletableFuture<Void> waitUtilTableNotExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        return waitUtilTableNotExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+}\n+```\n+\n+*FAQ Below: \"Why returning the service response for waiter operations with a success state of a specific response\" and \"Why not returning a response for waiter operations with a success state of error?\"*.\n+\n+#### Instantiation\n+\n+This class can be instantiated from an existing service client\n+\n+```Java\n+// sync waiter\n+DynamoDbClient dynamo = DynamoDbClient.create();\n+DynamoDbWaiter dynamoWaiter = dynamo.waiter();\n+\n+// async waiter\n+DynamoDbClient dynamoAsync = DynamoDbAsyncClient.create();\n+DynamoDbAsyncWaiter dynamoAsyncWaiter = dynamoAsync.waiter();\n+```\n+\n+#### Methods\n+\n+A method will be generated for each operation that needs waiter support. There are two categories depending on the expected success state.\n+\n+- Operations with a desired condition where a specific *successful* response is returned\n+  - sync: `{Operation}Response waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    DescribeTableResponse waitUtilTableExists(DescribeTableRequest describeTableRequest)\n+    ```\n+  - async: `CompletableFuture<{Operation}Response> waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    CompletableFuture<DescribeTableResponse> waitUtilTableExists(DescribeTableRequest describeTableRequest)\n+    ```\n+- Operations with a desired condition where a specific *exception* is thrown\n+  - sync: `void waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    void waitUtilTableNotExists(DescribeTableRequest describeTableRequest)\n+    ```\n+  - async: `CompletableFuture<Void> waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    CompletableFuture<Void> waitUtilTableNotExists(DescribeTableRequest describeTableRequest)\n+    ```\n+    \n+### `Waiter<T>`\n+\n+The generic `Waiter` class enables users to customize waiter configurations and provide their own `WaiterAcceptor`s which define the expected states and controls\n+the terminal state of the waiter.\n+\n+#### Methods\n+\n+```java\n+@SdkPublicApi\n+public final class Waiter<T> {\n+    /**\n+     * Runs the provided polling function. It completes when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param asyncPollingFunction the polling function to trigger\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    public CompletableFuture<T> runAsync(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+     ...\n+    }\n+\n+    /**\n+     * Runs the provided polling function. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param pollingFunction Represents the input of a <code>DescribeTable</code> operation.\n+     * @return the response\n+     */\n+    public T run(Supplier<T> pollingFunction) {\n+        ...\n+    }\n+}\n+```\n+\n+#### Inner-Class: `Waiter.Builder`\n+\n+```java\n+    public interface Builder<T> {\n+\n+        /**\n+         * Defines a list of {@link WaiterAcceptor}s to check if an expected state has met after executing an operation.\n+         *\n+         * @param waiterAcceptors the waiter acceptors\n+         * @return the chained builder\n+         */\n+        Builder<T> acceptors(List<WaiterAcceptor<T>> waiterAcceptors);\n+\n+        /**\n+         * Add a {@link WaiterAcceptor}s\n+         *\n+         * @param waiterAcceptors the waiter acceptors\n+         * @return the chained builder\n+         */\n+        Builder<T> addAcceptor(WaiterAcceptor<T> waiterAcceptors);\n+\n+        /**\n+         * Define the maximum number of attempts to try before transitioning the waiter to a failure state.\n+         */\n+        Builder<T> maxAttempts(int numRetries);\n+\n+        /**\n+         * Define the {@link BackoffStrategy} that computes the delay before the next retry request.\n+         * @param backoffStrategy the backoff strategy\n+         * @return the chained builder\n+         */\n+        Builder<T> backoffStrategy(BackoffStrategy backoffStrategy);\n+\n+        /**\n+         * Define the {@link ScheduledExecutorService} used to schedule async attempts\n+         *\n+         * @param scheduledExecutorService the schedule executor service\n+         * @return the chained builder\n+         */\n+        Builder<T> scheduledExecutorService(ScheduledExecutorService scheduledExecutorService);\n+    }\n+```\n+\n+### `WaiterState`\n+\n+`WaiterState` is an enum that defines possible states of a waiter to be transitioned to if a condition is met\n+\n+```java\n+public enum WaiterState {\n+    /**\n+     * Indicates the waiter succeeded and must no longer continue waiting.\n+     */\n+    SUCCESS,\n+\n+    /**\n+     * Indicates the waiter failed and must not continue waiting.\n+     */\n+    FAILURE,\n+\n+    /**\n+     * Indicates that the waiter encountered an expected failure case and should retry if possible.\n+     */\n+    RETRY\n+}\n+```\n+\n+### `WaiterAcceptor`\n+\n+`WaiterAcceptor` is a class that inspects the response or error returned from the operation and determines whether an expected condition\n+is met and indicates the next state that the waiter should be transitioned to if there is a match.\n+\n+```java\n+@SdkPublicApi\n+public interface WaiterAcceptor<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e78993f9d3c5dbb7f3e2952cde69fc8bee449771"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjk3ODY4OnYy", "diffSide": "RIGHT", "path": "docs/design/core/waiters/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjowOTo0MFrOGf-ukw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjowOTo0MFrOGf-ukw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4Njc3MQ==", "bodyText": "Isn't retrying on an exception just as common as retrying on a non-exception?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1875#discussion_r436186771", "createdAt": "2020-06-05T22:09:40Z", "author": {"login": "millems"}, "path": "docs/design/core/waiters/README.md", "diffHunk": "@@ -0,0 +1,447 @@\n+**Design:** New Feature, **Status:** [Proposed](../../README.md)\n+\n+# Waiters\n+\n+\"Waiters\" are an abstraction used to poll a resource until a desired state is reached or until it is determined that\n+the resource will never enter into the desired state. This feature is supported in the AWS Java SDK 1.x and this document proposes \n+how waiters should be implemented in the Java SDK 2.x. \n+\n+## Introduction\n+\n+A waiter makes it easier for customers to wait for a resource to transition into a desired state. It comes handy when customers are\n+interacting with operations that are eventually consistent on the service side.\n+\n+For example, when you invoke `dynamodb#createTable`, the service immediately returns a response with a TableStatus of `CREATING`\n+and the table will not be available to perform write or read until the status has transitioned to `ACTIVE`. Waiters can be used to help \n+you handle the task of waiting for the table to become available.\n+\n+## Proposed APIs\n+\n+The SDK 2.x will support both sync and async waiters for service clients that have waiter-eligible operations. It will also provide a generic `Waiter` class\n+which makes it possible for customers to customize polling function, define expected sucess, failure and retry conditions as well as configurations such as `maxAttempts`. \n+\n+### Usage Examples\n+\n+#### Example 1: Using sync waiters\n+\n+```Java\n+DynamoDbClient client = DynamoDbClient.create();\n+\n+DescribeTableResponse response = client.waiter().waitUtilTableExists(b -> b.tableName(\"table\"));\n+```\n+\n+#### Example 2: Using async waiters\n+\n+```Java\n+DynamoDbAsyncClient asyncClient = DynamoDbAsyncClient.create();\n+\n+CompletableFuture<DescribeTableResponse> responseFuture = \n+    asyncClient.waiter().waitUtilTableExists(b -> b.tableName(\"table\"));\n+```\n+\n+*FAQ Below: \"Why not create waiter operations directly on the client?\"*\n+\n+#### Example 3: Using the generic waiter\n+\n+```Java\n+Waiter<DescribeTableResponse> waiter =\n+   Waiter.<DescribeTableResponse>builder()\n+        .addAcceptor(WaiterAcceptor.successAcceptor(r -> r.table().tableStatus().equals(TableStatus.ACTIVE)))\n+        .addAcceptor(WaiterAcceptor.retryAcceptor(t -> t instanceof ResourceNotFoundException))\n+        .addAcceptor(WaiterAcceptor.errorAcceptor(t -> t instanceof InternalServerErrorException))\n+        .maxAttempts(20)\n+        .backoffStrategy(BackoffStrategy.defaultStrategy())\n+        .build();\n+\n+// run synchronousely \n+DescribeTableResponse response = waiter.run(() -> client.describeTable(describeTableRequest));\n+\n+// run asychronousely\n+CompletableFuture<DescribeTableResponse> responseFuture =\n+      waiter.runAsync(() -> asyncClient.describeTable(describeTableRequest));\n+```\n+\n+### `{Service}Waiter` and `{Service}AsyncWaiter`\n+\n+Two classes will be created for each waiter-eligible service: `{Service}Waiter` and `{Service}AsyncWaiter` (e.g. `DynamoDbWaiter`, `DynamoDbAsyncWaiter`). \n+This follows the naming strategy established by the current `{Service}Client` and `{Service}Utilities` classes.\n+\n+#### Example\n+\n+```Java\n+/**\n+ * Waiter utility class that waits for a resource to transition to the desired state.\n+ */\n+@SdkPublicApi\n+@Generated(\"software.amazon.awssdk:codegen\")\n+public interface DynamoDbWaiter {\n+\n+    /**\n+     * Poller method that waits for the table status to transition to <code>ACTIVE</code> by\n+     * invoking {@link DynamoDbClient#describeTable}. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return {@link DescribeTableResponse}\n+     */\n+    default DescribeTableResponse waitUtilTableExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default DescribeTableResponse waitUtilTableExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        return waitUtilTableExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+\n+    /**\n+     * Poller method that waits until the table does not exists by invoking {@link DynamoDbClient#describeTable}.\n+     * It returns when the resource enters into a desired state or it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     */\n+    default void waitUtilTableNotExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void waitUtilTableNotExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        waitUtilTableNotExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+}\n+\n+/**\n+ * Waiter utility class that waits for a resource to transition to the desired state asynchronously.\n+ */\n+@SdkPublicApi\n+@Generated(\"software.amazon.awssdk:codegen\")\n+public interface DynamoDbAsyncWaiter {\n+\n+    /**\n+     * Poller method that waits for the table status to transition to <code>ACTIVE</code> by\n+     * invoking {@link DynamoDbAsyncClient#describeTable}. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    default CompletableFuture<DescribeTableResponse> waitUtilTableExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default CompletableFuture<DescribeTableResponse> waitUtilTableExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        return waitUtilTableExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+\n+    /**\n+     * Poller method that waits until the table does not exists by invoking {@link DynamoDbAsyncClient#describeTable}.\n+     * It returns when the resource enters into a desired state or it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    default CompletableFuture<Void> waitUtilTableNotExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default CompletableFuture<Void> waitUtilTableNotExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        return waitUtilTableNotExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+}\n+```\n+\n+*FAQ Below: \"Why returning the service response for waiter operations with a success state of a specific response\" and \"Why not returning a response for waiter operations with a success state of error?\"*.\n+\n+#### Instantiation\n+\n+This class can be instantiated from an existing service client\n+\n+```Java\n+// sync waiter\n+DynamoDbClient dynamo = DynamoDbClient.create();\n+DynamoDbWaiter dynamoWaiter = dynamo.waiter();\n+\n+// async waiter\n+DynamoDbClient dynamoAsync = DynamoDbAsyncClient.create();\n+DynamoDbAsyncWaiter dynamoAsyncWaiter = dynamoAsync.waiter();\n+```\n+\n+#### Methods\n+\n+A method will be generated for each operation that needs waiter support. There are two categories depending on the expected success state.\n+\n+- Operations with a desired condition where a specific *successful* response is returned\n+  - sync: `{Operation}Response waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    DescribeTableResponse waitUtilTableExists(DescribeTableRequest describeTableRequest)\n+    ```\n+  - async: `CompletableFuture<{Operation}Response> waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    CompletableFuture<DescribeTableResponse> waitUtilTableExists(DescribeTableRequest describeTableRequest)\n+    ```\n+- Operations with a desired condition where a specific *exception* is thrown\n+  - sync: `void waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    void waitUtilTableNotExists(DescribeTableRequest describeTableRequest)\n+    ```\n+  - async: `CompletableFuture<Void> waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    CompletableFuture<Void> waitUtilTableNotExists(DescribeTableRequest describeTableRequest)\n+    ```\n+    \n+### `Waiter<T>`\n+\n+The generic `Waiter` class enables users to customize waiter configurations and provide their own `WaiterAcceptor`s which define the expected states and controls\n+the terminal state of the waiter.\n+\n+#### Methods\n+\n+```java\n+@SdkPublicApi\n+public final class Waiter<T> {\n+    /**\n+     * Runs the provided polling function. It completes when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param asyncPollingFunction the polling function to trigger\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    public CompletableFuture<T> runAsync(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+     ...\n+    }\n+\n+    /**\n+     * Runs the provided polling function. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param pollingFunction Represents the input of a <code>DescribeTable</code> operation.\n+     * @return the response\n+     */\n+    public T run(Supplier<T> pollingFunction) {\n+        ...\n+    }\n+}\n+```\n+\n+#### Inner-Class: `Waiter.Builder`\n+\n+```java\n+    public interface Builder<T> {\n+\n+        /**\n+         * Defines a list of {@link WaiterAcceptor}s to check if an expected state has met after executing an operation.\n+         *\n+         * @param waiterAcceptors the waiter acceptors\n+         * @return the chained builder\n+         */\n+        Builder<T> acceptors(List<WaiterAcceptor<T>> waiterAcceptors);\n+\n+        /**\n+         * Add a {@link WaiterAcceptor}s\n+         *\n+         * @param waiterAcceptors the waiter acceptors\n+         * @return the chained builder\n+         */\n+        Builder<T> addAcceptor(WaiterAcceptor<T> waiterAcceptors);\n+\n+        /**\n+         * Define the maximum number of attempts to try before transitioning the waiter to a failure state.\n+         */\n+        Builder<T> maxAttempts(int numRetries);\n+\n+        /**\n+         * Define the {@link BackoffStrategy} that computes the delay before the next retry request.\n+         * @param backoffStrategy the backoff strategy\n+         * @return the chained builder\n+         */\n+        Builder<T> backoffStrategy(BackoffStrategy backoffStrategy);\n+\n+        /**\n+         * Define the {@link ScheduledExecutorService} used to schedule async attempts\n+         *\n+         * @param scheduledExecutorService the schedule executor service\n+         * @return the chained builder\n+         */\n+        Builder<T> scheduledExecutorService(ScheduledExecutorService scheduledExecutorService);\n+    }\n+```\n+\n+### `WaiterState`\n+\n+`WaiterState` is an enum that defines possible states of a waiter to be transitioned to if a condition is met\n+\n+```java\n+public enum WaiterState {\n+    /**\n+     * Indicates the waiter succeeded and must no longer continue waiting.\n+     */\n+    SUCCESS,\n+\n+    /**\n+     * Indicates the waiter failed and must not continue waiting.\n+     */\n+    FAILURE,\n+\n+    /**\n+     * Indicates that the waiter encountered an expected failure case and should retry if possible.\n+     */\n+    RETRY\n+}\n+```\n+\n+### `WaiterAcceptor`\n+\n+`WaiterAcceptor` is a class that inspects the response or error returned from the operation and determines whether an expected condition\n+is met and indicates the next state that the waiter should be transitioned to if there is a match.\n+\n+```java\n+@SdkPublicApi\n+public interface WaiterAcceptor<T> {\n+\n+    /**\n+     * @return the next {@link WaiterState} that the waiter should be transitioned to if this acceptor matches with the response or error\n+     */\n+    WaiterState waiterState();\n+\n+    /**\n+     * Check to see if the response matches with the expected state defined by the acceptor\n+     *\n+     * @param response the response to inspect\n+     * @return whether it accepts the response\n+     */\n+    default boolean matches(T response) {\n+        return false;\n+    }\n+\n+    /**\n+     * Check to see if the exception matches with the expected state defined by the acceptor\n+     *\n+     * @param throwable the exception to inspect\n+     * @return whether it accepts the throwable\n+     */\n+    default boolean matches(Throwable throwable) {\n+        return false;\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the response matches with the success state\n+     *\n+     * @param responsePredicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> successAcceptor(Predicate<T> responsePredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.SUCCESS;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates an error waiter acceptor which determines if the exception should transition the waiter to failure state\n+     *\n+     * @param errorPredicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a retry waiter acceptor which determines if the exception should transition the waiter to retry state\n+     *\n+     * @param errorPredicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> retryAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.RETRY;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e78993f9d3c5dbb7f3e2952cde69fc8bee449771"}, "originalPosition": 390}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjk4MDg2OnYy", "diffSide": "RIGHT", "path": "docs/design/core/waiters/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjoxMDo1NlrOGf-v7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMjoxMDo1NlrOGf-v7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4NzExOA==", "bodyText": "Can we cache every response, so they can see what happened, instead of just the latest?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1875#discussion_r436187118", "createdAt": "2020-06-05T22:10:56Z", "author": {"login": "millems"}, "path": "docs/design/core/waiters/README.md", "diffHunk": "@@ -0,0 +1,447 @@\n+**Design:** New Feature, **Status:** [Proposed](../../README.md)\n+\n+# Waiters\n+\n+\"Waiters\" are an abstraction used to poll a resource until a desired state is reached or until it is determined that\n+the resource will never enter into the desired state. This feature is supported in the AWS Java SDK 1.x and this document proposes \n+how waiters should be implemented in the Java SDK 2.x. \n+\n+## Introduction\n+\n+A waiter makes it easier for customers to wait for a resource to transition into a desired state. It comes handy when customers are\n+interacting with operations that are eventually consistent on the service side.\n+\n+For example, when you invoke `dynamodb#createTable`, the service immediately returns a response with a TableStatus of `CREATING`\n+and the table will not be available to perform write or read until the status has transitioned to `ACTIVE`. Waiters can be used to help \n+you handle the task of waiting for the table to become available.\n+\n+## Proposed APIs\n+\n+The SDK 2.x will support both sync and async waiters for service clients that have waiter-eligible operations. It will also provide a generic `Waiter` class\n+which makes it possible for customers to customize polling function, define expected sucess, failure and retry conditions as well as configurations such as `maxAttempts`. \n+\n+### Usage Examples\n+\n+#### Example 1: Using sync waiters\n+\n+```Java\n+DynamoDbClient client = DynamoDbClient.create();\n+\n+DescribeTableResponse response = client.waiter().waitUtilTableExists(b -> b.tableName(\"table\"));\n+```\n+\n+#### Example 2: Using async waiters\n+\n+```Java\n+DynamoDbAsyncClient asyncClient = DynamoDbAsyncClient.create();\n+\n+CompletableFuture<DescribeTableResponse> responseFuture = \n+    asyncClient.waiter().waitUtilTableExists(b -> b.tableName(\"table\"));\n+```\n+\n+*FAQ Below: \"Why not create waiter operations directly on the client?\"*\n+\n+#### Example 3: Using the generic waiter\n+\n+```Java\n+Waiter<DescribeTableResponse> waiter =\n+   Waiter.<DescribeTableResponse>builder()\n+        .addAcceptor(WaiterAcceptor.successAcceptor(r -> r.table().tableStatus().equals(TableStatus.ACTIVE)))\n+        .addAcceptor(WaiterAcceptor.retryAcceptor(t -> t instanceof ResourceNotFoundException))\n+        .addAcceptor(WaiterAcceptor.errorAcceptor(t -> t instanceof InternalServerErrorException))\n+        .maxAttempts(20)\n+        .backoffStrategy(BackoffStrategy.defaultStrategy())\n+        .build();\n+\n+// run synchronousely \n+DescribeTableResponse response = waiter.run(() -> client.describeTable(describeTableRequest));\n+\n+// run asychronousely\n+CompletableFuture<DescribeTableResponse> responseFuture =\n+      waiter.runAsync(() -> asyncClient.describeTable(describeTableRequest));\n+```\n+\n+### `{Service}Waiter` and `{Service}AsyncWaiter`\n+\n+Two classes will be created for each waiter-eligible service: `{Service}Waiter` and `{Service}AsyncWaiter` (e.g. `DynamoDbWaiter`, `DynamoDbAsyncWaiter`). \n+This follows the naming strategy established by the current `{Service}Client` and `{Service}Utilities` classes.\n+\n+#### Example\n+\n+```Java\n+/**\n+ * Waiter utility class that waits for a resource to transition to the desired state.\n+ */\n+@SdkPublicApi\n+@Generated(\"software.amazon.awssdk:codegen\")\n+public interface DynamoDbWaiter {\n+\n+    /**\n+     * Poller method that waits for the table status to transition to <code>ACTIVE</code> by\n+     * invoking {@link DynamoDbClient#describeTable}. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return {@link DescribeTableResponse}\n+     */\n+    default DescribeTableResponse waitUtilTableExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default DescribeTableResponse waitUtilTableExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        return waitUtilTableExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+\n+    /**\n+     * Poller method that waits until the table does not exists by invoking {@link DynamoDbClient#describeTable}.\n+     * It returns when the resource enters into a desired state or it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     */\n+    default void waitUtilTableNotExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void waitUtilTableNotExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        waitUtilTableNotExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+}\n+\n+/**\n+ * Waiter utility class that waits for a resource to transition to the desired state asynchronously.\n+ */\n+@SdkPublicApi\n+@Generated(\"software.amazon.awssdk:codegen\")\n+public interface DynamoDbAsyncWaiter {\n+\n+    /**\n+     * Poller method that waits for the table status to transition to <code>ACTIVE</code> by\n+     * invoking {@link DynamoDbAsyncClient#describeTable}. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    default CompletableFuture<DescribeTableResponse> waitUtilTableExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default CompletableFuture<DescribeTableResponse> waitUtilTableExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        return waitUtilTableExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+\n+    /**\n+     * Poller method that waits until the table does not exists by invoking {@link DynamoDbAsyncClient#describeTable}.\n+     * It returns when the resource enters into a desired state or it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param describeTableRequest Represents the input of a <code>DescribeTable</code> operation.\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    default CompletableFuture<Void> waitUtilTableNotExists(DescribeTableRequest describeTableRequest) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default CompletableFuture<Void> waitUtilTableNotExists(Consumer<DescribeTableRequest.Builder> describeTableRequest) {\n+        return waitUtilTableNotExists(DescribeTableRequest.builder().applyMutation(describeTableRequest).build());\n+    }\n+}\n+```\n+\n+*FAQ Below: \"Why returning the service response for waiter operations with a success state of a specific response\" and \"Why not returning a response for waiter operations with a success state of error?\"*.\n+\n+#### Instantiation\n+\n+This class can be instantiated from an existing service client\n+\n+```Java\n+// sync waiter\n+DynamoDbClient dynamo = DynamoDbClient.create();\n+DynamoDbWaiter dynamoWaiter = dynamo.waiter();\n+\n+// async waiter\n+DynamoDbClient dynamoAsync = DynamoDbAsyncClient.create();\n+DynamoDbAsyncWaiter dynamoAsyncWaiter = dynamoAsync.waiter();\n+```\n+\n+#### Methods\n+\n+A method will be generated for each operation that needs waiter support. There are two categories depending on the expected success state.\n+\n+- Operations with a desired condition where a specific *successful* response is returned\n+  - sync: `{Operation}Response waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    DescribeTableResponse waitUtilTableExists(DescribeTableRequest describeTableRequest)\n+    ```\n+  - async: `CompletableFuture<{Operation}Response> waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    CompletableFuture<DescribeTableResponse> waitUtilTableExists(DescribeTableRequest describeTableRequest)\n+    ```\n+- Operations with a desired condition where a specific *exception* is thrown\n+  - sync: `void waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    void waitUtilTableNotExists(DescribeTableRequest describeTableRequest)\n+    ```\n+  - async: `CompletableFuture<Void> waitUtil{DesiredState}({Operation}Request)`\n+    ```java\n+    CompletableFuture<Void> waitUtilTableNotExists(DescribeTableRequest describeTableRequest)\n+    ```\n+    \n+### `Waiter<T>`\n+\n+The generic `Waiter` class enables users to customize waiter configurations and provide their own `WaiterAcceptor`s which define the expected states and controls\n+the terminal state of the waiter.\n+\n+#### Methods\n+\n+```java\n+@SdkPublicApi\n+public final class Waiter<T> {\n+    /**\n+     * Runs the provided polling function. It completes when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param asyncPollingFunction the polling function to trigger\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    public CompletableFuture<T> runAsync(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+     ...\n+    }\n+\n+    /**\n+     * Runs the provided polling function. It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param pollingFunction Represents the input of a <code>DescribeTable</code> operation.\n+     * @return the response\n+     */\n+    public T run(Supplier<T> pollingFunction) {\n+        ...\n+    }\n+}\n+```\n+\n+#### Inner-Class: `Waiter.Builder`\n+\n+```java\n+    public interface Builder<T> {\n+\n+        /**\n+         * Defines a list of {@link WaiterAcceptor}s to check if an expected state has met after executing an operation.\n+         *\n+         * @param waiterAcceptors the waiter acceptors\n+         * @return the chained builder\n+         */\n+        Builder<T> acceptors(List<WaiterAcceptor<T>> waiterAcceptors);\n+\n+        /**\n+         * Add a {@link WaiterAcceptor}s\n+         *\n+         * @param waiterAcceptors the waiter acceptors\n+         * @return the chained builder\n+         */\n+        Builder<T> addAcceptor(WaiterAcceptor<T> waiterAcceptors);\n+\n+        /**\n+         * Define the maximum number of attempts to try before transitioning the waiter to a failure state.\n+         */\n+        Builder<T> maxAttempts(int numRetries);\n+\n+        /**\n+         * Define the {@link BackoffStrategy} that computes the delay before the next retry request.\n+         * @param backoffStrategy the backoff strategy\n+         * @return the chained builder\n+         */\n+        Builder<T> backoffStrategy(BackoffStrategy backoffStrategy);\n+\n+        /**\n+         * Define the {@link ScheduledExecutorService} used to schedule async attempts\n+         *\n+         * @param scheduledExecutorService the schedule executor service\n+         * @return the chained builder\n+         */\n+        Builder<T> scheduledExecutorService(ScheduledExecutorService scheduledExecutorService);\n+    }\n+```\n+\n+### `WaiterState`\n+\n+`WaiterState` is an enum that defines possible states of a waiter to be transitioned to if a condition is met\n+\n+```java\n+public enum WaiterState {\n+    /**\n+     * Indicates the waiter succeeded and must no longer continue waiting.\n+     */\n+    SUCCESS,\n+\n+    /**\n+     * Indicates the waiter failed and must not continue waiting.\n+     */\n+    FAILURE,\n+\n+    /**\n+     * Indicates that the waiter encountered an expected failure case and should retry if possible.\n+     */\n+    RETRY\n+}\n+```\n+\n+### `WaiterAcceptor`\n+\n+`WaiterAcceptor` is a class that inspects the response or error returned from the operation and determines whether an expected condition\n+is met and indicates the next state that the waiter should be transitioned to if there is a match.\n+\n+```java\n+@SdkPublicApi\n+public interface WaiterAcceptor<T> {\n+\n+    /**\n+     * @return the next {@link WaiterState} that the waiter should be transitioned to if this acceptor matches with the response or error\n+     */\n+    WaiterState waiterState();\n+\n+    /**\n+     * Check to see if the response matches with the expected state defined by the acceptor\n+     *\n+     * @param response the response to inspect\n+     * @return whether it accepts the response\n+     */\n+    default boolean matches(T response) {\n+        return false;\n+    }\n+\n+    /**\n+     * Check to see if the exception matches with the expected state defined by the acceptor\n+     *\n+     * @param throwable the exception to inspect\n+     * @return whether it accepts the throwable\n+     */\n+    default boolean matches(Throwable throwable) {\n+        return false;\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the response matches with the success state\n+     *\n+     * @param responsePredicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> successAcceptor(Predicate<T> responsePredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.SUCCESS;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates an error waiter acceptor which determines if the exception should transition the waiter to failure state\n+     *\n+     * @param errorPredicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a retry waiter acceptor which determines if the exception should transition the waiter to retry state\n+     *\n+     * @param errorPredicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> retryAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.RETRY;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+}\n+```\n+\n+## FAQ\n+\n+### For which services will we generate waiters?\n+\n+We will generate a `{Service}Waiter` class if the service has any operations that need waiter support.\n+\n+### Why not create waiter operations directly on the client?\n+\n+The options are: (1) create separate waiter utility classes or (2) create waiter operations on the client\n+\n+The following compares Option 1 to Option 2, in the interest of illustrating why Option 1 was chosen.\n+\n+**Option 1:** create separate waiter utility classes\n+\n+```Java\n+dynamodb.waiter().waitUtilTableExists(describeTableRequest)\n+```\n+\n+**Option 2:** create waiter operations on each service client\n+\n+```Java\n+dynamodb.waitUntilTableExists(describeTableRequest)\n+```\n+\n+**Option 1 Pros:**\n+\n+1. consistent with existing s3 utilities and presigner method approach, eg: s3Client.utilities()\n+2. similar api to v1 waiter, and it might be easier for customers who are already using v1 waiter to migrate to v2.\n+\n+**Option 2 Pros:**\n+\n+1. slightly better discoverability\n+\n+**Decision:** Option 1 will be used, because it is consistent with existing features and option2 might bloat the size\n+of the client, making it more difficult to use.\n+\n+### Why returning the service response for waiter operations with a success state of a specific response?\n+\n+The reason that the last response that has satisfied the waiter success state is returned is because it is a common pattern that customers creates a resource and then\n+retrieves the information of the resources. Without returning the response, customers will have to send an extra request when the waiter returns. \n+See [feature request](https://github.com/aws/aws-sdk-java/issues/815)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e78993f9d3c5dbb7f3e2952cde69fc8bee449771"}, "originalPosition": 434}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4136, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}