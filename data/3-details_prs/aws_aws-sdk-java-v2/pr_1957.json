{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxNDAwNDgx", "number": 1957, "title": "Implement generic Waiter functionality", "bodyText": "Description\nImplement generic Waiter functionality", "createdAt": "2020-07-17T19:40:10Z", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957", "merged": true, "mergeCommit": {"oid": "34f3b998b82d32fbf28c495949257d3e096c32e7"}, "closed": true, "closedAt": "2020-08-26T22:24:28Z", "author": {"login": "zoewangg"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc164uJgBqjM1NTk5NjA0NDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCzAQFgBqjM2OTY3NDQ3NTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf221ba69f38e663d8eb834c5e2c7d3886205b32", "author": {"user": {"login": "zoewangg", "name": "Zoe Wang"}}, "url": "https://github.com/aws/aws-sdk-java-v2/commit/bf221ba69f38e663d8eb834c5e2c7d3886205b32", "committedDate": "2020-07-17T19:38:34Z", "message": "Implement generic Waiter functionality"}, "afterCommit": {"oid": "5f0077f885f3121f87af64539882e3533f17b62b", "author": {"user": {"login": "zoewangg", "name": "Zoe Wang"}}, "url": "https://github.com/aws/aws-sdk-java-v2/commit/5f0077f885f3121f87af64539882e3533f17b62b", "committedDate": "2020-07-17T21:40:21Z", "message": "Implement generic Waiter functionality"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5f0077f885f3121f87af64539882e3533f17b62b", "author": {"user": {"login": "zoewangg", "name": "Zoe Wang"}}, "url": "https://github.com/aws/aws-sdk-java-v2/commit/5f0077f885f3121f87af64539882e3533f17b62b", "committedDate": "2020-07-17T21:40:21Z", "message": "Implement generic Waiter functionality"}, "afterCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c", "author": {"user": {"login": "zoewangg", "name": "Zoe Wang"}}, "url": "https://github.com/aws/aws-sdk-java-v2/commit/fc6d8973f030436054ae63144bc336b824221a7c", "committedDate": "2020-07-17T23:15:03Z", "message": "Implement generic Waiter functionality"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzA5NjYy", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#pullrequestreview-452709662", "createdAt": "2020-07-21T18:10:41Z", "commit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxODoxMDo0MVrOG1EAfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxODo0MjozM1rOG1FIGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5MzM3Mw==", "bodyText": "Can you add more here? Not sure what a 'handler' does other than 'handle', and I don't know what it means to 'handle' an async waiter operation.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458293373", "createdAt": "2020-07-21T18:10:41Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NDE2MQ==", "bodyText": "Leftover logging?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458294161", "createdAt": "2020-07-21T18:12:04Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response\n+ */\n+@SdkInternalApi\n+@NotThreadSafe\n+public final class AsyncWaiterHandler<T> {\n+    private static final Logger log = Logger.loggerFor(AsyncWaiterHandler.class);\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final WaiterHandlerHelper<T> handlerHelper;\n+    private int attemptNumber = 0;\n+\n+    public AsyncWaiterHandler(PollingStrategy pollingStrategy,\n+                              List<WaiterAcceptor<T>> waiterAcceptors,\n+                              ScheduledExecutorService executorService) {\n+        this.pollingStrategy = Validate.paramNotNull(pollingStrategy, \"pollingStrategy\");\n+        Validate.paramNotNull(waiterAcceptors, \"waiterAcceptors\");\n+        this.executorService = Validate.paramNotNull(executorService, \"executorService\");\n+        this.handlerHelper = new WaiterHandlerHelper<>(waiterAcceptors, pollingStrategy);\n+    }\n+\n+    /**\n+     * Execute the provided async polling function\n+     */\n+    CompletableFuture<WaiterResponse<T>> execute(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        log.info(() -> \"starting to execute\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NTc1Mw==", "bodyText": "Any way that we could let an acceptor can provide a failure reason to include in the exception?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458295753", "createdAt": "2020-07-21T18:14:50Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response\n+ */\n+@SdkInternalApi\n+@NotThreadSafe\n+public final class AsyncWaiterHandler<T> {\n+    private static final Logger log = Logger.loggerFor(AsyncWaiterHandler.class);\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final WaiterHandlerHelper<T> handlerHelper;\n+    private int attemptNumber = 0;\n+\n+    public AsyncWaiterHandler(PollingStrategy pollingStrategy,\n+                              List<WaiterAcceptor<T>> waiterAcceptors,\n+                              ScheduledExecutorService executorService) {\n+        this.pollingStrategy = Validate.paramNotNull(pollingStrategy, \"pollingStrategy\");\n+        Validate.paramNotNull(waiterAcceptors, \"waiterAcceptors\");\n+        this.executorService = Validate.paramNotNull(executorService, \"executorService\");\n+        this.handlerHelper = new WaiterHandlerHelper<>(waiterAcceptors, pollingStrategy);\n+    }\n+\n+    /**\n+     * Execute the provided async polling function\n+     */\n+    CompletableFuture<WaiterResponse<T>> execute(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        log.info(() -> \"starting to execute\");\n+        CompletableFuture<WaiterResponse<T>> future = new CompletableFuture<>();\n+        doExecute(asyncPollingFunction, future);\n+        return future;\n+    }\n+\n+    private void doExecute(Supplier<CompletableFuture<T>> asyncPollingFunction, CompletableFuture<WaiterResponse<T>> future) {\n+        ++attemptNumber;\n+        log.info(() -> \"runOnce\" + attemptNumber);\n+        runAsyncPollingFunction(asyncPollingFunction, future);\n+    }\n+\n+    private void runAsyncPollingFunction(Supplier<CompletableFuture<T>> asyncPollingFunction,\n+                                         CompletableFuture<WaiterResponse<T>> future) {\n+        asyncPollingFunction.get().whenComplete((response, exception) -> {\n+            Optional<WaiterState> waiterState = handlerHelper.nextWaiterStateIfMatched(response, exception);\n+\n+            if (waiterState.isPresent()) {\n+                log.info(() -> \"waiter state \" + waiterState.get());\n+                WaiterState state = waiterState.get();\n+                switch (state) {\n+                    case SUCCESS:\n+                        future.complete(handlerHelper.createWaiterResponse(response, exception, attemptNumber));\n+                        break;\n+                    case RETRY:\n+                        maybeRetry(asyncPollingFunction, future);\n+                        break;\n+                    case FAILURE:\n+                        future.completeExceptionally(SdkClientException.create(\"A waiter acceptor was matched and transitioned \"\n+                                                                               + \"the waiter to failure state\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NjM5Nw==", "bodyText": "Should we preserve \"exception\" as the cause?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458296397", "createdAt": "2020-07-21T18:15:58Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response\n+ */\n+@SdkInternalApi\n+@NotThreadSafe\n+public final class AsyncWaiterHandler<T> {\n+    private static final Logger log = Logger.loggerFor(AsyncWaiterHandler.class);\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final WaiterHandlerHelper<T> handlerHelper;\n+    private int attemptNumber = 0;\n+\n+    public AsyncWaiterHandler(PollingStrategy pollingStrategy,\n+                              List<WaiterAcceptor<T>> waiterAcceptors,\n+                              ScheduledExecutorService executorService) {\n+        this.pollingStrategy = Validate.paramNotNull(pollingStrategy, \"pollingStrategy\");\n+        Validate.paramNotNull(waiterAcceptors, \"waiterAcceptors\");\n+        this.executorService = Validate.paramNotNull(executorService, \"executorService\");\n+        this.handlerHelper = new WaiterHandlerHelper<>(waiterAcceptors, pollingStrategy);\n+    }\n+\n+    /**\n+     * Execute the provided async polling function\n+     */\n+    CompletableFuture<WaiterResponse<T>> execute(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        log.info(() -> \"starting to execute\");\n+        CompletableFuture<WaiterResponse<T>> future = new CompletableFuture<>();\n+        doExecute(asyncPollingFunction, future);\n+        return future;\n+    }\n+\n+    private void doExecute(Supplier<CompletableFuture<T>> asyncPollingFunction, CompletableFuture<WaiterResponse<T>> future) {\n+        ++attemptNumber;\n+        log.info(() -> \"runOnce\" + attemptNumber);\n+        runAsyncPollingFunction(asyncPollingFunction, future);\n+    }\n+\n+    private void runAsyncPollingFunction(Supplier<CompletableFuture<T>> asyncPollingFunction,\n+                                         CompletableFuture<WaiterResponse<T>> future) {\n+        asyncPollingFunction.get().whenComplete((response, exception) -> {\n+            Optional<WaiterState> waiterState = handlerHelper.nextWaiterStateIfMatched(response, exception);\n+\n+            if (waiterState.isPresent()) {\n+                log.info(() -> \"waiter state \" + waiterState.get());\n+                WaiterState state = waiterState.get();\n+                switch (state) {\n+                    case SUCCESS:\n+                        future.complete(handlerHelper.createWaiterResponse(response, exception, attemptNumber));\n+                        break;\n+                    case RETRY:\n+                        maybeRetry(asyncPollingFunction, future);\n+                        break;\n+                    case FAILURE:\n+                        future.completeExceptionally(SdkClientException.create(\"A waiter acceptor was matched and transitioned \"\n+                                                                               + \"the waiter to failure state\"));\n+                        break;\n+                    default:\n+                        future.completeExceptionally(new UnsupportedOperationException());\n+                }\n+            } else {\n+                if (exception != null) {\n+                    future.completeExceptionally(SdkClientException.create(\"An exception was thrown and did not match any \"\n+                                                                           + \"waiter acceptors\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NzMyNA==", "bodyText": "Could we make this class thread-safe and reusable by just passing through the attemptNumber on each doExecute call? This seems like unnecessary mutability.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458297324", "createdAt": "2020-07-21T18:17:34Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response\n+ */\n+@SdkInternalApi\n+@NotThreadSafe\n+public final class AsyncWaiterHandler<T> {\n+    private static final Logger log = Logger.loggerFor(AsyncWaiterHandler.class);\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final WaiterHandlerHelper<T> handlerHelper;\n+    private int attemptNumber = 0;\n+\n+    public AsyncWaiterHandler(PollingStrategy pollingStrategy,\n+                              List<WaiterAcceptor<T>> waiterAcceptors,\n+                              ScheduledExecutorService executorService) {\n+        this.pollingStrategy = Validate.paramNotNull(pollingStrategy, \"pollingStrategy\");\n+        Validate.paramNotNull(waiterAcceptors, \"waiterAcceptors\");\n+        this.executorService = Validate.paramNotNull(executorService, \"executorService\");\n+        this.handlerHelper = new WaiterHandlerHelper<>(waiterAcceptors, pollingStrategy);\n+    }\n+\n+    /**\n+     * Execute the provided async polling function\n+     */\n+    CompletableFuture<WaiterResponse<T>> execute(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        log.info(() -> \"starting to execute\");\n+        CompletableFuture<WaiterResponse<T>> future = new CompletableFuture<>();\n+        doExecute(asyncPollingFunction, future);\n+        return future;\n+    }\n+\n+    private void doExecute(Supplier<CompletableFuture<T>> asyncPollingFunction, CompletableFuture<WaiterResponse<T>> future) {\n+        ++attemptNumber;\n+        log.info(() -> \"runOnce\" + attemptNumber);\n+        runAsyncPollingFunction(asyncPollingFunction, future);\n+    }\n+\n+    private void runAsyncPollingFunction(Supplier<CompletableFuture<T>> asyncPollingFunction,\n+                                         CompletableFuture<WaiterResponse<T>> future) {\n+        asyncPollingFunction.get().whenComplete((response, exception) -> {\n+            Optional<WaiterState> waiterState = handlerHelper.nextWaiterStateIfMatched(response, exception);\n+\n+            if (waiterState.isPresent()) {\n+                log.info(() -> \"waiter state \" + waiterState.get());\n+                WaiterState state = waiterState.get();\n+                switch (state) {\n+                    case SUCCESS:\n+                        future.complete(handlerHelper.createWaiterResponse(response, exception, attemptNumber));\n+                        break;\n+                    case RETRY:\n+                        maybeRetry(asyncPollingFunction, future);\n+                        break;\n+                    case FAILURE:\n+                        future.completeExceptionally(SdkClientException.create(\"A waiter acceptor was matched and transitioned \"\n+                                                                               + \"the waiter to failure state\"));\n+                        break;\n+                    default:\n+                        future.completeExceptionally(new UnsupportedOperationException());\n+                }\n+            } else {\n+                if (exception != null) {\n+                    future.completeExceptionally(SdkClientException.create(\"An exception was thrown and did not match any \"\n+                                                                           + \"waiter acceptors\"));\n+                } else {\n+                    // default to retry if there's no acceptor matched for the response\n+                    maybeRetry(asyncPollingFunction, future);\n+                }\n+            }\n+        });\n+    }\n+\n+    private void maybeRetry(Supplier<CompletableFuture<T>> asyncPollingFunction,\n+                            CompletableFuture<WaiterResponse<T>> future) {\n+        if (attemptNumber >= pollingStrategy.maxAttempts()) {\n+            future.completeExceptionally(SdkClientException.create(\"The waiter has exceeded max retry attempts: \" +\n+                                                                   pollingStrategy.maxAttempts()));\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5OTQ2Mw==", "bodyText": "Any reason we don't have the \"max attempts\" be an acceptor, instead of special-casing it within this handler?  I realize that means we have to pass something through to allow the acceptor to track \"execution context\" for a waiter invocation (so that it can keep count), but that seems like a useful feature that better separates the responsibilities of this 'handler'.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458299463", "createdAt": "2020-07-21T18:21:05Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response\n+ */\n+@SdkInternalApi\n+@NotThreadSafe\n+public final class AsyncWaiterHandler<T> {\n+    private static final Logger log = Logger.loggerFor(AsyncWaiterHandler.class);\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final WaiterHandlerHelper<T> handlerHelper;\n+    private int attemptNumber = 0;\n+\n+    public AsyncWaiterHandler(PollingStrategy pollingStrategy,\n+                              List<WaiterAcceptor<T>> waiterAcceptors,\n+                              ScheduledExecutorService executorService) {\n+        this.pollingStrategy = Validate.paramNotNull(pollingStrategy, \"pollingStrategy\");\n+        Validate.paramNotNull(waiterAcceptors, \"waiterAcceptors\");\n+        this.executorService = Validate.paramNotNull(executorService, \"executorService\");\n+        this.handlerHelper = new WaiterHandlerHelper<>(waiterAcceptors, pollingStrategy);\n+    }\n+\n+    /**\n+     * Execute the provided async polling function\n+     */\n+    CompletableFuture<WaiterResponse<T>> execute(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        log.info(() -> \"starting to execute\");\n+        CompletableFuture<WaiterResponse<T>> future = new CompletableFuture<>();\n+        doExecute(asyncPollingFunction, future);\n+        return future;\n+    }\n+\n+    private void doExecute(Supplier<CompletableFuture<T>> asyncPollingFunction, CompletableFuture<WaiterResponse<T>> future) {\n+        ++attemptNumber;\n+        log.info(() -> \"runOnce\" + attemptNumber);\n+        runAsyncPollingFunction(asyncPollingFunction, future);\n+    }\n+\n+    private void runAsyncPollingFunction(Supplier<CompletableFuture<T>> asyncPollingFunction,\n+                                         CompletableFuture<WaiterResponse<T>> future) {\n+        asyncPollingFunction.get().whenComplete((response, exception) -> {\n+            Optional<WaiterState> waiterState = handlerHelper.nextWaiterStateIfMatched(response, exception);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMTU5MA==", "bodyText": "Should we differentiate between a Waiter and an AsyncWaiter? It seems weird that someone that only wants the synchronous run(...) method can (should?) configure an executor service.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458301590", "createdAt": "2020-07-21T18:24:54Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/DefaultWaiter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.annotations.ThreadSafe;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.Waiter;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Default implementation of the generic {@link Waiter}.\n+ * @param <T> the type of the response expected to return from the polling function\n+ */\n+@SdkInternalApi\n+@ThreadSafe\n+public final class DefaultWaiter<T> implements Waiter<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMTk4Ng==", "bodyText": "What handles the \"scheduleExecutorService is null\" case? When runAsync is invoked?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458301986", "createdAt": "2020-07-21T18:25:35Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/DefaultWaiter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.annotations.ThreadSafe;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.Waiter;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Default implementation of the generic {@link Waiter}.\n+ * @param <T> the type of the response expected to return from the polling function\n+ */\n+@SdkInternalApi\n+@ThreadSafe\n+public final class DefaultWaiter<T> implements Waiter<T> {\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final List<WaiterAcceptor<T>> waiterAcceptors;\n+\n+    private DefaultWaiter(DefaultBuilder<T> builder) {\n+        this.executorService = builder.scheduledExecutorService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMjE3Mg==", "bodyText": "Copy?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458302172", "createdAt": "2020-07-21T18:25:54Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/DefaultWaiter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.annotations.ThreadSafe;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.Waiter;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Default implementation of the generic {@link Waiter}.\n+ * @param <T> the type of the response expected to return from the polling function\n+ */\n+@SdkInternalApi\n+@ThreadSafe\n+public final class DefaultWaiter<T> implements Waiter<T> {\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final List<WaiterAcceptor<T>> waiterAcceptors;\n+\n+    private DefaultWaiter(DefaultBuilder<T> builder) {\n+        this.executorService = builder.scheduledExecutorService;\n+        this.pollingStrategy = Validate.paramNotNull(builder.pollingStrategy, \"pollingStrategy\");\n+        this.waiterAcceptors = Collections.unmodifiableList(new ArrayList<>(builder.waiterAcceptors));\n+    }\n+\n+    @Override\n+    public CompletableFuture<WaiterResponse<T>> runAsync(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        AsyncWaiterHandler<T> handler = new AsyncWaiterHandler<>(pollingStrategy, waiterAcceptors, executorService);\n+        return handler.execute(asyncPollingFunction);\n+    }\n+\n+    @Override\n+    public WaiterResponse<T> run(Supplier<T> pollingFunction) {\n+        WaiterHandler<T> handler = new WaiterHandler<>(pollingStrategy, waiterAcceptors);\n+        return handler.execute(pollingFunction);\n+    }\n+\n+    public static <T> Builder<T> builder() {\n+        return new DefaultBuilder<>();\n+    }\n+\n+    public static final class DefaultBuilder<T> implements Builder<T> {\n+        private List<WaiterAcceptor<T>> waiterAcceptors = new ArrayList<>();\n+        private ScheduledExecutorService scheduledExecutorService;\n+        private PollingStrategy pollingStrategy;\n+\n+        private DefaultBuilder() {\n+        }\n+\n+        @Override\n+        public Builder<T> scheduledExecutorService(ScheduledExecutorService scheduledExecutorService) {\n+            this.scheduledExecutorService = scheduledExecutorService;\n+            return this;\n+        }\n+\n+        @Override\n+        public Builder<T> acceptors(List<WaiterAcceptor<T>> waiterAcceptors) {\n+            this.waiterAcceptors = waiterAcceptors;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwNTkyOQ==", "bodyText": "\"handler helper\". Helps the handler? Seems very generic. Is this just for code sharing between the async and sync code paths?\nIf so, is there any way we could use a strategy pattern here, where this is a parent class that handles the core logic, but it delegates to the children to do it synchronously or asynchronously?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458305929", "createdAt": "2020-07-21T18:32:28Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/WaiterHandlerHelper.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.retry.RetryPolicyContext;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+\n+/**\n+ * The waiter handler helper class\n+ */\n+@SdkInternalApi\n+public final class WaiterHandlerHelper<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwNjc3MA==", "bodyText": "ternary might read simpler.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458306770", "createdAt": "2020-07-21T18:33:59Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/WaiterHandlerHelper.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.retry.RetryPolicyContext;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+\n+/**\n+ * The waiter handler helper class\n+ */\n+@SdkInternalApi\n+public final class WaiterHandlerHelper<T> {\n+    private final List<WaiterAcceptor<T>> waiterAcceptors;\n+    private final PollingStrategy pollingStrategy;\n+\n+    public WaiterHandlerHelper(List<WaiterAcceptor<T>> waiterAcceptors, PollingStrategy pollingStrategy) {\n+        this.waiterAcceptors = waiterAcceptors;\n+        this.pollingStrategy = pollingStrategy;\n+    }\n+\n+    /**\n+     * A convenience method to create a {@link WaiterResponse} with either a response or an exception\n+     *\n+     * @param response nullable response\n+     * @param exception nullable exception\n+     * @return a {@link WaiterResponse}\n+     */\n+    public WaiterResponse<T> createWaiterResponse(T response, Throwable exception, int attempts) {\n+        WaiterResponse<T> waiterResponse;\n+        if (exception != null) {\n+            waiterResponse = DefaultWaiterResponse.<T>builder().exception(exception).attemptsExecuted(attempts).build();\n+        } else {\n+            waiterResponse = DefaultWaiterResponse.<T>builder().response(response).attemptsExecuted(attempts).build();\n+        }\n+        return waiterResponse;\n+    }\n+\n+    /**\n+     * Iterates over the acceptors list and returns the {@link WaiterState} of the the first acceptor to match the\n+     * result of the operation if present or empty otherwise.\n+     *\n+     * @param response nullable response to match\n+     * @param exception nullable exception to match\n+     * @return the optional {@link WaiterState}\n+     */\n+    public Optional<WaiterState> nextWaiterStateIfMatched(T response, Throwable exception) {\n+        Optional<WaiterState> waiterState;\n+        if (exception != null) {\n+            waiterState = exceptionMatches(exception);\n+        } else {\n+            waiterState = responseMatches(response);\n+        }\n+        return waiterState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwOTQ3MA==", "bodyText": "I feel like a lot of customers would want \"maxWaitTime\" as a configuration more than maxAttempts. I realize the max wait time can be indirectly managed via the maxAttempts, backoffStrategy and client configuration, but it's not easy to do. It would be nice if we did it for them, and we can use the request-level max-execution-time and some checks before sleeping/delegating to the scheduled executor service to do so fairly easily.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458309470", "createdAt": "2020-07-21T18:38:43Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/PollingStrategy.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.core.retry.backoff.BackoffStrategy;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Define the polling strategy for a {@link Waiter} to poll the resource\n+ */\n+@SdkPublicApi\n+public final class PollingStrategy {\n+\n+    private final int maxAttempts;\n+    private final BackoffStrategy backoffStrategy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMDIxMw==", "bodyText": "Again, \"only required during creation, if you invoke this method during usage\" feels like a gross invariant. Wouldn't it be better to encode that into the type? (AsyncWaiter versus Waiter)", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458310213", "createdAt": "2020-07-21T18:39:56Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/Waiter.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.core.internal.waiters.DefaultWaiter;\n+\n+/**\n+ * Waiter utility class that waits for a resource to transition to the desired state.\n+ *\n+ * @param <T> the type of the resource returned from the polling function\n+ */\n+@SdkPublicApi\n+public interface Waiter<T> {\n+\n+    /**\n+     * Runs the provided polling function. It completes when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param asyncPollingFunction the polling function to trigger\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    CompletableFuture<WaiterResponse<T>> runAsync(Supplier<CompletableFuture<T>> asyncPollingFunction);\n+\n+    /**\n+     * It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param pollingFunction Represents the input of a <code>DescribeTable</code> operation.\n+     * @return the response\n+     */\n+    WaiterResponse<T> run(Supplier<T> pollingFunction);\n+\n+    /**\n+     * Creates a newly initialized builder for the waiter object.\n+     *\n+     * @param responseClass the response class\n+     * @param <T> the type of the response\n+     * @return a Waiter builder\n+     */\n+    static <T> Builder<T> builder(Class<? extends T> responseClass) {\n+        return DefaultWaiter.builder();\n+    }\n+\n+    /**\n+     * The Waiter Builder\n+     * @param <T> the type of the resource\n+     */\n+    interface Builder<T> {\n+        /**\n+         * Defines a list of {@link WaiterAcceptor}s to check whether an expected state has met after executing an operation.\n+         *\n+         * <p>\n+         * The SDK will iterate over the acceptors list and the first acceptor to match the result of the operation transitions\n+         * the waiter to the state specified in the acceptor.\n+         *\n+         * <p>\n+         * This completely overrides any WaiterAcceptor currently configured in the builder via\n+         * {@link #addAcceptor(WaiterAcceptor)}\n+         *\n+         * @param waiterAcceptors the waiter acceptors\n+         * @return a reference to this object so that method calls can be chained together.\n+         */\n+        Builder<T> acceptors(List<WaiterAcceptor<T>> waiterAcceptors);\n+\n+        /**\n+         * Adds a {@link WaiterAcceptor} to the end of the ordered waiterAcceptors list.\n+         *\n+         * <p>\n+         * The SDK will iterate over the acceptors list and the first acceptor to match the result of the operation transitions\n+         * the waiter to the state specified in the acceptor.\n+         *\n+         * @param waiterAcceptors the waiter acceptors\n+         * @return a reference to this object so that method calls can be chained together.\n+         */\n+        Builder<T> addAcceptor(WaiterAcceptor<T> waiterAcceptors);\n+\n+        /**\n+         * Defines a {@link PollingStrategy} to use when polling a resource\n+         *\n+         * @param pollingStrategy the polling strategy to use\n+         * @return a reference to this object so that method calls can be chained together.\n+         */\n+        Builder<T> pollingStrategy(PollingStrategy pollingStrategy);\n+\n+        /**\n+         * Defines a {@link PollingStrategy} to use when polling a resource\n+         *\n+         * @param pollingStrategy the polling strategy to use\n+         * @return a reference to this object so that method calls can be chained together.\n+         */\n+        default Builder<T> pollingStrategy(Consumer<PollingStrategy.Builder> pollingStrategy) {\n+            PollingStrategy.Builder builder = PollingStrategy.builder();\n+            pollingStrategy.accept(builder);\n+            return pollingStrategy(builder.build());\n+        }\n+\n+        /**\n+         * Defines the {@link ScheduledExecutorService} used to schedule async polling attempts\n+         * Only required if you are calling {@link Waiter#runAsync(Supplier)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMTAzNg==", "bodyText": "What about retryOnResponseAcceptor?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458311036", "createdAt": "2020-07-21T18:41:22Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaiterAcceptor.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import java.util.function.Predicate;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+\n+/**\n+ * Inspects the response or errors returned from the operation and determines whether an expected state is met and returns the\n+ * next {@link WaiterState} that the waiter should be transitioned to.\n+ */\n+@SdkPublicApi\n+public interface WaiterAcceptor<T> {\n+\n+    /**\n+     * @return the next {@link WaiterState} that the waiter should be transitioned to\n+     */\n+    WaiterState waiterState();\n+\n+    /**\n+     * Check to see if the response matches with the expected state defined by this acceptor\n+     *\n+     * @param response the response to inspect\n+     * @return whether it accepts the response\n+     */\n+    default boolean matches(T response) {\n+        return false;\n+    }\n+\n+    /**\n+     * Check to see if the exception matches the expected state defined by this acceptor\n+     *\n+     * @param throwable the exception to inspect\n+     * @return whether it accepts the throwable\n+     */\n+    default boolean matches(Throwable throwable) {\n+        return false;\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param responsePredicate the predicate of the response\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> successOnResponseAcceptor(Predicate<T> responsePredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.SUCCESS;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates an error waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param errorPredicate the {@link Throwable} predicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> successOnExceptionAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.SUCCESS;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates an error waiter acceptor which determines if the exception should transition the waiter to failure state\n+     *\n+     * @param errorPredicate the {@link Throwable} predicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorOnExceptionAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param responsePredicate the predicate of the response\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorOnResponseAcceptor(Predicate<T> responsePredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a retry on exception waiter acceptor which determines if the exception should transition the waiter to retry state\n+     *\n+     * @param errorPredicate the {@link Throwable} predicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> retryOnExceptionAcceptor(Predicate<Throwable> errorPredicate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMTcwNA==", "bodyText": "Should we use an Either type here? Or something that is more explicitly a union type?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458311704", "createdAt": "2020-07-21T18:42:33Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaiterResponse.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import java.util.Optional;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+\n+/**\n+ * The response returned from a waiter operation\n+ * @param <T> the type of the response\n+ */\n+@SdkPublicApi\n+public interface WaiterResponse<T> {\n+\n+    /**\n+     * @return the optional response received that has matched with the waiter success condition\n+     */\n+    Optional<T> response();\n+\n+    /**\n+     * @return the optional exception thrown from the waiter operation that has matched with the waiter success condition\n+     */\n+    Optional<Throwable> exception();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDA1MzYz", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#pullrequestreview-454405363", "createdAt": "2020-07-23T18:47:52Z", "commit": {"oid": "fc6d8973f030436054ae63144bc336b824221a7c"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NjkxMzY2", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#pullrequestreview-475691366", "createdAt": "2020-08-26T17:08:33Z", "commit": {"oid": "feb25a88ddd844f1de5007eeace9266ecc8914c3"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNzowODozM1rOHHVnig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNzoxNDozMlrOHHV1ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ1NjI2Ng==", "bodyText": "Validate the message is not-null so that it doesn't fail slow? Or use Optional.ofNullable.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r477456266", "createdAt": "2020-08-26T17:08:33Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaiterAcceptor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+\n+/**\n+ * Inspects the response or errors returned from the operation and determines whether an expected state is met and returns the\n+ * next {@link WaiterState} that the waiter should be transitioned to.\n+ */\n+@SdkPublicApi\n+public interface WaiterAcceptor<T> {\n+\n+    /**\n+     * @return the next {@link WaiterState} that the waiter should be transitioned to\n+     */\n+    WaiterState waiterState();\n+\n+    /**\n+     * Check to see if the response matches with the expected state defined by this acceptor\n+     *\n+     * @param response the response to inspect\n+     * @return whether it accepts the response\n+     */\n+    default boolean matches(T response) {\n+        return false;\n+    }\n+\n+    /**\n+     * Check to see if the exception matches the expected state defined by this acceptor\n+     *\n+     * @param throwable the exception to inspect\n+     * @return whether it accepts the throwable\n+     */\n+    default boolean matches(Throwable throwable) {\n+        return false;\n+    }\n+\n+    /**\n+     * Optional message to provide pertaining to the next WaiterState\n+     *\n+     * @return the optional message\n+     */\n+    default Optional<String> message() {\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param responsePredicate the predicate of the response\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> successOnResponseAcceptor(Predicate<T> responsePredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.SUCCESS;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates an error waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param errorPredicate the {@link Throwable} predicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> successOnExceptionAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.SUCCESS;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates an error waiter acceptor which determines if the exception should transition the waiter to failure state\n+     *\n+     * @param errorPredicate the {@link Throwable} predicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorOnExceptionAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param responsePredicate the predicate of the response\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorOnResponseAcceptor(Predicate<T> responsePredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param responsePredicate the predicate of the response\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorOnResponseAcceptor(Predicate<T> responsePredicate, String message) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+\n+            @Override\n+            public Optional<String> message() {\n+                return Optional.of(message);\n+            }\n+        };\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "feb25a88ddd844f1de5007eeace9266ecc8914c3"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ1OTg5OA==", "bodyText": "Do we have a naming convention established that differentiates between a Strategy (e.g. PollingStrategy) or Policy (e.g. RetryPolicy)?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r477459898", "createdAt": "2020-08-26T17:14:32Z", "author": {"login": "millems"}, "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaiterBuilder.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+\n+@SdkPublicApi\n+public interface WaiterBuilder<T, B> {\n+    /**\n+     * Defines a list of {@link WaiterAcceptor}s to check whether an expected state has met after executing an operation.\n+     *\n+     * <p>\n+     * The SDK will iterate over the acceptors list and the first acceptor to match the result of the operation transitions\n+     * the waiter to the state specified in the acceptor.\n+     *\n+     * <p>\n+     * This completely overrides any WaiterAcceptor currently configured in the builder via\n+     * {@link #addAcceptor(WaiterAcceptor)}\n+     *\n+     * @param waiterAcceptors the waiter acceptors\n+     * @return a reference to this object so that method calls can be chained together.\n+     */\n+    B acceptors(List<WaiterAcceptor<T>> waiterAcceptors);\n+\n+    /**\n+     * Adds a {@link WaiterAcceptor} to the end of the ordered waiterAcceptors list.\n+     *\n+     * <p>\n+     * The SDK will iterate over the acceptors list and the first acceptor to match the result of the operation transitions\n+     * the waiter to the state specified in the acceptor.\n+     *\n+     * @param waiterAcceptors the waiter acceptors\n+     * @return a reference to this object so that method calls can be chained together.\n+     */\n+    B addAcceptor(WaiterAcceptor<T> waiterAcceptors);\n+\n+    /**\n+     * Defines a {@link PollingStrategy} to use when polling a resource\n+     *\n+     * @param pollingStrategy the polling strategy to use\n+     * @return a reference to this object so that method calls can be chained together.\n+     */\n+    B pollingStrategy(PollingStrategy pollingStrategy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "feb25a88ddd844f1de5007eeace9266ecc8914c3"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1ODgyMjM5", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#pullrequestreview-475882239", "createdAt": "2020-08-26T21:46:51Z", "commit": {"oid": "85aeb7bf2099aa5a8a1e13f7291d297cb087a6ad"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e29ddcacb8cc19ba344f91cb997607de6ef416c9", "author": {"user": {"login": "zoewangg", "name": "Zoe Wang"}}, "url": "https://github.com/aws/aws-sdk-java-v2/commit/e29ddcacb8cc19ba344f91cb997607de6ef416c9", "committedDate": "2020-08-26T21:50:19Z", "message": "Implement generic Waiter functionality"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85aeb7bf2099aa5a8a1e13f7291d297cb087a6ad", "author": {"user": {"login": "zoewangg", "name": "Zoe Wang"}}, "url": "https://github.com/aws/aws-sdk-java-v2/commit/85aeb7bf2099aa5a8a1e13f7291d297cb087a6ad", "committedDate": "2020-08-26T20:43:45Z", "message": "address comments"}, "afterCommit": {"oid": "e29ddcacb8cc19ba344f91cb997607de6ef416c9", "author": {"user": {"login": "zoewangg", "name": "Zoe Wang"}}, "url": "https://github.com/aws/aws-sdk-java-v2/commit/e29ddcacb8cc19ba344f91cb997607de6ef416c9", "committedDate": "2020-08-26T21:50:19Z", "message": "Implement generic Waiter functionality"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2417, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}