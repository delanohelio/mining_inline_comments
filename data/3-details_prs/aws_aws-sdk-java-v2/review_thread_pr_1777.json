{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyODQ5ODQ5", "number": 1777, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjozOToyNlrODz9CtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowOTo1M1rOEDDOUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODA0MDg1OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjozOToyNlrOGIqjWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjozOToyNlrOGIqjWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczODk2OA==", "bodyText": "nit, we have Content-Length in https://github.com/aws/aws-sdk-java-v2/blob/master/http-client-spi/src/main/java/software/amazon/awssdk/http/Header.java\nCan we add all the common headers to Header class?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411738968", "createdAt": "2020-04-20T22:39:26Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODA1MzA2OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjo0MzoxN1rOGIqp4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMTozNDowNVrOGOR3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0MDY0Mw==", "bodyText": "This can be confused with h2 intialWindowSize.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411740643", "createdAt": "2020-04-20T22:43:17Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYyNTkwOA==", "bodyText": "I'm updating the comment here to better reflect this setting, which actually corresponds to what's described for h1, but will correspond to h2 initialWindowSize for h2 connections.  It's not clear what changes will need to be made to fold h2 into the crt client, so for now I'd prefer to leave this be and readdress it (two params? one param with additional per-version comments?) as h2 gets brought in.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r417625908", "createdAt": "2020-04-29T21:34:05Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0MDY0Mw=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 348}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODExNDUwOnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowNDowNFrOGIrMIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzowNDowNFrOGIrMIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0OTQxMA==", "bodyText": "Can we break up this block a bit?\nMaybe extracting line 108 - line 128 to resolveProxyOptions?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411749410", "createdAt": "2020-04-20T23:04:04Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODEzMzg5OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzoxMTowNlrOGIrW9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMTo0OTo0M1rOGOSUHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MjE4MQ==", "bodyText": "errorCode -> statusCode?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411752181", "createdAt": "2020-04-20T23:11:06Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;\n+    }\n+\n+    @Override\n+    public void onResponseComplete(HttpStream stream, int errorCode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzMzMwOQ==", "bodyText": "In this case it's not a status code, it's an internal error integer from C-land.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r417633309", "createdAt": "2020-04-29T21:49:43Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;\n+    }\n+\n+    @Override\n+    public void onResponseComplete(HttpStream stream, int errorCode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MjE4MQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODEzNzMxOnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzoxMjozMFrOGIrY7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMDoxMjoxMlrOGO4o4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MjY4Nw==", "bodyText": "Should we do a try-catch here in case exceptions are thrown from the error response handler?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411752687", "createdAt": "2020-04-20T23:12:30Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;\n+    }\n+\n+    @Override\n+    public void onResponseComplete(HttpStream stream, int errorCode) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n+            log.debug(() -> \"Response Completed Successfully\");\n+            respBodyPublisher.setQueueComplete();\n+            respBodyPublisher.publishToSubscribers();\n+        } else {\n+            HttpException error = new HttpException(errorCode);\n+            log.error(() -> \"Response Encountered an Error.\", error);\n+\n+            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n+            sdkRequest.responseHandler().onError(error);\n+\n+            // Invoke Error Callback on any Subscriber's of the Response Body\n+            respBodyPublisher.setError(error);\n+            respBodyPublisher.publishToSubscribers();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNDUwNA==", "bodyText": "Makes sense but I'm not sure what scope it should cover and if it should do anything in the catch?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r417634504", "createdAt": "2020-04-29T21:52:12Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;\n+    }\n+\n+    @Override\n+    public void onResponseComplete(HttpStream stream, int errorCode) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n+            log.debug(() -> \"Response Completed Successfully\");\n+            respBodyPublisher.setQueueComplete();\n+            respBodyPublisher.publishToSubscribers();\n+        } else {\n+            HttpException error = new HttpException(errorCode);\n+            log.error(() -> \"Response Encountered an Error.\", error);\n+\n+            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n+            sdkRequest.responseHandler().onError(error);\n+\n+            // Invoke Error Callback on any Subscriber's of the Response Body\n+            respBodyPublisher.setError(error);\n+            respBodyPublisher.publishToSubscribers();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MjY4Nw=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2MTIxOA==", "bodyText": "In Netty client, we always log the error and complete the future exceptionally for such case. https://github.com/aws/aws-sdk-java-v2/blob/master/http-clients/netty-nio-client/src/main/java/software/amazon/awssdk/http/nio/netty/internal/ResponseHandler.java#L302-L307", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r418261218", "createdAt": "2020-04-30T20:12:12Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;\n+    }\n+\n+    @Override\n+    public void onResponseComplete(HttpStream stream, int errorCode) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (errorCode == CRT.AWS_CRT_SUCCESS) {\n+            log.debug(() -> \"Response Completed Successfully\");\n+            respBodyPublisher.setQueueComplete();\n+            respBodyPublisher.publishToSubscribers();\n+        } else {\n+            HttpException error = new HttpException(errorCode);\n+            log.error(() -> \"Response Encountered an Error.\", error);\n+\n+            // Invoke Error Callback on SdkAsyncHttpResponseHandler\n+            sdkRequest.responseHandler().onError(error);\n+\n+            // Invoke Error Callback on any Subscriber's of the Response Body\n+            respBodyPublisher.setError(error);\n+            respBodyPublisher.publishToSubscribers();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MjY4Nw=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODIzNDg4OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzo0NDozOVrOGIsPuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzo0NDozOVrOGIsPuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2NjcxNQ==", "bodyText": "How about registerOwnedResource?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411766715", "createdAt": "2020-04-20T23:44:39Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODI0MTMzOnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzo0Njo1N1rOGIsTTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzo0Njo1N1rOGIsTTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2NzYyOQ==", "bodyText": "Don't think this is necessary as uri is already validated on line 195", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411767629", "createdAt": "2020-04-20T23:46:57Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODMyNjYwOnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoyMDoyM1rOGItBxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDoyMDoyM1rOGItBxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3OTUyNA==", "bodyText": "This is confusing to me. From reading the code of HttpClientConnectionManager#close, it seems what close really does is to decrement the reference instead of closing the pool. Can we add a comment above to clarify that? because when I first read this, I thought it would close the connection pool for every request.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r411779524", "createdAt": "2020-04-21T00:20:23Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjMzMzE2OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODowMjoyMFrOGJRX3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjowMDo1NFrOGgKXGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NTAwNQ==", "bodyText": "Are there any plans to expose http configs supported in other http clients such as connectionMaxIdleTime or connectionTimeout?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412375005", "createdAt": "2020-04-21T18:02:20Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);\n+\n+        /**\n+         * The AWS CRT EventLoopGroup to use for this Client.\n+         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n+\n+        /**\n+         * The AWS CRT HostResolver to use for this Client.\n+         * @param hostResolver The AWS CRT HostResolver to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder hostResolver(HostResolver hostResolver);\n+\n+        /**\n+         * Sets the http proxy configuration to use for this client.\n+         * @param proxyConfiguration The http proxy configuration to use\n+         * @return The builder of the method chaining.\n+         */\n+        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n+    }\n+\n+    /**\n+     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n+     * configure and construct an immutable instance of the factory.\n+     */\n+    private static final class DefaultBuilder implements Builder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzODcyMw==", "bodyText": "Yes, but I don't think we're ready yet.  Our http connection monitoring is a bit different than existing timeouts.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r417638723", "createdAt": "2020-04-29T22:01:30Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);\n+\n+        /**\n+         * The AWS CRT EventLoopGroup to use for this Client.\n+         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n+\n+        /**\n+         * The AWS CRT HostResolver to use for this Client.\n+         * @param hostResolver The AWS CRT HostResolver to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder hostResolver(HostResolver hostResolver);\n+\n+        /**\n+         * Sets the http proxy configuration to use for this client.\n+         * @param proxyConfiguration The http proxy configuration to use\n+         * @return The builder of the method chaining.\n+         */\n+        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n+    }\n+\n+    /**\n+     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n+     * configure and construct an immutable instance of the factory.\n+     */\n+    private static final class DefaultBuilder implements Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NTAwNQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3NzM2OQ==", "bodyText": "Monitoring configuration has been merged in.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436377369", "createdAt": "2020-06-07T16:00:54Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);\n+\n+        /**\n+         * The AWS CRT EventLoopGroup to use for this Client.\n+         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n+\n+        /**\n+         * The AWS CRT HostResolver to use for this Client.\n+         * @param hostResolver The AWS CRT HostResolver to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder hostResolver(HostResolver hostResolver);\n+\n+        /**\n+         * Sets the http proxy configuration to use for this client.\n+         * @param proxyConfiguration The http proxy configuration to use\n+         * @return The builder of the method chaining.\n+         */\n+        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);\n+    }\n+\n+    /**\n+     * Factory that allows more advanced configuration of the AWS CRT HTTP implementation. Use {@link #builder()} to\n+     * configure and construct an immutable instance of the factory.\n+     */\n+    private static final class DefaultBuilder implements Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NTAwNQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 376}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjM0NDkzOnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODowNTowM1rOGJRfDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODowNTowM1rOGJRfDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3Njg0Ng==", "bodyText": "Seems like configuring maxConnection is supported; should we expose maxConnection here?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412376846", "createdAt": "2020-04-21T18:05:03Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);\n+\n+        /**\n+         * The AWS CRT EventLoopGroup to use for this Client.\n+         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n+\n+        /**\n+         * The AWS CRT HostResolver to use for this Client.\n+         * @param hostResolver The AWS CRT HostResolver to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder hostResolver(HostResolver hostResolver);\n+\n+        /**\n+         * Sets the http proxy configuration to use for this client.\n+         * @param proxyConfiguration The http proxy configuration to use\n+         * @return The builder of the method chaining.\n+         */\n+        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjM5ODM3OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODoxNjo0MlrOGJR-mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODoxNjo0MlrOGJR-mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4NDkyMw==", "bodyText": "Should we try-catch here in case onError throws the exception, resulting in an uncompletable future?\nWe can have something similar to https://github.com/aws/aws-sdk-java-v2/blob/master/http-clients/netty-nio-client/src/main/java/software/amazon/awssdk/http/nio/netty/internal/ResponseHandler.java#L177", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412384923", "createdAt": "2020-04-21T18:16:42Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjYyNDIxOnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTowODoxOVrOGJUEYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTowODoxOVrOGJUEYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQxOTE3MA==", "bodyText": "nit:\nHow about the following?\n            connectionPools.values().forEach(pool -> IoUtils.closeQuietly(pool, log.logger()));\n            ownedSubResources.forEach(r -> IoUtils.closeQuietly(r, log.logger()));", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412419170", "createdAt": "2020-04-21T19:08:19Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 314}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzA2MzA0OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDo1NjowM1rOGJYGcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDo1NjowM1rOGJYGcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4NTIzMw==", "bodyText": "nit: Validate.notNull actually returns the value, so we can do:\nthis.connection = Validate.notNull(connection, \"HttpConnection must not be null\");", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412485233", "createdAt": "2020-04-21T20:56:03Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.LongUnaryOperator;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Adapts an AWS Common Runtime Response Body stream from CrtHttpStreamHandler to a Publisher<ByteBuffer>\n+ */\n+@SdkInternalApi\n+public class AwsCrtResponseBodyPublisher implements Publisher<ByteBuffer> {\n+    private static final Logger log = Logger.loggerFor(AwsCrtResponseBodyPublisher.class);\n+    private static final LongUnaryOperator DECREMENT_IF_GREATER_THAN_ZERO = x -> ((x > 0) ? (x - 1) : (x));\n+\n+    private final HttpClientConnection connection;\n+    private final HttpStream stream;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AtomicLong outstandingRequests = new AtomicLong(0);\n+    private final int windowSize;\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+    private final AtomicBoolean areNativeResourcesReleased = new AtomicBoolean(false);\n+    private final AtomicBoolean isSubscriptionComplete = new AtomicBoolean(false);\n+    private final AtomicBoolean queueComplete = new AtomicBoolean(false);\n+    private final AtomicInteger mutualRecursionDepth = new AtomicInteger(0);\n+    private final AtomicInteger queuedBytes = new AtomicInteger(0);\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> subscriberRef = new AtomicReference<>(null);\n+    private final Queue<byte[]> queuedBuffers = new ConcurrentLinkedQueue<>();\n+    private final AtomicReference<Throwable> error = new AtomicReference<>(null);\n+\n+    /**\n+     * Adapts a streaming AWS CRT Http Response Body to a Publisher<ByteBuffer>\n+     * @param stream The AWS CRT Http Stream for this Response\n+     * @param windowSize The max allowed bytes to be queued. The sum of the sizes of all queued ByteBuffers should\n+     *                   never exceed this value.\n+     */\n+    public AwsCrtResponseBodyPublisher(HttpClientConnection connection, HttpStream stream,\n+                                       CompletableFuture<Void> responseComplete, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection must not be null\");\n+        Validate.notNull(stream, \"Stream must not be null\");\n+        Validate.notNull(responseComplete, \"Stream must not be null\");\n+        Validate.isPositive(windowSize, \"windowSize must be > 0\");\n+        this.connection = connection;\n+        this.stream = stream;\n+        this.responseComplete = responseComplete;\n+        this.windowSize = windowSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzM4NTQ0OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjoyMTowN1rOGJa7SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDoyMzoxNVrOGQ6JIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzMTUyOA==", "bodyText": "Seems like AwsCrtResponseBodySubscription and AwsCrtResponseBodyPublisher have circular dependency. Can we move the publisher methods that subscription class invokes to the subscription class?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412531528", "createdAt": "2020-04-21T22:21:07Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.LongUnaryOperator;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Adapts an AWS Common Runtime Response Body stream from CrtHttpStreamHandler to a Publisher<ByteBuffer>\n+ */\n+@SdkInternalApi\n+public class AwsCrtResponseBodyPublisher implements Publisher<ByteBuffer> {\n+    private static final Logger log = Logger.loggerFor(AwsCrtResponseBodyPublisher.class);\n+    private static final LongUnaryOperator DECREMENT_IF_GREATER_THAN_ZERO = x -> ((x > 0) ? (x - 1) : (x));\n+\n+    private final HttpClientConnection connection;\n+    private final HttpStream stream;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AtomicLong outstandingRequests = new AtomicLong(0);\n+    private final int windowSize;\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+    private final AtomicBoolean areNativeResourcesReleased = new AtomicBoolean(false);\n+    private final AtomicBoolean isSubscriptionComplete = new AtomicBoolean(false);\n+    private final AtomicBoolean queueComplete = new AtomicBoolean(false);\n+    private final AtomicInteger mutualRecursionDepth = new AtomicInteger(0);\n+    private final AtomicInteger queuedBytes = new AtomicInteger(0);\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> subscriberRef = new AtomicReference<>(null);\n+    private final Queue<byte[]> queuedBuffers = new ConcurrentLinkedQueue<>();\n+    private final AtomicReference<Throwable> error = new AtomicReference<>(null);\n+\n+    /**\n+     * Adapts a streaming AWS CRT Http Response Body to a Publisher<ByteBuffer>\n+     * @param stream The AWS CRT Http Stream for this Response\n+     * @param windowSize The max allowed bytes to be queued. The sum of the sizes of all queued ByteBuffers should\n+     *                   never exceed this value.\n+     */\n+    public AwsCrtResponseBodyPublisher(HttpClientConnection connection, HttpStream stream,\n+                                       CompletableFuture<Void> responseComplete, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection must not be null\");\n+        Validate.notNull(stream, \"Stream must not be null\");\n+        Validate.notNull(responseComplete, \"Stream must not be null\");\n+        Validate.isPositive(windowSize, \"windowSize must be > 0\");\n+        this.connection = connection;\n+        this.stream = stream;\n+        this.responseComplete = responseComplete;\n+        this.windowSize = windowSize;\n+    }\n+\n+    /**\n+     * Method for the users consuming the Http Response Body to register a subscriber.\n+     * @param subscriber The Subscriber to register.\n+     */\n+    @Override\n+    public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n+        Validate.notNull(subscriber, \"Subscriber must not be null\");\n+\n+        boolean wasFirstSubscriber = subscriberRef.compareAndSet(null, subscriber);\n+\n+        if (!wasFirstSubscriber) {\n+            log.error(() -> \"Only one subscriber allowed\");\n+\n+            // onSubscribe must be called first before onError gets called, so give it a do-nothing Subscription\n+            subscriber.onSubscribe(new Subscription() {\n+                @Override\n+                public void request(long n) {\n+                    // This is a dummy implementation to allow the onError call\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    // This is a dummy implementation to allow the onError call\n+                }\n+            });\n+            subscriber.onError(new IllegalStateException(\"Only one subscriber allowed\"));\n+        } else {\n+            subscriber.onSubscribe(new AwsCrtResponseBodySubscription(this));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMyMTcxMA==", "bodyText": "I don't quite follow the change here.  moving request() and publishToSubscribers() and their downstreams would be a really big refactor.  What about folding the logic of Subscription's request() into a single method on the publisher (rather than call 4 methods on the publisher)?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420321710", "createdAt": "2020-05-05T18:32:28Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.LongUnaryOperator;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Adapts an AWS Common Runtime Response Body stream from CrtHttpStreamHandler to a Publisher<ByteBuffer>\n+ */\n+@SdkInternalApi\n+public class AwsCrtResponseBodyPublisher implements Publisher<ByteBuffer> {\n+    private static final Logger log = Logger.loggerFor(AwsCrtResponseBodyPublisher.class);\n+    private static final LongUnaryOperator DECREMENT_IF_GREATER_THAN_ZERO = x -> ((x > 0) ? (x - 1) : (x));\n+\n+    private final HttpClientConnection connection;\n+    private final HttpStream stream;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AtomicLong outstandingRequests = new AtomicLong(0);\n+    private final int windowSize;\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+    private final AtomicBoolean areNativeResourcesReleased = new AtomicBoolean(false);\n+    private final AtomicBoolean isSubscriptionComplete = new AtomicBoolean(false);\n+    private final AtomicBoolean queueComplete = new AtomicBoolean(false);\n+    private final AtomicInteger mutualRecursionDepth = new AtomicInteger(0);\n+    private final AtomicInteger queuedBytes = new AtomicInteger(0);\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> subscriberRef = new AtomicReference<>(null);\n+    private final Queue<byte[]> queuedBuffers = new ConcurrentLinkedQueue<>();\n+    private final AtomicReference<Throwable> error = new AtomicReference<>(null);\n+\n+    /**\n+     * Adapts a streaming AWS CRT Http Response Body to a Publisher<ByteBuffer>\n+     * @param stream The AWS CRT Http Stream for this Response\n+     * @param windowSize The max allowed bytes to be queued. The sum of the sizes of all queued ByteBuffers should\n+     *                   never exceed this value.\n+     */\n+    public AwsCrtResponseBodyPublisher(HttpClientConnection connection, HttpStream stream,\n+                                       CompletableFuture<Void> responseComplete, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection must not be null\");\n+        Validate.notNull(stream, \"Stream must not be null\");\n+        Validate.notNull(responseComplete, \"Stream must not be null\");\n+        Validate.isPositive(windowSize, \"windowSize must be > 0\");\n+        this.connection = connection;\n+        this.stream = stream;\n+        this.responseComplete = responseComplete;\n+        this.windowSize = windowSize;\n+    }\n+\n+    /**\n+     * Method for the users consuming the Http Response Body to register a subscriber.\n+     * @param subscriber The Subscriber to register.\n+     */\n+    @Override\n+    public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n+        Validate.notNull(subscriber, \"Subscriber must not be null\");\n+\n+        boolean wasFirstSubscriber = subscriberRef.compareAndSet(null, subscriber);\n+\n+        if (!wasFirstSubscriber) {\n+            log.error(() -> \"Only one subscriber allowed\");\n+\n+            // onSubscribe must be called first before onError gets called, so give it a do-nothing Subscription\n+            subscriber.onSubscribe(new Subscription() {\n+                @Override\n+                public void request(long n) {\n+                    // This is a dummy implementation to allow the onError call\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    // This is a dummy implementation to allow the onError call\n+                }\n+            });\n+            subscriber.onError(new IllegalStateException(\"Only one subscriber allowed\"));\n+        } else {\n+            subscriber.onSubscribe(new AwsCrtResponseBodySubscription(this));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzMTUyOA=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4MzAxMQ==", "bodyText": "Yeah, ideally I'd expect most of the logic to be in Subscription class rather than Publisher class. How about making AwsCrtResponseBodySubscription an internal class of AwsCrtResponseBodyPublisher? Seems cleaner that way to me.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420383011", "createdAt": "2020-05-05T20:23:15Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.LongUnaryOperator;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Adapts an AWS Common Runtime Response Body stream from CrtHttpStreamHandler to a Publisher<ByteBuffer>\n+ */\n+@SdkInternalApi\n+public class AwsCrtResponseBodyPublisher implements Publisher<ByteBuffer> {\n+    private static final Logger log = Logger.loggerFor(AwsCrtResponseBodyPublisher.class);\n+    private static final LongUnaryOperator DECREMENT_IF_GREATER_THAN_ZERO = x -> ((x > 0) ? (x - 1) : (x));\n+\n+    private final HttpClientConnection connection;\n+    private final HttpStream stream;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AtomicLong outstandingRequests = new AtomicLong(0);\n+    private final int windowSize;\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+    private final AtomicBoolean areNativeResourcesReleased = new AtomicBoolean(false);\n+    private final AtomicBoolean isSubscriptionComplete = new AtomicBoolean(false);\n+    private final AtomicBoolean queueComplete = new AtomicBoolean(false);\n+    private final AtomicInteger mutualRecursionDepth = new AtomicInteger(0);\n+    private final AtomicInteger queuedBytes = new AtomicInteger(0);\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> subscriberRef = new AtomicReference<>(null);\n+    private final Queue<byte[]> queuedBuffers = new ConcurrentLinkedQueue<>();\n+    private final AtomicReference<Throwable> error = new AtomicReference<>(null);\n+\n+    /**\n+     * Adapts a streaming AWS CRT Http Response Body to a Publisher<ByteBuffer>\n+     * @param stream The AWS CRT Http Stream for this Response\n+     * @param windowSize The max allowed bytes to be queued. The sum of the sizes of all queued ByteBuffers should\n+     *                   never exceed this value.\n+     */\n+    public AwsCrtResponseBodyPublisher(HttpClientConnection connection, HttpStream stream,\n+                                       CompletableFuture<Void> responseComplete, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection must not be null\");\n+        Validate.notNull(stream, \"Stream must not be null\");\n+        Validate.notNull(responseComplete, \"Stream must not be null\");\n+        Validate.isPositive(windowSize, \"windowSize must be > 0\");\n+        this.connection = connection;\n+        this.stream = stream;\n+        this.responseComplete = responseComplete;\n+        this.windowSize = windowSize;\n+    }\n+\n+    /**\n+     * Method for the users consuming the Http Response Body to register a subscriber.\n+     * @param subscriber The Subscriber to register.\n+     */\n+    @Override\n+    public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n+        Validate.notNull(subscriber, \"Subscriber must not be null\");\n+\n+        boolean wasFirstSubscriber = subscriberRef.compareAndSet(null, subscriber);\n+\n+        if (!wasFirstSubscriber) {\n+            log.error(() -> \"Only one subscriber allowed\");\n+\n+            // onSubscribe must be called first before onError gets called, so give it a do-nothing Subscription\n+            subscriber.onSubscribe(new Subscription() {\n+                @Override\n+                public void request(long n) {\n+                    // This is a dummy implementation to allow the onError call\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    // This is a dummy implementation to allow the onError call\n+                }\n+            });\n+            subscriber.onError(new IllegalStateException(\"Only one subscriber allowed\"));\n+        } else {\n+            subscriber.onSubscribe(new AwsCrtResponseBodySubscription(this));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzMTUyOA=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzQyNTg0OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjozMzo1OVrOGJbR6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjozMzo1OVrOGJbR6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzNzMyMA==", "bodyText": "Is this necessary since we already set the statusCode on line 74?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412537320", "createdAt": "2020-04-21T22:33:59Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzQyODU4OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjozNTowMFrOGJbTdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjo1MTo1MlrOGOx6LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzNzcxNw==", "bodyText": "Just curious, why do we need to invoke initRespBodyPublisherIfNeeded in every method?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412537717", "createdAt": "2020-04-21T22:35:00Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1MDk1Nw==", "bodyText": "No clue!  We might be able to remove some (onResponseHeaders at least), but am not sure beyond that.  I can ping Alex on this.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r418150957", "createdAt": "2020-04-30T16:51:52Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzNzcxNw=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzQ0NDIwOnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjo0MDowMFrOGJbcJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxOToxNjowN1rOGSMp7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzOTk0MQ==", "bodyText": "Is return 0 intentional?  The javadoc of onResponseBody states that Repeatedly returning zero will eventually cause the sliding window to fill up and data to stop flowing until the user slides the window back open", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412539941", "createdAt": "2020-04-21T22:40:00Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNjg0NQ==", "bodyText": "I have a query out to Alex about this.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420316845", "createdAt": "2020-05-05T18:24:30Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzOTk0MQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczNDg5Mw==", "bodyText": "Edit: 0 is intentional.  I've added comments at this point and the point where we do the window update manually.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r421734893", "createdAt": "2020-05-07T19:16:07Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }\n+\n+        respBodyPublisher.queueBuffer(bodyBytesIn);\n+        respBodyPublisher.publishToSubscribers();\n+\n+        return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzOTk0MQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzQ3NTI0OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjo0OTozOFrOGJbtYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjo0OTozOFrOGJbtYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0NDM1NA==", "bodyText": "nit: this.connection = Validate.notNull(connection, \"HttpConnection is null\");", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412544354", "createdAt": "2020-04-21T22:49:38Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzQ4ODIyOnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjo1Mzo1NlrOGJb0mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjo1Mzo1NlrOGJb0mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0NjIwMA==", "bodyText": "Seems like this is unnecessary because respBodyPublisher should be initialized if it's null on line 92.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412546200", "createdAt": "2020-04-21T22:53:56Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(responseStatusCode);\n+\n+        for (HttpHeader h : nextHeaders) {\n+            respBuilder.appendHeader(h.getName(), h.getValue());\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeadersDone(HttpStream stream, int headerType) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        respBuilder.statusCode(stream.getResponseStatusCode());\n+        sdkRequest.responseHandler().onHeaders(respBuilder.build());\n+        sdkRequest.responseHandler().onStream(respBodyPublisher);\n+    }\n+\n+    @Override\n+    public int onResponseBody(HttpStream stream, byte[] bodyBytesIn) {\n+        initRespBodyPublisherIfNeeded(stream);\n+\n+        if (respBodyPublisher == null) {\n+            log.error(() -> \"Publisher is null, onResponseHeadersDone() was never called\");\n+            throw new IllegalStateException(\"Publisher is null, onResponseHeadersDone() was never called\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzUwNDM1OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjo1OToxNlrOGJb9kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjowMToyNFrOGgKXSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ==", "bodyText": "What happens if the status code is 5xx level? Would the underlying crt client close the connection after the response is complete? If not, should we mark it \"close to new request\" so that the next retry attempt would establish a new connection?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412548499", "createdAt": "2020-04-21T22:59:16Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MzYxMQ==", "bodyText": "Another question, sometimes services will put connection:close in the response header to indicate the connection is to be closed on the service side, would the underlying crt client close such connections after they are released to the pool?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412573611", "createdAt": "2020-04-22T00:03:05Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY1MzkwMQ==", "bodyText": "The connection will get closed before returning to the pool and the pool will check status and toss it, so it won't be vended again to the next requester", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r418653901", "createdAt": "2020-05-01T17:44:44Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMyMjQzMw==", "bodyText": "I'm going to go ahead and add a closed check on acquire as well, but it may arrive after the fact.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420322433", "createdAt": "2020-05-05T18:33:39Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4ODIxMQ==", "bodyText": "Update: this wasn't necessary; the instant a connection enters the closed state, if it's in the pool, it gets removed.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420388211", "createdAt": "2020-05-05T20:32:55Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5MjAxMw==", "bodyText": "To the original question, the crt does not make any interpretations on status code.  Behavioral changes would need to be driven by the SDK.  If we need to make this kind of a change, it will require a little more work, since we don't directly a close on the connection.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420392013", "createdAt": "2020-05-05T20:40:10Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQwMjQ2NQ==", "bodyText": "I see. For sync http clients, the SDK core module has access to the underlying connection, so it is able to close connections that generated a 5xx error. For async http clients, since core module doesn't have access to the connection, individual client would need to close such connections afterwards. This is how we implemented in netty for reference #1768", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420402465", "createdAt": "2020-05-05T20:58:58Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3NzQxNg==", "bodyText": "Updated, with test", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436377416", "createdAt": "2020-06-07T16:01:24Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU0ODQ5OQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzUzODA5OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzoxMDozOFrOGJcPxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzoxMDozOFrOGJcPxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MzE1Nw==", "bodyText": "It'd be nice to have a consumer builder overload here as well.\nBuilder proxyConfiguration(Consumer<ProxyConfiguration.Builder> proxyConfiguration);", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412553157", "createdAt": "2020-04-21T23:10:38Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());\n+                    });\n+\n+            return requestFuture;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized (this) {\n+\n+            if (isClosed) {\n+                return;\n+            }\n+\n+            for (HttpClientConnectionManager connPool : connectionPools.values()) {\n+                IoUtils.closeQuietly(connPool, log.logger());\n+            }\n+\n+            while (!ownedSubResources.isEmpty()) {\n+                CrtResource r = ownedSubResources.pop();\n+                IoUtils.closeQuietly(r, log.logger());\n+            }\n+\n+            isClosed = true;\n+        }\n+    }\n+\n+    /**\n+     * Builder that allows configuration of the AWS CRT HTTP implementation.\n+     */\n+    public interface Builder extends SdkAsyncHttpClient.Builder<AwsCrtAsyncHttpClient.Builder> {\n+\n+        /**\n+         * The AWS CRT TlsCipherPreference to use for this Client\n+         * @param tlsCipherPreference The AWS Common Runtime TlsCipherPreference\n+         * @return The builder of the method chaining.\n+         */\n+        Builder tlsCipherPreference(TlsCipherPreference tlsCipherPreference);\n+\n+        /**\n+         * If set to true, then the TCP read back pressure mechanism will be enabled, and the user\n+         * is responsible for calling incrementWindow on the stream object.\n+         * @param manualWindowManagement true if the TCP back pressure mechanism should be enabled.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder manualWindowManagement(boolean manualWindowManagement);\n+\n+        /**\n+         * The AWS CRT WindowSize to use for this HttpClient. This represents the number of unread bytes that can be\n+         * buffered in the ResponseBodyPublisher before we stop reading from the underlying TCP socket and wait for\n+         * the Subscriber to read more data.\n+         *\n+         * @param initialWindowSize The AWS Common Runtime WindowSize\n+         * @return The builder of the method chaining.\n+         */\n+        Builder initialWindowSize(int initialWindowSize);\n+\n+        /**\n+         * The AWS CRT EventLoopGroup to use for this Client.\n+         * @param eventLoopGroup The AWS CRT EventLoopGroup to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder eventLoopGroup(EventLoopGroup eventLoopGroup);\n+\n+        /**\n+         * The AWS CRT HostResolver to use for this Client.\n+         * @param hostResolver The AWS CRT HostResolver to use for this client.\n+         * @return The builder of the method chaining.\n+         */\n+        Builder hostResolver(HostResolver hostResolver);\n+\n+        /**\n+         * Sets the http proxy configuration to use for this client.\n+         * @param proxyConfiguration The http proxy configuration to use\n+         * @return The builder of the method chaining.\n+         */\n+        Builder proxyConfiguration(ProxyConfiguration proxyConfiguration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzU4OTA1OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzoyNzoxNlrOGJcrHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNzo0NzoyM1rOGPQrqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2MDE1Nw==", "bodyText": "How does it handle requests with Expect: 100-continue header?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412560157", "createdAt": "2020-04-21T23:27:16Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY1NTE0NA==", "bodyText": "Those come in as a different block type (informational) which actually was causing an issue in the initial draft of the s3 stability tests, but it was straightforward to fix.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r418655144", "createdAt": "2020-05-01T17:47:23Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtAsyncHttpStreamAdapter.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CompletableFuture;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.http.HttpClientConnection;\n+import software.amazon.awssdk.crt.http.HttpException;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpRequestBodyStream;\n+import software.amazon.awssdk.crt.http.HttpStream;\n+import software.amazon.awssdk.crt.http.HttpStreamResponseHandler;\n+import software.amazon.awssdk.http.SdkHttpResponse;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Implements the CrtHttpStreamHandler API and converts CRT callbacks into calls to SDK AsyncExecuteRequest methods\n+ */\n+@SdkInternalApi\n+public class AwsCrtAsyncHttpStreamAdapter implements HttpStreamResponseHandler, HttpRequestBodyStream {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpStreamAdapter.class);\n+\n+    private final HttpClientConnection connection;\n+    private final CompletableFuture<Void> responseComplete;\n+    private final AsyncExecuteRequest sdkRequest;\n+    private final SdkHttpResponse.Builder respBuilder = SdkHttpResponse.builder();\n+    private final int windowSize;\n+    private final AwsCrtRequestBodySubscriber requestBodySubscriber;\n+    private AwsCrtResponseBodyPublisher respBodyPublisher = null;\n+\n+    public AwsCrtAsyncHttpStreamAdapter(HttpClientConnection connection, CompletableFuture<Void> responseComplete,\n+                                        AsyncExecuteRequest sdkRequest, int windowSize) {\n+        Validate.notNull(connection, \"HttpConnection is null\");\n+        Validate.notNull(responseComplete, \"reqComplete Future is null\");\n+        Validate.notNull(sdkRequest, \"AsyncExecuteRequest Future is null\");\n+        Validate.isPositive(windowSize, \"windowSize is <= 0\");\n+\n+        this.connection = connection;\n+        this.responseComplete = responseComplete;\n+        this.sdkRequest = sdkRequest;\n+        this.windowSize = windowSize;\n+        this.requestBodySubscriber = new AwsCrtRequestBodySubscriber(windowSize);\n+\n+        sdkRequest.requestContentPublisher().subscribe(requestBodySubscriber);\n+    }\n+\n+    private void initRespBodyPublisherIfNeeded(HttpStream stream) {\n+        if (respBodyPublisher == null) {\n+            respBodyPublisher = new AwsCrtResponseBodyPublisher(connection, stream, responseComplete, windowSize);\n+        }\n+    }\n+\n+    @Override\n+    public void onResponseHeaders(HttpStream stream, int responseStatusCode, int blockType, HttpHeader[] nextHeaders) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2MDE1Nw=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzYxOTc1OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzozODozNlrOGJc78g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMDo0ODo0NVrOGQ6-0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDQ2Ng==", "bodyText": "Is there anyway to check if the connection is still active here? In our experience with netty, there could be a race condition where a connection gets closed on the service side at the same time it gets picked up for a new request, so we had to implement a health check mechanism when acquiring a new connection for netty client.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412564466", "createdAt": "2020-04-21T23:38:36Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY2NTMxOA==", "bodyText": "We check on release-to-pool but it does not appear that we check on acquire; I can look into that change, but the C connection manager is a delicate beast.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r418665318", "createdAt": "2020-05-01T18:09:21Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDQ2Ng=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5Njc1Mw==", "bodyText": "As noted above, closed connections are removed from the pool as soon as the status is registered.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420396753", "createdAt": "2020-05-05T20:48:45Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDQ2Ng=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 287}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzYyMjkxOnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzozOTo0MFrOGJc9pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo1NjoxNVrOGRcZ3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDkwMQ==", "bodyText": "What type of exception could it throw? If it's not a subtype of IOException, should we wrap it with IOException so that it can be retried?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412564901", "createdAt": "2020-04-21T23:39:40Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0NDM0OA==", "bodyText": "Looking at the subclasses of IoException and the ways this could fail I think wrapping this in an IoException is reasonable.  The most common problems would be socket in nature.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420944348", "createdAt": "2020-05-06T16:56:15Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NDkwMQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzYzNTQ0OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzo0NDowOFrOGJdEUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNzoyMDo1NlrOGSIihA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ==", "bodyText": "Same comment, we might want to wrap the exception with IOException so that it can be retried by the SDK.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r412566611", "createdAt": "2020-04-21T23:44:08Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk1NDIzMA==", "bodyText": "Would it make more sense to remove the invokeSafely and just add a try that wraps anything in IoException?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420954230", "createdAt": "2020-05-06T17:11:35Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjgzMQ==", "bodyText": "Looking at the code of HttpClientConnection#makeRequest, it can throw IllegalStateException and CrtRunTimeException, are they both retryable?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r420962831", "createdAt": "2020-05-06T17:24:45Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0NDQ0Nw==", "bodyText": "Looks like all should be retryable; there are some unknowns on the IllegalState situation whether or not you might end up with the same connection, but that case should not be possible in this particular situation.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r421644447", "createdAt": "2020-05-07T16:42:35Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0OTcyNA==", "bodyText": "Will the sdk dig inside a RuntimeException to find an IoException cause and consider that to be retryable?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r421649724", "createdAt": "2020-05-07T16:51:15Z", "author": {"login": "bretambrose"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NzQ2MA==", "bodyText": "The SDK will only check one level down of the exception chain, so if it'll retry if the exception thrown is an instance of IOException or its direct cause is IOException.\n\n  \n    \n      aws-sdk-java-v2/core/sdk-core/src/main/java/software/amazon/awssdk/core/retry/conditions/RetryOnExceptionsCondition.java\n    \n    \n        Lines 56 to 62\n      in\n      16b866a\n    \n    \n    \n    \n\n        \n          \n           Predicate<Class<? extends Exception>> isRetryableException = \n        \n\n        \n          \n               ex -> ex.isAssignableFrom(exception.getClass()); \n        \n\n        \n          \n            \n        \n\n        \n          \n           Predicate<Class<? extends Exception>> hasRetrableCause = \n        \n\n        \n          \n               ex -> exception.getCause() != null && ex.isAssignableFrom(exception.getCause().getClass()); \n        \n\n        \n          \n            \n        \n\n        \n          \n           return exceptionsToRetryOn.stream().anyMatch(isRetryableException.or(hasRetrableCause));", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r421667460", "createdAt": "2020-05-07T17:20:56Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http.crt;\n+\n+import static software.amazon.awssdk.utils.CollectionUtils.isNullOrEmpty;\n+import static software.amazon.awssdk.utils.FunctionalUtils.invokeSafely;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.crt.CrtResource;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManager;\n+import software.amazon.awssdk.crt.http.HttpClientConnectionManagerOptions;\n+import software.amazon.awssdk.crt.http.HttpHeader;\n+import software.amazon.awssdk.crt.http.HttpProxyOptions;\n+import software.amazon.awssdk.crt.http.HttpRequest;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.io.TlsCipherPreference;\n+import software.amazon.awssdk.crt.io.TlsContext;\n+import software.amazon.awssdk.crt.io.TlsContextOptions;\n+import software.amazon.awssdk.http.SdkHttpClient;\n+import software.amazon.awssdk.http.SdkHttpConfigurationOption;\n+import software.amazon.awssdk.http.SdkHttpRequest;\n+import software.amazon.awssdk.http.async.AsyncExecuteRequest;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+import software.amazon.awssdk.http.crt.internal.AwsCrtAsyncHttpStreamAdapter;\n+import software.amazon.awssdk.utils.AttributeMap;\n+import software.amazon.awssdk.utils.IoUtils;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+import software.amazon.awssdk.utils.http.SdkHttpUtils;\n+\n+/**\n+ * An implementation of {@link SdkHttpClient} that uses the AWS Common Runtime (CRT) Http Client to communicate with\n+ * Http Web Services. This client is asynchronous and uses non-blocking IO.\n+ *\n+ * <p>This can be created via {@link #builder()}</p>\n+ */\n+@SdkPublicApi\n+public final class AwsCrtAsyncHttpClient implements SdkAsyncHttpClient {\n+    private static final Logger log = Logger.loggerFor(AwsCrtAsyncHttpClient.class);\n+    private static final String HOST_HEADER = \"Host\";\n+    private static final String CONTENT_LENGTH = \"Content-Length\";\n+    private static final String CONNECTION = \"Connection\";\n+    private static final String KEEP_ALIVE = \"keep-alive\";\n+    private static final String AWS_COMMON_RUNTIME = \"AwsCommonRuntime\";\n+    private static final String NULL_REQUEST_ERROR_MESSAGE = \"SdkHttpRequest must not be null\";\n+    private static final String NULL_URI_ERROR_MESSAGE = \"URI must not be null\";\n+    private static final int DEFAULT_STREAM_WINDOW_SIZE = 16 * 1024 * 1024; // 16 MB\n+\n+    private final Map<URI, HttpClientConnectionManager> connectionPools = new ConcurrentHashMap<>();\n+    private final LinkedList<CrtResource> ownedSubResources = new LinkedList<>();\n+    private final ClientBootstrap bootstrap;\n+    private final SocketOptions socketOptions;\n+    private final TlsContext tlsContext;\n+    private final HttpProxyOptions proxyOptions;\n+    private final int initialWindowSize;\n+    private final int maxConnectionsPerEndpoint;\n+    private final boolean manualWindowManagement;\n+    private boolean isClosed = false;\n+\n+    private AwsCrtAsyncHttpClient(DefaultBuilder builder, AttributeMap config) {\n+        int maxConns = config.get(SdkHttpConfigurationOption.MAX_CONNECTIONS);\n+\n+        Validate.isPositive(maxConns, \"maxConns\");\n+        Validate.notNull(builder.cipherPreference, \"cipherPreference\");\n+        Validate.isPositive(builder.initialWindowSize, \"initialWindowSize\");\n+        Validate.notNull(builder.eventLoopGroup, \"eventLoopGroup\");\n+        Validate.notNull(builder.hostResolver, \"hostResolver\");\n+\n+        try (ClientBootstrap clientBootstrap = new ClientBootstrap(builder.eventLoopGroup, builder.hostResolver);\n+             SocketOptions clientSocketOptions = new SocketOptions();\n+             TlsContextOptions clientTlsContextOptions = TlsContextOptions.createDefaultClient() // NOSONAR\n+                     .withCipherPreference(builder.cipherPreference)\n+                     .withVerifyPeer(!config.get(SdkHttpConfigurationOption.TRUST_ALL_CERTIFICATES));\n+             TlsContext clientTlsContext = new TlsContext(clientTlsContextOptions)) {\n+\n+            this.bootstrap = own(clientBootstrap);\n+            this.socketOptions = own(clientSocketOptions);\n+            this.tlsContext = own(clientTlsContext);\n+\n+            this.initialWindowSize = builder.initialWindowSize;\n+            this.maxConnectionsPerEndpoint = maxConns;\n+            this.manualWindowManagement = builder.manualWindowManagement;\n+\n+            ProxyConfiguration builderProxyConfig = builder.proxyConfiguration;\n+            if (builderProxyConfig != null) {\n+                HttpProxyOptions clientProxyOptions = new HttpProxyOptions();\n+\n+                clientProxyOptions.setHost(builderProxyConfig.host());\n+                clientProxyOptions.setPort(builderProxyConfig.port());\n+                if (builderProxyConfig.scheme() != null && builderProxyConfig.scheme().equalsIgnoreCase(\"https\")) {\n+                    clientProxyOptions.setTlsContext(tlsContext);\n+                }\n+\n+                if (builderProxyConfig.username() != null && builderProxyConfig.password() != null) {\n+                    clientProxyOptions.setAuthorizationUsername(builderProxyConfig.username());\n+                    clientProxyOptions.setAuthorizationPassword(builderProxyConfig.password());\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.Basic);\n+                } else {\n+                    clientProxyOptions.setAuthorizationType(HttpProxyOptions.HttpProxyAuthorizationType.None);\n+                }\n+\n+                this.proxyOptions = clientProxyOptions;\n+            } else {\n+                this.proxyOptions = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Marks a Native CrtResource as owned by the current Java Object.\n+     *\n+     * @param subresource The Resource to own.\n+     * @param <T> The CrtResource Type\n+     * @return The CrtResource passed in\n+     */\n+    private <T extends CrtResource> T own(T subresource) {\n+        if (subresource != null) {\n+            subresource.addRef();\n+            ownedSubResources.push(subresource);\n+        }\n+        return subresource;\n+    }\n+\n+    private static URI toUri(SdkHttpRequest sdkRequest) {\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+        return invokeSafely(() -> new URI(sdkRequest.protocol(), null, sdkRequest.host(), sdkRequest.port(),\n+                null, null, null));\n+    }\n+\n+    public static Builder builder() {\n+        return new DefaultBuilder();\n+    }\n+\n+    @Override\n+    public String clientName() {\n+        return AWS_COMMON_RUNTIME;\n+    }\n+\n+    private HttpClientConnectionManager createConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        log.debug(() -> \"Creating ConnectionPool for: URI:\" + uri + \", MaxConns: \" + maxConnectionsPerEndpoint);\n+\n+        HttpClientConnectionManagerOptions options = new HttpClientConnectionManagerOptions()\n+                .withClientBootstrap(bootstrap)\n+                .withSocketOptions(socketOptions)\n+                .withTlsContext(tlsContext)\n+                .withUri(uri)\n+                .withWindowSize(initialWindowSize)\n+                .withMaxConnections(maxConnectionsPerEndpoint)\n+                .withManualWindowManagement(manualWindowManagement)\n+                .withProxyOptions(proxyOptions);\n+\n+        return HttpClientConnectionManager.create(options);\n+    }\n+\n+    /*\n+     * Callers of this function MUST account for the addRef() on the pool before returning.\n+     * Every execution path consuming the return value must guarantee an associated close().\n+     * Currently this function is only used by execute(), which guarantees a matching close\n+     * via the try-with-resources block.\n+     *\n+     * This guarantees that a returned pool will not get closed (by closing the http client) during\n+     * the time it takes to submit a request to the pool.  Acquisition requests submitted to the pool will\n+     * be properly failed if the http client is closed before the acquisition completes.\n+     *\n+     * This additional complexity means we only have to keep a lock for the scope of this function, as opposed to\n+     * the scope of calling execute().  This function will almost always just be a hash lookup and the return of an\n+     * existing pool.  If we add all of execute() to the scope, we include, at minimum a JNI call to the native\n+     * pool implementation.\n+     */\n+    private HttpClientConnectionManager getOrCreateConnectionPool(URI uri) {\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        synchronized (this) {\n+            if (isClosed) {\n+                throw new IllegalStateException(\"Client is closed. No more requests can be made with this client.\");\n+            }\n+\n+            HttpClientConnectionManager connPool = connectionPools.computeIfAbsent(uri, k -> createConnectionPool(k));\n+            connPool.addRef();\n+            return connPool;\n+        }\n+    }\n+\n+    private List<HttpHeader> createHttpHeaderList(URI uri, AsyncExecuteRequest asyncRequest) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        // worst case we may add 3 more headers here\n+        List<HttpHeader> crtHeaderList = new ArrayList<>(sdkRequest.headers().size() + 3);\n+\n+        // Set Host Header if needed\n+        if (isNullOrEmpty(sdkRequest.headers().get(HOST_HEADER))) {\n+            crtHeaderList.add(new HttpHeader(HOST_HEADER, uri.getHost()));\n+        }\n+\n+        // Add Connection Keep Alive Header to reuse this Http Connection as long as possible\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONNECTION))) {\n+            crtHeaderList.add(new HttpHeader(CONNECTION, KEEP_ALIVE));\n+        }\n+\n+        // Set Content-Length if needed\n+        Optional<Long> contentLength = asyncRequest.requestContentPublisher().contentLength();\n+        if (isNullOrEmpty(sdkRequest.headers().get(CONTENT_LENGTH)) && contentLength.isPresent()) {\n+            crtHeaderList.add(new HttpHeader(CONTENT_LENGTH, Long.toString(contentLength.get())));\n+        }\n+\n+        // Add the rest of the Headers\n+        for (Map.Entry<String, List<String>> headerList: sdkRequest.headers().entrySet()) {\n+            for (String val: headerList.getValue()) {\n+                HttpHeader h = new HttpHeader(headerList.getKey(), val);\n+                crtHeaderList.add(h);\n+            }\n+        }\n+\n+        return crtHeaderList;\n+    }\n+\n+    private HttpHeader[] asArray(List<HttpHeader> crtHeaderList) {\n+        return crtHeaderList.toArray(new HttpHeader[crtHeaderList.size()]);\n+    }\n+\n+    private HttpRequest toCrtRequest(URI uri, AsyncExecuteRequest asyncRequest, AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter) {\n+        SdkHttpRequest sdkRequest = asyncRequest.request();\n+        Validate.notNull(uri, NULL_URI_ERROR_MESSAGE);\n+        Validate.notNull(sdkRequest, NULL_REQUEST_ERROR_MESSAGE);\n+\n+        String method = sdkRequest.method().name();\n+        String encodedPath = sdkRequest.encodedPath();\n+        if (encodedPath == null || encodedPath.length() == 0) {\n+            encodedPath = \"/\";\n+        }\n+\n+        String encodedQueryString = SdkHttpUtils.encodeAndFlattenQueryParameters(sdkRequest.rawQueryParameters())\n+                .map(value -> \"?\" + value)\n+                .orElse(\"\");\n+\n+        HttpHeader[] crtHeaderArray = asArray(createHttpHeaderList(uri, asyncRequest));\n+\n+        return new HttpRequest(method, encodedPath + encodedQueryString, crtHeaderArray, crtToSdkAdapter);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(AsyncExecuteRequest asyncRequest) {\n+\n+        Validate.notNull(asyncRequest, \"AsyncExecuteRequest must not be null\");\n+        Validate.notNull(asyncRequest.request(), NULL_REQUEST_ERROR_MESSAGE);\n+        Validate.notNull(asyncRequest.requestContentPublisher(), \"RequestContentPublisher must not be null\");\n+        Validate.notNull(asyncRequest.responseHandler(), \"ResponseHandler must not be null\");\n+\n+        URI uri = toUri(asyncRequest.request());\n+\n+        try (HttpClientConnectionManager crtConnPool = getOrCreateConnectionPool(uri)) {\n+            CompletableFuture<Void> requestFuture = new CompletableFuture<>();\n+\n+            // When a Connection is ready from the Connection Pool, schedule the Request on the connection\n+            crtConnPool.acquireConnection()\n+                    .whenComplete((crtConn, throwable) -> {\n+                        // If we didn't get a connection for some reason, fail the request\n+                        if (throwable != null) {\n+                            asyncRequest.responseHandler().onError(throwable);\n+                            requestFuture.completeExceptionally(throwable);\n+                            return;\n+                        }\n+\n+                        AwsCrtAsyncHttpStreamAdapter crtToSdkAdapter =\n+                                new AwsCrtAsyncHttpStreamAdapter(crtConn, requestFuture, asyncRequest, initialWindowSize);\n+                        HttpRequest crtRequest = toCrtRequest(uri, asyncRequest, crtToSdkAdapter);\n+\n+                        // Submit the Request on this Connection\n+                        invokeSafely(() -> crtConn.makeRequest(crtRequest, crtToSdkAdapter).activate());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU2NjYxMQ=="}, "originalCommit": {"oid": "92af360089fb70c7bc5d1d55dfe8661576b019f3"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjE2MTY0OnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzoxNDozMVrOGf2pVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzoxNDozMVrOGf2pVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NDM1OA==", "bodyText": "Should we put a warning log here? same as line 218", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436054358", "createdAt": "2020-06-05T17:14:31Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/internal/AwsCrtResponseBodyPublisher.java", "diffHunk": "@@ -204,11 +204,19 @@ protected void completeSubscriptionExactlyOnce() {\n         // Complete the Futures\n         if (throwable != null) {\n             log.error(() -> \"Error before ResponseBodyPublisher could complete: \" + throwable.getMessage());\n-            subscriber.ifPresent(s -> s.onError(throwable));\n+            try {\n+                subscriber.ifPresent(s -> s.onError(throwable));\n+            } catch (Exception e) {\n+                ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5affa636c9ee0a219d88a7b158750ec64dab0617"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjE4MDYyOnYy", "diffSide": "RIGHT", "path": "test/http-client-tests/src/main/java/software/amazon/awssdk/http/H1ServerErrorTestBase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzoyMDo0OVrOGf21lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzoyMDo0OVrOGf21lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NzQ5NQ==", "bodyText": "Nice, thank you for making it sharable for all http clients!!", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436057495", "createdAt": "2020-06-05T17:20:49Z", "author": {"login": "zoewangg"}, "path": "test/http-client-tests/src/main/java/software/amazon/awssdk/http/H1ServerErrorTestBase.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.http;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.ServerSocketChannel;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import io.netty.handler.ssl.SslContext;\n+import io.netty.handler.ssl.SslContextBuilder;\n+import io.netty.handler.ssl.util.SelfSignedCertificate;\n+import software.amazon.awssdk.http.async.SdkAsyncHttpClient;\n+\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\n+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.TEXT_PLAIN;\n+import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;\n+\n+\n+/**\n+ * Testing the scenario where h1 server sends 5xx errors.\n+ */\n+public abstract class H1ServerErrorTestBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5affa636c9ee0a219d88a7b158750ec64dab0617"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjE4NTYxOnYy", "diffSide": "RIGHT", "path": "test/stability-tests/src/it/java/software/amazon/awssdk/stability/tests/s3/S3BaseStabilityTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzoyMjozMVrOGf244Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjowMjoyMVrOGgKXlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1ODMzNw==", "bodyText": "Is there any reason lowering the total runs and increasing concurrency?", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436058337", "createdAt": "2020-06-05T17:22:31Z", "author": {"login": "zoewangg"}, "path": "test/stability-tests/src/it/java/software/amazon/awssdk/stability/tests/s3/S3BaseStabilityTest.java", "diffHunk": "@@ -15,44 +15,39 @@\n \n package software.amazon.awssdk.stability.tests.s3;\n \n+import java.io.File;\n import java.io.IOException;\n+import java.nio.file.Path;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.core.retry.RetryPolicy;\n+import java.util.function.IntFunction;\n+\n+import org.apache.commons.lang3.RandomStringUtils;\n+import software.amazon.awssdk.core.async.AsyncRequestBody;\n+import software.amazon.awssdk.core.async.AsyncResponseTransformer;\n import software.amazon.awssdk.core.sync.RequestBody;\n import software.amazon.awssdk.http.apache.ApacheHttpClient;\n-import software.amazon.awssdk.http.nio.netty.NettyNioAsyncHttpClient;\n import software.amazon.awssdk.services.s3.S3AsyncClient;\n import software.amazon.awssdk.services.s3.S3Client;\n import software.amazon.awssdk.services.s3.model.DeleteBucketRequest;\n import software.amazon.awssdk.services.s3.model.NoSuchBucketException;\n import software.amazon.awssdk.services.s3.model.NoSuchKeyException;\n+import software.amazon.awssdk.stability.tests.utils.StabilityTestRunner;\n import software.amazon.awssdk.testutils.RandomTempFile;\n import software.amazon.awssdk.testutils.service.AwsTestBase;\n import software.amazon.awssdk.utils.Logger;\n \n public abstract class S3BaseStabilityTest extends AwsTestBase {\n     private static final Logger log = Logger.loggerFor(S3BaseStabilityTest.class);\n-    protected static final int CONCURRENCY = 100;\n-    protected static final int TOTAL_RUNS = 50;\n+    protected static final int CONCURRENCY = 500;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5affa636c9ee0a219d88a7b158750ec64dab0617"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3NzQ5NA==", "bodyText": "I think that's me forgetting what the original settings were after we finished debugging.", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436377494", "createdAt": "2020-06-07T16:02:21Z", "author": {"login": "bretambrose"}, "path": "test/stability-tests/src/it/java/software/amazon/awssdk/stability/tests/s3/S3BaseStabilityTest.java", "diffHunk": "@@ -15,44 +15,39 @@\n \n package software.amazon.awssdk.stability.tests.s3;\n \n+import java.io.File;\n import java.io.IOException;\n+import java.nio.file.Path;\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.core.retry.RetryPolicy;\n+import java.util.function.IntFunction;\n+\n+import org.apache.commons.lang3.RandomStringUtils;\n+import software.amazon.awssdk.core.async.AsyncRequestBody;\n+import software.amazon.awssdk.core.async.AsyncResponseTransformer;\n import software.amazon.awssdk.core.sync.RequestBody;\n import software.amazon.awssdk.http.apache.ApacheHttpClient;\n-import software.amazon.awssdk.http.nio.netty.NettyNioAsyncHttpClient;\n import software.amazon.awssdk.services.s3.S3AsyncClient;\n import software.amazon.awssdk.services.s3.S3Client;\n import software.amazon.awssdk.services.s3.model.DeleteBucketRequest;\n import software.amazon.awssdk.services.s3.model.NoSuchBucketException;\n import software.amazon.awssdk.services.s3.model.NoSuchKeyException;\n+import software.amazon.awssdk.stability.tests.utils.StabilityTestRunner;\n import software.amazon.awssdk.testutils.RandomTempFile;\n import software.amazon.awssdk.testutils.service.AwsTestBase;\n import software.amazon.awssdk.utils.Logger;\n \n public abstract class S3BaseStabilityTest extends AwsTestBase {\n     private static final Logger log = Logger.loggerFor(S3BaseStabilityTest.class);\n-    protected static final int CONCURRENCY = 100;\n-    protected static final int TOTAL_RUNS = 50;\n+    protected static final int CONCURRENCY = 500;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1ODMzNw=="}, "originalCommit": {"oid": "5affa636c9ee0a219d88a7b158750ec64dab0617"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjM0MDAwOnYy", "diffSide": "RIGHT", "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowOTo1NFrOGf4bWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxODowOTo1NFrOGf4bWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4MzU0NA==", "bodyText": "Minor: I don't think we need to create a default connectionMaxIdleTime here since the default value will be merged in when we merge SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS in the build method.\n        @Override\n        public SdkAsyncHttpClient build() {\n            return new AwsCrtAsyncHttpClient(this, standardOptions.build()\n                                                                  .merge(SdkHttpConfigurationOption.GLOBAL_HTTP_DEFAULTS));\n        }", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1777#discussion_r436083544", "createdAt": "2020-06-05T18:09:54Z", "author": {"login": "zoewangg"}, "path": "http-clients/aws-crt-client/src/main/java/software/amazon/awssdk/http/crt/AwsCrtAsyncHttpClient.java", "diffHunk": "@@ -417,6 +437,10 @@ public void close() {\n         private EventLoopGroup eventLoopGroup;\n         private HostResolver hostResolver;\n         private ProxyConfiguration proxyConfiguration;\n+        private HttpMonitoringOptions monitoringOptions;\n+\n+        // default reaping interval matches Apache client\n+        private Duration connectionMaxIdleTime = Duration.ofSeconds(60);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5affa636c9ee0a219d88a7b158750ec64dab0617"}, "originalPosition": 71}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4080, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}