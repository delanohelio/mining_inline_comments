{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3MjMwNjI5", "number": 19, "title": "Style guide update & removed unused files.", "bodyText": "Style guide changes.\nUpdate Readme.\nRemove unused assets and files.\nUpdate Pods.\nUpdate copyrights.\nApp Configuration changes.\nRemove fabric and crashlytics.(deprecated)", "createdAt": "2020-03-12T13:02:59Z", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19", "merged": true, "mergeCommit": {"oid": "a7c34b7c9d49ed2219a17b75b3db391cd6479190"}, "closed": true, "closedAt": "2020-03-18T17:22:05Z", "author": {"login": "tushar-boston"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcM6itpgH2gAyMzg3MjMwNjI5OjZlNGVkYjEwMGJkYWE5NTZlZTUzYzM4NTUyODE2ODcyNWU0ZWEwODU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcO1ZPzAH2gAyMzg3MjMwNjI5OjFjMWEwYmI2ZTljOTkxNTVmMTc5MGU1ZGRiN2UzMmJiN2Q3NjA4NTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085", "author": {"user": {"login": "tushar-boston", "name": "Tushar Katyal"}}, "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/6e4edb100bdaa956ee53c385528168725e4ea085", "committedDate": "2020-03-12T12:05:35Z", "message": "- Style guide changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNjI3ODIz", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#pullrequestreview-373627823", "createdAt": "2020-03-12T14:53:26Z", "commit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "state": "COMMENTED", "comments": {"totalCount": 75, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNDo1MzoyNlrOF1iDgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNTozMjozNFrOF2INEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3NjgwMw==", "bodyText": "please remove", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391676803", "createdAt": "2020-03-12T14:53:26Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/AppDelegate.swift", "diffHunk": "@@ -1,1900 +1,1844 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC\n+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import Fabric\n-import Crashlytics\n-import UserNotifications\n-import RealmSwift\n import CallKit\n import IQKeyboardManagerSwift\n+import RealmSwift\n+import UIKit\n+import UserNotifications\n \n-let kEncryptionKey = \"EncryptionKey\"\n-let kEncryptionIV =  \"EncryptionIV\"\n-let kBlockerScreenLabelText = \"Please update to the latest version of app to continue.\"\n-let kConsentUpdatedTitle = \"Consent Updated\"\n+@UIApplicationMain\n \n-let kMessageConsentUpdatedPartTwo = \" Please review the revised Consent terms and provide your Informed Consent, to continue participating in the study.\"\n+class AppDelegate: UIResponder, UIApplicationDelegate {\n \n-let kMessageConsentUpdated = \"The Consent Document for this study has been updated.\" + kMessageConsentUpdatedPartTwo\n+  var window: UIWindow?\n \n-let kReviewTitle = \"Review\"\n-let kPasscodeStepIdentifier = \"PasscodeStep\"\n-let kPasscodeTaskIdentifier = \"PassCodeTask\"\n-let kMessagePasscode = \"Passcode\"\n-let kMessagePasscodeSignOut = \"You will be signed out and will need to sign in again. Are you sure you want to proceed?\"\n-let kNewProgressViewNIB = \"NewProgressView\"\n-let kforgotPasscodeTitle = \"Forgot Passcode? Sign In Again\"\n-let kStudyStoryboard = \"Study\"\n-let kPasscodeSetUpText = \"Set up a passcode for the app\"\n-let kIphoneSimulator =  \"iPhone Simulator\"\n+  var notificationDetails: [String: Any]? = [String: Any]()\n \n-let kBundleIdentier = \"CFBundleIdentifier\"\n-let kPDFCreationNotificationId = \"pdfCreationNotificationIdentifier\"\n-let ksetUpTimeIdentifier = \"setUPTime\"\n-let kCFBundleShortVersion = \"CFBundleShortVersionString\"\n+  var appIsResignedButDidNotEnteredBackground: Bool? = false\n \n-let kResultCount = \"resultCount\"\n-let kResultsForAppStore = \"results\"\n-let kAppStoreVersion = \"version\"\n+  var alertVCPresented: UIAlertController?\n \n-let kContinueButtonTitle =  NSLocalizedString(\"Continue\", comment:\"\")\n-let kType = \"type\"\n+  var isPasscodePresented: Bool? = false\n \n-let kCurrentVersion = \"currentVersion\"\n-let kForceUpdate = \"forceUpdate\"\n-let kMessage = \"message\"\n-let kVisualStepId = \"visual\"\n-let kMessageString = \"Message\"\n+  var isComprehensionFailed: Bool? = false\n \n+  var parentViewControllerForAlert: UIViewController?\n \n-@UIApplicationMain\n+  var iscomingFromForgotPasscode: Bool? = false\n \n-class AppDelegate: UIResponder, UIApplicationDelegate {\n-    \n-    var window: UIWindow?\n-    \n-    var notificationDetails:Dictionary<String,Any>? = Dictionary<String,Any>()\n-    \n-    var appIsResignedButDidNotEnteredBackground:Bool? = false\n-    \n-    var alertVCPresented:UIAlertController?\n-    \n-    var isPasscodePresented:Bool? =  false\n-    \n-    var isComprehensionFailed:Bool? = false\n-    \n-    var parentViewControllerForAlert:UIViewController?\n-    \n-    var iscomingFromForgotPasscode:Bool? =  false\n-    \n-    var isAppLaunched: Bool? = false\n-    \n-    let healthStore = HKHealthStore()\n-    var containerViewController: ResearchContainerViewController? {\n-        return window?.rootViewController as? ResearchContainerViewController\n+  var isAppLaunched: Bool? = false\n+\n+  let healthStore = HKHealthStore()\n+\n+  var containerViewController: ResearchContainerViewController? {\n+    return window?.rootViewController as? ResearchContainerViewController\n+  }\n+\n+  var selectedController: UIViewController?\n+\n+  var shouldAddForceUpgradeScreen = false\n+\n+  var retryView: ComprehensionFailure?\n+\n+  var blockerScreen: AppUpdateBlocker?\n+  var passcodeParentControllerWhileSetup: UIViewController?\n+\n+  /// to be used in case of ineligible\n+  var consentToken: String? = \"\"\n+\n+  /// Register for Remote Notification\n+  func askForNotification() {\n+\n+    if #available(iOS 10.0, *) {\n+      let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n+      UNUserNotificationCenter.current().requestAuthorization(\n+        options: authOptions,\n+        completionHandler: { _, _ in })\n+\n+      // For iOS 10 display notification (sent via APNS)\n+      UNUserNotificationCenter.current().delegate = self\n+\n+    } else {\n+      let settings: UIUserNotificationSettings = UIUserNotificationSettings(\n+        types: [.alert, .badge, .sound], categories: nil)\n+      UIApplication.shared.registerUserNotificationSettings(settings)\n     }\n-    \n-    var selectedController: UIViewController?\n-    \n-    var shouldAddForceUpgradeScreen = false\n-    \n-    var retryView: ComprehensionFailure?\n-    \n-    var blockerScreen: AppUpdateBlocker?\n-    var passcodeParentControllerWhileSetup: UIViewController?\n-    \n-    var consentToken: String? = \"\" //to be used in case of ineligible\n-    \n-    //Register Remote Notification\n-    func askForNotification() {\n-        \n-        if #available(iOS 10.0, *) {\n-            let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n-            UNUserNotificationCenter.current().requestAuthorization(\n-                options: authOptions,\n-                completionHandler: {_, _ in })\n-            \n-            // For iOS 10 display notification (sent via APNS)\n-            UNUserNotificationCenter.current().delegate = self\n-            \n-        }else {\n-            let settings: UIUserNotificationSettings =\n-                UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)\n-            UIApplication.shared.registerUserNotificationSettings(settings)\n-        }\n-        UIApplication.shared.registerForRemoteNotifications()\n+    UIApplication.shared.registerForRemoteNotifications()\n+  }\n+\n+  /// Updates Key & InitializationVector for Encryption\n+  func updateKeyAndInitializationVector() {\n+\n+    let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n+    let currentIndex = currentDate.index(currentDate.endIndex, offsetBy: -13)\n+    let subStringFromDate = String(currentDate[..<currentIndex])\n+\n+    if User.currentUser.userType == .FDAUser {  // Registered/LogedIn User\n+\n+      let index = User.currentUser.userId.index(User.currentUser.userId.endIndex, offsetBy: -16)\n+      let subKey = String(User.currentUser.userId[..<index])\n+      FDAKeychain.shared[kEncryptionKey] = subKey + subStringFromDate\n+    } else {  // Anonymous User\n+      FDAKeychain.shared[kEncryptionKey] = kEncryptionKey\n     }\n-    \n-    /**\n-     Updates Key & InitializationVector for Encryption\n-     */\n-    func updateKeyAndInitializationVector() {\n-        \n-        let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n-        let currentIndex = currentDate.index(currentDate.endIndex\n-            , offsetBy: -13)\n-        let subStringFromDate = String(currentDate[..<currentIndex])\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if User.currentUser.userType ==  .FDAUser { // Registered/LogedIn User\n-            \n-            let index =  User.currentUser.userId.index(User.currentUser.userId.endIndex\n-                , offsetBy: -16)\n-            let subKey = String(User.currentUser.userId[..<index]) //User.currentUser.userId.substring(to: index ) // 36 - 12 =  24 characters\n-            ud.set(\"\\(subKey + subStringFromDate)\", forKey: kEncryptionKey)\n-            \n-        }else { // Anonymous User\n-            ud.set(currentDate + kDefaultPasscodeString, forKey: kEncryptionKey)\n-        }\n-        \n-        if UIDevice.current.model == kIsIphoneSimulator {\n-            // simulator\n-            ud.set(kdefaultIVForEncryption, forKey: kEncryptionIV)\n-        }else {\n-            // Device\n-            var udid = UIDevice.current.identifierForVendor?.uuidString\n-            let index =  udid?.index((udid?.endIndex)!\n-                , offsetBy: -20)\n-            udid = String((udid?[..<index!])!)//udid?.substring(to: index!)\n-            ud.set(udid, forKey: kEncryptionIV)\n+\n+    if UIDevice.current.model == kIsIphoneSimulator {\n+      FDAKeychain.shared[kEncryptionIV] = kdefaultIVForEncryption\n+    } else {\n+      // Device\n+      var udid = UIDevice.current.identifierForVendor?.uuidString\n+      let index = udid?.index((udid?.endIndex)!, offsetBy: -20)\n+      udid = String((udid?[..<index!])!)\n+      FDAKeychain.shared[kEncryptionIV] = udid\n+    }\n+    //ud.synchronize()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3NzY2NA==", "bodyText": "nit: extra space", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391677664", "createdAt": "2020-03-12T14:54:41Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/AppDelegate.swift", "diffHunk": "@@ -1,1900 +1,1844 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC\n+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import Fabric\n-import Crashlytics\n-import UserNotifications\n-import RealmSwift\n import CallKit\n import IQKeyboardManagerSwift\n+import RealmSwift\n+import UIKit\n+import UserNotifications\n \n-let kEncryptionKey = \"EncryptionKey\"\n-let kEncryptionIV =  \"EncryptionIV\"\n-let kBlockerScreenLabelText = \"Please update to the latest version of app to continue.\"\n-let kConsentUpdatedTitle = \"Consent Updated\"\n+@UIApplicationMain\n \n-let kMessageConsentUpdatedPartTwo = \" Please review the revised Consent terms and provide your Informed Consent, to continue participating in the study.\"\n+class AppDelegate: UIResponder, UIApplicationDelegate {\n \n-let kMessageConsentUpdated = \"The Consent Document for this study has been updated.\" + kMessageConsentUpdatedPartTwo\n+  var window: UIWindow?\n \n-let kReviewTitle = \"Review\"\n-let kPasscodeStepIdentifier = \"PasscodeStep\"\n-let kPasscodeTaskIdentifier = \"PassCodeTask\"\n-let kMessagePasscode = \"Passcode\"\n-let kMessagePasscodeSignOut = \"You will be signed out and will need to sign in again. Are you sure you want to proceed?\"\n-let kNewProgressViewNIB = \"NewProgressView\"\n-let kforgotPasscodeTitle = \"Forgot Passcode? Sign In Again\"\n-let kStudyStoryboard = \"Study\"\n-let kPasscodeSetUpText = \"Set up a passcode for the app\"\n-let kIphoneSimulator =  \"iPhone Simulator\"\n+  var notificationDetails: [String: Any]? = [String: Any]()\n \n-let kBundleIdentier = \"CFBundleIdentifier\"\n-let kPDFCreationNotificationId = \"pdfCreationNotificationIdentifier\"\n-let ksetUpTimeIdentifier = \"setUPTime\"\n-let kCFBundleShortVersion = \"CFBundleShortVersionString\"\n+  var appIsResignedButDidNotEnteredBackground: Bool? = false\n \n-let kResultCount = \"resultCount\"\n-let kResultsForAppStore = \"results\"\n-let kAppStoreVersion = \"version\"\n+  var alertVCPresented: UIAlertController?\n \n-let kContinueButtonTitle =  NSLocalizedString(\"Continue\", comment:\"\")\n-let kType = \"type\"\n+  var isPasscodePresented: Bool? = false\n \n-let kCurrentVersion = \"currentVersion\"\n-let kForceUpdate = \"forceUpdate\"\n-let kMessage = \"message\"\n-let kVisualStepId = \"visual\"\n-let kMessageString = \"Message\"\n+  var isComprehensionFailed: Bool? = false\n \n+  var parentViewControllerForAlert: UIViewController?\n \n-@UIApplicationMain\n+  var iscomingFromForgotPasscode: Bool? = false\n \n-class AppDelegate: UIResponder, UIApplicationDelegate {\n-    \n-    var window: UIWindow?\n-    \n-    var notificationDetails:Dictionary<String,Any>? = Dictionary<String,Any>()\n-    \n-    var appIsResignedButDidNotEnteredBackground:Bool? = false\n-    \n-    var alertVCPresented:UIAlertController?\n-    \n-    var isPasscodePresented:Bool? =  false\n-    \n-    var isComprehensionFailed:Bool? = false\n-    \n-    var parentViewControllerForAlert:UIViewController?\n-    \n-    var iscomingFromForgotPasscode:Bool? =  false\n-    \n-    var isAppLaunched: Bool? = false\n-    \n-    let healthStore = HKHealthStore()\n-    var containerViewController: ResearchContainerViewController? {\n-        return window?.rootViewController as? ResearchContainerViewController\n+  var isAppLaunched: Bool? = false\n+\n+  let healthStore = HKHealthStore()\n+\n+  var containerViewController: ResearchContainerViewController? {\n+    return window?.rootViewController as? ResearchContainerViewController\n+  }\n+\n+  var selectedController: UIViewController?\n+\n+  var shouldAddForceUpgradeScreen = false\n+\n+  var retryView: ComprehensionFailure?\n+\n+  var blockerScreen: AppUpdateBlocker?\n+  var passcodeParentControllerWhileSetup: UIViewController?\n+\n+  /// to be used in case of ineligible\n+  var consentToken: String? = \"\"\n+\n+  /// Register for Remote Notification\n+  func askForNotification() {\n+\n+    if #available(iOS 10.0, *) {\n+      let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n+      UNUserNotificationCenter.current().requestAuthorization(\n+        options: authOptions,\n+        completionHandler: { _, _ in })\n+\n+      // For iOS 10 display notification (sent via APNS)\n+      UNUserNotificationCenter.current().delegate = self\n+\n+    } else {\n+      let settings: UIUserNotificationSettings = UIUserNotificationSettings(\n+        types: [.alert, .badge, .sound], categories: nil)\n+      UIApplication.shared.registerUserNotificationSettings(settings)\n     }\n-    \n-    var selectedController: UIViewController?\n-    \n-    var shouldAddForceUpgradeScreen = false\n-    \n-    var retryView: ComprehensionFailure?\n-    \n-    var blockerScreen: AppUpdateBlocker?\n-    var passcodeParentControllerWhileSetup: UIViewController?\n-    \n-    var consentToken: String? = \"\" //to be used in case of ineligible\n-    \n-    //Register Remote Notification\n-    func askForNotification() {\n-        \n-        if #available(iOS 10.0, *) {\n-            let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n-            UNUserNotificationCenter.current().requestAuthorization(\n-                options: authOptions,\n-                completionHandler: {_, _ in })\n-            \n-            // For iOS 10 display notification (sent via APNS)\n-            UNUserNotificationCenter.current().delegate = self\n-            \n-        }else {\n-            let settings: UIUserNotificationSettings =\n-                UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)\n-            UIApplication.shared.registerUserNotificationSettings(settings)\n-        }\n-        UIApplication.shared.registerForRemoteNotifications()\n+    UIApplication.shared.registerForRemoteNotifications()\n+  }\n+\n+  /// Updates Key & InitializationVector for Encryption\n+  func updateKeyAndInitializationVector() {\n+\n+    let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n+    let currentIndex = currentDate.index(currentDate.endIndex, offsetBy: -13)\n+    let subStringFromDate = String(currentDate[..<currentIndex])\n+\n+    if User.currentUser.userType == .FDAUser {  // Registered/LogedIn User\n+\n+      let index = User.currentUser.userId.index(User.currentUser.userId.endIndex, offsetBy: -16)\n+      let subKey = String(User.currentUser.userId[..<index])\n+      FDAKeychain.shared[kEncryptionKey] = subKey + subStringFromDate\n+    } else {  // Anonymous User\n+      FDAKeychain.shared[kEncryptionKey] = kEncryptionKey\n     }\n-    \n-    /**\n-     Updates Key & InitializationVector for Encryption\n-     */\n-    func updateKeyAndInitializationVector() {\n-        \n-        let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n-        let currentIndex = currentDate.index(currentDate.endIndex\n-            , offsetBy: -13)\n-        let subStringFromDate = String(currentDate[..<currentIndex])\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if User.currentUser.userType ==  .FDAUser { // Registered/LogedIn User\n-            \n-            let index =  User.currentUser.userId.index(User.currentUser.userId.endIndex\n-                , offsetBy: -16)\n-            let subKey = String(User.currentUser.userId[..<index]) //User.currentUser.userId.substring(to: index ) // 36 - 12 =  24 characters\n-            ud.set(\"\\(subKey + subStringFromDate)\", forKey: kEncryptionKey)\n-            \n-        }else { // Anonymous User\n-            ud.set(currentDate + kDefaultPasscodeString, forKey: kEncryptionKey)\n-        }\n-        \n-        if UIDevice.current.model == kIsIphoneSimulator {\n-            // simulator\n-            ud.set(kdefaultIVForEncryption, forKey: kEncryptionIV)\n-        }else {\n-            // Device\n-            var udid = UIDevice.current.identifierForVendor?.uuidString\n-            let index =  udid?.index((udid?.endIndex)!\n-                , offsetBy: -20)\n-            udid = String((udid?[..<index!])!)//udid?.substring(to: index!)\n-            ud.set(udid, forKey: kEncryptionIV)\n+\n+    if UIDevice.current.model == kIsIphoneSimulator {\n+      FDAKeychain.shared[kEncryptionIV] = kdefaultIVForEncryption\n+    } else {\n+      // Device\n+      var udid = UIDevice.current.identifierForVendor?.uuidString\n+      let index = udid?.index((udid?.endIndex)!, offsetBy: -20)\n+      udid = String((udid?[..<index!])!)\n+      FDAKeychain.shared[kEncryptionIV] = udid\n+    }\n+    //ud.synchronize()\n+  }\n+\n+  /// Handler for TimeZone changes, updates time zone in the local database\n+  func calculateTimeZoneChange() {\n+\n+    let timeZoneCurrent = TimeZone.current\n+    let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n+\n+    // Saving TimeZone to User Defaults\n+    let ud = UserDefaults.standard\n+    let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n+\n+    // Saving time difference\n+    if setuptimeDiff == nil {\n+      ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n+      ud.set(0, forKey: \"offset\")\n+\n+    } else {\n+\n+      let difference = differenceFromCurrent - setuptimeDiff!\n+      ud.set(difference, forKey: \"offset\")\n+      if difference == 0 {\n+        // Do Nothing\n+      } else {\n+\n+        Schedule._formatter = nil\n+        Schedule._formatter2 = nil\n+      }\n+    }\n+    ud.synchronize()\n+  }\n+\n+  // MARK: - Realm Migragion\n+  func generateRealmKeys() {\n+\n+    // Realm Encryption key generation\n+    if FDAKeychain.shared[kRealmEncryptionKeychainKey] == nil {\n+      // Generate 64 bytes of random data to serve as the encryption key\n+      var realmKey = kRealmEncryptionDefaultKey\n+      var key = Data(count: 64)\n+      let result = key.withUnsafeMutableBytes {\n+        SecRandomCopyBytes(kSecRandomDefault, 64, $0.baseAddress!)\n+      }\n+      if result == errSecSuccess {\n+        realmKey = key.base64EncodedString()\n+      } else {\n+        Logger.sharedInstance.info(\"Problem generating random bytes\")\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3ODc2OQ==", "bodyText": "nit: spacing is a bit inconsistent, please run the formatter to fix spacing.", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391678769", "createdAt": "2020-03-12T14:56:13Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/AppDelegate.swift", "diffHunk": "@@ -1,1900 +1,1844 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC\n+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import Fabric\n-import Crashlytics\n-import UserNotifications\n-import RealmSwift\n import CallKit\n import IQKeyboardManagerSwift\n+import RealmSwift\n+import UIKit\n+import UserNotifications\n \n-let kEncryptionKey = \"EncryptionKey\"\n-let kEncryptionIV =  \"EncryptionIV\"\n-let kBlockerScreenLabelText = \"Please update to the latest version of app to continue.\"\n-let kConsentUpdatedTitle = \"Consent Updated\"\n+@UIApplicationMain\n \n-let kMessageConsentUpdatedPartTwo = \" Please review the revised Consent terms and provide your Informed Consent, to continue participating in the study.\"\n+class AppDelegate: UIResponder, UIApplicationDelegate {\n \n-let kMessageConsentUpdated = \"The Consent Document for this study has been updated.\" + kMessageConsentUpdatedPartTwo\n+  var window: UIWindow?\n \n-let kReviewTitle = \"Review\"\n-let kPasscodeStepIdentifier = \"PasscodeStep\"\n-let kPasscodeTaskIdentifier = \"PassCodeTask\"\n-let kMessagePasscode = \"Passcode\"\n-let kMessagePasscodeSignOut = \"You will be signed out and will need to sign in again. Are you sure you want to proceed?\"\n-let kNewProgressViewNIB = \"NewProgressView\"\n-let kforgotPasscodeTitle = \"Forgot Passcode? Sign In Again\"\n-let kStudyStoryboard = \"Study\"\n-let kPasscodeSetUpText = \"Set up a passcode for the app\"\n-let kIphoneSimulator =  \"iPhone Simulator\"\n+  var notificationDetails: [String: Any]? = [String: Any]()\n \n-let kBundleIdentier = \"CFBundleIdentifier\"\n-let kPDFCreationNotificationId = \"pdfCreationNotificationIdentifier\"\n-let ksetUpTimeIdentifier = \"setUPTime\"\n-let kCFBundleShortVersion = \"CFBundleShortVersionString\"\n+  var appIsResignedButDidNotEnteredBackground: Bool? = false\n \n-let kResultCount = \"resultCount\"\n-let kResultsForAppStore = \"results\"\n-let kAppStoreVersion = \"version\"\n+  var alertVCPresented: UIAlertController?\n \n-let kContinueButtonTitle =  NSLocalizedString(\"Continue\", comment:\"\")\n-let kType = \"type\"\n+  var isPasscodePresented: Bool? = false\n \n-let kCurrentVersion = \"currentVersion\"\n-let kForceUpdate = \"forceUpdate\"\n-let kMessage = \"message\"\n-let kVisualStepId = \"visual\"\n-let kMessageString = \"Message\"\n+  var isComprehensionFailed: Bool? = false\n \n+  var parentViewControllerForAlert: UIViewController?\n \n-@UIApplicationMain\n+  var iscomingFromForgotPasscode: Bool? = false\n \n-class AppDelegate: UIResponder, UIApplicationDelegate {\n-    \n-    var window: UIWindow?\n-    \n-    var notificationDetails:Dictionary<String,Any>? = Dictionary<String,Any>()\n-    \n-    var appIsResignedButDidNotEnteredBackground:Bool? = false\n-    \n-    var alertVCPresented:UIAlertController?\n-    \n-    var isPasscodePresented:Bool? =  false\n-    \n-    var isComprehensionFailed:Bool? = false\n-    \n-    var parentViewControllerForAlert:UIViewController?\n-    \n-    var iscomingFromForgotPasscode:Bool? =  false\n-    \n-    var isAppLaunched: Bool? = false\n-    \n-    let healthStore = HKHealthStore()\n-    var containerViewController: ResearchContainerViewController? {\n-        return window?.rootViewController as? ResearchContainerViewController\n+  var isAppLaunched: Bool? = false\n+\n+  let healthStore = HKHealthStore()\n+\n+  var containerViewController: ResearchContainerViewController? {\n+    return window?.rootViewController as? ResearchContainerViewController\n+  }\n+\n+  var selectedController: UIViewController?\n+\n+  var shouldAddForceUpgradeScreen = false\n+\n+  var retryView: ComprehensionFailure?\n+\n+  var blockerScreen: AppUpdateBlocker?\n+  var passcodeParentControllerWhileSetup: UIViewController?\n+\n+  /// to be used in case of ineligible\n+  var consentToken: String? = \"\"\n+\n+  /// Register for Remote Notification\n+  func askForNotification() {\n+\n+    if #available(iOS 10.0, *) {\n+      let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n+      UNUserNotificationCenter.current().requestAuthorization(\n+        options: authOptions,\n+        completionHandler: { _, _ in })\n+\n+      // For iOS 10 display notification (sent via APNS)\n+      UNUserNotificationCenter.current().delegate = self\n+\n+    } else {\n+      let settings: UIUserNotificationSettings = UIUserNotificationSettings(\n+        types: [.alert, .badge, .sound], categories: nil)\n+      UIApplication.shared.registerUserNotificationSettings(settings)\n     }\n-    \n-    var selectedController: UIViewController?\n-    \n-    var shouldAddForceUpgradeScreen = false\n-    \n-    var retryView: ComprehensionFailure?\n-    \n-    var blockerScreen: AppUpdateBlocker?\n-    var passcodeParentControllerWhileSetup: UIViewController?\n-    \n-    var consentToken: String? = \"\" //to be used in case of ineligible\n-    \n-    //Register Remote Notification\n-    func askForNotification() {\n-        \n-        if #available(iOS 10.0, *) {\n-            let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n-            UNUserNotificationCenter.current().requestAuthorization(\n-                options: authOptions,\n-                completionHandler: {_, _ in })\n-            \n-            // For iOS 10 display notification (sent via APNS)\n-            UNUserNotificationCenter.current().delegate = self\n-            \n-        }else {\n-            let settings: UIUserNotificationSettings =\n-                UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)\n-            UIApplication.shared.registerUserNotificationSettings(settings)\n-        }\n-        UIApplication.shared.registerForRemoteNotifications()\n+    UIApplication.shared.registerForRemoteNotifications()\n+  }\n+\n+  /// Updates Key & InitializationVector for Encryption\n+  func updateKeyAndInitializationVector() {\n+\n+    let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n+    let currentIndex = currentDate.index(currentDate.endIndex, offsetBy: -13)\n+    let subStringFromDate = String(currentDate[..<currentIndex])\n+\n+    if User.currentUser.userType == .FDAUser {  // Registered/LogedIn User\n+\n+      let index = User.currentUser.userId.index(User.currentUser.userId.endIndex, offsetBy: -16)\n+      let subKey = String(User.currentUser.userId[..<index])\n+      FDAKeychain.shared[kEncryptionKey] = subKey + subStringFromDate\n+    } else {  // Anonymous User\n+      FDAKeychain.shared[kEncryptionKey] = kEncryptionKey\n     }\n-    \n-    /**\n-     Updates Key & InitializationVector for Encryption\n-     */\n-    func updateKeyAndInitializationVector() {\n-        \n-        let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n-        let currentIndex = currentDate.index(currentDate.endIndex\n-            , offsetBy: -13)\n-        let subStringFromDate = String(currentDate[..<currentIndex])\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if User.currentUser.userType ==  .FDAUser { // Registered/LogedIn User\n-            \n-            let index =  User.currentUser.userId.index(User.currentUser.userId.endIndex\n-                , offsetBy: -16)\n-            let subKey = String(User.currentUser.userId[..<index]) //User.currentUser.userId.substring(to: index ) // 36 - 12 =  24 characters\n-            ud.set(\"\\(subKey + subStringFromDate)\", forKey: kEncryptionKey)\n-            \n-        }else { // Anonymous User\n-            ud.set(currentDate + kDefaultPasscodeString, forKey: kEncryptionKey)\n-        }\n-        \n-        if UIDevice.current.model == kIsIphoneSimulator {\n-            // simulator\n-            ud.set(kdefaultIVForEncryption, forKey: kEncryptionIV)\n-        }else {\n-            // Device\n-            var udid = UIDevice.current.identifierForVendor?.uuidString\n-            let index =  udid?.index((udid?.endIndex)!\n-                , offsetBy: -20)\n-            udid = String((udid?[..<index!])!)//udid?.substring(to: index!)\n-            ud.set(udid, forKey: kEncryptionIV)\n+\n+    if UIDevice.current.model == kIsIphoneSimulator {\n+      FDAKeychain.shared[kEncryptionIV] = kdefaultIVForEncryption\n+    } else {\n+      // Device\n+      var udid = UIDevice.current.identifierForVendor?.uuidString\n+      let index = udid?.index((udid?.endIndex)!, offsetBy: -20)\n+      udid = String((udid?[..<index!])!)\n+      FDAKeychain.shared[kEncryptionIV] = udid\n+    }\n+    //ud.synchronize()\n+  }\n+\n+  /// Handler for TimeZone changes, updates time zone in the local database\n+  func calculateTimeZoneChange() {\n+\n+    let timeZoneCurrent = TimeZone.current\n+    let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n+\n+    // Saving TimeZone to User Defaults\n+    let ud = UserDefaults.standard\n+    let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n+\n+    // Saving time difference\n+    if setuptimeDiff == nil {\n+      ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n+      ud.set(0, forKey: \"offset\")\n+\n+    } else {\n+\n+      let difference = differenceFromCurrent - setuptimeDiff!\n+      ud.set(difference, forKey: \"offset\")\n+      if difference == 0 {\n+        // Do Nothing\n+      } else {\n+\n+        Schedule._formatter = nil\n+        Schedule._formatter2 = nil\n+      }\n+    }\n+    ud.synchronize()\n+  }\n+\n+  // MARK: - Realm Migragion\n+  func generateRealmKeys() {\n+\n+    // Realm Encryption key generation\n+    if FDAKeychain.shared[kRealmEncryptionKeychainKey] == nil {\n+      // Generate 64 bytes of random data to serve as the encryption key\n+      var realmKey = kRealmEncryptionDefaultKey\n+      var key = Data(count: 64)\n+      let result = key.withUnsafeMutableBytes {\n+        SecRandomCopyBytes(kSecRandomDefault, 64, $0.baseAddress!)\n+      }\n+      if result == errSecSuccess {\n+        realmKey = key.base64EncodedString()\n+      } else {\n+        Logger.sharedInstance.info(\"Problem generating random bytes\")\n+\n+      }\n+      FDAKeychain.shared[kRealmEncryptionKeychainKey] = realmKey\n+    }\n+  }\n+\n+  func checkForRealmMigration() {\n+\n+    self.generateRealmKeys()\n+\n+    let key = FDAKeychain.shared[kRealmEncryptionKeychainKey]\n+    let keyData = Data.init(base64Encoded: key!)\n+\n+    let config = Realm.Configuration(\n+      encryptionKey: keyData,\n+      schemaVersion: 1,\n+      migrationBlock: { _, oldSchemaVersion in\n+        // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n+        if oldSchemaVersion < 1 {\n+          // Nothing to do!\n+          // Realm will automatically detect new properties and removed properties\n+          // And will update the schema on disk automatically\n         }\n+      })\n+\n+    // Tell Realm to use this new configuration object for the default Realm\n+    Realm.Configuration.defaultConfiguration = config\n+  }\n+\n+  // MARK: - App Delegates methods\n+\n+  func application(\n+    _ application: UIApplication,\n+    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n+  ) -> Bool {\n+    // Override point for customization after application launch.\n+\n+    self.isAppLaunched = true\n+    IQKeyboardManager.shared.enable = true\n+    Logger.sharedInstance.info(Utilities.isStandaloneApp(), \"Standalone\")\n+    self.customizeNavigationBar()\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+\n+    //Check For Updates\n+    self.checkForAppUpdate()\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    SyncUpdate.currentSyncUpdate = SyncUpdate()\n+\n+    // Register observer for Network change\n+    NotificationCenter.default.addObserver(\n+      SyncUpdate.currentSyncUpdate as Any,\n+      selector: #selector(SyncUpdate.currentSyncUpdate?.updateData),\n+      name: ReachabilityChangedNotification, object: nil)\n+\n+    let ud1 = UserDefaults.standard\n+\n+    // Check if App is launched because of Notification Received\n+    if launchOptions != nil && launchOptions?[.sourceApplication] == nil {\n+\n+      ud1.set(\"not null\", forKey: \"launch\")\n+\n+      // Launched from push notification\n+      let notification = launchOptions?[.remoteNotification]\n+\n+      if Utilities.isValidObject(someObject: notification as AnyObject) {  // Launched from Remote Notification\n+\n+        notificationDetails = notification as? [String: Any]\n+\n+        let ud = UserDefaults.standard\n+        ud.set(true, forKey: kShowNotification)\n         ud.synchronize()\n-    }\n-    \n-    /**\n-     Handler for TimeZone changes, updates time zone in the local database\n-     */\n-    func calculateTimeZoneChange() {\n-        \n-        //let date = Date().utcDate()\n-        \n-        //let timeZoneUTC = TimeZone(abbreviation: \"UTC\")\n-        //let timeZoneAutoCurrent = TimeZone.autoupdatingCurrent\n-        let timeZoneCurrent = TimeZone.current\n-        \n-        //let differenceFromUTC = timeZoneUTC?.secondsFromGMT()\n-        let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n-        //let differenceFromAutoCurrent = timeZoneCurrent.secondsFromGMT()\n-        \n-        //Saving TimeZone to User Defaults\n+\n+      } else {  // Regular Launch\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 396}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4NDIyMw==", "bodyText": "error logs should be logged as error", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391684223", "createdAt": "2020-03-12T15:03:46Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/AppDelegate.swift", "diffHunk": "@@ -1,1900 +1,1844 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC\n+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import Fabric\n-import Crashlytics\n-import UserNotifications\n-import RealmSwift\n import CallKit\n import IQKeyboardManagerSwift\n+import RealmSwift\n+import UIKit\n+import UserNotifications\n \n-let kEncryptionKey = \"EncryptionKey\"\n-let kEncryptionIV =  \"EncryptionIV\"\n-let kBlockerScreenLabelText = \"Please update to the latest version of app to continue.\"\n-let kConsentUpdatedTitle = \"Consent Updated\"\n+@UIApplicationMain\n \n-let kMessageConsentUpdatedPartTwo = \" Please review the revised Consent terms and provide your Informed Consent, to continue participating in the study.\"\n+class AppDelegate: UIResponder, UIApplicationDelegate {\n \n-let kMessageConsentUpdated = \"The Consent Document for this study has been updated.\" + kMessageConsentUpdatedPartTwo\n+  var window: UIWindow?\n \n-let kReviewTitle = \"Review\"\n-let kPasscodeStepIdentifier = \"PasscodeStep\"\n-let kPasscodeTaskIdentifier = \"PassCodeTask\"\n-let kMessagePasscode = \"Passcode\"\n-let kMessagePasscodeSignOut = \"You will be signed out and will need to sign in again. Are you sure you want to proceed?\"\n-let kNewProgressViewNIB = \"NewProgressView\"\n-let kforgotPasscodeTitle = \"Forgot Passcode? Sign In Again\"\n-let kStudyStoryboard = \"Study\"\n-let kPasscodeSetUpText = \"Set up a passcode for the app\"\n-let kIphoneSimulator =  \"iPhone Simulator\"\n+  var notificationDetails: [String: Any]? = [String: Any]()\n \n-let kBundleIdentier = \"CFBundleIdentifier\"\n-let kPDFCreationNotificationId = \"pdfCreationNotificationIdentifier\"\n-let ksetUpTimeIdentifier = \"setUPTime\"\n-let kCFBundleShortVersion = \"CFBundleShortVersionString\"\n+  var appIsResignedButDidNotEnteredBackground: Bool? = false\n \n-let kResultCount = \"resultCount\"\n-let kResultsForAppStore = \"results\"\n-let kAppStoreVersion = \"version\"\n+  var alertVCPresented: UIAlertController?\n \n-let kContinueButtonTitle =  NSLocalizedString(\"Continue\", comment:\"\")\n-let kType = \"type\"\n+  var isPasscodePresented: Bool? = false\n \n-let kCurrentVersion = \"currentVersion\"\n-let kForceUpdate = \"forceUpdate\"\n-let kMessage = \"message\"\n-let kVisualStepId = \"visual\"\n-let kMessageString = \"Message\"\n+  var isComprehensionFailed: Bool? = false\n \n+  var parentViewControllerForAlert: UIViewController?\n \n-@UIApplicationMain\n+  var iscomingFromForgotPasscode: Bool? = false\n \n-class AppDelegate: UIResponder, UIApplicationDelegate {\n-    \n-    var window: UIWindow?\n-    \n-    var notificationDetails:Dictionary<String,Any>? = Dictionary<String,Any>()\n-    \n-    var appIsResignedButDidNotEnteredBackground:Bool? = false\n-    \n-    var alertVCPresented:UIAlertController?\n-    \n-    var isPasscodePresented:Bool? =  false\n-    \n-    var isComprehensionFailed:Bool? = false\n-    \n-    var parentViewControllerForAlert:UIViewController?\n-    \n-    var iscomingFromForgotPasscode:Bool? =  false\n-    \n-    var isAppLaunched: Bool? = false\n-    \n-    let healthStore = HKHealthStore()\n-    var containerViewController: ResearchContainerViewController? {\n-        return window?.rootViewController as? ResearchContainerViewController\n+  var isAppLaunched: Bool? = false\n+\n+  let healthStore = HKHealthStore()\n+\n+  var containerViewController: ResearchContainerViewController? {\n+    return window?.rootViewController as? ResearchContainerViewController\n+  }\n+\n+  var selectedController: UIViewController?\n+\n+  var shouldAddForceUpgradeScreen = false\n+\n+  var retryView: ComprehensionFailure?\n+\n+  var blockerScreen: AppUpdateBlocker?\n+  var passcodeParentControllerWhileSetup: UIViewController?\n+\n+  /// to be used in case of ineligible\n+  var consentToken: String? = \"\"\n+\n+  /// Register for Remote Notification\n+  func askForNotification() {\n+\n+    if #available(iOS 10.0, *) {\n+      let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n+      UNUserNotificationCenter.current().requestAuthorization(\n+        options: authOptions,\n+        completionHandler: { _, _ in })\n+\n+      // For iOS 10 display notification (sent via APNS)\n+      UNUserNotificationCenter.current().delegate = self\n+\n+    } else {\n+      let settings: UIUserNotificationSettings = UIUserNotificationSettings(\n+        types: [.alert, .badge, .sound], categories: nil)\n+      UIApplication.shared.registerUserNotificationSettings(settings)\n     }\n-    \n-    var selectedController: UIViewController?\n-    \n-    var shouldAddForceUpgradeScreen = false\n-    \n-    var retryView: ComprehensionFailure?\n-    \n-    var blockerScreen: AppUpdateBlocker?\n-    var passcodeParentControllerWhileSetup: UIViewController?\n-    \n-    var consentToken: String? = \"\" //to be used in case of ineligible\n-    \n-    //Register Remote Notification\n-    func askForNotification() {\n-        \n-        if #available(iOS 10.0, *) {\n-            let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n-            UNUserNotificationCenter.current().requestAuthorization(\n-                options: authOptions,\n-                completionHandler: {_, _ in })\n-            \n-            // For iOS 10 display notification (sent via APNS)\n-            UNUserNotificationCenter.current().delegate = self\n-            \n-        }else {\n-            let settings: UIUserNotificationSettings =\n-                UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)\n-            UIApplication.shared.registerUserNotificationSettings(settings)\n-        }\n-        UIApplication.shared.registerForRemoteNotifications()\n+    UIApplication.shared.registerForRemoteNotifications()\n+  }\n+\n+  /// Updates Key & InitializationVector for Encryption\n+  func updateKeyAndInitializationVector() {\n+\n+    let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n+    let currentIndex = currentDate.index(currentDate.endIndex, offsetBy: -13)\n+    let subStringFromDate = String(currentDate[..<currentIndex])\n+\n+    if User.currentUser.userType == .FDAUser {  // Registered/LogedIn User\n+\n+      let index = User.currentUser.userId.index(User.currentUser.userId.endIndex, offsetBy: -16)\n+      let subKey = String(User.currentUser.userId[..<index])\n+      FDAKeychain.shared[kEncryptionKey] = subKey + subStringFromDate\n+    } else {  // Anonymous User\n+      FDAKeychain.shared[kEncryptionKey] = kEncryptionKey\n     }\n-    \n-    /**\n-     Updates Key & InitializationVector for Encryption\n-     */\n-    func updateKeyAndInitializationVector() {\n-        \n-        let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n-        let currentIndex = currentDate.index(currentDate.endIndex\n-            , offsetBy: -13)\n-        let subStringFromDate = String(currentDate[..<currentIndex])\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if User.currentUser.userType ==  .FDAUser { // Registered/LogedIn User\n-            \n-            let index =  User.currentUser.userId.index(User.currentUser.userId.endIndex\n-                , offsetBy: -16)\n-            let subKey = String(User.currentUser.userId[..<index]) //User.currentUser.userId.substring(to: index ) // 36 - 12 =  24 characters\n-            ud.set(\"\\(subKey + subStringFromDate)\", forKey: kEncryptionKey)\n-            \n-        }else { // Anonymous User\n-            ud.set(currentDate + kDefaultPasscodeString, forKey: kEncryptionKey)\n-        }\n-        \n-        if UIDevice.current.model == kIsIphoneSimulator {\n-            // simulator\n-            ud.set(kdefaultIVForEncryption, forKey: kEncryptionIV)\n-        }else {\n-            // Device\n-            var udid = UIDevice.current.identifierForVendor?.uuidString\n-            let index =  udid?.index((udid?.endIndex)!\n-                , offsetBy: -20)\n-            udid = String((udid?[..<index!])!)//udid?.substring(to: index!)\n-            ud.set(udid, forKey: kEncryptionIV)\n+\n+    if UIDevice.current.model == kIsIphoneSimulator {\n+      FDAKeychain.shared[kEncryptionIV] = kdefaultIVForEncryption\n+    } else {\n+      // Device\n+      var udid = UIDevice.current.identifierForVendor?.uuidString\n+      let index = udid?.index((udid?.endIndex)!, offsetBy: -20)\n+      udid = String((udid?[..<index!])!)\n+      FDAKeychain.shared[kEncryptionIV] = udid\n+    }\n+    //ud.synchronize()\n+  }\n+\n+  /// Handler for TimeZone changes, updates time zone in the local database\n+  func calculateTimeZoneChange() {\n+\n+    let timeZoneCurrent = TimeZone.current\n+    let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n+\n+    // Saving TimeZone to User Defaults\n+    let ud = UserDefaults.standard\n+    let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n+\n+    // Saving time difference\n+    if setuptimeDiff == nil {\n+      ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n+      ud.set(0, forKey: \"offset\")\n+\n+    } else {\n+\n+      let difference = differenceFromCurrent - setuptimeDiff!\n+      ud.set(difference, forKey: \"offset\")\n+      if difference == 0 {\n+        // Do Nothing\n+      } else {\n+\n+        Schedule._formatter = nil\n+        Schedule._formatter2 = nil\n+      }\n+    }\n+    ud.synchronize()\n+  }\n+\n+  // MARK: - Realm Migragion\n+  func generateRealmKeys() {\n+\n+    // Realm Encryption key generation\n+    if FDAKeychain.shared[kRealmEncryptionKeychainKey] == nil {\n+      // Generate 64 bytes of random data to serve as the encryption key\n+      var realmKey = kRealmEncryptionDefaultKey\n+      var key = Data(count: 64)\n+      let result = key.withUnsafeMutableBytes {\n+        SecRandomCopyBytes(kSecRandomDefault, 64, $0.baseAddress!)\n+      }\n+      if result == errSecSuccess {\n+        realmKey = key.base64EncodedString()\n+      } else {\n+        Logger.sharedInstance.info(\"Problem generating random bytes\")\n+\n+      }\n+      FDAKeychain.shared[kRealmEncryptionKeychainKey] = realmKey\n+    }\n+  }\n+\n+  func checkForRealmMigration() {\n+\n+    self.generateRealmKeys()\n+\n+    let key = FDAKeychain.shared[kRealmEncryptionKeychainKey]\n+    let keyData = Data.init(base64Encoded: key!)\n+\n+    let config = Realm.Configuration(\n+      encryptionKey: keyData,\n+      schemaVersion: 1,\n+      migrationBlock: { _, oldSchemaVersion in\n+        // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n+        if oldSchemaVersion < 1 {\n+          // Nothing to do!\n+          // Realm will automatically detect new properties and removed properties\n+          // And will update the schema on disk automatically\n         }\n+      })\n+\n+    // Tell Realm to use this new configuration object for the default Realm\n+    Realm.Configuration.defaultConfiguration = config\n+  }\n+\n+  // MARK: - App Delegates methods\n+\n+  func application(\n+    _ application: UIApplication,\n+    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n+  ) -> Bool {\n+    // Override point for customization after application launch.\n+\n+    self.isAppLaunched = true\n+    IQKeyboardManager.shared.enable = true\n+    Logger.sharedInstance.info(Utilities.isStandaloneApp(), \"Standalone\")\n+    self.customizeNavigationBar()\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+\n+    //Check For Updates\n+    self.checkForAppUpdate()\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    SyncUpdate.currentSyncUpdate = SyncUpdate()\n+\n+    // Register observer for Network change\n+    NotificationCenter.default.addObserver(\n+      SyncUpdate.currentSyncUpdate as Any,\n+      selector: #selector(SyncUpdate.currentSyncUpdate?.updateData),\n+      name: ReachabilityChangedNotification, object: nil)\n+\n+    let ud1 = UserDefaults.standard\n+\n+    // Check if App is launched because of Notification Received\n+    if launchOptions != nil && launchOptions?[.sourceApplication] == nil {\n+\n+      ud1.set(\"not null\", forKey: \"launch\")\n+\n+      // Launched from push notification\n+      let notification = launchOptions?[.remoteNotification]\n+\n+      if Utilities.isValidObject(someObject: notification as AnyObject) {  // Launched from Remote Notification\n+\n+        notificationDetails = notification as? [String: Any]\n+\n+        let ud = UserDefaults.standard\n+        ud.set(true, forKey: kShowNotification)\n         ud.synchronize()\n-    }\n-    \n-    /**\n-     Handler for TimeZone changes, updates time zone in the local database\n-     */\n-    func calculateTimeZoneChange() {\n-        \n-        //let date = Date().utcDate()\n-        \n-        //let timeZoneUTC = TimeZone(abbreviation: \"UTC\")\n-        //let timeZoneAutoCurrent = TimeZone.autoupdatingCurrent\n-        let timeZoneCurrent = TimeZone.current\n-        \n-        //let differenceFromUTC = timeZoneUTC?.secondsFromGMT()\n-        let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n-        //let differenceFromAutoCurrent = timeZoneCurrent.secondsFromGMT()\n-        \n-        //Saving TimeZone to User Defaults\n+\n+      } else {  // Regular Launch\n+\n+        ud1.set(\"invalid\", forKey: \"launch\")\n         let ud = UserDefaults.standard\n-        let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n-        \n-        //Saving time difference\n-        if setuptimeDiff == nil {\n-            ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n-            ud.set(0, forKey: \"offset\")\n-            \n-        }else {\n-            \n-            let difference = differenceFromCurrent - setuptimeDiff!\n-            ud.set(difference, forKey: \"offset\")\n-            if difference == 0 {\n-                // Do Nothing\n-            }else {\n-                \n-                Schedule._formatter = nil\n-                Schedule._formatter2 = nil\n-            }\n-        }\n+        ud.set(false, forKey: kShowNotification)\n         ud.synchronize()\n+      }\n     }\n-    \n-    func checkForAppReopenNotification() {\n-        \n-        //remove if notification is available\n-        LocalNotification.removeReopenAppNotification()\n-        LocalNotification.registerReopenAppNotification()\n-        \n-    }\n-    \n-    // MARK: Realm Migragion\n-    func checkForRealmMigration() {\n-        \n-        let config = Realm.Configuration(\n-            // Set the new schema version. This must be greater than the previously used\n-            // version (if you've never set a schema version before, the version is 0).\n-            schemaVersion: 3,\n-            \n-            // Set the block which will be called automatically when opening a Realm with\n-            // a schema version lower than the one set above\n-            migrationBlock: { migration, oldSchemaVersion in\n-                // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n-                if (oldSchemaVersion < 1) {\n-                    // Nothing to do!\n-                    // Realm will automatically detect new properties and removed properties\n-                    // And will update the schema on disk automatically\n-                }\n-        })\n-        \n-        // Tell Realm to use this new configuration object for the default Realm\n-        Realm.Configuration.defaultConfiguration = config\n-        \n-        // Now that we've told Realm how to handle the schema change, opening the file\n-        // will automatically perform the migration\n-        let _ = try! Realm()\n-    }\n-    \n-    func fireNotiffication(intervel:Int) {\n-        \n-        let content = UNMutableNotificationContent()\n-        content.body = \"message\"\n-        \n-        content.sound = UNNotificationSound.default\n-        content.badge = 1\n-        let date = Date().addingTimeInterval(TimeInterval(intervel))\n-        var timeInterval = date.timeIntervalSinceNow\n-\n-        \n-        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: timeInterval, repeats: false)\n-        let id = Utilities.randomString(length: 10)\n-        let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)\n-        let center = UNUserNotificationCenter.current()\n-        center.add(request)\n-    }\n-    \n-    // MARK: App Delegates\n-    \n-    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n-        // Override point for customization after application launch.\n-        \n-        self.isAppLaunched = true\n-        IQKeyboardManager.shared.enable = true\n-        print(Utilities.isStandaloneApp(),\"standalone\")\n-        self.customizeNavigationBar()\n-        Fabric.with([Crashlytics.self])\n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        \n-        //Check For Updates\n-        //self.checkForAppUpdateForVersion()\n-        self.checkForAppUpdate()\n-        \n-        if UIApplication.shared.applicationIconBadgeNumber > 0 {\n-            UIApplication.shared.applicationIconBadgeNumber = 0\n-        }\n-        \n-        SyncUpdate.currentSyncUpdate = SyncUpdate()\n-        \n-        //Register observer for Network change\n-        NotificationCenter.default.addObserver(SyncUpdate.currentSyncUpdate as Any , selector: #selector(SyncUpdate.currentSyncUpdate?.updateData), name: Notification.Name.reachabilityChanged, object: nil)\n-        \n-        let ud1 = UserDefaults.standard\n-        \n-        //Check if App is launched because of Notification Received\n-        if (launchOptions != nil && launchOptions?[.sourceApplication] == nil) {\n-            \n-            ud1.set(\"not null\", forKey: \"launch\")\n-            \n-            // Launched from push notification\n-            let notification = launchOptions?[.remoteNotification]\n-            \n-            if Utilities.isValidObject(someObject: notification as AnyObject) { // Launched from Remote Notification\n-                \n-                notificationDetails = notification as? Dictionary<String, Any>\n-                \n-                let ud = UserDefaults.standard\n-                ud.set(true, forKey: kShowNotification)\n-                ud.synchronize()\n-                \n-            }else if (launchOptions?[.localNotification] != nil) { //Launched from Local Notification\n-                \n-                ud1.set(\"local\", forKey: \"launch\")\n-                let localNotification = (launchOptions?[.localNotification] as? UILocalNotification)!\n-                let notificationDetails = (localNotification.userInfo as? Dictionary<String, Any>)!\n-                \n-                NotificationHandler.instance.appOpenFromNotification = true\n-                NotificationHandler.instance.studyId = (notificationDetails[kStudyId] as? String)!\n-                NotificationHandler.instance.activityId = (notificationDetails[kActivityId] as? String)!\n-                ud1.synchronize()\n-                \n-            }else { //Regular Launch\n-                \n-                ud1.set(\"invalid\", forKey: \"launch\")\n-                UIApplication.shared.applicationIconBadgeNumber = 0\n-                \n-                let ud = UserDefaults.standard\n-                ud.set(false, forKey: kShowNotification)\n-                ud.synchronize()\n-            }\n-        }\n-        \n-        //self.fireNotiffication(intervel: 10)\n-        //self.fireNotiffication(intervel: 15)\n-        \n-        //Check if Database needs migration\n-        self.checkForRealmMigration()\n-        return true\n-    }\n-    \n-    func applicationWillResignActive(_ application: UIApplication) {\n-        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.\n-        \n-        // set Flag to handle background to foreground transition\n-        self.appIsResignedButDidNotEnteredBackground = true\n-    }\n-    \n-    func applicationDidEnterBackground(_ application: UIApplication) {\n-        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n-        \n-        // set Flag to handle foreground to background transition\n-        self.appIsResignedButDidNotEnteredBackground = false\n-    }\n-    \n-    \n-    func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {\n-    }\n-    \n-    \n-    func applicationWillEnterForeground(_ application: UIApplication) {\n-        \n-        self.checkPasscode(viewController: (application.windows[0].rootViewController)!)\n-        \n-        self.checkForStudyUpdates()\n-        \n-        let number = UIApplication.shared.applicationIconBadgeNumber\n-        if number >= 1 {\n-            self.updateNotification()\n-        }\n-        \n-        //Check For Updates\n-        self.checkForAppUpdate()\n-        \n+\n+    // Check if Database needs migration\n+    self.checkForRealmMigration()\n+    return true\n+  }\n+\n+  func applicationWillResignActive(_ application: UIApplication) {\n+    // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.\n+\n+    // set Flag to handle background to foreground transition\n+    self.appIsResignedButDidNotEnteredBackground = true\n+  }\n+\n+  func applicationDidEnterBackground(_ application: UIApplication) {\n+    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n+\n+    // set Flag to handle foreground to background transition\n+    self.appIsResignedButDidNotEnteredBackground = false\n+  }\n+\n+  func application(\n+    _ application: UIApplication,\n+    performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) ->\n+      Void\n+  ) {\n+  }\n+\n+  func applicationWillEnterForeground(_ application: UIApplication) {\n+\n+    self.checkPasscode(viewController: (application.windows[0].rootViewController)!)\n+    self.checkForStudyUpdates()\n+    let number = UIApplication.shared.applicationIconBadgeNumber\n+    if number >= 1 {\n+      self.updateNotification()\n     }\n-    \n-    func applicationDidBecomeActive(_ application: UIApplication) {\n-        \n-        // self.window?.isHidden = false\n-        \n-        UIApplication.shared.applicationIconBadgeNumber = 0\n-        \n-        if self.appIsResignedButDidNotEnteredBackground! {\n-            \n-            let navController = application.windows[0].rootViewController\n-            \n-            \n-            let isTaskViewControllerVisible = (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKTaskViewController.self)\n-            \n-           // guard let navigation = (navController as? UINavigationController)?.visibleViewController as? ORKTaskViewController, let navigationTitle = navigation.title else {return}\n-            \n-            let navigationTitle = ((navController as? UINavigationController)?.visibleViewController as? ORKTaskViewController)?.title ?? \"\"\n-            \n-            if (navController as? UINavigationController) != nil &&  isTaskViewControllerVisible == false {\n-                \n-                if (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKPasscodeViewController.self) == false {\n-                    //Request for Passcode\n-                    //self.checkPasscode(viewController: navController!)\n-                }\n-                \n-            } else if(navController as? UINavigationController) != nil\n-                &&  isTaskViewControllerVisible == true\n-                && navigationTitle == \"Activity\" {\n-                \n-                if (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKPasscodeViewController.self) == false {\n-                    //Request for Passcode\n-                    //self.checkPasscode(viewController: navController!)\n-                }\n-            } else if(navController as? UIViewController) != nil {\n-               // self.checkPasscode(viewController: navController!)\n-            }\n-        }\n-        \n-        //Check if App running on Jailbreak Device\n-        if AppDelegate.jailbroken(application: application) {\n-            \n-            let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-            let appBlocker = JailbrokeBlocker.instanceFromNib(frame: navigationController.view.frame, detail: nil);\n-            UIApplication.shared.keyWindow?.addSubview(appBlocker);\n-            UIApplication.shared.keyWindow?.bringSubviewToFront(appBlocker)\n-            \n-        }\n-        \n-        //Update TimeZone Changes if any\n-        self.calculateTimeZoneChange()\n-        \n-        if self.isAppLaunched! {\n-            self.isAppLaunched = false\n-            \n-            //Update Local Notifications\n-            self.checkForRegisteredNotifications()\n+\n+    // Check For Updates\n+    self.checkForAppUpdate()\n+\n+  }\n+\n+  func applicationDidBecomeActive(_ application: UIApplication) {\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    if self.appIsResignedButDidNotEnteredBackground! {\n+\n+      let navController = application.windows[0].rootViewController\n+\n+      let isTaskViewControllerVisible = (navController as? UINavigationController)?\n+        .visibleViewController?.isKind(of: ORKTaskViewController.self)\n+\n+      let navigationTitle = (\n+        (navController as? UINavigationController)?.visibleViewController\n+          as? ORKTaskViewController\n+      )?.title ?? \"\"\n+\n+      if (navController as? UINavigationController) != nil && isTaskViewControllerVisible\n+        == false {\n+\n+        if (navController as? UINavigationController)?.visibleViewController?.isKind(\n+          of: ORKPasscodeViewController.self) == false {\n+          // Request for Passcode\n+          self.checkPasscode(viewController: navController!)\n         }\n-    }\n-    \n-    func applicationWillTerminate(_ application: UIApplication) {\n-        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.\n-    }\n-    \n-    // MARK:- NOTIFICATION\n-    \n-    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n-        \n-        let deviceTokenString = deviceToken.reduce(\"\", {$0 + String(format: \"%02X\", $1)})\n-        print(\"Token: \\(deviceTokenString)\")\n-        \n-        if  User.currentUser.userType == .FDAUser {\n-            \n-            User.currentUser.settings?.remoteNotifications = true\n-            User.currentUser.settings?.localNotifications = true\n-            //Update device Token to Local server\n-            UserServices().updateUserProfile(deviceToken: deviceTokenString , delegate: self)\n-            \n+\n+      } else if (navController as? UINavigationController) != nil\n+        && isTaskViewControllerVisible == true\n+        && navigationTitle == \"Activity\" {\n+\n+        if (navController as? UINavigationController)?.visibleViewController?.isKind(\n+          of: ORKPasscodeViewController.self) == false {\n+          // Request for Passcode\n+          self.checkPasscode(viewController: navController!)\n         }\n-        \n+      } else if (navController) != nil {\n+        self.checkPasscode(viewController: navController!)\n+      }\n     }\n-    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {\n-        \n-        print(\"Token Registration failed  \\(error)\")\n-        \n-    }\n-    \n-    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) {\n-        \n-        //For iOS 8 & 9\n-        if (UIApplication.shared.applicationState == .background)||(UIApplication.shared.applicationState == .inactive) {\n-            \n-            self.updateNotification()\n-            self.handleLocalAndRemoteNotification(userInfoDetails: (userInfo as? Dictionary<String, Any>)!)\n-        }\n-        \n-        // userInfo is valid\n-        if userInfo.count > 0 && userInfo.keys.contains(kType) {\n-            self.updateNotification()\n-            \n-        }else {\n-            if (UIApplication.shared.applicationState == .background || (UIApplication.shared.applicationState == .inactive)) {\n-                //Handle local Notification Received\n-                self.handleLocalNotification(userInfoDetails: (userInfo as? Dictionary<String, Any>)!)\n-            }\n-        }\n+\n+    // Check if App running on Jailbreak Device\n+    if AppDelegate.jailbroken(application: application) {\n+\n+      let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+      let appBlocker = JailbrokeBlocker.instanceFromNib(\n+        frame: navigationController.view.frame)\n+      UIApplication.shared.keyWindow?.addSubview(appBlocker)\n+      UIApplication.shared.keyWindow?.bringSubviewToFront(appBlocker)\n+\n     }\n-    \n-    func application(_ application: UIApplication, didReceive notification: UILocalNotification) {\n-        \n-        self.handleLocalNotification(userInfoDetails: (notification.userInfo as? Dictionary<String, Any>)!)\n+\n+    // Update TimeZone Changes if any\n+    self.calculateTimeZoneChange()\n+\n+    if self.isAppLaunched! {\n+      self.isAppLaunched = false\n+\n+      // Update Local Notifications\n+      self.checkForRegisteredNotifications()\n     }\n-    \n-    // MARK: Jailbreak Methods\n-    \n-    public static func jailbroken(application: UIApplication) -> Bool {\n-        guard let cydiaUrlScheme = NSURL(string: \"cydia://package/com.example.package\") else { return isJailbroken() }\n-        return application.canOpenURL(cydiaUrlScheme as URL) || isJailbroken()\n+  }\n+\n+  func applicationWillTerminate(_ application: UIApplication) {\n+    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.\n+  }\n+\n+  // MARK: - NOTIFICATION\n+\n+  func application(\n+    _ application: UIApplication,\n+    didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data\n+  ) {\n+\n+    let deviceTokenString = deviceToken.reduce(\"\", { $0 + String(format: \"%02X\", $1) })\n+    print(\"Token: \\(deviceTokenString)\")\n+\n+    if User.currentUser.userType == .FDAUser {\n+\n+      User.currentUser.settings?.remoteNotifications = true\n+      User.currentUser.settings?.localNotifications = true\n+      // Update device Token to Local server\n+      UserServices().updateUserProfile(deviceToken: deviceTokenString, delegate: self)\n+\n     }\n-    \n-    \n-    static func isJailbroken() -> Bool {\n-        \n-        if UIDevice.current.model != kIphoneSimulator {\n-            return false\n-        }\n-        \n-        let fileManager = FileManager.default\n-        if fileManager.fileExists(atPath: \"/Applications/Cydia.app\") ||\n-            fileManager.fileExists(atPath: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") ||\n-            fileManager.fileExists(atPath: \"/bin/bash\") ||\n-            fileManager.fileExists(atPath: \"/usr/sbin/sshd\") ||\n-            fileManager.fileExists(atPath: \"/etc/apt\") ||\n-            fileManager.fileExists(atPath: \"/usr/bin/ssh\") {\n-            return true\n-        }\n-        \n-        if canOpen(path: \"/Applications/Cydia.app\") ||\n-            canOpen(path: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") ||\n-            canOpen(path: \"/bin/bash\") ||\n-            canOpen(path: \"/usr/sbin/sshd\") ||\n-            canOpen(path: \"/etc/apt\") ||\n-            \n-            canOpen(path: \"/usr/bin/ssh\") {\n-            return true\n-        }\n-        \n-        let path = \"/private/\" + NSUUID().uuidString\n-        do {\n-            try \"anyString\".write(toFile: path, atomically: true, encoding: String.Encoding.utf8)\n-            try fileManager.removeItem(atPath: path)\n-            return true\n-        }catch {\n-            return false\n-        }\n+\n+  }\n+\n+  func application(\n+    _ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error\n+  ) {\n+\n+    Logger.sharedInstance.info(\"Token Registration failed  \\(error)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 862}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4NjcwNw==", "bodyText": "nit: remove empty if and just add a comment if needed.", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391686707", "createdAt": "2020-03-12T15:07:18Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/AppDelegate.swift", "diffHunk": "@@ -1,1900 +1,1844 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC\n+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import Fabric\n-import Crashlytics\n-import UserNotifications\n-import RealmSwift\n import CallKit\n import IQKeyboardManagerSwift\n+import RealmSwift\n+import UIKit\n+import UserNotifications\n \n-let kEncryptionKey = \"EncryptionKey\"\n-let kEncryptionIV =  \"EncryptionIV\"\n-let kBlockerScreenLabelText = \"Please update to the latest version of app to continue.\"\n-let kConsentUpdatedTitle = \"Consent Updated\"\n+@UIApplicationMain\n \n-let kMessageConsentUpdatedPartTwo = \" Please review the revised Consent terms and provide your Informed Consent, to continue participating in the study.\"\n+class AppDelegate: UIResponder, UIApplicationDelegate {\n \n-let kMessageConsentUpdated = \"The Consent Document for this study has been updated.\" + kMessageConsentUpdatedPartTwo\n+  var window: UIWindow?\n \n-let kReviewTitle = \"Review\"\n-let kPasscodeStepIdentifier = \"PasscodeStep\"\n-let kPasscodeTaskIdentifier = \"PassCodeTask\"\n-let kMessagePasscode = \"Passcode\"\n-let kMessagePasscodeSignOut = \"You will be signed out and will need to sign in again. Are you sure you want to proceed?\"\n-let kNewProgressViewNIB = \"NewProgressView\"\n-let kforgotPasscodeTitle = \"Forgot Passcode? Sign In Again\"\n-let kStudyStoryboard = \"Study\"\n-let kPasscodeSetUpText = \"Set up a passcode for the app\"\n-let kIphoneSimulator =  \"iPhone Simulator\"\n+  var notificationDetails: [String: Any]? = [String: Any]()\n \n-let kBundleIdentier = \"CFBundleIdentifier\"\n-let kPDFCreationNotificationId = \"pdfCreationNotificationIdentifier\"\n-let ksetUpTimeIdentifier = \"setUPTime\"\n-let kCFBundleShortVersion = \"CFBundleShortVersionString\"\n+  var appIsResignedButDidNotEnteredBackground: Bool? = false\n \n-let kResultCount = \"resultCount\"\n-let kResultsForAppStore = \"results\"\n-let kAppStoreVersion = \"version\"\n+  var alertVCPresented: UIAlertController?\n \n-let kContinueButtonTitle =  NSLocalizedString(\"Continue\", comment:\"\")\n-let kType = \"type\"\n+  var isPasscodePresented: Bool? = false\n \n-let kCurrentVersion = \"currentVersion\"\n-let kForceUpdate = \"forceUpdate\"\n-let kMessage = \"message\"\n-let kVisualStepId = \"visual\"\n-let kMessageString = \"Message\"\n+  var isComprehensionFailed: Bool? = false\n \n+  var parentViewControllerForAlert: UIViewController?\n \n-@UIApplicationMain\n+  var iscomingFromForgotPasscode: Bool? = false\n \n-class AppDelegate: UIResponder, UIApplicationDelegate {\n-    \n-    var window: UIWindow?\n-    \n-    var notificationDetails:Dictionary<String,Any>? = Dictionary<String,Any>()\n-    \n-    var appIsResignedButDidNotEnteredBackground:Bool? = false\n-    \n-    var alertVCPresented:UIAlertController?\n-    \n-    var isPasscodePresented:Bool? =  false\n-    \n-    var isComprehensionFailed:Bool? = false\n-    \n-    var parentViewControllerForAlert:UIViewController?\n-    \n-    var iscomingFromForgotPasscode:Bool? =  false\n-    \n-    var isAppLaunched: Bool? = false\n-    \n-    let healthStore = HKHealthStore()\n-    var containerViewController: ResearchContainerViewController? {\n-        return window?.rootViewController as? ResearchContainerViewController\n+  var isAppLaunched: Bool? = false\n+\n+  let healthStore = HKHealthStore()\n+\n+  var containerViewController: ResearchContainerViewController? {\n+    return window?.rootViewController as? ResearchContainerViewController\n+  }\n+\n+  var selectedController: UIViewController?\n+\n+  var shouldAddForceUpgradeScreen = false\n+\n+  var retryView: ComprehensionFailure?\n+\n+  var blockerScreen: AppUpdateBlocker?\n+  var passcodeParentControllerWhileSetup: UIViewController?\n+\n+  /// to be used in case of ineligible\n+  var consentToken: String? = \"\"\n+\n+  /// Register for Remote Notification\n+  func askForNotification() {\n+\n+    if #available(iOS 10.0, *) {\n+      let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n+      UNUserNotificationCenter.current().requestAuthorization(\n+        options: authOptions,\n+        completionHandler: { _, _ in })\n+\n+      // For iOS 10 display notification (sent via APNS)\n+      UNUserNotificationCenter.current().delegate = self\n+\n+    } else {\n+      let settings: UIUserNotificationSettings = UIUserNotificationSettings(\n+        types: [.alert, .badge, .sound], categories: nil)\n+      UIApplication.shared.registerUserNotificationSettings(settings)\n     }\n-    \n-    var selectedController: UIViewController?\n-    \n-    var shouldAddForceUpgradeScreen = false\n-    \n-    var retryView: ComprehensionFailure?\n-    \n-    var blockerScreen: AppUpdateBlocker?\n-    var passcodeParentControllerWhileSetup: UIViewController?\n-    \n-    var consentToken: String? = \"\" //to be used in case of ineligible\n-    \n-    //Register Remote Notification\n-    func askForNotification() {\n-        \n-        if #available(iOS 10.0, *) {\n-            let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n-            UNUserNotificationCenter.current().requestAuthorization(\n-                options: authOptions,\n-                completionHandler: {_, _ in })\n-            \n-            // For iOS 10 display notification (sent via APNS)\n-            UNUserNotificationCenter.current().delegate = self\n-            \n-        }else {\n-            let settings: UIUserNotificationSettings =\n-                UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)\n-            UIApplication.shared.registerUserNotificationSettings(settings)\n-        }\n-        UIApplication.shared.registerForRemoteNotifications()\n+    UIApplication.shared.registerForRemoteNotifications()\n+  }\n+\n+  /// Updates Key & InitializationVector for Encryption\n+  func updateKeyAndInitializationVector() {\n+\n+    let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n+    let currentIndex = currentDate.index(currentDate.endIndex, offsetBy: -13)\n+    let subStringFromDate = String(currentDate[..<currentIndex])\n+\n+    if User.currentUser.userType == .FDAUser {  // Registered/LogedIn User\n+\n+      let index = User.currentUser.userId.index(User.currentUser.userId.endIndex, offsetBy: -16)\n+      let subKey = String(User.currentUser.userId[..<index])\n+      FDAKeychain.shared[kEncryptionKey] = subKey + subStringFromDate\n+    } else {  // Anonymous User\n+      FDAKeychain.shared[kEncryptionKey] = kEncryptionKey\n     }\n-    \n-    /**\n-     Updates Key & InitializationVector for Encryption\n-     */\n-    func updateKeyAndInitializationVector() {\n-        \n-        let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n-        let currentIndex = currentDate.index(currentDate.endIndex\n-            , offsetBy: -13)\n-        let subStringFromDate = String(currentDate[..<currentIndex])\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if User.currentUser.userType ==  .FDAUser { // Registered/LogedIn User\n-            \n-            let index =  User.currentUser.userId.index(User.currentUser.userId.endIndex\n-                , offsetBy: -16)\n-            let subKey = String(User.currentUser.userId[..<index]) //User.currentUser.userId.substring(to: index ) // 36 - 12 =  24 characters\n-            ud.set(\"\\(subKey + subStringFromDate)\", forKey: kEncryptionKey)\n-            \n-        }else { // Anonymous User\n-            ud.set(currentDate + kDefaultPasscodeString, forKey: kEncryptionKey)\n-        }\n-        \n-        if UIDevice.current.model == kIsIphoneSimulator {\n-            // simulator\n-            ud.set(kdefaultIVForEncryption, forKey: kEncryptionIV)\n-        }else {\n-            // Device\n-            var udid = UIDevice.current.identifierForVendor?.uuidString\n-            let index =  udid?.index((udid?.endIndex)!\n-                , offsetBy: -20)\n-            udid = String((udid?[..<index!])!)//udid?.substring(to: index!)\n-            ud.set(udid, forKey: kEncryptionIV)\n+\n+    if UIDevice.current.model == kIsIphoneSimulator {\n+      FDAKeychain.shared[kEncryptionIV] = kdefaultIVForEncryption\n+    } else {\n+      // Device\n+      var udid = UIDevice.current.identifierForVendor?.uuidString\n+      let index = udid?.index((udid?.endIndex)!, offsetBy: -20)\n+      udid = String((udid?[..<index!])!)\n+      FDAKeychain.shared[kEncryptionIV] = udid\n+    }\n+    //ud.synchronize()\n+  }\n+\n+  /// Handler for TimeZone changes, updates time zone in the local database\n+  func calculateTimeZoneChange() {\n+\n+    let timeZoneCurrent = TimeZone.current\n+    let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n+\n+    // Saving TimeZone to User Defaults\n+    let ud = UserDefaults.standard\n+    let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n+\n+    // Saving time difference\n+    if setuptimeDiff == nil {\n+      ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n+      ud.set(0, forKey: \"offset\")\n+\n+    } else {\n+\n+      let difference = differenceFromCurrent - setuptimeDiff!\n+      ud.set(difference, forKey: \"offset\")\n+      if difference == 0 {\n+        // Do Nothing\n+      } else {\n+\n+        Schedule._formatter = nil\n+        Schedule._formatter2 = nil\n+      }\n+    }\n+    ud.synchronize()\n+  }\n+\n+  // MARK: - Realm Migragion\n+  func generateRealmKeys() {\n+\n+    // Realm Encryption key generation\n+    if FDAKeychain.shared[kRealmEncryptionKeychainKey] == nil {\n+      // Generate 64 bytes of random data to serve as the encryption key\n+      var realmKey = kRealmEncryptionDefaultKey\n+      var key = Data(count: 64)\n+      let result = key.withUnsafeMutableBytes {\n+        SecRandomCopyBytes(kSecRandomDefault, 64, $0.baseAddress!)\n+      }\n+      if result == errSecSuccess {\n+        realmKey = key.base64EncodedString()\n+      } else {\n+        Logger.sharedInstance.info(\"Problem generating random bytes\")\n+\n+      }\n+      FDAKeychain.shared[kRealmEncryptionKeychainKey] = realmKey\n+    }\n+  }\n+\n+  func checkForRealmMigration() {\n+\n+    self.generateRealmKeys()\n+\n+    let key = FDAKeychain.shared[kRealmEncryptionKeychainKey]\n+    let keyData = Data.init(base64Encoded: key!)\n+\n+    let config = Realm.Configuration(\n+      encryptionKey: keyData,\n+      schemaVersion: 1,\n+      migrationBlock: { _, oldSchemaVersion in\n+        // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n+        if oldSchemaVersion < 1 {\n+          // Nothing to do!\n+          // Realm will automatically detect new properties and removed properties\n+          // And will update the schema on disk automatically\n         }\n+      })\n+\n+    // Tell Realm to use this new configuration object for the default Realm\n+    Realm.Configuration.defaultConfiguration = config\n+  }\n+\n+  // MARK: - App Delegates methods\n+\n+  func application(\n+    _ application: UIApplication,\n+    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n+  ) -> Bool {\n+    // Override point for customization after application launch.\n+\n+    self.isAppLaunched = true\n+    IQKeyboardManager.shared.enable = true\n+    Logger.sharedInstance.info(Utilities.isStandaloneApp(), \"Standalone\")\n+    self.customizeNavigationBar()\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+\n+    //Check For Updates\n+    self.checkForAppUpdate()\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    SyncUpdate.currentSyncUpdate = SyncUpdate()\n+\n+    // Register observer for Network change\n+    NotificationCenter.default.addObserver(\n+      SyncUpdate.currentSyncUpdate as Any,\n+      selector: #selector(SyncUpdate.currentSyncUpdate?.updateData),\n+      name: ReachabilityChangedNotification, object: nil)\n+\n+    let ud1 = UserDefaults.standard\n+\n+    // Check if App is launched because of Notification Received\n+    if launchOptions != nil && launchOptions?[.sourceApplication] == nil {\n+\n+      ud1.set(\"not null\", forKey: \"launch\")\n+\n+      // Launched from push notification\n+      let notification = launchOptions?[.remoteNotification]\n+\n+      if Utilities.isValidObject(someObject: notification as AnyObject) {  // Launched from Remote Notification\n+\n+        notificationDetails = notification as? [String: Any]\n+\n+        let ud = UserDefaults.standard\n+        ud.set(true, forKey: kShowNotification)\n         ud.synchronize()\n-    }\n-    \n-    /**\n-     Handler for TimeZone changes, updates time zone in the local database\n-     */\n-    func calculateTimeZoneChange() {\n-        \n-        //let date = Date().utcDate()\n-        \n-        //let timeZoneUTC = TimeZone(abbreviation: \"UTC\")\n-        //let timeZoneAutoCurrent = TimeZone.autoupdatingCurrent\n-        let timeZoneCurrent = TimeZone.current\n-        \n-        //let differenceFromUTC = timeZoneUTC?.secondsFromGMT()\n-        let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n-        //let differenceFromAutoCurrent = timeZoneCurrent.secondsFromGMT()\n-        \n-        //Saving TimeZone to User Defaults\n+\n+      } else {  // Regular Launch\n+\n+        ud1.set(\"invalid\", forKey: \"launch\")\n         let ud = UserDefaults.standard\n-        let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n-        \n-        //Saving time difference\n-        if setuptimeDiff == nil {\n-            ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n-            ud.set(0, forKey: \"offset\")\n-            \n-        }else {\n-            \n-            let difference = differenceFromCurrent - setuptimeDiff!\n-            ud.set(difference, forKey: \"offset\")\n-            if difference == 0 {\n-                // Do Nothing\n-            }else {\n-                \n-                Schedule._formatter = nil\n-                Schedule._formatter2 = nil\n-            }\n-        }\n+        ud.set(false, forKey: kShowNotification)\n         ud.synchronize()\n+      }\n     }\n-    \n-    func checkForAppReopenNotification() {\n-        \n-        //remove if notification is available\n-        LocalNotification.removeReopenAppNotification()\n-        LocalNotification.registerReopenAppNotification()\n-        \n-    }\n-    \n-    // MARK: Realm Migragion\n-    func checkForRealmMigration() {\n-        \n-        let config = Realm.Configuration(\n-            // Set the new schema version. This must be greater than the previously used\n-            // version (if you've never set a schema version before, the version is 0).\n-            schemaVersion: 3,\n-            \n-            // Set the block which will be called automatically when opening a Realm with\n-            // a schema version lower than the one set above\n-            migrationBlock: { migration, oldSchemaVersion in\n-                // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n-                if (oldSchemaVersion < 1) {\n-                    // Nothing to do!\n-                    // Realm will automatically detect new properties and removed properties\n-                    // And will update the schema on disk automatically\n-                }\n-        })\n-        \n-        // Tell Realm to use this new configuration object for the default Realm\n-        Realm.Configuration.defaultConfiguration = config\n-        \n-        // Now that we've told Realm how to handle the schema change, opening the file\n-        // will automatically perform the migration\n-        let _ = try! Realm()\n-    }\n-    \n-    func fireNotiffication(intervel:Int) {\n-        \n-        let content = UNMutableNotificationContent()\n-        content.body = \"message\"\n-        \n-        content.sound = UNNotificationSound.default\n-        content.badge = 1\n-        let date = Date().addingTimeInterval(TimeInterval(intervel))\n-        var timeInterval = date.timeIntervalSinceNow\n-\n-        \n-        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: timeInterval, repeats: false)\n-        let id = Utilities.randomString(length: 10)\n-        let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)\n-        let center = UNUserNotificationCenter.current()\n-        center.add(request)\n-    }\n-    \n-    // MARK: App Delegates\n-    \n-    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n-        // Override point for customization after application launch.\n-        \n-        self.isAppLaunched = true\n-        IQKeyboardManager.shared.enable = true\n-        print(Utilities.isStandaloneApp(),\"standalone\")\n-        self.customizeNavigationBar()\n-        Fabric.with([Crashlytics.self])\n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        \n-        //Check For Updates\n-        //self.checkForAppUpdateForVersion()\n-        self.checkForAppUpdate()\n-        \n-        if UIApplication.shared.applicationIconBadgeNumber > 0 {\n-            UIApplication.shared.applicationIconBadgeNumber = 0\n-        }\n-        \n-        SyncUpdate.currentSyncUpdate = SyncUpdate()\n-        \n-        //Register observer for Network change\n-        NotificationCenter.default.addObserver(SyncUpdate.currentSyncUpdate as Any , selector: #selector(SyncUpdate.currentSyncUpdate?.updateData), name: Notification.Name.reachabilityChanged, object: nil)\n-        \n-        let ud1 = UserDefaults.standard\n-        \n-        //Check if App is launched because of Notification Received\n-        if (launchOptions != nil && launchOptions?[.sourceApplication] == nil) {\n-            \n-            ud1.set(\"not null\", forKey: \"launch\")\n-            \n-            // Launched from push notification\n-            let notification = launchOptions?[.remoteNotification]\n-            \n-            if Utilities.isValidObject(someObject: notification as AnyObject) { // Launched from Remote Notification\n-                \n-                notificationDetails = notification as? Dictionary<String, Any>\n-                \n-                let ud = UserDefaults.standard\n-                ud.set(true, forKey: kShowNotification)\n-                ud.synchronize()\n-                \n-            }else if (launchOptions?[.localNotification] != nil) { //Launched from Local Notification\n-                \n-                ud1.set(\"local\", forKey: \"launch\")\n-                let localNotification = (launchOptions?[.localNotification] as? UILocalNotification)!\n-                let notificationDetails = (localNotification.userInfo as? Dictionary<String, Any>)!\n-                \n-                NotificationHandler.instance.appOpenFromNotification = true\n-                NotificationHandler.instance.studyId = (notificationDetails[kStudyId] as? String)!\n-                NotificationHandler.instance.activityId = (notificationDetails[kActivityId] as? String)!\n-                ud1.synchronize()\n-                \n-            }else { //Regular Launch\n-                \n-                ud1.set(\"invalid\", forKey: \"launch\")\n-                UIApplication.shared.applicationIconBadgeNumber = 0\n-                \n-                let ud = UserDefaults.standard\n-                ud.set(false, forKey: kShowNotification)\n-                ud.synchronize()\n-            }\n-        }\n-        \n-        //self.fireNotiffication(intervel: 10)\n-        //self.fireNotiffication(intervel: 15)\n-        \n-        //Check if Database needs migration\n-        self.checkForRealmMigration()\n-        return true\n-    }\n-    \n-    func applicationWillResignActive(_ application: UIApplication) {\n-        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.\n-        \n-        // set Flag to handle background to foreground transition\n-        self.appIsResignedButDidNotEnteredBackground = true\n-    }\n-    \n-    func applicationDidEnterBackground(_ application: UIApplication) {\n-        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n-        \n-        // set Flag to handle foreground to background transition\n-        self.appIsResignedButDidNotEnteredBackground = false\n-    }\n-    \n-    \n-    func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {\n-    }\n-    \n-    \n-    func applicationWillEnterForeground(_ application: UIApplication) {\n-        \n-        self.checkPasscode(viewController: (application.windows[0].rootViewController)!)\n-        \n-        self.checkForStudyUpdates()\n-        \n-        let number = UIApplication.shared.applicationIconBadgeNumber\n-        if number >= 1 {\n-            self.updateNotification()\n-        }\n-        \n-        //Check For Updates\n-        self.checkForAppUpdate()\n-        \n+\n+    // Check if Database needs migration\n+    self.checkForRealmMigration()\n+    return true\n+  }\n+\n+  func applicationWillResignActive(_ application: UIApplication) {\n+    // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.\n+\n+    // set Flag to handle background to foreground transition\n+    self.appIsResignedButDidNotEnteredBackground = true\n+  }\n+\n+  func applicationDidEnterBackground(_ application: UIApplication) {\n+    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n+\n+    // set Flag to handle foreground to background transition\n+    self.appIsResignedButDidNotEnteredBackground = false\n+  }\n+\n+  func application(\n+    _ application: UIApplication,\n+    performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) ->\n+      Void\n+  ) {\n+  }\n+\n+  func applicationWillEnterForeground(_ application: UIApplication) {\n+\n+    self.checkPasscode(viewController: (application.windows[0].rootViewController)!)\n+    self.checkForStudyUpdates()\n+    let number = UIApplication.shared.applicationIconBadgeNumber\n+    if number >= 1 {\n+      self.updateNotification()\n     }\n-    \n-    func applicationDidBecomeActive(_ application: UIApplication) {\n-        \n-        // self.window?.isHidden = false\n-        \n-        UIApplication.shared.applicationIconBadgeNumber = 0\n-        \n-        if self.appIsResignedButDidNotEnteredBackground! {\n-            \n-            let navController = application.windows[0].rootViewController\n-            \n-            \n-            let isTaskViewControllerVisible = (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKTaskViewController.self)\n-            \n-           // guard let navigation = (navController as? UINavigationController)?.visibleViewController as? ORKTaskViewController, let navigationTitle = navigation.title else {return}\n-            \n-            let navigationTitle = ((navController as? UINavigationController)?.visibleViewController as? ORKTaskViewController)?.title ?? \"\"\n-            \n-            if (navController as? UINavigationController) != nil &&  isTaskViewControllerVisible == false {\n-                \n-                if (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKPasscodeViewController.self) == false {\n-                    //Request for Passcode\n-                    //self.checkPasscode(viewController: navController!)\n-                }\n-                \n-            } else if(navController as? UINavigationController) != nil\n-                &&  isTaskViewControllerVisible == true\n-                && navigationTitle == \"Activity\" {\n-                \n-                if (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKPasscodeViewController.self) == false {\n-                    //Request for Passcode\n-                    //self.checkPasscode(viewController: navController!)\n-                }\n-            } else if(navController as? UIViewController) != nil {\n-               // self.checkPasscode(viewController: navController!)\n-            }\n-        }\n-        \n-        //Check if App running on Jailbreak Device\n-        if AppDelegate.jailbroken(application: application) {\n-            \n-            let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-            let appBlocker = JailbrokeBlocker.instanceFromNib(frame: navigationController.view.frame, detail: nil);\n-            UIApplication.shared.keyWindow?.addSubview(appBlocker);\n-            UIApplication.shared.keyWindow?.bringSubviewToFront(appBlocker)\n-            \n-        }\n-        \n-        //Update TimeZone Changes if any\n-        self.calculateTimeZoneChange()\n-        \n-        if self.isAppLaunched! {\n-            self.isAppLaunched = false\n-            \n-            //Update Local Notifications\n-            self.checkForRegisteredNotifications()\n+\n+    // Check For Updates\n+    self.checkForAppUpdate()\n+\n+  }\n+\n+  func applicationDidBecomeActive(_ application: UIApplication) {\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    if self.appIsResignedButDidNotEnteredBackground! {\n+\n+      let navController = application.windows[0].rootViewController\n+\n+      let isTaskViewControllerVisible = (navController as? UINavigationController)?\n+        .visibleViewController?.isKind(of: ORKTaskViewController.self)\n+\n+      let navigationTitle = (\n+        (navController as? UINavigationController)?.visibleViewController\n+          as? ORKTaskViewController\n+      )?.title ?? \"\"\n+\n+      if (navController as? UINavigationController) != nil && isTaskViewControllerVisible\n+        == false {\n+\n+        if (navController as? UINavigationController)?.visibleViewController?.isKind(\n+          of: ORKPasscodeViewController.self) == false {\n+          // Request for Passcode\n+          self.checkPasscode(viewController: navController!)\n         }\n-    }\n-    \n-    func applicationWillTerminate(_ application: UIApplication) {\n-        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.\n-    }\n-    \n-    // MARK:- NOTIFICATION\n-    \n-    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n-        \n-        let deviceTokenString = deviceToken.reduce(\"\", {$0 + String(format: \"%02X\", $1)})\n-        print(\"Token: \\(deviceTokenString)\")\n-        \n-        if  User.currentUser.userType == .FDAUser {\n-            \n-            User.currentUser.settings?.remoteNotifications = true\n-            User.currentUser.settings?.localNotifications = true\n-            //Update device Token to Local server\n-            UserServices().updateUserProfile(deviceToken: deviceTokenString , delegate: self)\n-            \n+\n+      } else if (navController as? UINavigationController) != nil\n+        && isTaskViewControllerVisible == true\n+        && navigationTitle == \"Activity\" {\n+\n+        if (navController as? UINavigationController)?.visibleViewController?.isKind(\n+          of: ORKPasscodeViewController.self) == false {\n+          // Request for Passcode\n+          self.checkPasscode(viewController: navController!)\n         }\n-        \n+      } else if (navController) != nil {\n+        self.checkPasscode(viewController: navController!)\n+      }\n     }\n-    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {\n-        \n-        print(\"Token Registration failed  \\(error)\")\n-        \n-    }\n-    \n-    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) {\n-        \n-        //For iOS 8 & 9\n-        if (UIApplication.shared.applicationState == .background)||(UIApplication.shared.applicationState == .inactive) {\n-            \n-            self.updateNotification()\n-            self.handleLocalAndRemoteNotification(userInfoDetails: (userInfo as? Dictionary<String, Any>)!)\n-        }\n-        \n-        // userInfo is valid\n-        if userInfo.count > 0 && userInfo.keys.contains(kType) {\n-            self.updateNotification()\n-            \n-        }else {\n-            if (UIApplication.shared.applicationState == .background || (UIApplication.shared.applicationState == .inactive)) {\n-                //Handle local Notification Received\n-                self.handleLocalNotification(userInfoDetails: (userInfo as? Dictionary<String, Any>)!)\n-            }\n-        }\n+\n+    // Check if App running on Jailbreak Device\n+    if AppDelegate.jailbroken(application: application) {\n+\n+      let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+      let appBlocker = JailbrokeBlocker.instanceFromNib(\n+        frame: navigationController.view.frame)\n+      UIApplication.shared.keyWindow?.addSubview(appBlocker)\n+      UIApplication.shared.keyWindow?.bringSubviewToFront(appBlocker)\n+\n     }\n-    \n-    func application(_ application: UIApplication, didReceive notification: UILocalNotification) {\n-        \n-        self.handleLocalNotification(userInfoDetails: (notification.userInfo as? Dictionary<String, Any>)!)\n+\n+    // Update TimeZone Changes if any\n+    self.calculateTimeZoneChange()\n+\n+    if self.isAppLaunched! {\n+      self.isAppLaunched = false\n+\n+      // Update Local Notifications\n+      self.checkForRegisteredNotifications()\n     }\n-    \n-    // MARK: Jailbreak Methods\n-    \n-    public static func jailbroken(application: UIApplication) -> Bool {\n-        guard let cydiaUrlScheme = NSURL(string: \"cydia://package/com.example.package\") else { return isJailbroken() }\n-        return application.canOpenURL(cydiaUrlScheme as URL) || isJailbroken()\n+  }\n+\n+  func applicationWillTerminate(_ application: UIApplication) {\n+    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.\n+  }\n+\n+  // MARK: - NOTIFICATION\n+\n+  func application(\n+    _ application: UIApplication,\n+    didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data\n+  ) {\n+\n+    let deviceTokenString = deviceToken.reduce(\"\", { $0 + String(format: \"%02X\", $1) })\n+    print(\"Token: \\(deviceTokenString)\")\n+\n+    if User.currentUser.userType == .FDAUser {\n+\n+      User.currentUser.settings?.remoteNotifications = true\n+      User.currentUser.settings?.localNotifications = true\n+      // Update device Token to Local server\n+      UserServices().updateUserProfile(deviceToken: deviceTokenString, delegate: self)\n+\n     }\n-    \n-    \n-    static func isJailbroken() -> Bool {\n-        \n-        if UIDevice.current.model != kIphoneSimulator {\n-            return false\n-        }\n-        \n-        let fileManager = FileManager.default\n-        if fileManager.fileExists(atPath: \"/Applications/Cydia.app\") ||\n-            fileManager.fileExists(atPath: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") ||\n-            fileManager.fileExists(atPath: \"/bin/bash\") ||\n-            fileManager.fileExists(atPath: \"/usr/sbin/sshd\") ||\n-            fileManager.fileExists(atPath: \"/etc/apt\") ||\n-            fileManager.fileExists(atPath: \"/usr/bin/ssh\") {\n-            return true\n-        }\n-        \n-        if canOpen(path: \"/Applications/Cydia.app\") ||\n-            canOpen(path: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") ||\n-            canOpen(path: \"/bin/bash\") ||\n-            canOpen(path: \"/usr/sbin/sshd\") ||\n-            canOpen(path: \"/etc/apt\") ||\n-            \n-            canOpen(path: \"/usr/bin/ssh\") {\n-            return true\n-        }\n-        \n-        let path = \"/private/\" + NSUUID().uuidString\n-        do {\n-            try \"anyString\".write(toFile: path, atomically: true, encoding: String.Encoding.utf8)\n-            try fileManager.removeItem(atPath: path)\n-            return true\n-        }catch {\n-            return false\n-        }\n+\n+  }\n+\n+  func application(\n+    _ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error\n+  ) {\n+\n+    Logger.sharedInstance.info(\"Token Registration failed  \\(error)\")\n+\n+  }\n+\n+  // MARK: - Jailbreak Methods\n+\n+  /// Checks Jailbroken status\n+  /// - Parameter application: `UIApplication` instance\n+  /// - Returns: `Boolean` state of Jailbroken\n+  public static func jailbroken(application: UIApplication) -> Bool {\n+    guard let cydiaUrlScheme = NSURL(string: \"cydia://package/com.example.package\") else {\n+      return isJailbroken()\n+    }\n+    return application.canOpenURL(cydiaUrlScheme as URL) || isJailbroken()\n+  }\n+\n+  /// Checks Jailbroken status\n+  /// - Returns: `Boolean` state of Jailbroken\n+  static func isJailbroken() -> Bool {\n+\n+    if UIDevice.current.model != kIphoneSimulator {\n+      return false\n     }\n-    \n-    static func canOpen(path: String) -> Bool {\n-        let file = fopen(path, \"r\")\n-        guard file != nil else { return false }\n-        fclose(file)\n-        return true\n+\n+    let fileManager = FileManager.default\n+    if fileManager.fileExists(atPath: \"/Applications/Cydia.app\") || fileManager.fileExists(\n+      atPath: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") || fileManager.fileExists(\n+        atPath: \"/bin/bash\") || fileManager.fileExists(atPath: \"/usr/sbin/sshd\")\n+      || fileManager\n+      .fileExists(atPath: \"/etc/apt\") || fileManager.fileExists(atPath: \"/usr/bin/ssh\") {\n+      return true\n     }\n-    \n-    // MARK: Add Retry Screen\n-    \n-    func addRetryScreen(viewController: UIViewController?) {\n-        \n-        let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-        self.retryView = ComprehensionFailure.instanceFromNib(frame: navigationController.view.frame, detail: nil);\n-        \n-        if viewController != nil {\n-            retryView?.delegate = (viewController as? ComprehensionFailureDelegate)!\n-            \n-        }else {\n-            retryView?.delegate = (self as? ComprehensionFailureDelegate)!\n-        }\n-        UIApplication.shared.keyWindow?.addSubview(retryView!);\n-        UIApplication.shared.keyWindow?.bringSubviewToFront(retryView!)\n+\n+    if canOpen(path: \"/Applications/Cydia.app\") || canOpen(\n+      path: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") || canOpen(path: \"/bin/bash\")\n+      || canOpen(path: \"/usr/sbin/sshd\") || canOpen(path: \"/etc/apt\") || canOpen(\n+        path: \"/usr/bin/ssh\") {\n+      return true\n     }\n-    \n-    // MARK:Custom Navigation Bar\n-    \n-    func customizeNavigationBar() {\n-        UINavigationBar.appearance().titleTextAttributes = [\n-            NSAttributedString.Key.font: UIFont(name: \"HelveticaNeue-Medium\", size: 18)!\n-        ]\n+\n+    let path = \"/private/\" + NSUUID().uuidString\n+    do {\n+      try \"anyString\".write(toFile: path, atomically: true, encoding: String.Encoding.utf8)\n+      try fileManager.removeItem(atPath: path)\n+      return true\n+    } catch {\n+      return false\n+    }\n+  }\n+\n+  static func canOpen(path: String) -> Bool {\n+    let file = fopen(path, \"r\")\n+    guard file != nil else { return false }\n+    fclose(file)\n+    return true\n+  }\n+\n+  // MARK: - Add Retry Screen\n+\n+  /// Present Retry View\n+  /// - Parameter viewController: `UIViewController` instance\n+  func addRetryScreen(viewController: UIViewController?) {\n+\n+    let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+    self.retryView = ComprehensionFailure.instanceFromNib(\n+      frame: navigationController.view.frame, detail: nil)\n+\n+    if viewController != nil {\n+      retryView?.delegate = (viewController as? ComprehensionFailureDelegate)!\n+\n+    } else {\n+      retryView?.delegate = self\n     }\n-    \n-    // MARK: Checker Methods\n-    \n-    /**\n-     To get the current App version from App Store and Adds the blocker screen if it is of lower version\n-     */\n-    func checkForAppUpdate() {\n-        WCPServices().checkForAppUpdates(delegate: self)\n+    UIApplication.shared.keyWindow?.addSubview(retryView!)\n+    UIApplication.shared.keyWindow?.bringSubviewToFront(retryView!)\n+  }\n+\n+  // MARK: - Custom Navigation Bar\n+\n+  func customizeNavigationBar() {\n+    UINavigationBar.appearance().titleTextAttributes = [\n+      NSAttributedString.Key.font: UIFont(name: \"HelveticaNeue-Medium\", size: 18)!\n+    ]\n+  }\n+\n+  // MARK: - Checker Methods\n+\n+  /// Get the current App version from App Store and Adds the blocker screen if it is of lower version\n+  func checkForAppUpdate() {\n+    WCPServices().checkForAppUpdates(delegate: self)\n+  }\n+\n+  /// Registers pending notifications based on UserType\n+  func checkForRegisteredNotifications() {\n+\n+    if User.currentUser.userType == .FDAUser {\n+\n+      let center = UNUserNotificationCenter.current()\n+      center.getPendingNotificationRequests(\n+        completionHandler: { requests in\n+          if requests.count < 50 {\n+            LocalNotification.refreshAllLocalNotification()\n+          }\n+        })\n     }\n-    \n-    func checkForRegisteredNotifications() {\n-        \n-        if User.currentUser.userType == .FDAUser {\n-           \n-            let center = UNUserNotificationCenter.current()\n-            center.getPendingNotificationRequests(completionHandler: { requests in\n-                print(requests)\n-                if requests.count < 50 {\n-                     LocalNotification.refreshAllLocalNotification()\n-                }\n-            })\n-            \n-            //check if notifications are expired or already fired\n-//            if scheduledNotifications.count < 50 {\n-//                //refresh local notifcation from DB\n-//                LocalNotification.refreshAllLocalNotification()\n-//                scheduledNotifications = application.scheduledLocalNotifications!\n-//\n-//            }\n-        }\n+  }\n+\n+  /// Webservice request call to SignOut\n+  func sendRequestToSignOut() {\n+    UserServices().logoutUser(self as NMWebServiceDelegate)\n+  }\n+\n+  /// Check the  current Consent Status for Updated Version\n+  /// - Parameter controller: Instance of `UIVIewController`\n+  func checkConsentStatus(controller: UIViewController) {\n+\n+    self.selectedController = controller\n+\n+    if StudyUpdates.studyConsentUpdated {\n+      // Study consent is updated: Please Present Consent UI.\n+\n+      let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+\n+      var topController: UIViewController = navigationController\n+      if navigationController.viewControllers.count > 0 {\n+        topController = navigationController.viewControllers.first!\n+      }\n+\n+      UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+        NSLocalizedString(kConsentUpdatedTitle, comment: \"\"),\n+        errorMessage: NSLocalizedString(kMessageConsentUpdated, comment: \"\"),\n+        errorAlertActionTitle: NSLocalizedString(kReviewTitle, comment: \"\"),\n+        errorAlertActionTitle2: nil, viewControllerUsed: topController,\n+        action1: {\n+\n+          self.addAndRemoveProgress(add: true)\n+          WCPServices().getEligibilityConsentMetadata(\n+            studyId: (Study.currentStudy?.studyId)!,\n+            delegate: self as NMWebServiceDelegate)\n+\n+        },\n+        action2: {\n+        })\n+    } else {\n+      // Study consent not updated\n     }\n-    \n-    func sendRequestToSignOut() {\n-        UserServices().logoutUser(self as NMWebServiceDelegate)\n+  }\n+\n+  /// Creates Eligibility Consent Task\n+  func createEligibilityConsentTask() {\n+\n+    let taskViewController: ORKTaskViewController?\n+\n+    //create orderedTask\n+    let consentTask: ORKOrderedTask? = ConsentBuilder.currentConsent?.createConsentTask()\n+      as! ORKOrderedTask?\n+\n+    taskViewController = ORKTaskViewController(task: consentTask, taskRun: nil)\n+\n+    taskViewController?.delegate = self\n+    taskViewController?.outputDirectory = FileManager.default.urls(\n+      for: .documentDirectory, in: .userDomainMask).first!\n+\n+    taskViewController?.navigationItem.title = nil\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+\n+    var topVC = UIApplication.shared.keyWindow?.rootViewController\n+    // Fetching the current Visible Controller\n+    while topVC?.presentedViewController != nil {\n+      topVC = topVC?.presentedViewController\n     }\n-    \n-    /**\n-     check the  current Consent Status for Updated Version\n-     */\n-    func checkConsentStatus(controller: UIViewController) {\n-        \n-        self.selectedController = controller\n-        \n-        if(StudyUpdates.studyConsentUpdated) {\n-            print(\"Study consent is updated: Please Present Consent UI\")\n-            \n-            let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-            \n-            var topController: UIViewController = navigationController\n-            if navigationController.viewControllers.count > 0 {\n-                topController = navigationController.viewControllers.first!\n-            }\n-            \n-            UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(kConsentUpdatedTitle, comment: \"\"), errorMessage: NSLocalizedString(kMessageConsentUpdated, comment: \"\"), errorAlertActionTitle: NSLocalizedString(kReviewTitle, comment: \"\"),\n-                                                                 errorAlertActionTitle2: nil, viewControllerUsed: topController,\n-                                                                 action1: {\n-                                                                    \n-                                                                    self.addAndRemoveProgress(add: true)\n-                                                                    WCPServices().getEligibilityConsentMetadata(studyId:(Study.currentStudy?.studyId)!, delegate: self as NMWebServiceDelegate)\n-                                                                    \n-            },\n-                                                                 action2: {\n-            })\n-        }else {\n-            print(\"Study consent not updated\")\n-        }\n+\n+    self.addAndRemoveProgress(add: false)\n+    // present consent task\n+    taskViewController?.navigationBar.prefersLargeTitles = false\n+    taskViewController?.modalPresentationStyle = .fullScreen\n+    topVC?.present(taskViewController!, animated: true, completion: nil)\n+  }\n+\n+  /// Handler for local notification\n+  /// - Parameter userInfoDetails: Contains the info for notification\n+  func handleLocalNotification(userInfoDetails: [String: Any]) {\n+\n+    var initialVC: UIViewController?\n+\n+    // getting topmost visible controller\n+    let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+    let menuVC = navigationController.viewControllers.last\n+    if menuVC is FDASlideMenuViewController {\n+      let mainController = (menuVC as? FDASlideMenuViewController)!.mainViewController\n+      if mainController is UINavigationController {\n+        let nav = (mainController as? UINavigationController)!\n+        initialVC = nav.viewControllers.last\n+      }\n     }\n-    \n-    /**\n-     Used to Create Eligibility Consent Task\n-     */\n-    func createEligibilityConsentTask() {\n-        \n-        let taskViewController: ORKTaskViewController?\n-        \n-        //create orderedTask\n-        let consentTask: ORKOrderedTask? = ConsentBuilder.currentConsent?.createConsentTask() as! ORKOrderedTask?\n-        \n-        taskViewController = ORKTaskViewController(task: consentTask, taskRun: nil)\n-        \n-        taskViewController?.delegate = self\n-        taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-        \n-        taskViewController?.navigationItem.title = nil\n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        \n-        //UIApplication.shared.statusBarStyle = .default\n-        \n-        var topVC = UIApplication.shared.keyWindow?.rootViewController\n-        //Fetching the current Visible Controller\n-        while topVC?.presentedViewController != nil {\n-            topVC = topVC?.presentedViewController\n+\n+    NotificationHandler.instance.appOpenFromNotification = true\n+    NotificationHandler.instance.studyId = (userInfoDetails[kStudyId] as? String)!\n+    NotificationHandler.instance.activityId = (userInfoDetails[kActivityId] as? String)!\n+\n+    if !(initialVC is UITabBarController) {\n+      // push tabbar and switch to activty tab\n+      if !(initialVC is StudyListViewController) {\n+\n+        let leftController = (\n+          (menuVC as? FDASlideMenuViewController)!.leftViewController\n+            as? LeftMenuViewController\n+        )!\n+        leftController.changeViewController(.studyList)\n+        leftController.createLeftmenuItems()\n+      }\n+    } else {\n+      // switch to activty tab\n+      (initialVC as? UITabBarController)!.selectedIndex = 0\n+    }\n+  }\n+\n+  /// Handler for local & remote notification\n+  /// - Parameter userInfoDetails: contains the info for notification\n+  func handleLocalAndRemoteNotification(userInfoDetails: [String: Any]) {\n+\n+    var notificationType: String? = \"\"\n+    var notificationSubType: AppNotification.NotificationSubType? = .Announcement\n+    // User info is valid\n+    if (userInfoDetails.count) > 0 {\n+\n+      if Utilities.isValidValue(someObject: userInfoDetails[kNotificationType] as AnyObject) {\n+        notificationType = userInfoDetails[kNotificationType] as? String\n+      }\n+      if Utilities.isValidValue(\n+        someObject: userInfoDetails[kNotificationSubType] as AnyObject) {\n+        notificationSubType = AppNotification.NotificationSubType(\n+          rawValue: (userInfoDetails[kNotificationSubType] as? String)!)\n+      }\n+\n+      if notificationType == AppNotification.NotificationType.Study.rawValue {  //Study Level Notification\n+\n+        var studyId: String? = \"\"\n+\n+        if Utilities.isValidValue(someObject: userInfoDetails[kStudyId] as AnyObject) {\n+          studyId = userInfoDetails[kStudyId] as? String\n         }\n-        \n-        self.addAndRemoveProgress(add: false)\n-        //present consent task\n-        taskViewController?.modalPresentationStyle = .fullScreen\n-        topVC?.present(taskViewController!, animated: true, completion: nil)\n-    }\n-    \n-    /**\n-     Handler for local notification\n-     @param userInfoDetails, contains the info for notification\n-     */\n-    \n-    func handleLocalNotification(userInfoDetails: Dictionary<String,Any>) {\n-        \n-        var initialVC: UIViewController?\n-        \n-        //getting topmost visible controller\n-        let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-        let menuVC = navigationController.viewControllers.last\n-        if  menuVC is FDASlideMenuViewController {\n-            let mainController =  (menuVC as? FDASlideMenuViewController)!.mainViewController\n+\n+        if studyId != nil || studyId != \"\" {\n+\n+          var initialVC: UIViewController?\n+\n+          if Gateway.instance.studies?.isEmpty == false {\n+\n+            let study = Gateway.instance.studies?.filter({ $0.studyId == studyId })\n+              .first\n+            Study.updateCurrentStudy(study: study!)\n+          }\n+          // fetch the visible view controller\n+          let navigationController = (\n+            self.window?.rootViewController as? UINavigationController\n+          )!\n+          let menuVC = navigationController.viewControllers.last\n+          if menuVC is FDASlideMenuViewController {\n+            let mainController = (menuVC as? FDASlideMenuViewController)!\n+              .mainViewController\n             if mainController is UINavigationController {\n-                let nav = (mainController as? UINavigationController)!\n-                initialVC = nav.viewControllers.last\n+              let nav = (mainController as? UINavigationController)!\n+              initialVC = nav.viewControllers.last\n+\n             }\n-        }\n-        \n-        NotificationHandler.instance.appOpenFromNotification = true\n-        NotificationHandler.instance.studyId = (userInfoDetails[kStudyId] as? String)!\n-        NotificationHandler.instance.activityId = (userInfoDetails[kActivityId] as? String)!\n-        \n-        if !(initialVC is UITabBarController) {\n-            //push tabbar and switch to activty tab\n+\n+          }\n+          // Handling Notifications based on SubType\n+          switch notificationSubType! as AppNotification.NotificationSubType {\n+          case .Activity, .Resource:  // Activity & Resource  Notifications\n+\n+            if !(initialVC is UITabBarController) {\n+              // push tabbar and switch to activty tab\n+\n+              self.pushToTabbar(\n+                viewController: initialVC!,\n+                selectedTab: (\n+                  notificationSubType! as AppNotification.NotificationSubType\n+                    == .Activity\n+                ) ? 0 : 2)\n+\n+            } else {\n+              // switch to activity tab\n+              (initialVC as? UITabBarController)!.selectedIndex = (\n+                notificationSubType! as AppNotification.NotificationSubType\n+                  == .Activity\n+              ) ? 0 : 2\n+            }\n+\n+          case .Study, .studyEvent:  // Study Notifications\n+\n+            let leftController = (\n+              (menuVC as? FDASlideMenuViewController)!.leftViewController\n+                as? LeftMenuViewController\n+            )!\n+\n             if !(initialVC is StudyListViewController) {\n-                \n-                let leftController = ((menuVC as? FDASlideMenuViewController)!.leftViewController as? LeftMenuViewController)!\n+\n+              if initialVC is ProfileViewController || initialVC\n+                is ReachoutOptionsViewController\n+                || initialVC is GatewayResourcesListViewController {\n+\n+                NotificationHandler.instance.appOpenFromNotification = true\n+                NotificationHandler.instance.studyId = studyId\n+\n                 leftController.changeViewController(.studyList)\n                 leftController.createLeftmenuItems()\n+\n+              } else if initialVC is UITabBarController {\n+\n+              }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4ODMxOQ==", "bodyText": "nit: extra white line", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391688319", "createdAt": "2020-03-12T15:09:30Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/AppDelegate.swift", "diffHunk": "@@ -1,1900 +1,1844 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC\n+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import Fabric\n-import Crashlytics\n-import UserNotifications\n-import RealmSwift\n import CallKit\n import IQKeyboardManagerSwift\n+import RealmSwift\n+import UIKit\n+import UserNotifications\n \n-let kEncryptionKey = \"EncryptionKey\"\n-let kEncryptionIV =  \"EncryptionIV\"\n-let kBlockerScreenLabelText = \"Please update to the latest version of app to continue.\"\n-let kConsentUpdatedTitle = \"Consent Updated\"\n+@UIApplicationMain\n \n-let kMessageConsentUpdatedPartTwo = \" Please review the revised Consent terms and provide your Informed Consent, to continue participating in the study.\"\n+class AppDelegate: UIResponder, UIApplicationDelegate {\n \n-let kMessageConsentUpdated = \"The Consent Document for this study has been updated.\" + kMessageConsentUpdatedPartTwo\n+  var window: UIWindow?\n \n-let kReviewTitle = \"Review\"\n-let kPasscodeStepIdentifier = \"PasscodeStep\"\n-let kPasscodeTaskIdentifier = \"PassCodeTask\"\n-let kMessagePasscode = \"Passcode\"\n-let kMessagePasscodeSignOut = \"You will be signed out and will need to sign in again. Are you sure you want to proceed?\"\n-let kNewProgressViewNIB = \"NewProgressView\"\n-let kforgotPasscodeTitle = \"Forgot Passcode? Sign In Again\"\n-let kStudyStoryboard = \"Study\"\n-let kPasscodeSetUpText = \"Set up a passcode for the app\"\n-let kIphoneSimulator =  \"iPhone Simulator\"\n+  var notificationDetails: [String: Any]? = [String: Any]()\n \n-let kBundleIdentier = \"CFBundleIdentifier\"\n-let kPDFCreationNotificationId = \"pdfCreationNotificationIdentifier\"\n-let ksetUpTimeIdentifier = \"setUPTime\"\n-let kCFBundleShortVersion = \"CFBundleShortVersionString\"\n+  var appIsResignedButDidNotEnteredBackground: Bool? = false\n \n-let kResultCount = \"resultCount\"\n-let kResultsForAppStore = \"results\"\n-let kAppStoreVersion = \"version\"\n+  var alertVCPresented: UIAlertController?\n \n-let kContinueButtonTitle =  NSLocalizedString(\"Continue\", comment:\"\")\n-let kType = \"type\"\n+  var isPasscodePresented: Bool? = false\n \n-let kCurrentVersion = \"currentVersion\"\n-let kForceUpdate = \"forceUpdate\"\n-let kMessage = \"message\"\n-let kVisualStepId = \"visual\"\n-let kMessageString = \"Message\"\n+  var isComprehensionFailed: Bool? = false\n \n+  var parentViewControllerForAlert: UIViewController?\n \n-@UIApplicationMain\n+  var iscomingFromForgotPasscode: Bool? = false\n \n-class AppDelegate: UIResponder, UIApplicationDelegate {\n-    \n-    var window: UIWindow?\n-    \n-    var notificationDetails:Dictionary<String,Any>? = Dictionary<String,Any>()\n-    \n-    var appIsResignedButDidNotEnteredBackground:Bool? = false\n-    \n-    var alertVCPresented:UIAlertController?\n-    \n-    var isPasscodePresented:Bool? =  false\n-    \n-    var isComprehensionFailed:Bool? = false\n-    \n-    var parentViewControllerForAlert:UIViewController?\n-    \n-    var iscomingFromForgotPasscode:Bool? =  false\n-    \n-    var isAppLaunched: Bool? = false\n-    \n-    let healthStore = HKHealthStore()\n-    var containerViewController: ResearchContainerViewController? {\n-        return window?.rootViewController as? ResearchContainerViewController\n+  var isAppLaunched: Bool? = false\n+\n+  let healthStore = HKHealthStore()\n+\n+  var containerViewController: ResearchContainerViewController? {\n+    return window?.rootViewController as? ResearchContainerViewController\n+  }\n+\n+  var selectedController: UIViewController?\n+\n+  var shouldAddForceUpgradeScreen = false\n+\n+  var retryView: ComprehensionFailure?\n+\n+  var blockerScreen: AppUpdateBlocker?\n+  var passcodeParentControllerWhileSetup: UIViewController?\n+\n+  /// to be used in case of ineligible\n+  var consentToken: String? = \"\"\n+\n+  /// Register for Remote Notification\n+  func askForNotification() {\n+\n+    if #available(iOS 10.0, *) {\n+      let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n+      UNUserNotificationCenter.current().requestAuthorization(\n+        options: authOptions,\n+        completionHandler: { _, _ in })\n+\n+      // For iOS 10 display notification (sent via APNS)\n+      UNUserNotificationCenter.current().delegate = self\n+\n+    } else {\n+      let settings: UIUserNotificationSettings = UIUserNotificationSettings(\n+        types: [.alert, .badge, .sound], categories: nil)\n+      UIApplication.shared.registerUserNotificationSettings(settings)\n     }\n-    \n-    var selectedController: UIViewController?\n-    \n-    var shouldAddForceUpgradeScreen = false\n-    \n-    var retryView: ComprehensionFailure?\n-    \n-    var blockerScreen: AppUpdateBlocker?\n-    var passcodeParentControllerWhileSetup: UIViewController?\n-    \n-    var consentToken: String? = \"\" //to be used in case of ineligible\n-    \n-    //Register Remote Notification\n-    func askForNotification() {\n-        \n-        if #available(iOS 10.0, *) {\n-            let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n-            UNUserNotificationCenter.current().requestAuthorization(\n-                options: authOptions,\n-                completionHandler: {_, _ in })\n-            \n-            // For iOS 10 display notification (sent via APNS)\n-            UNUserNotificationCenter.current().delegate = self\n-            \n-        }else {\n-            let settings: UIUserNotificationSettings =\n-                UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)\n-            UIApplication.shared.registerUserNotificationSettings(settings)\n-        }\n-        UIApplication.shared.registerForRemoteNotifications()\n+    UIApplication.shared.registerForRemoteNotifications()\n+  }\n+\n+  /// Updates Key & InitializationVector for Encryption\n+  func updateKeyAndInitializationVector() {\n+\n+    let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n+    let currentIndex = currentDate.index(currentDate.endIndex, offsetBy: -13)\n+    let subStringFromDate = String(currentDate[..<currentIndex])\n+\n+    if User.currentUser.userType == .FDAUser {  // Registered/LogedIn User\n+\n+      let index = User.currentUser.userId.index(User.currentUser.userId.endIndex, offsetBy: -16)\n+      let subKey = String(User.currentUser.userId[..<index])\n+      FDAKeychain.shared[kEncryptionKey] = subKey + subStringFromDate\n+    } else {  // Anonymous User\n+      FDAKeychain.shared[kEncryptionKey] = kEncryptionKey\n     }\n-    \n-    /**\n-     Updates Key & InitializationVector for Encryption\n-     */\n-    func updateKeyAndInitializationVector() {\n-        \n-        let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n-        let currentIndex = currentDate.index(currentDate.endIndex\n-            , offsetBy: -13)\n-        let subStringFromDate = String(currentDate[..<currentIndex])\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if User.currentUser.userType ==  .FDAUser { // Registered/LogedIn User\n-            \n-            let index =  User.currentUser.userId.index(User.currentUser.userId.endIndex\n-                , offsetBy: -16)\n-            let subKey = String(User.currentUser.userId[..<index]) //User.currentUser.userId.substring(to: index ) // 36 - 12 =  24 characters\n-            ud.set(\"\\(subKey + subStringFromDate)\", forKey: kEncryptionKey)\n-            \n-        }else { // Anonymous User\n-            ud.set(currentDate + kDefaultPasscodeString, forKey: kEncryptionKey)\n-        }\n-        \n-        if UIDevice.current.model == kIsIphoneSimulator {\n-            // simulator\n-            ud.set(kdefaultIVForEncryption, forKey: kEncryptionIV)\n-        }else {\n-            // Device\n-            var udid = UIDevice.current.identifierForVendor?.uuidString\n-            let index =  udid?.index((udid?.endIndex)!\n-                , offsetBy: -20)\n-            udid = String((udid?[..<index!])!)//udid?.substring(to: index!)\n-            ud.set(udid, forKey: kEncryptionIV)\n+\n+    if UIDevice.current.model == kIsIphoneSimulator {\n+      FDAKeychain.shared[kEncryptionIV] = kdefaultIVForEncryption\n+    } else {\n+      // Device\n+      var udid = UIDevice.current.identifierForVendor?.uuidString\n+      let index = udid?.index((udid?.endIndex)!, offsetBy: -20)\n+      udid = String((udid?[..<index!])!)\n+      FDAKeychain.shared[kEncryptionIV] = udid\n+    }\n+    //ud.synchronize()\n+  }\n+\n+  /// Handler for TimeZone changes, updates time zone in the local database\n+  func calculateTimeZoneChange() {\n+\n+    let timeZoneCurrent = TimeZone.current\n+    let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n+\n+    // Saving TimeZone to User Defaults\n+    let ud = UserDefaults.standard\n+    let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n+\n+    // Saving time difference\n+    if setuptimeDiff == nil {\n+      ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n+      ud.set(0, forKey: \"offset\")\n+\n+    } else {\n+\n+      let difference = differenceFromCurrent - setuptimeDiff!\n+      ud.set(difference, forKey: \"offset\")\n+      if difference == 0 {\n+        // Do Nothing\n+      } else {\n+\n+        Schedule._formatter = nil\n+        Schedule._formatter2 = nil\n+      }\n+    }\n+    ud.synchronize()\n+  }\n+\n+  // MARK: - Realm Migragion\n+  func generateRealmKeys() {\n+\n+    // Realm Encryption key generation\n+    if FDAKeychain.shared[kRealmEncryptionKeychainKey] == nil {\n+      // Generate 64 bytes of random data to serve as the encryption key\n+      var realmKey = kRealmEncryptionDefaultKey\n+      var key = Data(count: 64)\n+      let result = key.withUnsafeMutableBytes {\n+        SecRandomCopyBytes(kSecRandomDefault, 64, $0.baseAddress!)\n+      }\n+      if result == errSecSuccess {\n+        realmKey = key.base64EncodedString()\n+      } else {\n+        Logger.sharedInstance.info(\"Problem generating random bytes\")\n+\n+      }\n+      FDAKeychain.shared[kRealmEncryptionKeychainKey] = realmKey\n+    }\n+  }\n+\n+  func checkForRealmMigration() {\n+\n+    self.generateRealmKeys()\n+\n+    let key = FDAKeychain.shared[kRealmEncryptionKeychainKey]\n+    let keyData = Data.init(base64Encoded: key!)\n+\n+    let config = Realm.Configuration(\n+      encryptionKey: keyData,\n+      schemaVersion: 1,\n+      migrationBlock: { _, oldSchemaVersion in\n+        // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n+        if oldSchemaVersion < 1 {\n+          // Nothing to do!\n+          // Realm will automatically detect new properties and removed properties\n+          // And will update the schema on disk automatically\n         }\n+      })\n+\n+    // Tell Realm to use this new configuration object for the default Realm\n+    Realm.Configuration.defaultConfiguration = config\n+  }\n+\n+  // MARK: - App Delegates methods\n+\n+  func application(\n+    _ application: UIApplication,\n+    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n+  ) -> Bool {\n+    // Override point for customization after application launch.\n+\n+    self.isAppLaunched = true\n+    IQKeyboardManager.shared.enable = true\n+    Logger.sharedInstance.info(Utilities.isStandaloneApp(), \"Standalone\")\n+    self.customizeNavigationBar()\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+\n+    //Check For Updates\n+    self.checkForAppUpdate()\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    SyncUpdate.currentSyncUpdate = SyncUpdate()\n+\n+    // Register observer for Network change\n+    NotificationCenter.default.addObserver(\n+      SyncUpdate.currentSyncUpdate as Any,\n+      selector: #selector(SyncUpdate.currentSyncUpdate?.updateData),\n+      name: ReachabilityChangedNotification, object: nil)\n+\n+    let ud1 = UserDefaults.standard\n+\n+    // Check if App is launched because of Notification Received\n+    if launchOptions != nil && launchOptions?[.sourceApplication] == nil {\n+\n+      ud1.set(\"not null\", forKey: \"launch\")\n+\n+      // Launched from push notification\n+      let notification = launchOptions?[.remoteNotification]\n+\n+      if Utilities.isValidObject(someObject: notification as AnyObject) {  // Launched from Remote Notification\n+\n+        notificationDetails = notification as? [String: Any]\n+\n+        let ud = UserDefaults.standard\n+        ud.set(true, forKey: kShowNotification)\n         ud.synchronize()\n-    }\n-    \n-    /**\n-     Handler for TimeZone changes, updates time zone in the local database\n-     */\n-    func calculateTimeZoneChange() {\n-        \n-        //let date = Date().utcDate()\n-        \n-        //let timeZoneUTC = TimeZone(abbreviation: \"UTC\")\n-        //let timeZoneAutoCurrent = TimeZone.autoupdatingCurrent\n-        let timeZoneCurrent = TimeZone.current\n-        \n-        //let differenceFromUTC = timeZoneUTC?.secondsFromGMT()\n-        let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n-        //let differenceFromAutoCurrent = timeZoneCurrent.secondsFromGMT()\n-        \n-        //Saving TimeZone to User Defaults\n+\n+      } else {  // Regular Launch\n+\n+        ud1.set(\"invalid\", forKey: \"launch\")\n         let ud = UserDefaults.standard\n-        let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n-        \n-        //Saving time difference\n-        if setuptimeDiff == nil {\n-            ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n-            ud.set(0, forKey: \"offset\")\n-            \n-        }else {\n-            \n-            let difference = differenceFromCurrent - setuptimeDiff!\n-            ud.set(difference, forKey: \"offset\")\n-            if difference == 0 {\n-                // Do Nothing\n-            }else {\n-                \n-                Schedule._formatter = nil\n-                Schedule._formatter2 = nil\n-            }\n-        }\n+        ud.set(false, forKey: kShowNotification)\n         ud.synchronize()\n+      }\n     }\n-    \n-    func checkForAppReopenNotification() {\n-        \n-        //remove if notification is available\n-        LocalNotification.removeReopenAppNotification()\n-        LocalNotification.registerReopenAppNotification()\n-        \n-    }\n-    \n-    // MARK: Realm Migragion\n-    func checkForRealmMigration() {\n-        \n-        let config = Realm.Configuration(\n-            // Set the new schema version. This must be greater than the previously used\n-            // version (if you've never set a schema version before, the version is 0).\n-            schemaVersion: 3,\n-            \n-            // Set the block which will be called automatically when opening a Realm with\n-            // a schema version lower than the one set above\n-            migrationBlock: { migration, oldSchemaVersion in\n-                // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n-                if (oldSchemaVersion < 1) {\n-                    // Nothing to do!\n-                    // Realm will automatically detect new properties and removed properties\n-                    // And will update the schema on disk automatically\n-                }\n-        })\n-        \n-        // Tell Realm to use this new configuration object for the default Realm\n-        Realm.Configuration.defaultConfiguration = config\n-        \n-        // Now that we've told Realm how to handle the schema change, opening the file\n-        // will automatically perform the migration\n-        let _ = try! Realm()\n-    }\n-    \n-    func fireNotiffication(intervel:Int) {\n-        \n-        let content = UNMutableNotificationContent()\n-        content.body = \"message\"\n-        \n-        content.sound = UNNotificationSound.default\n-        content.badge = 1\n-        let date = Date().addingTimeInterval(TimeInterval(intervel))\n-        var timeInterval = date.timeIntervalSinceNow\n-\n-        \n-        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: timeInterval, repeats: false)\n-        let id = Utilities.randomString(length: 10)\n-        let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)\n-        let center = UNUserNotificationCenter.current()\n-        center.add(request)\n-    }\n-    \n-    // MARK: App Delegates\n-    \n-    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n-        // Override point for customization after application launch.\n-        \n-        self.isAppLaunched = true\n-        IQKeyboardManager.shared.enable = true\n-        print(Utilities.isStandaloneApp(),\"standalone\")\n-        self.customizeNavigationBar()\n-        Fabric.with([Crashlytics.self])\n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        \n-        //Check For Updates\n-        //self.checkForAppUpdateForVersion()\n-        self.checkForAppUpdate()\n-        \n-        if UIApplication.shared.applicationIconBadgeNumber > 0 {\n-            UIApplication.shared.applicationIconBadgeNumber = 0\n-        }\n-        \n-        SyncUpdate.currentSyncUpdate = SyncUpdate()\n-        \n-        //Register observer for Network change\n-        NotificationCenter.default.addObserver(SyncUpdate.currentSyncUpdate as Any , selector: #selector(SyncUpdate.currentSyncUpdate?.updateData), name: Notification.Name.reachabilityChanged, object: nil)\n-        \n-        let ud1 = UserDefaults.standard\n-        \n-        //Check if App is launched because of Notification Received\n-        if (launchOptions != nil && launchOptions?[.sourceApplication] == nil) {\n-            \n-            ud1.set(\"not null\", forKey: \"launch\")\n-            \n-            // Launched from push notification\n-            let notification = launchOptions?[.remoteNotification]\n-            \n-            if Utilities.isValidObject(someObject: notification as AnyObject) { // Launched from Remote Notification\n-                \n-                notificationDetails = notification as? Dictionary<String, Any>\n-                \n-                let ud = UserDefaults.standard\n-                ud.set(true, forKey: kShowNotification)\n-                ud.synchronize()\n-                \n-            }else if (launchOptions?[.localNotification] != nil) { //Launched from Local Notification\n-                \n-                ud1.set(\"local\", forKey: \"launch\")\n-                let localNotification = (launchOptions?[.localNotification] as? UILocalNotification)!\n-                let notificationDetails = (localNotification.userInfo as? Dictionary<String, Any>)!\n-                \n-                NotificationHandler.instance.appOpenFromNotification = true\n-                NotificationHandler.instance.studyId = (notificationDetails[kStudyId] as? String)!\n-                NotificationHandler.instance.activityId = (notificationDetails[kActivityId] as? String)!\n-                ud1.synchronize()\n-                \n-            }else { //Regular Launch\n-                \n-                ud1.set(\"invalid\", forKey: \"launch\")\n-                UIApplication.shared.applicationIconBadgeNumber = 0\n-                \n-                let ud = UserDefaults.standard\n-                ud.set(false, forKey: kShowNotification)\n-                ud.synchronize()\n-            }\n-        }\n-        \n-        //self.fireNotiffication(intervel: 10)\n-        //self.fireNotiffication(intervel: 15)\n-        \n-        //Check if Database needs migration\n-        self.checkForRealmMigration()\n-        return true\n-    }\n-    \n-    func applicationWillResignActive(_ application: UIApplication) {\n-        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.\n-        \n-        // set Flag to handle background to foreground transition\n-        self.appIsResignedButDidNotEnteredBackground = true\n-    }\n-    \n-    func applicationDidEnterBackground(_ application: UIApplication) {\n-        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n-        \n-        // set Flag to handle foreground to background transition\n-        self.appIsResignedButDidNotEnteredBackground = false\n-    }\n-    \n-    \n-    func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {\n-    }\n-    \n-    \n-    func applicationWillEnterForeground(_ application: UIApplication) {\n-        \n-        self.checkPasscode(viewController: (application.windows[0].rootViewController)!)\n-        \n-        self.checkForStudyUpdates()\n-        \n-        let number = UIApplication.shared.applicationIconBadgeNumber\n-        if number >= 1 {\n-            self.updateNotification()\n-        }\n-        \n-        //Check For Updates\n-        self.checkForAppUpdate()\n-        \n+\n+    // Check if Database needs migration\n+    self.checkForRealmMigration()\n+    return true\n+  }\n+\n+  func applicationWillResignActive(_ application: UIApplication) {\n+    // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.\n+\n+    // set Flag to handle background to foreground transition\n+    self.appIsResignedButDidNotEnteredBackground = true\n+  }\n+\n+  func applicationDidEnterBackground(_ application: UIApplication) {\n+    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n+\n+    // set Flag to handle foreground to background transition\n+    self.appIsResignedButDidNotEnteredBackground = false\n+  }\n+\n+  func application(\n+    _ application: UIApplication,\n+    performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) ->\n+      Void\n+  ) {\n+  }\n+\n+  func applicationWillEnterForeground(_ application: UIApplication) {\n+\n+    self.checkPasscode(viewController: (application.windows[0].rootViewController)!)\n+    self.checkForStudyUpdates()\n+    let number = UIApplication.shared.applicationIconBadgeNumber\n+    if number >= 1 {\n+      self.updateNotification()\n     }\n-    \n-    func applicationDidBecomeActive(_ application: UIApplication) {\n-        \n-        // self.window?.isHidden = false\n-        \n-        UIApplication.shared.applicationIconBadgeNumber = 0\n-        \n-        if self.appIsResignedButDidNotEnteredBackground! {\n-            \n-            let navController = application.windows[0].rootViewController\n-            \n-            \n-            let isTaskViewControllerVisible = (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKTaskViewController.self)\n-            \n-           // guard let navigation = (navController as? UINavigationController)?.visibleViewController as? ORKTaskViewController, let navigationTitle = navigation.title else {return}\n-            \n-            let navigationTitle = ((navController as? UINavigationController)?.visibleViewController as? ORKTaskViewController)?.title ?? \"\"\n-            \n-            if (navController as? UINavigationController) != nil &&  isTaskViewControllerVisible == false {\n-                \n-                if (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKPasscodeViewController.self) == false {\n-                    //Request for Passcode\n-                    //self.checkPasscode(viewController: navController!)\n-                }\n-                \n-            } else if(navController as? UINavigationController) != nil\n-                &&  isTaskViewControllerVisible == true\n-                && navigationTitle == \"Activity\" {\n-                \n-                if (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKPasscodeViewController.self) == false {\n-                    //Request for Passcode\n-                    //self.checkPasscode(viewController: navController!)\n-                }\n-            } else if(navController as? UIViewController) != nil {\n-               // self.checkPasscode(viewController: navController!)\n-            }\n-        }\n-        \n-        //Check if App running on Jailbreak Device\n-        if AppDelegate.jailbroken(application: application) {\n-            \n-            let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-            let appBlocker = JailbrokeBlocker.instanceFromNib(frame: navigationController.view.frame, detail: nil);\n-            UIApplication.shared.keyWindow?.addSubview(appBlocker);\n-            UIApplication.shared.keyWindow?.bringSubviewToFront(appBlocker)\n-            \n-        }\n-        \n-        //Update TimeZone Changes if any\n-        self.calculateTimeZoneChange()\n-        \n-        if self.isAppLaunched! {\n-            self.isAppLaunched = false\n-            \n-            //Update Local Notifications\n-            self.checkForRegisteredNotifications()\n+\n+    // Check For Updates\n+    self.checkForAppUpdate()\n+\n+  }\n+\n+  func applicationDidBecomeActive(_ application: UIApplication) {\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    if self.appIsResignedButDidNotEnteredBackground! {\n+\n+      let navController = application.windows[0].rootViewController\n+\n+      let isTaskViewControllerVisible = (navController as? UINavigationController)?\n+        .visibleViewController?.isKind(of: ORKTaskViewController.self)\n+\n+      let navigationTitle = (\n+        (navController as? UINavigationController)?.visibleViewController\n+          as? ORKTaskViewController\n+      )?.title ?? \"\"\n+\n+      if (navController as? UINavigationController) != nil && isTaskViewControllerVisible\n+        == false {\n+\n+        if (navController as? UINavigationController)?.visibleViewController?.isKind(\n+          of: ORKPasscodeViewController.self) == false {\n+          // Request for Passcode\n+          self.checkPasscode(viewController: navController!)\n         }\n-    }\n-    \n-    func applicationWillTerminate(_ application: UIApplication) {\n-        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.\n-    }\n-    \n-    // MARK:- NOTIFICATION\n-    \n-    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n-        \n-        let deviceTokenString = deviceToken.reduce(\"\", {$0 + String(format: \"%02X\", $1)})\n-        print(\"Token: \\(deviceTokenString)\")\n-        \n-        if  User.currentUser.userType == .FDAUser {\n-            \n-            User.currentUser.settings?.remoteNotifications = true\n-            User.currentUser.settings?.localNotifications = true\n-            //Update device Token to Local server\n-            UserServices().updateUserProfile(deviceToken: deviceTokenString , delegate: self)\n-            \n+\n+      } else if (navController as? UINavigationController) != nil\n+        && isTaskViewControllerVisible == true\n+        && navigationTitle == \"Activity\" {\n+\n+        if (navController as? UINavigationController)?.visibleViewController?.isKind(\n+          of: ORKPasscodeViewController.self) == false {\n+          // Request for Passcode\n+          self.checkPasscode(viewController: navController!)\n         }\n-        \n+      } else if (navController) != nil {\n+        self.checkPasscode(viewController: navController!)\n+      }\n     }\n-    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {\n-        \n-        print(\"Token Registration failed  \\(error)\")\n-        \n-    }\n-    \n-    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) {\n-        \n-        //For iOS 8 & 9\n-        if (UIApplication.shared.applicationState == .background)||(UIApplication.shared.applicationState == .inactive) {\n-            \n-            self.updateNotification()\n-            self.handleLocalAndRemoteNotification(userInfoDetails: (userInfo as? Dictionary<String, Any>)!)\n-        }\n-        \n-        // userInfo is valid\n-        if userInfo.count > 0 && userInfo.keys.contains(kType) {\n-            self.updateNotification()\n-            \n-        }else {\n-            if (UIApplication.shared.applicationState == .background || (UIApplication.shared.applicationState == .inactive)) {\n-                //Handle local Notification Received\n-                self.handleLocalNotification(userInfoDetails: (userInfo as? Dictionary<String, Any>)!)\n-            }\n-        }\n+\n+    // Check if App running on Jailbreak Device\n+    if AppDelegate.jailbroken(application: application) {\n+\n+      let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+      let appBlocker = JailbrokeBlocker.instanceFromNib(\n+        frame: navigationController.view.frame)\n+      UIApplication.shared.keyWindow?.addSubview(appBlocker)\n+      UIApplication.shared.keyWindow?.bringSubviewToFront(appBlocker)\n+\n     }\n-    \n-    func application(_ application: UIApplication, didReceive notification: UILocalNotification) {\n-        \n-        self.handleLocalNotification(userInfoDetails: (notification.userInfo as? Dictionary<String, Any>)!)\n+\n+    // Update TimeZone Changes if any\n+    self.calculateTimeZoneChange()\n+\n+    if self.isAppLaunched! {\n+      self.isAppLaunched = false\n+\n+      // Update Local Notifications\n+      self.checkForRegisteredNotifications()\n     }\n-    \n-    // MARK: Jailbreak Methods\n-    \n-    public static func jailbroken(application: UIApplication) -> Bool {\n-        guard let cydiaUrlScheme = NSURL(string: \"cydia://package/com.example.package\") else { return isJailbroken() }\n-        return application.canOpenURL(cydiaUrlScheme as URL) || isJailbroken()\n+  }\n+\n+  func applicationWillTerminate(_ application: UIApplication) {\n+    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.\n+  }\n+\n+  // MARK: - NOTIFICATION\n+\n+  func application(\n+    _ application: UIApplication,\n+    didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data\n+  ) {\n+\n+    let deviceTokenString = deviceToken.reduce(\"\", { $0 + String(format: \"%02X\", $1) })\n+    print(\"Token: \\(deviceTokenString)\")\n+\n+    if User.currentUser.userType == .FDAUser {\n+\n+      User.currentUser.settings?.remoteNotifications = true\n+      User.currentUser.settings?.localNotifications = true\n+      // Update device Token to Local server\n+      UserServices().updateUserProfile(deviceToken: deviceTokenString, delegate: self)\n+\n     }\n-    \n-    \n-    static func isJailbroken() -> Bool {\n-        \n-        if UIDevice.current.model != kIphoneSimulator {\n-            return false\n-        }\n-        \n-        let fileManager = FileManager.default\n-        if fileManager.fileExists(atPath: \"/Applications/Cydia.app\") ||\n-            fileManager.fileExists(atPath: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") ||\n-            fileManager.fileExists(atPath: \"/bin/bash\") ||\n-            fileManager.fileExists(atPath: \"/usr/sbin/sshd\") ||\n-            fileManager.fileExists(atPath: \"/etc/apt\") ||\n-            fileManager.fileExists(atPath: \"/usr/bin/ssh\") {\n-            return true\n-        }\n-        \n-        if canOpen(path: \"/Applications/Cydia.app\") ||\n-            canOpen(path: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") ||\n-            canOpen(path: \"/bin/bash\") ||\n-            canOpen(path: \"/usr/sbin/sshd\") ||\n-            canOpen(path: \"/etc/apt\") ||\n-            \n-            canOpen(path: \"/usr/bin/ssh\") {\n-            return true\n-        }\n-        \n-        let path = \"/private/\" + NSUUID().uuidString\n-        do {\n-            try \"anyString\".write(toFile: path, atomically: true, encoding: String.Encoding.utf8)\n-            try fileManager.removeItem(atPath: path)\n-            return true\n-        }catch {\n-            return false\n-        }\n+\n+  }\n+\n+  func application(\n+    _ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error\n+  ) {\n+\n+    Logger.sharedInstance.info(\"Token Registration failed  \\(error)\")\n+\n+  }\n+\n+  // MARK: - Jailbreak Methods\n+\n+  /// Checks Jailbroken status\n+  /// - Parameter application: `UIApplication` instance\n+  /// - Returns: `Boolean` state of Jailbroken\n+  public static func jailbroken(application: UIApplication) -> Bool {\n+    guard let cydiaUrlScheme = NSURL(string: \"cydia://package/com.example.package\") else {\n+      return isJailbroken()\n+    }\n+    return application.canOpenURL(cydiaUrlScheme as URL) || isJailbroken()\n+  }\n+\n+  /// Checks Jailbroken status\n+  /// - Returns: `Boolean` state of Jailbroken\n+  static func isJailbroken() -> Bool {\n+\n+    if UIDevice.current.model != kIphoneSimulator {\n+      return false\n     }\n-    \n-    static func canOpen(path: String) -> Bool {\n-        let file = fopen(path, \"r\")\n-        guard file != nil else { return false }\n-        fclose(file)\n-        return true\n+\n+    let fileManager = FileManager.default\n+    if fileManager.fileExists(atPath: \"/Applications/Cydia.app\") || fileManager.fileExists(\n+      atPath: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") || fileManager.fileExists(\n+        atPath: \"/bin/bash\") || fileManager.fileExists(atPath: \"/usr/sbin/sshd\")\n+      || fileManager\n+      .fileExists(atPath: \"/etc/apt\") || fileManager.fileExists(atPath: \"/usr/bin/ssh\") {\n+      return true\n     }\n-    \n-    // MARK: Add Retry Screen\n-    \n-    func addRetryScreen(viewController: UIViewController?) {\n-        \n-        let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-        self.retryView = ComprehensionFailure.instanceFromNib(frame: navigationController.view.frame, detail: nil);\n-        \n-        if viewController != nil {\n-            retryView?.delegate = (viewController as? ComprehensionFailureDelegate)!\n-            \n-        }else {\n-            retryView?.delegate = (self as? ComprehensionFailureDelegate)!\n-        }\n-        UIApplication.shared.keyWindow?.addSubview(retryView!);\n-        UIApplication.shared.keyWindow?.bringSubviewToFront(retryView!)\n+\n+    if canOpen(path: \"/Applications/Cydia.app\") || canOpen(\n+      path: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") || canOpen(path: \"/bin/bash\")\n+      || canOpen(path: \"/usr/sbin/sshd\") || canOpen(path: \"/etc/apt\") || canOpen(\n+        path: \"/usr/bin/ssh\") {\n+      return true\n     }\n-    \n-    // MARK:Custom Navigation Bar\n-    \n-    func customizeNavigationBar() {\n-        UINavigationBar.appearance().titleTextAttributes = [\n-            NSAttributedString.Key.font: UIFont(name: \"HelveticaNeue-Medium\", size: 18)!\n-        ]\n+\n+    let path = \"/private/\" + NSUUID().uuidString\n+    do {\n+      try \"anyString\".write(toFile: path, atomically: true, encoding: String.Encoding.utf8)\n+      try fileManager.removeItem(atPath: path)\n+      return true\n+    } catch {\n+      return false\n+    }\n+  }\n+\n+  static func canOpen(path: String) -> Bool {\n+    let file = fopen(path, \"r\")\n+    guard file != nil else { return false }\n+    fclose(file)\n+    return true\n+  }\n+\n+  // MARK: - Add Retry Screen\n+\n+  /// Present Retry View\n+  /// - Parameter viewController: `UIViewController` instance\n+  func addRetryScreen(viewController: UIViewController?) {\n+\n+    let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+    self.retryView = ComprehensionFailure.instanceFromNib(\n+      frame: navigationController.view.frame, detail: nil)\n+\n+    if viewController != nil {\n+      retryView?.delegate = (viewController as? ComprehensionFailureDelegate)!\n+\n+    } else {\n+      retryView?.delegate = self\n     }\n-    \n-    // MARK: Checker Methods\n-    \n-    /**\n-     To get the current App version from App Store and Adds the blocker screen if it is of lower version\n-     */\n-    func checkForAppUpdate() {\n-        WCPServices().checkForAppUpdates(delegate: self)\n+    UIApplication.shared.keyWindow?.addSubview(retryView!)\n+    UIApplication.shared.keyWindow?.bringSubviewToFront(retryView!)\n+  }\n+\n+  // MARK: - Custom Navigation Bar\n+\n+  func customizeNavigationBar() {\n+    UINavigationBar.appearance().titleTextAttributes = [\n+      NSAttributedString.Key.font: UIFont(name: \"HelveticaNeue-Medium\", size: 18)!\n+    ]\n+  }\n+\n+  // MARK: - Checker Methods\n+\n+  /// Get the current App version from App Store and Adds the blocker screen if it is of lower version\n+  func checkForAppUpdate() {\n+    WCPServices().checkForAppUpdates(delegate: self)\n+  }\n+\n+  /// Registers pending notifications based on UserType\n+  func checkForRegisteredNotifications() {\n+\n+    if User.currentUser.userType == .FDAUser {\n+\n+      let center = UNUserNotificationCenter.current()\n+      center.getPendingNotificationRequests(\n+        completionHandler: { requests in\n+          if requests.count < 50 {\n+            LocalNotification.refreshAllLocalNotification()\n+          }\n+        })\n     }\n-    \n-    func checkForRegisteredNotifications() {\n-        \n-        if User.currentUser.userType == .FDAUser {\n-           \n-            let center = UNUserNotificationCenter.current()\n-            center.getPendingNotificationRequests(completionHandler: { requests in\n-                print(requests)\n-                if requests.count < 50 {\n-                     LocalNotification.refreshAllLocalNotification()\n-                }\n-            })\n-            \n-            //check if notifications are expired or already fired\n-//            if scheduledNotifications.count < 50 {\n-//                //refresh local notifcation from DB\n-//                LocalNotification.refreshAllLocalNotification()\n-//                scheduledNotifications = application.scheduledLocalNotifications!\n-//\n-//            }\n-        }\n+  }\n+\n+  /// Webservice request call to SignOut\n+  func sendRequestToSignOut() {\n+    UserServices().logoutUser(self as NMWebServiceDelegate)\n+  }\n+\n+  /// Check the  current Consent Status for Updated Version\n+  /// - Parameter controller: Instance of `UIVIewController`\n+  func checkConsentStatus(controller: UIViewController) {\n+\n+    self.selectedController = controller\n+\n+    if StudyUpdates.studyConsentUpdated {\n+      // Study consent is updated: Please Present Consent UI.\n+\n+      let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+\n+      var topController: UIViewController = navigationController\n+      if navigationController.viewControllers.count > 0 {\n+        topController = navigationController.viewControllers.first!\n+      }\n+\n+      UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+        NSLocalizedString(kConsentUpdatedTitle, comment: \"\"),\n+        errorMessage: NSLocalizedString(kMessageConsentUpdated, comment: \"\"),\n+        errorAlertActionTitle: NSLocalizedString(kReviewTitle, comment: \"\"),\n+        errorAlertActionTitle2: nil, viewControllerUsed: topController,\n+        action1: {\n+\n+          self.addAndRemoveProgress(add: true)\n+          WCPServices().getEligibilityConsentMetadata(\n+            studyId: (Study.currentStudy?.studyId)!,\n+            delegate: self as NMWebServiceDelegate)\n+\n+        },\n+        action2: {\n+        })\n+    } else {\n+      // Study consent not updated\n     }\n-    \n-    func sendRequestToSignOut() {\n-        UserServices().logoutUser(self as NMWebServiceDelegate)\n+  }\n+\n+  /// Creates Eligibility Consent Task\n+  func createEligibilityConsentTask() {\n+\n+    let taskViewController: ORKTaskViewController?\n+\n+    //create orderedTask\n+    let consentTask: ORKOrderedTask? = ConsentBuilder.currentConsent?.createConsentTask()\n+      as! ORKOrderedTask?\n+\n+    taskViewController = ORKTaskViewController(task: consentTask, taskRun: nil)\n+\n+    taskViewController?.delegate = self\n+    taskViewController?.outputDirectory = FileManager.default.urls(\n+      for: .documentDirectory, in: .userDomainMask).first!\n+\n+    taskViewController?.navigationItem.title = nil\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+\n+    var topVC = UIApplication.shared.keyWindow?.rootViewController\n+    // Fetching the current Visible Controller\n+    while topVC?.presentedViewController != nil {\n+      topVC = topVC?.presentedViewController\n     }\n-    \n-    /**\n-     check the  current Consent Status for Updated Version\n-     */\n-    func checkConsentStatus(controller: UIViewController) {\n-        \n-        self.selectedController = controller\n-        \n-        if(StudyUpdates.studyConsentUpdated) {\n-            print(\"Study consent is updated: Please Present Consent UI\")\n-            \n-            let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-            \n-            var topController: UIViewController = navigationController\n-            if navigationController.viewControllers.count > 0 {\n-                topController = navigationController.viewControllers.first!\n-            }\n-            \n-            UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(kConsentUpdatedTitle, comment: \"\"), errorMessage: NSLocalizedString(kMessageConsentUpdated, comment: \"\"), errorAlertActionTitle: NSLocalizedString(kReviewTitle, comment: \"\"),\n-                                                                 errorAlertActionTitle2: nil, viewControllerUsed: topController,\n-                                                                 action1: {\n-                                                                    \n-                                                                    self.addAndRemoveProgress(add: true)\n-                                                                    WCPServices().getEligibilityConsentMetadata(studyId:(Study.currentStudy?.studyId)!, delegate: self as NMWebServiceDelegate)\n-                                                                    \n-            },\n-                                                                 action2: {\n-            })\n-        }else {\n-            print(\"Study consent not updated\")\n-        }\n+\n+    self.addAndRemoveProgress(add: false)\n+    // present consent task\n+    taskViewController?.navigationBar.prefersLargeTitles = false\n+    taskViewController?.modalPresentationStyle = .fullScreen\n+    topVC?.present(taskViewController!, animated: true, completion: nil)\n+  }\n+\n+  /// Handler for local notification\n+  /// - Parameter userInfoDetails: Contains the info for notification\n+  func handleLocalNotification(userInfoDetails: [String: Any]) {\n+\n+    var initialVC: UIViewController?\n+\n+    // getting topmost visible controller\n+    let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+    let menuVC = navigationController.viewControllers.last\n+    if menuVC is FDASlideMenuViewController {\n+      let mainController = (menuVC as? FDASlideMenuViewController)!.mainViewController\n+      if mainController is UINavigationController {\n+        let nav = (mainController as? UINavigationController)!\n+        initialVC = nav.viewControllers.last\n+      }\n     }\n-    \n-    /**\n-     Used to Create Eligibility Consent Task\n-     */\n-    func createEligibilityConsentTask() {\n-        \n-        let taskViewController: ORKTaskViewController?\n-        \n-        //create orderedTask\n-        let consentTask: ORKOrderedTask? = ConsentBuilder.currentConsent?.createConsentTask() as! ORKOrderedTask?\n-        \n-        taskViewController = ORKTaskViewController(task: consentTask, taskRun: nil)\n-        \n-        taskViewController?.delegate = self\n-        taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-        \n-        taskViewController?.navigationItem.title = nil\n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        \n-        //UIApplication.shared.statusBarStyle = .default\n-        \n-        var topVC = UIApplication.shared.keyWindow?.rootViewController\n-        //Fetching the current Visible Controller\n-        while topVC?.presentedViewController != nil {\n-            topVC = topVC?.presentedViewController\n+\n+    NotificationHandler.instance.appOpenFromNotification = true\n+    NotificationHandler.instance.studyId = (userInfoDetails[kStudyId] as? String)!\n+    NotificationHandler.instance.activityId = (userInfoDetails[kActivityId] as? String)!\n+\n+    if !(initialVC is UITabBarController) {\n+      // push tabbar and switch to activty tab\n+      if !(initialVC is StudyListViewController) {\n+\n+        let leftController = (\n+          (menuVC as? FDASlideMenuViewController)!.leftViewController\n+            as? LeftMenuViewController\n+        )!\n+        leftController.changeViewController(.studyList)\n+        leftController.createLeftmenuItems()\n+      }\n+    } else {\n+      // switch to activty tab\n+      (initialVC as? UITabBarController)!.selectedIndex = 0\n+    }\n+  }\n+\n+  /// Handler for local & remote notification\n+  /// - Parameter userInfoDetails: contains the info for notification\n+  func handleLocalAndRemoteNotification(userInfoDetails: [String: Any]) {\n+\n+    var notificationType: String? = \"\"\n+    var notificationSubType: AppNotification.NotificationSubType? = .Announcement\n+    // User info is valid\n+    if (userInfoDetails.count) > 0 {\n+\n+      if Utilities.isValidValue(someObject: userInfoDetails[kNotificationType] as AnyObject) {\n+        notificationType = userInfoDetails[kNotificationType] as? String\n+      }\n+      if Utilities.isValidValue(\n+        someObject: userInfoDetails[kNotificationSubType] as AnyObject) {\n+        notificationSubType = AppNotification.NotificationSubType(\n+          rawValue: (userInfoDetails[kNotificationSubType] as? String)!)\n+      }\n+\n+      if notificationType == AppNotification.NotificationType.Study.rawValue {  //Study Level Notification\n+\n+        var studyId: String? = \"\"\n+\n+        if Utilities.isValidValue(someObject: userInfoDetails[kStudyId] as AnyObject) {\n+          studyId = userInfoDetails[kStudyId] as? String\n         }\n-        \n-        self.addAndRemoveProgress(add: false)\n-        //present consent task\n-        taskViewController?.modalPresentationStyle = .fullScreen\n-        topVC?.present(taskViewController!, animated: true, completion: nil)\n-    }\n-    \n-    /**\n-     Handler for local notification\n-     @param userInfoDetails, contains the info for notification\n-     */\n-    \n-    func handleLocalNotification(userInfoDetails: Dictionary<String,Any>) {\n-        \n-        var initialVC: UIViewController?\n-        \n-        //getting topmost visible controller\n-        let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-        let menuVC = navigationController.viewControllers.last\n-        if  menuVC is FDASlideMenuViewController {\n-            let mainController =  (menuVC as? FDASlideMenuViewController)!.mainViewController\n+\n+        if studyId != nil || studyId != \"\" {\n+\n+          var initialVC: UIViewController?\n+\n+          if Gateway.instance.studies?.isEmpty == false {\n+\n+            let study = Gateway.instance.studies?.filter({ $0.studyId == studyId })\n+              .first\n+            Study.updateCurrentStudy(study: study!)\n+          }\n+          // fetch the visible view controller\n+          let navigationController = (\n+            self.window?.rootViewController as? UINavigationController\n+          )!\n+          let menuVC = navigationController.viewControllers.last\n+          if menuVC is FDASlideMenuViewController {\n+            let mainController = (menuVC as? FDASlideMenuViewController)!\n+              .mainViewController\n             if mainController is UINavigationController {\n-                let nav = (mainController as? UINavigationController)!\n-                initialVC = nav.viewControllers.last\n+              let nav = (mainController as? UINavigationController)!\n+              initialVC = nav.viewControllers.last\n+\n             }\n-        }\n-        \n-        NotificationHandler.instance.appOpenFromNotification = true\n-        NotificationHandler.instance.studyId = (userInfoDetails[kStudyId] as? String)!\n-        NotificationHandler.instance.activityId = (userInfoDetails[kActivityId] as? String)!\n-        \n-        if !(initialVC is UITabBarController) {\n-            //push tabbar and switch to activty tab\n+\n+          }\n+          // Handling Notifications based on SubType\n+          switch notificationSubType! as AppNotification.NotificationSubType {\n+          case .Activity, .Resource:  // Activity & Resource  Notifications\n+\n+            if !(initialVC is UITabBarController) {\n+              // push tabbar and switch to activty tab\n+\n+              self.pushToTabbar(\n+                viewController: initialVC!,\n+                selectedTab: (\n+                  notificationSubType! as AppNotification.NotificationSubType\n+                    == .Activity\n+                ) ? 0 : 2)\n+\n+            } else {\n+              // switch to activity tab\n+              (initialVC as? UITabBarController)!.selectedIndex = (\n+                notificationSubType! as AppNotification.NotificationSubType\n+                  == .Activity\n+              ) ? 0 : 2\n+            }\n+\n+          case .Study, .studyEvent:  // Study Notifications\n+\n+            let leftController = (\n+              (menuVC as? FDASlideMenuViewController)!.leftViewController\n+                as? LeftMenuViewController\n+            )!\n+\n             if !(initialVC is StudyListViewController) {\n-                \n-                let leftController = ((menuVC as? FDASlideMenuViewController)!.leftViewController as? LeftMenuViewController)!\n+\n+              if initialVC is ProfileViewController || initialVC\n+                is ReachoutOptionsViewController\n+                || initialVC is GatewayResourcesListViewController {\n+\n+                NotificationHandler.instance.appOpenFromNotification = true\n+                NotificationHandler.instance.studyId = studyId\n+\n                 leftController.changeViewController(.studyList)\n                 leftController.createLeftmenuItems()\n+\n+              } else if initialVC is UITabBarController {\n+\n+              }\n+            } else {\n+\n+              NotificationHandler.instance.appOpenFromNotification = true\n+              NotificationHandler.instance.studyId = studyId\n+\n+              leftController.changeViewController(.studyList)\n+              leftController.createLeftmenuItems()\n             }\n+\n+          case .Announcement:\n+            break\n+          }\n         }\n-        else {\n-            //switch to activty tab\n-            (initialVC as? UITabBarController)!.selectedIndex =  0\n-        }\n+      } else if notificationType == AppNotification.NotificationType.Gateway.rawValue {  // Gateway level Notification\n+        // Do Nothing\n+      }\n     }\n-    \n-    /**\n-     Handler for local & remote notification\n-     @param userInfoDetails, contains the info for notification\n-     */\n-    func handleLocalAndRemoteNotification(userInfoDetails: Dictionary<String,Any>) {\n-        \n-        var notificationType: String? = \"\"\n-        var notificationSubType: AppNotification.NotificationSubType? = .Announcement\n-        //User info is valid\n-        if (userInfoDetails.count) > 0 {\n-            \n-            if Utilities.isValidValue(someObject: userInfoDetails[kNotificationType] as AnyObject) {\n-                notificationType =  userInfoDetails[kNotificationType] as? String\n-            }\n-            if Utilities.isValidValue(someObject: userInfoDetails[kNotificationSubType] as AnyObject) {\n-                notificationSubType = AppNotification.NotificationSubType(rawValue: (userInfoDetails[kNotificationSubType] as? String)!)\n+    self.notificationDetails = nil\n+  }\n+\n+  /// Push to tabbar Controller with tabs Activity, Dashboard & Resource\n+  /// - Parameters:\n+  ///   - viewController: Instance of `UIViewController`\n+  ///   - selectedTab: Selected tab in form of `Int`\n+  func pushToTabbar(viewController: UIViewController, selectedTab: Int) {\n+\n+    let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n+\n+    let studyDashboard = (\n+      studyStoryBoard.instantiateViewController(\n+        withIdentifier: kStudyDashboardTabbarControllerIdentifier)\n+        as? StudyDashboardTabbarViewController\n+    )!\n+\n+    studyDashboard.selectedIndex = selectedTab\n+    viewController.navigationController?.navigationBar.isHidden = true\n+    viewController.navigationController?.pushViewController(studyDashboard, animated: true)\n+  }\n+\n+  /// Verifies passcode if enabled or set passcode\n+  /// - Parameter viewController: Instance of `UIViewController`\n+  func checkPasscode(viewController: UIViewController) {\n+\n+    if User.currentUser.userType == .FDAUser {  // FDA user\n+\n+      if User.currentUser.settings?.passcode! == true {\n+        // Passcode already exist\n+        if ORKPasscodeViewController.isPasscodeStoredInKeychain() == false {\n+\n+          let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n+          passcodeStep.passcodeType = .type4Digit\n+          let task = ORKOrderedTask(\n+            identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n+          let taskViewController = ORKTaskViewController.init(task: task, taskRun: nil)\n+\n+          if viewController.isKind(of: UINavigationController.self) {\n+            taskViewController.delegate = self\n+\n+          } else {\n+            taskViewController.delegate = viewController\n+              as? ORKTaskViewControllerDelegate\n+          }\n+          taskViewController.isNavigationBarHidden = true\n+          passcodeParentControllerWhileSetup = viewController\n+          isPasscodePresented = true\n+          blockerScreen?.isHidden = true\n+          taskViewController.navigationBar.prefersLargeTitles = false\n+          taskViewController.modalPresentationStyle = .fullScreen\n+          viewController.present(taskViewController, animated: false, completion: nil)\n+\n+        } else {\n+          guard\n+            ORKPasscodeViewController.isPasscodeStoredInKeychain() && !(\n+              containerViewController?.presentedViewController\n+                is ORKPasscodeViewController\n+            )\n+          else { return }\n+          window?.makeKeyAndVisible()\n+\n+          let passcodeViewController = ORKPasscodeViewController\n+            .passcodeAuthenticationViewController(withText: \"\", delegate: self)\n+          var topVC = UIApplication.shared.keyWindow?.rootViewController\n+          var parentController: UIViewController?\n+\n+          while topVC?.presentedViewController != nil {\n+\n+            parentController = topVC\n+            topVC = topVC?.presentedViewController\n+          }\n+\n+          if topVC is UIAlertController {  // topmost Visible Controller is AlertController\n+            alertVCPresented = (topVC as? UIAlertController)!\n+\n+            if (parentController is ORKPasscodeViewController) == false {\n+              topVC?.dismiss(animated: true, completion: nil)\n             }\n-            \n-            if notificationType == AppNotification.NotificationType.Study.rawValue { //Study Level Notification\n-                \n-                var studyId: String? = \"\"\n-                \n-                if Utilities.isValidValue(someObject: userInfoDetails[kStudyId] as AnyObject) {\n-                    studyId = userInfoDetails[kStudyId] as? String\n-                }\n-                \n-                if studyId != nil || studyId != \"\" {\n-                    \n-                    var initialVC: UIViewController?\n-                    \n-                    if Gateway.instance.studies?.isEmpty == false {\n-                        \n-                        let study = Gateway.instance.studies?.filter({$0.studyId == studyId}).first\n-                        Study.updateCurrentStudy(study: study!)\n-                    }\n-                    //fetch the visible view controller\n-                    let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-                    let menuVC = navigationController.viewControllers.last\n-                    if  menuVC is FDASlideMenuViewController {\n-                        let mainController =  (menuVC as? FDASlideMenuViewController)!.mainViewController\n-                        if mainController is UINavigationController {\n-                            let nav = (mainController as? UINavigationController)!\n-                            initialVC = nav.viewControllers.last\n-                            \n-                        }\n-                        \n-                    }\n-                    //Handling Notifications based on SubType\n-                    switch notificationSubType! as AppNotification.NotificationSubType {\n-                    case .Activity, .Resource: //Activity & Resource  Notifications\n-                        \n-                        var activityId: String? = \"\"\n-                        \n-                        if Utilities.isValidValue(someObject: userInfoDetails[kActivityId] as AnyObject) {\n-                            activityId = userInfoDetails[kActivityId] as? String\n-                        }\n-                        \n-                        var resourceId: String? = \"\"\n-                        if Utilities.isValidValue(someObject: userInfoDetails[kResourceId] as AnyObject) {\n-                            resourceId = userInfoDetails[kResourceId] as? String\n-                        }\n-                        \n-                        if !(initialVC is UITabBarController) {\n-                            //push tabbar and switch to activty tab\n-                            \n-                            self.pushToTabbar(viewController: initialVC!, selectedTab: (notificationSubType! as AppNotification.NotificationSubType == .Activity) ? 0 : 2)\n-                            \n-                        }else {\n-                            //switch to activity tab\n-                            \n-                            (initialVC as? UITabBarController)!.selectedIndex =  (notificationSubType! as AppNotification.NotificationSubType == .Activity) ? 0 : 2\n-                        }\n-                        \n-                    case .Study,.studyEvent: // Study Notifications\n-                        \n-                        let leftController = ((menuVC as? FDASlideMenuViewController)!.leftViewController as? LeftMenuViewController)!\n-                        \n-                        if !(initialVC is StudyListViewController) {\n-                            \n-                            if initialVC is ProfileViewController  ||  initialVC is ReachoutOptionsViewController || initialVC is GatewayResourcesListViewController {\n-                                \n-                                NotificationHandler.instance.appOpenFromNotification = true\n-                                NotificationHandler.instance.studyId = studyId\n-                                \n-                                leftController.changeViewController(.studyList)\n-                                leftController.createLeftmenuItems()\n-                                \n-                            }else if initialVC is UITabBarController {\n-                                \n-                            }\n-                        }else {\n-                            \n-                            NotificationHandler.instance.appOpenFromNotification = true\n-                            NotificationHandler.instance.studyId = studyId\n-                            \n-                            leftController.changeViewController(.studyList)\n-                            leftController.createLeftmenuItems()\n-                        }\n-                        \n-                    case .Announcement: break\n-                        \n-                    //default: break\n-                        \n-                    }\n-                }else {\n-                    //studyId is Null\n-                }\n-            }else if notificationType == AppNotification.NotificationType.Gateway.rawValue { //Gateway level Notification\n-                // Do Nothing\n+            topVC = parentController\n+            parentViewControllerForAlert = topVC\n+          }\n+          passcodeParentControllerWhileSetup = nil\n+\n+          // PasscodeController or TaskViewController is not presented\n+          if (\n+            topVC?.presentedViewController?.isKind(of: ORKPasscodeViewController.self)\n+              == false && (\n+                topVC?.presentedViewController?.isKind(\n+                  of: ORKTaskViewController.self)\n+              )!\n+          ) || (\n+            topVC != nil && topVC?.isKind(of: ORKPasscodeViewController.self) == false\n+          ) {\n+\n+            isPasscodePresented = true\n+            blockerScreen?.isHidden = true\n+\n+            if isComprehensionFailed! {\n+              self.retryView?.isHidden = true\n             }\n+            passcodeViewController.navigationBar.prefersLargeTitles = false\n+            passcodeViewController.modalPresentationStyle = .fullScreen\n+            topVC!.present(passcodeViewController, animated: false, completion: nil)\n+          }\n         }\n-        self.notificationDetails = nil\n-    }\n-    \n-    // Push to tabbar Controller with tabs Activity, Dashboard & Resource\n-    func pushToTabbar(viewController: UIViewController,selectedTab: Int) {\n-        \n-        let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n-        \n-        let studyDashboard = (studyStoryBoard.instantiateViewController(withIdentifier: kStudyDashboardTabbarControllerIdentifier) as? StudyDashboardTabbarViewController)!\n-        \n-        studyDashboard.selectedIndex = selectedTab\n-        viewController.navigationController?.navigationBar.isHidden = true\n-        viewController.navigationController?.pushViewController(studyDashboard, animated: true)\n+      }\n     }\n-    \n-    //Verify passcode if enabled or set passcode\n-    func checkPasscode(viewController: UIViewController) {\n-        \n-        if User.currentUser.userType == .FDAUser {//FDA user\n-            \n-            if User.currentUser.settings?.passcode! == true {\n-                //Passcode already exist\n-                if  ORKPasscodeViewController.isPasscodeStoredInKeychain() == false {\n-                    \n-                    let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n-                    passcodeStep.passcodeType = .type4Digit\n-                    let task = ORKOrderedTask(identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n-                    let taskViewController = ORKTaskViewController.init(task: task, taskRun: nil)\n-                    \n-                    if viewController.isKind(of: UINavigat", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1863}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY4OTM0Nw==", "bodyText": "nit: extra empty line", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391689347", "createdAt": "2020-03-12T15:10:58Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/AppDelegate.swift", "diffHunk": "@@ -1,1900 +1,1844 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC\n+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import Fabric\n-import Crashlytics\n-import UserNotifications\n-import RealmSwift\n import CallKit\n import IQKeyboardManagerSwift\n+import RealmSwift\n+import UIKit\n+import UserNotifications\n \n-let kEncryptionKey = \"EncryptionKey\"\n-let kEncryptionIV =  \"EncryptionIV\"\n-let kBlockerScreenLabelText = \"Please update to the latest version of app to continue.\"\n-let kConsentUpdatedTitle = \"Consent Updated\"\n+@UIApplicationMain\n \n-let kMessageConsentUpdatedPartTwo = \" Please review the revised Consent terms and provide your Informed Consent, to continue participating in the study.\"\n+class AppDelegate: UIResponder, UIApplicationDelegate {\n \n-let kMessageConsentUpdated = \"The Consent Document for this study has been updated.\" + kMessageConsentUpdatedPartTwo\n+  var window: UIWindow?\n \n-let kReviewTitle = \"Review\"\n-let kPasscodeStepIdentifier = \"PasscodeStep\"\n-let kPasscodeTaskIdentifier = \"PassCodeTask\"\n-let kMessagePasscode = \"Passcode\"\n-let kMessagePasscodeSignOut = \"You will be signed out and will need to sign in again. Are you sure you want to proceed?\"\n-let kNewProgressViewNIB = \"NewProgressView\"\n-let kforgotPasscodeTitle = \"Forgot Passcode? Sign In Again\"\n-let kStudyStoryboard = \"Study\"\n-let kPasscodeSetUpText = \"Set up a passcode for the app\"\n-let kIphoneSimulator =  \"iPhone Simulator\"\n+  var notificationDetails: [String: Any]? = [String: Any]()\n \n-let kBundleIdentier = \"CFBundleIdentifier\"\n-let kPDFCreationNotificationId = \"pdfCreationNotificationIdentifier\"\n-let ksetUpTimeIdentifier = \"setUPTime\"\n-let kCFBundleShortVersion = \"CFBundleShortVersionString\"\n+  var appIsResignedButDidNotEnteredBackground: Bool? = false\n \n-let kResultCount = \"resultCount\"\n-let kResultsForAppStore = \"results\"\n-let kAppStoreVersion = \"version\"\n+  var alertVCPresented: UIAlertController?\n \n-let kContinueButtonTitle =  NSLocalizedString(\"Continue\", comment:\"\")\n-let kType = \"type\"\n+  var isPasscodePresented: Bool? = false\n \n-let kCurrentVersion = \"currentVersion\"\n-let kForceUpdate = \"forceUpdate\"\n-let kMessage = \"message\"\n-let kVisualStepId = \"visual\"\n-let kMessageString = \"Message\"\n+  var isComprehensionFailed: Bool? = false\n \n+  var parentViewControllerForAlert: UIViewController?\n \n-@UIApplicationMain\n+  var iscomingFromForgotPasscode: Bool? = false\n \n-class AppDelegate: UIResponder, UIApplicationDelegate {\n-    \n-    var window: UIWindow?\n-    \n-    var notificationDetails:Dictionary<String,Any>? = Dictionary<String,Any>()\n-    \n-    var appIsResignedButDidNotEnteredBackground:Bool? = false\n-    \n-    var alertVCPresented:UIAlertController?\n-    \n-    var isPasscodePresented:Bool? =  false\n-    \n-    var isComprehensionFailed:Bool? = false\n-    \n-    var parentViewControllerForAlert:UIViewController?\n-    \n-    var iscomingFromForgotPasscode:Bool? =  false\n-    \n-    var isAppLaunched: Bool? = false\n-    \n-    let healthStore = HKHealthStore()\n-    var containerViewController: ResearchContainerViewController? {\n-        return window?.rootViewController as? ResearchContainerViewController\n+  var isAppLaunched: Bool? = false\n+\n+  let healthStore = HKHealthStore()\n+\n+  var containerViewController: ResearchContainerViewController? {\n+    return window?.rootViewController as? ResearchContainerViewController\n+  }\n+\n+  var selectedController: UIViewController?\n+\n+  var shouldAddForceUpgradeScreen = false\n+\n+  var retryView: ComprehensionFailure?\n+\n+  var blockerScreen: AppUpdateBlocker?\n+  var passcodeParentControllerWhileSetup: UIViewController?\n+\n+  /// to be used in case of ineligible\n+  var consentToken: String? = \"\"\n+\n+  /// Register for Remote Notification\n+  func askForNotification() {\n+\n+    if #available(iOS 10.0, *) {\n+      let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n+      UNUserNotificationCenter.current().requestAuthorization(\n+        options: authOptions,\n+        completionHandler: { _, _ in })\n+\n+      // For iOS 10 display notification (sent via APNS)\n+      UNUserNotificationCenter.current().delegate = self\n+\n+    } else {\n+      let settings: UIUserNotificationSettings = UIUserNotificationSettings(\n+        types: [.alert, .badge, .sound], categories: nil)\n+      UIApplication.shared.registerUserNotificationSettings(settings)\n     }\n-    \n-    var selectedController: UIViewController?\n-    \n-    var shouldAddForceUpgradeScreen = false\n-    \n-    var retryView: ComprehensionFailure?\n-    \n-    var blockerScreen: AppUpdateBlocker?\n-    var passcodeParentControllerWhileSetup: UIViewController?\n-    \n-    var consentToken: String? = \"\" //to be used in case of ineligible\n-    \n-    //Register Remote Notification\n-    func askForNotification() {\n-        \n-        if #available(iOS 10.0, *) {\n-            let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n-            UNUserNotificationCenter.current().requestAuthorization(\n-                options: authOptions,\n-                completionHandler: {_, _ in })\n-            \n-            // For iOS 10 display notification (sent via APNS)\n-            UNUserNotificationCenter.current().delegate = self\n-            \n-        }else {\n-            let settings: UIUserNotificationSettings =\n-                UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)\n-            UIApplication.shared.registerUserNotificationSettings(settings)\n-        }\n-        UIApplication.shared.registerForRemoteNotifications()\n+    UIApplication.shared.registerForRemoteNotifications()\n+  }\n+\n+  /// Updates Key & InitializationVector for Encryption\n+  func updateKeyAndInitializationVector() {\n+\n+    let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n+    let currentIndex = currentDate.index(currentDate.endIndex, offsetBy: -13)\n+    let subStringFromDate = String(currentDate[..<currentIndex])\n+\n+    if User.currentUser.userType == .FDAUser {  // Registered/LogedIn User\n+\n+      let index = User.currentUser.userId.index(User.currentUser.userId.endIndex, offsetBy: -16)\n+      let subKey = String(User.currentUser.userId[..<index])\n+      FDAKeychain.shared[kEncryptionKey] = subKey + subStringFromDate\n+    } else {  // Anonymous User\n+      FDAKeychain.shared[kEncryptionKey] = kEncryptionKey\n     }\n-    \n-    /**\n-     Updates Key & InitializationVector for Encryption\n-     */\n-    func updateKeyAndInitializationVector() {\n-        \n-        let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n-        let currentIndex = currentDate.index(currentDate.endIndex\n-            , offsetBy: -13)\n-        let subStringFromDate = String(currentDate[..<currentIndex])\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if User.currentUser.userType ==  .FDAUser { // Registered/LogedIn User\n-            \n-            let index =  User.currentUser.userId.index(User.currentUser.userId.endIndex\n-                , offsetBy: -16)\n-            let subKey = String(User.currentUser.userId[..<index]) //User.currentUser.userId.substring(to: index ) // 36 - 12 =  24 characters\n-            ud.set(\"\\(subKey + subStringFromDate)\", forKey: kEncryptionKey)\n-            \n-        }else { // Anonymous User\n-            ud.set(currentDate + kDefaultPasscodeString, forKey: kEncryptionKey)\n-        }\n-        \n-        if UIDevice.current.model == kIsIphoneSimulator {\n-            // simulator\n-            ud.set(kdefaultIVForEncryption, forKey: kEncryptionIV)\n-        }else {\n-            // Device\n-            var udid = UIDevice.current.identifierForVendor?.uuidString\n-            let index =  udid?.index((udid?.endIndex)!\n-                , offsetBy: -20)\n-            udid = String((udid?[..<index!])!)//udid?.substring(to: index!)\n-            ud.set(udid, forKey: kEncryptionIV)\n+\n+    if UIDevice.current.model == kIsIphoneSimulator {\n+      FDAKeychain.shared[kEncryptionIV] = kdefaultIVForEncryption\n+    } else {\n+      // Device\n+      var udid = UIDevice.current.identifierForVendor?.uuidString\n+      let index = udid?.index((udid?.endIndex)!, offsetBy: -20)\n+      udid = String((udid?[..<index!])!)\n+      FDAKeychain.shared[kEncryptionIV] = udid\n+    }\n+    //ud.synchronize()\n+  }\n+\n+  /// Handler for TimeZone changes, updates time zone in the local database\n+  func calculateTimeZoneChange() {\n+\n+    let timeZoneCurrent = TimeZone.current\n+    let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n+\n+    // Saving TimeZone to User Defaults\n+    let ud = UserDefaults.standard\n+    let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n+\n+    // Saving time difference\n+    if setuptimeDiff == nil {\n+      ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n+      ud.set(0, forKey: \"offset\")\n+\n+    } else {\n+\n+      let difference = differenceFromCurrent - setuptimeDiff!\n+      ud.set(difference, forKey: \"offset\")\n+      if difference == 0 {\n+        // Do Nothing\n+      } else {\n+\n+        Schedule._formatter = nil\n+        Schedule._formatter2 = nil\n+      }\n+    }\n+    ud.synchronize()\n+  }\n+\n+  // MARK: - Realm Migragion\n+  func generateRealmKeys() {\n+\n+    // Realm Encryption key generation\n+    if FDAKeychain.shared[kRealmEncryptionKeychainKey] == nil {\n+      // Generate 64 bytes of random data to serve as the encryption key\n+      var realmKey = kRealmEncryptionDefaultKey\n+      var key = Data(count: 64)\n+      let result = key.withUnsafeMutableBytes {\n+        SecRandomCopyBytes(kSecRandomDefault, 64, $0.baseAddress!)\n+      }\n+      if result == errSecSuccess {\n+        realmKey = key.base64EncodedString()\n+      } else {\n+        Logger.sharedInstance.info(\"Problem generating random bytes\")\n+\n+      }\n+      FDAKeychain.shared[kRealmEncryptionKeychainKey] = realmKey\n+    }\n+  }\n+\n+  func checkForRealmMigration() {\n+\n+    self.generateRealmKeys()\n+\n+    let key = FDAKeychain.shared[kRealmEncryptionKeychainKey]\n+    let keyData = Data.init(base64Encoded: key!)\n+\n+    let config = Realm.Configuration(\n+      encryptionKey: keyData,\n+      schemaVersion: 1,\n+      migrationBlock: { _, oldSchemaVersion in\n+        // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n+        if oldSchemaVersion < 1 {\n+          // Nothing to do!\n+          // Realm will automatically detect new properties and removed properties\n+          // And will update the schema on disk automatically\n         }\n+      })\n+\n+    // Tell Realm to use this new configuration object for the default Realm\n+    Realm.Configuration.defaultConfiguration = config\n+  }\n+\n+  // MARK: - App Delegates methods\n+\n+  func application(\n+    _ application: UIApplication,\n+    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n+  ) -> Bool {\n+    // Override point for customization after application launch.\n+\n+    self.isAppLaunched = true\n+    IQKeyboardManager.shared.enable = true\n+    Logger.sharedInstance.info(Utilities.isStandaloneApp(), \"Standalone\")\n+    self.customizeNavigationBar()\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+\n+    //Check For Updates\n+    self.checkForAppUpdate()\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    SyncUpdate.currentSyncUpdate = SyncUpdate()\n+\n+    // Register observer for Network change\n+    NotificationCenter.default.addObserver(\n+      SyncUpdate.currentSyncUpdate as Any,\n+      selector: #selector(SyncUpdate.currentSyncUpdate?.updateData),\n+      name: ReachabilityChangedNotification, object: nil)\n+\n+    let ud1 = UserDefaults.standard\n+\n+    // Check if App is launched because of Notification Received\n+    if launchOptions != nil && launchOptions?[.sourceApplication] == nil {\n+\n+      ud1.set(\"not null\", forKey: \"launch\")\n+\n+      // Launched from push notification\n+      let notification = launchOptions?[.remoteNotification]\n+\n+      if Utilities.isValidObject(someObject: notification as AnyObject) {  // Launched from Remote Notification\n+\n+        notificationDetails = notification as? [String: Any]\n+\n+        let ud = UserDefaults.standard\n+        ud.set(true, forKey: kShowNotification)\n         ud.synchronize()\n-    }\n-    \n-    /**\n-     Handler for TimeZone changes, updates time zone in the local database\n-     */\n-    func calculateTimeZoneChange() {\n-        \n-        //let date = Date().utcDate()\n-        \n-        //let timeZoneUTC = TimeZone(abbreviation: \"UTC\")\n-        //let timeZoneAutoCurrent = TimeZone.autoupdatingCurrent\n-        let timeZoneCurrent = TimeZone.current\n-        \n-        //let differenceFromUTC = timeZoneUTC?.secondsFromGMT()\n-        let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n-        //let differenceFromAutoCurrent = timeZoneCurrent.secondsFromGMT()\n-        \n-        //Saving TimeZone to User Defaults\n+\n+      } else {  // Regular Launch\n+\n+        ud1.set(\"invalid\", forKey: \"launch\")\n         let ud = UserDefaults.standard\n-        let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n-        \n-        //Saving time difference\n-        if setuptimeDiff == nil {\n-            ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n-            ud.set(0, forKey: \"offset\")\n-            \n-        }else {\n-            \n-            let difference = differenceFromCurrent - setuptimeDiff!\n-            ud.set(difference, forKey: \"offset\")\n-            if difference == 0 {\n-                // Do Nothing\n-            }else {\n-                \n-                Schedule._formatter = nil\n-                Schedule._formatter2 = nil\n-            }\n-        }\n+        ud.set(false, forKey: kShowNotification)\n         ud.synchronize()\n+      }\n     }\n-    \n-    func checkForAppReopenNotification() {\n-        \n-        //remove if notification is available\n-        LocalNotification.removeReopenAppNotification()\n-        LocalNotification.registerReopenAppNotification()\n-        \n-    }\n-    \n-    // MARK: Realm Migragion\n-    func checkForRealmMigration() {\n-        \n-        let config = Realm.Configuration(\n-            // Set the new schema version. This must be greater than the previously used\n-            // version (if you've never set a schema version before, the version is 0).\n-            schemaVersion: 3,\n-            \n-            // Set the block which will be called automatically when opening a Realm with\n-            // a schema version lower than the one set above\n-            migrationBlock: { migration, oldSchemaVersion in\n-                // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n-                if (oldSchemaVersion < 1) {\n-                    // Nothing to do!\n-                    // Realm will automatically detect new properties and removed properties\n-                    // And will update the schema on disk automatically\n-                }\n-        })\n-        \n-        // Tell Realm to use this new configuration object for the default Realm\n-        Realm.Configuration.defaultConfiguration = config\n-        \n-        // Now that we've told Realm how to handle the schema change, opening the file\n-        // will automatically perform the migration\n-        let _ = try! Realm()\n-    }\n-    \n-    func fireNotiffication(intervel:Int) {\n-        \n-        let content = UNMutableNotificationContent()\n-        content.body = \"message\"\n-        \n-        content.sound = UNNotificationSound.default\n-        content.badge = 1\n-        let date = Date().addingTimeInterval(TimeInterval(intervel))\n-        var timeInterval = date.timeIntervalSinceNow\n-\n-        \n-        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: timeInterval, repeats: false)\n-        let id = Utilities.randomString(length: 10)\n-        let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)\n-        let center = UNUserNotificationCenter.current()\n-        center.add(request)\n-    }\n-    \n-    // MARK: App Delegates\n-    \n-    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n-        // Override point for customization after application launch.\n-        \n-        self.isAppLaunched = true\n-        IQKeyboardManager.shared.enable = true\n-        print(Utilities.isStandaloneApp(),\"standalone\")\n-        self.customizeNavigationBar()\n-        Fabric.with([Crashlytics.self])\n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        \n-        //Check For Updates\n-        //self.checkForAppUpdateForVersion()\n-        self.checkForAppUpdate()\n-        \n-        if UIApplication.shared.applicationIconBadgeNumber > 0 {\n-            UIApplication.shared.applicationIconBadgeNumber = 0\n-        }\n-        \n-        SyncUpdate.currentSyncUpdate = SyncUpdate()\n-        \n-        //Register observer for Network change\n-        NotificationCenter.default.addObserver(SyncUpdate.currentSyncUpdate as Any , selector: #selector(SyncUpdate.currentSyncUpdate?.updateData), name: Notification.Name.reachabilityChanged, object: nil)\n-        \n-        let ud1 = UserDefaults.standard\n-        \n-        //Check if App is launched because of Notification Received\n-        if (launchOptions != nil && launchOptions?[.sourceApplication] == nil) {\n-            \n-            ud1.set(\"not null\", forKey: \"launch\")\n-            \n-            // Launched from push notification\n-            let notification = launchOptions?[.remoteNotification]\n-            \n-            if Utilities.isValidObject(someObject: notification as AnyObject) { // Launched from Remote Notification\n-                \n-                notificationDetails = notification as? Dictionary<String, Any>\n-                \n-                let ud = UserDefaults.standard\n-                ud.set(true, forKey: kShowNotification)\n-                ud.synchronize()\n-                \n-            }else if (launchOptions?[.localNotification] != nil) { //Launched from Local Notification\n-                \n-                ud1.set(\"local\", forKey: \"launch\")\n-                let localNotification = (launchOptions?[.localNotification] as? UILocalNotification)!\n-                let notificationDetails = (localNotification.userInfo as? Dictionary<String, Any>)!\n-                \n-                NotificationHandler.instance.appOpenFromNotification = true\n-                NotificationHandler.instance.studyId = (notificationDetails[kStudyId] as? String)!\n-                NotificationHandler.instance.activityId = (notificationDetails[kActivityId] as? String)!\n-                ud1.synchronize()\n-                \n-            }else { //Regular Launch\n-                \n-                ud1.set(\"invalid\", forKey: \"launch\")\n-                UIApplication.shared.applicationIconBadgeNumber = 0\n-                \n-                let ud = UserDefaults.standard\n-                ud.set(false, forKey: kShowNotification)\n-                ud.synchronize()\n-            }\n-        }\n-        \n-        //self.fireNotiffication(intervel: 10)\n-        //self.fireNotiffication(intervel: 15)\n-        \n-        //Check if Database needs migration\n-        self.checkForRealmMigration()\n-        return true\n-    }\n-    \n-    func applicationWillResignActive(_ application: UIApplication) {\n-        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.\n-        \n-        // set Flag to handle background to foreground transition\n-        self.appIsResignedButDidNotEnteredBackground = true\n-    }\n-    \n-    func applicationDidEnterBackground(_ application: UIApplication) {\n-        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n-        \n-        // set Flag to handle foreground to background transition\n-        self.appIsResignedButDidNotEnteredBackground = false\n-    }\n-    \n-    \n-    func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {\n-    }\n-    \n-    \n-    func applicationWillEnterForeground(_ application: UIApplication) {\n-        \n-        self.checkPasscode(viewController: (application.windows[0].rootViewController)!)\n-        \n-        self.checkForStudyUpdates()\n-        \n-        let number = UIApplication.shared.applicationIconBadgeNumber\n-        if number >= 1 {\n-            self.updateNotification()\n-        }\n-        \n-        //Check For Updates\n-        self.checkForAppUpdate()\n-        \n+\n+    // Check if Database needs migration\n+    self.checkForRealmMigration()\n+    return true\n+  }\n+\n+  func applicationWillResignActive(_ application: UIApplication) {\n+    // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.\n+\n+    // set Flag to handle background to foreground transition\n+    self.appIsResignedButDidNotEnteredBackground = true\n+  }\n+\n+  func applicationDidEnterBackground(_ application: UIApplication) {\n+    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n+\n+    // set Flag to handle foreground to background transition\n+    self.appIsResignedButDidNotEnteredBackground = false\n+  }\n+\n+  func application(\n+    _ application: UIApplication,\n+    performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) ->\n+      Void\n+  ) {\n+  }\n+\n+  func applicationWillEnterForeground(_ application: UIApplication) {\n+\n+    self.checkPasscode(viewController: (application.windows[0].rootViewController)!)\n+    self.checkForStudyUpdates()\n+    let number = UIApplication.shared.applicationIconBadgeNumber\n+    if number >= 1 {\n+      self.updateNotification()\n     }\n-    \n-    func applicationDidBecomeActive(_ application: UIApplication) {\n-        \n-        // self.window?.isHidden = false\n-        \n-        UIApplication.shared.applicationIconBadgeNumber = 0\n-        \n-        if self.appIsResignedButDidNotEnteredBackground! {\n-            \n-            let navController = application.windows[0].rootViewController\n-            \n-            \n-            let isTaskViewControllerVisible = (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKTaskViewController.self)\n-            \n-           // guard let navigation = (navController as? UINavigationController)?.visibleViewController as? ORKTaskViewController, let navigationTitle = navigation.title else {return}\n-            \n-            let navigationTitle = ((navController as? UINavigationController)?.visibleViewController as? ORKTaskViewController)?.title ?? \"\"\n-            \n-            if (navController as? UINavigationController) != nil &&  isTaskViewControllerVisible == false {\n-                \n-                if (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKPasscodeViewController.self) == false {\n-                    //Request for Passcode\n-                    //self.checkPasscode(viewController: navController!)\n-                }\n-                \n-            } else if(navController as? UINavigationController) != nil\n-                &&  isTaskViewControllerVisible == true\n-                && navigationTitle == \"Activity\" {\n-                \n-                if (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKPasscodeViewController.self) == false {\n-                    //Request for Passcode\n-                    //self.checkPasscode(viewController: navController!)\n-                }\n-            } else if(navController as? UIViewController) != nil {\n-               // self.checkPasscode(viewController: navController!)\n-            }\n-        }\n-        \n-        //Check if App running on Jailbreak Device\n-        if AppDelegate.jailbroken(application: application) {\n-            \n-            let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-            let appBlocker = JailbrokeBlocker.instanceFromNib(frame: navigationController.view.frame, detail: nil);\n-            UIApplication.shared.keyWindow?.addSubview(appBlocker);\n-            UIApplication.shared.keyWindow?.bringSubviewToFront(appBlocker)\n-            \n-        }\n-        \n-        //Update TimeZone Changes if any\n-        self.calculateTimeZoneChange()\n-        \n-        if self.isAppLaunched! {\n-            self.isAppLaunched = false\n-            \n-            //Update Local Notifications\n-            self.checkForRegisteredNotifications()\n+\n+    // Check For Updates\n+    self.checkForAppUpdate()\n+\n+  }\n+\n+  func applicationDidBecomeActive(_ application: UIApplication) {\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    if self.appIsResignedButDidNotEnteredBackground! {\n+\n+      let navController = application.windows[0].rootViewController\n+\n+      let isTaskViewControllerVisible = (navController as? UINavigationController)?\n+        .visibleViewController?.isKind(of: ORKTaskViewController.self)\n+\n+      let navigationTitle = (\n+        (navController as? UINavigationController)?.visibleViewController\n+          as? ORKTaskViewController\n+      )?.title ?? \"\"\n+\n+      if (navController as? UINavigationController) != nil && isTaskViewControllerVisible\n+        == false {\n+\n+        if (navController as? UINavigationController)?.visibleViewController?.isKind(\n+          of: ORKPasscodeViewController.self) == false {\n+          // Request for Passcode\n+          self.checkPasscode(viewController: navController!)\n         }\n-    }\n-    \n-    func applicationWillTerminate(_ application: UIApplication) {\n-        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.\n-    }\n-    \n-    // MARK:- NOTIFICATION\n-    \n-    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n-        \n-        let deviceTokenString = deviceToken.reduce(\"\", {$0 + String(format: \"%02X\", $1)})\n-        print(\"Token: \\(deviceTokenString)\")\n-        \n-        if  User.currentUser.userType == .FDAUser {\n-            \n-            User.currentUser.settings?.remoteNotifications = true\n-            User.currentUser.settings?.localNotifications = true\n-            //Update device Token to Local server\n-            UserServices().updateUserProfile(deviceToken: deviceTokenString , delegate: self)\n-            \n+\n+      } else if (navController as? UINavigationController) != nil\n+        && isTaskViewControllerVisible == true\n+        && navigationTitle == \"Activity\" {\n+\n+        if (navController as? UINavigationController)?.visibleViewController?.isKind(\n+          of: ORKPasscodeViewController.self) == false {\n+          // Request for Passcode\n+          self.checkPasscode(viewController: navController!)\n         }\n-        \n+      } else if (navController) != nil {\n+        self.checkPasscode(viewController: navController!)\n+      }\n     }\n-    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {\n-        \n-        print(\"Token Registration failed  \\(error)\")\n-        \n-    }\n-    \n-    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) {\n-        \n-        //For iOS 8 & 9\n-        if (UIApplication.shared.applicationState == .background)||(UIApplication.shared.applicationState == .inactive) {\n-            \n-            self.updateNotification()\n-            self.handleLocalAndRemoteNotification(userInfoDetails: (userInfo as? Dictionary<String, Any>)!)\n-        }\n-        \n-        // userInfo is valid\n-        if userInfo.count > 0 && userInfo.keys.contains(kType) {\n-            self.updateNotification()\n-            \n-        }else {\n-            if (UIApplication.shared.applicationState == .background || (UIApplication.shared.applicationState == .inactive)) {\n-                //Handle local Notification Received\n-                self.handleLocalNotification(userInfoDetails: (userInfo as? Dictionary<String, Any>)!)\n-            }\n-        }\n+\n+    // Check if App running on Jailbreak Device\n+    if AppDelegate.jailbroken(application: application) {\n+\n+      let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+      let appBlocker = JailbrokeBlocker.instanceFromNib(\n+        frame: navigationController.view.frame)\n+      UIApplication.shared.keyWindow?.addSubview(appBlocker)\n+      UIApplication.shared.keyWindow?.bringSubviewToFront(appBlocker)\n+\n     }\n-    \n-    func application(_ application: UIApplication, didReceive notification: UILocalNotification) {\n-        \n-        self.handleLocalNotification(userInfoDetails: (notification.userInfo as? Dictionary<String, Any>)!)\n+\n+    // Update TimeZone Changes if any\n+    self.calculateTimeZoneChange()\n+\n+    if self.isAppLaunched! {\n+      self.isAppLaunched = false\n+\n+      // Update Local Notifications\n+      self.checkForRegisteredNotifications()\n     }\n-    \n-    // MARK: Jailbreak Methods\n-    \n-    public static func jailbroken(application: UIApplication) -> Bool {\n-        guard let cydiaUrlScheme = NSURL(string: \"cydia://package/com.example.package\") else { return isJailbroken() }\n-        return application.canOpenURL(cydiaUrlScheme as URL) || isJailbroken()\n+  }\n+\n+  func applicationWillTerminate(_ application: UIApplication) {\n+    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.\n+  }\n+\n+  // MARK: - NOTIFICATION\n+\n+  func application(\n+    _ application: UIApplication,\n+    didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data\n+  ) {\n+\n+    let deviceTokenString = deviceToken.reduce(\"\", { $0 + String(format: \"%02X\", $1) })\n+    print(\"Token: \\(deviceTokenString)\")\n+\n+    if User.currentUser.userType == .FDAUser {\n+\n+      User.currentUser.settings?.remoteNotifications = true\n+      User.currentUser.settings?.localNotifications = true\n+      // Update device Token to Local server\n+      UserServices().updateUserProfile(deviceToken: deviceTokenString, delegate: self)\n+\n     }\n-    \n-    \n-    static func isJailbroken() -> Bool {\n-        \n-        if UIDevice.current.model != kIphoneSimulator {\n-            return false\n-        }\n-        \n-        let fileManager = FileManager.default\n-        if fileManager.fileExists(atPath: \"/Applications/Cydia.app\") ||\n-            fileManager.fileExists(atPath: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") ||\n-            fileManager.fileExists(atPath: \"/bin/bash\") ||\n-            fileManager.fileExists(atPath: \"/usr/sbin/sshd\") ||\n-            fileManager.fileExists(atPath: \"/etc/apt\") ||\n-            fileManager.fileExists(atPath: \"/usr/bin/ssh\") {\n-            return true\n-        }\n-        \n-        if canOpen(path: \"/Applications/Cydia.app\") ||\n-            canOpen(path: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") ||\n-            canOpen(path: \"/bin/bash\") ||\n-            canOpen(path: \"/usr/sbin/sshd\") ||\n-            canOpen(path: \"/etc/apt\") ||\n-            \n-            canOpen(path: \"/usr/bin/ssh\") {\n-            return true\n-        }\n-        \n-        let path = \"/private/\" + NSUUID().uuidString\n-        do {\n-            try \"anyString\".write(toFile: path, atomically: true, encoding: String.Encoding.utf8)\n-            try fileManager.removeItem(atPath: path)\n-            return true\n-        }catch {\n-            return false\n-        }\n+\n+  }\n+\n+  func application(\n+    _ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error\n+  ) {\n+\n+    Logger.sharedInstance.info(\"Token Registration failed  \\(error)\")\n+\n+  }\n+\n+  // MARK: - Jailbreak Methods\n+\n+  /// Checks Jailbroken status\n+  /// - Parameter application: `UIApplication` instance\n+  /// - Returns: `Boolean` state of Jailbroken\n+  public static func jailbroken(application: UIApplication) -> Bool {\n+    guard let cydiaUrlScheme = NSURL(string: \"cydia://package/com.example.package\") else {\n+      return isJailbroken()\n+    }\n+    return application.canOpenURL(cydiaUrlScheme as URL) || isJailbroken()\n+  }\n+\n+  /// Checks Jailbroken status\n+  /// - Returns: `Boolean` state of Jailbroken\n+  static func isJailbroken() -> Bool {\n+\n+    if UIDevice.current.model != kIphoneSimulator {\n+      return false\n     }\n-    \n-    static func canOpen(path: String) -> Bool {\n-        let file = fopen(path, \"r\")\n-        guard file != nil else { return false }\n-        fclose(file)\n-        return true\n+\n+    let fileManager = FileManager.default\n+    if fileManager.fileExists(atPath: \"/Applications/Cydia.app\") || fileManager.fileExists(\n+      atPath: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") || fileManager.fileExists(\n+        atPath: \"/bin/bash\") || fileManager.fileExists(atPath: \"/usr/sbin/sshd\")\n+      || fileManager\n+      .fileExists(atPath: \"/etc/apt\") || fileManager.fileExists(atPath: \"/usr/bin/ssh\") {\n+      return true\n     }\n-    \n-    // MARK: Add Retry Screen\n-    \n-    func addRetryScreen(viewController: UIViewController?) {\n-        \n-        let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-        self.retryView = ComprehensionFailure.instanceFromNib(frame: navigationController.view.frame, detail: nil);\n-        \n-        if viewController != nil {\n-            retryView?.delegate = (viewController as? ComprehensionFailureDelegate)!\n-            \n-        }else {\n-            retryView?.delegate = (self as? ComprehensionFailureDelegate)!\n-        }\n-        UIApplication.shared.keyWindow?.addSubview(retryView!);\n-        UIApplication.shared.keyWindow?.bringSubviewToFront(retryView!)\n+\n+    if canOpen(path: \"/Applications/Cydia.app\") || canOpen(\n+      path: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") || canOpen(path: \"/bin/bash\")\n+      || canOpen(path: \"/usr/sbin/sshd\") || canOpen(path: \"/etc/apt\") || canOpen(\n+        path: \"/usr/bin/ssh\") {\n+      return true\n     }\n-    \n-    // MARK:Custom Navigation Bar\n-    \n-    func customizeNavigationBar() {\n-        UINavigationBar.appearance().titleTextAttributes = [\n-            NSAttributedString.Key.font: UIFont(name: \"HelveticaNeue-Medium\", size: 18)!\n-        ]\n+\n+    let path = \"/private/\" + NSUUID().uuidString\n+    do {\n+      try \"anyString\".write(toFile: path, atomically: true, encoding: String.Encoding.utf8)\n+      try fileManager.removeItem(atPath: path)\n+      return true\n+    } catch {\n+      return false\n+    }\n+  }\n+\n+  static func canOpen(path: String) -> Bool {\n+    let file = fopen(path, \"r\")\n+    guard file != nil else { return false }\n+    fclose(file)\n+    return true\n+  }\n+\n+  // MARK: - Add Retry Screen\n+\n+  /// Present Retry View\n+  /// - Parameter viewController: `UIViewController` instance\n+  func addRetryScreen(viewController: UIViewController?) {\n+\n+    let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+    self.retryView = ComprehensionFailure.instanceFromNib(\n+      frame: navigationController.view.frame, detail: nil)\n+\n+    if viewController != nil {\n+      retryView?.delegate = (viewController as? ComprehensionFailureDelegate)!\n+\n+    } else {\n+      retryView?.delegate = self\n     }\n-    \n-    // MARK: Checker Methods\n-    \n-    /**\n-     To get the current App version from App Store and Adds the blocker screen if it is of lower version\n-     */\n-    func checkForAppUpdate() {\n-        WCPServices().checkForAppUpdates(delegate: self)\n+    UIApplication.shared.keyWindow?.addSubview(retryView!)\n+    UIApplication.shared.keyWindow?.bringSubviewToFront(retryView!)\n+  }\n+\n+  // MARK: - Custom Navigation Bar\n+\n+  func customizeNavigationBar() {\n+    UINavigationBar.appearance().titleTextAttributes = [\n+      NSAttributedString.Key.font: UIFont(name: \"HelveticaNeue-Medium\", size: 18)!\n+    ]\n+  }\n+\n+  // MARK: - Checker Methods\n+\n+  /// Get the current App version from App Store and Adds the blocker screen if it is of lower version\n+  func checkForAppUpdate() {\n+    WCPServices().checkForAppUpdates(delegate: self)\n+  }\n+\n+  /// Registers pending notifications based on UserType\n+  func checkForRegisteredNotifications() {\n+\n+    if User.currentUser.userType == .FDAUser {\n+\n+      let center = UNUserNotificationCenter.current()\n+      center.getPendingNotificationRequests(\n+        completionHandler: { requests in\n+          if requests.count < 50 {\n+            LocalNotification.refreshAllLocalNotification()\n+          }\n+        })\n     }\n-    \n-    func checkForRegisteredNotifications() {\n-        \n-        if User.currentUser.userType == .FDAUser {\n-           \n-            let center = UNUserNotificationCenter.current()\n-            center.getPendingNotificationRequests(completionHandler: { requests in\n-                print(requests)\n-                if requests.count < 50 {\n-                     LocalNotification.refreshAllLocalNotification()\n-                }\n-            })\n-            \n-            //check if notifications are expired or already fired\n-//            if scheduledNotifications.count < 50 {\n-//                //refresh local notifcation from DB\n-//                LocalNotification.refreshAllLocalNotification()\n-//                scheduledNotifications = application.scheduledLocalNotifications!\n-//\n-//            }\n-        }\n+  }\n+\n+  /// Webservice request call to SignOut\n+  func sendRequestToSignOut() {\n+    UserServices().logoutUser(self as NMWebServiceDelegate)\n+  }\n+\n+  /// Check the  current Consent Status for Updated Version\n+  /// - Parameter controller: Instance of `UIVIewController`\n+  func checkConsentStatus(controller: UIViewController) {\n+\n+    self.selectedController = controller\n+\n+    if StudyUpdates.studyConsentUpdated {\n+      // Study consent is updated: Please Present Consent UI.\n+\n+      let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+\n+      var topController: UIViewController = navigationController\n+      if navigationController.viewControllers.count > 0 {\n+        topController = navigationController.viewControllers.first!\n+      }\n+\n+      UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+        NSLocalizedString(kConsentUpdatedTitle, comment: \"\"),\n+        errorMessage: NSLocalizedString(kMessageConsentUpdated, comment: \"\"),\n+        errorAlertActionTitle: NSLocalizedString(kReviewTitle, comment: \"\"),\n+        errorAlertActionTitle2: nil, viewControllerUsed: topController,\n+        action1: {\n+\n+          self.addAndRemoveProgress(add: true)\n+          WCPServices().getEligibilityConsentMetadata(\n+            studyId: (Study.currentStudy?.studyId)!,\n+            delegate: self as NMWebServiceDelegate)\n+\n+        },\n+        action2: {\n+        })\n+    } else {\n+      // Study consent not updated\n     }\n-    \n-    func sendRequestToSignOut() {\n-        UserServices().logoutUser(self as NMWebServiceDelegate)\n+  }\n+\n+  /// Creates Eligibility Consent Task\n+  func createEligibilityConsentTask() {\n+\n+    let taskViewController: ORKTaskViewController?\n+\n+    //create orderedTask\n+    let consentTask: ORKOrderedTask? = ConsentBuilder.currentConsent?.createConsentTask()\n+      as! ORKOrderedTask?\n+\n+    taskViewController = ORKTaskViewController(task: consentTask, taskRun: nil)\n+\n+    taskViewController?.delegate = self\n+    taskViewController?.outputDirectory = FileManager.default.urls(\n+      for: .documentDirectory, in: .userDomainMask).first!\n+\n+    taskViewController?.navigationItem.title = nil\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+\n+    var topVC = UIApplication.shared.keyWindow?.rootViewController\n+    // Fetching the current Visible Controller\n+    while topVC?.presentedViewController != nil {\n+      topVC = topVC?.presentedViewController\n     }\n-    \n-    /**\n-     check the  current Consent Status for Updated Version\n-     */\n-    func checkConsentStatus(controller: UIViewController) {\n-        \n-        self.selectedController = controller\n-        \n-        if(StudyUpdates.studyConsentUpdated) {\n-            print(\"Study consent is updated: Please Present Consent UI\")\n-            \n-            let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-            \n-            var topController: UIViewController = navigationController\n-            if navigationController.viewControllers.count > 0 {\n-                topController = navigationController.viewControllers.first!\n-            }\n-            \n-            UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(kConsentUpdatedTitle, comment: \"\"), errorMessage: NSLocalizedString(kMessageConsentUpdated, comment: \"\"), errorAlertActionTitle: NSLocalizedString(kReviewTitle, comment: \"\"),\n-                                                                 errorAlertActionTitle2: nil, viewControllerUsed: topController,\n-                                                                 action1: {\n-                                                                    \n-                                                                    self.addAndRemoveProgress(add: true)\n-                                                                    WCPServices().getEligibilityConsentMetadata(studyId:(Study.currentStudy?.studyId)!, delegate: self as NMWebServiceDelegate)\n-                                                                    \n-            },\n-                                                                 action2: {\n-            })\n-        }else {\n-            print(\"Study consent not updated\")\n-        }\n+\n+    self.addAndRemoveProgress(add: false)\n+    // present consent task\n+    taskViewController?.navigationBar.prefersLargeTitles = false\n+    taskViewController?.modalPresentationStyle = .fullScreen\n+    topVC?.present(taskViewController!, animated: true, completion: nil)\n+  }\n+\n+  /// Handler for local notification\n+  /// - Parameter userInfoDetails: Contains the info for notification\n+  func handleLocalNotification(userInfoDetails: [String: Any]) {\n+\n+    var initialVC: UIViewController?\n+\n+    // getting topmost visible controller\n+    let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+    let menuVC = navigationController.viewControllers.last\n+    if menuVC is FDASlideMenuViewController {\n+      let mainController = (menuVC as? FDASlideMenuViewController)!.mainViewController\n+      if mainController is UINavigationController {\n+        let nav = (mainController as? UINavigationController)!\n+        initialVC = nav.viewControllers.last\n+      }\n     }\n-    \n-    /**\n-     Used to Create Eligibility Consent Task\n-     */\n-    func createEligibilityConsentTask() {\n-        \n-        let taskViewController: ORKTaskViewController?\n-        \n-        //create orderedTask\n-        let consentTask: ORKOrderedTask? = ConsentBuilder.currentConsent?.createConsentTask() as! ORKOrderedTask?\n-        \n-        taskViewController = ORKTaskViewController(task: consentTask, taskRun: nil)\n-        \n-        taskViewController?.delegate = self\n-        taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-        \n-        taskViewController?.navigationItem.title = nil\n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        \n-        //UIApplication.shared.statusBarStyle = .default\n-        \n-        var topVC = UIApplication.shared.keyWindow?.rootViewController\n-        //Fetching the current Visible Controller\n-        while topVC?.presentedViewController != nil {\n-            topVC = topVC?.presentedViewController\n+\n+    NotificationHandler.instance.appOpenFromNotification = true\n+    NotificationHandler.instance.studyId = (userInfoDetails[kStudyId] as? String)!\n+    NotificationHandler.instance.activityId = (userInfoDetails[kActivityId] as? String)!\n+\n+    if !(initialVC is UITabBarController) {\n+      // push tabbar and switch to activty tab\n+      if !(initialVC is StudyListViewController) {\n+\n+        let leftController = (\n+          (menuVC as? FDASlideMenuViewController)!.leftViewController\n+            as? LeftMenuViewController\n+        )!\n+        leftController.changeViewController(.studyList)\n+        leftController.createLeftmenuItems()\n+      }\n+    } else {\n+      // switch to activty tab\n+      (initialVC as? UITabBarController)!.selectedIndex = 0\n+    }\n+  }\n+\n+  /// Handler for local & remote notification\n+  /// - Parameter userInfoDetails: contains the info for notification\n+  func handleLocalAndRemoteNotification(userInfoDetails: [String: Any]) {\n+\n+    var notificationType: String? = \"\"\n+    var notificationSubType: AppNotification.NotificationSubType? = .Announcement\n+    // User info is valid\n+    if (userInfoDetails.count) > 0 {\n+\n+      if Utilities.isValidValue(someObject: userInfoDetails[kNotificationType] as AnyObject) {\n+        notificationType = userInfoDetails[kNotificationType] as? String\n+      }\n+      if Utilities.isValidValue(\n+        someObject: userInfoDetails[kNotificationSubType] as AnyObject) {\n+        notificationSubType = AppNotification.NotificationSubType(\n+          rawValue: (userInfoDetails[kNotificationSubType] as? String)!)\n+      }\n+\n+      if notificationType == AppNotification.NotificationType.Study.rawValue {  //Study Level Notification\n+\n+        var studyId: String? = \"\"\n+\n+        if Utilities.isValidValue(someObject: userInfoDetails[kStudyId] as AnyObject) {\n+          studyId = userInfoDetails[kStudyId] as? String\n         }\n-        \n-        self.addAndRemoveProgress(add: false)\n-        //present consent task\n-        taskViewController?.modalPresentationStyle = .fullScreen\n-        topVC?.present(taskViewController!, animated: true, completion: nil)\n-    }\n-    \n-    /**\n-     Handler for local notification\n-     @param userInfoDetails, contains the info for notification\n-     */\n-    \n-    func handleLocalNotification(userInfoDetails: Dictionary<String,Any>) {\n-        \n-        var initialVC: UIViewController?\n-        \n-        //getting topmost visible controller\n-        let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-        let menuVC = navigationController.viewControllers.last\n-        if  menuVC is FDASlideMenuViewController {\n-            let mainController =  (menuVC as? FDASlideMenuViewController)!.mainViewController\n+\n+        if studyId != nil || studyId != \"\" {\n+\n+          var initialVC: UIViewController?\n+\n+          if Gateway.instance.studies?.isEmpty == false {\n+\n+            let study = Gateway.instance.studies?.filter({ $0.studyId == studyId })\n+              .first\n+            Study.updateCurrentStudy(study: study!)\n+          }\n+          // fetch the visible view controller\n+          let navigationController = (\n+            self.window?.rootViewController as? UINavigationController\n+          )!\n+          let menuVC = navigationController.viewControllers.last\n+          if menuVC is FDASlideMenuViewController {\n+            let mainController = (menuVC as? FDASlideMenuViewController)!\n+              .mainViewController\n             if mainController is UINavigationController {\n-                let nav = (mainController as? UINavigationController)!\n-                initialVC = nav.viewControllers.last\n+              let nav = (mainController as? UINavigationController)!\n+              initialVC = nav.viewControllers.last\n+\n             }\n-        }\n-        \n-        NotificationHandler.instance.appOpenFromNotification = true\n-        NotificationHandler.instance.studyId = (userInfoDetails[kStudyId] as? String)!\n-        NotificationHandler.instance.activityId = (userInfoDetails[kActivityId] as? String)!\n-        \n-        if !(initialVC is UITabBarController) {\n-            //push tabbar and switch to activty tab\n+\n+          }\n+          // Handling Notifications based on SubType\n+          switch notificationSubType! as AppNotification.NotificationSubType {\n+          case .Activity, .Resource:  // Activity & Resource  Notifications\n+\n+            if !(initialVC is UITabBarController) {\n+              // push tabbar and switch to activty tab\n+\n+              self.pushToTabbar(\n+                viewController: initialVC!,\n+                selectedTab: (\n+                  notificationSubType! as AppNotification.NotificationSubType\n+                    == .Activity\n+                ) ? 0 : 2)\n+\n+            } else {\n+              // switch to activity tab\n+              (initialVC as? UITabBarController)!.selectedIndex = (\n+                notificationSubType! as AppNotification.NotificationSubType\n+                  == .Activity\n+              ) ? 0 : 2\n+            }\n+\n+          case .Study, .studyEvent:  // Study Notifications\n+\n+            let leftController = (\n+              (menuVC as? FDASlideMenuViewController)!.leftViewController\n+                as? LeftMenuViewController\n+            )!\n+\n             if !(initialVC is StudyListViewController) {\n-                \n-                let leftController = ((menuVC as? FDASlideMenuViewController)!.leftViewController as? LeftMenuViewController)!\n+\n+              if initialVC is ProfileViewController || initialVC\n+                is ReachoutOptionsViewController\n+                || initialVC is GatewayResourcesListViewController {\n+\n+                NotificationHandler.instance.appOpenFromNotification = true\n+                NotificationHandler.instance.studyId = studyId\n+\n                 leftController.changeViewController(.studyList)\n                 leftController.createLeftmenuItems()\n+\n+              } else if initialVC is UITabBarController {\n+\n+              }\n+            } else {\n+\n+              NotificationHandler.instance.appOpenFromNotification = true\n+              NotificationHandler.instance.studyId = studyId\n+\n+              leftController.changeViewController(.studyList)\n+              leftController.createLeftmenuItems()\n             }\n+\n+          case .Announcement:\n+            break\n+          }\n         }\n-        else {\n-            //switch to activty tab\n-            (initialVC as? UITabBarController)!.selectedIndex =  0\n-        }\n+      } else if notificationType == AppNotification.NotificationType.Gateway.rawValue {  // Gateway level Notification\n+        // Do Nothing\n+      }\n     }\n-    \n-    /**\n-     Handler for local & remote notification\n-     @param userInfoDetails, contains the info for notification\n-     */\n-    func handleLocalAndRemoteNotification(userInfoDetails: Dictionary<String,Any>) {\n-        \n-        var notificationType: String? = \"\"\n-        var notificationSubType: AppNotification.NotificationSubType? = .Announcement\n-        //User info is valid\n-        if (userInfoDetails.count) > 0 {\n-            \n-            if Utilities.isValidValue(someObject: userInfoDetails[kNotificationType] as AnyObject) {\n-                notificationType =  userInfoDetails[kNotificationType] as? String\n-            }\n-            if Utilities.isValidValue(someObject: userInfoDetails[kNotificationSubType] as AnyObject) {\n-                notificationSubType = AppNotification.NotificationSubType(rawValue: (userInfoDetails[kNotificationSubType] as? String)!)\n+    self.notificationDetails = nil\n+  }\n+\n+  /// Push to tabbar Controller with tabs Activity, Dashboard & Resource\n+  /// - Parameters:\n+  ///   - viewController: Instance of `UIViewController`\n+  ///   - selectedTab: Selected tab in form of `Int`\n+  func pushToTabbar(viewController: UIViewController, selectedTab: Int) {\n+\n+    let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n+\n+    let studyDashboard = (\n+      studyStoryBoard.instantiateViewController(\n+        withIdentifier: kStudyDashboardTabbarControllerIdentifier)\n+        as? StudyDashboardTabbarViewController\n+    )!\n+\n+    studyDashboard.selectedIndex = selectedTab\n+    viewController.navigationController?.navigationBar.isHidden = true\n+    viewController.navigationController?.pushViewController(studyDashboard, animated: true)\n+  }\n+\n+  /// Verifies passcode if enabled or set passcode\n+  /// - Parameter viewController: Instance of `UIViewController`\n+  func checkPasscode(viewController: UIViewController) {\n+\n+    if User.currentUser.userType == .FDAUser {  // FDA user\n+\n+      if User.currentUser.settings?.passcode! == true {\n+        // Passcode already exist\n+        if ORKPasscodeViewController.isPasscodeStoredInKeychain() == false {\n+\n+          let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n+          passcodeStep.passcodeType = .type4Digit\n+          let task = ORKOrderedTask(\n+            identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n+          let taskViewController = ORKTaskViewController.init(task: task, taskRun: nil)\n+\n+          if viewController.isKind(of: UINavigationController.self) {\n+            taskViewController.delegate = self\n+\n+          } else {\n+            taskViewController.delegate = viewController\n+              as? ORKTaskViewControllerDelegate\n+          }\n+          taskViewController.isNavigationBarHidden = true\n+          passcodeParentControllerWhileSetup = viewController\n+          isPasscodePresented = true\n+          blockerScreen?.isHidden = true\n+          taskViewController.navigationBar.prefersLargeTitles = false\n+          taskViewController.modalPresentationStyle = .fullScreen\n+          viewController.present(taskViewController, animated: false, completion: nil)\n+\n+        } else {\n+          guard\n+            ORKPasscodeViewController.isPasscodeStoredInKeychain() && !(\n+              containerViewController?.presentedViewController\n+                is ORKPasscodeViewController\n+            )\n+          else { return }\n+          window?.makeKeyAndVisible()\n+\n+          let passcodeViewController = ORKPasscodeViewController\n+            .passcodeAuthenticationViewController(withText: \"\", delegate: self)\n+          var topVC = UIApplication.shared.keyWindow?.rootViewController\n+          var parentController: UIViewController?\n+\n+          while topVC?.presentedViewController != nil {\n+\n+            parentController = topVC\n+            topVC = topVC?.presentedViewController\n+          }\n+\n+          if topVC is UIAlertController {  // topmost Visible Controller is AlertController\n+            alertVCPresented = (topVC as? UIAlertController)!\n+\n+            if (parentController is ORKPasscodeViewController) == false {\n+              topVC?.dismiss(animated: true, completion: nil)\n             }\n-            \n-            if notificationType == AppNotification.NotificationType.Study.rawValue { //Study Level Notification\n-                \n-                var studyId: String? = \"\"\n-                \n-                if Utilities.isValidValue(someObject: userInfoDetails[kStudyId] as AnyObject) {\n-                    studyId = userInfoDetails[kStudyId] as? String\n-                }\n-                \n-                if studyId != nil || studyId != \"\" {\n-                    \n-                    var initialVC: UIViewController?\n-                    \n-                    if Gateway.instance.studies?.isEmpty == false {\n-                        \n-                        let study = Gateway.instance.studies?.filter({$0.studyId == studyId}).first\n-                        Study.updateCurrentStudy(study: study!)\n-                    }\n-                    //fetch the visible view controller\n-                    let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-                    let menuVC = navigationController.viewControllers.last\n-                    if  menuVC is FDASlideMenuViewController {\n-                        let mainController =  (menuVC as? FDASlideMenuViewController)!.mainViewController\n-                        if mainController is UINavigationController {\n-                            let nav = (mainController as? UINavigationController)!\n-                            initialVC = nav.viewControllers.last\n-                            \n-                        }\n-                        \n-                    }\n-                    //Handling Notifications based on SubType\n-                    switch notificationSubType! as AppNotification.NotificationSubType {\n-                    case .Activity, .Resource: //Activity & Resource  Notifications\n-                        \n-                        var activityId: String? = \"\"\n-                        \n-                        if Utilities.isValidValue(someObject: userInfoDetails[kActivityId] as AnyObject) {\n-                            activityId = userInfoDetails[kActivityId] as? String\n-                        }\n-                        \n-                        var resourceId: String? = \"\"\n-                        if Utilities.isValidValue(someObject: userInfoDetails[kResourceId] as AnyObject) {\n-                            resourceId = userInfoDetails[kResourceId] as? String\n-                        }\n-                        \n-                        if !(initialVC is UITabBarController) {\n-                            //push tabbar and switch to activty tab\n-                            \n-                            self.pushToTabbar(viewController: initialVC!, selectedTab: (notificationSubType! as AppNotification.NotificationSubType == .Activity) ? 0 : 2)\n-                            \n-                        }else {\n-                            //switch to activity tab\n-                            \n-                            (initialVC as? UITabBarController)!.selectedIndex =  (notificationSubType! as AppNotification.NotificationSubType == .Activity) ? 0 : 2\n-                        }\n-                        \n-                    case .Study,.studyEvent: // Study Notifications\n-                        \n-                        let leftController = ((menuVC as? FDASlideMenuViewController)!.leftViewController as? LeftMenuViewController)!\n-                        \n-                        if !(initialVC is StudyListViewController) {\n-                            \n-                            if initialVC is ProfileViewController  ||  initialVC is ReachoutOptionsViewController || initialVC is GatewayResourcesListViewController {\n-                                \n-                                NotificationHandler.instance.appOpenFromNotification = true\n-                                NotificationHandler.instance.studyId = studyId\n-                                \n-                                leftController.changeViewController(.studyList)\n-                                leftController.createLeftmenuItems()\n-                                \n-                            }else if initialVC is UITabBarController {\n-                                \n-                            }\n-                        }else {\n-                            \n-                            NotificationHandler.instance.appOpenFromNotification = true\n-                            NotificationHandler.instance.studyId = studyId\n-                            \n-                            leftController.changeViewController(.studyList)\n-                            leftController.createLeftmenuItems()\n-                        }\n-                        \n-                    case .Announcement: break\n-                        \n-                    //default: break\n-                        \n-                    }\n-                }else {\n-                    //studyId is Null\n-                }\n-            }else if notificationType == AppNotification.NotificationType.Gateway.rawValue { //Gateway level Notification\n-                // Do Nothing\n+            topVC = parentController\n+            parentViewControllerForAlert = topVC\n+          }\n+          passcodeParentControllerWhileSetup = nil\n+\n+          // PasscodeController or TaskViewController is not presented\n+          if (\n+            topVC?.presentedViewController?.isKind(of: ORKPasscodeViewController.self)\n+              == false && (\n+                topVC?.presentedViewController?.isKind(\n+                  of: ORKTaskViewController.self)\n+              )!\n+          ) || (\n+            topVC != nil && topVC?.isKind(of: ORKPasscodeViewController.self) == false\n+          ) {\n+\n+            isPasscodePresented = true\n+            blockerScreen?.isHidden = true\n+\n+            if isComprehensionFailed! {\n+              self.retryView?.isHidden = true\n             }\n+            passcodeViewController.navigationBar.prefersLargeTitles = false\n+            passcodeViewController.modalPresentationStyle = .fullScreen\n+            topVC!.present(passcodeViewController, animated: false, completion: nil)\n+          }\n         }\n-        self.notificationDetails = nil\n-    }\n-    \n-    // Push to tabbar Controller with tabs Activity, Dashboard & Resource\n-    func pushToTabbar(viewController: UIViewController,selectedTab: Int) {\n-        \n-        let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n-        \n-        let studyDashboard = (studyStoryBoard.instantiateViewController(withIdentifier: kStudyDashboardTabbarControllerIdentifier) as? StudyDashboardTabbarViewController)!\n-        \n-        studyDashboard.selectedIndex = selectedTab\n-        viewController.navigationController?.navigationBar.isHidden = true\n-        viewController.navigationController?.pushViewController(studyDashboard, animated: true)\n+      }\n     }\n-    \n-    //Verify passcode if enabled or set passcode\n-    func checkPasscode(viewController: UIViewController) {\n-        \n-        if User.currentUser.userType == .FDAUser {//FDA user\n-            \n-            if User.currentUser.settings?.passcode! == true {\n-                //Passcode already exist\n-                if  ORKPasscodeViewController.isPasscodeStoredInKeychain() == false {\n-                    \n-                    let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n-                    passcodeStep.passcodeType = .type4Digit\n-                    let task = ORKOrderedTask(identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n-                    let taskViewController = ORKTaskViewController.init(task: task, taskRun: nil)\n-                    \n-                    if viewController.isKind(of: UINavigat", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 2030}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY5MjIwNA==", "bodyText": "nit: inconsistency in blank lines, some blocks have blank lines at the start, some both at start and at the end and others with no extra blank space like the else block following the if.", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391692204", "createdAt": "2020-03-12T15:15:10Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/AppDelegate.swift", "diffHunk": "@@ -1,1900 +1,1844 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC\n+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import Fabric\n-import Crashlytics\n-import UserNotifications\n-import RealmSwift\n import CallKit\n import IQKeyboardManagerSwift\n+import RealmSwift\n+import UIKit\n+import UserNotifications\n \n-let kEncryptionKey = \"EncryptionKey\"\n-let kEncryptionIV =  \"EncryptionIV\"\n-let kBlockerScreenLabelText = \"Please update to the latest version of app to continue.\"\n-let kConsentUpdatedTitle = \"Consent Updated\"\n+@UIApplicationMain\n \n-let kMessageConsentUpdatedPartTwo = \" Please review the revised Consent terms and provide your Informed Consent, to continue participating in the study.\"\n+class AppDelegate: UIResponder, UIApplicationDelegate {\n \n-let kMessageConsentUpdated = \"The Consent Document for this study has been updated.\" + kMessageConsentUpdatedPartTwo\n+  var window: UIWindow?\n \n-let kReviewTitle = \"Review\"\n-let kPasscodeStepIdentifier = \"PasscodeStep\"\n-let kPasscodeTaskIdentifier = \"PassCodeTask\"\n-let kMessagePasscode = \"Passcode\"\n-let kMessagePasscodeSignOut = \"You will be signed out and will need to sign in again. Are you sure you want to proceed?\"\n-let kNewProgressViewNIB = \"NewProgressView\"\n-let kforgotPasscodeTitle = \"Forgot Passcode? Sign In Again\"\n-let kStudyStoryboard = \"Study\"\n-let kPasscodeSetUpText = \"Set up a passcode for the app\"\n-let kIphoneSimulator =  \"iPhone Simulator\"\n+  var notificationDetails: [String: Any]? = [String: Any]()\n \n-let kBundleIdentier = \"CFBundleIdentifier\"\n-let kPDFCreationNotificationId = \"pdfCreationNotificationIdentifier\"\n-let ksetUpTimeIdentifier = \"setUPTime\"\n-let kCFBundleShortVersion = \"CFBundleShortVersionString\"\n+  var appIsResignedButDidNotEnteredBackground: Bool? = false\n \n-let kResultCount = \"resultCount\"\n-let kResultsForAppStore = \"results\"\n-let kAppStoreVersion = \"version\"\n+  var alertVCPresented: UIAlertController?\n \n-let kContinueButtonTitle =  NSLocalizedString(\"Continue\", comment:\"\")\n-let kType = \"type\"\n+  var isPasscodePresented: Bool? = false\n \n-let kCurrentVersion = \"currentVersion\"\n-let kForceUpdate = \"forceUpdate\"\n-let kMessage = \"message\"\n-let kVisualStepId = \"visual\"\n-let kMessageString = \"Message\"\n+  var isComprehensionFailed: Bool? = false\n \n+  var parentViewControllerForAlert: UIViewController?\n \n-@UIApplicationMain\n+  var iscomingFromForgotPasscode: Bool? = false\n \n-class AppDelegate: UIResponder, UIApplicationDelegate {\n-    \n-    var window: UIWindow?\n-    \n-    var notificationDetails:Dictionary<String,Any>? = Dictionary<String,Any>()\n-    \n-    var appIsResignedButDidNotEnteredBackground:Bool? = false\n-    \n-    var alertVCPresented:UIAlertController?\n-    \n-    var isPasscodePresented:Bool? =  false\n-    \n-    var isComprehensionFailed:Bool? = false\n-    \n-    var parentViewControllerForAlert:UIViewController?\n-    \n-    var iscomingFromForgotPasscode:Bool? =  false\n-    \n-    var isAppLaunched: Bool? = false\n-    \n-    let healthStore = HKHealthStore()\n-    var containerViewController: ResearchContainerViewController? {\n-        return window?.rootViewController as? ResearchContainerViewController\n+  var isAppLaunched: Bool? = false\n+\n+  let healthStore = HKHealthStore()\n+\n+  var containerViewController: ResearchContainerViewController? {\n+    return window?.rootViewController as? ResearchContainerViewController\n+  }\n+\n+  var selectedController: UIViewController?\n+\n+  var shouldAddForceUpgradeScreen = false\n+\n+  var retryView: ComprehensionFailure?\n+\n+  var blockerScreen: AppUpdateBlocker?\n+  var passcodeParentControllerWhileSetup: UIViewController?\n+\n+  /// to be used in case of ineligible\n+  var consentToken: String? = \"\"\n+\n+  /// Register for Remote Notification\n+  func askForNotification() {\n+\n+    if #available(iOS 10.0, *) {\n+      let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n+      UNUserNotificationCenter.current().requestAuthorization(\n+        options: authOptions,\n+        completionHandler: { _, _ in })\n+\n+      // For iOS 10 display notification (sent via APNS)\n+      UNUserNotificationCenter.current().delegate = self\n+\n+    } else {\n+      let settings: UIUserNotificationSettings = UIUserNotificationSettings(\n+        types: [.alert, .badge, .sound], categories: nil)\n+      UIApplication.shared.registerUserNotificationSettings(settings)\n     }\n-    \n-    var selectedController: UIViewController?\n-    \n-    var shouldAddForceUpgradeScreen = false\n-    \n-    var retryView: ComprehensionFailure?\n-    \n-    var blockerScreen: AppUpdateBlocker?\n-    var passcodeParentControllerWhileSetup: UIViewController?\n-    \n-    var consentToken: String? = \"\" //to be used in case of ineligible\n-    \n-    //Register Remote Notification\n-    func askForNotification() {\n-        \n-        if #available(iOS 10.0, *) {\n-            let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n-            UNUserNotificationCenter.current().requestAuthorization(\n-                options: authOptions,\n-                completionHandler: {_, _ in })\n-            \n-            // For iOS 10 display notification (sent via APNS)\n-            UNUserNotificationCenter.current().delegate = self\n-            \n-        }else {\n-            let settings: UIUserNotificationSettings =\n-                UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)\n-            UIApplication.shared.registerUserNotificationSettings(settings)\n-        }\n-        UIApplication.shared.registerForRemoteNotifications()\n+    UIApplication.shared.registerForRemoteNotifications()\n+  }\n+\n+  /// Updates Key & InitializationVector for Encryption\n+  func updateKeyAndInitializationVector() {\n+\n+    let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n+    let currentIndex = currentDate.index(currentDate.endIndex, offsetBy: -13)\n+    let subStringFromDate = String(currentDate[..<currentIndex])\n+\n+    if User.currentUser.userType == .FDAUser {  // Registered/LogedIn User\n+\n+      let index = User.currentUser.userId.index(User.currentUser.userId.endIndex, offsetBy: -16)\n+      let subKey = String(User.currentUser.userId[..<index])\n+      FDAKeychain.shared[kEncryptionKey] = subKey + subStringFromDate\n+    } else {  // Anonymous User\n+      FDAKeychain.shared[kEncryptionKey] = kEncryptionKey\n     }\n-    \n-    /**\n-     Updates Key & InitializationVector for Encryption\n-     */\n-    func updateKeyAndInitializationVector() {\n-        \n-        let currentDate = \"\\(Date(timeIntervalSinceNow: 0))\"\n-        let currentIndex = currentDate.index(currentDate.endIndex\n-            , offsetBy: -13)\n-        let subStringFromDate = String(currentDate[..<currentIndex])\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if User.currentUser.userType ==  .FDAUser { // Registered/LogedIn User\n-            \n-            let index =  User.currentUser.userId.index(User.currentUser.userId.endIndex\n-                , offsetBy: -16)\n-            let subKey = String(User.currentUser.userId[..<index]) //User.currentUser.userId.substring(to: index ) // 36 - 12 =  24 characters\n-            ud.set(\"\\(subKey + subStringFromDate)\", forKey: kEncryptionKey)\n-            \n-        }else { // Anonymous User\n-            ud.set(currentDate + kDefaultPasscodeString, forKey: kEncryptionKey)\n-        }\n-        \n-        if UIDevice.current.model == kIsIphoneSimulator {\n-            // simulator\n-            ud.set(kdefaultIVForEncryption, forKey: kEncryptionIV)\n-        }else {\n-            // Device\n-            var udid = UIDevice.current.identifierForVendor?.uuidString\n-            let index =  udid?.index((udid?.endIndex)!\n-                , offsetBy: -20)\n-            udid = String((udid?[..<index!])!)//udid?.substring(to: index!)\n-            ud.set(udid, forKey: kEncryptionIV)\n+\n+    if UIDevice.current.model == kIsIphoneSimulator {\n+      FDAKeychain.shared[kEncryptionIV] = kdefaultIVForEncryption\n+    } else {\n+      // Device\n+      var udid = UIDevice.current.identifierForVendor?.uuidString\n+      let index = udid?.index((udid?.endIndex)!, offsetBy: -20)\n+      udid = String((udid?[..<index!])!)\n+      FDAKeychain.shared[kEncryptionIV] = udid\n+    }\n+    //ud.synchronize()\n+  }\n+\n+  /// Handler for TimeZone changes, updates time zone in the local database\n+  func calculateTimeZoneChange() {\n+\n+    let timeZoneCurrent = TimeZone.current\n+    let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n+\n+    // Saving TimeZone to User Defaults\n+    let ud = UserDefaults.standard\n+    let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n+\n+    // Saving time difference\n+    if setuptimeDiff == nil {\n+      ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n+      ud.set(0, forKey: \"offset\")\n+\n+    } else {\n+\n+      let difference = differenceFromCurrent - setuptimeDiff!\n+      ud.set(difference, forKey: \"offset\")\n+      if difference == 0 {\n+        // Do Nothing\n+      } else {\n+\n+        Schedule._formatter = nil\n+        Schedule._formatter2 = nil\n+      }\n+    }\n+    ud.synchronize()\n+  }\n+\n+  // MARK: - Realm Migragion\n+  func generateRealmKeys() {\n+\n+    // Realm Encryption key generation\n+    if FDAKeychain.shared[kRealmEncryptionKeychainKey] == nil {\n+      // Generate 64 bytes of random data to serve as the encryption key\n+      var realmKey = kRealmEncryptionDefaultKey\n+      var key = Data(count: 64)\n+      let result = key.withUnsafeMutableBytes {\n+        SecRandomCopyBytes(kSecRandomDefault, 64, $0.baseAddress!)\n+      }\n+      if result == errSecSuccess {\n+        realmKey = key.base64EncodedString()\n+      } else {\n+        Logger.sharedInstance.info(\"Problem generating random bytes\")\n+\n+      }\n+      FDAKeychain.shared[kRealmEncryptionKeychainKey] = realmKey\n+    }\n+  }\n+\n+  func checkForRealmMigration() {\n+\n+    self.generateRealmKeys()\n+\n+    let key = FDAKeychain.shared[kRealmEncryptionKeychainKey]\n+    let keyData = Data.init(base64Encoded: key!)\n+\n+    let config = Realm.Configuration(\n+      encryptionKey: keyData,\n+      schemaVersion: 1,\n+      migrationBlock: { _, oldSchemaVersion in\n+        // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n+        if oldSchemaVersion < 1 {\n+          // Nothing to do!\n+          // Realm will automatically detect new properties and removed properties\n+          // And will update the schema on disk automatically\n         }\n+      })\n+\n+    // Tell Realm to use this new configuration object for the default Realm\n+    Realm.Configuration.defaultConfiguration = config\n+  }\n+\n+  // MARK: - App Delegates methods\n+\n+  func application(\n+    _ application: UIApplication,\n+    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n+  ) -> Bool {\n+    // Override point for customization after application launch.\n+\n+    self.isAppLaunched = true\n+    IQKeyboardManager.shared.enable = true\n+    Logger.sharedInstance.info(Utilities.isStandaloneApp(), \"Standalone\")\n+    self.customizeNavigationBar()\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+\n+    //Check For Updates\n+    self.checkForAppUpdate()\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    SyncUpdate.currentSyncUpdate = SyncUpdate()\n+\n+    // Register observer for Network change\n+    NotificationCenter.default.addObserver(\n+      SyncUpdate.currentSyncUpdate as Any,\n+      selector: #selector(SyncUpdate.currentSyncUpdate?.updateData),\n+      name: ReachabilityChangedNotification, object: nil)\n+\n+    let ud1 = UserDefaults.standard\n+\n+    // Check if App is launched because of Notification Received\n+    if launchOptions != nil && launchOptions?[.sourceApplication] == nil {\n+\n+      ud1.set(\"not null\", forKey: \"launch\")\n+\n+      // Launched from push notification\n+      let notification = launchOptions?[.remoteNotification]\n+\n+      if Utilities.isValidObject(someObject: notification as AnyObject) {  // Launched from Remote Notification\n+\n+        notificationDetails = notification as? [String: Any]\n+\n+        let ud = UserDefaults.standard\n+        ud.set(true, forKey: kShowNotification)\n         ud.synchronize()\n-    }\n-    \n-    /**\n-     Handler for TimeZone changes, updates time zone in the local database\n-     */\n-    func calculateTimeZoneChange() {\n-        \n-        //let date = Date().utcDate()\n-        \n-        //let timeZoneUTC = TimeZone(abbreviation: \"UTC\")\n-        //let timeZoneAutoCurrent = TimeZone.autoupdatingCurrent\n-        let timeZoneCurrent = TimeZone.current\n-        \n-        //let differenceFromUTC = timeZoneUTC?.secondsFromGMT()\n-        let differenceFromCurrent = timeZoneCurrent.secondsFromGMT()\n-        //let differenceFromAutoCurrent = timeZoneCurrent.secondsFromGMT()\n-        \n-        //Saving TimeZone to User Defaults\n+\n+      } else {  // Regular Launch\n+\n+        ud1.set(\"invalid\", forKey: \"launch\")\n         let ud = UserDefaults.standard\n-        let setuptimeDiff = ud.value(forKey: ksetUpTimeIdentifier) as? Int\n-        \n-        //Saving time difference\n-        if setuptimeDiff == nil {\n-            ud.set(differenceFromCurrent, forKey: ksetUpTimeIdentifier)\n-            ud.set(0, forKey: \"offset\")\n-            \n-        }else {\n-            \n-            let difference = differenceFromCurrent - setuptimeDiff!\n-            ud.set(difference, forKey: \"offset\")\n-            if difference == 0 {\n-                // Do Nothing\n-            }else {\n-                \n-                Schedule._formatter = nil\n-                Schedule._formatter2 = nil\n-            }\n-        }\n+        ud.set(false, forKey: kShowNotification)\n         ud.synchronize()\n+      }\n     }\n-    \n-    func checkForAppReopenNotification() {\n-        \n-        //remove if notification is available\n-        LocalNotification.removeReopenAppNotification()\n-        LocalNotification.registerReopenAppNotification()\n-        \n-    }\n-    \n-    // MARK: Realm Migragion\n-    func checkForRealmMigration() {\n-        \n-        let config = Realm.Configuration(\n-            // Set the new schema version. This must be greater than the previously used\n-            // version (if you've never set a schema version before, the version is 0).\n-            schemaVersion: 3,\n-            \n-            // Set the block which will be called automatically when opening a Realm with\n-            // a schema version lower than the one set above\n-            migrationBlock: { migration, oldSchemaVersion in\n-                // We haven\u2019t migrated anything yet, so oldSchemaVersion == 0\n-                if (oldSchemaVersion < 1) {\n-                    // Nothing to do!\n-                    // Realm will automatically detect new properties and removed properties\n-                    // And will update the schema on disk automatically\n-                }\n-        })\n-        \n-        // Tell Realm to use this new configuration object for the default Realm\n-        Realm.Configuration.defaultConfiguration = config\n-        \n-        // Now that we've told Realm how to handle the schema change, opening the file\n-        // will automatically perform the migration\n-        let _ = try! Realm()\n-    }\n-    \n-    func fireNotiffication(intervel:Int) {\n-        \n-        let content = UNMutableNotificationContent()\n-        content.body = \"message\"\n-        \n-        content.sound = UNNotificationSound.default\n-        content.badge = 1\n-        let date = Date().addingTimeInterval(TimeInterval(intervel))\n-        var timeInterval = date.timeIntervalSinceNow\n-\n-        \n-        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: timeInterval, repeats: false)\n-        let id = Utilities.randomString(length: 10)\n-        let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)\n-        let center = UNUserNotificationCenter.current()\n-        center.add(request)\n-    }\n-    \n-    // MARK: App Delegates\n-    \n-    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n-        // Override point for customization after application launch.\n-        \n-        self.isAppLaunched = true\n-        IQKeyboardManager.shared.enable = true\n-        print(Utilities.isStandaloneApp(),\"standalone\")\n-        self.customizeNavigationBar()\n-        Fabric.with([Crashlytics.self])\n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        \n-        //Check For Updates\n-        //self.checkForAppUpdateForVersion()\n-        self.checkForAppUpdate()\n-        \n-        if UIApplication.shared.applicationIconBadgeNumber > 0 {\n-            UIApplication.shared.applicationIconBadgeNumber = 0\n-        }\n-        \n-        SyncUpdate.currentSyncUpdate = SyncUpdate()\n-        \n-        //Register observer for Network change\n-        NotificationCenter.default.addObserver(SyncUpdate.currentSyncUpdate as Any , selector: #selector(SyncUpdate.currentSyncUpdate?.updateData), name: Notification.Name.reachabilityChanged, object: nil)\n-        \n-        let ud1 = UserDefaults.standard\n-        \n-        //Check if App is launched because of Notification Received\n-        if (launchOptions != nil && launchOptions?[.sourceApplication] == nil) {\n-            \n-            ud1.set(\"not null\", forKey: \"launch\")\n-            \n-            // Launched from push notification\n-            let notification = launchOptions?[.remoteNotification]\n-            \n-            if Utilities.isValidObject(someObject: notification as AnyObject) { // Launched from Remote Notification\n-                \n-                notificationDetails = notification as? Dictionary<String, Any>\n-                \n-                let ud = UserDefaults.standard\n-                ud.set(true, forKey: kShowNotification)\n-                ud.synchronize()\n-                \n-            }else if (launchOptions?[.localNotification] != nil) { //Launched from Local Notification\n-                \n-                ud1.set(\"local\", forKey: \"launch\")\n-                let localNotification = (launchOptions?[.localNotification] as? UILocalNotification)!\n-                let notificationDetails = (localNotification.userInfo as? Dictionary<String, Any>)!\n-                \n-                NotificationHandler.instance.appOpenFromNotification = true\n-                NotificationHandler.instance.studyId = (notificationDetails[kStudyId] as? String)!\n-                NotificationHandler.instance.activityId = (notificationDetails[kActivityId] as? String)!\n-                ud1.synchronize()\n-                \n-            }else { //Regular Launch\n-                \n-                ud1.set(\"invalid\", forKey: \"launch\")\n-                UIApplication.shared.applicationIconBadgeNumber = 0\n-                \n-                let ud = UserDefaults.standard\n-                ud.set(false, forKey: kShowNotification)\n-                ud.synchronize()\n-            }\n-        }\n-        \n-        //self.fireNotiffication(intervel: 10)\n-        //self.fireNotiffication(intervel: 15)\n-        \n-        //Check if Database needs migration\n-        self.checkForRealmMigration()\n-        return true\n-    }\n-    \n-    func applicationWillResignActive(_ application: UIApplication) {\n-        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.\n-        \n-        // set Flag to handle background to foreground transition\n-        self.appIsResignedButDidNotEnteredBackground = true\n-    }\n-    \n-    func applicationDidEnterBackground(_ application: UIApplication) {\n-        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n-        \n-        // set Flag to handle foreground to background transition\n-        self.appIsResignedButDidNotEnteredBackground = false\n-    }\n-    \n-    \n-    func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {\n-    }\n-    \n-    \n-    func applicationWillEnterForeground(_ application: UIApplication) {\n-        \n-        self.checkPasscode(viewController: (application.windows[0].rootViewController)!)\n-        \n-        self.checkForStudyUpdates()\n-        \n-        let number = UIApplication.shared.applicationIconBadgeNumber\n-        if number >= 1 {\n-            self.updateNotification()\n-        }\n-        \n-        //Check For Updates\n-        self.checkForAppUpdate()\n-        \n+\n+    // Check if Database needs migration\n+    self.checkForRealmMigration()\n+    return true\n+  }\n+\n+  func applicationWillResignActive(_ application: UIApplication) {\n+    // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.\n+\n+    // set Flag to handle background to foreground transition\n+    self.appIsResignedButDidNotEnteredBackground = true\n+  }\n+\n+  func applicationDidEnterBackground(_ application: UIApplication) {\n+    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.\n+\n+    // set Flag to handle foreground to background transition\n+    self.appIsResignedButDidNotEnteredBackground = false\n+  }\n+\n+  func application(\n+    _ application: UIApplication,\n+    performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) ->\n+      Void\n+  ) {\n+  }\n+\n+  func applicationWillEnterForeground(_ application: UIApplication) {\n+\n+    self.checkPasscode(viewController: (application.windows[0].rootViewController)!)\n+    self.checkForStudyUpdates()\n+    let number = UIApplication.shared.applicationIconBadgeNumber\n+    if number >= 1 {\n+      self.updateNotification()\n     }\n-    \n-    func applicationDidBecomeActive(_ application: UIApplication) {\n-        \n-        // self.window?.isHidden = false\n-        \n-        UIApplication.shared.applicationIconBadgeNumber = 0\n-        \n-        if self.appIsResignedButDidNotEnteredBackground! {\n-            \n-            let navController = application.windows[0].rootViewController\n-            \n-            \n-            let isTaskViewControllerVisible = (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKTaskViewController.self)\n-            \n-           // guard let navigation = (navController as? UINavigationController)?.visibleViewController as? ORKTaskViewController, let navigationTitle = navigation.title else {return}\n-            \n-            let navigationTitle = ((navController as? UINavigationController)?.visibleViewController as? ORKTaskViewController)?.title ?? \"\"\n-            \n-            if (navController as? UINavigationController) != nil &&  isTaskViewControllerVisible == false {\n-                \n-                if (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKPasscodeViewController.self) == false {\n-                    //Request for Passcode\n-                    //self.checkPasscode(viewController: navController!)\n-                }\n-                \n-            } else if(navController as? UINavigationController) != nil\n-                &&  isTaskViewControllerVisible == true\n-                && navigationTitle == \"Activity\" {\n-                \n-                if (navController as? UINavigationController)?.visibleViewController?.isKind(of: ORKPasscodeViewController.self) == false {\n-                    //Request for Passcode\n-                    //self.checkPasscode(viewController: navController!)\n-                }\n-            } else if(navController as? UIViewController) != nil {\n-               // self.checkPasscode(viewController: navController!)\n-            }\n-        }\n-        \n-        //Check if App running on Jailbreak Device\n-        if AppDelegate.jailbroken(application: application) {\n-            \n-            let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-            let appBlocker = JailbrokeBlocker.instanceFromNib(frame: navigationController.view.frame, detail: nil);\n-            UIApplication.shared.keyWindow?.addSubview(appBlocker);\n-            UIApplication.shared.keyWindow?.bringSubviewToFront(appBlocker)\n-            \n-        }\n-        \n-        //Update TimeZone Changes if any\n-        self.calculateTimeZoneChange()\n-        \n-        if self.isAppLaunched! {\n-            self.isAppLaunched = false\n-            \n-            //Update Local Notifications\n-            self.checkForRegisteredNotifications()\n+\n+    // Check For Updates\n+    self.checkForAppUpdate()\n+\n+  }\n+\n+  func applicationDidBecomeActive(_ application: UIApplication) {\n+\n+    UIApplication.shared.applicationIconBadgeNumber = 0\n+\n+    if self.appIsResignedButDidNotEnteredBackground! {\n+\n+      let navController = application.windows[0].rootViewController\n+\n+      let isTaskViewControllerVisible = (navController as? UINavigationController)?\n+        .visibleViewController?.isKind(of: ORKTaskViewController.self)\n+\n+      let navigationTitle = (\n+        (navController as? UINavigationController)?.visibleViewController\n+          as? ORKTaskViewController\n+      )?.title ?? \"\"\n+\n+      if (navController as? UINavigationController) != nil && isTaskViewControllerVisible\n+        == false {\n+\n+        if (navController as? UINavigationController)?.visibleViewController?.isKind(\n+          of: ORKPasscodeViewController.self) == false {\n+          // Request for Passcode\n+          self.checkPasscode(viewController: navController!)\n         }\n-    }\n-    \n-    func applicationWillTerminate(_ application: UIApplication) {\n-        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.\n-    }\n-    \n-    // MARK:- NOTIFICATION\n-    \n-    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n-        \n-        let deviceTokenString = deviceToken.reduce(\"\", {$0 + String(format: \"%02X\", $1)})\n-        print(\"Token: \\(deviceTokenString)\")\n-        \n-        if  User.currentUser.userType == .FDAUser {\n-            \n-            User.currentUser.settings?.remoteNotifications = true\n-            User.currentUser.settings?.localNotifications = true\n-            //Update device Token to Local server\n-            UserServices().updateUserProfile(deviceToken: deviceTokenString , delegate: self)\n-            \n+\n+      } else if (navController as? UINavigationController) != nil\n+        && isTaskViewControllerVisible == true\n+        && navigationTitle == \"Activity\" {\n+\n+        if (navController as? UINavigationController)?.visibleViewController?.isKind(\n+          of: ORKPasscodeViewController.self) == false {\n+          // Request for Passcode\n+          self.checkPasscode(viewController: navController!)\n         }\n-        \n+      } else if (navController) != nil {\n+        self.checkPasscode(viewController: navController!)\n+      }\n     }\n-    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {\n-        \n-        print(\"Token Registration failed  \\(error)\")\n-        \n-    }\n-    \n-    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) {\n-        \n-        //For iOS 8 & 9\n-        if (UIApplication.shared.applicationState == .background)||(UIApplication.shared.applicationState == .inactive) {\n-            \n-            self.updateNotification()\n-            self.handleLocalAndRemoteNotification(userInfoDetails: (userInfo as? Dictionary<String, Any>)!)\n-        }\n-        \n-        // userInfo is valid\n-        if userInfo.count > 0 && userInfo.keys.contains(kType) {\n-            self.updateNotification()\n-            \n-        }else {\n-            if (UIApplication.shared.applicationState == .background || (UIApplication.shared.applicationState == .inactive)) {\n-                //Handle local Notification Received\n-                self.handleLocalNotification(userInfoDetails: (userInfo as? Dictionary<String, Any>)!)\n-            }\n-        }\n+\n+    // Check if App running on Jailbreak Device\n+    if AppDelegate.jailbroken(application: application) {\n+\n+      let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+      let appBlocker = JailbrokeBlocker.instanceFromNib(\n+        frame: navigationController.view.frame)\n+      UIApplication.shared.keyWindow?.addSubview(appBlocker)\n+      UIApplication.shared.keyWindow?.bringSubviewToFront(appBlocker)\n+\n     }\n-    \n-    func application(_ application: UIApplication, didReceive notification: UILocalNotification) {\n-        \n-        self.handleLocalNotification(userInfoDetails: (notification.userInfo as? Dictionary<String, Any>)!)\n+\n+    // Update TimeZone Changes if any\n+    self.calculateTimeZoneChange()\n+\n+    if self.isAppLaunched! {\n+      self.isAppLaunched = false\n+\n+      // Update Local Notifications\n+      self.checkForRegisteredNotifications()\n     }\n-    \n-    // MARK: Jailbreak Methods\n-    \n-    public static func jailbroken(application: UIApplication) -> Bool {\n-        guard let cydiaUrlScheme = NSURL(string: \"cydia://package/com.example.package\") else { return isJailbroken() }\n-        return application.canOpenURL(cydiaUrlScheme as URL) || isJailbroken()\n+  }\n+\n+  func applicationWillTerminate(_ application: UIApplication) {\n+    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.\n+  }\n+\n+  // MARK: - NOTIFICATION\n+\n+  func application(\n+    _ application: UIApplication,\n+    didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data\n+  ) {\n+\n+    let deviceTokenString = deviceToken.reduce(\"\", { $0 + String(format: \"%02X\", $1) })\n+    print(\"Token: \\(deviceTokenString)\")\n+\n+    if User.currentUser.userType == .FDAUser {\n+\n+      User.currentUser.settings?.remoteNotifications = true\n+      User.currentUser.settings?.localNotifications = true\n+      // Update device Token to Local server\n+      UserServices().updateUserProfile(deviceToken: deviceTokenString, delegate: self)\n+\n     }\n-    \n-    \n-    static func isJailbroken() -> Bool {\n-        \n-        if UIDevice.current.model != kIphoneSimulator {\n-            return false\n-        }\n-        \n-        let fileManager = FileManager.default\n-        if fileManager.fileExists(atPath: \"/Applications/Cydia.app\") ||\n-            fileManager.fileExists(atPath: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") ||\n-            fileManager.fileExists(atPath: \"/bin/bash\") ||\n-            fileManager.fileExists(atPath: \"/usr/sbin/sshd\") ||\n-            fileManager.fileExists(atPath: \"/etc/apt\") ||\n-            fileManager.fileExists(atPath: \"/usr/bin/ssh\") {\n-            return true\n-        }\n-        \n-        if canOpen(path: \"/Applications/Cydia.app\") ||\n-            canOpen(path: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") ||\n-            canOpen(path: \"/bin/bash\") ||\n-            canOpen(path: \"/usr/sbin/sshd\") ||\n-            canOpen(path: \"/etc/apt\") ||\n-            \n-            canOpen(path: \"/usr/bin/ssh\") {\n-            return true\n-        }\n-        \n-        let path = \"/private/\" + NSUUID().uuidString\n-        do {\n-            try \"anyString\".write(toFile: path, atomically: true, encoding: String.Encoding.utf8)\n-            try fileManager.removeItem(atPath: path)\n-            return true\n-        }catch {\n-            return false\n-        }\n+\n+  }\n+\n+  func application(\n+    _ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error\n+  ) {\n+\n+    Logger.sharedInstance.info(\"Token Registration failed  \\(error)\")\n+\n+  }\n+\n+  // MARK: - Jailbreak Methods\n+\n+  /// Checks Jailbroken status\n+  /// - Parameter application: `UIApplication` instance\n+  /// - Returns: `Boolean` state of Jailbroken\n+  public static func jailbroken(application: UIApplication) -> Bool {\n+    guard let cydiaUrlScheme = NSURL(string: \"cydia://package/com.example.package\") else {\n+      return isJailbroken()\n+    }\n+    return application.canOpenURL(cydiaUrlScheme as URL) || isJailbroken()\n+  }\n+\n+  /// Checks Jailbroken status\n+  /// - Returns: `Boolean` state of Jailbroken\n+  static func isJailbroken() -> Bool {\n+\n+    if UIDevice.current.model != kIphoneSimulator {\n+      return false\n     }\n-    \n-    static func canOpen(path: String) -> Bool {\n-        let file = fopen(path, \"r\")\n-        guard file != nil else { return false }\n-        fclose(file)\n-        return true\n+\n+    let fileManager = FileManager.default\n+    if fileManager.fileExists(atPath: \"/Applications/Cydia.app\") || fileManager.fileExists(\n+      atPath: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") || fileManager.fileExists(\n+        atPath: \"/bin/bash\") || fileManager.fileExists(atPath: \"/usr/sbin/sshd\")\n+      || fileManager\n+      .fileExists(atPath: \"/etc/apt\") || fileManager.fileExists(atPath: \"/usr/bin/ssh\") {\n+      return true\n     }\n-    \n-    // MARK: Add Retry Screen\n-    \n-    func addRetryScreen(viewController: UIViewController?) {\n-        \n-        let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-        self.retryView = ComprehensionFailure.instanceFromNib(frame: navigationController.view.frame, detail: nil);\n-        \n-        if viewController != nil {\n-            retryView?.delegate = (viewController as? ComprehensionFailureDelegate)!\n-            \n-        }else {\n-            retryView?.delegate = (self as? ComprehensionFailureDelegate)!\n-        }\n-        UIApplication.shared.keyWindow?.addSubview(retryView!);\n-        UIApplication.shared.keyWindow?.bringSubviewToFront(retryView!)\n+\n+    if canOpen(path: \"/Applications/Cydia.app\") || canOpen(\n+      path: \"/Library/MobileSubstrate/MobileSubstrate.dylib\") || canOpen(path: \"/bin/bash\")\n+      || canOpen(path: \"/usr/sbin/sshd\") || canOpen(path: \"/etc/apt\") || canOpen(\n+        path: \"/usr/bin/ssh\") {\n+      return true\n     }\n-    \n-    // MARK:Custom Navigation Bar\n-    \n-    func customizeNavigationBar() {\n-        UINavigationBar.appearance().titleTextAttributes = [\n-            NSAttributedString.Key.font: UIFont(name: \"HelveticaNeue-Medium\", size: 18)!\n-        ]\n+\n+    let path = \"/private/\" + NSUUID().uuidString\n+    do {\n+      try \"anyString\".write(toFile: path, atomically: true, encoding: String.Encoding.utf8)\n+      try fileManager.removeItem(atPath: path)\n+      return true\n+    } catch {\n+      return false\n+    }\n+  }\n+\n+  static func canOpen(path: String) -> Bool {\n+    let file = fopen(path, \"r\")\n+    guard file != nil else { return false }\n+    fclose(file)\n+    return true\n+  }\n+\n+  // MARK: - Add Retry Screen\n+\n+  /// Present Retry View\n+  /// - Parameter viewController: `UIViewController` instance\n+  func addRetryScreen(viewController: UIViewController?) {\n+\n+    let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+    self.retryView = ComprehensionFailure.instanceFromNib(\n+      frame: navigationController.view.frame, detail: nil)\n+\n+    if viewController != nil {\n+      retryView?.delegate = (viewController as? ComprehensionFailureDelegate)!\n+\n+    } else {\n+      retryView?.delegate = self\n     }\n-    \n-    // MARK: Checker Methods\n-    \n-    /**\n-     To get the current App version from App Store and Adds the blocker screen if it is of lower version\n-     */\n-    func checkForAppUpdate() {\n-        WCPServices().checkForAppUpdates(delegate: self)\n+    UIApplication.shared.keyWindow?.addSubview(retryView!)\n+    UIApplication.shared.keyWindow?.bringSubviewToFront(retryView!)\n+  }\n+\n+  // MARK: - Custom Navigation Bar\n+\n+  func customizeNavigationBar() {\n+    UINavigationBar.appearance().titleTextAttributes = [\n+      NSAttributedString.Key.font: UIFont(name: \"HelveticaNeue-Medium\", size: 18)!\n+    ]\n+  }\n+\n+  // MARK: - Checker Methods\n+\n+  /// Get the current App version from App Store and Adds the blocker screen if it is of lower version\n+  func checkForAppUpdate() {\n+    WCPServices().checkForAppUpdates(delegate: self)\n+  }\n+\n+  /// Registers pending notifications based on UserType\n+  func checkForRegisteredNotifications() {\n+\n+    if User.currentUser.userType == .FDAUser {\n+\n+      let center = UNUserNotificationCenter.current()\n+      center.getPendingNotificationRequests(\n+        completionHandler: { requests in\n+          if requests.count < 50 {\n+            LocalNotification.refreshAllLocalNotification()\n+          }\n+        })\n     }\n-    \n-    func checkForRegisteredNotifications() {\n-        \n-        if User.currentUser.userType == .FDAUser {\n-           \n-            let center = UNUserNotificationCenter.current()\n-            center.getPendingNotificationRequests(completionHandler: { requests in\n-                print(requests)\n-                if requests.count < 50 {\n-                     LocalNotification.refreshAllLocalNotification()\n-                }\n-            })\n-            \n-            //check if notifications are expired or already fired\n-//            if scheduledNotifications.count < 50 {\n-//                //refresh local notifcation from DB\n-//                LocalNotification.refreshAllLocalNotification()\n-//                scheduledNotifications = application.scheduledLocalNotifications!\n-//\n-//            }\n-        }\n+  }\n+\n+  /// Webservice request call to SignOut\n+  func sendRequestToSignOut() {\n+    UserServices().logoutUser(self as NMWebServiceDelegate)\n+  }\n+\n+  /// Check the  current Consent Status for Updated Version\n+  /// - Parameter controller: Instance of `UIVIewController`\n+  func checkConsentStatus(controller: UIViewController) {\n+\n+    self.selectedController = controller\n+\n+    if StudyUpdates.studyConsentUpdated {\n+      // Study consent is updated: Please Present Consent UI.\n+\n+      let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+\n+      var topController: UIViewController = navigationController\n+      if navigationController.viewControllers.count > 0 {\n+        topController = navigationController.viewControllers.first!\n+      }\n+\n+      UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+        NSLocalizedString(kConsentUpdatedTitle, comment: \"\"),\n+        errorMessage: NSLocalizedString(kMessageConsentUpdated, comment: \"\"),\n+        errorAlertActionTitle: NSLocalizedString(kReviewTitle, comment: \"\"),\n+        errorAlertActionTitle2: nil, viewControllerUsed: topController,\n+        action1: {\n+\n+          self.addAndRemoveProgress(add: true)\n+          WCPServices().getEligibilityConsentMetadata(\n+            studyId: (Study.currentStudy?.studyId)!,\n+            delegate: self as NMWebServiceDelegate)\n+\n+        },\n+        action2: {\n+        })\n+    } else {\n+      // Study consent not updated\n     }\n-    \n-    func sendRequestToSignOut() {\n-        UserServices().logoutUser(self as NMWebServiceDelegate)\n+  }\n+\n+  /// Creates Eligibility Consent Task\n+  func createEligibilityConsentTask() {\n+\n+    let taskViewController: ORKTaskViewController?\n+\n+    //create orderedTask\n+    let consentTask: ORKOrderedTask? = ConsentBuilder.currentConsent?.createConsentTask()\n+      as! ORKOrderedTask?\n+\n+    taskViewController = ORKTaskViewController(task: consentTask, taskRun: nil)\n+\n+    taskViewController?.delegate = self\n+    taskViewController?.outputDirectory = FileManager.default.urls(\n+      for: .documentDirectory, in: .userDomainMask).first!\n+\n+    taskViewController?.navigationItem.title = nil\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+\n+    var topVC = UIApplication.shared.keyWindow?.rootViewController\n+    // Fetching the current Visible Controller\n+    while topVC?.presentedViewController != nil {\n+      topVC = topVC?.presentedViewController\n     }\n-    \n-    /**\n-     check the  current Consent Status for Updated Version\n-     */\n-    func checkConsentStatus(controller: UIViewController) {\n-        \n-        self.selectedController = controller\n-        \n-        if(StudyUpdates.studyConsentUpdated) {\n-            print(\"Study consent is updated: Please Present Consent UI\")\n-            \n-            let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-            \n-            var topController: UIViewController = navigationController\n-            if navigationController.viewControllers.count > 0 {\n-                topController = navigationController.viewControllers.first!\n-            }\n-            \n-            UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(kConsentUpdatedTitle, comment: \"\"), errorMessage: NSLocalizedString(kMessageConsentUpdated, comment: \"\"), errorAlertActionTitle: NSLocalizedString(kReviewTitle, comment: \"\"),\n-                                                                 errorAlertActionTitle2: nil, viewControllerUsed: topController,\n-                                                                 action1: {\n-                                                                    \n-                                                                    self.addAndRemoveProgress(add: true)\n-                                                                    WCPServices().getEligibilityConsentMetadata(studyId:(Study.currentStudy?.studyId)!, delegate: self as NMWebServiceDelegate)\n-                                                                    \n-            },\n-                                                                 action2: {\n-            })\n-        }else {\n-            print(\"Study consent not updated\")\n-        }\n+\n+    self.addAndRemoveProgress(add: false)\n+    // present consent task\n+    taskViewController?.navigationBar.prefersLargeTitles = false\n+    taskViewController?.modalPresentationStyle = .fullScreen\n+    topVC?.present(taskViewController!, animated: true, completion: nil)\n+  }\n+\n+  /// Handler for local notification\n+  /// - Parameter userInfoDetails: Contains the info for notification\n+  func handleLocalNotification(userInfoDetails: [String: Any]) {\n+\n+    var initialVC: UIViewController?\n+\n+    // getting topmost visible controller\n+    let navigationController = (self.window?.rootViewController as? UINavigationController)!\n+    let menuVC = navigationController.viewControllers.last\n+    if menuVC is FDASlideMenuViewController {\n+      let mainController = (menuVC as? FDASlideMenuViewController)!.mainViewController\n+      if mainController is UINavigationController {\n+        let nav = (mainController as? UINavigationController)!\n+        initialVC = nav.viewControllers.last\n+      }\n     }\n-    \n-    /**\n-     Used to Create Eligibility Consent Task\n-     */\n-    func createEligibilityConsentTask() {\n-        \n-        let taskViewController: ORKTaskViewController?\n-        \n-        //create orderedTask\n-        let consentTask: ORKOrderedTask? = ConsentBuilder.currentConsent?.createConsentTask() as! ORKOrderedTask?\n-        \n-        taskViewController = ORKTaskViewController(task: consentTask, taskRun: nil)\n-        \n-        taskViewController?.delegate = self\n-        taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-        \n-        taskViewController?.navigationItem.title = nil\n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        \n-        //UIApplication.shared.statusBarStyle = .default\n-        \n-        var topVC = UIApplication.shared.keyWindow?.rootViewController\n-        //Fetching the current Visible Controller\n-        while topVC?.presentedViewController != nil {\n-            topVC = topVC?.presentedViewController\n+\n+    NotificationHandler.instance.appOpenFromNotification = true\n+    NotificationHandler.instance.studyId = (userInfoDetails[kStudyId] as? String)!\n+    NotificationHandler.instance.activityId = (userInfoDetails[kActivityId] as? String)!\n+\n+    if !(initialVC is UITabBarController) {\n+      // push tabbar and switch to activty tab\n+      if !(initialVC is StudyListViewController) {\n+\n+        let leftController = (\n+          (menuVC as? FDASlideMenuViewController)!.leftViewController\n+            as? LeftMenuViewController\n+        )!\n+        leftController.changeViewController(.studyList)\n+        leftController.createLeftmenuItems()\n+      }\n+    } else {\n+      // switch to activty tab\n+      (initialVC as? UITabBarController)!.selectedIndex = 0\n+    }\n+  }\n+\n+  /// Handler for local & remote notification\n+  /// - Parameter userInfoDetails: contains the info for notification\n+  func handleLocalAndRemoteNotification(userInfoDetails: [String: Any]) {\n+\n+    var notificationType: String? = \"\"\n+    var notificationSubType: AppNotification.NotificationSubType? = .Announcement\n+    // User info is valid\n+    if (userInfoDetails.count) > 0 {\n+\n+      if Utilities.isValidValue(someObject: userInfoDetails[kNotificationType] as AnyObject) {\n+        notificationType = userInfoDetails[kNotificationType] as? String\n+      }\n+      if Utilities.isValidValue(\n+        someObject: userInfoDetails[kNotificationSubType] as AnyObject) {\n+        notificationSubType = AppNotification.NotificationSubType(\n+          rawValue: (userInfoDetails[kNotificationSubType] as? String)!)\n+      }\n+\n+      if notificationType == AppNotification.NotificationType.Study.rawValue {  //Study Level Notification\n+\n+        var studyId: String? = \"\"\n+\n+        if Utilities.isValidValue(someObject: userInfoDetails[kStudyId] as AnyObject) {\n+          studyId = userInfoDetails[kStudyId] as? String\n         }\n-        \n-        self.addAndRemoveProgress(add: false)\n-        //present consent task\n-        taskViewController?.modalPresentationStyle = .fullScreen\n-        topVC?.present(taskViewController!, animated: true, completion: nil)\n-    }\n-    \n-    /**\n-     Handler for local notification\n-     @param userInfoDetails, contains the info for notification\n-     */\n-    \n-    func handleLocalNotification(userInfoDetails: Dictionary<String,Any>) {\n-        \n-        var initialVC: UIViewController?\n-        \n-        //getting topmost visible controller\n-        let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-        let menuVC = navigationController.viewControllers.last\n-        if  menuVC is FDASlideMenuViewController {\n-            let mainController =  (menuVC as? FDASlideMenuViewController)!.mainViewController\n+\n+        if studyId != nil || studyId != \"\" {\n+\n+          var initialVC: UIViewController?\n+\n+          if Gateway.instance.studies?.isEmpty == false {\n+\n+            let study = Gateway.instance.studies?.filter({ $0.studyId == studyId })\n+              .first\n+            Study.updateCurrentStudy(study: study!)\n+          }\n+          // fetch the visible view controller\n+          let navigationController = (\n+            self.window?.rootViewController as? UINavigationController\n+          )!\n+          let menuVC = navigationController.viewControllers.last\n+          if menuVC is FDASlideMenuViewController {\n+            let mainController = (menuVC as? FDASlideMenuViewController)!\n+              .mainViewController\n             if mainController is UINavigationController {\n-                let nav = (mainController as? UINavigationController)!\n-                initialVC = nav.viewControllers.last\n+              let nav = (mainController as? UINavigationController)!\n+              initialVC = nav.viewControllers.last\n+\n             }\n-        }\n-        \n-        NotificationHandler.instance.appOpenFromNotification = true\n-        NotificationHandler.instance.studyId = (userInfoDetails[kStudyId] as? String)!\n-        NotificationHandler.instance.activityId = (userInfoDetails[kActivityId] as? String)!\n-        \n-        if !(initialVC is UITabBarController) {\n-            //push tabbar and switch to activty tab\n+\n+          }\n+          // Handling Notifications based on SubType\n+          switch notificationSubType! as AppNotification.NotificationSubType {\n+          case .Activity, .Resource:  // Activity & Resource  Notifications\n+\n+            if !(initialVC is UITabBarController) {\n+              // push tabbar and switch to activty tab\n+\n+              self.pushToTabbar(\n+                viewController: initialVC!,\n+                selectedTab: (\n+                  notificationSubType! as AppNotification.NotificationSubType\n+                    == .Activity\n+                ) ? 0 : 2)\n+\n+            } else {\n+              // switch to activity tab\n+              (initialVC as? UITabBarController)!.selectedIndex = (\n+                notificationSubType! as AppNotification.NotificationSubType\n+                  == .Activity\n+              ) ? 0 : 2\n+            }\n+\n+          case .Study, .studyEvent:  // Study Notifications\n+\n+            let leftController = (\n+              (menuVC as? FDASlideMenuViewController)!.leftViewController\n+                as? LeftMenuViewController\n+            )!\n+\n             if !(initialVC is StudyListViewController) {\n-                \n-                let leftController = ((menuVC as? FDASlideMenuViewController)!.leftViewController as? LeftMenuViewController)!\n+\n+              if initialVC is ProfileViewController || initialVC\n+                is ReachoutOptionsViewController\n+                || initialVC is GatewayResourcesListViewController {\n+\n+                NotificationHandler.instance.appOpenFromNotification = true\n+                NotificationHandler.instance.studyId = studyId\n+\n                 leftController.changeViewController(.studyList)\n                 leftController.createLeftmenuItems()\n+\n+              } else if initialVC is UITabBarController {\n+\n+              }\n+            } else {\n+\n+              NotificationHandler.instance.appOpenFromNotification = true\n+              NotificationHandler.instance.studyId = studyId\n+\n+              leftController.changeViewController(.studyList)\n+              leftController.createLeftmenuItems()\n             }\n+\n+          case .Announcement:\n+            break\n+          }\n         }\n-        else {\n-            //switch to activty tab\n-            (initialVC as? UITabBarController)!.selectedIndex =  0\n-        }\n+      } else if notificationType == AppNotification.NotificationType.Gateway.rawValue {  // Gateway level Notification\n+        // Do Nothing\n+      }\n     }\n-    \n-    /**\n-     Handler for local & remote notification\n-     @param userInfoDetails, contains the info for notification\n-     */\n-    func handleLocalAndRemoteNotification(userInfoDetails: Dictionary<String,Any>) {\n-        \n-        var notificationType: String? = \"\"\n-        var notificationSubType: AppNotification.NotificationSubType? = .Announcement\n-        //User info is valid\n-        if (userInfoDetails.count) > 0 {\n-            \n-            if Utilities.isValidValue(someObject: userInfoDetails[kNotificationType] as AnyObject) {\n-                notificationType =  userInfoDetails[kNotificationType] as? String\n-            }\n-            if Utilities.isValidValue(someObject: userInfoDetails[kNotificationSubType] as AnyObject) {\n-                notificationSubType = AppNotification.NotificationSubType(rawValue: (userInfoDetails[kNotificationSubType] as? String)!)\n+    self.notificationDetails = nil\n+  }\n+\n+  /// Push to tabbar Controller with tabs Activity, Dashboard & Resource\n+  /// - Parameters:\n+  ///   - viewController: Instance of `UIViewController`\n+  ///   - selectedTab: Selected tab in form of `Int`\n+  func pushToTabbar(viewController: UIViewController, selectedTab: Int) {\n+\n+    let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n+\n+    let studyDashboard = (\n+      studyStoryBoard.instantiateViewController(\n+        withIdentifier: kStudyDashboardTabbarControllerIdentifier)\n+        as? StudyDashboardTabbarViewController\n+    )!\n+\n+    studyDashboard.selectedIndex = selectedTab\n+    viewController.navigationController?.navigationBar.isHidden = true\n+    viewController.navigationController?.pushViewController(studyDashboard, animated: true)\n+  }\n+\n+  /// Verifies passcode if enabled or set passcode\n+  /// - Parameter viewController: Instance of `UIViewController`\n+  func checkPasscode(viewController: UIViewController) {\n+\n+    if User.currentUser.userType == .FDAUser {  // FDA user\n+\n+      if User.currentUser.settings?.passcode! == true {\n+        // Passcode already exist\n+        if ORKPasscodeViewController.isPasscodeStoredInKeychain() == false {\n+\n+          let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n+          passcodeStep.passcodeType = .type4Digit\n+          let task = ORKOrderedTask(\n+            identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n+          let taskViewController = ORKTaskViewController.init(task: task, taskRun: nil)\n+\n+          if viewController.isKind(of: UINavigationController.self) {\n+            taskViewController.delegate = self\n+\n+          } else {\n+            taskViewController.delegate = viewController\n+              as? ORKTaskViewControllerDelegate\n+          }\n+          taskViewController.isNavigationBarHidden = true\n+          passcodeParentControllerWhileSetup = viewController\n+          isPasscodePresented = true\n+          blockerScreen?.isHidden = true\n+          taskViewController.navigationBar.prefersLargeTitles = false\n+          taskViewController.modalPresentationStyle = .fullScreen\n+          viewController.present(taskViewController, animated: false, completion: nil)\n+\n+        } else {\n+          guard\n+            ORKPasscodeViewController.isPasscodeStoredInKeychain() && !(\n+              containerViewController?.presentedViewController\n+                is ORKPasscodeViewController\n+            )\n+          else { return }\n+          window?.makeKeyAndVisible()\n+\n+          let passcodeViewController = ORKPasscodeViewController\n+            .passcodeAuthenticationViewController(withText: \"\", delegate: self)\n+          var topVC = UIApplication.shared.keyWindow?.rootViewController\n+          var parentController: UIViewController?\n+\n+          while topVC?.presentedViewController != nil {\n+\n+            parentController = topVC\n+            topVC = topVC?.presentedViewController\n+          }\n+\n+          if topVC is UIAlertController {  // topmost Visible Controller is AlertController\n+            alertVCPresented = (topVC as? UIAlertController)!\n+\n+            if (parentController is ORKPasscodeViewController) == false {\n+              topVC?.dismiss(animated: true, completion: nil)\n             }\n-            \n-            if notificationType == AppNotification.NotificationType.Study.rawValue { //Study Level Notification\n-                \n-                var studyId: String? = \"\"\n-                \n-                if Utilities.isValidValue(someObject: userInfoDetails[kStudyId] as AnyObject) {\n-                    studyId = userInfoDetails[kStudyId] as? String\n-                }\n-                \n-                if studyId != nil || studyId != \"\" {\n-                    \n-                    var initialVC: UIViewController?\n-                    \n-                    if Gateway.instance.studies?.isEmpty == false {\n-                        \n-                        let study = Gateway.instance.studies?.filter({$0.studyId == studyId}).first\n-                        Study.updateCurrentStudy(study: study!)\n-                    }\n-                    //fetch the visible view controller\n-                    let navigationController =  (self.window?.rootViewController as? UINavigationController)!\n-                    let menuVC = navigationController.viewControllers.last\n-                    if  menuVC is FDASlideMenuViewController {\n-                        let mainController =  (menuVC as? FDASlideMenuViewController)!.mainViewController\n-                        if mainController is UINavigationController {\n-                            let nav = (mainController as? UINavigationController)!\n-                            initialVC = nav.viewControllers.last\n-                            \n-                        }\n-                        \n-                    }\n-                    //Handling Notifications based on SubType\n-                    switch notificationSubType! as AppNotification.NotificationSubType {\n-                    case .Activity, .Resource: //Activity & Resource  Notifications\n-                        \n-                        var activityId: String? = \"\"\n-                        \n-                        if Utilities.isValidValue(someObject: userInfoDetails[kActivityId] as AnyObject) {\n-                            activityId = userInfoDetails[kActivityId] as? String\n-                        }\n-                        \n-                        var resourceId: String? = \"\"\n-                        if Utilities.isValidValue(someObject: userInfoDetails[kResourceId] as AnyObject) {\n-                            resourceId = userInfoDetails[kResourceId] as? String\n-                        }\n-                        \n-                        if !(initialVC is UITabBarController) {\n-                            //push tabbar and switch to activty tab\n-                            \n-                            self.pushToTabbar(viewController: initialVC!, selectedTab: (notificationSubType! as AppNotification.NotificationSubType == .Activity) ? 0 : 2)\n-                            \n-                        }else {\n-                            //switch to activity tab\n-                            \n-                            (initialVC as? UITabBarController)!.selectedIndex =  (notificationSubType! as AppNotification.NotificationSubType == .Activity) ? 0 : 2\n-                        }\n-                        \n-                    case .Study,.studyEvent: // Study Notifications\n-                        \n-                        let leftController = ((menuVC as? FDASlideMenuViewController)!.leftViewController as? LeftMenuViewController)!\n-                        \n-                        if !(initialVC is StudyListViewController) {\n-                            \n-                            if initialVC is ProfileViewController  ||  initialVC is ReachoutOptionsViewController || initialVC is GatewayResourcesListViewController {\n-                                \n-                                NotificationHandler.instance.appOpenFromNotification = true\n-                                NotificationHandler.instance.studyId = studyId\n-                                \n-                                leftController.changeViewController(.studyList)\n-                                leftController.createLeftmenuItems()\n-                                \n-                            }else if initialVC is UITabBarController {\n-                                \n-                            }\n-                        }else {\n-                            \n-                            NotificationHandler.instance.appOpenFromNotification = true\n-                            NotificationHandler.instance.studyId = studyId\n-                            \n-                            leftController.changeViewController(.studyList)\n-                            leftController.createLeftmenuItems()\n-                        }\n-                        \n-                    case .Announcement: break\n-                        \n-                    //default: break\n-                        \n-                    }\n-                }else {\n-                    //studyId is Null\n-                }\n-            }else if notificationType == AppNotification.NotificationType.Gateway.rawValue { //Gateway level Notification\n-                // Do Nothing\n+            topVC = parentController\n+            parentViewControllerForAlert = topVC\n+          }\n+          passcodeParentControllerWhileSetup = nil\n+\n+          // PasscodeController or TaskViewController is not presented\n+          if (\n+            topVC?.presentedViewController?.isKind(of: ORKPasscodeViewController.self)\n+              == false && (\n+                topVC?.presentedViewController?.isKind(\n+                  of: ORKTaskViewController.self)\n+              )!\n+          ) || (\n+            topVC != nil && topVC?.isKind(of: ORKPasscodeViewController.self) == false\n+          ) {\n+\n+            isPasscodePresented = true\n+            blockerScreen?.isHidden = true\n+\n+            if isComprehensionFailed! {\n+              self.retryView?.isHidden = true\n             }\n+            passcodeViewController.navigationBar.prefersLargeTitles = false\n+            passcodeViewController.modalPresentationStyle = .fullScreen\n+            topVC!.present(passcodeViewController, animated: false, completion: nil)\n+          }\n         }\n-        self.notificationDetails = nil\n-    }\n-    \n-    // Push to tabbar Controller with tabs Activity, Dashboard & Resource\n-    func pushToTabbar(viewController: UIViewController,selectedTab: Int) {\n-        \n-        let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n-        \n-        let studyDashboard = (studyStoryBoard.instantiateViewController(withIdentifier: kStudyDashboardTabbarControllerIdentifier) as? StudyDashboardTabbarViewController)!\n-        \n-        studyDashboard.selectedIndex = selectedTab\n-        viewController.navigationController?.navigationBar.isHidden = true\n-        viewController.navigationController?.pushViewController(studyDashboard, animated: true)\n+      }\n     }\n-    \n-    //Verify passcode if enabled or set passcode\n-    func checkPasscode(viewController: UIViewController) {\n-        \n-        if User.currentUser.userType == .FDAUser {//FDA user\n-            \n-            if User.currentUser.settings?.passcode! == true {\n-                //Passcode already exist\n-                if  ORKPasscodeViewController.isPasscodeStoredInKeychain() == false {\n-                    \n-                    let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n-                    passcodeStep.passcodeType = .type4Digit\n-                    let task = ORKOrderedTask(identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n-                    let taskViewController = ORKTaskViewController.init(task: task, taskRun: nil)\n-                    \n-                    if viewController.isKind(of: UINavigat", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 2230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwMjQwOA==", "bodyText": "why was this change added?", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391702408", "createdAt": "2020-03-12T15:30:14Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Branding/FDA/Branding.plist", "diffHunk": "@@ -24,5 +24,7 @@\n \t<string>https://www.fda.gov/AboutFDA/AboutThisWebsite/WebsitePolicies/#privacy</string>\n \t<key>ValidatedTitle</key>\n \t<string>Validated!</string>\n+\t<key>AllowFeedback</key>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNDczOA==", "bodyText": "inconsistency on blank lines again.", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391704738", "createdAt": "2020-03-12T15:33:40Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/EligibilityUI/InEligibilityStepViewController.swift", "diffHunk": "@@ -1,89 +1,82 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import ResearchKit\n-\n+import UIKit\n \n class InEligibilityStep: ORKStep {\n-    \n-    func showsProgress() -> Bool {\n-        return false\n-    }\n-}\n \n+  func showsProgress() -> Bool {\n+    return false\n+  }\n+}\n \n class InEligibilityStepViewController: ORKStepViewController {\n-    \n-    \n-    @IBOutlet weak var buttonDone: UIButton?\n-    @IBOutlet weak var labelDescription: UILabel?\n-    var descriptionText: String?\n-    \n-    // MARK: ORKStepViewController Intitialization Methods\n-    \n-    override init(step: ORKStep?) {\n-        super.init(step: step)\n-    }\n-    \n-    required init?(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-    }\n-    \n-    override func hasNextStep() -> Bool {\n-        super.hasNextStep()\n-        return true\n-    }\n-    \n-    override func goForward(){\n-        \n-        super.goForward()\n-        \n-    }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        buttonDone?.layer.borderColor =   kUicolorForButtonBackground\n-    }\n-    \n-    // MARK: Methods and Button Actions\n-    \n-    func showAlert(message: String){\n-        let alert = UIAlertController(title: kErrorTitle as String,message: message as String,preferredStyle: UIAlertController.Style.alert)\n-        alert.addAction(UIAlertAction(title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n-        \n-        \n-        self.navigationController?.present(alert, animated: true, completion: nil)\n-        \n-    }\n-    \n-    @IBAction func buttonActionDone(sender: UIButton?) {\n-        \n-        self.goForward()\n-    }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n-    }\n-}\n \n+  // MARK: - Outlets\n+  @IBOutlet weak var buttonDone: UIButton?\n+\n+  @IBOutlet weak var labelDescription: UILabel?\n+\n+  var descriptionText: String?\n+\n+  // MARK: - ORKStepViewController Intitialization Methods\n+\n+  override init(step: ORKStep?) {\n+    super.init(step: step)\n+  }\n \n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  override func hasNextStep() -> Bool {\n+    super.hasNextStep()\n+    return true\n+  }\n+\n+  override func goForward() {\n+    super.goForward()\n+  }\n+\n+  // MARK: - LifeCycle", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNTA5Ng==", "bodyText": "nit: extra blank line", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391705096", "createdAt": "2020-03-12T15:34:15Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/EligibilityUI/InEligibilityStepViewController.swift", "diffHunk": "@@ -1,89 +1,82 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import ResearchKit\n-\n+import UIKit\n \n class InEligibilityStep: ORKStep {\n-    \n-    func showsProgress() -> Bool {\n-        return false\n-    }\n-}\n \n+  func showsProgress() -> Bool {\n+    return false\n+  }\n+}\n \n class InEligibilityStepViewController: ORKStepViewController {\n-    \n-    \n-    @IBOutlet weak var buttonDone: UIButton?\n-    @IBOutlet weak var labelDescription: UILabel?\n-    var descriptionText: String?\n-    \n-    // MARK: ORKStepViewController Intitialization Methods\n-    \n-    override init(step: ORKStep?) {\n-        super.init(step: step)\n-    }\n-    \n-    required init?(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-    }\n-    \n-    override func hasNextStep() -> Bool {\n-        super.hasNextStep()\n-        return true\n-    }\n-    \n-    override func goForward(){\n-        \n-        super.goForward()\n-        \n-    }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        buttonDone?.layer.borderColor =   kUicolorForButtonBackground\n-    }\n-    \n-    // MARK: Methods and Button Actions\n-    \n-    func showAlert(message: String){\n-        let alert = UIAlertController(title: kErrorTitle as String,message: message as String,preferredStyle: UIAlertController.Style.alert)\n-        alert.addAction(UIAlertAction(title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n-        \n-        \n-        self.navigationController?.present(alert, animated: true, completion: nil)\n-        \n-    }\n-    \n-    @IBAction func buttonActionDone(sender: UIButton?) {\n-        \n-        self.goForward()\n-    }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n-    }\n-}\n \n+  // MARK: - Outlets\n+  @IBOutlet weak var buttonDone: UIButton?\n+\n+  @IBOutlet weak var labelDescription: UILabel?\n+\n+  var descriptionText: String?\n+\n+  // MARK: - ORKStepViewController Intitialization Methods\n+\n+  override init(step: ORKStep?) {\n+    super.init(step: step)\n+  }\n \n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  override func hasNextStep() -> Bool {\n+    super.hasNextStep()\n+    return true\n+  }\n+\n+  override func goForward() {\n+    super.goForward()\n+  }\n+\n+  // MARK: - LifeCycle\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    buttonDone?.layer.borderColor = kUicolorForButtonBackground\n+  }\n+\n+  // MARK: - UI Utils\n+\n+  func showAlert(message: String) {\n+    let alert = UIAlertController(\n+      title: kErrorTitle as String, message: message as String,\n+      preferredStyle: UIAlertController.Style.alert)\n+    alert.addAction(\n+      UIAlertAction(\n+        title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n+\n+    self.navigationController?.present(alert, animated: true, completion: nil)\n+\n+  }\n+\n+  // MARK: - Actions\n+  @IBAction func buttonActionDone(sender: UIButton?) {\n+    self.goForward()\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNjMzNw==", "bodyText": "is this even needed?\nalso can be presented in one line format:\nUIApplication.shared.beginBackgroundTask(expirationHandler: {})", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391706337", "createdAt": "2020-03-12T15:36:05Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/FetalKickUI/FetalKickCounterStepViewController/FetalKickCounterStepViewController.swift", "diffHunk": "@@ -45,582 +40,600 @@ let kFetalKickCounterValue = \"FetalKickCounterValue\"\n let kFetalKickCounterRunId = \"FetalKickCounterRunid\"\n let kSelectTimeLabel = \"Select Time\"\n \n-class FetalKickCounterStepViewController:  ORKStepViewController {\n-    \n-    var backgroundTaskIdentifier: UIBackgroundTaskIdentifier?\n-    \n-    @IBOutlet weak var startButton: UIButton?   // button to start task as well as increment the counter\n-    @IBOutlet weak var startTitleLabel: UILabel? // displays the title\n-    @IBOutlet weak var timerLabel: UILabel?      //  displays the current timer Value\n-    @IBOutlet weak var counterTextField: UITextField? // displays current kick counts\n-    @IBOutlet weak var editCounterButton: UIButton?  // used to edit the counter value\n-    @IBOutlet weak var seperatorLineView: UIView? // separator line\n-    \n-    @IBOutlet weak var submitButton: UIButton? // button to submit response to server\n-    \n-    @IBOutlet weak var editTimerButton: UIButton?\n-    \n-    var kickCounter: Int? = 0        // counter\n-    var timer: Timer? = Timer()      //  timer for the task\n-    var timerValue: Int? = 0         // TimerValue\n-    \n-    var totalTime: Int? = 0          // Total duration\n-    var maxKicksAllowed: Int? = 0\n-    \n-    var taskResult: FetalKickCounterTaskResult = FetalKickCounterTaskResult(identifier: kFetalKickCounterStepDefaultIdentifier)\n-  \n-    \n-    // MARK: ORKStepViewController overriden methods\n-    \n-    override init(step: ORKStep?) {\n-        super.init(step: step)\n-        \n-    }\n-    \n-    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {\n-        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n-        \n-    }\n-    \n-    required init?(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-    }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        var initialTime = 0\n-        \n-        let notificationCenter = NotificationCenter.default\n-        notificationCenter.addObserver(self, selector: #selector(appMovedToBackground), name: UIApplication.willResignActiveNotification, object: nil)\n-        \n-        \n-        notificationCenter.addObserver(self, selector: #selector(appBecameActive), name: UIApplication.didBecomeActiveNotification, object: nil)\n-        \n-         submitButton?.layer.borderColor =   kUicolorForButtonBackground\n-        \n-        if let step = step as? FetalKickCounterStep {\n-           \n-            let ud = UserDefaults.standard\n-            \n-            let activityId = ud.value(forKey: kFetalKickActivityId ) as! String?\n-            var differenceInSec = 0\n-            var autoStartTimer = false\n-            if  ud.bool(forKey: \"FKC\")\n-                && activityId != nil\n-                && activityId == Study.currentActivity?.actvityId\n-                 {\n-                    \n-                let previousTimerStartDate = ud.object(forKey: kFetalKickStartTimeStamp) as! Date\n-                let currentDate = Date()\n-                differenceInSec = Int(currentDate.timeIntervalSince(previousTimerStartDate))\n-                autoStartTimer = true\n-            }\n-        \n-           \n-                if differenceInSec >= 0 {\n-                    initialTime =   initialTime + differenceInSec\n-                }\n-                \n-                print(\"difference \\(differenceInSec)\")\n-                //Setting the maximum time allowed for the task\n-                 self.totalTime = step.counDownTimer! //10\n-            \n-                //Setting the maximum Kicks allowed\n-                self.maxKicksAllowed = step.totalCounts!\n-            \n-                //Calculating time in required Format\n-                let hours =   Int(initialTime) / 3600\n-                let minutes =  Int(initialTime) / 60 % 60\n-                let seconds =   Int(initialTime) % 60\n-                \n-                self.timerValue =  initialTime //self.totalTime    // step.counDownTimer!\n-                \n-                self.timerLabel?.text = (hours < 10 ? \"0\\(hours):\" : \"\\(hours):\") + (minutes < 10 ? \"0\\(minutes):\" : \"\\(minutes):\")   + (seconds < 10 ? \"0\\(seconds)\" : \"\\(seconds)\")\n-                //self.taskResult.duration = self.totalTime!\n-                \n-                if autoStartTimer{\n-                    \n-                    let previousKicks: Int? = ud.value(forKey: kFetalKickCounterValue ) as? Int\n-                    \n-                    self.kickCounter = (previousKicks == nil ? 0 : previousKicks!)\n-                    //Update Step Counter Value\n-                    self.setCounter()\n-                    \n-                    self.startButtonAction(UIButton())\n-                }\n-            backgroundTaskIdentifier = UIApplication.shared.beginBackgroundTask(expirationHandler: {\n-                \n-            })\n-            \n-            // enables the IQKeyboardManager\n-            // IQKeyboardManager.sharedManager().enable = true\n-            \n-            // adding guesture to view to support outside tap\n-            let gestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(FetalKickCounterStepViewController.handleTap(_:)))\n-            gestureRecognizer.delegate = self\n-            self.view.addGestureRecognizer(gestureRecognizer)\n-            }\n-    }\n-    \n-    \n-    override func hasNextStep() -> Bool {\n-        super.hasNextStep()\n-        return true\n-    }\n-    \n-    override func goForward(){\n-        \n-        super.goForward()\n-        \n-    }\n-    \n-    override var result: ORKStepResult? {\n-        \n-        let orkResult = super.result\n-        orkResult?.results = [self.taskResult]\n-        return orkResult\n-        \n-    }\n-    \n-    \n-    // MARK:Helper Methods\n-    \n-    /*\n-     updates the timer value\n-     */\n-    func setCounterValue(){\n-        \n-            if self.kickCounter! < 10 {\n-                counterTextField?.text = \"00\" + \"\\(self.kickCounter!)\"\n-                \n-            } else if self.kickCounter! >= 10 && self.kickCounter! < 100 {\n-                counterTextField?.text = \"0\" + \"\\(self.kickCounter!)\"\n-                \n-            } else {\n-                counterTextField?.text = \"\\(self.kickCounter!)\"\n-            }\n-    }\n-    \n-    /**\n-     Updates the timer Value\n-    */\n-    @objc func setCounter() {\n-        \n-        DispatchQueue.global(qos: .background).async {\n-            if self.timerValue! < 0 {\n-                self.timerValue = 0\n-                self.timer?.invalidate()\n-                self.timer = nil\n-               \n-                DispatchQueue.main.async {\n-\n-                    self.startButton?.isHidden = true\n-                    self.startTitleLabel?.isHidden = true\n-                    self.submitButton?.isHidden =  false\n-                }\n-                \n-            } else {\n-                self.timerValue = self.timerValue! + 1\n-            }\n-            \n-            if self.timerValue! >= 0 {\n-                \n-                DispatchQueue.main.async {\n-                    \n-                    if self.timerValue! > self.totalTime! {\n-                    self.setResults()\n-                    self.showAlertOnCompletion()\n-                       \n-                    } else {\n-                    self.editCounterButton?.isHidden = false\n-                    self.setTimerValue()\n-                    \n-                    }\n-                }\n-            }\n-        }\n-    }\n-    \n-    /**\n-     Updates the UI with timer value\n-    */\n-    func setTimerValue(){\n-        \n-        let hours = Int(self.timerValue!) / 3600\n-        let minutes = Int(self.timerValue!) / 60 % 60\n-        let seconds = Int(self.timerValue!) % 60\n-        \n-        self.timerLabel?.text = (hours < 10 ? \"0\\(hours):\" : \"\\(hours):\") + (minutes < 10 ? \"0\\(minutes):\" : \"\\(minutes):\")   + (seconds < 10 ? \"0\\(seconds)\" : \"\\(seconds)\")\n-        \n-        self.taskResult.totalKickCount = self.kickCounter!\n-    }\n-    \n-    /*\n-     handleTap method detects the tap gesture event\n-     @param  sender is tapguesture instance\n-     */\n-    @objc func handleTap(_ sender: UITapGestureRecognizer)   {\n-        counterTextField?.resignFirstResponder()\n-    }\n-    \n-    /**\n-     stores the details of ongoing Fetal Kick task in local datatbase\n-    */\n-    @objc func appMovedToBackground() {\n-        \n-        let ud = UserDefaults.standard\n-        if ud.object(forKey: kFetalKickStartTimeStamp) != nil{\n-            \n-            ud.set(true, forKey: \"FKC\")\n-            \n-            ud.set(Study.currentActivity?.actvityId, forKey: kFetalKickActivityId)\n-            ud.set(Study.currentStudy?.studyId, forKey: kFetalkickStudyId)\n-            \n-            ud.set(self.kickCounter, forKey: kFetalKickCounterValue)\n-            \n-            //check if runid is saved\n-            if ud.object(forKey: kFetalKickCounterRunId) == nil {\n-                ud.set(Study.currentActivity?.currentRun.runId, forKey: kFetalKickCounterRunId)\n-            }\n-            \n-            ud.synchronize()\n-        }\n-        \n-    }\n-    \n-    /**\n-     Resets the keys when app becomes Active\n-    */\n-    @objc func appBecameActive() {\n-        \n-        let ud = UserDefaults.standard\n-        ud.set(false, forKey: \"FKC\")\n-        ud.synchronize()\n+class FetalKickCounterStepViewController: ORKStepViewController {\n+\n+  // MARK: - Outlets\n+\n+  /// button to start task as well as increment the counter.\n+  @IBOutlet weak var startButton: UIButton?\n+\n+  /// displays the title.\n+  @IBOutlet weak var startTitleLabel: UILabel?\n+\n+  ///  displays the current timer Value.\n+  @IBOutlet weak var timerLabel: UILabel?\n+\n+  /// displays current kick counts.\n+  @IBOutlet weak var counterTextField: UITextField?\n+\n+  /// used to edit the counter value.\n+  @IBOutlet weak var editCounterButton: UIButton?\n+\n+  /// separator line.\n+  @IBOutlet weak var seperatorLineView: UIView?\n+\n+  /// button to submit response to server.\n+  @IBOutlet weak var submitButton: UIButton?\n+\n+  @IBOutlet weak var editTimerButton: UIButton?\n+\n+  /// Counter\n+  lazy var kickCounter: Int? = 0\n+\n+  /// Timer for the task\n+  lazy var timer: Timer? = Timer()\n+\n+  /// TimerValue\n+  lazy var timerValue: Int? = 0\n+\n+  var backgroundTaskIdentifier: UIBackgroundTaskIdentifier?\n+\n+  /// Total duration\n+  lazy var totalTime: Int? = 0\n+\n+  lazy var maxKicksAllowed: Int? = 0\n+\n+  lazy var taskResult: FetalKickCounterTaskResult = FetalKickCounterTaskResult(\n+    identifier: kFetalKickCounterStepDefaultIdentifier)\n+\n+  // MARK: ORKStepViewController Initializer methods\n+\n+  override init(step: ORKStep?) {\n+    super.init(step: step)\n+  }\n+\n+  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {\n+    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n+  }\n+\n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    var initialTime = 0\n+\n+    let notificationCenter = NotificationCenter.default\n+    notificationCenter.addObserver(\n+      self, selector: #selector(appMovedToBackground),\n+      name: UIApplication.willResignActiveNotification, object: nil)\n+\n+    notificationCenter.addObserver(\n+      self, selector: #selector(appBecameActive),\n+      name: UIApplication.didBecomeActiveNotification,\n+      object: nil)\n+\n+    submitButton?.layer.borderColor = kUicolorForButtonBackground\n+\n+    if let step = step as? FetalKickCounterStep {\n+\n+      let ud = UserDefaults.standard\n+\n+      let activityId = ud.value(forKey: kFetalKickActivityId) as! String?\n+      var differenceInSec = 0\n+      var autoStartTimer = false\n+      if ud.bool(forKey: \"FKC\")\n+        && activityId != nil\n+        && activityId == Study.currentActivity?.actvityId {\n+\n+        let previousTimerStartDate = ud.object(forKey: kFetalKickStartTimeStamp) as! Date\n+        let currentDate = Date()\n+        differenceInSec = Int(currentDate.timeIntervalSince(previousTimerStartDate))\n+        autoStartTimer = true\n+      }\n+\n+      if differenceInSec >= 0 {\n+        initialTime = initialTime + differenceInSec\n+      }\n+\n+      // Setting the maximum time allowed for the task\n+      self.totalTime = step.counDownTimer!  //10\n+\n+      // Setting the maximum Kicks allowed\n+      self.maxKicksAllowed = step.totalCounts!\n+\n+      // Calculating time in required Format\n+      let hours = Int(initialTime) / 3600\n+      let minutes = Int(initialTime) / 60 % 60\n+      let seconds = Int(initialTime) % 60\n+\n+      self.timerValue = initialTime\n+\n+      self.timerLabel?.text = (hours < 10 ? \"0\\(hours):\" : \"\\(hours):\") + (\n+        minutes < 10 ? \"0\\(minutes):\" : \"\\(minutes):\"\n+      ) + (seconds < 10 ? \"0\\(seconds)\" : \"\\(seconds)\")\n+\n+      if autoStartTimer {\n+\n+        let previousKicks: Int? = ud.value(forKey: kFetalKickCounterValue) as? Int\n+\n+        self.kickCounter = (previousKicks == nil ? 0 : previousKicks!)\n+        // Update Step Counter Value\n+        self.setCounter()\n+\n+        self.startButtonAction(UIButton())\n+      }\n+      backgroundTaskIdentifier = UIApplication.shared.beginBackgroundTask(\n+        expirationHandler: {\n+\n+        })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 443}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcxMjM3NA==", "bodyText": "please remove all debug logs", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391712374", "createdAt": "2020-03-12T15:45:16Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/NotificationUI/NotificationViewController.swift", "diffHunk": "@@ -1,302 +1,301 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n import UIKit\n \n-\n class NotificationViewController: UIViewController {\n-    \n-    @IBOutlet var tableView: UITableView?\n-    var notificationArray: Array<Any> = []\n-    \n-    \n-// MARK:- ViewController LifeCycle\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        self.title = NSLocalizedString(kNotificationsTitleText, comment: \"\")\n-        \n-        self.loadLocalNotification()\n-        WCPServices().getNotification(skip: 0, delegate: self)\n-    }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        self.addBackBarButton()\n-        self.navigationController?.setNavigationBarHidden(false, animated: true)\n-        \n-        let ud = UserDefaults.standard\n-        ud.set(false, forKey: kShowNotification)\n-        ud.synchronize()\n-    }\n-    \n-    override func viewDidAppear(_ animated: Bool) {\n-        super.viewDidAppear(animated)\n-    }\n \n-// MARK:- Helper Methods\n-    \n-    func handleNotificationListResponse() {\n-        if (Gateway.instance.notification?.count)! > 0{\n-            self.loadNotificationFromDatabase()\n-           // self.tableView?.isHidden = false\n-            \n-        }else {\n-          // self.tableView?.isHidden = true\n-            self.tableView?.isHidden = false\n-            self.tableView?.reloadData()\n-        }\n-    }\n-    \n-    func loadNotificationFromDatabase() {\n-        \n-        DBHandler.loadNotificationListFromDatabase(completionHandler: {(notificationList) in\n-            \n-            if notificationList.count > 0 {\n-               // self.tableView?.isHidden = false\n-                \n-                for notification in notificationList {\n-                    \n-                    //filter notification\n-                    if notification.type == AppNotification.NotificationType.Study {\n-                        \n-                        let study = Gateway.instance.studies?.filter({$0.studyId == notification.studyId}).last\n-                        if study != nil && self.isUserJoined(study: study!) {\n-                            self.notificationArray.append(notification)\n-                        }\n-                        \n-                    }else {\n-                         self.notificationArray.append(notification)\n-                    }\n-                }\n-              \n-                //Sort Notification according to sort date\n-              let sorted = self.notificationArray.sorted(by: { (first, second) -> Bool in\n-                \n-                let date1: Date!\n-                let date2: Date!\n-                if first is AppLocalNotification {\n-                  date1 = (first as! AppLocalNotification).startDate\n-                  \n-                }else {\n-                  date1 = (first as! AppNotification).date\n-                }\n-                \n-                if second is AppLocalNotification {\n-                  date2 = (second as! AppLocalNotification).startDate\n-                    \n-                }else {\n-                  date2 = (second as! AppNotification).date\n-                }\n-               return date1 > date2\n-                \n-              })\n-              self.notificationArray = sorted\n-              self.tableView?.isHidden = false\n-              self.tableView?.reloadData()\n-                \n-            }else {\n-                self.tableView?.isHidden = false\n-                self.tableView?.reloadData()\n-            }\n-        })\n+  // MARK: - Outlets\n+  @IBOutlet var tableView: UITableView?\n+\n+  // MARK: - Properties\n+  lazy var notificationArray: [Any] = []\n+\n+  // MARK: - ViewController LifeCycle\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    self.title = NSLocalizedString(kNotificationsTitleText, comment: \"\")\n+\n+    self.loadLocalNotification()\n+    WCPServices().getNotification(skip: 0, delegate: self)\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+    self.addBackBarButton()\n+    self.navigationController?.setNavigationBarHidden(false, animated: true)\n+\n+    let ud = UserDefaults.standard\n+    ud.set(false, forKey: kShowNotification)\n+    ud.synchronize()\n+  }\n+\n+  // MARK: - Utils\n+\n+  private func handleNotificationListResponse() {\n+    if (Gateway.instance.notification?.count)! > 0 {\n+      self.loadNotificationFromDatabase()\n+    } else {\n+      self.tableView?.isHidden = false\n+      self.tableView?.reloadData()\n     }\n-    \n-    func loadLocalNotification(){\n-        \n-        DBHandler.getLocalNotification { (notificationList) in\n-            if notificationList.count > 0 {\n-                self.notificationArray = notificationList\n+  }\n+\n+  private func loadNotificationFromDatabase() {\n+\n+    DBHandler.loadNotificationListFromDatabase(\n+      completionHandler: { (notificationList) in\n+\n+        if notificationList.count > 0 {\n+\n+          for notification in notificationList {\n+\n+            // filter notification\n+            if notification.type == AppNotification.NotificationType.Study {\n+\n+              let study = Gateway.instance.studies?.filter({ $0.studyId == notification.studyId })\n+                .last\n+              if study != nil && self.isUserJoined(study: study!) {\n+                self.notificationArray.append(notification)\n+              }\n+\n+            } else {\n+              self.notificationArray.append(notification)\n             }\n+          }\n+\n+          // Sort Notification according to sort date\n+          let sorted = self.notificationArray.sorted(\n+            by: { (first, second) -> Bool in\n+\n+              let date1: Date!\n+              let date2: Date!\n+              if first is AppLocalNotification {\n+                date1 = (first as! AppLocalNotification).startDate\n+\n+              } else {\n+                date1 = (first as! AppNotification).date\n+              }\n+\n+              if second is AppLocalNotification {\n+                date2 = (second as! AppLocalNotification).startDate\n+\n+              } else {\n+                date2 = (second as! AppNotification).date\n+              }\n+              return date1 > date2\n+\n+            })\n+          self.notificationArray = sorted\n+          self.tableView?.isHidden = false\n+          self.tableView?.reloadData()\n+\n+        } else {\n+          self.tableView?.isHidden = false\n+          self.tableView?.reloadData()\n         }\n-        \n+      })\n+  }\n+\n+  private func loadLocalNotification() {\n+\n+    DBHandler.getLocalNotification { (notificationList) in\n+      if notificationList.count > 0 {\n+        self.notificationArray = notificationList\n+      }\n     }\n \n-    \n-    /**\n-     Used to check the Study State\n-     @param study    Access the data from Study class\n-     @return Bool\n-     */\n-    class func checkForStudyState(study: Study) -> Bool {\n-        \n-        let currentStudy = study\n-        let participatedStatus = (currentStudy.userParticipateState.status)\n-        \n-        switch currentStudy.status {\n-        case .Active:\n-            if participatedStatus == .inProgress {\n-                return true\n-            }else {\n-                 UIUtilities.showAlertWithTitleAndMessage(title: \"\", message: NSLocalizedString(\"Please join study to go forward.\", comment: \"\") as NSString)\n-            }\n-        case .Upcoming:\n-            UIUtilities.showAlertWithTitleAndMessage(title: \"\", message: NSLocalizedString(kMessageForStudyUpcomingState, comment: \"\") as NSString)\n-            \n-        case .Paused:\n-            UIUtilities.showAlertWithTitleAndMessage(title: \"\", message: NSLocalizedString(kMessageForStudyPausedState, comment: \"\") as NSString)\n-            \n-        case .Closed:\n-            UIUtilities.showAlertWithTitleAndMessage(title: \"\", message: NSLocalizedString(kMessageForStudyClosedState, comment: \"\") as NSString)\n-            \n-        }\n-        \n-        return false\n+  }\n+\n+  /// Used to check the Study State.\n+  /// - Parameter study: Instance of `Study`.\n+  /// - Returns: `true` if participationStatus == .inProgress.\n+  class func checkForStudyState(study: Study) -> Bool {\n+\n+    let currentStudy = study\n+    let participatedStatus = (currentStudy.userParticipateState.status)\n+\n+    switch currentStudy.status {\n+    case .Active:\n+      if participatedStatus == .inProgress {\n+        return true\n+      } else {\n+        UIUtilities.showAlertWithTitleAndMessage(\n+          title: \"\",\n+          message: NSLocalizedString(\"Please join study to go forward.\", comment: \"\")\n+            as NSString)\n+      }\n+    case .Upcoming:\n+      UIUtilities.showAlertWithTitleAndMessage(\n+        title: \"\",\n+        message: NSLocalizedString(kMessageForStudyUpcomingState, comment: \"\") as NSString)\n+\n+    case .Paused:\n+      UIUtilities.showAlertWithTitleAndMessage(\n+        title: \"\",\n+        message: NSLocalizedString(kMessageForStudyPausedState, comment: \"\") as NSString)\n+\n+    case .Closed:\n+      UIUtilities.showAlertWithTitleAndMessage(\n+        title: \"\",\n+        message: NSLocalizedString(kMessageForStudyClosedState, comment: \"\") as NSString)\n+\n     }\n-    \n-     func isUserJoined(study: Study) -> Bool {\n-        \n-        let currentStudy = study\n-        let participatedStatus = (currentStudy.userParticipateState.status)\n-        if participatedStatus == .inProgress {\n-            return true\n-        }\n-        return false\n+\n+    return false\n+  }\n+\n+  /// This method checks if the user has joined the study already.\n+  /// - Parameter study: Instance of `Study`to check.\n+  private func isUserJoined(study: Study) -> Bool {\n+\n+    let currentStudy = study\n+    let participatedStatus = (currentStudy.userParticipateState.status)\n+    if participatedStatus == .inProgress {\n+      return true\n     }\n-    \n-    \n-    class func checkForStudyStateAndParticiapantState(study: Study) -> Bool {\n-        \n-        let currentStudy = study\n-        let participatedStatus = (currentStudy.userParticipateState.status)\n-        \n-        switch currentStudy.status {\n-        case .Active:\n-            if participatedStatus == .inProgress {\n-                return true\n-            }else {\n-               return false\n-            }\n-        case .Upcoming:\n-           return false\n-        case .Paused:\n-            return false\n-        case .Closed:\n-            return false\n-            \n-        }\n-        \n-        //return false\n+    return false\n+  }\n+\n+  class func checkForStudyStateAndParticiapantState(study: Study) -> Bool {\n+\n+    let currentStudy = study\n+    let participatedStatus = (currentStudy.userParticipateState.status)\n+\n+    switch currentStudy.status {\n+    case .Active:\n+      if participatedStatus == .inProgress {\n+        return true\n+      } else {\n+        return false\n+      }\n+    case .Upcoming:\n+      return false\n+    case .Paused:\n+      return false\n+    case .Closed:\n+      return false\n+\n     }\n-    \n-    /**\n-     Used to push the screen to Study Dashboard\n-     @param type    Access data from AppNotification class and NotificationSubType Enum\n-     */\n-    func pushToStudyDashboard(type: AppNotification.NotificationSubType?) {\n-        \n-        let viewController: StudyDashboardTabbarViewController?\n-        let storyboard = UIStoryboard(name: kStudyStoryboard, bundle: nil)\n-        if type != nil {\n-            \n-            self.navigationController?.setNavigationBarHidden(true, animated: true)\n-            \n-            viewController = storyboard.instantiateViewController(withIdentifier: kStudyDashboardTabbarControllerIdentifier) as? StudyDashboardTabbarViewController\n-            \n-            switch type! as  AppNotification.NotificationSubType{\n-            case .Study:\n-                \n-                viewController?.selectedIndex = 0\n-                self.navigationController?.pushViewController(viewController!, animated: true)\n-            case .Resource:\n-                \n-                viewController?.selectedIndex = 2\n-                self.navigationController?.pushViewController(viewController!, animated: true)\n-            case .Activity:\n-                \n-                viewController?.selectedIndex = 0\n-                self.navigationController?.pushViewController(viewController!, animated: true)\n-            default: break\n-                \n-            }\n-        }\n+\n+  }\n+\n+  /// Used to push the screen to Study Dashboard.\n+  /// - Parameter type: Access data from AppNotification class and NotificationSubType Enum.\n+  func pushToStudyDashboard(type: AppNotification.NotificationSubType?) {\n+\n+    let viewController: StudyDashboardTabbarViewController?\n+    let storyboard = UIStoryboard(name: kStudyStoryboard, bundle: nil)\n+    if type != nil {\n+\n+      self.navigationController?.setNavigationBarHidden(true, animated: true)\n+\n+      viewController = storyboard.instantiateViewController(\n+        withIdentifier: kStudyDashboardTabbarControllerIdentifier)\n+        as? StudyDashboardTabbarViewController\n+\n+      switch type! as AppNotification.NotificationSubType {\n+      case .Study:\n+\n+        viewController?.selectedIndex = 0\n+        self.navigationController?.pushViewController(viewController!, animated: true)\n+      case .Resource:\n+\n+        viewController?.selectedIndex = 2\n+        self.navigationController?.pushViewController(viewController!, animated: true)\n+      case .Activity:\n+\n+        viewController?.selectedIndex = 0\n+        self.navigationController?.pushViewController(viewController!, animated: true)\n+      default: break\n+\n+      }\n     }\n+  }\n }\n \n-// MARK:- TableView Datasource\n+// MARK: - TableView Datasource\n extension NotificationViewController: UITableViewDataSource {\n-    \n-    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n-        return notificationArray.count\n-    }\n-    \n-    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n-        var cell: NotificationTableViewCell?\n-        \n-        cell = tableView.dequeueReusableCell(withIdentifier: kNotificationTableViewCellIdentifier , for: indexPath) as? NotificationTableViewCell\n-        \n-        cell?.populateCellWith(notification: (notificationArray[indexPath.row]))\n-        cell?.backgroundColor = UIColor.clear\n-        return cell!\n-    }\n+\n+  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n+    return notificationArray.count\n+  }\n+\n+  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n+    var cell: NotificationTableViewCell?\n+\n+    cell = tableView.dequeueReusableCell(\n+      withIdentifier: kNotificationTableViewCellIdentifier, for: indexPath)\n+      as? NotificationTableViewCell\n+\n+    cell?.populateCellWith(notification: (notificationArray[indexPath.row]))\n+    cell?.backgroundColor = UIColor.clear\n+    return cell!\n+  }\n }\n \n-// MARK:- TableView Delegates\n-extension NotificationViewController: UITableViewDelegate{\n-    \n-    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n-        tableView.deselectRow(at: indexPath, animated: true)\n-      \n-      \n-        let appNotification = notificationArray[indexPath.row]\n-        let appNotif = appNotification as! AppNotification\n-        if appNotif.type == AppNotification.NotificationType.Study {\n-        \n-        if Utilities.isValidValue(someObject: appNotif.studyId as AnyObject?) {\n-            \n-            let study = Gateway.instance.studies?.filter({$0.studyId == appNotif.studyId}).last\n-            \n-            if self.isUserJoined(study: study!) && study?.status == .Active {\n-                \n-                Study.updateCurrentStudy(study: study! )\n-                self.pushToStudyDashboard(type: appNotif.subType )\n-            }\n-        }\n+// MARK: - TableView Delegates\n+extension NotificationViewController: UITableViewDelegate {\n+\n+  func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n+    tableView.deselectRow(at: indexPath, animated: true)\n+\n+    let appNotification = notificationArray[indexPath.row]\n+    let appNotif = appNotification as! AppNotification\n+    if appNotif.type == AppNotification.NotificationType.Study {\n+\n+      if Utilities.isValidValue(someObject: appNotif.studyId as AnyObject?) {\n+\n+        let study = Gateway.instance.studies?.filter({ $0.studyId == appNotif.studyId })\n+          .last\n+\n+        if self.isUserJoined(study: study!) && study?.status == .Active {\n+\n+          Study.updateCurrentStudy(study: study!)\n+          self.pushToStudyDashboard(type: appNotif.subType)\n         }\n+      }\n     }\n+  }\n }\n \n-\n-// MARK:- WebService Delegate\n+// MARK: - WebService Delegate\n extension NotificationViewController: NMWebServiceDelegate {\n-    \n-    func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        self.addProgressIndicator()\n-    }\n-    \n-    func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n-        self.removeProgressIndicator()\n-        \n-        if requestName as String == WCPMethods.notifications.method.methodName {\n-           self.handleNotificationListResponse()\n-        }\n-    }\n- \n-    func failedRequest(_ manager: NetworkManager, requestName: NSString, error: NSError) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        self.removeProgressIndicator()\n-        \n+\n+  func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n+    Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n+    self.addProgressIndicator()\n+  }\n+\n+  func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n+    self.removeProgressIndicator()\n+\n+    if requestName as String == WCPMethods.notifications.method.methodName {\n+      self.handleNotificationListResponse()\n     }\n-}\n+  }\n \n+  func failedRequest(_ manager: NetworkManager, requestName: NSString, error: NSError) {\n+    Logger.sharedInstance.info(\"requestname : \\(requestName)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 571}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcxMjkyNQ==", "bodyText": "nit: remove extra blank line.", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391712925", "createdAt": "2020-03-12T15:46:02Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/ProfileViewUI/ProfileViewController.swift", "diffHunk": "@@ -49,957 +47,818 @@ let kUsePasscodeToAccessApp = \"Use Passcode to access app\"\n let ktouchid = \"touchIdEnabled\"\n let korkPasscode = \"ORKPasscode\"\n \n-\n // Cell Toggle Switch Types\n-enum ToggelSwitchTags: Int{\n-    case usePasscode = 3\n-    case useTouchId = 6\n-    case receivePush = 4\n-    case receiveStudyActivityReminders = 5\n+enum ToggelSwitchTags: Int {\n+  case usePasscode = 3\n+  case useTouchId = 6\n+  case receivePush = 4\n+  case receiveStudyActivityReminders = 5\n }\n \n class ProfileViewController: UIViewController, SlideMenuControllerDelegate {\n-    \n-    var tableViewRowDetails: NSMutableArray?\n-    var datePickerView: UIDatePicker?\n-    var isCellEditable: Bool?\n-    var user = User.currentUser\n-    var isPasscodeViewPresented: Bool = false\n-    \n-    var passcodeStateIsEditing: Bool = false\n-    \n-    var isProfileEdited = false\n-    \n-    @IBOutlet var tableViewProfile: UITableView?\n-    @IBOutlet var tableViewFooterViewProfile: UIView?\n-    @IBOutlet var buttonLeadTime: UIButton?\n-    @IBOutlet var editBarButtonItem: UIBarButtonItem?\n-    @IBOutlet var tableTopConstraint: NSLayoutConstraint?\n-    \n-    \n-// MARK:- ViewController Lifecycle\n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        //First responder handler for textfields\n-        // IQKeyboardManager.sharedManager().enable = true\n-        \n-        //Load plist info\n-        let plistPath = Bundle.main.path(forResource: \"Profile\", ofType: \".plist\", inDirectory:nil)\n-        \n-        tableViewRowDetails = NSMutableArray.init(contentsOfFile: plistPath!)\n-        \n-        //Resigning First Responder on outside tap\n-        let gestureRecognizer: UITapGestureRecognizer = UITapGestureRecognizer.init(target: self, action: #selector(ProfileViewController.dismissKeyboard))\n-        self.tableViewProfile?.addGestureRecognizer(gestureRecognizer)\n-        \n-        //Initial data setup\n-        self.setInitialDate()\n-        \n-        self.fdaSlideMenuController()?.delegate = self\n-        \n+\n+  // MARK: - Outlets\n+  @IBOutlet var tableViewProfile: UITableView?\n+\n+  @IBOutlet var tableViewFooterViewProfile: UIView?\n+  @IBOutlet var buttonLeadTime: UIButton?\n+  @IBOutlet var editBarButtonItem: UIBarButtonItem?\n+  @IBOutlet var tableTopConstraint: NSLayoutConstraint?\n+\n+  // MARK: - Properties\n+  var tableViewRowDetails: NSMutableArray?\n+\n+  var datePickerView: UIDatePicker?\n+  var isCellEditable: Bool?\n+  lazy var user = User.currentUser\n+  lazy var isPasscodeViewPresented: Bool = false\n+  lazy var passcodeStateIsEditing: Bool = false\n+  lazy var isProfileEdited = false\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  // MARK: - ViewController Lifecycle\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    // Load plist info\n+    let plistPath = Bundle.main.path(forResource: \"Profile\", ofType: \".plist\", inDirectory: nil)\n+\n+    tableViewRowDetails = NSMutableArray.init(contentsOfFile: plistPath!)\n+\n+    // Resigning First Responder on outside tap\n+    let gestureRecognizer: UITapGestureRecognizer = UITapGestureRecognizer.init(\n+      target: self, action: #selector(ProfileViewController.dismissKeyboard))\n+    self.tableViewProfile?.addGestureRecognizer(gestureRecognizer)\n+\n+    // Initial data setup\n+    self.setInitialDate()\n+\n+    self.fdaSlideMenuController()?.delegate = self\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcxMzU4NA==", "bodyText": "nit: remove extra blank line", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391713584", "createdAt": "2020-03-12T15:46:58Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/ProfileViewUI/ProfileViewController.swift", "diffHunk": "@@ -49,957 +47,818 @@ let kUsePasscodeToAccessApp = \"Use Passcode to access app\"\n let ktouchid = \"touchIdEnabled\"\n let korkPasscode = \"ORKPasscode\"\n \n-\n // Cell Toggle Switch Types\n-enum ToggelSwitchTags: Int{\n-    case usePasscode = 3\n-    case useTouchId = 6\n-    case receivePush = 4\n-    case receiveStudyActivityReminders = 5\n+enum ToggelSwitchTags: Int {\n+  case usePasscode = 3\n+  case useTouchId = 6\n+  case receivePush = 4\n+  case receiveStudyActivityReminders = 5\n }\n \n class ProfileViewController: UIViewController, SlideMenuControllerDelegate {\n-    \n-    var tableViewRowDetails: NSMutableArray?\n-    var datePickerView: UIDatePicker?\n-    var isCellEditable: Bool?\n-    var user = User.currentUser\n-    var isPasscodeViewPresented: Bool = false\n-    \n-    var passcodeStateIsEditing: Bool = false\n-    \n-    var isProfileEdited = false\n-    \n-    @IBOutlet var tableViewProfile: UITableView?\n-    @IBOutlet var tableViewFooterViewProfile: UIView?\n-    @IBOutlet var buttonLeadTime: UIButton?\n-    @IBOutlet var editBarButtonItem: UIBarButtonItem?\n-    @IBOutlet var tableTopConstraint: NSLayoutConstraint?\n-    \n-    \n-// MARK:- ViewController Lifecycle\n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        //First responder handler for textfields\n-        // IQKeyboardManager.sharedManager().enable = true\n-        \n-        //Load plist info\n-        let plistPath = Bundle.main.path(forResource: \"Profile\", ofType: \".plist\", inDirectory:nil)\n-        \n-        tableViewRowDetails = NSMutableArray.init(contentsOfFile: plistPath!)\n-        \n-        //Resigning First Responder on outside tap\n-        let gestureRecognizer: UITapGestureRecognizer = UITapGestureRecognizer.init(target: self, action: #selector(ProfileViewController.dismissKeyboard))\n-        self.tableViewProfile?.addGestureRecognizer(gestureRecognizer)\n-        \n-        //Initial data setup\n-        self.setInitialDate()\n-        \n-        self.fdaSlideMenuController()?.delegate = self\n-        \n+\n+  // MARK: - Outlets\n+  @IBOutlet var tableViewProfile: UITableView?\n+\n+  @IBOutlet var tableViewFooterViewProfile: UIView?\n+  @IBOutlet var buttonLeadTime: UIButton?\n+  @IBOutlet var editBarButtonItem: UIBarButtonItem?\n+  @IBOutlet var tableTopConstraint: NSLayoutConstraint?\n+\n+  // MARK: - Properties\n+  var tableViewRowDetails: NSMutableArray?\n+\n+  var datePickerView: UIDatePicker?\n+  var isCellEditable: Bool?\n+  lazy var user = User.currentUser\n+  lazy var isPasscodeViewPresented: Bool = false\n+  lazy var passcodeStateIsEditing: Bool = false\n+  lazy var isProfileEdited = false\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  // MARK: - ViewController Lifecycle\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    // Load plist info\n+    let plistPath = Bundle.main.path(forResource: \"Profile\", ofType: \".plist\", inDirectory: nil)\n+\n+    tableViewRowDetails = NSMutableArray.init(contentsOfFile: plistPath!)\n+\n+    // Resigning First Responder on outside tap\n+    let gestureRecognizer: UITapGestureRecognizer = UITapGestureRecognizer.init(\n+      target: self, action: #selector(ProfileViewController.dismissKeyboard))\n+    self.tableViewProfile?.addGestureRecognizer(gestureRecognizer)\n+\n+    // Initial data setup\n+    self.setInitialDate()\n+\n+    self.fdaSlideMenuController()?.delegate = self\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+    user = User.currentUser\n+\n+    if isPasscodeViewPresented == false {\n+      UserServices().getUserProfile(self as NMWebServiceDelegate)\n     }\n-    \n-    override func viewWillAppear(_ animated: Bool) { \n-        super.viewWillAppear(animated)\n-        user = User.currentUser\n-        \n-        if isPasscodeViewPresented == false{\n-            UserServices().getUserProfile(self as NMWebServiceDelegate)\n-        }\n-        self.setNavigationBarItem()\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-        self.tableViewProfile?.reloadData()\n+    self.setNavigationBarItem()\n+    self.tableViewProfile?.reloadData()\n+  }\n+\n+  override func viewWillDisappear(_ animated: Bool) {\n+    super.viewWillDisappear(animated)\n+\n+    if isProfileEdited {\n+      isProfileEdited = false\n+      UserServices().updateUserProfile(self)\n     }\n-    \n-    override func viewDidAppear(_ animated: Bool) {\n-        super.viewDidAppear(animated)\n-        \n-       \n-        \n+  }\n+\n+  func leftDidClose() {\n+    Logger.sharedInstance.info(\"Left menu is closed\")\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  /// Change password button clicked.\n+  @IBAction func buttonActionChangePassCode(_ sender: UIButton) {\n+\n+    let passcodeViewController = ORKPasscodeViewController.passcodeEditingViewController(\n+      withText: \"\", delegate: self, passcodeType: .type4Digit)\n+    passcodeStateIsEditing = true\n+\n+    self.navigationController?.present(passcodeViewController, animated: false, completion: {})\n+  }\n+\n+  ///  Edit Profile button clicked\n+  @IBAction func editBarButtonAction(_ sender: UIBarButtonItem) {\n+\n+    if self.isCellEditable! == false {\n+      self.isCellEditable = true\n+\n+      self.buttonLeadTime?.isUserInteractionEnabled = true\n+\n+      self.editBarButtonItem?.title = \"Save\"\n+      self.editBarButtonItem?.tintColor = UIColor.black\n+    } else {\n+      self.view.endEditing(true)\n+\n+      if self.validateAllFields() {\n+        UserServices().updateUserProfile(self)\n+      }\n     }\n-    \n-    override func viewWillDisappear(_ animated: Bool) {\n-        print(\"Profile View will disapper\")\n-        \n-        if isProfileEdited {\n-            isProfileEdited = false\n-            UserServices().updateUserProfile(self)\n+    self.tableViewProfile?.reloadData()\n+  }\n+\n+  ///  Button action for LeadtimeButton, CancelButton & DoneButton.\n+  @IBAction func buttonActionLeadTime(_ sender: UIButton) {\n+\n+    let alertView = UIAlertController(\n+      title: kLeadTimeSelectText, message: \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\",\n+      preferredStyle: UIAlertController.Style.actionSheet)\n+\n+    datePickerView = UIDatePicker.init(\n+      frame: CGRect(x: 10, y: 30, width: alertView.view.frame.size.width - 40, height: 216))\n+\n+    datePickerView?.datePickerMode = .countDownTimer\n+\n+    let dateFormatter = DateFormatter()\n+    dateFormatter.dateFormat = \"HH:mm\"\n+\n+    datePickerView?.date = dateFormatter.date(from: \"00:00\")!\n+\n+    alertView.view.addSubview(datePickerView!)\n+\n+    let action = UIAlertAction(\n+      title: kActionSheetDoneButtonTitle, style: UIAlertAction.Style.default,\n+      handler: {\n+        _ in\n+\n+        let calender: Calendar? = Calendar.current\n+\n+        if Utilities.isValidValue(someObject: self.datePickerView?.date as AnyObject?) {\n+\n+          let dateComponent = calender?.dateComponents(\n+            [.hour, .minute], from: (self.datePickerView?.date)!)\n+\n+          let title: String! = (\n+            ((dateComponent?.hour)! as Int) < 10\n+              ? \"0\\((dateComponent?.hour)! as Int)\"\n+              : \"\\((dateComponent?.hour)! as Int)\"\n+          ) + \":\"\n+\n+            + (\n+              ((dateComponent?.minute)! as Int) < 10\n+                ? \"0\\((dateComponent?.minute)! as Int)\"\n+                : \"\\((dateComponent?.minute)! as Int)\"\n+            )\n+\n+          self.buttonLeadTime?.setTitle(title!, for: .normal)\n+          self.user.settings?.leadTime = title\n         }\n+\n+      })\n+    let actionCancel = UIAlertAction(\n+      title: kActionSheetCancelButtonTitle, style: UIAlertAction.Style.default,\n+      handler: {\n+        _ in\n+\n+      })\n+\n+    alertView.addAction(action)\n+    alertView.addAction(actionCancel)\n+    present(alertView, animated: true, completion: nil)\n+\n+  }\n+\n+  /// Signout Button Clicked.\n+  @IBAction func buttonActionSignOut(_ sender: UIButton) {\n+\n+    UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+      NSLocalizedString(kSignOutText, comment: \"\"),\n+      errorMessage: NSLocalizedString(kAlertMessageForSignOut, comment: \"\"),\n+      errorAlertActionTitle: NSLocalizedString(kSignOutText, comment: \"\"),\n+      errorAlertActionTitle2: NSLocalizedString(kTitleCancel, comment: \"\"),\n+      viewControllerUsed: self,\n+      action1: {\n+\n+        self.sendRequestToSignOut()\n+\n+      },\n+      action2: {\n+        // Handle cancel action\n+      })\n+\n+  }\n+\n+  /// Delete Account clicked.\n+  @IBAction func buttonActionDeleteAccount(_ sender: UIButton) {\n+\n+    if (Gateway.instance.studies?.count)! > 0 {\n+      let studies = Gateway.instance.studies\n+      var joinedStudies: [Study] = []\n+      if Utilities.isStandaloneApp() {\n+        let standaloneStudyId = Utilities.standaloneStudyId()\n+        joinedStudies = studies?.filter({\n+            (\n+              $0.userParticipateState.status == .inProgress || $0.userParticipateState\n+                .status\n+                == .completed\n+            ) && ($0.studyId == standaloneStudyId)\n+          }) ?? []\n+      } else {\n+        joinedStudies = studies?.filter({\n+            $0.userParticipateState.status == .inProgress || $0.userParticipateState\n+              .status\n+              == .completed\n+          }) ?? []\n+      }\n+\n+      if joinedStudies.count != 0 {\n+        self.performSegue(withIdentifier: \"confirmationSegue\", sender: joinedStudies)\n+      } else {\n+\n+        var infoDict: NSDictionary?\n+        if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n+          infoDict = NSDictionary(contentsOfFile: path)\n+        }\n+        let navTitle = infoDict![\"ProductTitleName\"] as! String\n+\n+        var descriptionText = kDeleteAccountConfirmationMessage\n+        descriptionText = descriptionText.replacingOccurrences(\n+          of: \"#APPNAME#\", with: navTitle)\n+\n+        UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+          NSLocalizedString(kTitleDeleteAccount, comment: \"\"),\n+          errorMessage: NSLocalizedString(descriptionText, comment: \"\"),\n+          errorAlertActionTitle: NSLocalizedString(kTitleDeleteAccount, comment: \"\"),\n+          errorAlertActionTitle2: NSLocalizedString(kTitleCancel, comment: \"\"),\n+          viewControllerUsed: self,\n+          action1: {\n+\n+            self.sendRequestToDeleteAccount()\n+\n+          },\n+          action2: {\n+              // Handle cancel action\n+          })\n+      }\n     }\n-    \n-    func leftDidClose() {\n-        print(\"Left menu is closed\")\n-    }\n-    \n-// MARK:- Button Actions\n-    \n-    /**\n-     \n-     Change password button clicked\n-     \n-     @param sender    Accepts UIButton object\n-\n-     */\n-    \n-    \n-    @IBAction func buttonActionChangePassCode(_ sender: UIButton){\n-        \n-        let passcodeViewController = ORKPasscodeViewController.passcodeEditingViewController(withText: \"\", delegate: self, passcodeType: .type4Digit)\n-        passcodeStateIsEditing = true\n-        \n-        self.navigationController?.present(passcodeViewController, animated: false, completion: {})\n+\n+  }\n+\n+  // MARK: - Utility Methods\n+\n+  @objc func dismissKeyboard() {\n+    self.view.endEditing(true)\n+  }\n+\n+  /// Api Call to SignOut.\n+  func sendRequestToSignOut() {\n+    UserServices().logoutUser(self)\n+  }\n+\n+  /// Api call to delete account.\n+  func sendRequestToDeleteAccount() {\n+    let studies: [String] = []\n+    UserServices().deActivateAccount(listOfStudyIds: studies, delegate: self)\n+  }\n+\n+  /// SignOut Response handler for slider menu setup.\n+  func handleSignoutResponse() {\n+\n+    if ORKPasscodeViewController.isPasscodeStoredInKeychain() {\n+      ORKPasscodeViewController.removePasscodeFromKeychain()\n     }\n-    \n-    \n-    /**\n-     \n-     Edit Profile button clicked\n-     \n-     @param sender    Accepts UIbarButtonItem\n-\n-     */\n-    @IBAction func editBarButtonAction(_ sender: UIBarButtonItem){\n-        \n-        if self.isCellEditable! == false  {\n-            self.isCellEditable =  true\n-            \n-            self.buttonLeadTime?.isUserInteractionEnabled =  true\n-            \n-            self.editBarButtonItem?.title = \"Save\"\n-            self.editBarButtonItem?.tintColor = UIColor.black\n-        }\n-        else{\n-            self.view.endEditing(true)\n-            \n-            if self.validateAllFields() {\n-                UserServices().updateUserProfile(self)\n-            }\n+\n+    let ud = UserDefaults.standard\n+    ud.set(false, forKey: kPasscodeIsPending)\n+    ud.set(false, forKey: kShowNotification)\n+    ud.synchronize()\n+\n+    let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+    appDelegate.updateKeyAndInitializationVector()\n+\n+    let leftController = (slideMenuController()?.leftViewController as? LeftMenuViewController)!\n+    leftController.changeViewController(.studyList)\n+    leftController.createLeftmenuItems()\n+\n+  }\n+\n+  /// DeleteAccount Response handler.\n+  func handleDeleteAccountResponse() {\n+\n+    ORKPasscodeViewController.removePasscodeFromKeychain()\n+\n+    let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+    appDelegate.updateKeyAndInitializationVector()\n+\n+    UIUtilities.showAlertMessageWithActionHandler(\n+      NSLocalizedString(kTitleMessage, comment: \"\"),\n+      message: NSLocalizedString(kMessageAccountDeletedSuccess, comment: \"\"),\n+      buttonTitle: NSLocalizedString(kTitleOk, comment: \"\"), viewControllerUsed: self\n+    ) {\n+\n+      if Utilities.isStandaloneApp() {\n+\n+        UIApplication.shared.keyWindow?.addProgressIndicatorOnWindowFromTop()\n+        Study.currentStudy = nil\n+        self.slideMenuController()?.leftViewController?.navigationController?\n+          .popToRootViewController(animated: true)\n+        DispatchQueue.main.asyncAfter(deadline: .now()+1) {\n+          UIApplication.shared.keyWindow?.removeProgressIndicatorFromWindow()\n         }\n-        self.tableViewProfile?.reloadData()\n-    }\n-    \n-    \n-    /**\n-     \n-     Button action for LeadtimeButton, CancelButton & DoneButton\n-     \n-     @param sender  Accepts UIButton object\n-     \n-     */\n-    @IBAction func buttonActionLeadTime(_ sender: UIButton) {\n-        \n-        \n-        let alertView = UIAlertController(title: kLeadTimeSelectText, message: \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\", preferredStyle: UIAlertController.Style.actionSheet);\n-        \n-        \n-        datePickerView = UIDatePicker.init(frame: CGRect(x: 10, y: 30, width: alertView.view.frame.size.width - 40, height: 216) )\n-        \n-        datePickerView?.datePickerMode = .countDownTimer\n-        \n-        \n-        let dateFormatter = DateFormatter()\n-        dateFormatter.dateFormat = \"HH:mm\"\n-        \n-        datePickerView?.date = dateFormatter.date(from: \"00:00\")!\n-        \n-        alertView.view.addSubview(datePickerView!)\n-        \n-        let action =   UIAlertAction(title: kActionSheetDoneButtonTitle, style: UIAlertAction.Style.default, handler: {\n-            action in\n-            \n-            let calender:Calendar? = Calendar.current\n-            \n-            if Utilities.isValidValue(someObject: self.datePickerView?.date as AnyObject? )  {\n-                \n-                let dateComponent = calender?.dateComponents([.hour, .minute], from: (self.datePickerView?.date)!)\n-                \n-                \n-                // title =  hour : minute,  if hour < 10, hour =  \"0\" + hour ,if minute < 10, minute =  \"0\" + minute\n-                \n-                let title: String! = (((dateComponent?.hour)! as Int) < 10 ? \"0\\((dateComponent?.hour)! as Int)\" : \"\\((dateComponent?.hour)! as Int)\") + \":\"\n-                    \n-                    + (((dateComponent?.minute)! as Int) < 10 ? \"0\\((dateComponent?.minute)! as Int)\" : \"\\((dateComponent?.minute)! as Int)\")\n-                \n-                self.buttonLeadTime?.setTitle(title!, for: .normal)\n-                \n-                self.user.settings?.leadTime = title\n-            }\n-            \n-        })\n-        let actionCancel =   UIAlertAction(title: kActionSheetCancelButtonTitle, style: UIAlertAction.Style.default, handler: {\n-            action in\n-            \n-        })\n-        \n-        alertView.addAction(action)\n-        alertView.addAction(actionCancel)\n-        present(alertView, animated: true, completion: nil)\n-        \n+      } else {\n+        let leftController = (\n+          self.slideMenuController()?.leftViewController as? LeftMenuViewController\n+        )!\n+        leftController.changeViewController(.studyList)\n+        leftController.createLeftmenuItems()\n+      }\n+\n     }\n-    \n-    \n-    /**\n-     \n-     Signout Button Clicked\n-     \n-     @param sender  Accepts UIButton Object\n-     \n-     */\n-    @IBAction func buttonActionSignOut(_ sender: UIButton) {\n-        \n-        UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(kSignOutText, comment: \"\"), errorMessage: NSLocalizedString(kAlertMessageForSignOut, comment: \"\"), errorAlertActionTitle: NSLocalizedString(kSignOutText, comment: \"\"),\n-                                                             errorAlertActionTitle2: NSLocalizedString(kTitleCancel, comment: \"\"), viewControllerUsed: self,\n-                                                             action1: {\n-                                                                \n-                                                                self.sendRequestToSignOut()\n-                                                                \n-                                                                \n-        },\n-                                                             action2: {\n-                                                                \n-        })\n-        \n+  }\n+\n+  /// Se tInitial Date sets lead Time.\n+  func setInitialDate() {\n+\n+    if user.settings != nil && Utilities.isValidValue(\n+      someObject: user.settings?.leadTime as AnyObject?) {\n+      self.buttonLeadTime?.setTitle(user.settings?.leadTime, for: .normal)\n+    } else {\n+     // Settings/LeadTime is null\n     }\n-    \n-    \n-    /**\n-     \n-     Delete Account clicked\n-     \n-     @param sender  Accepts UIButton Object\n-     \n-     */\n-    @IBAction func buttonActionDeleteAccount(_ sender: UIButton) {\n-      \n-        if (Gateway.instance.studies?.count)! > 0 {\n-            let studies = Gateway.instance.studies\n-            var joinedStudies:[Study] = []\n-            if Utilities.isStandaloneApp() {\n-                let standaloneStudyId = Utilities.standaloneStudyId()\n-                joinedStudies = studies?.filter({($0.userParticipateState.status == .inProgress || $0.userParticipateState.status == .completed) && ($0.studyId == standaloneStudyId)}) ?? []\n-            }\n-            else {\n-                joinedStudies = studies?.filter({$0.userParticipateState.status == .inProgress || $0.userParticipateState.status == .completed}) ?? []\n-            }\n-\n-            if joinedStudies.count != 0 {\n-                self.performSegue(withIdentifier: \"confirmationSegue\", sender: joinedStudies)\n-            }\n-            else {\n-                \n-                var infoDict: NSDictionary?\n-                if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n-                    infoDict = NSDictionary(contentsOfFile: path)\n-                }\n-                let navTitle = infoDict![\"ProductTitleName\"] as! String\n-                \n-                var descriptionText =  kDeleteAccountConfirmationMessage\n-                descriptionText = descriptionText.replacingOccurrences(of: \"#APPNAME#\", with: navTitle)\n-                \n-                UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(kTitleDeleteAccount, comment: \"\"), errorMessage: NSLocalizedString(descriptionText, comment: \"\"), errorAlertActionTitle: NSLocalizedString(kTitleDeleteAccount, comment: \"\"),\n-                                                                     errorAlertActionTitle2: NSLocalizedString(kTitleCancel, comment: \"\"), viewControllerUsed: self,\n-                                                                     action1: {\n-\n-                                                                        self.sendRequestToDeleteAccount()\n-\n-\n-                },\n-                                                                     action2: {\n-\n-                })\n-            }\n-        }\n-        \n-        \n-        \n+    self.title = NSLocalizedString(kProfileTitleText, comment: \"\")\n+    self.isCellEditable = true\n+\n+    self.buttonLeadTime?.isUserInteractionEnabled = false\n+\n+    // 1. Create a authentication context\n+    let authenticationContext = LAContext()\n+    var error: NSError?\n+\n+    // 2. Check if the device has a fingerprint sensor\n+    // If not, show the user an alert view and bail out!\n+    guard\n+      authenticationContext.canEvaluatePolicy(\n+        .deviceOwnerAuthenticationWithBiometrics, error: &error)\n+    else {\n+      return\n     }\n-    \n-    \n-// MARK:- Utility Methods\n-    \n-    /**\n-     \n-     Dismiss key board when clicked on Background\n-     \n-     */\n-    @objc func dismissKeyboard(){\n-        self.view.endEditing(true)\n+\n+    var passcodeDict: [String: Any] = (tableViewRowDetails?[3] as? [String: Any])!\n+\n+    guard\n+      let keychainPasscodeDict = try? ORKKeychainWrapper.object(forKey: korkPasscode)\n+      as? [String: Any]\n+    else {\n+      return\n     }\n-    \n-    \n-    /**\n-     \n-     Api Call to SignOut\n-     \n-     */\n-    func sendRequestToSignOut() {\n-        UserServices().logoutUser(self)\n+\n+    var istouchIdEnabled: Bool = false\n+    if keychainPasscodeDict.count > 0 {\n+      istouchIdEnabled = keychainPasscodeDict[ktouchid] as? Bool ?? false\n     }\n-    \n-    \n-    /**\n- \n-     Api call to delete account\n-     \n-     */\n-    func sendRequestToDeleteAccount(){\n-        let studies: Array<String> = []\n-        UserServices().deActivateAccount(listOfStudyIds: studies, delegate: self)\n+\n+    var touchLabelText = kUsePasscodeToAccessApp\n+    if istouchIdEnabled {\n+      if authenticationContext.biometryType == .faceID {\n+        touchLabelText = kUseFaceIdOrPasscode\n+      } else if authenticationContext.biometryType == .touchID {\n+        touchLabelText = kUseTouchIdOrPasscode\n+      }\n     }\n-    \n-    \n-    /**\n-     \n-     SignOut Response handler for slider menu setup\n-     \n-     */\n-    func handleSignoutResponse(){\n-        debugPrint(\"singout\")\n-        \n-        if ORKPasscodeViewController.isPasscodeStoredInKeychain(){\n+    passcodeDict[kLabelName] = touchLabelText\n+    tableViewRowDetails?.replaceObject(at: 3, with: passcodeDict)\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 713}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcxNzQ0Mg==", "bodyText": "nit: remove blank line", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391717442", "createdAt": "2020-03-12T15:52:46Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/EligibilityUI/EligibilityStepViewController.swift", "diffHunk": "@@ -1,252 +1,222 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import ResearchKit\n import IQKeyboardManagerSwift\n-\n+import ResearchKit\n+import UIKit\n \n let kStudyWithStudyId = \"Study with StudyId\"\n let kTitleOK = \"OK\"\n \n class EligibilityStep: ORKStep {\n-    var type: String?\n-    \n-    func showsProgress() -> Bool {\n-        return false\n-    }\n+  var type: String?\n+\n+  func showsProgress() -> Bool {\n+    return false\n+  }\n }\n \n+// MARK: ORKResult overriding\n+open class EligibilityTokenTaskResult: ORKResult {\n+  open var enrollmentToken: String = \"\"\n+\n+  override open var description: String {\n+    return \"enrollmentToken:\\(enrollmentToken)\"\n+  }\n+\n+  override open var debugDescription: String {\n+    return \"enrollmentToken:\\(enrollmentToken)\"\n+  }\n+}\n \n class EligibilityStepViewController: ORKStepViewController {\n-    \n-    @IBOutlet weak var tokenTextField: UITextField!\n-    @IBOutlet weak var buttonSubmit: UIButton?\n-    @IBOutlet weak var labelDescription: UILabel?\n-    var descriptionText: String?\n-    \n-    var taskResult: EligibilityTokenTaskResult = EligibilityTokenTaskResult(identifier: kFetalKickCounterStepDefaultIdentifier)\n-    \n-    // MARK: ORKStepViewController Intitialization Methods\n-    \n-    override init(step: ORKStep?) {\n-        super.init(step: step)\n-    }\n-    \n-    required init?(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-    }\n-    \n-    override func hasNextStep() -> Bool {\n-        super.hasNextStep()\n-        return true\n-    }\n-    \n-    override func goForward(){\n-        \n-        super.goForward()\n-        \n-    }\n-    \n-    override var result: ORKStepResult? {\n-        \n-        let orkResult = super.result\n-        orkResult?.results = [self.taskResult]\n-        return orkResult\n-        \n-    }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        buttonSubmit?.layer.borderColor =   kUicolorForButtonBackground\n-        \n-        if (self.descriptionText?.count)! > 0 {\n-            labelDescription?.text = self.descriptionText\n-        }\n-        \n-        if let step = step as? EligibilityStep {\n-            step.type = \"token\"\n-        }\n-        \n-       //Delete this\n-        //tokenTextField.text = \"YGELWVCCX\"\n-    }\n \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-   \n-        let footerView = ORKNavigationContainerView()\n-        footerView.translatesAutoresizingMaskIntoConstraints = false\n-        footerView.neverHasContinueButton = true\n-        footerView.cancelButtonItem = self.cancelButtonItem\n-        footerView.skipEnabled = false\n-        self.view.addSubview(footerView)\n-        \n-        NSLayoutConstraint.activate([\n-            footerView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: 0),\n-            footerView.heightAnchor.constraint(equalToConstant: 100),\n-            footerView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor, constant: 0),\n-            footerView.trailingAnchor.constraint(equalTo: self.view.trailingAnchor, constant: 0)\n-            ])\n-    }\n-    \n-//    private func addCancelButton() {\n-//        \n-//        let button = UIButton(type: .system)\n-//        button.translatesAutoresizingMaskIntoConstraints = false\n-//        button.setTitle(\"Cancel\", for: .normal)\n-//        button.addTarget(self, action: #selector(getter: self.cancelButtonItem?.action), for: .touchUpInside)\n-//\n-//        \n-//        self.view.addSubview(button)\n-//        \n-//        NSLayoutConstraint.activate([\n-//            button.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: -100),\n-//            button.heightAnchor.constraint(equalToConstant: 40),\n-//            button.widthAnchor.constraint(equalToConstant: 90),\n-//            button.centerXAnchor.constraint(equalTo: self.view.centerXAnchor)\n-//            ])\n-//    }\n-    \n-    @objc func cancelButton(){\n-        \n-        self.dismiss(animated: true, completion: nil)\n-        \n-    }\n-    // MARK: Methods and Button Actions\n-    \n-    func showAlert(message: String) {\n-        let alert = UIAlertController(title: kErrorTitle as String,message: message as String,preferredStyle: UIAlertController.Style.alert)\n-        alert.addAction(UIAlertAction(title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n-        \n-        self.navigationController?.present(alert, animated: true, completion: nil)\n+  // MARK: - Outlets\n+  @IBOutlet weak var tokenTextField: UITextField!\n+\n+  @IBOutlet weak var buttonSubmit: UIButton?\n+  @IBOutlet weak var labelDescription: UILabel?\n+\n+  // MARK: - UI Properties\n+  var descriptionText: String?\n+\n+  var taskResult: EligibilityTokenTaskResult = EligibilityTokenTaskResult(\n+    identifier: kFetalKickCounterStepDefaultIdentifier)\n+\n+  // MARK: - ORKStepViewController Intitialization Methods\n+\n+  override init(step: ORKStep?) {\n+    super.init(step: step)\n+  }\n+\n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  override func hasNextStep() -> Bool {\n+    super.hasNextStep()\n+    return true\n+  }\n+\n+  override func goForward() {\n+    super.goForward()\n+  }\n+\n+  override var result: ORKStepResult? {\n+\n+    let orkResult = super.result\n+    orkResult?.results = [self.taskResult]\n+    return orkResult\n+\n+  }\n+\n+  // MARK: - LifeCycle\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    buttonSubmit?.layer.borderColor = kUicolorForButtonBackground\n+\n+    if (self.descriptionText?.count)! > 0 {\n+      labelDescription?.text = self.descriptionText\n     }\n-    \n-    @IBAction func buttonActionSubmit(sender: UIButton?) {\n-        \n-        self.view.endEditing(true)\n-        let token = tokenTextField.text\n-        \n-        if (token?.isEmpty) == false {\n-            \n-            LabKeyServices().verifyEnrollmentToken(studyId: (Study.currentStudy?.studyId)!, token: token!, delegate: self)\n-        }else {\n-            self.showAlert(title: kTitleMessage, message: kMessageValidToken )\n-            \n-        }\n+\n+    if let step = step as? EligibilityStep {\n+      step.type = \"token\"\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    let footerView = ORKNavigationContainerView()\n+    footerView.translatesAutoresizingMaskIntoConstraints = false\n+    footerView.neverHasContinueButton = true\n+    footerView.cancelButtonItem = self.cancelButtonItem\n+    footerView.skipEnabled = false\n+    self.view.addSubview(footerView)\n+\n+    NSLayoutConstraint.activate(\n+      [\n+        footerView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: 0),\n+        footerView.heightAnchor.constraint(equalToConstant: 100),\n+        footerView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor, constant: 0),\n+        footerView.trailingAnchor.constraint(\n+          equalTo: self.view.trailingAnchor, constant: 0)\n+      ])\n+  }\n+\n+  // MARK: - UI Utils\n+\n+  func showAlert(message: String) {\n+    let alert = UIAlertController(\n+      title: kErrorTitle as String, message: message as String,\n+      preferredStyle: UIAlertController.Style.alert)\n+    alert.addAction(\n+      UIAlertAction(\n+        title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n+\n+    self.navigationController?.present(alert, animated: true, completion: nil)\n+  }\n+\n+  // MARK: - Action\n+  @IBAction func buttonActionSubmit(sender: UIButton?) {\n+\n+    self.view.endEditing(true)\n+    let token = tokenTextField.text\n+\n+    if (token?.isEmpty) == false {\n+\n+      LabKeyServices().verifyEnrollmentToken(\n+        studyId: (Study.currentStudy?.studyId)!, token: token!, delegate: self)\n+    } else {\n+      self.showAlert(title: kTitleMessage, message: kMessageValidToken)\n+\n     }\n+  }\n+\n }\n \n // MARK: TextField Delegates\n extension EligibilityStepViewController: UITextFieldDelegate {\n-    func textFieldDidEndEditing(_ textField: UITextField) {\n-    }\n-    func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {\n-        return true\n-    }\n-    \n-    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n-        \n-        if string == \" \"{\n-            return false\n-            \n-        }else {\n-            return true\n-        }\n-    }\n-    \n-    func textFieldDidBeginEditing(_ textField: UITextField) {\n+\n+  func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {\n+    return true\n+  }\n+\n+  func textField(\n+    _ textField: UITextField, shouldChangeCharactersIn range: NSRange,\n+    replacementString string: String\n+  ) -> Bool {\n+\n+    if string == \" \" {\n+      return false\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 331}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcxNzUxOA==", "bodyText": "same here", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391717518", "createdAt": "2020-03-12T15:52:53Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/EligibilityUI/EligibilityStepViewController.swift", "diffHunk": "@@ -1,252 +1,222 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import ResearchKit\n import IQKeyboardManagerSwift\n-\n+import ResearchKit\n+import UIKit\n \n let kStudyWithStudyId = \"Study with StudyId\"\n let kTitleOK = \"OK\"\n \n class EligibilityStep: ORKStep {\n-    var type: String?\n-    \n-    func showsProgress() -> Bool {\n-        return false\n-    }\n+  var type: String?\n+\n+  func showsProgress() -> Bool {\n+    return false\n+  }\n }\n \n+// MARK: ORKResult overriding\n+open class EligibilityTokenTaskResult: ORKResult {\n+  open var enrollmentToken: String = \"\"\n+\n+  override open var description: String {\n+    return \"enrollmentToken:\\(enrollmentToken)\"\n+  }\n+\n+  override open var debugDescription: String {\n+    return \"enrollmentToken:\\(enrollmentToken)\"\n+  }\n+}\n \n class EligibilityStepViewController: ORKStepViewController {\n-    \n-    @IBOutlet weak var tokenTextField: UITextField!\n-    @IBOutlet weak var buttonSubmit: UIButton?\n-    @IBOutlet weak var labelDescription: UILabel?\n-    var descriptionText: String?\n-    \n-    var taskResult: EligibilityTokenTaskResult = EligibilityTokenTaskResult(identifier: kFetalKickCounterStepDefaultIdentifier)\n-    \n-    // MARK: ORKStepViewController Intitialization Methods\n-    \n-    override init(step: ORKStep?) {\n-        super.init(step: step)\n-    }\n-    \n-    required init?(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-    }\n-    \n-    override func hasNextStep() -> Bool {\n-        super.hasNextStep()\n-        return true\n-    }\n-    \n-    override func goForward(){\n-        \n-        super.goForward()\n-        \n-    }\n-    \n-    override var result: ORKStepResult? {\n-        \n-        let orkResult = super.result\n-        orkResult?.results = [self.taskResult]\n-        return orkResult\n-        \n-    }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        buttonSubmit?.layer.borderColor =   kUicolorForButtonBackground\n-        \n-        if (self.descriptionText?.count)! > 0 {\n-            labelDescription?.text = self.descriptionText\n-        }\n-        \n-        if let step = step as? EligibilityStep {\n-            step.type = \"token\"\n-        }\n-        \n-       //Delete this\n-        //tokenTextField.text = \"YGELWVCCX\"\n-    }\n \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-   \n-        let footerView = ORKNavigationContainerView()\n-        footerView.translatesAutoresizingMaskIntoConstraints = false\n-        footerView.neverHasContinueButton = true\n-        footerView.cancelButtonItem = self.cancelButtonItem\n-        footerView.skipEnabled = false\n-        self.view.addSubview(footerView)\n-        \n-        NSLayoutConstraint.activate([\n-            footerView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: 0),\n-            footerView.heightAnchor.constraint(equalToConstant: 100),\n-            footerView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor, constant: 0),\n-            footerView.trailingAnchor.constraint(equalTo: self.view.trailingAnchor, constant: 0)\n-            ])\n-    }\n-    \n-//    private func addCancelButton() {\n-//        \n-//        let button = UIButton(type: .system)\n-//        button.translatesAutoresizingMaskIntoConstraints = false\n-//        button.setTitle(\"Cancel\", for: .normal)\n-//        button.addTarget(self, action: #selector(getter: self.cancelButtonItem?.action), for: .touchUpInside)\n-//\n-//        \n-//        self.view.addSubview(button)\n-//        \n-//        NSLayoutConstraint.activate([\n-//            button.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: -100),\n-//            button.heightAnchor.constraint(equalToConstant: 40),\n-//            button.widthAnchor.constraint(equalToConstant: 90),\n-//            button.centerXAnchor.constraint(equalTo: self.view.centerXAnchor)\n-//            ])\n-//    }\n-    \n-    @objc func cancelButton(){\n-        \n-        self.dismiss(animated: true, completion: nil)\n-        \n-    }\n-    // MARK: Methods and Button Actions\n-    \n-    func showAlert(message: String) {\n-        let alert = UIAlertController(title: kErrorTitle as String,message: message as String,preferredStyle: UIAlertController.Style.alert)\n-        alert.addAction(UIAlertAction(title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n-        \n-        self.navigationController?.present(alert, animated: true, completion: nil)\n+  // MARK: - Outlets\n+  @IBOutlet weak var tokenTextField: UITextField!\n+\n+  @IBOutlet weak var buttonSubmit: UIButton?\n+  @IBOutlet weak var labelDescription: UILabel?\n+\n+  // MARK: - UI Properties\n+  var descriptionText: String?\n+\n+  var taskResult: EligibilityTokenTaskResult = EligibilityTokenTaskResult(\n+    identifier: kFetalKickCounterStepDefaultIdentifier)\n+\n+  // MARK: - ORKStepViewController Intitialization Methods\n+\n+  override init(step: ORKStep?) {\n+    super.init(step: step)\n+  }\n+\n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  override func hasNextStep() -> Bool {\n+    super.hasNextStep()\n+    return true\n+  }\n+\n+  override func goForward() {\n+    super.goForward()\n+  }\n+\n+  override var result: ORKStepResult? {\n+\n+    let orkResult = super.result\n+    orkResult?.results = [self.taskResult]\n+    return orkResult\n+\n+  }\n+\n+  // MARK: - LifeCycle\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    buttonSubmit?.layer.borderColor = kUicolorForButtonBackground\n+\n+    if (self.descriptionText?.count)! > 0 {\n+      labelDescription?.text = self.descriptionText\n     }\n-    \n-    @IBAction func buttonActionSubmit(sender: UIButton?) {\n-        \n-        self.view.endEditing(true)\n-        let token = tokenTextField.text\n-        \n-        if (token?.isEmpty) == false {\n-            \n-            LabKeyServices().verifyEnrollmentToken(studyId: (Study.currentStudy?.studyId)!, token: token!, delegate: self)\n-        }else {\n-            self.showAlert(title: kTitleMessage, message: kMessageValidToken )\n-            \n-        }\n+\n+    if let step = step as? EligibilityStep {\n+      step.type = \"token\"\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    let footerView = ORKNavigationContainerView()\n+    footerView.translatesAutoresizingMaskIntoConstraints = false\n+    footerView.neverHasContinueButton = true\n+    footerView.cancelButtonItem = self.cancelButtonItem\n+    footerView.skipEnabled = false\n+    self.view.addSubview(footerView)\n+\n+    NSLayoutConstraint.activate(\n+      [\n+        footerView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: 0),\n+        footerView.heightAnchor.constraint(equalToConstant: 100),\n+        footerView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor, constant: 0),\n+        footerView.trailingAnchor.constraint(\n+          equalTo: self.view.trailingAnchor, constant: 0)\n+      ])\n+  }\n+\n+  // MARK: - UI Utils\n+\n+  func showAlert(message: String) {\n+    let alert = UIAlertController(\n+      title: kErrorTitle as String, message: message as String,\n+      preferredStyle: UIAlertController.Style.alert)\n+    alert.addAction(\n+      UIAlertAction(\n+        title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n+\n+    self.navigationController?.present(alert, animated: true, completion: nil)\n+  }\n+\n+  // MARK: - Action\n+  @IBAction func buttonActionSubmit(sender: UIButton?) {\n+\n+    self.view.endEditing(true)\n+    let token = tokenTextField.text\n+\n+    if (token?.isEmpty) == false {\n+\n+      LabKeyServices().verifyEnrollmentToken(\n+        studyId: (Study.currentStudy?.studyId)!, token: token!, delegate: self)\n+    } else {\n+      self.showAlert(title: kTitleMessage, message: kMessageValidToken)\n+\n     }\n+  }\n+\n }\n \n // MARK: TextField Delegates\n extension EligibilityStepViewController: UITextFieldDelegate {\n-    func textFieldDidEndEditing(_ textField: UITextField) {\n-    }\n-    func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {\n-        return true\n-    }\n-    \n-    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n-        \n-        if string == \" \"{\n-            return false\n-            \n-        }else {\n-            return true\n-        }\n-    }\n-    \n-    func textFieldDidBeginEditing(_ textField: UITextField) {\n+\n+  func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {\n+    return true\n+  }\n+\n+  func textField(\n+    _ textField: UITextField, shouldChangeCharactersIn range: NSRange,\n+    replacementString string: String\n+  ) -> Bool {\n+\n+    if string == \" \" {\n+      return false\n+\n+    } else {\n+      return true\n     }\n-    \n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcxNzY3Ng==", "bodyText": "remove debug lines", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391717676", "createdAt": "2020-03-12T15:53:06Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/EligibilityUI/EligibilityStepViewController.swift", "diffHunk": "@@ -1,252 +1,222 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import ResearchKit\n import IQKeyboardManagerSwift\n-\n+import ResearchKit\n+import UIKit\n \n let kStudyWithStudyId = \"Study with StudyId\"\n let kTitleOK = \"OK\"\n \n class EligibilityStep: ORKStep {\n-    var type: String?\n-    \n-    func showsProgress() -> Bool {\n-        return false\n-    }\n+  var type: String?\n+\n+  func showsProgress() -> Bool {\n+    return false\n+  }\n }\n \n+// MARK: ORKResult overriding\n+open class EligibilityTokenTaskResult: ORKResult {\n+  open var enrollmentToken: String = \"\"\n+\n+  override open var description: String {\n+    return \"enrollmentToken:\\(enrollmentToken)\"\n+  }\n+\n+  override open var debugDescription: String {\n+    return \"enrollmentToken:\\(enrollmentToken)\"\n+  }\n+}\n \n class EligibilityStepViewController: ORKStepViewController {\n-    \n-    @IBOutlet weak var tokenTextField: UITextField!\n-    @IBOutlet weak var buttonSubmit: UIButton?\n-    @IBOutlet weak var labelDescription: UILabel?\n-    var descriptionText: String?\n-    \n-    var taskResult: EligibilityTokenTaskResult = EligibilityTokenTaskResult(identifier: kFetalKickCounterStepDefaultIdentifier)\n-    \n-    // MARK: ORKStepViewController Intitialization Methods\n-    \n-    override init(step: ORKStep?) {\n-        super.init(step: step)\n-    }\n-    \n-    required init?(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-    }\n-    \n-    override func hasNextStep() -> Bool {\n-        super.hasNextStep()\n-        return true\n-    }\n-    \n-    override func goForward(){\n-        \n-        super.goForward()\n-        \n-    }\n-    \n-    override var result: ORKStepResult? {\n-        \n-        let orkResult = super.result\n-        orkResult?.results = [self.taskResult]\n-        return orkResult\n-        \n-    }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        buttonSubmit?.layer.borderColor =   kUicolorForButtonBackground\n-        \n-        if (self.descriptionText?.count)! > 0 {\n-            labelDescription?.text = self.descriptionText\n-        }\n-        \n-        if let step = step as? EligibilityStep {\n-            step.type = \"token\"\n-        }\n-        \n-       //Delete this\n-        //tokenTextField.text = \"YGELWVCCX\"\n-    }\n \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-   \n-        let footerView = ORKNavigationContainerView()\n-        footerView.translatesAutoresizingMaskIntoConstraints = false\n-        footerView.neverHasContinueButton = true\n-        footerView.cancelButtonItem = self.cancelButtonItem\n-        footerView.skipEnabled = false\n-        self.view.addSubview(footerView)\n-        \n-        NSLayoutConstraint.activate([\n-            footerView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: 0),\n-            footerView.heightAnchor.constraint(equalToConstant: 100),\n-            footerView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor, constant: 0),\n-            footerView.trailingAnchor.constraint(equalTo: self.view.trailingAnchor, constant: 0)\n-            ])\n-    }\n-    \n-//    private func addCancelButton() {\n-//        \n-//        let button = UIButton(type: .system)\n-//        button.translatesAutoresizingMaskIntoConstraints = false\n-//        button.setTitle(\"Cancel\", for: .normal)\n-//        button.addTarget(self, action: #selector(getter: self.cancelButtonItem?.action), for: .touchUpInside)\n-//\n-//        \n-//        self.view.addSubview(button)\n-//        \n-//        NSLayoutConstraint.activate([\n-//            button.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: -100),\n-//            button.heightAnchor.constraint(equalToConstant: 40),\n-//            button.widthAnchor.constraint(equalToConstant: 90),\n-//            button.centerXAnchor.constraint(equalTo: self.view.centerXAnchor)\n-//            ])\n-//    }\n-    \n-    @objc func cancelButton(){\n-        \n-        self.dismiss(animated: true, completion: nil)\n-        \n-    }\n-    // MARK: Methods and Button Actions\n-    \n-    func showAlert(message: String) {\n-        let alert = UIAlertController(title: kErrorTitle as String,message: message as String,preferredStyle: UIAlertController.Style.alert)\n-        alert.addAction(UIAlertAction(title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n-        \n-        self.navigationController?.present(alert, animated: true, completion: nil)\n+  // MARK: - Outlets\n+  @IBOutlet weak var tokenTextField: UITextField!\n+\n+  @IBOutlet weak var buttonSubmit: UIButton?\n+  @IBOutlet weak var labelDescription: UILabel?\n+\n+  // MARK: - UI Properties\n+  var descriptionText: String?\n+\n+  var taskResult: EligibilityTokenTaskResult = EligibilityTokenTaskResult(\n+    identifier: kFetalKickCounterStepDefaultIdentifier)\n+\n+  // MARK: - ORKStepViewController Intitialization Methods\n+\n+  override init(step: ORKStep?) {\n+    super.init(step: step)\n+  }\n+\n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  override func hasNextStep() -> Bool {\n+    super.hasNextStep()\n+    return true\n+  }\n+\n+  override func goForward() {\n+    super.goForward()\n+  }\n+\n+  override var result: ORKStepResult? {\n+\n+    let orkResult = super.result\n+    orkResult?.results = [self.taskResult]\n+    return orkResult\n+\n+  }\n+\n+  // MARK: - LifeCycle\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    buttonSubmit?.layer.borderColor = kUicolorForButtonBackground\n+\n+    if (self.descriptionText?.count)! > 0 {\n+      labelDescription?.text = self.descriptionText\n     }\n-    \n-    @IBAction func buttonActionSubmit(sender: UIButton?) {\n-        \n-        self.view.endEditing(true)\n-        let token = tokenTextField.text\n-        \n-        if (token?.isEmpty) == false {\n-            \n-            LabKeyServices().verifyEnrollmentToken(studyId: (Study.currentStudy?.studyId)!, token: token!, delegate: self)\n-        }else {\n-            self.showAlert(title: kTitleMessage, message: kMessageValidToken )\n-            \n-        }\n+\n+    if let step = step as? EligibilityStep {\n+      step.type = \"token\"\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    let footerView = ORKNavigationContainerView()\n+    footerView.translatesAutoresizingMaskIntoConstraints = false\n+    footerView.neverHasContinueButton = true\n+    footerView.cancelButtonItem = self.cancelButtonItem\n+    footerView.skipEnabled = false\n+    self.view.addSubview(footerView)\n+\n+    NSLayoutConstraint.activate(\n+      [\n+        footerView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: 0),\n+        footerView.heightAnchor.constraint(equalToConstant: 100),\n+        footerView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor, constant: 0),\n+        footerView.trailingAnchor.constraint(\n+          equalTo: self.view.trailingAnchor, constant: 0)\n+      ])\n+  }\n+\n+  // MARK: - UI Utils\n+\n+  func showAlert(message: String) {\n+    let alert = UIAlertController(\n+      title: kErrorTitle as String, message: message as String,\n+      preferredStyle: UIAlertController.Style.alert)\n+    alert.addAction(\n+      UIAlertAction(\n+        title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n+\n+    self.navigationController?.present(alert, animated: true, completion: nil)\n+  }\n+\n+  // MARK: - Action\n+  @IBAction func buttonActionSubmit(sender: UIButton?) {\n+\n+    self.view.endEditing(true)\n+    let token = tokenTextField.text\n+\n+    if (token?.isEmpty) == false {\n+\n+      LabKeyServices().verifyEnrollmentToken(\n+        studyId: (Study.currentStudy?.studyId)!, token: token!, delegate: self)\n+    } else {\n+      self.showAlert(title: kTitleMessage, message: kMessageValidToken)\n+\n     }\n+  }\n+\n }\n \n // MARK: TextField Delegates\n extension EligibilityStepViewController: UITextFieldDelegate {\n-    func textFieldDidEndEditing(_ textField: UITextField) {\n-    }\n-    func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {\n-        return true\n-    }\n-    \n-    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n-        \n-        if string == \" \"{\n-            return false\n-            \n-        }else {\n-            return true\n-        }\n-    }\n-    \n-    func textFieldDidBeginEditing(_ textField: UITextField) {\n+\n+  func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {\n+    return true\n+  }\n+\n+  func textField(\n+    _ textField: UITextField, shouldChangeCharactersIn range: NSRange,\n+    replacementString string: String\n+  ) -> Bool {\n+\n+    if string == \" \" {\n+      return false\n+\n+    } else {\n+      return true\n     }\n-    \n+  }\n+\n }\n \n // MARK: Webservice Delegates\n extension EligibilityStepViewController: NMWebServiceDelegate {\n-    func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        \n-        self.addProgressIndicator()\n-        \n-    }\n-    \n-    func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        Logger.sharedInstance.info(\"requestname : \\(response)\")\n-        \n-        self.removeProgressIndicator()\n-        \n-        if (tokenTextField.text?.isEmpty) == false {\n-            self.taskResult.enrollmentToken = tokenTextField.text!\n-            //Storing token so that it can be used in case of ineligibility\n-            let appdelegate = UIApplication.shared.delegate as! AppDelegate\n-            appdelegate.consentToken = tokenTextField.text!\n-            \n-        }else {\n-            self.taskResult.enrollmentToken = \"\"\n-        }\n-        \n-        \n-        self.goForward()\n-    }\n-    \n-    func failedRequest(_ manager: NetworkManager, requestName: NSString, error: NSError) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        \n-        self.removeProgressIndicator()\n-        if error.localizedDescription.localizedCaseInsensitiveContains(tokenTextField.text!) {\n-            \n-            self.showAlert(message: kMessageInvalidTokenOrIfStudyDoesNotExist) //kMessageForInvalidToken\n-            \n-        }else {\n-            if error.localizedDescription.localizedCaseInsensitiveContains(kStudyWithStudyId) {\n-                \n-                self.showAlert(message: kMessageInvalidTokenOrIfStudyDoesNotExist) //kMessageForMissingStudyId\n-                \n-            }else {\n-                self.showAlert(message: error.localizedDescription)\n-            }\n-        }\n-    }\n-}\n \n-// MARK: ORKResult overriding\n+  func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n+    Logger.sharedInstance.info(\"requestname : \\(requestName)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcxNzg0Mg==", "bodyText": "please remove all debug logs", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391717842", "createdAt": "2020-03-12T15:53:22Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/EligibilityUI/EligibilityStepViewController.swift", "diffHunk": "@@ -1,252 +1,222 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import ResearchKit\n import IQKeyboardManagerSwift\n-\n+import ResearchKit\n+import UIKit\n \n let kStudyWithStudyId = \"Study with StudyId\"\n let kTitleOK = \"OK\"\n \n class EligibilityStep: ORKStep {\n-    var type: String?\n-    \n-    func showsProgress() -> Bool {\n-        return false\n-    }\n+  var type: String?\n+\n+  func showsProgress() -> Bool {\n+    return false\n+  }\n }\n \n+// MARK: ORKResult overriding\n+open class EligibilityTokenTaskResult: ORKResult {\n+  open var enrollmentToken: String = \"\"\n+\n+  override open var description: String {\n+    return \"enrollmentToken:\\(enrollmentToken)\"\n+  }\n+\n+  override open var debugDescription: String {\n+    return \"enrollmentToken:\\(enrollmentToken)\"\n+  }\n+}\n \n class EligibilityStepViewController: ORKStepViewController {\n-    \n-    @IBOutlet weak var tokenTextField: UITextField!\n-    @IBOutlet weak var buttonSubmit: UIButton?\n-    @IBOutlet weak var labelDescription: UILabel?\n-    var descriptionText: String?\n-    \n-    var taskResult: EligibilityTokenTaskResult = EligibilityTokenTaskResult(identifier: kFetalKickCounterStepDefaultIdentifier)\n-    \n-    // MARK: ORKStepViewController Intitialization Methods\n-    \n-    override init(step: ORKStep?) {\n-        super.init(step: step)\n-    }\n-    \n-    required init?(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-    }\n-    \n-    override func hasNextStep() -> Bool {\n-        super.hasNextStep()\n-        return true\n-    }\n-    \n-    override func goForward(){\n-        \n-        super.goForward()\n-        \n-    }\n-    \n-    override var result: ORKStepResult? {\n-        \n-        let orkResult = super.result\n-        orkResult?.results = [self.taskResult]\n-        return orkResult\n-        \n-    }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        buttonSubmit?.layer.borderColor =   kUicolorForButtonBackground\n-        \n-        if (self.descriptionText?.count)! > 0 {\n-            labelDescription?.text = self.descriptionText\n-        }\n-        \n-        if let step = step as? EligibilityStep {\n-            step.type = \"token\"\n-        }\n-        \n-       //Delete this\n-        //tokenTextField.text = \"YGELWVCCX\"\n-    }\n \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-   \n-        let footerView = ORKNavigationContainerView()\n-        footerView.translatesAutoresizingMaskIntoConstraints = false\n-        footerView.neverHasContinueButton = true\n-        footerView.cancelButtonItem = self.cancelButtonItem\n-        footerView.skipEnabled = false\n-        self.view.addSubview(footerView)\n-        \n-        NSLayoutConstraint.activate([\n-            footerView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: 0),\n-            footerView.heightAnchor.constraint(equalToConstant: 100),\n-            footerView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor, constant: 0),\n-            footerView.trailingAnchor.constraint(equalTo: self.view.trailingAnchor, constant: 0)\n-            ])\n-    }\n-    \n-//    private func addCancelButton() {\n-//        \n-//        let button = UIButton(type: .system)\n-//        button.translatesAutoresizingMaskIntoConstraints = false\n-//        button.setTitle(\"Cancel\", for: .normal)\n-//        button.addTarget(self, action: #selector(getter: self.cancelButtonItem?.action), for: .touchUpInside)\n-//\n-//        \n-//        self.view.addSubview(button)\n-//        \n-//        NSLayoutConstraint.activate([\n-//            button.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: -100),\n-//            button.heightAnchor.constraint(equalToConstant: 40),\n-//            button.widthAnchor.constraint(equalToConstant: 90),\n-//            button.centerXAnchor.constraint(equalTo: self.view.centerXAnchor)\n-//            ])\n-//    }\n-    \n-    @objc func cancelButton(){\n-        \n-        self.dismiss(animated: true, completion: nil)\n-        \n-    }\n-    // MARK: Methods and Button Actions\n-    \n-    func showAlert(message: String) {\n-        let alert = UIAlertController(title: kErrorTitle as String,message: message as String,preferredStyle: UIAlertController.Style.alert)\n-        alert.addAction(UIAlertAction(title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n-        \n-        self.navigationController?.present(alert, animated: true, completion: nil)\n+  // MARK: - Outlets\n+  @IBOutlet weak var tokenTextField: UITextField!\n+\n+  @IBOutlet weak var buttonSubmit: UIButton?\n+  @IBOutlet weak var labelDescription: UILabel?\n+\n+  // MARK: - UI Properties\n+  var descriptionText: String?\n+\n+  var taskResult: EligibilityTokenTaskResult = EligibilityTokenTaskResult(\n+    identifier: kFetalKickCounterStepDefaultIdentifier)\n+\n+  // MARK: - ORKStepViewController Intitialization Methods\n+\n+  override init(step: ORKStep?) {\n+    super.init(step: step)\n+  }\n+\n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  override func hasNextStep() -> Bool {\n+    super.hasNextStep()\n+    return true\n+  }\n+\n+  override func goForward() {\n+    super.goForward()\n+  }\n+\n+  override var result: ORKStepResult? {\n+\n+    let orkResult = super.result\n+    orkResult?.results = [self.taskResult]\n+    return orkResult\n+\n+  }\n+\n+  // MARK: - LifeCycle\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    buttonSubmit?.layer.borderColor = kUicolorForButtonBackground\n+\n+    if (self.descriptionText?.count)! > 0 {\n+      labelDescription?.text = self.descriptionText\n     }\n-    \n-    @IBAction func buttonActionSubmit(sender: UIButton?) {\n-        \n-        self.view.endEditing(true)\n-        let token = tokenTextField.text\n-        \n-        if (token?.isEmpty) == false {\n-            \n-            LabKeyServices().verifyEnrollmentToken(studyId: (Study.currentStudy?.studyId)!, token: token!, delegate: self)\n-        }else {\n-            self.showAlert(title: kTitleMessage, message: kMessageValidToken )\n-            \n-        }\n+\n+    if let step = step as? EligibilityStep {\n+      step.type = \"token\"\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    let footerView = ORKNavigationContainerView()\n+    footerView.translatesAutoresizingMaskIntoConstraints = false\n+    footerView.neverHasContinueButton = true\n+    footerView.cancelButtonItem = self.cancelButtonItem\n+    footerView.skipEnabled = false\n+    self.view.addSubview(footerView)\n+\n+    NSLayoutConstraint.activate(\n+      [\n+        footerView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor, constant: 0),\n+        footerView.heightAnchor.constraint(equalToConstant: 100),\n+        footerView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor, constant: 0),\n+        footerView.trailingAnchor.constraint(\n+          equalTo: self.view.trailingAnchor, constant: 0)\n+      ])\n+  }\n+\n+  // MARK: - UI Utils\n+\n+  func showAlert(message: String) {\n+    let alert = UIAlertController(\n+      title: kErrorTitle as String, message: message as String,\n+      preferredStyle: UIAlertController.Style.alert)\n+    alert.addAction(\n+      UIAlertAction(\n+        title: NSLocalizedString(kTitleOK, comment: \"\"), style: .default, handler: nil))\n+\n+    self.navigationController?.present(alert, animated: true, completion: nil)\n+  }\n+\n+  // MARK: - Action\n+  @IBAction func buttonActionSubmit(sender: UIButton?) {\n+\n+    self.view.endEditing(true)\n+    let token = tokenTextField.text\n+\n+    if (token?.isEmpty) == false {\n+\n+      LabKeyServices().verifyEnrollmentToken(\n+        studyId: (Study.currentStudy?.studyId)!, token: token!, delegate: self)\n+    } else {\n+      self.showAlert(title: kTitleMessage, message: kMessageValidToken)\n+\n     }\n+  }\n+\n }\n \n // MARK: TextField Delegates\n extension EligibilityStepViewController: UITextFieldDelegate {\n-    func textFieldDidEndEditing(_ textField: UITextField) {\n-    }\n-    func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {\n-        return true\n-    }\n-    \n-    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n-        \n-        if string == \" \"{\n-            return false\n-            \n-        }else {\n-            return true\n-        }\n-    }\n-    \n-    func textFieldDidBeginEditing(_ textField: UITextField) {\n+\n+  func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {\n+    return true\n+  }\n+\n+  func textField(\n+    _ textField: UITextField, shouldChangeCharactersIn range: NSRange,\n+    replacementString string: String\n+  ) -> Bool {\n+\n+    if string == \" \" {\n+      return false\n+\n+    } else {\n+      return true\n     }\n-    \n+  }\n+\n }\n \n // MARK: Webservice Delegates\n extension EligibilityStepViewController: NMWebServiceDelegate {\n-    func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        \n-        self.addProgressIndicator()\n-        \n-    }\n-    \n-    func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        Logger.sharedInstance.info(\"requestname : \\(response)\")\n-        \n-        self.removeProgressIndicator()\n-        \n-        if (tokenTextField.text?.isEmpty) == false {\n-            self.taskResult.enrollmentToken = tokenTextField.text!\n-            //Storing token so that it can be used in case of ineligibility\n-            let appdelegate = UIApplication.shared.delegate as! AppDelegate\n-            appdelegate.consentToken = tokenTextField.text!\n-            \n-        }else {\n-            self.taskResult.enrollmentToken = \"\"\n-        }\n-        \n-        \n-        self.goForward()\n-    }\n-    \n-    func failedRequest(_ manager: NetworkManager, requestName: NSString, error: NSError) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        \n-        self.removeProgressIndicator()\n-        if error.localizedDescription.localizedCaseInsensitiveContains(tokenTextField.text!) {\n-            \n-            self.showAlert(message: kMessageInvalidTokenOrIfStudyDoesNotExist) //kMessageForInvalidToken\n-            \n-        }else {\n-            if error.localizedDescription.localizedCaseInsensitiveContains(kStudyWithStudyId) {\n-                \n-                self.showAlert(message: kMessageInvalidTokenOrIfStudyDoesNotExist) //kMessageForMissingStudyId\n-                \n-            }else {\n-                self.showAlert(message: error.localizedDescription)\n-            }\n-        }\n-    }\n-}\n \n-// MARK: ORKResult overriding\n+  func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n+    Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n+    self.addProgressIndicator()\n+  }\n \n-open class EligibilityTokenTaskResult: ORKResult {\n-    open var enrollmentToken: String = \"\"\n-    \n-    override open var description: String {\n-        get {\n-            return \"enrollmentToken:\\(enrollmentToken)\"\n-        }\n+  func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n+    Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n+    Logger.sharedInstance.info(\"requestname : \\(String(describing: response))\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcxODk1OA==", "bodyText": "debug log, please remove", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391718958", "createdAt": "2020-03-12T15:54:59Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/Resource/GatewayResourcesListViewController.swift", "diffHunk": "@@ -1,148 +1,118 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import UIKit\n \n class GatewayResourcesListViewController: UIViewController {\n \n-    @IBOutlet var tableView: UITableView?\n-    \n-    func loadResources(){\n-        \n-        let plistPath = Bundle.main.path(forResource: \"Resources\", ofType: \".plist\", inDirectory: nil)\n-        let arrayContent = NSMutableArray.init(contentsOfFile: plistPath!)\n-        \n-        do {\n-           \n-           // let resources = response[kResources] as! Array<Dictionary<String,Any>>\n-            var listOfResources: Array<Resource>! = []\n-            for resource in arrayContent!{\n-                let resourceObj = Resource(detail: resource as! Dictionary<String, Any>)\n-                listOfResources.append(resourceObj)\n-            }\n-            \n-            //assgin to Gateway\n-            Gateway.instance.resources = listOfResources\n-            \n-            \n-            self.tableView?.reloadData()\n-        } catch {\n-            print(\"json error: \\(error.localizedDescription)\")\n-        }\n+  @IBOutlet var tableView: UITableView?\n \n+  /// Load the collection of `Resources` from plist file and assign it to Gateway.\n+  func loadResources() {\n \n-    }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n+    let plistPath = Bundle.main.path(\n+      forResource: \"Resources\", ofType: \".plist\", inDirectory: nil)\n+    let arrayContent = NSMutableArray.init(contentsOfFile: plistPath!)\n \n-        self.navigationItem.title =  NSLocalizedString(\"RESOURCES\", comment: \"\")\n-        \n-        // Do any additional setup after loading the view.\n-    }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        \n-        self.setNavigationBarItem()\n-        //WCPServices().getGatewayResources(delegate: self)\n-        self.loadResources()\n+    var listOfResources: [Resource] = []\n+    for resource in arrayContent! {\n+      let resourceObj = Resource(detail: resource as! [String: Any])\n+      listOfResources.append(resourceObj)\n     }\n+    // Assgin to Gateway\n+    Gateway.instance.resources = listOfResources\n \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n-    }\n-    \n+    self.tableView?.reloadData()\n \n-    /*\n-    // MARK: - Navigation\n+  }\n \n-    // In a storyboard-based application, you will often want to do a little preparation before navigation\n-    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n-        // Get the new view controller using segue.destinationViewController.\n-        // Pass the selected object to the new view controller.\n-    }\n-    */\n-    \n-    func handleResourcesReponse(){\n-        self.tableView?.reloadData()\n-    }\n+  // MARK: - ViewController Lifecycle.\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    self.navigationItem.title = NSLocalizedString(\"RESOURCES\", comment: \"\")\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+    self.setNavigationBarItem()\n+    self.loadResources()\n+  }\n+\n+  func handleResourcesReponse() {\n+    self.tableView?.reloadData()\n+  }\n \n }\n // MARK: TableView Data source\n extension GatewayResourcesListViewController: UITableViewDataSource {\n-    \n-    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n-        return (Gateway.instance.resources?.count)!\n-    }\n-    \n-    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n-        \n-        //let tableViewData = tableViewRowDetails?.object(at: indexPath.row) as! NSDictionary\n-        \n-        let cell = tableView.dequeueReusableCell(withIdentifier: \"resourcesCell\", for: indexPath) as! ResourcesListCell\n-        \n-        \n-        let resource = Gateway.instance.resources?[indexPath.row]\n-        cell.labelResourceTitle?.text = resource?.title\n-        \n-        return cell\n-    }\n+\n+  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n+    return (Gateway.instance.resources?.count)!\n+  }\n+\n+  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n+\n+    let cell = tableView.dequeueReusableCell(withIdentifier: \"resourcesCell\", for: indexPath)\n+      as! ResourcesListCell\n+\n+    let resource = Gateway.instance.resources?[indexPath.row]\n+    cell.labelResourceTitle?.text = resource?.title\n+\n+    return cell\n+  }\n }\n \n // MARK: TableView Delegates\n-extension GatewayResourcesListViewController:  UITableViewDelegate {\n-    \n-    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n-        tableView.deselectRow(at: indexPath, animated: true)\n-        \n-        let resource = Gateway.instance.resources?[indexPath.row]\n-        let storyboard = UIStoryboard(name: kStudyStoryboard, bundle: nil)\n-        let resourceDetail =   storyboard.instantiateViewController(withIdentifier: \"ResourceDetailViewControllerIdentifier\") as! GatewayResourceDetailViewController\n-        resourceDetail.resource = resource\n-        self.navigationController?.pushViewController(resourceDetail, animated: true)\n-        \n-    }\n+extension GatewayResourcesListViewController: UITableViewDelegate {\n+\n+  func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n+    tableView.deselectRow(at: indexPath, animated: true)\n+\n+    let resource = Gateway.instance.resources?[indexPath.row]\n+    let storyboard = UIStoryboard(name: kStudyStoryboard, bundle: nil)\n+    let resourceDetail = storyboard.instantiateViewController(\n+      withIdentifier: \"ResourceDetailViewControllerIdentifier\")\n+      as! GatewayResourceDetailViewController\n+    resourceDetail.resource = resource\n+    self.navigationController?.pushViewController(resourceDetail, animated: true)\n+\n+  }\n }\n \n+extension GatewayResourcesListViewController: NMWebServiceDelegate {\n+  func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n+    Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n+    self.addProgressIndicator()\n+  }\n \n-extension GatewayResourcesListViewController:NMWebServiceDelegate {\n-    func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        self.addProgressIndicator()\n-    }\n-    func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName) response : \\(String(describing:response))\" )\n-        \n-        self.removeProgressIndicator()\n-        \n-        if requestName as String == WCPMethods.gatewayInfo.method.methodName {\n-            \n-            self.handleResourcesReponse()\n-            \n-        }\n-        \n-    }\n-    func failedRequest(_ manager: NetworkManager, requestName: NSString, error: NSError) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        self.removeProgressIndicator()\n-        \n+  func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n+    Logger.sharedInstance.info(\n+      \"requestname : \\(requestName) response : \\(String(describing: response))\")\n+\n+    self.removeProgressIndicator()\n+\n+    if requestName as String == WCPMethods.gatewayInfo.method.methodName {\n+      self.handleResourcesReponse()\n     }\n+  }\n+\n+  func failedRequest(_ manager: NetworkManager, requestName: NSString, error: NSError) {\n+    Logger.sharedInstance.info(\"requestname : \\(requestName)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczNTE5Mg==", "bodyText": "please remove debug logs", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391735192", "createdAt": "2020-03-12T16:19:41Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/SlideMenu/LeftMenuViewController.swift", "diffHunk": "@@ -33,478 +31,549 @@ let kLeftMenuCellSubTitleValue = \"Sign up\"\n let kAlertMessageReachoutText = \"This feature will be available in the next sprint.\"\n \n let kAlertMessageForSignOut = \"Are you sure you want to sign out?\"\n-let kAlertMessageSignOutSync = \"Are you sure you want to sign out? Incomplete activities and activities completed while offline must be re-started when you next sign in.\"\n+let kAlertMessageSignOutSync\n+  = \"Are you sure you want to sign out? Incomplete activities and activities completed while offline must be re-started when you next sign in.\"\n \n let kAlertSignOutLaterTitle = \"Sign Out later\"\n \n-// MARK:Segue Identifiers\n+// MARK: Segue Identifiers\n let kLoginStoryboardIdentifier = \"Login\"\n \n-\n enum LeftMenu: Int {\n-    case studyList = 0\n-    case resources\n-    case profile_reachOut\n-    case reachOut_signIn\n-    case signup\n+  case studyList = 0\n+  case resources\n+  case profile_reachOut\n+  case reachOut_signIn\n+  case signup\n }\n \n-\n protocol LeftMenuProtocol: class {\n-    func changeViewController(_ menu: LeftMenu)\n+  func changeViewController(_ menu: LeftMenu)\n }\n \n class LeftMenuViewController: UIViewController, LeftMenuProtocol {\n-    \n-    @IBOutlet weak var tableView: UITableView!\n-    @IBOutlet weak var labelVersion: UILabel!\n-    @IBOutlet weak var labelProductName: UILabel!\n-    @IBOutlet weak var tableHeaderView: UIView!\n-    @IBOutlet weak var tableFooterView: UIView!\n-    @IBOutlet weak var buttonSignOut: UIButton?\n-    \n-    var menus: [[String: Any]] = [ [\"menuTitle\": \"Home\",\n-                   \"iconName\": \"home_menu1-1\",\n-                   \"menuType\": LeftMenu.studyList],\n-                  \n-                  [\"menuTitle\": \"Resources\",\n-                   \"iconName\": \"resources_menu1\",\n-                   \"menuType\": LeftMenu.resources],\n+\n+  // MARK: - Outlets\n+  @IBOutlet weak var tableView: UITableView!\n+\n+  @IBOutlet weak var labelVersion: UILabel!\n+  @IBOutlet weak var labelProductName: UILabel!\n+  @IBOutlet weak var tableHeaderView: UIView!\n+  @IBOutlet weak var tableFooterView: UIView!\n+  @IBOutlet weak var buttonSignOut: UIButton?\n+\n+  // MARK: - Properties\n+  lazy var menus: [[String: Any]] = [\n+    [\n+      \"menuTitle\": \"Home\",\n+      \"iconName\": \"home_menu1-1\",\n+      \"menuType\": LeftMenu.studyList\n+    ],\n+\n+    [\n+      \"menuTitle\": \"Resources\",\n+      \"iconName\": \"resources_menu1\",\n+      \"menuType\": LeftMenu.resources\n     ]\n-    // standalone\n-    var studyTabBarController: UITabBarController!\n-    var studyHomeViewController: UINavigationController!\n-    \n-    // Gateway & standalone\n-    var studyListViewController: UINavigationController!\n-    var notificationController: UIViewController!\n-    var resourcesViewController: UINavigationController!\n-    var profileviewController: UIViewController!\n-    var nonMenuViewController: UIViewController!\n-    var reachoutViewController: UINavigationController!\n-    var signInViewController: UINavigationController!\n-    var signUpViewController: UINavigationController!\n-    \n-    required init?(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-    }\n-    \n-// MARK:- ViewController Lifecycle\n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        self.view.isHidden = true\n-        self.createLeftmenuItems()\n-        \n-        var infoDict: NSDictionary?\n-        if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n-            infoDict = NSDictionary(contentsOfFile: path)\n-        }\n-        let navTitle = infoDict![\"ProductTitleName\"] as! String\n-        labelProductName.text = navTitle\n-        \n-        self.tableView.separatorColor = UIColor(red: 224/255, green: 224/255, blue: 224/255, alpha: 1.0)\n-        \n-        if Utilities.isStandaloneApp() {\n-            setupStandaloneMenu()\n-        } else {\n-            setupGatewayMenu()\n-        }\n-        \n-        self.labelVersion.text = \"V\" + \"\\(Utilities.getAppVersion())\"\n-    }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-    }\n-    \n-    override func viewDidAppear(_ animated: Bool) {\n-        super.viewDidAppear(animated)\n-        self.view.isHidden = false\n-    }\n-    \n-    \n-    final private func setupGatewayMenu(){\n-        \n-        let storyboard = UIStoryboard(name: kStoryboardIdentifierGateway, bundle: nil)\n-        \n-        self.studyListViewController = (storyboard.instantiateViewController(withIdentifier: String(describing: StudyListViewController.classForCoder())) as? UINavigationController)!\n-        \n-        self.notificationController = (storyboard.instantiateViewController(withIdentifier:  String(describing: NotificationViewController.classForCoder())) as? UINavigationController)!\n-        \n-        self.resourcesViewController = (storyboard.instantiateViewController(withIdentifier:  String(describing: GatewayResourcesListViewController.classForCoder())) as? UINavigationController)!\n-        \n-        self.profileviewController = (storyboard.instantiateViewController(withIdentifier:  String(describing: ProfileViewController.classForCoder())) as? UINavigationController)!\n-        \n-        self.reachoutViewController = (storyboard.instantiateViewController(withIdentifier:  String(describing: ReachoutOptionsViewController.classForCoder())) as? UINavigationController)!\n-        \n-    }\n-    \n-    final private func setupStandaloneMenu(){\n-        \n-        let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n-        /*for standalone*/\n-        self.studyTabBarController = studyStoryBoard.instantiateViewController(withIdentifier: kStudyDashboardTabbarControllerIdentifier) as! StudyDashboardTabbarViewController\n-        \n-        let storyboard = UIStoryboard(name: kStoryboardIdentifierGateway, bundle: nil)\n-        \n-        self.studyListViewController = storyboard.instantiateViewController(withIdentifier: String(describing: StudyListViewController.classForCoder())) as? UINavigationController\n-        \n-        \n-        self.studyHomeViewController = studyStoryBoard.instantiateViewController(withIdentifier: String(describing: \"StudyHomeNavigationController\")) as? UINavigationController //for standalone\n-        \n-        self.notificationController = storyboard.instantiateViewController(withIdentifier:  String(describing: NotificationViewController.classForCoder())) as? UINavigationController\n-        \n-        self.resourcesViewController = storyboard.instantiateViewController(withIdentifier:  String(describing: GatewayResourcesListViewController.classForCoder())) as? UINavigationController\n-        \n-        self.profileviewController = storyboard.instantiateViewController(withIdentifier:  String(describing: ProfileViewController.classForCoder())) as? UINavigationController\n-        \n-        self.reachoutViewController = storyboard.instantiateViewController(withIdentifier:  String(describing: ReachoutOptionsViewController.classForCoder())) as? UINavigationController\n-        \n+  ]\n+\n+  /// Standalone\n+  var studyTabBarController: UITabBarController!\n+\n+  var studyHomeViewController: UINavigationController!\n+\n+  /// Gateway & standalone\n+  var studyListViewController: UINavigationController!\n+\n+  var notificationController: UIViewController!\n+  var resourcesViewController: UINavigationController!\n+  var profileviewController: UIViewController!\n+  var nonMenuViewController: UIViewController!\n+  var reachoutViewController: UINavigationController!\n+  var signInViewController: UINavigationController!\n+  var signUpViewController: UINavigationController!\n+\n+  var shouldAllowToGiveFeedback = true\n+\n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  // MARK: - ViewController Lifecycle\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    self.view.isHidden = true\n+\n+    let branding = Utilities.getBrandingDetails()\n+    shouldAllowToGiveFeedback = branding![\"AllowFeedback\"] as! Bool\n+    self.createLeftmenuItems()\n+\n+    var infoDict: NSDictionary?\n+    if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n+      infoDict = NSDictionary(contentsOfFile: path)\n     }\n-    \n-    \n-    \n-    /**\n-     Used to create Login controller for new user using SignInViewController\n-     and SignUpViewController\n-     */\n-    func createControllersForAnonymousUser(){\n-        \n-        let loginStoryBoard = UIStoryboard(name: kLoginStoryboardIdentifier, bundle: nil)\n-        let signInController = (loginStoryBoard.instantiateViewController(withIdentifier:  String(describing: SignInViewController.classForCoder())) as? SignInViewController)!\n-        self.signInViewController = UINavigationController(rootViewController: signInController)\n-        self.signInViewController.navigationBar.barStyle = .default\n-         self.signInViewController.navigationBar.isTranslucent = false\n-        \n-        let signUpController = (loginStoryBoard.instantiateViewController(withIdentifier:  String(describing: SignUpViewController.classForCoder())) as? SignUpViewController)!\n-        self.signUpViewController = UINavigationController(rootViewController: signUpController)\n-        self.signUpViewController.navigationBar.barStyle = .default\n-        self.signUpViewController.navigationBar.isTranslucent = false\n+    let navTitle = infoDict![\"ProductTitleName\"] as! String\n+    labelProductName.text = navTitle\n+\n+    self.tableView.separatorColor = UIColor(red: 224/255, green: 224/255, blue: 224/255, alpha: 1.0)\n+\n+    if Utilities.isStandaloneApp() {\n+      setupStandaloneMenu()\n+    } else {\n+      setupGatewayMenu()\n     }\n-    \n-\n-    /**\n-     Used to create Left menu items\n-     */\n-    func createLeftmenuItems(){\n-        \n-        self.createControllersForAnonymousUser()\n-        \n-        let user = User.currentUser\n-        \n-        menus = [ [\"menuTitle\": \"Home\",\n-                   \"iconName\": \"home_menu1-1\",\n-            \"menuType\": LeftMenu.studyList]\n-        ]\n-        \n-        if !Utilities.isStandaloneApp() {\n-            \n-            menus.append([\"menuTitle\": \"Resources\",\n-             \"iconName\": \"resources_menu1\",\n-                \"menuType\": LeftMenu.resources])\n-        }\n-        \n-        if user.userType == .FDAUser {\n-            menus.append([\"menuTitle\": \"My Account\",\n-                          \"iconName\": \"profile_menu1\",\n-                \"menuType\": LeftMenu.profile_reachOut])\n-            menus.append([\"menuTitle\": \"Reach Out\",\n-                          \"iconName\": \"reachout_menu1\",\n-                \"menuType\": LeftMenu.reachOut_signIn])\n-           \n-            self.buttonSignOut?.isHidden = false\n-        }\n-        else{\n-            menus.append([\"menuTitle\": \"Reach Out\",\n-                          \"iconName\": \"reachout_menu1\",\n-                \"menuType\": LeftMenu.profile_reachOut])\n-\n-            menus.append([\"menuTitle\": \"Sign In\",\n-                          \"iconName\": \"signin_menu1\",\n-                \"menuType\": LeftMenu.reachOut_signIn])\n-            \n-            menus.append([\"menuTitle\": \"New User?\",\n-                          \"iconName\":\"newuser_menu1\",\n-                          \"subTitle\": \"Sign up\",\n-                \"menuType\": LeftMenu.signup])\n-             self.buttonSignOut?.isHidden = true\n-        }\n-        \n-        // Setting proportion height of the header and footer view\n-        var height: CGFloat? = 0.0\n-        height =  (UIScreen.main.bounds.size.height -  CGFloat(menus.count * 70))/2\n-        \n-        self.tableHeaderView.frame.size = CGSize(width: self.tableHeaderView!.frame.size.width, height: height!)\n-        self.tableFooterView.frame.size = CGSize(width: self.tableFooterView!.frame.size.width, height: height!)\n-        self.tableView.frame.size = CGSize(width: self.tableView.frame.width, height: UIScreen.main.bounds.size.height  )\n-        \n-        self.tableView.reloadData()\n-        \n+\n+    self.labelVersion.text = \"V\" + \"\\(Utilities.getAppVersion())\"\n+  }\n+\n+  override func viewDidAppear(_ animated: Bool) {\n+    super.viewDidAppear(animated)\n+    self.view.isHidden = false\n+  }\n+\n+  final private func setupGatewayMenu() {\n+\n+    let storyboard = UIStoryboard(name: kStoryboardIdentifierGateway, bundle: nil)\n+\n+    self.studyListViewController = (\n+      storyboard.instantiateViewController(\n+        withIdentifier: String(describing: StudyListViewController.classForCoder()))\n+        as? UINavigationController\n+    )!\n+\n+    self.notificationController = (\n+      storyboard.instantiateViewController(\n+        withIdentifier: String(describing: NotificationViewController.classForCoder()))\n+        as? UINavigationController\n+    )!\n+\n+    self.resourcesViewController = (\n+      storyboard.instantiateViewController(\n+        withIdentifier: String(\n+          describing: GatewayResourcesListViewController.classForCoder()))\n+        as? UINavigationController\n+    )!\n+\n+    self.profileviewController = (\n+      storyboard.instantiateViewController(\n+        withIdentifier: String(describing: ProfileViewController.classForCoder()))\n+        as? UINavigationController\n+    )!\n+\n+    self.reachoutViewController = (\n+      storyboard.instantiateViewController(\n+        withIdentifier: String(describing: ReachoutOptionsViewController.classForCoder()))\n+        as? UINavigationController\n+    )!\n+\n+  }\n+\n+  // MARK: - UI Utils\n+\n+  /// This method will setup the Menu in case of Standalone app.\n+  final private func setupStandaloneMenu() {\n+\n+    let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n+    // for standalone\n+    self.studyTabBarController = studyStoryBoard.instantiateViewController(\n+      withIdentifier: kStudyDashboardTabbarControllerIdentifier)\n+      as! StudyDashboardTabbarViewController\n+\n+    let storyboard = UIStoryboard(name: kStoryboardIdentifierGateway, bundle: nil)\n+\n+    self.studyListViewController = storyboard.instantiateViewController(\n+      withIdentifier: String(describing: StudyListViewController.classForCoder()))\n+      as? UINavigationController\n+\n+    self.studyHomeViewController = studyStoryBoard.instantiateViewController(\n+      withIdentifier: String(describing: \"StudyHomeNavigationController\"))\n+      as? UINavigationController  // for standalone\n+\n+    self.notificationController = storyboard.instantiateViewController(\n+      withIdentifier: String(describing: NotificationViewController.classForCoder()))\n+      as? UINavigationController\n+\n+    self.resourcesViewController = storyboard.instantiateViewController(\n+      withIdentifier: String(describing: GatewayResourcesListViewController.classForCoder()))\n+      as? UINavigationController\n+\n+    self.profileviewController = storyboard.instantiateViewController(\n+      withIdentifier: String(describing: ProfileViewController.classForCoder()))\n+      as? UINavigationController\n+\n+    self.reachoutViewController = storyboard.instantiateViewController(\n+      withIdentifier: String(describing: ReachoutOptionsViewController.classForCoder()))\n+      as? UINavigationController\n+\n+  }\n+\n+  /// Used to create Login controller for new user using SignInViewController and SignUpViewController.\n+  func createControllersForAnonymousUser() {\n+\n+    let loginStoryBoard = UIStoryboard(name: kLoginStoryboardIdentifier, bundle: nil)\n+    let signInController = (\n+      loginStoryBoard.instantiateViewController(\n+        withIdentifier: String(describing: SignInViewController.classForCoder()))\n+        as? SignInViewController\n+    )!\n+    self.signInViewController = UINavigationController(rootViewController: signInController)\n+    self.signInViewController.navigationBar.barStyle = .default\n+    self.signInViewController.navigationBar.isTranslucent = false\n+\n+    let signUpController = (\n+      loginStoryBoard.instantiateViewController(\n+        withIdentifier: String(describing: SignUpViewController.classForCoder()))\n+        as? SignUpViewController\n+    )!\n+    self.signUpViewController = UINavigationController(rootViewController: signUpController)\n+    self.signUpViewController.navigationBar.barStyle = .default\n+    self.signUpViewController.navigationBar.isTranslucent = false\n+  }\n+\n+  /// Used to create Left menu items.\n+  func createLeftmenuItems() {\n+\n+    self.createControllersForAnonymousUser()\n+\n+    let user = User.currentUser\n+\n+    menus = [\n+      [\n+        \"menuTitle\": \"Home\",\n+        \"iconName\": \"home_menu1-1\",\n+        \"menuType\": LeftMenu.studyList\n+      ]\n+    ]\n+\n+    if !Utilities.isStandaloneApp() {\n+\n+      menus.append(\n+        [\n+          \"menuTitle\": \"Resources\",\n+          \"iconName\": \"resources_menu1\",\n+          \"menuType\": LeftMenu.resources\n+        ])\n     }\n-    \n-    /**\n-     Used to set the initial data for new user\n-     */\n-    func setInitialData()  {\n-        \n-        let user = User.currentUser\n-        if user.userType == .FDAUser {\n-            menus.append([\"menuTitle\": \"My Account\",\n-                          \"iconName\": \"profile_menu1\"])\n-            self.tableView.tableFooterView?.isHidden = false\n-        }\n-        else{\n-            menus.append([\"menuTitle\": \"Sign In\",\n-                          \"iconName\": \"signin_menu1\"])\n-            \n-            menus.append([\"menuTitle\": \"New User?\",\n-                          \"iconName\": \"newuser_menu1\",\n-                          \"subTitle\": \"Sign up\"])\n-            self.tableView.tableFooterView?.isHidden = true\n-        }\n-        \n-        // Setting proportion height of the header and footer view\n-        let height = UIScreen.main.bounds.size.height  * (220.0 / 667.0) //calculate new height\n-        self.tableView.tableHeaderView?.frame.size = CGSize(width: self.tableView.tableHeaderView!.frame.size.width, height: height)\n-        self.tableView.tableFooterView?.frame.size = CGSize(width: self.tableView.tableFooterView!.frame.size.width, height: height)\n-        self.tableView.frame.size = CGSize(width: self.tableView.frame.width, height: UIScreen.main.bounds.size.height)\n-        self.tableView.reloadData()\n+\n+    if user.userType == .FDAUser {\n+      menus.append(\n+        [\n+          \"menuTitle\": \"My Account\",\n+          \"iconName\": \"profile_menu1\",\n+          \"menuType\": LeftMenu.profile_reachOut\n+        ])\n+\n+      if shouldAllowToGiveFeedback {\n+        menus.append(\n+          [\n+            \"menuTitle\": \"Reach Out\",\n+            \"iconName\": \"reachout_menu1\",\n+            \"menuType\": LeftMenu.reachOut_signIn\n+          ])\n+      }\n+\n+      self.buttonSignOut?.isHidden = false\n+    } else {\n+      if shouldAllowToGiveFeedback {\n+        menus.append(\n+          [\n+            \"menuTitle\": \"Reach Out\",\n+            \"iconName\": \"reachout_menu1\",\n+            \"menuType\": LeftMenu.profile_reachOut\n+          ])\n+      }\n+\n+      menus.append(\n+        [\n+          \"menuTitle\": \"Sign In\",\n+          \"iconName\": \"signin_menu1\",\n+          \"menuType\": LeftMenu.reachOut_signIn\n+        ])\n+\n+      menus.append(\n+        [\n+          \"menuTitle\": \"New User?\",\n+          \"iconName\": \"newuser_menu1\",\n+          \"subTitle\": \"Sign up\",\n+          \"menuType\": LeftMenu.signup\n+        ])\n+      self.buttonSignOut?.isHidden = true\n     }\n-    \n-    \n-    /**\n-     Used to change the view controller when clicked from the left menu\n-     @param menu    Accepts the data from enum LeftMenu\n-     */\n-    func changeViewController(_ menu: LeftMenu) {\n-        \n-        let isStandalone = Utilities.isStandaloneApp()\n-        \n-        switch menu {\n-        case .studyList:\n-            \n-            if isStandalone {\n-                if Study.currentStudy?.userParticipateState.status == .inProgress {\n-                     self.slideMenuController()?.changeMainViewController(self.studyTabBarController, close: true)\n-                }\n-                else {\n-                    self.slideMenuController()?.changeMainViewController(self.studyHomeViewController, close: true)\n-                }\n-                \n-               \n-            } else {\n-                self.slideMenuController()?.changeMainViewController(self.studyListViewController, close: true)\n-            }\n-            \n-            \n-        case .resources:\n-            self.slideMenuController()?.changeMainViewController(self.resourcesViewController, close: true)\n-            \n-        case .profile_reachOut:\n-            \n-            if User.currentUser.userType == .FDAUser {\n-                self.slideMenuController()?.changeMainViewController(self.profileviewController, close: true)\n-                \n-            }else {\n-                // go to ReachOut screen\n-                self.slideMenuController()?.changeMainViewController(self.reachoutViewController, close: true)\n-            }\n-            \n-        case .reachOut_signIn:\n-            if User.currentUser.userType == .FDAUser {\n-                // go to reach out\n-                self.slideMenuController()?.changeMainViewController(self.reachoutViewController, close: true)\n-                \n-            }else {\n-                \n-                // go sign in\n-                self.slideMenuController()?.changeMainViewController(self.signInViewController, close: true)\n-            }\n-        case .signup:\n-            self.slideMenuController()?.changeMainViewController(self.signUpViewController, close: true)\n-            \n-            \n-        }\n+\n+    // Setting proportion height of the header and footer view\n+    var height: CGFloat? = 0.0\n+    height = (UIScreen.main.bounds.size.height - CGFloat(menus.count * 70))/2\n+\n+    self.tableHeaderView.frame.size = CGSize(\n+      width: self.tableHeaderView!.frame.size.width, height: height!)\n+    self.tableFooterView.frame.size = CGSize(\n+      width: self.tableFooterView!.frame.size.width, height: height!)\n+    self.tableView.frame.size = CGSize(\n+      width: self.tableView.frame.width, height: UIScreen.main.bounds.size.height)\n+\n+    self.tableView.reloadData()\n+\n+  }\n+\n+  /// Used to set the initial data for new user\n+  func setInitialData() {\n+\n+    let user = User.currentUser\n+    if user.userType == .FDAUser {\n+      menus.append(\n+        [\n+          \"menuTitle\": \"My Account\",\n+          \"iconName\": \"profile_menu1\"\n+        ])\n+      self.tableView.tableFooterView?.isHidden = false\n+    } else {\n+      menus.append(\n+        [\n+          \"menuTitle\": \"Sign In\",\n+          \"iconName\": \"signin_menu1\"\n+        ])\n+\n+      menus.append(\n+        [\n+          \"menuTitle\": \"New User?\",\n+          \"iconName\": \"newuser_menu1\",\n+          \"subTitle\": \"Sign up\"\n+        ])\n+      self.tableView.tableFooterView?.isHidden = true\n     }\n-    \n-    \n-// MARK:- Button Action\n-    \n-    /**\n-     Signout button clicked\n-     @param sender    Accepts UIButton Object\n-     */\n-    @IBAction func buttonActionSignOut(_ sender: UIButton) {\n-        \n-     \n-        \n-        DBHandler.isDataAvailableToSync { (available) in\n-            if(available){\n-                \n-                UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(kSignOutText, comment: \"\"), errorMessage: NSLocalizedString(kAlertMessageSignOutSync, comment: \"\"), errorAlertActionTitle: NSLocalizedString(kSignOutText, comment: \"\"),\n-                                                                     errorAlertActionTitle2: NSLocalizedString(kAlertSignOutLaterTitle, comment: \"\"), viewControllerUsed: self,\n-                                                                     action1: {\n-                                                                        \n-                                                                        self.sendRequestToSignOut()\n-                                                                        \n-                },\n-                                                                     action2: {\n-                })\n-            }\n-            else {\n-                \n-                UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(kSignOutText, comment: \"\"), errorMessage: NSLocalizedString(kAlertMessageForSignOut, comment: \"\"), errorAlertActionTitle: NSLocalizedString(kSignOutText, comment: \"\"),\n-                                                                     errorAlertActionTitle2: NSLocalizedString(kTitleCancel, comment: \"\"), viewControllerUsed: self,\n-                                                                     action1: {\n-                                                                        \n-                                                                        self.sendRequestToSignOut()\n-                                                                        \n-                                                                        \n-                },\n-                                                                     action2: {\n-                                                                        \n-                })\n-            }\n+\n+    /// Setting proportion height of the header and footer view\n+    let height = UIScreen.main.bounds.size.height * (220.0 / 667.0)  // calculate new height\n+    self.tableView.tableHeaderView?.frame.size = CGSize(\n+      width: self.tableView.tableHeaderView!.frame.size.width, height: height)\n+    self.tableView.tableFooterView?.frame.size = CGSize(\n+      width: self.tableView.tableFooterView!.frame.size.width, height: height)\n+    self.tableView.frame.size = CGSize(\n+      width: self.tableView.frame.width, height: UIScreen.main.bounds.size.height)\n+    self.tableView.reloadData()\n+  }\n+\n+  /// Used to change the view controller when clicked from the left menu.\n+  /// - Parameter menu:  Accepts the data from enum LeftMenu\n+  func changeViewController(_ menu: LeftMenu) {\n+\n+    let isStandalone = Utilities.isStandaloneApp()\n+\n+    switch menu {\n+    case .studyList:\n+\n+      if isStandalone {\n+        if Study.currentStudy?.userParticipateState.status == .inProgress {\n+          self.slideMenuController()?.changeMainViewController(\n+            self.studyTabBarController, close: true)\n+        } else {\n+          self.slideMenuController()?.changeMainViewController(\n+            self.studyHomeViewController, close: true)\n         }\n-        \n-       \n-        \n+\n+      } else {\n+        self.slideMenuController()?.changeMainViewController(\n+          self.studyListViewController, close: true)\n+      }\n+\n+    case .resources:\n+      self.slideMenuController()?.changeMainViewController(\n+        self.resourcesViewController, close: true)\n+\n+    case .profile_reachOut:\n+\n+      if User.currentUser.userType == .FDAUser {\n+        self.slideMenuController()?.changeMainViewController(\n+          self.profileviewController, close: true)\n+\n+      } else {\n+        // go to ReachOut screen\n+        self.slideMenuController()?.changeMainViewController(\n+          self.reachoutViewController, close: true)\n+      }\n+\n+    case .reachOut_signIn:\n+      if User.currentUser.userType == .FDAUser {\n+        // go to reach out\n+        self.slideMenuController()?.changeMainViewController(\n+          self.reachoutViewController, close: true)\n+\n+      } else {\n+\n+        // go sign in\n+        self.slideMenuController()?.changeMainViewController(\n+          self.signInViewController, close: true)\n+      }\n+    case .signup:\n+      self.slideMenuController()?.changeMainViewController(\n+        self.signUpViewController, close: true)\n+\n     }\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  /// Signout button clicked.\n+  /// - Parameter sender: Instance of UIButton.\n+  @IBAction func buttonActionSignOut(_ sender: UIButton) {\n+\n+    DBHandler.isDataAvailableToSync { (available) in\n+      if available {\n \n-    \n-    /**\n-     Send the webservice request to Signout\n-     */\n-    func sendRequestToSignOut() {\n-        \n-        \n-        UserServices().logoutUser(self as NMWebServiceDelegate)\n-        \n-        \n+        UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+          NSLocalizedString(kSignOutText, comment: \"\"),\n+          errorMessage: NSLocalizedString(kAlertMessageSignOutSync, comment: \"\"),\n+          errorAlertActionTitle: NSLocalizedString(kSignOutText, comment: \"\"),\n+          errorAlertActionTitle2: NSLocalizedString(kAlertSignOutLaterTitle, comment: \"\"),\n+          viewControllerUsed: self,\n+          action1: {\n+            self.sendRequestToSignOut()\n+          },\n+          action2: {\n+            // Cancel Action.\n+          })\n+      } else {\n+\n+        UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+          NSLocalizedString(kSignOutText, comment: \"\"),\n+          errorMessage: NSLocalizedString(kAlertMessageForSignOut, comment: \"\"),\n+          errorAlertActionTitle: NSLocalizedString(kSignOutText, comment: \"\"),\n+          errorAlertActionTitle2: NSLocalizedString(kTitleCancel, comment: \"\"),\n+          viewControllerUsed: self,\n+          action1: {\n+            self.sendRequestToSignOut()\n+          },\n+          action2: {\n+            // Cancel Action.\n+          })\n+      }\n     }\n-    \n-    \n-    /**\n-     As the user is Signed out Remove passcode from the keychain\n-     */\n-    func signout(){\n-      \n-        ORKPasscodeViewController.removePasscodeFromKeychain()\n-        \n-        let ud = UserDefaults.standard\n-        ud.set(false, forKey: kPasscodeIsPending)\n-        ud.set(false, forKey: kShowNotification)\n-        ud.synchronize()\n-        \n-        StudyDashboard.instance.dashboardResponse = []\n-        let appDelegate = UIApplication.shared.delegate as! AppDelegate\n-        appDelegate.updateKeyAndInitializationVector()\n-        \n-        if !Utilities.isStandaloneApp() {\n-            self.changeViewController(.studyList)\n-            self.createLeftmenuItems()\n-        }\n-        else {\n-            UIApplication.shared.keyWindow?.removeProgressIndicatorFromWindow()\n-            self.navigationController?.popToRootViewController(animated: true)\n-        }\n-        \n-       \n+\n+  }\n+\n+  /// Call webservice to logout current user.\n+  func sendRequestToSignOut() {\n+\n+    UserServices().logoutUser(self as NMWebServiceDelegate)\n+\n+  }\n+\n+  /// As the user is Signed out Remove passcode from the keychain\n+  func signout() {\n+\n+    ORKPasscodeViewController.removePasscodeFromKeychain()\n+\n+    let ud = UserDefaults.standard\n+    ud.set(false, forKey: kPasscodeIsPending)\n+    ud.set(false, forKey: kShowNotification)\n+    ud.synchronize()\n+\n+    StudyDashboard.instance.dashboardResponse = []\n+    let appDelegate = UIApplication.shared.delegate as! AppDelegate\n+    appDelegate.updateKeyAndInitializationVector()\n+\n+    if !Utilities.isStandaloneApp() {\n+      self.changeViewController(.studyList)\n+      self.createLeftmenuItems()\n+    } else {\n+      UIApplication.shared.keyWindow?.removeProgressIndicatorFromWindow()\n+      self.navigationController?.popToRootViewController(animated: true)\n     }\n-}\n \n+  }\n+}\n \n-// MARK:- UITableView Delegate\n+// MARK: - UITableView Delegate\n extension LeftMenuViewController: UITableViewDelegate {\n-    \n-    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n-        \n-        if let menu = LeftMenu(rawValue: indexPath.row) {\n-            switch menu {\n-            case .studyList, .resources, .profile_reachOut,.reachOut_signIn, .signup:\n-                return 70.0\n-            }\n-        }\n-        return 0\n-    }\n-    \n-    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n-        \n-        tableView.deselectRow(at: indexPath, animated: true)\n-        \n-        if let menu = menus[indexPath.row][\"menuType\"] as? LeftMenu {\n-            self.changeViewController(menu)\n-        }\n-    }\n-    \n-    func scrollViewDidScroll(_ scrollView: UIScrollView) {\n-        if self.tableView == scrollView {\n-            \n-        }\n+\n+  func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {\n+\n+    if let menu = LeftMenu(rawValue: indexPath.row) {\n+      switch menu {\n+      case .studyList, .resources, .profile_reachOut, .reachOut_signIn, .signup:\n+        return 70.0\n+      }\n     }\n-}\n+    return 0\n+  }\n \n+  func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n \n-// MARK:- UITableView DataSource\n-extension LeftMenuViewController: UITableViewDataSource {\n-    \n-    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n-        return menus.count\n+    tableView.deselectRow(at: indexPath, animated: true)\n+\n+    if let menu = menus[indexPath.row][\"menuType\"] as? LeftMenu {\n+      self.changeViewController(menu)\n     }\n-    \n-    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n-        \n-        let dict: Dictionary<String,Any>? = menus[indexPath.row]\n-        \n-        if dict?[\"subTitle\"] != nil {\n-            \n-            var cell: LeftMenuCell?\n-            cell = tableView.dequeueReusableCell(withIdentifier: \"cell\" , for: indexPath) as? LeftMenuCell\n-            cell?.populateCellData(data: menus[indexPath.row])\n-            return cell!\n-            \n-        }else {\n-            var cell: LeftMenuResourceTableViewCell?\n-            \n-            cell = tableView.dequeueReusableCell(withIdentifier: \"LeftMenuResourceCell\" , for: indexPath) as? LeftMenuResourceTableViewCell\n-            cell?.populateCellData(data: menus[indexPath.row])\n-            return cell!\n-        }\n+  }\n+\n+  func scrollViewDidScroll(_ scrollView: UIScrollView) {\n+    if self.tableView == scrollView {\n+\n     }\n+  }\n }\n \n+// MARK: - UITableView DataSource\n+extension LeftMenuViewController: UITableViewDataSource {\n \n-// MARK:- UserService Response handler\n-extension LeftMenuViewController: NMWebServiceDelegate {\n-    \n-    func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        UIApplication.shared.keyWindow?.addProgressIndicatorOnWindowFromTop()\n-    }\n-    \n-    func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        \n-        if requestName as String ==  RegistrationMethods.logout.description {\n-            self.signout()\n-        }\n-        UIApplication.shared.keyWindow?.addProgressIndicatorOnWindowFromTop()\n-    }\n-    \n-    func failedRequest(_ manager: NetworkManager, requestName: NSString, error: NSError) {\n-        Logger.sharedInstance.info(\"requestname : \\(requestName)\")\n-        UIApplication.shared.keyWindow?.addProgressIndicatorOnWindowFromTop()\n-        \n-        if error.code == 403 { //unauthorized\n-            UIUtilities.showAlertMessageWithActionHandler(kErrorTitle, message: error.localizedDescription, buttonTitle: kTitleOk, viewControllerUsed: self, action: {\n-                self.fdaSlideMenuController()?.navigateToHomeAfterUnauthorizedAccess()\n-            })\n-        }else {\n-            UIUtilities.showAlertWithTitleAndMessage(title: NSLocalizedString(kErrorTitle, comment: \"\") as NSString, message: error.localizedDescription as NSString)\n-        }\n+  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n+    return menus.count\n+  }\n+\n+  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n+\n+    let dict: [String: Any]? = menus[indexPath.row]\n+\n+    if dict?[\"subTitle\"] != nil {\n+      var cell: LeftMenuCell?\n+      cell = tableView.dequeueReusableCell(withIdentifier: \"cell\", for: indexPath)\n+        as? LeftMenuCell\n+      cell?.populateCellData(data: menus[indexPath.row])\n+      return cell!\n+    } else {\n+      var cell: LeftMenuResourceTableViewCell?\n+      cell = tableView.dequeueReusableCell(\n+        withIdentifier: \"LeftMenuResourceCell\", for: indexPath)\n+        as? LeftMenuResourceTableViewCell\n+      cell?.populateCellData(data: menus[indexPath.row])\n+      return cell!\n     }\n+  }\n }\n \n+// MARK: - UserService Response handler\n+extension LeftMenuViewController: NMWebServiceDelegate {\n+\n+  func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n+    Logger.sharedInstance.info(\"requestname : \\(requestName)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 998}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczODAyOQ==", "bodyText": "please remove comment", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391738029", "createdAt": "2020-03-12T16:24:02Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/StudyUI/StudyFilterViewController.swift", "diffHunk": "@@ -1,341 +1,343 @@\n-/*\n- License Agreement for FDA My Studies\n- Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n- hereby granted, free of charge, to any person obtaining a copy of this software and associated\n- documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n- Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n- conditions:\n- The above copyright notice and this permission notice shall be included in all copies or substantial\n- portions of the Software.\n- Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n- Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n- THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n- PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n- OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n- OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n import UIKit\n \n-\n-//Used to do filter based on Apply and Cancel actions\n+// Used to do filter based on Apply and Cancel actions\n protocol StudyFilterDelegates: class {\n-    \n-    func appliedFilter(studyStatus: Array<String>, pariticipationsStatus: Array<String>, categories: Array<String> , searchText: String,bookmarked: Bool)\n-    \n-    func didCancelFilter(_ cancel: Bool)\n-    \n+\n+  func appliedFilter(\n+    studyStatus: [String], pariticipationsStatus: [String], categories: [String],\n+    searchText: String, bookmarked: Bool\n+  )\n+\n+  func didCancelFilter(_ cancel: Bool)\n+\n }\n \n enum FilterType: Int {\n-    \n-    case studyStatus = 0\n-    case bookMark\n-    case participantStatus\n-    case category\n-    \n-}\n \n+  case studyStatus = 0\n+  case bookMark\n+  case participantStatus\n+  case category\n+\n+}\n \n class StudyFilterViewController: UIViewController {\n-    \n-    // MARK:- Outlets\n-    \n-    @IBOutlet weak var collectionView: UICollectionView?\n-    @IBOutlet weak var cancelButton: UIButton?\n-    @IBOutlet weak var applyButton: UIButton?\n-    \n-    // MARK:- Properties\n-    \n-    weak var delegate: StudyFilterDelegates?\n-    \n-    private lazy var studyStatus: [String] = []\n-    private lazy var pariticipationsStatus: [String] = []\n-    private lazy var categories: [String] = []\n-    private lazy var searchText: String = \"\"\n-    private lazy var bookmark = true\n-    \n-    lazy var previousCollectionData: [[String]] = []\n-    \n-    // MARK:- Viewcontroller lifecycle\n-    override func viewDidLoad() {\n-        \n-        super.viewDidLoad()\n-        applyButton?.layer.borderColor = kUicolorForButtonBackground\n-        cancelButton?.layer.borderColor = kUicolorForCancelBackground\n-        \n-        if let layout = collectionView?.collectionViewLayout as? PinterestLayout {\n-            layout.delegate = self\n-        }\n-        \n-        if StudyFilterHandler.instance.filterOptions.count == 0 {\n-            let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-            appDelegate.setDefaultFilters(previousCollectionData: self.previousCollectionData)\n-        }\n-        \n-        self.collectionView?.reloadData()\n-    }\n-    \n-  \n-    // MARK:- Button Actions\n-    \n-    /**\n-     Navigate to Studylist screen on Apply button clicked\n-     @param sender    accepts Anyobject in sender\n-     */\n-    \n-    @IBAction func applyButtonAction(_ sender: AnyObject){\n-        \n-        //categories = [\"Food Safety\",\"Observational Studies\",\"Cosmetics Safety\"]\n-        //pariticipationsStatus = [\"Food Safety\",\"Observational Studies\"]\n-        \n-        var i: Int = 0\n-        var isbookmarked = false\n-        \n-        for filterOptions in StudyFilterHandler.instance.filterOptions {\n-            \n-            let filterType = FilterType.init(rawValue: i)\n-            let filterValues = (filterOptions.filterValues.filter({$0.isSelected == true}))\n-            for value in filterValues {\n-                switch (filterType!) {\n-                    \n-                case .studyStatus:\n-                    studyStatus.append(value.title)\n-                case .participantStatus:\n-                    pariticipationsStatus.append(value.title)\n-                case .bookMark:\n-                    \n-                    if User.currentUser.userType == .FDAUser {\n-                        bookmark = (value.isSelected)\n-                        isbookmarked = true\n-                    } else {\n-                        categories.append(value.title)\n-                    }\n-                    \n-                case .category:\n-                    categories.append(value.title)\n-                    //default: break\n-                }\n-            }\n-            i = i + 1\n-        }\n-        \n-        previousCollectionData = []\n-        previousCollectionData.append(studyStatus)\n-        \n-        if User.currentUser.userType == .FDAUser {\n-            if isbookmarked {\n-                previousCollectionData.append((bookmark == true ? [\"Bookmarked\"]: []))\n-            } else {\n-                previousCollectionData.append([])\n-                bookmark = false\n-            }\n-        } else {\n-            previousCollectionData.append(categories)\n-            bookmark = false\n-            \n-        }\n-        previousCollectionData.append(pariticipationsStatus)\n-        previousCollectionData.append(categories.count == 0 ? [] : categories)\n-        \n-        delegate?.appliedFilter(studyStatus: studyStatus, pariticipationsStatus: pariticipationsStatus, categories: categories,searchText: searchText,bookmarked: bookmark)\n-        self.dismiss(animated: true, completion: nil)\n-        \n+\n+  // MARK: - Outlets\n+\n+  @IBOutlet weak var collectionView: UICollectionView?\n+\n+  @IBOutlet weak var cancelButton: UIButton?\n+  @IBOutlet weak var applyButton: UIButton?\n+\n+  // MARK: - Properties\n+\n+  weak var delegate: StudyFilterDelegates?\n+\n+  private lazy var studyStatus: [String] = []\n+  private lazy var pariticipationsStatus: [String] = []\n+  private lazy var categories: [String] = []\n+  private lazy var searchText: String = \"\"\n+  private lazy var bookmark = true\n+\n+  lazy var previousCollectionData: [[String]] = []\n+\n+  deinit {\n+    Logger.sharedInstance.info(\"\\(self): deinit\")\n+  }\n+\n+  // MARK: - Viewcontroller lifecycle\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    applyButton?.layer.borderColor = kUicolorForButtonBackground\n+    cancelButton?.layer.borderColor = kUicolorForCancelBackground\n+\n+    if let layout = collectionView?.collectionViewLayout as? PinterestLayout {\n+      layout.delegate = self\n     }\n-    \n-    \n-    /**\n-     Navigate to Studylist screen on Cancel button clicked\n-     @param sender    accepts Anyobject in sender\n-     */\n-    @IBAction func cancelButtonAction(_ sender: AnyObject) {\n-        self.delegate?.didCancelFilter(true)\n-        self.dismiss(animated: true, completion: nil)\n+\n+    if StudyFilterHandler.instance.filterOptions.count == 0 {\n+      let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+      appDelegate.setDefaultFilters(previousCollectionData: self.previousCollectionData)\n     }\n-}\n \n-//// MARK:- Collection Data source & Delegate\n-extension StudyFilterViewController: UICollectionViewDataSource {//,UICollectionViewDelegate {\n-    \n-    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n-        return StudyFilterHandler.instance.filterOptions.count //filterData!.count\n+    self.collectionView?.reloadData()\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  /// Navigate to Studylist screen on Apply button clicked.\n+  @IBAction func applyButtonAction(_ sender: AnyObject) {\n+\n+    var i: Int = 0\n+    var isbookmarked = false\n+\n+    for filterOptions in StudyFilterHandler.instance.filterOptions {\n+\n+      let filterType = FilterType.init(rawValue: i)\n+      let filterValues = (filterOptions.filterValues.filter({ $0.isSelected == true }))\n+      for value in filterValues {\n+        switch filterType! {\n+\n+        case .studyStatus:\n+          studyStatus.append(value.title)\n+\n+        case .participantStatus:\n+          pariticipationsStatus.append(value.title)\n+\n+        case .bookMark:\n+          if User.currentUser.userType == .FDAUser {\n+            bookmark = (value.isSelected)\n+            isbookmarked = true\n+          } else {\n+            categories.append(value.title)\n+          }\n+\n+        case .category:\n+          categories.append(value.title)\n+\n+        }\n+      }\n+      i = i + 1\n     }\n-    \n-    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n-        let cell = (collectionView.dequeueReusableCell(withReuseIdentifier: \"cell\", for: indexPath) as?\n-            FilterListCollectionViewCell)!\n-        \n-        let filterOption = StudyFilterHandler.instance.filterOptions[indexPath.row]\n-        cell.displayCollectionData(data: filterOption)\n-        \n-        return cell\n+\n+    previousCollectionData = []\n+    previousCollectionData.append(studyStatus)\n+\n+    if User.currentUser.userType == .FDAUser {\n+      if isbookmarked {\n+        previousCollectionData.append((bookmark == true ? [\"Bookmarked\"] : []))\n+      } else {\n+        previousCollectionData.append([])\n+        bookmark = false\n+      }\n+    } else {\n+      previousCollectionData.append(categories)\n+      bookmark = false\n+\n     }\n-    \n+    previousCollectionData.append(pariticipationsStatus)\n+    previousCollectionData.append(categories.count == 0 ? [] : categories)\n+\n+    delegate?.appliedFilter(\n+      studyStatus: studyStatus, pariticipationsStatus: pariticipationsStatus,\n+      categories: categories, searchText: searchText, bookmarked: bookmark)\n+    self.dismiss(animated: true, completion: nil)\n+\n+  }\n+\n+  /// Navigate to Studylist screen on Cancel button clicked.\n+  @IBAction func cancelButtonAction(_ sender: AnyObject) {\n+    self.delegate?.didCancelFilter(true)\n+    self.dismiss(animated: true, completion: nil)\n+  }\n }\n \n+// MARK: - Collection Data source & Delegate\n+extension StudyFilterViewController: UICollectionViewDataSource {  //,UICollectionViewDelegate {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczODIyOA==", "bodyText": "please remove comment", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391738228", "createdAt": "2020-03-12T16:24:21Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/StudyUI/StudyFilterViewController.swift", "diffHunk": "@@ -1,341 +1,343 @@\n-/*\n- License Agreement for FDA My Studies\n- Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n- hereby granted, free of charge, to any person obtaining a copy of this software and associated\n- documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n- Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n- conditions:\n- The above copyright notice and this permission notice shall be included in all copies or substantial\n- portions of the Software.\n- Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n- Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n- THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n- PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n- OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n- OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n import UIKit\n \n-\n-//Used to do filter based on Apply and Cancel actions\n+// Used to do filter based on Apply and Cancel actions\n protocol StudyFilterDelegates: class {\n-    \n-    func appliedFilter(studyStatus: Array<String>, pariticipationsStatus: Array<String>, categories: Array<String> , searchText: String,bookmarked: Bool)\n-    \n-    func didCancelFilter(_ cancel: Bool)\n-    \n+\n+  func appliedFilter(\n+    studyStatus: [String], pariticipationsStatus: [String], categories: [String],\n+    searchText: String, bookmarked: Bool\n+  )\n+\n+  func didCancelFilter(_ cancel: Bool)\n+\n }\n \n enum FilterType: Int {\n-    \n-    case studyStatus = 0\n-    case bookMark\n-    case participantStatus\n-    case category\n-    \n-}\n \n+  case studyStatus = 0\n+  case bookMark\n+  case participantStatus\n+  case category\n+\n+}\n \n class StudyFilterViewController: UIViewController {\n-    \n-    // MARK:- Outlets\n-    \n-    @IBOutlet weak var collectionView: UICollectionView?\n-    @IBOutlet weak var cancelButton: UIButton?\n-    @IBOutlet weak var applyButton: UIButton?\n-    \n-    // MARK:- Properties\n-    \n-    weak var delegate: StudyFilterDelegates?\n-    \n-    private lazy var studyStatus: [String] = []\n-    private lazy var pariticipationsStatus: [String] = []\n-    private lazy var categories: [String] = []\n-    private lazy var searchText: String = \"\"\n-    private lazy var bookmark = true\n-    \n-    lazy var previousCollectionData: [[String]] = []\n-    \n-    // MARK:- Viewcontroller lifecycle\n-    override func viewDidLoad() {\n-        \n-        super.viewDidLoad()\n-        applyButton?.layer.borderColor = kUicolorForButtonBackground\n-        cancelButton?.layer.borderColor = kUicolorForCancelBackground\n-        \n-        if let layout = collectionView?.collectionViewLayout as? PinterestLayout {\n-            layout.delegate = self\n-        }\n-        \n-        if StudyFilterHandler.instance.filterOptions.count == 0 {\n-            let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-            appDelegate.setDefaultFilters(previousCollectionData: self.previousCollectionData)\n-        }\n-        \n-        self.collectionView?.reloadData()\n-    }\n-    \n-  \n-    // MARK:- Button Actions\n-    \n-    /**\n-     Navigate to Studylist screen on Apply button clicked\n-     @param sender    accepts Anyobject in sender\n-     */\n-    \n-    @IBAction func applyButtonAction(_ sender: AnyObject){\n-        \n-        //categories = [\"Food Safety\",\"Observational Studies\",\"Cosmetics Safety\"]\n-        //pariticipationsStatus = [\"Food Safety\",\"Observational Studies\"]\n-        \n-        var i: Int = 0\n-        var isbookmarked = false\n-        \n-        for filterOptions in StudyFilterHandler.instance.filterOptions {\n-            \n-            let filterType = FilterType.init(rawValue: i)\n-            let filterValues = (filterOptions.filterValues.filter({$0.isSelected == true}))\n-            for value in filterValues {\n-                switch (filterType!) {\n-                    \n-                case .studyStatus:\n-                    studyStatus.append(value.title)\n-                case .participantStatus:\n-                    pariticipationsStatus.append(value.title)\n-                case .bookMark:\n-                    \n-                    if User.currentUser.userType == .FDAUser {\n-                        bookmark = (value.isSelected)\n-                        isbookmarked = true\n-                    } else {\n-                        categories.append(value.title)\n-                    }\n-                    \n-                case .category:\n-                    categories.append(value.title)\n-                    //default: break\n-                }\n-            }\n-            i = i + 1\n-        }\n-        \n-        previousCollectionData = []\n-        previousCollectionData.append(studyStatus)\n-        \n-        if User.currentUser.userType == .FDAUser {\n-            if isbookmarked {\n-                previousCollectionData.append((bookmark == true ? [\"Bookmarked\"]: []))\n-            } else {\n-                previousCollectionData.append([])\n-                bookmark = false\n-            }\n-        } else {\n-            previousCollectionData.append(categories)\n-            bookmark = false\n-            \n-        }\n-        previousCollectionData.append(pariticipationsStatus)\n-        previousCollectionData.append(categories.count == 0 ? [] : categories)\n-        \n-        delegate?.appliedFilter(studyStatus: studyStatus, pariticipationsStatus: pariticipationsStatus, categories: categories,searchText: searchText,bookmarked: bookmark)\n-        self.dismiss(animated: true, completion: nil)\n-        \n+\n+  // MARK: - Outlets\n+\n+  @IBOutlet weak var collectionView: UICollectionView?\n+\n+  @IBOutlet weak var cancelButton: UIButton?\n+  @IBOutlet weak var applyButton: UIButton?\n+\n+  // MARK: - Properties\n+\n+  weak var delegate: StudyFilterDelegates?\n+\n+  private lazy var studyStatus: [String] = []\n+  private lazy var pariticipationsStatus: [String] = []\n+  private lazy var categories: [String] = []\n+  private lazy var searchText: String = \"\"\n+  private lazy var bookmark = true\n+\n+  lazy var previousCollectionData: [[String]] = []\n+\n+  deinit {\n+    Logger.sharedInstance.info(\"\\(self): deinit\")\n+  }\n+\n+  // MARK: - Viewcontroller lifecycle\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    applyButton?.layer.borderColor = kUicolorForButtonBackground\n+    cancelButton?.layer.borderColor = kUicolorForCancelBackground\n+\n+    if let layout = collectionView?.collectionViewLayout as? PinterestLayout {\n+      layout.delegate = self\n     }\n-    \n-    \n-    /**\n-     Navigate to Studylist screen on Cancel button clicked\n-     @param sender    accepts Anyobject in sender\n-     */\n-    @IBAction func cancelButtonAction(_ sender: AnyObject) {\n-        self.delegate?.didCancelFilter(true)\n-        self.dismiss(animated: true, completion: nil)\n+\n+    if StudyFilterHandler.instance.filterOptions.count == 0 {\n+      let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+      appDelegate.setDefaultFilters(previousCollectionData: self.previousCollectionData)\n     }\n-}\n \n-//// MARK:- Collection Data source & Delegate\n-extension StudyFilterViewController: UICollectionViewDataSource {//,UICollectionViewDelegate {\n-    \n-    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n-        return StudyFilterHandler.instance.filterOptions.count //filterData!.count\n+    self.collectionView?.reloadData()\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  /// Navigate to Studylist screen on Apply button clicked.\n+  @IBAction func applyButtonAction(_ sender: AnyObject) {\n+\n+    var i: Int = 0\n+    var isbookmarked = false\n+\n+    for filterOptions in StudyFilterHandler.instance.filterOptions {\n+\n+      let filterType = FilterType.init(rawValue: i)\n+      let filterValues = (filterOptions.filterValues.filter({ $0.isSelected == true }))\n+      for value in filterValues {\n+        switch filterType! {\n+\n+        case .studyStatus:\n+          studyStatus.append(value.title)\n+\n+        case .participantStatus:\n+          pariticipationsStatus.append(value.title)\n+\n+        case .bookMark:\n+          if User.currentUser.userType == .FDAUser {\n+            bookmark = (value.isSelected)\n+            isbookmarked = true\n+          } else {\n+            categories.append(value.title)\n+          }\n+\n+        case .category:\n+          categories.append(value.title)\n+\n+        }\n+      }\n+      i = i + 1\n     }\n-    \n-    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n-        let cell = (collectionView.dequeueReusableCell(withReuseIdentifier: \"cell\", for: indexPath) as?\n-            FilterListCollectionViewCell)!\n-        \n-        let filterOption = StudyFilterHandler.instance.filterOptions[indexPath.row]\n-        cell.displayCollectionData(data: filterOption)\n-        \n-        return cell\n+\n+    previousCollectionData = []\n+    previousCollectionData.append(studyStatus)\n+\n+    if User.currentUser.userType == .FDAUser {\n+      if isbookmarked {\n+        previousCollectionData.append((bookmark == true ? [\"Bookmarked\"] : []))\n+      } else {\n+        previousCollectionData.append([])\n+        bookmark = false\n+      }\n+    } else {\n+      previousCollectionData.append(categories)\n+      bookmark = false\n+\n     }\n-    \n+    previousCollectionData.append(pariticipationsStatus)\n+    previousCollectionData.append(categories.count == 0 ? [] : categories)\n+\n+    delegate?.appliedFilter(\n+      studyStatus: studyStatus, pariticipationsStatus: pariticipationsStatus,\n+      categories: categories, searchText: searchText, bookmarked: bookmark)\n+    self.dismiss(animated: true, completion: nil)\n+\n+  }\n+\n+  /// Navigate to Studylist screen on Cancel button clicked.\n+  @IBAction func cancelButtonAction(_ sender: AnyObject) {\n+    self.delegate?.didCancelFilter(true)\n+    self.dismiss(animated: true, completion: nil)\n+  }\n }\n \n+// MARK: - Collection Data source & Delegate\n+extension StudyFilterViewController: UICollectionViewDataSource {  //,UICollectionViewDelegate {\n+\n+  func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int)\n+    -> Int {\n+    return StudyFilterHandler.instance.filterOptions.count  //filterData!.count", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 322}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczODk4Ng==", "bodyText": "nit: remove blank line", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391738986", "createdAt": "2020-03-12T16:25:28Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/StudyUI/StudyFilterViewController.swift", "diffHunk": "@@ -1,341 +1,343 @@\n-/*\n- License Agreement for FDA My Studies\n- Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n- hereby granted, free of charge, to any person obtaining a copy of this software and associated\n- documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n- Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n- conditions:\n- The above copyright notice and this permission notice shall be included in all copies or substantial\n- portions of the Software.\n- Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n- Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n- THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n- PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n- OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n- OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n import UIKit\n \n-\n-//Used to do filter based on Apply and Cancel actions\n+// Used to do filter based on Apply and Cancel actions\n protocol StudyFilterDelegates: class {\n-    \n-    func appliedFilter(studyStatus: Array<String>, pariticipationsStatus: Array<String>, categories: Array<String> , searchText: String,bookmarked: Bool)\n-    \n-    func didCancelFilter(_ cancel: Bool)\n-    \n+\n+  func appliedFilter(\n+    studyStatus: [String], pariticipationsStatus: [String], categories: [String],\n+    searchText: String, bookmarked: Bool\n+  )\n+\n+  func didCancelFilter(_ cancel: Bool)\n+\n }\n \n enum FilterType: Int {\n-    \n-    case studyStatus = 0\n-    case bookMark\n-    case participantStatus\n-    case category\n-    \n-}\n \n+  case studyStatus = 0\n+  case bookMark\n+  case participantStatus\n+  case category\n+\n+}\n \n class StudyFilterViewController: UIViewController {\n-    \n-    // MARK:- Outlets\n-    \n-    @IBOutlet weak var collectionView: UICollectionView?\n-    @IBOutlet weak var cancelButton: UIButton?\n-    @IBOutlet weak var applyButton: UIButton?\n-    \n-    // MARK:- Properties\n-    \n-    weak var delegate: StudyFilterDelegates?\n-    \n-    private lazy var studyStatus: [String] = []\n-    private lazy var pariticipationsStatus: [String] = []\n-    private lazy var categories: [String] = []\n-    private lazy var searchText: String = \"\"\n-    private lazy var bookmark = true\n-    \n-    lazy var previousCollectionData: [[String]] = []\n-    \n-    // MARK:- Viewcontroller lifecycle\n-    override func viewDidLoad() {\n-        \n-        super.viewDidLoad()\n-        applyButton?.layer.borderColor = kUicolorForButtonBackground\n-        cancelButton?.layer.borderColor = kUicolorForCancelBackground\n-        \n-        if let layout = collectionView?.collectionViewLayout as? PinterestLayout {\n-            layout.delegate = self\n-        }\n-        \n-        if StudyFilterHandler.instance.filterOptions.count == 0 {\n-            let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-            appDelegate.setDefaultFilters(previousCollectionData: self.previousCollectionData)\n-        }\n-        \n-        self.collectionView?.reloadData()\n-    }\n-    \n-  \n-    // MARK:- Button Actions\n-    \n-    /**\n-     Navigate to Studylist screen on Apply button clicked\n-     @param sender    accepts Anyobject in sender\n-     */\n-    \n-    @IBAction func applyButtonAction(_ sender: AnyObject){\n-        \n-        //categories = [\"Food Safety\",\"Observational Studies\",\"Cosmetics Safety\"]\n-        //pariticipationsStatus = [\"Food Safety\",\"Observational Studies\"]\n-        \n-        var i: Int = 0\n-        var isbookmarked = false\n-        \n-        for filterOptions in StudyFilterHandler.instance.filterOptions {\n-            \n-            let filterType = FilterType.init(rawValue: i)\n-            let filterValues = (filterOptions.filterValues.filter({$0.isSelected == true}))\n-            for value in filterValues {\n-                switch (filterType!) {\n-                    \n-                case .studyStatus:\n-                    studyStatus.append(value.title)\n-                case .participantStatus:\n-                    pariticipationsStatus.append(value.title)\n-                case .bookMark:\n-                    \n-                    if User.currentUser.userType == .FDAUser {\n-                        bookmark = (value.isSelected)\n-                        isbookmarked = true\n-                    } else {\n-                        categories.append(value.title)\n-                    }\n-                    \n-                case .category:\n-                    categories.append(value.title)\n-                    //default: break\n-                }\n-            }\n-            i = i + 1\n-        }\n-        \n-        previousCollectionData = []\n-        previousCollectionData.append(studyStatus)\n-        \n-        if User.currentUser.userType == .FDAUser {\n-            if isbookmarked {\n-                previousCollectionData.append((bookmark == true ? [\"Bookmarked\"]: []))\n-            } else {\n-                previousCollectionData.append([])\n-                bookmark = false\n-            }\n-        } else {\n-            previousCollectionData.append(categories)\n-            bookmark = false\n-            \n-        }\n-        previousCollectionData.append(pariticipationsStatus)\n-        previousCollectionData.append(categories.count == 0 ? [] : categories)\n-        \n-        delegate?.appliedFilter(studyStatus: studyStatus, pariticipationsStatus: pariticipationsStatus, categories: categories,searchText: searchText,bookmarked: bookmark)\n-        self.dismiss(animated: true, completion: nil)\n-        \n+\n+  // MARK: - Outlets\n+\n+  @IBOutlet weak var collectionView: UICollectionView?\n+\n+  @IBOutlet weak var cancelButton: UIButton?\n+  @IBOutlet weak var applyButton: UIButton?\n+\n+  // MARK: - Properties\n+\n+  weak var delegate: StudyFilterDelegates?\n+\n+  private lazy var studyStatus: [String] = []\n+  private lazy var pariticipationsStatus: [String] = []\n+  private lazy var categories: [String] = []\n+  private lazy var searchText: String = \"\"\n+  private lazy var bookmark = true\n+\n+  lazy var previousCollectionData: [[String]] = []\n+\n+  deinit {\n+    Logger.sharedInstance.info(\"\\(self): deinit\")\n+  }\n+\n+  // MARK: - Viewcontroller lifecycle\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    applyButton?.layer.borderColor = kUicolorForButtonBackground\n+    cancelButton?.layer.borderColor = kUicolorForCancelBackground\n+\n+    if let layout = collectionView?.collectionViewLayout as? PinterestLayout {\n+      layout.delegate = self\n     }\n-    \n-    \n-    /**\n-     Navigate to Studylist screen on Cancel button clicked\n-     @param sender    accepts Anyobject in sender\n-     */\n-    @IBAction func cancelButtonAction(_ sender: AnyObject) {\n-        self.delegate?.didCancelFilter(true)\n-        self.dismiss(animated: true, completion: nil)\n+\n+    if StudyFilterHandler.instance.filterOptions.count == 0 {\n+      let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+      appDelegate.setDefaultFilters(previousCollectionData: self.previousCollectionData)\n     }\n-}\n \n-//// MARK:- Collection Data source & Delegate\n-extension StudyFilterViewController: UICollectionViewDataSource {//,UICollectionViewDelegate {\n-    \n-    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n-        return StudyFilterHandler.instance.filterOptions.count //filterData!.count\n+    self.collectionView?.reloadData()\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  /// Navigate to Studylist screen on Apply button clicked.\n+  @IBAction func applyButtonAction(_ sender: AnyObject) {\n+\n+    var i: Int = 0\n+    var isbookmarked = false\n+\n+    for filterOptions in StudyFilterHandler.instance.filterOptions {\n+\n+      let filterType = FilterType.init(rawValue: i)\n+      let filterValues = (filterOptions.filterValues.filter({ $0.isSelected == true }))\n+      for value in filterValues {\n+        switch filterType! {\n+\n+        case .studyStatus:\n+          studyStatus.append(value.title)\n+\n+        case .participantStatus:\n+          pariticipationsStatus.append(value.title)\n+\n+        case .bookMark:\n+          if User.currentUser.userType == .FDAUser {\n+            bookmark = (value.isSelected)\n+            isbookmarked = true\n+          } else {\n+            categories.append(value.title)\n+          }\n+\n+        case .category:\n+          categories.append(value.title)\n+\n+        }\n+      }\n+      i = i + 1\n     }\n-    \n-    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n-        let cell = (collectionView.dequeueReusableCell(withReuseIdentifier: \"cell\", for: indexPath) as?\n-            FilterListCollectionViewCell)!\n-        \n-        let filterOption = StudyFilterHandler.instance.filterOptions[indexPath.row]\n-        cell.displayCollectionData(data: filterOption)\n-        \n-        return cell\n+\n+    previousCollectionData = []\n+    previousCollectionData.append(studyStatus)\n+\n+    if User.currentUser.userType == .FDAUser {\n+      if isbookmarked {\n+        previousCollectionData.append((bookmark == true ? [\"Bookmarked\"] : []))\n+      } else {\n+        previousCollectionData.append([])\n+        bookmark = false\n+      }\n+    } else {\n+      previousCollectionData.append(categories)\n+      bookmark = false\n+\n     }\n-    \n+    previousCollectionData.append(pariticipationsStatus)\n+    previousCollectionData.append(categories.count == 0 ? [] : categories)\n+\n+    delegate?.appliedFilter(\n+      studyStatus: studyStatus, pariticipationsStatus: pariticipationsStatus,\n+      categories: categories, searchText: searchText, bookmarked: bookmark)\n+    self.dismiss(animated: true, completion: nil)\n+\n+  }\n+\n+  /// Navigate to Studylist screen on Cancel button clicked.\n+  @IBAction func cancelButtonAction(_ sender: AnyObject) {\n+    self.delegate?.didCancelFilter(true)\n+    self.dismiss(animated: true, completion: nil)\n+  }\n }\n \n+// MARK: - Collection Data source & Delegate\n+extension StudyFilterViewController: UICollectionViewDataSource {  //,UICollectionViewDelegate {\n+\n+  func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int)\n+    -> Int {\n+    return StudyFilterHandler.instance.filterOptions.count  //filterData!.count\n+  }\n+\n+  func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath)\n+    -> UICollectionViewCell {\n+    let cell = (\n+      collectionView.dequeueReusableCell(withReuseIdentifier: \"cell\", for: indexPath)\n+        as? FilterListCollectionViewCell\n+    )!\n+\n+    let filterOption = StudyFilterHandler.instance.filterOptions[indexPath.row]\n+    cell.displayCollectionData(data: filterOption)\n+\n+    return cell\n+  }\n+\n+}\n \n extension StudyFilterViewController: PinterestLayoutDelegate {\n-    \n-    // 1. Returns the photo height\n-    func collectionView(_ collectionView: UICollectionView, heightForPhotoAtIndexPath indexPath: IndexPath , withWidth width: CGFloat) -> CGFloat {\n-        \n-        let filterOptions = StudyFilterHandler.instance.filterOptions[indexPath.row]\n-        var headerHeight = 0\n-        if filterOptions.title.count > 0 {\n-            headerHeight = 60\n-        }\n-        let height: CGFloat = CGFloat((filterOptions.filterValues.count * 50) + headerHeight)\n-        return height\n-    }\n-    \n-    // 2. Returns the annotation size based on the text\n-    func collectionView(_ collectionView: UICollectionView, heightForAnnotationAtIndexPath indexPath: IndexPath, withWidth width: CGFloat) -> CGFloat {\n-        return 0\n+\n+  // 1. Returns the photo height\n+  func collectionView(\n+    _ collectionView: UICollectionView, heightForPhotoAtIndexPath indexPath: IndexPath,\n+    withWidth width: CGFloat\n+  ) -> CGFloat {\n+\n+    let filterOptions = StudyFilterHandler.instance.filterOptions[indexPath.row]\n+    var headerHeight: CGFloat = 0\n+    if filterOptions.title.count > 0 {\n+      headerHeight = 60\n     }\n-    \n+    let cellTableViewHeight = CGFloat(filterOptions.filterValues.count)\n+      * FilterListCollectionViewCell.filterTableViewCellHeight\n+\n+    let totalHeight: CGFloat = cellTableViewHeight + headerHeight\n+    return totalHeight\n+  }\n+\n+  // 2. Returns the annotation size based on the text\n+  func collectionView(\n+    _ collectionView: UICollectionView, heightForAnnotationAtIndexPath indexPath: IndexPath,\n+    withWidth width: CGFloat\n+  ) -> CGFloat {\n+    return 0\n+  }\n+\n }\n \n class StudyFilterHandler {\n-    var filterOptions: Array<FilterOptions> = []\n-    var previousAppliedFilters: Array<Array<String>> = []\n-    var searchText = \"\"\n-    static var instance = StudyFilterHandler()\n+  var filterOptions: [FilterOptions] = []\n+  var previousAppliedFilters: [[String]] = []\n+  var searchText = \"\"\n+  static var instance = StudyFilterHandler()\n }\n \n class FilterOptions {\n-    var title: String!\n-    var filterValues: Array<FilterValues> = []\n+  var title: String!\n+  var filterValues: [FilterValues] = []\n }\n \n class FilterValues {\n-    var title: String!\n-    var isSelected = false\n+  var title: String!\n+  var isSelected = false\n }\n \n extension AppDelegate {\n-    \n-    /**\n-     setter method to set the default filter options if none are selected\n-     */\n-    func setDefaultFilters(previousCollectionData: Array<Array<String>>) {\n-        \n-        var filterData: NSMutableArray?\n-        var resource = \"AnanomousFilterData\"\n-        \n-        if User.currentUser.userType == .FDAUser {\n-            resource = \"FilterData\"\n-        }\n-        \n-        let plistPath = Bundle.main.path(forResource: resource, ofType: \".plist\", inDirectory: nil)\n-        filterData = NSMutableArray.init(contentsOfFile: plistPath!)!\n-        \n-        StudyFilterHandler.instance.filterOptions = []\n-        var filterOptionsList: Array<FilterOptions> = []\n-        var i = 0\n-        \n-        for options in filterData! {\n-            let values = ((options as? Dictionary<String,Any>)![\"studyData\"] as? Array<Dictionary<String,Any>>)!\n-            let filterOptions = FilterOptions()\n-            filterOptions.title = ((options as? Dictionary<String,Any>)![\"headerText\"] as? String)!\n-            \n-            var selectedValues: Array<String> = []\n-            if previousCollectionData.count > 0 {\n-                selectedValues = previousCollectionData[i]\n-            }\n-            \n-            var filterValues: Array<FilterValues> = []\n-            for value in values {\n-                \n-                var isContained = false\n-                \n-                let filterValue = FilterValues()\n-                filterValue.title = (value[\"name\"] as? String)!\n-                \n-                if selectedValues.count > 0 {\n-                    isContained = selectedValues.contains((value[\"name\"] as? String)!)\n-                }\n-                \n-                if isContained == false {\n-                    \n-                    if previousCollectionData.count == 0 {\n-                        // this means that we are first time accessing the filter screen\n-                        filterValue.isSelected =  (value[\"isEnabled\"] as? Bool)!\n-                        \n-                    } else {\n-                        // means that filter is already set\n-                        filterValue.isSelected = false\n-                    }\n-                } else {\n-                    filterValue.isSelected = true\n-                }\n-                \n-                filterValues.append(filterValue)\n-            }\n-            filterOptions.filterValues = filterValues\n-            filterOptionsList.append(filterOptions)\n-            \n-            i = i + 1\n-        }\n-        StudyFilterHandler.instance.filterOptions = filterOptionsList\n-        \n+\n+  /// setter method to set the default filter options if none are selected.\n+  func setDefaultFilters(previousCollectionData: [[String]]) {\n+\n+    var filterData: NSMutableArray?\n+    var resource = \"AnanomousFilterData\"\n+\n+    if User.currentUser.userType == .FDAUser {\n+      resource = \"FilterData\"\n     }\n-    \n-    /**\n-     returns the array of strings for default filters\n-     studyStatus: array of default study status\n-     pariticipationsStatus: array of participation status\n-     categories: array of categories\n-     */\n-    \n-    func getDefaultFilterStrings()->(studyStatus: Array<String>,pariticipationsStatus: Array<String>,categories: Array<String>,searchText: String,bookmark: Bool){\n-        \n-        var studyStatus: Array<String> = []\n-        var pariticipationsStatus: Array<String> = []\n-        var categories: Array<String> = []\n-        var bookmark = true\n-\n-        //Parsing the filter options\n-        for (index,filterOptions) in StudyFilterHandler.instance.filterOptions.enumerated() {\n-            \n-            let filterType = FilterType.init(rawValue: index)\n-            let filterValues = (filterOptions.filterValues.filter({$0.isSelected == true}))\n-            for value in filterValues {\n-                switch (filterType!) {\n-                    \n-                case .studyStatus:\n-                    studyStatus.append(value.title)\n-                    \n-                case .participantStatus:\n-                    pariticipationsStatus.append(value.title)\n-                    \n-                case .bookMark:\n-                    if User.currentUser.userType == .FDAUser {\n-                        bookmark = (value.isSelected)\n-                    } else {\n-                        categories.append(value.title)\n-                    }\n-                    \n-                case .category:\n-                    categories.append(value.title)\n-                    //default: break\n-                }\n-            }\n+\n+    let plistPath = Bundle.main.path(forResource: resource, ofType: \".plist\", inDirectory: nil)\n+    filterData = NSMutableArray.init(contentsOfFile: plistPath!)!\n+\n+    StudyFilterHandler.instance.filterOptions = []\n+    var filterOptionsList: [FilterOptions] = []\n+    var i = 0\n+\n+    for options in filterData! {\n+      let values = ((options as? [String: Any])![\"studyData\"] as? [[String: Any]])!\n+      let filterOptions = FilterOptions()\n+      filterOptions.title = ((options as? [String: Any])![\"headerText\"] as? String)!\n+\n+      var selectedValues: [String] = []\n+      if previousCollectionData.count > 0 {\n+        selectedValues = previousCollectionData[i]\n+      }\n+\n+      var filterValues: [FilterValues] = []\n+      for value in values {\n+\n+        var isContained = false\n+\n+        let filterValue = FilterValues()\n+        filterValue.title = (value[\"name\"] as? String)!\n+\n+        if selectedValues.count > 0 {\n+          isContained = selectedValues.contains((value[\"name\"] as? String)!)\n         }\n-        \n-        if User.currentUser.userType == .FDAUser {\n-            bookmark = false\n+\n+        if isContained == false {\n+\n+          if previousCollectionData.count == 0 {\n+            // this means that we are first time accessing the filter screen\n+            filterValue.isSelected = (value[\"isEnabled\"] as? Bool)!\n+\n+          } else {\n+            // means that filter is already set\n+            filterValue.isSelected = false\n+          }\n         } else {\n-            bookmark = false\n+          filterValue.isSelected = true\n         }\n-        \n-        return(studyStatus: studyStatus,pariticipationsStatus : pariticipationsStatus,categories: categories,searchText: \"\",bookmark: bookmark)\n+\n+        filterValues.append(filterValue)\n+      }\n+      filterOptions.filterValues = filterValues\n+      filterOptionsList.append(filterOptions)\n+\n+      i = i + 1\n     }\n-    \n-    \n-}\n+    StudyFilterHandler.instance.filterOptions = filterOptionsList\n+\n+  }\n+\n+  /// Query the filters settings.\n+  func getDefaultFilterStrings() -> (\n+    studyStatus: [String], pariticipationsStatus: [String], categories: [String],\n+    searchText: String, bookmark: Bool\n+  ) {\n+\n+    var studyStatus: [String] = []\n+    var pariticipationsStatus: [String] = []\n+    var categories: [String] = []\n+    var bookmark = true\n+\n+    // Parsing the filter options\n+    for (index, filterOptions) in StudyFilterHandler.instance.filterOptions.enumerated() {\n \n+      let filterType = FilterType.init(rawValue: index)\n+      let filterValues = (filterOptions.filterValues.filter({ $0.isSelected == true }))\n+      for value in filterValues {\n+        switch filterType! {\n \n+        case .studyStatus:\n+          studyStatus.append(value.title)\n+\n+        case .participantStatus:\n+          pariticipationsStatus.append(value.title)\n+\n+        case .bookMark:\n+          if User.currentUser.userType == .FDAUser {\n+            bookmark = (value.isSelected)\n+          } else {\n+            categories.append(value.title)\n+          }\n+\n+        case .category:\n+          categories.append(value.title)\n+\n+        }\n+      }\n+    }\n+\n+    if User.currentUser.userType == .FDAUser {\n+      bookmark = false\n+    } else {\n+      bookmark = false\n+    }\n+\n+    return (\n+      studyStatus: studyStatus, pariticipationsStatus: pariticipationsStatus,\n+      categories: categories, searchText: \"\", bookmark: bookmark\n+    )\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 643}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczOTk5Nw==", "bodyText": "nit: should be isPasscodePending ?", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391739997", "createdAt": "2020-03-12T16:26:54Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/StudyUI/StudyListViewController.swift", "diffHunk": "@@ -1,1154 +1,1133 @@\n-/*\n- License Agreement for FDA My Studies\n- Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n- hereby granted, free of charge, to any person obtaining a copy of this software and associated\n- documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n- Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n- conditions:\n- The above copyright notice and this permission notice shall be included in all copies or substantial\n- portions of the Software.\n- Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n- Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n- THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n- PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n- OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n- OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import IQKeyboardManagerSwift\n import UIKit\n \n-let kHelperTextForFilteredStudiesNotFound = \"Sorry, no Studies found. Please try different Filter Options\"\n-let kHelperTextForSearchedStudiesNotFound = \"Sorry, no Studies found. Please check the spelling or try a different search.\"\n+let kHelperTextForFilteredStudiesNotFound\n+  = \"No study found.\\nPlease try different Filter Options.\"\n \n-let kHelperTextForOffline = \"Sorry, no studies available right now. Please remain signed in to get notified when there are new studies available.\"\n+let kHelperTextForSearchedStudiesNotFound\n+  = \"No study found.\\nPlease check the spelling or try a different search.\"\n+\n+let kHelperTextForOffline\n+  = \"No study available right now.\\nPlease remain signed in to get notified when there are new studies available.\"\n \n let kNotificationViewControllerIdentifier = \"NotificationViewControllerIdentifier\"\n \n class StudyListViewController: UIViewController {\n-    \n-    // MARK:- Outlets\n-    \n-    @IBOutlet var tableView: UITableView?\n-    @IBOutlet var labelHelperText: UILabel!\n-\n-    var refreshControl: UIRefreshControl? // for refreshing studylist\n-\n-    var studyListRequestFailed = false\n-    var searchView: SearchBarView?\n-\n-    var isComingFromFilterScreen: Bool = false\n-    var studiesList: [Study] = []\n-\n-    var previousStudyList: [Study] = []\n-\n-    var allStudyList: [Study] = [] // Gatewaystudylist\n-    override var preferredStatusBarStyle: UIStatusBarStyle {\n-        return .default\n-    }\n-\n-    // MARK: - Viewcontroller lifecycle\n-\n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-\n-        var infoDict: NSDictionary?\n-        if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n-            infoDict = NSDictionary(contentsOfFile: path)\n-        }\n-        let navTitle = infoDict![\"ProductTitleName\"] as! String\n-        let titleLabel = UILabel()\n-        titleLabel.text = NSLocalizedString(navTitle, comment: \"\")\n-        titleLabel.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n-        titleLabel.textAlignment = .left\n-        titleLabel.textColor = Utilities.getUIColorFromHex(0x007CBA)\n-        titleLabel.frame = CGRect(x: 0, y: 0, width: 300, height: 44)\n-\n-        navigationItem.titleView = titleLabel\n-\n-        // self.loadTestData()\n-        // get Profile data to check for passcode\n-        // Condition missing\n \n-        let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+  // MARK: - Outlets\n \n-        \n-        if User.currentUser.userType == .FDAUser, User.currentUser.settings?.localNotifications == true {\n-            /* Will come next next phase */\n-            //appDelegate.checkForAppReopenNotification()\n-        }\n+  @IBOutlet weak var tableView: UITableView!\n \n-        isComingFromFilterScreen = false\n-        // IQKeyboardManager.sharedManager().enable = true\n+  @IBOutlet weak var labelHelperText: UILabel!\n \n-        refreshControl = UIRefreshControl()\n-        refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n-        refreshControl?.addTarget(self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n-        tableView?.addSubview(refreshControl!)\n-    }\n+  lazy var studyListRequestFailed = false\n+  var searchView: SearchBarView?\n+  lazy var isComingFromFilterScreen: Bool = false\n+  lazy var studiesList: [Study] = []\n+  lazy var previousStudyList: [Study] = []\n \n-    override func viewWillAppear(_: Bool) {\n-        if isComingFromFilterScreen {\n-            isComingFromFilterScreen = false\n-            return\n-        }\n-        addRightNavigationItem()\n-        let appdelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+  /// Gatewaystudylist\n+  lazy var allStudyList: [Study] = []\n \n-        Study.currentStudy = nil\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n \n-        let ud = UserDefaults.standard\n-        var ispasscodePending: Bool? = false\n+  // MARK: - Viewcontroller lifecycle\n \n-        // Checking if User has missed out setting the passcode/TouchId\n-        if ud.value(forKey: kPasscodeIsPending) != nil {\n-            ispasscodePending = (ud.value(forKey: kPasscodeIsPending) as? Bool)!\n-        }\n-\n-        if ispasscodePending == true {\n-            if User.currentUser.userType == .FDAUser {\n-                tableView?.isHidden = true\n-                // Fetch the User Profile\n-                UserServices().getUserProfile(self as NMWebServiceDelegate)\n-            }\n-        }\n-\n-        labelHelperText.isHidden = true\n-        setNavigationBarItem()\n-        navigationController?.setNavigationBarHidden(false, animated: true)\n-        navigationController?.navigationBar.isHidden = false\n-\n-        if User.currentUser.userType == .FDAUser { // For LoggedIn User\n-            tableView?.estimatedRowHeight = 145\n-            tableView?.rowHeight = UITableView.automaticDimension\n-\n-            if (fdaSlideMenuController()?.isLeftOpen())! {\n-                // Do Nothing\n-            } else {\n-                // Fetch User Preferences\n-                sendRequestToGetUserPreference()\n-            }\n-        } else { // For ananomous User\n-            tableView?.estimatedRowHeight = 140\n-            tableView?.rowHeight = UITableView.automaticDimension\n-            // Fetch StudyList\n-            sendRequestToGetStudyList()\n-        }\n-\n-        // UIApplication.shared.statusBarStyle = .default\n-        setNeedsStatusBarAppearanceUpdate()\n-        // Checking if registering notification is pending\n-        if ud.value(forKey: kNotificationRegistrationIsPending) != nil, ud.bool(forKey: kNotificationRegistrationIsPending) == true {\n-            appdelegate.askForNotification()\n-        }\n-\n-        // Handling StudyList Request Failure condition\n-        if studyListRequestFailed {\n-            labelHelperText.isHidden = false\n-            labelHelperText.text = kHelperTextForOffline\n-        }\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    addNavigationTitle()\n+    isComingFromFilterScreen = false\n+    DispatchQueue.main.async { [weak self] in\n+      self?.setupStudyListTableView()\n     }\n+  }\n \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  override func viewDidAppear(_ animated: Bool) {\n+    super.viewDidAppear(animated)\n+    if isComingFromFilterScreen {\n+      isComingFromFilterScreen = false\n+      return\n     }\n+    addRightNavigationItem()\n+    let appdelegate = (UIApplication.shared.delegate as? AppDelegate)!\n \n-    // MARK: - Helper Methods\n+    Study.currentStudy = nil\n \n-    /**\n-     addRightNavigationItem method updates the navigation bar items for current controller , by adding Notification Button, Notification Indicator & Filter Button\n-     */\n-    func addRightNavigationItem() {\n-        let view = UIView(frame: CGRect(x: 0, y: 4, width: 110, height: 40))\n+    let ud = UserDefaults.standard\n+    var ispasscodePending: Bool? = false\n \n-        // Notification Button\n-        let button = addNotificationButton()\n-        view.addSubview(button)\n-        button.isExclusiveTouch = true\n-\n-        // notification Indicator\n-        let label = addNotificationIndication()\n-        view.addSubview(label)\n-\n-        let ud = UserDefaults.standard\n-        let showNotification = ud.bool(forKey: kShowNotification)\n-\n-        if showNotification {\n-            label.isHidden = false\n-        } else {\n-            label.isHidden = true\n-        }\n-\n-        //  filter Button\n-        let filterButton = addFilterButton()\n-        view.addSubview(filterButton)\n-        filterButton.isExclusiveTouch = true\n-\n-        //  Search Button\n-        let searchButton = addSearchButton()\n-        view.addSubview(searchButton)\n-        searchButton.isExclusiveTouch = true\n-\n-        let barButton = UIBarButtonItem(customView: view)\n-        navigationItem.rightBarButtonItems = [barButton]\n-    }\n-\n-    func addSearchButton() -> UIButton {\n-        let searchButton = UIButton(type: .custom)\n-        searchButton.setImage(#imageLiteral(resourceName: \"search_small\"), for: UIControl.State.normal)\n-        searchButton.addTarget(self, action: #selector(searchButtonAction(_:)), for: .touchUpInside)\n-        searchButton.frame = CGRect(x: 0, y: 4, width: 30, height: 30)\n-        return searchButton\n+    // Checking if User has missed out setting the passcode/TouchId\n+    if ud.value(forKey: kPasscodeIsPending) != nil {\n+      ispasscodePending = (ud.value(forKey: kPasscodeIsPending) as? Bool)!\n     }\n \n-    func addFilterButton() -> UIButton {\n-        let filterButton = UIButton(type: .custom)\n-        filterButton.setImage(#imageLiteral(resourceName: \"filterIcon\"), for: UIControl.State.normal)\n-        filterButton.addTarget(self, action: #selector(filterAction(_:)), for: .touchUpInside)\n-        filterButton.frame = CGRect(x: 40, y: 4, width: 30, height: 30)\n-        return filterButton\n-    }\n-\n-    func addNotificationButton() -> UIButton {\n-        let button = UIButton(type: .custom)\n-\n-        button.setImage(#imageLiteral(resourceName: \"notification_grey\"), for: UIControl.State.normal)\n-        button.addTarget(self, action: #selector(buttonActionNotification(_:)), for: .touchUpInside)\n-        button.frame = CGRect(x: 80, y: 4, width: 30, height: 30)\n-        return button\n-    }\n-\n-    func addNotificationIndication() -> UILabel {\n-        let label = UILabel(frame: CGRect(x: 100, y: 4, width: 10, height: 10))\n-        label.font = UIFont.systemFont(ofSize: 10)\n-        label.textColor = UIColor.white\n-\n-        label.textAlignment = NSTextAlignment.center\n-        label.backgroundColor = kUIColorForSubmitButtonBackground\n-        label.layer.cornerRadius = 5\n-        label.clipsToBounds = true\n-        label.text = \"\"\n-        return label\n-    }\n-\n-    func checkIfNotificationEnabled() {\n-        var notificationEnabledFromAppSettings = false\n-\n-        // checking the app settings\n-        let notificationType = UIApplication.shared.currentUserNotificationSettings!.types\n-        if notificationType == [] {\n-            print(\"notifications are NOT enabled\")\n-        } else {\n-            print(\"notifications are enabled\")\n-            notificationEnabledFromAppSettings = true\n-        }\n-\n-        if (User.currentUser.settings?.remoteNotifications)!,\n-            (User.currentUser.settings?.localNotifications)!,\n-            notificationEnabledFromAppSettings { // Notifications are enabled\n-            // Do Nothing\n-        } else { // Notification is Disabled\n-            let ud = UserDefaults.standard\n-            let previousDate = ud.object(forKey: \"NotificationRemainder\") as? Date\n-            let todayDate = Date()\n-            var daysLastSeen = 0\n-            if previousDate != nil {\n-                daysLastSeen = Schedule().getNumberOfDaysBetween(startDate: previousDate!, endDate: todayDate)\n-            }\n-\n-            if daysLastSeen >= 7 { // Notification is disabled for 7 or more Days\n-                UIUtilities.showAlertWithTitleAndMessage(title: NSLocalizedString(\"FDA My Studies\", comment: \"\") as NSString, message: NSLocalizedString(kMessageAppNotificationOffRemainder, comment: \"\") as NSString)\n-\n-                ud.set(Date(), forKey: \"NotificationRemainder\")\n-                ud.synchronize()\n-            }\n-        }\n-    }\n-\n-    /**\n-     Used to load the test data from Studylist of type json\n-     */\n-    func loadTestData() {\n-        let filePath = Bundle.main.path(forResource: \"StudyList\", ofType: \"json\")\n-        let data = NSData(contentsOfFile: filePath!)\n-\n-        do {\n-            let response = try JSONSerialization.jsonObject(with: data! as Data, options: []) as? [String: Any]\n-\n-            let studies = (response?[kStudies] as? [[String: Any]])!\n-            var listOfStudies: [Study] = []\n-            for study in studies {\n-                let studyModelObj = Study(studyDetail: study)\n-                listOfStudies.append(studyModelObj)\n-            }\n-\n-            // assgin to Gateway\n-            Gateway.instance.studies = listOfStudies\n-\n-        } catch {\n-            print(\"json error: \\(error.localizedDescription)\")\n-        }\n+    if ispasscodePending == true {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 353}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0MDU4NA==", "bodyText": "typo", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391740584", "createdAt": "2020-03-12T16:27:39Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/StudyUI/StudyListViewController.swift", "diffHunk": "@@ -1,1154 +1,1133 @@\n-/*\n- License Agreement for FDA My Studies\n- Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n- hereby granted, free of charge, to any person obtaining a copy of this software and associated\n- documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n- Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n- conditions:\n- The above copyright notice and this permission notice shall be included in all copies or substantial\n- portions of the Software.\n- Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n- Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n- THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n- PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n- OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n- OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import IQKeyboardManagerSwift\n import UIKit\n \n-let kHelperTextForFilteredStudiesNotFound = \"Sorry, no Studies found. Please try different Filter Options\"\n-let kHelperTextForSearchedStudiesNotFound = \"Sorry, no Studies found. Please check the spelling or try a different search.\"\n+let kHelperTextForFilteredStudiesNotFound\n+  = \"No study found.\\nPlease try different Filter Options.\"\n \n-let kHelperTextForOffline = \"Sorry, no studies available right now. Please remain signed in to get notified when there are new studies available.\"\n+let kHelperTextForSearchedStudiesNotFound\n+  = \"No study found.\\nPlease check the spelling or try a different search.\"\n+\n+let kHelperTextForOffline\n+  = \"No study available right now.\\nPlease remain signed in to get notified when there are new studies available.\"\n \n let kNotificationViewControllerIdentifier = \"NotificationViewControllerIdentifier\"\n \n class StudyListViewController: UIViewController {\n-    \n-    // MARK:- Outlets\n-    \n-    @IBOutlet var tableView: UITableView?\n-    @IBOutlet var labelHelperText: UILabel!\n-\n-    var refreshControl: UIRefreshControl? // for refreshing studylist\n-\n-    var studyListRequestFailed = false\n-    var searchView: SearchBarView?\n-\n-    var isComingFromFilterScreen: Bool = false\n-    var studiesList: [Study] = []\n-\n-    var previousStudyList: [Study] = []\n-\n-    var allStudyList: [Study] = [] // Gatewaystudylist\n-    override var preferredStatusBarStyle: UIStatusBarStyle {\n-        return .default\n-    }\n-\n-    // MARK: - Viewcontroller lifecycle\n-\n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-\n-        var infoDict: NSDictionary?\n-        if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n-            infoDict = NSDictionary(contentsOfFile: path)\n-        }\n-        let navTitle = infoDict![\"ProductTitleName\"] as! String\n-        let titleLabel = UILabel()\n-        titleLabel.text = NSLocalizedString(navTitle, comment: \"\")\n-        titleLabel.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n-        titleLabel.textAlignment = .left\n-        titleLabel.textColor = Utilities.getUIColorFromHex(0x007CBA)\n-        titleLabel.frame = CGRect(x: 0, y: 0, width: 300, height: 44)\n-\n-        navigationItem.titleView = titleLabel\n-\n-        // self.loadTestData()\n-        // get Profile data to check for passcode\n-        // Condition missing\n \n-        let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+  // MARK: - Outlets\n \n-        \n-        if User.currentUser.userType == .FDAUser, User.currentUser.settings?.localNotifications == true {\n-            /* Will come next next phase */\n-            //appDelegate.checkForAppReopenNotification()\n-        }\n+  @IBOutlet weak var tableView: UITableView!\n \n-        isComingFromFilterScreen = false\n-        // IQKeyboardManager.sharedManager().enable = true\n+  @IBOutlet weak var labelHelperText: UILabel!\n \n-        refreshControl = UIRefreshControl()\n-        refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n-        refreshControl?.addTarget(self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n-        tableView?.addSubview(refreshControl!)\n-    }\n+  lazy var studyListRequestFailed = false\n+  var searchView: SearchBarView?\n+  lazy var isComingFromFilterScreen: Bool = false\n+  lazy var studiesList: [Study] = []\n+  lazy var previousStudyList: [Study] = []\n \n-    override func viewWillAppear(_: Bool) {\n-        if isComingFromFilterScreen {\n-            isComingFromFilterScreen = false\n-            return\n-        }\n-        addRightNavigationItem()\n-        let appdelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+  /// Gatewaystudylist\n+  lazy var allStudyList: [Study] = []\n \n-        Study.currentStudy = nil\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n \n-        let ud = UserDefaults.standard\n-        var ispasscodePending: Bool? = false\n+  // MARK: - Viewcontroller lifecycle\n \n-        // Checking if User has missed out setting the passcode/TouchId\n-        if ud.value(forKey: kPasscodeIsPending) != nil {\n-            ispasscodePending = (ud.value(forKey: kPasscodeIsPending) as? Bool)!\n-        }\n-\n-        if ispasscodePending == true {\n-            if User.currentUser.userType == .FDAUser {\n-                tableView?.isHidden = true\n-                // Fetch the User Profile\n-                UserServices().getUserProfile(self as NMWebServiceDelegate)\n-            }\n-        }\n-\n-        labelHelperText.isHidden = true\n-        setNavigationBarItem()\n-        navigationController?.setNavigationBarHidden(false, animated: true)\n-        navigationController?.navigationBar.isHidden = false\n-\n-        if User.currentUser.userType == .FDAUser { // For LoggedIn User\n-            tableView?.estimatedRowHeight = 145\n-            tableView?.rowHeight = UITableView.automaticDimension\n-\n-            if (fdaSlideMenuController()?.isLeftOpen())! {\n-                // Do Nothing\n-            } else {\n-                // Fetch User Preferences\n-                sendRequestToGetUserPreference()\n-            }\n-        } else { // For ananomous User\n-            tableView?.estimatedRowHeight = 140\n-            tableView?.rowHeight = UITableView.automaticDimension\n-            // Fetch StudyList\n-            sendRequestToGetStudyList()\n-        }\n-\n-        // UIApplication.shared.statusBarStyle = .default\n-        setNeedsStatusBarAppearanceUpdate()\n-        // Checking if registering notification is pending\n-        if ud.value(forKey: kNotificationRegistrationIsPending) != nil, ud.bool(forKey: kNotificationRegistrationIsPending) == true {\n-            appdelegate.askForNotification()\n-        }\n-\n-        // Handling StudyList Request Failure condition\n-        if studyListRequestFailed {\n-            labelHelperText.isHidden = false\n-            labelHelperText.text = kHelperTextForOffline\n-        }\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    addNavigationTitle()\n+    isComingFromFilterScreen = false\n+    DispatchQueue.main.async { [weak self] in\n+      self?.setupStudyListTableView()\n     }\n+  }\n \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  override func viewDidAppear(_ animated: Bool) {\n+    super.viewDidAppear(animated)\n+    if isComingFromFilterScreen {\n+      isComingFromFilterScreen = false\n+      return\n     }\n+    addRightNavigationItem()\n+    let appdelegate = (UIApplication.shared.delegate as? AppDelegate)!\n \n-    // MARK: - Helper Methods\n+    Study.currentStudy = nil\n \n-    /**\n-     addRightNavigationItem method updates the navigation bar items for current controller , by adding Notification Button, Notification Indicator & Filter Button\n-     */\n-    func addRightNavigationItem() {\n-        let view = UIView(frame: CGRect(x: 0, y: 4, width: 110, height: 40))\n+    let ud = UserDefaults.standard\n+    var ispasscodePending: Bool? = false\n \n-        // Notification Button\n-        let button = addNotificationButton()\n-        view.addSubview(button)\n-        button.isExclusiveTouch = true\n-\n-        // notification Indicator\n-        let label = addNotificationIndication()\n-        view.addSubview(label)\n-\n-        let ud = UserDefaults.standard\n-        let showNotification = ud.bool(forKey: kShowNotification)\n-\n-        if showNotification {\n-            label.isHidden = false\n-        } else {\n-            label.isHidden = true\n-        }\n-\n-        //  filter Button\n-        let filterButton = addFilterButton()\n-        view.addSubview(filterButton)\n-        filterButton.isExclusiveTouch = true\n-\n-        //  Search Button\n-        let searchButton = addSearchButton()\n-        view.addSubview(searchButton)\n-        searchButton.isExclusiveTouch = true\n-\n-        let barButton = UIBarButtonItem(customView: view)\n-        navigationItem.rightBarButtonItems = [barButton]\n-    }\n-\n-    func addSearchButton() -> UIButton {\n-        let searchButton = UIButton(type: .custom)\n-        searchButton.setImage(#imageLiteral(resourceName: \"search_small\"), for: UIControl.State.normal)\n-        searchButton.addTarget(self, action: #selector(searchButtonAction(_:)), for: .touchUpInside)\n-        searchButton.frame = CGRect(x: 0, y: 4, width: 30, height: 30)\n-        return searchButton\n+    // Checking if User has missed out setting the passcode/TouchId\n+    if ud.value(forKey: kPasscodeIsPending) != nil {\n+      ispasscodePending = (ud.value(forKey: kPasscodeIsPending) as? Bool)!\n     }\n \n-    func addFilterButton() -> UIButton {\n-        let filterButton = UIButton(type: .custom)\n-        filterButton.setImage(#imageLiteral(resourceName: \"filterIcon\"), for: UIControl.State.normal)\n-        filterButton.addTarget(self, action: #selector(filterAction(_:)), for: .touchUpInside)\n-        filterButton.frame = CGRect(x: 40, y: 4, width: 30, height: 30)\n-        return filterButton\n-    }\n-\n-    func addNotificationButton() -> UIButton {\n-        let button = UIButton(type: .custom)\n-\n-        button.setImage(#imageLiteral(resourceName: \"notification_grey\"), for: UIControl.State.normal)\n-        button.addTarget(self, action: #selector(buttonActionNotification(_:)), for: .touchUpInside)\n-        button.frame = CGRect(x: 80, y: 4, width: 30, height: 30)\n-        return button\n-    }\n-\n-    func addNotificationIndication() -> UILabel {\n-        let label = UILabel(frame: CGRect(x: 100, y: 4, width: 10, height: 10))\n-        label.font = UIFont.systemFont(ofSize: 10)\n-        label.textColor = UIColor.white\n-\n-        label.textAlignment = NSTextAlignment.center\n-        label.backgroundColor = kUIColorForSubmitButtonBackground\n-        label.layer.cornerRadius = 5\n-        label.clipsToBounds = true\n-        label.text = \"\"\n-        return label\n-    }\n-\n-    func checkIfNotificationEnabled() {\n-        var notificationEnabledFromAppSettings = false\n-\n-        // checking the app settings\n-        let notificationType = UIApplication.shared.currentUserNotificationSettings!.types\n-        if notificationType == [] {\n-            print(\"notifications are NOT enabled\")\n-        } else {\n-            print(\"notifications are enabled\")\n-            notificationEnabledFromAppSettings = true\n-        }\n-\n-        if (User.currentUser.settings?.remoteNotifications)!,\n-            (User.currentUser.settings?.localNotifications)!,\n-            notificationEnabledFromAppSettings { // Notifications are enabled\n-            // Do Nothing\n-        } else { // Notification is Disabled\n-            let ud = UserDefaults.standard\n-            let previousDate = ud.object(forKey: \"NotificationRemainder\") as? Date\n-            let todayDate = Date()\n-            var daysLastSeen = 0\n-            if previousDate != nil {\n-                daysLastSeen = Schedule().getNumberOfDaysBetween(startDate: previousDate!, endDate: todayDate)\n-            }\n-\n-            if daysLastSeen >= 7 { // Notification is disabled for 7 or more Days\n-                UIUtilities.showAlertWithTitleAndMessage(title: NSLocalizedString(\"FDA My Studies\", comment: \"\") as NSString, message: NSLocalizedString(kMessageAppNotificationOffRemainder, comment: \"\") as NSString)\n-\n-                ud.set(Date(), forKey: \"NotificationRemainder\")\n-                ud.synchronize()\n-            }\n-        }\n-    }\n-\n-    /**\n-     Used to load the test data from Studylist of type json\n-     */\n-    func loadTestData() {\n-        let filePath = Bundle.main.path(forResource: \"StudyList\", ofType: \"json\")\n-        let data = NSData(contentsOfFile: filePath!)\n-\n-        do {\n-            let response = try JSONSerialization.jsonObject(with: data! as Data, options: []) as? [String: Any]\n-\n-            let studies = (response?[kStudies] as? [[String: Any]])!\n-            var listOfStudies: [Study] = []\n-            for study in studies {\n-                let studyModelObj = Study(studyDetail: study)\n-                listOfStudies.append(studyModelObj)\n-            }\n-\n-            // assgin to Gateway\n-            Gateway.instance.studies = listOfStudies\n-\n-        } catch {\n-            print(\"json error: \\(error.localizedDescription)\")\n-        }\n+    if ispasscodePending == true {\n+      if User.currentUser.userType == .FDAUser {\n+        tableView?.isHidden = true\n+        // Fetch the User Profile\n+        UserServices().getUserProfile(self as NMWebServiceDelegate)\n+      }\n     }\n \n-    /**\n-     checkIfFetelKickCountRunning method verifies whether if FetalKick Task is Still running and calculate the time difference.\n-     */\n-    func checkIfFetelKickCountRunning() {\n-        let ud = UserDefaults.standard\n-\n-        if ud.bool(forKey: \"FKC\"), ud.object(forKey: kFetalKickStartTimeStamp) != nil {\n-            let studyId = (ud.object(forKey: kFetalkickStudyId) as? String)!\n-            let study = Gateway.instance.studies?.filter { $0.studyId == studyId }.last\n-\n-            if study?.userParticipateState.status == .inProgress, study?.status == .Active {\n-                Study.updateCurrentStudy(study: study!)\n-                pushToStudyDashboard(animated: false)\n-            }\n-        } else {\n-            checkIfNotificationEnabled()\n-            if NotificationHandler.instance.studyId.count > 0 {\n-                let studyId = NotificationHandler.instance.studyId\n-                let study = Gateway.instance.studies?.filter { $0.studyId == studyId }.first\n-                Study.updateCurrentStudy(study: study!)\n-\n-                NotificationHandler.instance.studyId = \"\"\n-                performTaskBasedOnStudyStatus()\n-            }\n-        }\n+    labelHelperText.isHidden = true\n+    setNavigationBarItem()\n+    navigationController?.setNavigationBarHidden(false, animated: true)\n+    navigationController?.navigationBar.isHidden = false\n+\n+    if User.currentUser.userType == .FDAUser {  // For LoggedIn User\n+      tableView?.estimatedRowHeight = 145\n+      tableView?.rowHeight = UITableView.automaticDimension\n+\n+      if !(fdaSlideMenuController()?.isLeftOpen())! {\n+        sendRequestToGetUserPreference()\n+      }\n+    } else {  // For ananomous User\n+      tableView?.estimatedRowHeight = 140\n+      tableView?.rowHeight = UITableView.automaticDimension\n+      // Fetch StudyList\n+      sendRequestToGetStudyList()\n     }\n \n-    /**\n-     Navigate to notification screen\n-     */\n-    func navigateToNotifications() {\n-        let gatewayStoryBoard = UIStoryboard(name: kStoryboardIdentifierGateway, bundle: Bundle.main)\n-        let notificationController = (gatewayStoryBoard.instantiateViewController(withIdentifier: kNotificationViewControllerIdentifier) as? NotificationViewController)!\n-        navigationController?.pushViewController(notificationController, animated: true)\n+    // UIApplication.shared.statusBarStyle = .default\n+    setNeedsStatusBarAppearanceUpdate()\n+    // Checking if registering notification is pending\n+    if ud.value(forKey: kNotificationRegistrationIsPending) != nil,\n+      ud.bool(forKey: kNotificationRegistrationIsPending) == true {\n+      appdelegate.askForNotification()\n     }\n \n-    /**\n-     Navigate to StudyHomeViewController screen\n-     */\n-    func navigateToStudyHome() {\n-        let studyStoryBoard = UIStoryboard(name: kStudyStoryboard, bundle: Bundle.main)\n-        let studyHomeController = (studyStoryBoard.instantiateViewController(withIdentifier: String(describing: StudyHomeViewController.classForCoder())) as? StudyHomeViewController)!\n-        studyHomeController.delegate = self\n-        navigationController?.pushViewController(studyHomeController, animated: true)\n+    // Handling StudyList Request Failure condition\n+    if studyListRequestFailed {\n+      labelHelperText.isHidden = false\n+      labelHelperText.text = kHelperTextForOffline\n     }\n+  }\n \n-    /**\n-     Navigate the screen to Study Dashboard tabbar viewcontroller screen\n-     */\n-    func pushToStudyDashboard(animated: Bool = true) {\n-        let studyStoryBoard = UIStoryboard(name: kStudyStoryboard, bundle: Bundle.main)\n+  // MARK: - UI Utils\n \n-        let studyDashboard = (studyStoryBoard.instantiateViewController(withIdentifier: kStudyDashboardTabbarControllerIdentifier) as? StudyDashboardTabbarViewController)!\n+  /// To update the navigation bar items , by adding Notification Button, Notification Indicator & Filter Button.\n+  func addRightNavigationItem() {\n+    let view = UIView(frame: CGRect(x: 0, y: 4, width: 110, height: 40))\n \n-        navigationController?.navigationBar.isHidden = true\n-        navigationController?.pushViewController(studyDashboard, animated: animated)\n-    }\n+    // Notification Button\n+    let button = addNotificationButton()\n+    view.addSubview(button)\n+    button.isExclusiveTouch = true\n \n-    /**\n-     Method to display taskViewController for passcode setup if\n-     passcode setup is enabled,called only once after signin.\n-     */\n-    func setPassCode() {\n-        // Remove Passcode if already exist\n-        ORKPasscodeViewController.removePasscodeFromKeychain()\n-\n-        let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n-        passcodeStep.passcodeType = .type4Digit\n-\n-        let task = ORKOrderedTask(identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n-        let taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n-        taskViewController.delegate = self\n-        taskViewController.isNavigationBarHidden = true\n-        taskViewController.modalPresentationStyle = .fullScreen\n-        navigationController?.present(taskViewController, animated: false, completion: {\n-            self.tableView?.isHidden = false\n-        })\n-    }\n+    // notification Indicator\n+    let label = addNotificationIndication()\n+    view.addSubview(label)\n \n-    /**\n-     Load the study data from Database\n-     */\n-    func loadStudiesFromDatabase() {\n-        Logger.sharedInstance.info(\"Fetching Studies From DB\")\n-        DBHandler.loadStudyListFromDatabase { studies in\n-            if studies.count > 0 {\n-                self.tableView?.isHidden = false\n-                \n-//                var sortedstudies2 = studies.sorted(by: { $0.name!.lowercased() < $1.name!.lowercased() })\n-            \n-                \n-//               Logger.sharedInstance.info(\"Sorting Studies\")\n-//                sortedstudies2 = sortedstudies2.sorted(by: { (study1: Study, study2: Study) -> Bool in\n-//                    // sorting based on UserParticipation status\n-//                    if study1.status == study2.status {\n-//                        return (study1.userParticipateState.status.sortIndex < study2.userParticipateState.status.sortIndex)\n-//                    }\n-//                    return (study1.status.sortIndex < study2.status.sortIndex)\n-//                })\n-                self.studiesList = studies\n-                self.tableView?.reloadData()\n-                Logger.sharedInstance.info(\"Studies displayed to user\")\n-\n-                self.previousStudyList = studies\n-                self.allStudyList = studies\n-                Gateway.instance.studies = studies\n-\n-                // Applying Filters\n-                if StudyFilterHandler.instance.previousAppliedFilters.count > 0 {\n-                    let previousCollectionData = StudyFilterHandler.instance.previousAppliedFilters\n-\n-                    if User.currentUser.userType == .FDAUser {\n-                        self.appliedFilter(studyStatus: previousCollectionData.first!, pariticipationsStatus: previousCollectionData[2], categories: previousCollectionData[3], searchText: \"\", bookmarked: previousCollectionData[1].count > 0 ? true : false)\n-                    } else {\n-                        self.appliedFilter(studyStatus: previousCollectionData.first!, pariticipationsStatus: [], categories: previousCollectionData[1], searchText: \"\", bookmarked: false)\n-                    }\n-                } else {\n-                    let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-\n-                    appDelegate.setDefaultFilters(previousCollectionData: [])\n-\n-                    // using default Filters\n-                    let filterStrings = appDelegate.getDefaultFilterStrings()\n-\n-                    self.appliedFilter(studyStatus: filterStrings.studyStatus, pariticipationsStatus: filterStrings.pariticipationsStatus, categories: filterStrings.categories, searchText: filterStrings.searchText, bookmarked: filterStrings.bookmark)\n-                }\n-                self.checkIfFetelKickCountRunning()\n-            } else {\n-                if !self.studyListRequestFailed {\n-                    self.labelHelperText.isHidden = true\n-                    self.tableView?.isHidden = false\n-                    self.studyListRequestFailed = false\n-\n-                    self.sendRequestToGetStudyList()\n-                } else {\n-                    self.tableView?.isHidden = true\n-                    self.labelHelperText.isHidden = false\n-                    self.labelHelperText.text = kHelperTextForOffline\n-                }\n-            }\n-        }\n-    }\n+    let ud = UserDefaults.standard\n+    let showNotification = ud.bool(forKey: kShowNotification)\n \n-    /**\n-     Sort Studies based on the Study Status\n-     */\n-    func getSortedStudies(studies: [Study]) -> [Study] {\n-        var sortedstudies2 = studies.sorted(by: { $0.name!.lowercased() < $1.name!.lowercased() })\n-        sortedstudies2 = sortedstudies2.sorted(by: { (study1: Study, study2: Study) -> Bool in\n-\n-            if study1.status == study2.status {\n-                return (study1.userParticipateState.status.sortIndex < study2.userParticipateState.status.sortIndex)\n-            }\n-            return (study1.status.sortIndex < study2.status.sortIndex)\n-        })\n-        return sortedstudies2\n+    if showNotification {\n+      label.isHidden = false\n+    } else {\n+      label.isHidden = true\n     }\n \n-    // MARK: - Button Actions\n-\n-    /**\n-     Navigate to notification screen on button clicked\n-     @param sender    accepts UIBarButtonItem in sender\n-     */\n-    @IBAction func buttonActionNotification(_: UIBarButtonItem) {\n-        navigateToNotifications()\n+    //  filter Button\n+    let filterButton = addFilterButton()\n+    view.addSubview(filterButton)\n+    filterButton.isExclusiveTouch = true\n+\n+    //  Search Button\n+    let searchButton = addSearchButton()\n+    view.addSubview(searchButton)\n+    searchButton.isExclusiveTouch = true\n+\n+    let barButton = UIBarButtonItem(customView: view)\n+    navigationItem.rightBarButtonItems = [barButton]\n+  }\n+\n+  func addSearchButton() -> UIButton {\n+    let searchButton = UIButton(type: .custom)\n+    searchButton.setImage(\n+      #imageLiteral(resourceName: \"search_small\"), for: UIControl.State.normal)\n+    searchButton.addTarget(self, action: #selector(searchButtonAction(_:)), for: .touchUpInside)\n+    searchButton.frame = CGRect(x: 0, y: 4, width: 30, height: 30)\n+    return searchButton\n+  }\n+\n+  func addFilterButton() -> UIButton {\n+    let filterButton = UIButton(type: .custom)\n+    filterButton.setImage(\n+      #imageLiteral(resourceName: \"filterIcon\"), for: UIControl.State.normal)\n+    filterButton.addTarget(self, action: #selector(filterAction(_:)), for: .touchUpInside)\n+    filterButton.frame = CGRect(x: 40, y: 4, width: 30, height: 30)\n+    return filterButton\n+  }\n+\n+  func addNotificationButton() -> UIButton {\n+    let button = UIButton(type: .custom)\n+\n+    button.setImage(\n+      #imageLiteral(resourceName: \"notification_grey\"), for: UIControl.State.normal)\n+    button.addTarget(self, action: #selector(buttonActionNotification(_:)), for: .touchUpInside)\n+    button.frame = CGRect(x: 80, y: 4, width: 30, height: 30)\n+    return button\n+  }\n+\n+  func addNotificationIndication() -> UILabel {\n+    let label = UILabel(frame: CGRect(x: 100, y: 4, width: 10, height: 10))\n+    label.font = UIFont.systemFont(ofSize: 10)\n+    label.textColor = UIColor.white\n+\n+    label.textAlignment = NSTextAlignment.center\n+    label.backgroundColor = kUIColorForSubmitButtonBackground\n+    label.layer.cornerRadius = 5\n+    label.clipsToBounds = true\n+    label.text = \"\"\n+    return label\n+  }\n+\n+  /// Add the navigation title from the branding plist.\n+  fileprivate func addNavigationTitle() {\n+    var infoDict: NSDictionary?\n+    if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n+      infoDict = NSDictionary(contentsOfFile: path)\n     }\n-\n-    @objc func refresh(sender _: AnyObject) {\n-        sendRequestToGetStudyList()\n+    let navTitle = infoDict![\"ProductTitleName\"] as! String\n+    let titleLabel = UILabel()\n+    titleLabel.text = NSLocalizedString(navTitle, comment: \"\")\n+    titleLabel.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n+    titleLabel.textAlignment = .left\n+    titleLabel.textColor = Utilities.getUIColorFromHex(0x007CBA)\n+    titleLabel.frame = CGRect(x: 0, y: 0, width: 300, height: 44)\n+\n+    navigationItem.titleView = titleLabel\n+  }\n+\n+  fileprivate func setupStudyListTableView() {\n+    let refresher = UIRefreshControl()\n+    refresher.addTarget(self, action: #selector(sendRequestToGetStudyList), for: .valueChanged)\n+    refresher.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n+    tableView.refreshControl = refresher\n+  }\n+\n+  /// Used to add left bar button item.\n+  func addLeftBarButton() {\n+    let button = UIButton(type: .custom)\n+    button.setTitle(\"FDA LISTENS!\", for: .normal)\n+    button.titleLabel?.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n+    button.frame = CGRect(x: 0, y: 0, width: 120, height: 30)\n+    button.contentHorizontalAlignment = .left\n+    button.setTitleColor(Utilities.getUIColorFromHex(0x007CBA), for: .normal)\n+\n+    let barItem = UIBarButtonItem(customView: button)\n+\n+    navigationItem.setLeftBarButton(barItem, animated: true)\n+  }\n+\n+  /// Used to add right bar button item.\n+  func addRightBarButton() {\n+    let button = UIButton(type: .custom)\n+    button.setImage(#imageLiteral(resourceName: \"filter_icn\"), for: .normal)\n+\n+    button.frame = CGRect(x: 0, y: 0, width: 19, height: 22.5)\n+    let barItem = UIBarButtonItem(customView: button)\n+\n+    navigationItem.setRightBarButton(barItem, animated: true)\n+  }\n+\n+  // MARK: - Utils\n+  func checkIfNotificationEnabled() {\n+\n+    var notificationEnabledFromAppSettings = false\n+    // Checking the app notification settings.\n+    LocalNotification.notificationsEnabled { (status) in\n+      notificationEnabledFromAppSettings = status\n     }\n \n-    /**\n-     Navigate to StudyFilter screen on button clicked\n-     @param sender    accepts UIBarButtonItem in sender\n-     */\n-    @IBAction func filterAction(_: UIBarButtonItem) {\n-        isComingFromFilterScreen = true\n-        performSegue(withIdentifier: filterListSegue, sender: nil)\n+    if (User.currentUser.settings?.remoteNotifications)!,\n+      (User.currentUser.settings?.localNotifications)!,\n+      notificationEnabledFromAppSettings {  // Notifications are enabled\n+      // Do Nothing\n+    } else {  // Notification is Disabled\n+      let ud = UserDefaults.standard\n+      let previousDate = ud.object(forKey: \"NotificationRemainder\") as? Date\n+      let todayDate = Date()\n+      var daysLastSeen = 0\n+      if previousDate != nil {\n+        daysLastSeen = Schedule().getNumberOfDaysBetween(\n+          startDate: previousDate!, endDate: todayDate)\n+      }\n+\n+      if daysLastSeen >= 7 {  // Notification is disabled for 7 or more Days\n+        UIUtilities.showAlertWithTitleAndMessage(\n+          title: NSLocalizedString(\"FDA My Studies\", comment: \"\") as NSString,\n+          message: NSLocalizedString(kMessageAppNotificationOffRemainder, comment: \"\")\n+            as NSString)\n+\n+        ud.set(Date(), forKey: \"NotificationRemainder\")\n+        ud.synchronize()\n+      }\n     }\n+  }\n \n-    @IBAction func searchButtonAction(_: UIBarButtonItem) {\n-        searchView = SearchBarView.instanceFromNib(frame: CGRect(x: 0, y: -200, width: view.frame.size.width, height: 64.0), detail: nil)\n-\n-        UIView.animate(withDuration: 0.2,\n-                       delay: 0.0,\n-                       options: UIView.AnimationOptions.preferredFramesPerSecond60,\n-                       animations: { () -> Void in\n-\n-                           let y: CGFloat = DeviceType.IS_IPHONE_X_OR_HIGH ? 20.0 : 0.0\n-\n-                           self.searchView?.frame = CGRect(x: 0, y: y, width: self.view.frame.size.width, height: 64.0)\n+  /// Used to load the test data from Studylist of type json.\n+  func loadTestData() {\n+    let filePath = Bundle.main.path(forResource: \"StudyList\", ofType: \"json\")\n+    let data = NSData(contentsOfFile: filePath!)\n \n-                           self.searchView?.textFieldSearch?.becomeFirstResponder()\n-                           self.searchView?.delegate = self\n+    do {\n+      let response = try JSONSerialization.jsonObject(with: data! as Data, options: [])\n+        as? [String: Any]\n \n-                           self.slideMenuController()?.leftPanGesture?.isEnabled = false\n+      let studies = (response?[kStudies] as? [[String: Any]])!\n+      var listOfStudies: [Study] = []\n+      for study in studies {\n+        let studyModelObj = Study(studyDetail: study)\n+        listOfStudies.append(studyModelObj)\n+      }\n \n-                           self.navigationController?.view.addSubview(self.searchView!)\n+      // assgin to Gateway", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 752}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0MDczOA==", "bodyText": "error log should be .error", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391740738", "createdAt": "2020-03-12T16:27:54Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/StudyUI/StudyListViewController.swift", "diffHunk": "@@ -1,1154 +1,1133 @@\n-/*\n- License Agreement for FDA My Studies\n- Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n- hereby granted, free of charge, to any person obtaining a copy of this software and associated\n- documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n- Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n- conditions:\n- The above copyright notice and this permission notice shall be included in all copies or substantial\n- portions of the Software.\n- Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n- Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n- THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n- PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n- OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n- OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import IQKeyboardManagerSwift\n import UIKit\n \n-let kHelperTextForFilteredStudiesNotFound = \"Sorry, no Studies found. Please try different Filter Options\"\n-let kHelperTextForSearchedStudiesNotFound = \"Sorry, no Studies found. Please check the spelling or try a different search.\"\n+let kHelperTextForFilteredStudiesNotFound\n+  = \"No study found.\\nPlease try different Filter Options.\"\n \n-let kHelperTextForOffline = \"Sorry, no studies available right now. Please remain signed in to get notified when there are new studies available.\"\n+let kHelperTextForSearchedStudiesNotFound\n+  = \"No study found.\\nPlease check the spelling or try a different search.\"\n+\n+let kHelperTextForOffline\n+  = \"No study available right now.\\nPlease remain signed in to get notified when there are new studies available.\"\n \n let kNotificationViewControllerIdentifier = \"NotificationViewControllerIdentifier\"\n \n class StudyListViewController: UIViewController {\n-    \n-    // MARK:- Outlets\n-    \n-    @IBOutlet var tableView: UITableView?\n-    @IBOutlet var labelHelperText: UILabel!\n-\n-    var refreshControl: UIRefreshControl? // for refreshing studylist\n-\n-    var studyListRequestFailed = false\n-    var searchView: SearchBarView?\n-\n-    var isComingFromFilterScreen: Bool = false\n-    var studiesList: [Study] = []\n-\n-    var previousStudyList: [Study] = []\n-\n-    var allStudyList: [Study] = [] // Gatewaystudylist\n-    override var preferredStatusBarStyle: UIStatusBarStyle {\n-        return .default\n-    }\n-\n-    // MARK: - Viewcontroller lifecycle\n-\n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-\n-        var infoDict: NSDictionary?\n-        if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n-            infoDict = NSDictionary(contentsOfFile: path)\n-        }\n-        let navTitle = infoDict![\"ProductTitleName\"] as! String\n-        let titleLabel = UILabel()\n-        titleLabel.text = NSLocalizedString(navTitle, comment: \"\")\n-        titleLabel.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n-        titleLabel.textAlignment = .left\n-        titleLabel.textColor = Utilities.getUIColorFromHex(0x007CBA)\n-        titleLabel.frame = CGRect(x: 0, y: 0, width: 300, height: 44)\n-\n-        navigationItem.titleView = titleLabel\n-\n-        // self.loadTestData()\n-        // get Profile data to check for passcode\n-        // Condition missing\n \n-        let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+  // MARK: - Outlets\n \n-        \n-        if User.currentUser.userType == .FDAUser, User.currentUser.settings?.localNotifications == true {\n-            /* Will come next next phase */\n-            //appDelegate.checkForAppReopenNotification()\n-        }\n+  @IBOutlet weak var tableView: UITableView!\n \n-        isComingFromFilterScreen = false\n-        // IQKeyboardManager.sharedManager().enable = true\n+  @IBOutlet weak var labelHelperText: UILabel!\n \n-        refreshControl = UIRefreshControl()\n-        refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n-        refreshControl?.addTarget(self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n-        tableView?.addSubview(refreshControl!)\n-    }\n+  lazy var studyListRequestFailed = false\n+  var searchView: SearchBarView?\n+  lazy var isComingFromFilterScreen: Bool = false\n+  lazy var studiesList: [Study] = []\n+  lazy var previousStudyList: [Study] = []\n \n-    override func viewWillAppear(_: Bool) {\n-        if isComingFromFilterScreen {\n-            isComingFromFilterScreen = false\n-            return\n-        }\n-        addRightNavigationItem()\n-        let appdelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+  /// Gatewaystudylist\n+  lazy var allStudyList: [Study] = []\n \n-        Study.currentStudy = nil\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n \n-        let ud = UserDefaults.standard\n-        var ispasscodePending: Bool? = false\n+  // MARK: - Viewcontroller lifecycle\n \n-        // Checking if User has missed out setting the passcode/TouchId\n-        if ud.value(forKey: kPasscodeIsPending) != nil {\n-            ispasscodePending = (ud.value(forKey: kPasscodeIsPending) as? Bool)!\n-        }\n-\n-        if ispasscodePending == true {\n-            if User.currentUser.userType == .FDAUser {\n-                tableView?.isHidden = true\n-                // Fetch the User Profile\n-                UserServices().getUserProfile(self as NMWebServiceDelegate)\n-            }\n-        }\n-\n-        labelHelperText.isHidden = true\n-        setNavigationBarItem()\n-        navigationController?.setNavigationBarHidden(false, animated: true)\n-        navigationController?.navigationBar.isHidden = false\n-\n-        if User.currentUser.userType == .FDAUser { // For LoggedIn User\n-            tableView?.estimatedRowHeight = 145\n-            tableView?.rowHeight = UITableView.automaticDimension\n-\n-            if (fdaSlideMenuController()?.isLeftOpen())! {\n-                // Do Nothing\n-            } else {\n-                // Fetch User Preferences\n-                sendRequestToGetUserPreference()\n-            }\n-        } else { // For ananomous User\n-            tableView?.estimatedRowHeight = 140\n-            tableView?.rowHeight = UITableView.automaticDimension\n-            // Fetch StudyList\n-            sendRequestToGetStudyList()\n-        }\n-\n-        // UIApplication.shared.statusBarStyle = .default\n-        setNeedsStatusBarAppearanceUpdate()\n-        // Checking if registering notification is pending\n-        if ud.value(forKey: kNotificationRegistrationIsPending) != nil, ud.bool(forKey: kNotificationRegistrationIsPending) == true {\n-            appdelegate.askForNotification()\n-        }\n-\n-        // Handling StudyList Request Failure condition\n-        if studyListRequestFailed {\n-            labelHelperText.isHidden = false\n-            labelHelperText.text = kHelperTextForOffline\n-        }\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    addNavigationTitle()\n+    isComingFromFilterScreen = false\n+    DispatchQueue.main.async { [weak self] in\n+      self?.setupStudyListTableView()\n     }\n+  }\n \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  override func viewDidAppear(_ animated: Bool) {\n+    super.viewDidAppear(animated)\n+    if isComingFromFilterScreen {\n+      isComingFromFilterScreen = false\n+      return\n     }\n+    addRightNavigationItem()\n+    let appdelegate = (UIApplication.shared.delegate as? AppDelegate)!\n \n-    // MARK: - Helper Methods\n+    Study.currentStudy = nil\n \n-    /**\n-     addRightNavigationItem method updates the navigation bar items for current controller , by adding Notification Button, Notification Indicator & Filter Button\n-     */\n-    func addRightNavigationItem() {\n-        let view = UIView(frame: CGRect(x: 0, y: 4, width: 110, height: 40))\n+    let ud = UserDefaults.standard\n+    var ispasscodePending: Bool? = false\n \n-        // Notification Button\n-        let button = addNotificationButton()\n-        view.addSubview(button)\n-        button.isExclusiveTouch = true\n-\n-        // notification Indicator\n-        let label = addNotificationIndication()\n-        view.addSubview(label)\n-\n-        let ud = UserDefaults.standard\n-        let showNotification = ud.bool(forKey: kShowNotification)\n-\n-        if showNotification {\n-            label.isHidden = false\n-        } else {\n-            label.isHidden = true\n-        }\n-\n-        //  filter Button\n-        let filterButton = addFilterButton()\n-        view.addSubview(filterButton)\n-        filterButton.isExclusiveTouch = true\n-\n-        //  Search Button\n-        let searchButton = addSearchButton()\n-        view.addSubview(searchButton)\n-        searchButton.isExclusiveTouch = true\n-\n-        let barButton = UIBarButtonItem(customView: view)\n-        navigationItem.rightBarButtonItems = [barButton]\n-    }\n-\n-    func addSearchButton() -> UIButton {\n-        let searchButton = UIButton(type: .custom)\n-        searchButton.setImage(#imageLiteral(resourceName: \"search_small\"), for: UIControl.State.normal)\n-        searchButton.addTarget(self, action: #selector(searchButtonAction(_:)), for: .touchUpInside)\n-        searchButton.frame = CGRect(x: 0, y: 4, width: 30, height: 30)\n-        return searchButton\n+    // Checking if User has missed out setting the passcode/TouchId\n+    if ud.value(forKey: kPasscodeIsPending) != nil {\n+      ispasscodePending = (ud.value(forKey: kPasscodeIsPending) as? Bool)!\n     }\n \n-    func addFilterButton() -> UIButton {\n-        let filterButton = UIButton(type: .custom)\n-        filterButton.setImage(#imageLiteral(resourceName: \"filterIcon\"), for: UIControl.State.normal)\n-        filterButton.addTarget(self, action: #selector(filterAction(_:)), for: .touchUpInside)\n-        filterButton.frame = CGRect(x: 40, y: 4, width: 30, height: 30)\n-        return filterButton\n-    }\n-\n-    func addNotificationButton() -> UIButton {\n-        let button = UIButton(type: .custom)\n-\n-        button.setImage(#imageLiteral(resourceName: \"notification_grey\"), for: UIControl.State.normal)\n-        button.addTarget(self, action: #selector(buttonActionNotification(_:)), for: .touchUpInside)\n-        button.frame = CGRect(x: 80, y: 4, width: 30, height: 30)\n-        return button\n-    }\n-\n-    func addNotificationIndication() -> UILabel {\n-        let label = UILabel(frame: CGRect(x: 100, y: 4, width: 10, height: 10))\n-        label.font = UIFont.systemFont(ofSize: 10)\n-        label.textColor = UIColor.white\n-\n-        label.textAlignment = NSTextAlignment.center\n-        label.backgroundColor = kUIColorForSubmitButtonBackground\n-        label.layer.cornerRadius = 5\n-        label.clipsToBounds = true\n-        label.text = \"\"\n-        return label\n-    }\n-\n-    func checkIfNotificationEnabled() {\n-        var notificationEnabledFromAppSettings = false\n-\n-        // checking the app settings\n-        let notificationType = UIApplication.shared.currentUserNotificationSettings!.types\n-        if notificationType == [] {\n-            print(\"notifications are NOT enabled\")\n-        } else {\n-            print(\"notifications are enabled\")\n-            notificationEnabledFromAppSettings = true\n-        }\n-\n-        if (User.currentUser.settings?.remoteNotifications)!,\n-            (User.currentUser.settings?.localNotifications)!,\n-            notificationEnabledFromAppSettings { // Notifications are enabled\n-            // Do Nothing\n-        } else { // Notification is Disabled\n-            let ud = UserDefaults.standard\n-            let previousDate = ud.object(forKey: \"NotificationRemainder\") as? Date\n-            let todayDate = Date()\n-            var daysLastSeen = 0\n-            if previousDate != nil {\n-                daysLastSeen = Schedule().getNumberOfDaysBetween(startDate: previousDate!, endDate: todayDate)\n-            }\n-\n-            if daysLastSeen >= 7 { // Notification is disabled for 7 or more Days\n-                UIUtilities.showAlertWithTitleAndMessage(title: NSLocalizedString(\"FDA My Studies\", comment: \"\") as NSString, message: NSLocalizedString(kMessageAppNotificationOffRemainder, comment: \"\") as NSString)\n-\n-                ud.set(Date(), forKey: \"NotificationRemainder\")\n-                ud.synchronize()\n-            }\n-        }\n-    }\n-\n-    /**\n-     Used to load the test data from Studylist of type json\n-     */\n-    func loadTestData() {\n-        let filePath = Bundle.main.path(forResource: \"StudyList\", ofType: \"json\")\n-        let data = NSData(contentsOfFile: filePath!)\n-\n-        do {\n-            let response = try JSONSerialization.jsonObject(with: data! as Data, options: []) as? [String: Any]\n-\n-            let studies = (response?[kStudies] as? [[String: Any]])!\n-            var listOfStudies: [Study] = []\n-            for study in studies {\n-                let studyModelObj = Study(studyDetail: study)\n-                listOfStudies.append(studyModelObj)\n-            }\n-\n-            // assgin to Gateway\n-            Gateway.instance.studies = listOfStudies\n-\n-        } catch {\n-            print(\"json error: \\(error.localizedDescription)\")\n-        }\n+    if ispasscodePending == true {\n+      if User.currentUser.userType == .FDAUser {\n+        tableView?.isHidden = true\n+        // Fetch the User Profile\n+        UserServices().getUserProfile(self as NMWebServiceDelegate)\n+      }\n     }\n \n-    /**\n-     checkIfFetelKickCountRunning method verifies whether if FetalKick Task is Still running and calculate the time difference.\n-     */\n-    func checkIfFetelKickCountRunning() {\n-        let ud = UserDefaults.standard\n-\n-        if ud.bool(forKey: \"FKC\"), ud.object(forKey: kFetalKickStartTimeStamp) != nil {\n-            let studyId = (ud.object(forKey: kFetalkickStudyId) as? String)!\n-            let study = Gateway.instance.studies?.filter { $0.studyId == studyId }.last\n-\n-            if study?.userParticipateState.status == .inProgress, study?.status == .Active {\n-                Study.updateCurrentStudy(study: study!)\n-                pushToStudyDashboard(animated: false)\n-            }\n-        } else {\n-            checkIfNotificationEnabled()\n-            if NotificationHandler.instance.studyId.count > 0 {\n-                let studyId = NotificationHandler.instance.studyId\n-                let study = Gateway.instance.studies?.filter { $0.studyId == studyId }.first\n-                Study.updateCurrentStudy(study: study!)\n-\n-                NotificationHandler.instance.studyId = \"\"\n-                performTaskBasedOnStudyStatus()\n-            }\n-        }\n+    labelHelperText.isHidden = true\n+    setNavigationBarItem()\n+    navigationController?.setNavigationBarHidden(false, animated: true)\n+    navigationController?.navigationBar.isHidden = false\n+\n+    if User.currentUser.userType == .FDAUser {  // For LoggedIn User\n+      tableView?.estimatedRowHeight = 145\n+      tableView?.rowHeight = UITableView.automaticDimension\n+\n+      if !(fdaSlideMenuController()?.isLeftOpen())! {\n+        sendRequestToGetUserPreference()\n+      }\n+    } else {  // For ananomous User\n+      tableView?.estimatedRowHeight = 140\n+      tableView?.rowHeight = UITableView.automaticDimension\n+      // Fetch StudyList\n+      sendRequestToGetStudyList()\n     }\n \n-    /**\n-     Navigate to notification screen\n-     */\n-    func navigateToNotifications() {\n-        let gatewayStoryBoard = UIStoryboard(name: kStoryboardIdentifierGateway, bundle: Bundle.main)\n-        let notificationController = (gatewayStoryBoard.instantiateViewController(withIdentifier: kNotificationViewControllerIdentifier) as? NotificationViewController)!\n-        navigationController?.pushViewController(notificationController, animated: true)\n+    // UIApplication.shared.statusBarStyle = .default\n+    setNeedsStatusBarAppearanceUpdate()\n+    // Checking if registering notification is pending\n+    if ud.value(forKey: kNotificationRegistrationIsPending) != nil,\n+      ud.bool(forKey: kNotificationRegistrationIsPending) == true {\n+      appdelegate.askForNotification()\n     }\n \n-    /**\n-     Navigate to StudyHomeViewController screen\n-     */\n-    func navigateToStudyHome() {\n-        let studyStoryBoard = UIStoryboard(name: kStudyStoryboard, bundle: Bundle.main)\n-        let studyHomeController = (studyStoryBoard.instantiateViewController(withIdentifier: String(describing: StudyHomeViewController.classForCoder())) as? StudyHomeViewController)!\n-        studyHomeController.delegate = self\n-        navigationController?.pushViewController(studyHomeController, animated: true)\n+    // Handling StudyList Request Failure condition\n+    if studyListRequestFailed {\n+      labelHelperText.isHidden = false\n+      labelHelperText.text = kHelperTextForOffline\n     }\n+  }\n \n-    /**\n-     Navigate the screen to Study Dashboard tabbar viewcontroller screen\n-     */\n-    func pushToStudyDashboard(animated: Bool = true) {\n-        let studyStoryBoard = UIStoryboard(name: kStudyStoryboard, bundle: Bundle.main)\n+  // MARK: - UI Utils\n \n-        let studyDashboard = (studyStoryBoard.instantiateViewController(withIdentifier: kStudyDashboardTabbarControllerIdentifier) as? StudyDashboardTabbarViewController)!\n+  /// To update the navigation bar items , by adding Notification Button, Notification Indicator & Filter Button.\n+  func addRightNavigationItem() {\n+    let view = UIView(frame: CGRect(x: 0, y: 4, width: 110, height: 40))\n \n-        navigationController?.navigationBar.isHidden = true\n-        navigationController?.pushViewController(studyDashboard, animated: animated)\n-    }\n+    // Notification Button\n+    let button = addNotificationButton()\n+    view.addSubview(button)\n+    button.isExclusiveTouch = true\n \n-    /**\n-     Method to display taskViewController for passcode setup if\n-     passcode setup is enabled,called only once after signin.\n-     */\n-    func setPassCode() {\n-        // Remove Passcode if already exist\n-        ORKPasscodeViewController.removePasscodeFromKeychain()\n-\n-        let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n-        passcodeStep.passcodeType = .type4Digit\n-\n-        let task = ORKOrderedTask(identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n-        let taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n-        taskViewController.delegate = self\n-        taskViewController.isNavigationBarHidden = true\n-        taskViewController.modalPresentationStyle = .fullScreen\n-        navigationController?.present(taskViewController, animated: false, completion: {\n-            self.tableView?.isHidden = false\n-        })\n-    }\n+    // notification Indicator\n+    let label = addNotificationIndication()\n+    view.addSubview(label)\n \n-    /**\n-     Load the study data from Database\n-     */\n-    func loadStudiesFromDatabase() {\n-        Logger.sharedInstance.info(\"Fetching Studies From DB\")\n-        DBHandler.loadStudyListFromDatabase { studies in\n-            if studies.count > 0 {\n-                self.tableView?.isHidden = false\n-                \n-//                var sortedstudies2 = studies.sorted(by: { $0.name!.lowercased() < $1.name!.lowercased() })\n-            \n-                \n-//               Logger.sharedInstance.info(\"Sorting Studies\")\n-//                sortedstudies2 = sortedstudies2.sorted(by: { (study1: Study, study2: Study) -> Bool in\n-//                    // sorting based on UserParticipation status\n-//                    if study1.status == study2.status {\n-//                        return (study1.userParticipateState.status.sortIndex < study2.userParticipateState.status.sortIndex)\n-//                    }\n-//                    return (study1.status.sortIndex < study2.status.sortIndex)\n-//                })\n-                self.studiesList = studies\n-                self.tableView?.reloadData()\n-                Logger.sharedInstance.info(\"Studies displayed to user\")\n-\n-                self.previousStudyList = studies\n-                self.allStudyList = studies\n-                Gateway.instance.studies = studies\n-\n-                // Applying Filters\n-                if StudyFilterHandler.instance.previousAppliedFilters.count > 0 {\n-                    let previousCollectionData = StudyFilterHandler.instance.previousAppliedFilters\n-\n-                    if User.currentUser.userType == .FDAUser {\n-                        self.appliedFilter(studyStatus: previousCollectionData.first!, pariticipationsStatus: previousCollectionData[2], categories: previousCollectionData[3], searchText: \"\", bookmarked: previousCollectionData[1].count > 0 ? true : false)\n-                    } else {\n-                        self.appliedFilter(studyStatus: previousCollectionData.first!, pariticipationsStatus: [], categories: previousCollectionData[1], searchText: \"\", bookmarked: false)\n-                    }\n-                } else {\n-                    let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-\n-                    appDelegate.setDefaultFilters(previousCollectionData: [])\n-\n-                    // using default Filters\n-                    let filterStrings = appDelegate.getDefaultFilterStrings()\n-\n-                    self.appliedFilter(studyStatus: filterStrings.studyStatus, pariticipationsStatus: filterStrings.pariticipationsStatus, categories: filterStrings.categories, searchText: filterStrings.searchText, bookmarked: filterStrings.bookmark)\n-                }\n-                self.checkIfFetelKickCountRunning()\n-            } else {\n-                if !self.studyListRequestFailed {\n-                    self.labelHelperText.isHidden = true\n-                    self.tableView?.isHidden = false\n-                    self.studyListRequestFailed = false\n-\n-                    self.sendRequestToGetStudyList()\n-                } else {\n-                    self.tableView?.isHidden = true\n-                    self.labelHelperText.isHidden = false\n-                    self.labelHelperText.text = kHelperTextForOffline\n-                }\n-            }\n-        }\n-    }\n+    let ud = UserDefaults.standard\n+    let showNotification = ud.bool(forKey: kShowNotification)\n \n-    /**\n-     Sort Studies based on the Study Status\n-     */\n-    func getSortedStudies(studies: [Study]) -> [Study] {\n-        var sortedstudies2 = studies.sorted(by: { $0.name!.lowercased() < $1.name!.lowercased() })\n-        sortedstudies2 = sortedstudies2.sorted(by: { (study1: Study, study2: Study) -> Bool in\n-\n-            if study1.status == study2.status {\n-                return (study1.userParticipateState.status.sortIndex < study2.userParticipateState.status.sortIndex)\n-            }\n-            return (study1.status.sortIndex < study2.status.sortIndex)\n-        })\n-        return sortedstudies2\n+    if showNotification {\n+      label.isHidden = false\n+    } else {\n+      label.isHidden = true\n     }\n \n-    // MARK: - Button Actions\n-\n-    /**\n-     Navigate to notification screen on button clicked\n-     @param sender    accepts UIBarButtonItem in sender\n-     */\n-    @IBAction func buttonActionNotification(_: UIBarButtonItem) {\n-        navigateToNotifications()\n+    //  filter Button\n+    let filterButton = addFilterButton()\n+    view.addSubview(filterButton)\n+    filterButton.isExclusiveTouch = true\n+\n+    //  Search Button\n+    let searchButton = addSearchButton()\n+    view.addSubview(searchButton)\n+    searchButton.isExclusiveTouch = true\n+\n+    let barButton = UIBarButtonItem(customView: view)\n+    navigationItem.rightBarButtonItems = [barButton]\n+  }\n+\n+  func addSearchButton() -> UIButton {\n+    let searchButton = UIButton(type: .custom)\n+    searchButton.setImage(\n+      #imageLiteral(resourceName: \"search_small\"), for: UIControl.State.normal)\n+    searchButton.addTarget(self, action: #selector(searchButtonAction(_:)), for: .touchUpInside)\n+    searchButton.frame = CGRect(x: 0, y: 4, width: 30, height: 30)\n+    return searchButton\n+  }\n+\n+  func addFilterButton() -> UIButton {\n+    let filterButton = UIButton(type: .custom)\n+    filterButton.setImage(\n+      #imageLiteral(resourceName: \"filterIcon\"), for: UIControl.State.normal)\n+    filterButton.addTarget(self, action: #selector(filterAction(_:)), for: .touchUpInside)\n+    filterButton.frame = CGRect(x: 40, y: 4, width: 30, height: 30)\n+    return filterButton\n+  }\n+\n+  func addNotificationButton() -> UIButton {\n+    let button = UIButton(type: .custom)\n+\n+    button.setImage(\n+      #imageLiteral(resourceName: \"notification_grey\"), for: UIControl.State.normal)\n+    button.addTarget(self, action: #selector(buttonActionNotification(_:)), for: .touchUpInside)\n+    button.frame = CGRect(x: 80, y: 4, width: 30, height: 30)\n+    return button\n+  }\n+\n+  func addNotificationIndication() -> UILabel {\n+    let label = UILabel(frame: CGRect(x: 100, y: 4, width: 10, height: 10))\n+    label.font = UIFont.systemFont(ofSize: 10)\n+    label.textColor = UIColor.white\n+\n+    label.textAlignment = NSTextAlignment.center\n+    label.backgroundColor = kUIColorForSubmitButtonBackground\n+    label.layer.cornerRadius = 5\n+    label.clipsToBounds = true\n+    label.text = \"\"\n+    return label\n+  }\n+\n+  /// Add the navigation title from the branding plist.\n+  fileprivate func addNavigationTitle() {\n+    var infoDict: NSDictionary?\n+    if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n+      infoDict = NSDictionary(contentsOfFile: path)\n     }\n-\n-    @objc func refresh(sender _: AnyObject) {\n-        sendRequestToGetStudyList()\n+    let navTitle = infoDict![\"ProductTitleName\"] as! String\n+    let titleLabel = UILabel()\n+    titleLabel.text = NSLocalizedString(navTitle, comment: \"\")\n+    titleLabel.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n+    titleLabel.textAlignment = .left\n+    titleLabel.textColor = Utilities.getUIColorFromHex(0x007CBA)\n+    titleLabel.frame = CGRect(x: 0, y: 0, width: 300, height: 44)\n+\n+    navigationItem.titleView = titleLabel\n+  }\n+\n+  fileprivate func setupStudyListTableView() {\n+    let refresher = UIRefreshControl()\n+    refresher.addTarget(self, action: #selector(sendRequestToGetStudyList), for: .valueChanged)\n+    refresher.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n+    tableView.refreshControl = refresher\n+  }\n+\n+  /// Used to add left bar button item.\n+  func addLeftBarButton() {\n+    let button = UIButton(type: .custom)\n+    button.setTitle(\"FDA LISTENS!\", for: .normal)\n+    button.titleLabel?.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n+    button.frame = CGRect(x: 0, y: 0, width: 120, height: 30)\n+    button.contentHorizontalAlignment = .left\n+    button.setTitleColor(Utilities.getUIColorFromHex(0x007CBA), for: .normal)\n+\n+    let barItem = UIBarButtonItem(customView: button)\n+\n+    navigationItem.setLeftBarButton(barItem, animated: true)\n+  }\n+\n+  /// Used to add right bar button item.\n+  func addRightBarButton() {\n+    let button = UIButton(type: .custom)\n+    button.setImage(#imageLiteral(resourceName: \"filter_icn\"), for: .normal)\n+\n+    button.frame = CGRect(x: 0, y: 0, width: 19, height: 22.5)\n+    let barItem = UIBarButtonItem(customView: button)\n+\n+    navigationItem.setRightBarButton(barItem, animated: true)\n+  }\n+\n+  // MARK: - Utils\n+  func checkIfNotificationEnabled() {\n+\n+    var notificationEnabledFromAppSettings = false\n+    // Checking the app notification settings.\n+    LocalNotification.notificationsEnabled { (status) in\n+      notificationEnabledFromAppSettings = status\n     }\n \n-    /**\n-     Navigate to StudyFilter screen on button clicked\n-     @param sender    accepts UIBarButtonItem in sender\n-     */\n-    @IBAction func filterAction(_: UIBarButtonItem) {\n-        isComingFromFilterScreen = true\n-        performSegue(withIdentifier: filterListSegue, sender: nil)\n+    if (User.currentUser.settings?.remoteNotifications)!,\n+      (User.currentUser.settings?.localNotifications)!,\n+      notificationEnabledFromAppSettings {  // Notifications are enabled\n+      // Do Nothing\n+    } else {  // Notification is Disabled\n+      let ud = UserDefaults.standard\n+      let previousDate = ud.object(forKey: \"NotificationRemainder\") as? Date\n+      let todayDate = Date()\n+      var daysLastSeen = 0\n+      if previousDate != nil {\n+        daysLastSeen = Schedule().getNumberOfDaysBetween(\n+          startDate: previousDate!, endDate: todayDate)\n+      }\n+\n+      if daysLastSeen >= 7 {  // Notification is disabled for 7 or more Days\n+        UIUtilities.showAlertWithTitleAndMessage(\n+          title: NSLocalizedString(\"FDA My Studies\", comment: \"\") as NSString,\n+          message: NSLocalizedString(kMessageAppNotificationOffRemainder, comment: \"\")\n+            as NSString)\n+\n+        ud.set(Date(), forKey: \"NotificationRemainder\")\n+        ud.synchronize()\n+      }\n     }\n+  }\n \n-    @IBAction func searchButtonAction(_: UIBarButtonItem) {\n-        searchView = SearchBarView.instanceFromNib(frame: CGRect(x: 0, y: -200, width: view.frame.size.width, height: 64.0), detail: nil)\n-\n-        UIView.animate(withDuration: 0.2,\n-                       delay: 0.0,\n-                       options: UIView.AnimationOptions.preferredFramesPerSecond60,\n-                       animations: { () -> Void in\n-\n-                           let y: CGFloat = DeviceType.IS_IPHONE_X_OR_HIGH ? 20.0 : 0.0\n-\n-                           self.searchView?.frame = CGRect(x: 0, y: y, width: self.view.frame.size.width, height: 64.0)\n+  /// Used to load the test data from Studylist of type json.\n+  func loadTestData() {\n+    let filePath = Bundle.main.path(forResource: \"StudyList\", ofType: \"json\")\n+    let data = NSData(contentsOfFile: filePath!)\n \n-                           self.searchView?.textFieldSearch?.becomeFirstResponder()\n-                           self.searchView?.delegate = self\n+    do {\n+      let response = try JSONSerialization.jsonObject(with: data! as Data, options: [])\n+        as? [String: Any]\n \n-                           self.slideMenuController()?.leftPanGesture?.isEnabled = false\n+      let studies = (response?[kStudies] as? [[String: Any]])!\n+      var listOfStudies: [Study] = []\n+      for study in studies {\n+        let studyModelObj = Study(studyDetail: study)\n+        listOfStudies.append(studyModelObj)\n+      }\n \n-                           self.navigationController?.view.addSubview(self.searchView!)\n+      // assgin to Gateway\n+      Gateway.instance.studies = listOfStudies\n \n-                           if StudyFilterHandler.instance.searchText.count > 0 {\n-                               self.searchView?.textFieldSearch?.text = StudyFilterHandler.instance.searchText\n-                           }\n-\n-                       }, completion: { (_) -> Void in\n-\n-        })\n+    } catch {\n+      Logger.sharedInstance.info(\"json error: \\(error.localizedDescription)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 763}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0MTY2Mg==", "bodyText": "typo: should be fetal", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391741662", "createdAt": "2020-03-12T16:29:10Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/StudyUI/StudyListViewController.swift", "diffHunk": "@@ -1,1154 +1,1133 @@\n-/*\n- License Agreement for FDA My Studies\n- Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n- hereby granted, free of charge, to any person obtaining a copy of this software and associated\n- documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n- Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n- conditions:\n- The above copyright notice and this permission notice shall be included in all copies or substantial\n- portions of the Software.\n- Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n- Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n- THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n- PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n- OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n- OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import IQKeyboardManagerSwift\n import UIKit\n \n-let kHelperTextForFilteredStudiesNotFound = \"Sorry, no Studies found. Please try different Filter Options\"\n-let kHelperTextForSearchedStudiesNotFound = \"Sorry, no Studies found. Please check the spelling or try a different search.\"\n+let kHelperTextForFilteredStudiesNotFound\n+  = \"No study found.\\nPlease try different Filter Options.\"\n \n-let kHelperTextForOffline = \"Sorry, no studies available right now. Please remain signed in to get notified when there are new studies available.\"\n+let kHelperTextForSearchedStudiesNotFound\n+  = \"No study found.\\nPlease check the spelling or try a different search.\"\n+\n+let kHelperTextForOffline\n+  = \"No study available right now.\\nPlease remain signed in to get notified when there are new studies available.\"\n \n let kNotificationViewControllerIdentifier = \"NotificationViewControllerIdentifier\"\n \n class StudyListViewController: UIViewController {\n-    \n-    // MARK:- Outlets\n-    \n-    @IBOutlet var tableView: UITableView?\n-    @IBOutlet var labelHelperText: UILabel!\n-\n-    var refreshControl: UIRefreshControl? // for refreshing studylist\n-\n-    var studyListRequestFailed = false\n-    var searchView: SearchBarView?\n-\n-    var isComingFromFilterScreen: Bool = false\n-    var studiesList: [Study] = []\n-\n-    var previousStudyList: [Study] = []\n-\n-    var allStudyList: [Study] = [] // Gatewaystudylist\n-    override var preferredStatusBarStyle: UIStatusBarStyle {\n-        return .default\n-    }\n-\n-    // MARK: - Viewcontroller lifecycle\n-\n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-\n-        var infoDict: NSDictionary?\n-        if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n-            infoDict = NSDictionary(contentsOfFile: path)\n-        }\n-        let navTitle = infoDict![\"ProductTitleName\"] as! String\n-        let titleLabel = UILabel()\n-        titleLabel.text = NSLocalizedString(navTitle, comment: \"\")\n-        titleLabel.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n-        titleLabel.textAlignment = .left\n-        titleLabel.textColor = Utilities.getUIColorFromHex(0x007CBA)\n-        titleLabel.frame = CGRect(x: 0, y: 0, width: 300, height: 44)\n-\n-        navigationItem.titleView = titleLabel\n-\n-        // self.loadTestData()\n-        // get Profile data to check for passcode\n-        // Condition missing\n \n-        let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+  // MARK: - Outlets\n \n-        \n-        if User.currentUser.userType == .FDAUser, User.currentUser.settings?.localNotifications == true {\n-            /* Will come next next phase */\n-            //appDelegate.checkForAppReopenNotification()\n-        }\n+  @IBOutlet weak var tableView: UITableView!\n \n-        isComingFromFilterScreen = false\n-        // IQKeyboardManager.sharedManager().enable = true\n+  @IBOutlet weak var labelHelperText: UILabel!\n \n-        refreshControl = UIRefreshControl()\n-        refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n-        refreshControl?.addTarget(self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n-        tableView?.addSubview(refreshControl!)\n-    }\n+  lazy var studyListRequestFailed = false\n+  var searchView: SearchBarView?\n+  lazy var isComingFromFilterScreen: Bool = false\n+  lazy var studiesList: [Study] = []\n+  lazy var previousStudyList: [Study] = []\n \n-    override func viewWillAppear(_: Bool) {\n-        if isComingFromFilterScreen {\n-            isComingFromFilterScreen = false\n-            return\n-        }\n-        addRightNavigationItem()\n-        let appdelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+  /// Gatewaystudylist\n+  lazy var allStudyList: [Study] = []\n \n-        Study.currentStudy = nil\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n \n-        let ud = UserDefaults.standard\n-        var ispasscodePending: Bool? = false\n+  // MARK: - Viewcontroller lifecycle\n \n-        // Checking if User has missed out setting the passcode/TouchId\n-        if ud.value(forKey: kPasscodeIsPending) != nil {\n-            ispasscodePending = (ud.value(forKey: kPasscodeIsPending) as? Bool)!\n-        }\n-\n-        if ispasscodePending == true {\n-            if User.currentUser.userType == .FDAUser {\n-                tableView?.isHidden = true\n-                // Fetch the User Profile\n-                UserServices().getUserProfile(self as NMWebServiceDelegate)\n-            }\n-        }\n-\n-        labelHelperText.isHidden = true\n-        setNavigationBarItem()\n-        navigationController?.setNavigationBarHidden(false, animated: true)\n-        navigationController?.navigationBar.isHidden = false\n-\n-        if User.currentUser.userType == .FDAUser { // For LoggedIn User\n-            tableView?.estimatedRowHeight = 145\n-            tableView?.rowHeight = UITableView.automaticDimension\n-\n-            if (fdaSlideMenuController()?.isLeftOpen())! {\n-                // Do Nothing\n-            } else {\n-                // Fetch User Preferences\n-                sendRequestToGetUserPreference()\n-            }\n-        } else { // For ananomous User\n-            tableView?.estimatedRowHeight = 140\n-            tableView?.rowHeight = UITableView.automaticDimension\n-            // Fetch StudyList\n-            sendRequestToGetStudyList()\n-        }\n-\n-        // UIApplication.shared.statusBarStyle = .default\n-        setNeedsStatusBarAppearanceUpdate()\n-        // Checking if registering notification is pending\n-        if ud.value(forKey: kNotificationRegistrationIsPending) != nil, ud.bool(forKey: kNotificationRegistrationIsPending) == true {\n-            appdelegate.askForNotification()\n-        }\n-\n-        // Handling StudyList Request Failure condition\n-        if studyListRequestFailed {\n-            labelHelperText.isHidden = false\n-            labelHelperText.text = kHelperTextForOffline\n-        }\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    addNavigationTitle()\n+    isComingFromFilterScreen = false\n+    DispatchQueue.main.async { [weak self] in\n+      self?.setupStudyListTableView()\n     }\n+  }\n \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  override func viewDidAppear(_ animated: Bool) {\n+    super.viewDidAppear(animated)\n+    if isComingFromFilterScreen {\n+      isComingFromFilterScreen = false\n+      return\n     }\n+    addRightNavigationItem()\n+    let appdelegate = (UIApplication.shared.delegate as? AppDelegate)!\n \n-    // MARK: - Helper Methods\n+    Study.currentStudy = nil\n \n-    /**\n-     addRightNavigationItem method updates the navigation bar items for current controller , by adding Notification Button, Notification Indicator & Filter Button\n-     */\n-    func addRightNavigationItem() {\n-        let view = UIView(frame: CGRect(x: 0, y: 4, width: 110, height: 40))\n+    let ud = UserDefaults.standard\n+    var ispasscodePending: Bool? = false\n \n-        // Notification Button\n-        let button = addNotificationButton()\n-        view.addSubview(button)\n-        button.isExclusiveTouch = true\n-\n-        // notification Indicator\n-        let label = addNotificationIndication()\n-        view.addSubview(label)\n-\n-        let ud = UserDefaults.standard\n-        let showNotification = ud.bool(forKey: kShowNotification)\n-\n-        if showNotification {\n-            label.isHidden = false\n-        } else {\n-            label.isHidden = true\n-        }\n-\n-        //  filter Button\n-        let filterButton = addFilterButton()\n-        view.addSubview(filterButton)\n-        filterButton.isExclusiveTouch = true\n-\n-        //  Search Button\n-        let searchButton = addSearchButton()\n-        view.addSubview(searchButton)\n-        searchButton.isExclusiveTouch = true\n-\n-        let barButton = UIBarButtonItem(customView: view)\n-        navigationItem.rightBarButtonItems = [barButton]\n-    }\n-\n-    func addSearchButton() -> UIButton {\n-        let searchButton = UIButton(type: .custom)\n-        searchButton.setImage(#imageLiteral(resourceName: \"search_small\"), for: UIControl.State.normal)\n-        searchButton.addTarget(self, action: #selector(searchButtonAction(_:)), for: .touchUpInside)\n-        searchButton.frame = CGRect(x: 0, y: 4, width: 30, height: 30)\n-        return searchButton\n+    // Checking if User has missed out setting the passcode/TouchId\n+    if ud.value(forKey: kPasscodeIsPending) != nil {\n+      ispasscodePending = (ud.value(forKey: kPasscodeIsPending) as? Bool)!\n     }\n \n-    func addFilterButton() -> UIButton {\n-        let filterButton = UIButton(type: .custom)\n-        filterButton.setImage(#imageLiteral(resourceName: \"filterIcon\"), for: UIControl.State.normal)\n-        filterButton.addTarget(self, action: #selector(filterAction(_:)), for: .touchUpInside)\n-        filterButton.frame = CGRect(x: 40, y: 4, width: 30, height: 30)\n-        return filterButton\n-    }\n-\n-    func addNotificationButton() -> UIButton {\n-        let button = UIButton(type: .custom)\n-\n-        button.setImage(#imageLiteral(resourceName: \"notification_grey\"), for: UIControl.State.normal)\n-        button.addTarget(self, action: #selector(buttonActionNotification(_:)), for: .touchUpInside)\n-        button.frame = CGRect(x: 80, y: 4, width: 30, height: 30)\n-        return button\n-    }\n-\n-    func addNotificationIndication() -> UILabel {\n-        let label = UILabel(frame: CGRect(x: 100, y: 4, width: 10, height: 10))\n-        label.font = UIFont.systemFont(ofSize: 10)\n-        label.textColor = UIColor.white\n-\n-        label.textAlignment = NSTextAlignment.center\n-        label.backgroundColor = kUIColorForSubmitButtonBackground\n-        label.layer.cornerRadius = 5\n-        label.clipsToBounds = true\n-        label.text = \"\"\n-        return label\n-    }\n-\n-    func checkIfNotificationEnabled() {\n-        var notificationEnabledFromAppSettings = false\n-\n-        // checking the app settings\n-        let notificationType = UIApplication.shared.currentUserNotificationSettings!.types\n-        if notificationType == [] {\n-            print(\"notifications are NOT enabled\")\n-        } else {\n-            print(\"notifications are enabled\")\n-            notificationEnabledFromAppSettings = true\n-        }\n-\n-        if (User.currentUser.settings?.remoteNotifications)!,\n-            (User.currentUser.settings?.localNotifications)!,\n-            notificationEnabledFromAppSettings { // Notifications are enabled\n-            // Do Nothing\n-        } else { // Notification is Disabled\n-            let ud = UserDefaults.standard\n-            let previousDate = ud.object(forKey: \"NotificationRemainder\") as? Date\n-            let todayDate = Date()\n-            var daysLastSeen = 0\n-            if previousDate != nil {\n-                daysLastSeen = Schedule().getNumberOfDaysBetween(startDate: previousDate!, endDate: todayDate)\n-            }\n-\n-            if daysLastSeen >= 7 { // Notification is disabled for 7 or more Days\n-                UIUtilities.showAlertWithTitleAndMessage(title: NSLocalizedString(\"FDA My Studies\", comment: \"\") as NSString, message: NSLocalizedString(kMessageAppNotificationOffRemainder, comment: \"\") as NSString)\n-\n-                ud.set(Date(), forKey: \"NotificationRemainder\")\n-                ud.synchronize()\n-            }\n-        }\n-    }\n-\n-    /**\n-     Used to load the test data from Studylist of type json\n-     */\n-    func loadTestData() {\n-        let filePath = Bundle.main.path(forResource: \"StudyList\", ofType: \"json\")\n-        let data = NSData(contentsOfFile: filePath!)\n-\n-        do {\n-            let response = try JSONSerialization.jsonObject(with: data! as Data, options: []) as? [String: Any]\n-\n-            let studies = (response?[kStudies] as? [[String: Any]])!\n-            var listOfStudies: [Study] = []\n-            for study in studies {\n-                let studyModelObj = Study(studyDetail: study)\n-                listOfStudies.append(studyModelObj)\n-            }\n-\n-            // assgin to Gateway\n-            Gateway.instance.studies = listOfStudies\n-\n-        } catch {\n-            print(\"json error: \\(error.localizedDescription)\")\n-        }\n+    if ispasscodePending == true {\n+      if User.currentUser.userType == .FDAUser {\n+        tableView?.isHidden = true\n+        // Fetch the User Profile\n+        UserServices().getUserProfile(self as NMWebServiceDelegate)\n+      }\n     }\n \n-    /**\n-     checkIfFetelKickCountRunning method verifies whether if FetalKick Task is Still running and calculate the time difference.\n-     */\n-    func checkIfFetelKickCountRunning() {\n-        let ud = UserDefaults.standard\n-\n-        if ud.bool(forKey: \"FKC\"), ud.object(forKey: kFetalKickStartTimeStamp) != nil {\n-            let studyId = (ud.object(forKey: kFetalkickStudyId) as? String)!\n-            let study = Gateway.instance.studies?.filter { $0.studyId == studyId }.last\n-\n-            if study?.userParticipateState.status == .inProgress, study?.status == .Active {\n-                Study.updateCurrentStudy(study: study!)\n-                pushToStudyDashboard(animated: false)\n-            }\n-        } else {\n-            checkIfNotificationEnabled()\n-            if NotificationHandler.instance.studyId.count > 0 {\n-                let studyId = NotificationHandler.instance.studyId\n-                let study = Gateway.instance.studies?.filter { $0.studyId == studyId }.first\n-                Study.updateCurrentStudy(study: study!)\n-\n-                NotificationHandler.instance.studyId = \"\"\n-                performTaskBasedOnStudyStatus()\n-            }\n-        }\n+    labelHelperText.isHidden = true\n+    setNavigationBarItem()\n+    navigationController?.setNavigationBarHidden(false, animated: true)\n+    navigationController?.navigationBar.isHidden = false\n+\n+    if User.currentUser.userType == .FDAUser {  // For LoggedIn User\n+      tableView?.estimatedRowHeight = 145\n+      tableView?.rowHeight = UITableView.automaticDimension\n+\n+      if !(fdaSlideMenuController()?.isLeftOpen())! {\n+        sendRequestToGetUserPreference()\n+      }\n+    } else {  // For ananomous User\n+      tableView?.estimatedRowHeight = 140\n+      tableView?.rowHeight = UITableView.automaticDimension\n+      // Fetch StudyList\n+      sendRequestToGetStudyList()\n     }\n \n-    /**\n-     Navigate to notification screen\n-     */\n-    func navigateToNotifications() {\n-        let gatewayStoryBoard = UIStoryboard(name: kStoryboardIdentifierGateway, bundle: Bundle.main)\n-        let notificationController = (gatewayStoryBoard.instantiateViewController(withIdentifier: kNotificationViewControllerIdentifier) as? NotificationViewController)!\n-        navigationController?.pushViewController(notificationController, animated: true)\n+    // UIApplication.shared.statusBarStyle = .default\n+    setNeedsStatusBarAppearanceUpdate()\n+    // Checking if registering notification is pending\n+    if ud.value(forKey: kNotificationRegistrationIsPending) != nil,\n+      ud.bool(forKey: kNotificationRegistrationIsPending) == true {\n+      appdelegate.askForNotification()\n     }\n \n-    /**\n-     Navigate to StudyHomeViewController screen\n-     */\n-    func navigateToStudyHome() {\n-        let studyStoryBoard = UIStoryboard(name: kStudyStoryboard, bundle: Bundle.main)\n-        let studyHomeController = (studyStoryBoard.instantiateViewController(withIdentifier: String(describing: StudyHomeViewController.classForCoder())) as? StudyHomeViewController)!\n-        studyHomeController.delegate = self\n-        navigationController?.pushViewController(studyHomeController, animated: true)\n+    // Handling StudyList Request Failure condition\n+    if studyListRequestFailed {\n+      labelHelperText.isHidden = false\n+      labelHelperText.text = kHelperTextForOffline\n     }\n+  }\n \n-    /**\n-     Navigate the screen to Study Dashboard tabbar viewcontroller screen\n-     */\n-    func pushToStudyDashboard(animated: Bool = true) {\n-        let studyStoryBoard = UIStoryboard(name: kStudyStoryboard, bundle: Bundle.main)\n+  // MARK: - UI Utils\n \n-        let studyDashboard = (studyStoryBoard.instantiateViewController(withIdentifier: kStudyDashboardTabbarControllerIdentifier) as? StudyDashboardTabbarViewController)!\n+  /// To update the navigation bar items , by adding Notification Button, Notification Indicator & Filter Button.\n+  func addRightNavigationItem() {\n+    let view = UIView(frame: CGRect(x: 0, y: 4, width: 110, height: 40))\n \n-        navigationController?.navigationBar.isHidden = true\n-        navigationController?.pushViewController(studyDashboard, animated: animated)\n-    }\n+    // Notification Button\n+    let button = addNotificationButton()\n+    view.addSubview(button)\n+    button.isExclusiveTouch = true\n \n-    /**\n-     Method to display taskViewController for passcode setup if\n-     passcode setup is enabled,called only once after signin.\n-     */\n-    func setPassCode() {\n-        // Remove Passcode if already exist\n-        ORKPasscodeViewController.removePasscodeFromKeychain()\n-\n-        let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n-        passcodeStep.passcodeType = .type4Digit\n-\n-        let task = ORKOrderedTask(identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n-        let taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n-        taskViewController.delegate = self\n-        taskViewController.isNavigationBarHidden = true\n-        taskViewController.modalPresentationStyle = .fullScreen\n-        navigationController?.present(taskViewController, animated: false, completion: {\n-            self.tableView?.isHidden = false\n-        })\n-    }\n+    // notification Indicator\n+    let label = addNotificationIndication()\n+    view.addSubview(label)\n \n-    /**\n-     Load the study data from Database\n-     */\n-    func loadStudiesFromDatabase() {\n-        Logger.sharedInstance.info(\"Fetching Studies From DB\")\n-        DBHandler.loadStudyListFromDatabase { studies in\n-            if studies.count > 0 {\n-                self.tableView?.isHidden = false\n-                \n-//                var sortedstudies2 = studies.sorted(by: { $0.name!.lowercased() < $1.name!.lowercased() })\n-            \n-                \n-//               Logger.sharedInstance.info(\"Sorting Studies\")\n-//                sortedstudies2 = sortedstudies2.sorted(by: { (study1: Study, study2: Study) -> Bool in\n-//                    // sorting based on UserParticipation status\n-//                    if study1.status == study2.status {\n-//                        return (study1.userParticipateState.status.sortIndex < study2.userParticipateState.status.sortIndex)\n-//                    }\n-//                    return (study1.status.sortIndex < study2.status.sortIndex)\n-//                })\n-                self.studiesList = studies\n-                self.tableView?.reloadData()\n-                Logger.sharedInstance.info(\"Studies displayed to user\")\n-\n-                self.previousStudyList = studies\n-                self.allStudyList = studies\n-                Gateway.instance.studies = studies\n-\n-                // Applying Filters\n-                if StudyFilterHandler.instance.previousAppliedFilters.count > 0 {\n-                    let previousCollectionData = StudyFilterHandler.instance.previousAppliedFilters\n-\n-                    if User.currentUser.userType == .FDAUser {\n-                        self.appliedFilter(studyStatus: previousCollectionData.first!, pariticipationsStatus: previousCollectionData[2], categories: previousCollectionData[3], searchText: \"\", bookmarked: previousCollectionData[1].count > 0 ? true : false)\n-                    } else {\n-                        self.appliedFilter(studyStatus: previousCollectionData.first!, pariticipationsStatus: [], categories: previousCollectionData[1], searchText: \"\", bookmarked: false)\n-                    }\n-                } else {\n-                    let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-\n-                    appDelegate.setDefaultFilters(previousCollectionData: [])\n-\n-                    // using default Filters\n-                    let filterStrings = appDelegate.getDefaultFilterStrings()\n-\n-                    self.appliedFilter(studyStatus: filterStrings.studyStatus, pariticipationsStatus: filterStrings.pariticipationsStatus, categories: filterStrings.categories, searchText: filterStrings.searchText, bookmarked: filterStrings.bookmark)\n-                }\n-                self.checkIfFetelKickCountRunning()\n-            } else {\n-                if !self.studyListRequestFailed {\n-                    self.labelHelperText.isHidden = true\n-                    self.tableView?.isHidden = false\n-                    self.studyListRequestFailed = false\n-\n-                    self.sendRequestToGetStudyList()\n-                } else {\n-                    self.tableView?.isHidden = true\n-                    self.labelHelperText.isHidden = false\n-                    self.labelHelperText.text = kHelperTextForOffline\n-                }\n-            }\n-        }\n-    }\n+    let ud = UserDefaults.standard\n+    let showNotification = ud.bool(forKey: kShowNotification)\n \n-    /**\n-     Sort Studies based on the Study Status\n-     */\n-    func getSortedStudies(studies: [Study]) -> [Study] {\n-        var sortedstudies2 = studies.sorted(by: { $0.name!.lowercased() < $1.name!.lowercased() })\n-        sortedstudies2 = sortedstudies2.sorted(by: { (study1: Study, study2: Study) -> Bool in\n-\n-            if study1.status == study2.status {\n-                return (study1.userParticipateState.status.sortIndex < study2.userParticipateState.status.sortIndex)\n-            }\n-            return (study1.status.sortIndex < study2.status.sortIndex)\n-        })\n-        return sortedstudies2\n+    if showNotification {\n+      label.isHidden = false\n+    } else {\n+      label.isHidden = true\n     }\n \n-    // MARK: - Button Actions\n-\n-    /**\n-     Navigate to notification screen on button clicked\n-     @param sender    accepts UIBarButtonItem in sender\n-     */\n-    @IBAction func buttonActionNotification(_: UIBarButtonItem) {\n-        navigateToNotifications()\n+    //  filter Button\n+    let filterButton = addFilterButton()\n+    view.addSubview(filterButton)\n+    filterButton.isExclusiveTouch = true\n+\n+    //  Search Button\n+    let searchButton = addSearchButton()\n+    view.addSubview(searchButton)\n+    searchButton.isExclusiveTouch = true\n+\n+    let barButton = UIBarButtonItem(customView: view)\n+    navigationItem.rightBarButtonItems = [barButton]\n+  }\n+\n+  func addSearchButton() -> UIButton {\n+    let searchButton = UIButton(type: .custom)\n+    searchButton.setImage(\n+      #imageLiteral(resourceName: \"search_small\"), for: UIControl.State.normal)\n+    searchButton.addTarget(self, action: #selector(searchButtonAction(_:)), for: .touchUpInside)\n+    searchButton.frame = CGRect(x: 0, y: 4, width: 30, height: 30)\n+    return searchButton\n+  }\n+\n+  func addFilterButton() -> UIButton {\n+    let filterButton = UIButton(type: .custom)\n+    filterButton.setImage(\n+      #imageLiteral(resourceName: \"filterIcon\"), for: UIControl.State.normal)\n+    filterButton.addTarget(self, action: #selector(filterAction(_:)), for: .touchUpInside)\n+    filterButton.frame = CGRect(x: 40, y: 4, width: 30, height: 30)\n+    return filterButton\n+  }\n+\n+  func addNotificationButton() -> UIButton {\n+    let button = UIButton(type: .custom)\n+\n+    button.setImage(\n+      #imageLiteral(resourceName: \"notification_grey\"), for: UIControl.State.normal)\n+    button.addTarget(self, action: #selector(buttonActionNotification(_:)), for: .touchUpInside)\n+    button.frame = CGRect(x: 80, y: 4, width: 30, height: 30)\n+    return button\n+  }\n+\n+  func addNotificationIndication() -> UILabel {\n+    let label = UILabel(frame: CGRect(x: 100, y: 4, width: 10, height: 10))\n+    label.font = UIFont.systemFont(ofSize: 10)\n+    label.textColor = UIColor.white\n+\n+    label.textAlignment = NSTextAlignment.center\n+    label.backgroundColor = kUIColorForSubmitButtonBackground\n+    label.layer.cornerRadius = 5\n+    label.clipsToBounds = true\n+    label.text = \"\"\n+    return label\n+  }\n+\n+  /// Add the navigation title from the branding plist.\n+  fileprivate func addNavigationTitle() {\n+    var infoDict: NSDictionary?\n+    if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n+      infoDict = NSDictionary(contentsOfFile: path)\n     }\n-\n-    @objc func refresh(sender _: AnyObject) {\n-        sendRequestToGetStudyList()\n+    let navTitle = infoDict![\"ProductTitleName\"] as! String\n+    let titleLabel = UILabel()\n+    titleLabel.text = NSLocalizedString(navTitle, comment: \"\")\n+    titleLabel.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n+    titleLabel.textAlignment = .left\n+    titleLabel.textColor = Utilities.getUIColorFromHex(0x007CBA)\n+    titleLabel.frame = CGRect(x: 0, y: 0, width: 300, height: 44)\n+\n+    navigationItem.titleView = titleLabel\n+  }\n+\n+  fileprivate func setupStudyListTableView() {\n+    let refresher = UIRefreshControl()\n+    refresher.addTarget(self, action: #selector(sendRequestToGetStudyList), for: .valueChanged)\n+    refresher.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n+    tableView.refreshControl = refresher\n+  }\n+\n+  /// Used to add left bar button item.\n+  func addLeftBarButton() {\n+    let button = UIButton(type: .custom)\n+    button.setTitle(\"FDA LISTENS!\", for: .normal)\n+    button.titleLabel?.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n+    button.frame = CGRect(x: 0, y: 0, width: 120, height: 30)\n+    button.contentHorizontalAlignment = .left\n+    button.setTitleColor(Utilities.getUIColorFromHex(0x007CBA), for: .normal)\n+\n+    let barItem = UIBarButtonItem(customView: button)\n+\n+    navigationItem.setLeftBarButton(barItem, animated: true)\n+  }\n+\n+  /// Used to add right bar button item.\n+  func addRightBarButton() {\n+    let button = UIButton(type: .custom)\n+    button.setImage(#imageLiteral(resourceName: \"filter_icn\"), for: .normal)\n+\n+    button.frame = CGRect(x: 0, y: 0, width: 19, height: 22.5)\n+    let barItem = UIBarButtonItem(customView: button)\n+\n+    navigationItem.setRightBarButton(barItem, animated: true)\n+  }\n+\n+  // MARK: - Utils\n+  func checkIfNotificationEnabled() {\n+\n+    var notificationEnabledFromAppSettings = false\n+    // Checking the app notification settings.\n+    LocalNotification.notificationsEnabled { (status) in\n+      notificationEnabledFromAppSettings = status\n     }\n \n-    /**\n-     Navigate to StudyFilter screen on button clicked\n-     @param sender    accepts UIBarButtonItem in sender\n-     */\n-    @IBAction func filterAction(_: UIBarButtonItem) {\n-        isComingFromFilterScreen = true\n-        performSegue(withIdentifier: filterListSegue, sender: nil)\n+    if (User.currentUser.settings?.remoteNotifications)!,\n+      (User.currentUser.settings?.localNotifications)!,\n+      notificationEnabledFromAppSettings {  // Notifications are enabled\n+      // Do Nothing\n+    } else {  // Notification is Disabled\n+      let ud = UserDefaults.standard\n+      let previousDate = ud.object(forKey: \"NotificationRemainder\") as? Date\n+      let todayDate = Date()\n+      var daysLastSeen = 0\n+      if previousDate != nil {\n+        daysLastSeen = Schedule().getNumberOfDaysBetween(\n+          startDate: previousDate!, endDate: todayDate)\n+      }\n+\n+      if daysLastSeen >= 7 {  // Notification is disabled for 7 or more Days\n+        UIUtilities.showAlertWithTitleAndMessage(\n+          title: NSLocalizedString(\"FDA My Studies\", comment: \"\") as NSString,\n+          message: NSLocalizedString(kMessageAppNotificationOffRemainder, comment: \"\")\n+            as NSString)\n+\n+        ud.set(Date(), forKey: \"NotificationRemainder\")\n+        ud.synchronize()\n+      }\n     }\n+  }\n \n-    @IBAction func searchButtonAction(_: UIBarButtonItem) {\n-        searchView = SearchBarView.instanceFromNib(frame: CGRect(x: 0, y: -200, width: view.frame.size.width, height: 64.0), detail: nil)\n-\n-        UIView.animate(withDuration: 0.2,\n-                       delay: 0.0,\n-                       options: UIView.AnimationOptions.preferredFramesPerSecond60,\n-                       animations: { () -> Void in\n-\n-                           let y: CGFloat = DeviceType.IS_IPHONE_X_OR_HIGH ? 20.0 : 0.0\n-\n-                           self.searchView?.frame = CGRect(x: 0, y: y, width: self.view.frame.size.width, height: 64.0)\n+  /// Used to load the test data from Studylist of type json.\n+  func loadTestData() {\n+    let filePath = Bundle.main.path(forResource: \"StudyList\", ofType: \"json\")\n+    let data = NSData(contentsOfFile: filePath!)\n \n-                           self.searchView?.textFieldSearch?.becomeFirstResponder()\n-                           self.searchView?.delegate = self\n+    do {\n+      let response = try JSONSerialization.jsonObject(with: data! as Data, options: [])\n+        as? [String: Any]\n \n-                           self.slideMenuController()?.leftPanGesture?.isEnabled = false\n+      let studies = (response?[kStudies] as? [[String: Any]])!\n+      var listOfStudies: [Study] = []\n+      for study in studies {\n+        let studyModelObj = Study(studyDetail: study)\n+        listOfStudies.append(studyModelObj)\n+      }\n \n-                           self.navigationController?.view.addSubview(self.searchView!)\n+      // assgin to Gateway\n+      Gateway.instance.studies = listOfStudies\n \n-                           if StudyFilterHandler.instance.searchText.count > 0 {\n-                               self.searchView?.textFieldSearch?.text = StudyFilterHandler.instance.searchText\n-                           }\n-\n-                       }, completion: { (_) -> Void in\n-\n-        })\n+    } catch {\n+      Logger.sharedInstance.info(\"json error: \\(error.localizedDescription)\")\n     }\n-\n-    // MARK: - Custom Bar Buttons\n-\n-    /**\n-     Used to add left bar button item\n-     */\n-    func addLeftBarButton() {\n-        let button = UIButton(type: .custom)\n-        button.setTitle(\"FDA LISTENS!\", for: .normal)\n-        button.titleLabel?.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n-        button.frame = CGRect(x: 0, y: 0, width: 120, height: 30)\n-        button.contentHorizontalAlignment = .left\n-        button.setTitleColor(Utilities.getUIColorFromHex(0x007CBA), for: .normal)\n-\n-        let barItem = UIBarButtonItem(customView: button)\n-\n-        navigationItem.setLeftBarButton(barItem, animated: true)\n+  }\n+\n+  /// CheckIfFetelKickCountRunning method verifies wheather if FetalKick Task is Still running and calculate the time difference.\n+  func checkIfFetelKickCountRunning() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 785}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0OTc1Mw==", "bodyText": "remove debug logs", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391749753", "createdAt": "2020-03-12T16:41:54Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/GatewayUI/StudyUI/StudyListViewController.swift", "diffHunk": "@@ -1,1154 +1,1133 @@\n-/*\n- License Agreement for FDA My Studies\n- Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n- hereby granted, free of charge, to any person obtaining a copy of this software and associated\n- documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n- limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n- Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n- conditions:\n- The above copyright notice and this permission notice shall be included in all copies or substantial\n- portions of the Software.\n- Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n- Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n- THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n- PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n- OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n- OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import IQKeyboardManagerSwift\n import UIKit\n \n-let kHelperTextForFilteredStudiesNotFound = \"Sorry, no Studies found. Please try different Filter Options\"\n-let kHelperTextForSearchedStudiesNotFound = \"Sorry, no Studies found. Please check the spelling or try a different search.\"\n+let kHelperTextForFilteredStudiesNotFound\n+  = \"No study found.\\nPlease try different Filter Options.\"\n \n-let kHelperTextForOffline = \"Sorry, no studies available right now. Please remain signed in to get notified when there are new studies available.\"\n+let kHelperTextForSearchedStudiesNotFound\n+  = \"No study found.\\nPlease check the spelling or try a different search.\"\n+\n+let kHelperTextForOffline\n+  = \"No study available right now.\\nPlease remain signed in to get notified when there are new studies available.\"\n \n let kNotificationViewControllerIdentifier = \"NotificationViewControllerIdentifier\"\n \n class StudyListViewController: UIViewController {\n-    \n-    // MARK:- Outlets\n-    \n-    @IBOutlet var tableView: UITableView?\n-    @IBOutlet var labelHelperText: UILabel!\n-\n-    var refreshControl: UIRefreshControl? // for refreshing studylist\n-\n-    var studyListRequestFailed = false\n-    var searchView: SearchBarView?\n-\n-    var isComingFromFilterScreen: Bool = false\n-    var studiesList: [Study] = []\n-\n-    var previousStudyList: [Study] = []\n-\n-    var allStudyList: [Study] = [] // Gatewaystudylist\n-    override var preferredStatusBarStyle: UIStatusBarStyle {\n-        return .default\n-    }\n-\n-    // MARK: - Viewcontroller lifecycle\n-\n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-\n-        var infoDict: NSDictionary?\n-        if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n-            infoDict = NSDictionary(contentsOfFile: path)\n-        }\n-        let navTitle = infoDict![\"ProductTitleName\"] as! String\n-        let titleLabel = UILabel()\n-        titleLabel.text = NSLocalizedString(navTitle, comment: \"\")\n-        titleLabel.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n-        titleLabel.textAlignment = .left\n-        titleLabel.textColor = Utilities.getUIColorFromHex(0x007CBA)\n-        titleLabel.frame = CGRect(x: 0, y: 0, width: 300, height: 44)\n-\n-        navigationItem.titleView = titleLabel\n-\n-        // self.loadTestData()\n-        // get Profile data to check for passcode\n-        // Condition missing\n \n-        let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+  // MARK: - Outlets\n \n-        \n-        if User.currentUser.userType == .FDAUser, User.currentUser.settings?.localNotifications == true {\n-            /* Will come next next phase */\n-            //appDelegate.checkForAppReopenNotification()\n-        }\n+  @IBOutlet weak var tableView: UITableView!\n \n-        isComingFromFilterScreen = false\n-        // IQKeyboardManager.sharedManager().enable = true\n+  @IBOutlet weak var labelHelperText: UILabel!\n \n-        refreshControl = UIRefreshControl()\n-        refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n-        refreshControl?.addTarget(self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n-        tableView?.addSubview(refreshControl!)\n-    }\n+  lazy var studyListRequestFailed = false\n+  var searchView: SearchBarView?\n+  lazy var isComingFromFilterScreen: Bool = false\n+  lazy var studiesList: [Study] = []\n+  lazy var previousStudyList: [Study] = []\n \n-    override func viewWillAppear(_: Bool) {\n-        if isComingFromFilterScreen {\n-            isComingFromFilterScreen = false\n-            return\n-        }\n-        addRightNavigationItem()\n-        let appdelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+  /// Gatewaystudylist\n+  lazy var allStudyList: [Study] = []\n \n-        Study.currentStudy = nil\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n \n-        let ud = UserDefaults.standard\n-        var ispasscodePending: Bool? = false\n+  // MARK: - Viewcontroller lifecycle\n \n-        // Checking if User has missed out setting the passcode/TouchId\n-        if ud.value(forKey: kPasscodeIsPending) != nil {\n-            ispasscodePending = (ud.value(forKey: kPasscodeIsPending) as? Bool)!\n-        }\n-\n-        if ispasscodePending == true {\n-            if User.currentUser.userType == .FDAUser {\n-                tableView?.isHidden = true\n-                // Fetch the User Profile\n-                UserServices().getUserProfile(self as NMWebServiceDelegate)\n-            }\n-        }\n-\n-        labelHelperText.isHidden = true\n-        setNavigationBarItem()\n-        navigationController?.setNavigationBarHidden(false, animated: true)\n-        navigationController?.navigationBar.isHidden = false\n-\n-        if User.currentUser.userType == .FDAUser { // For LoggedIn User\n-            tableView?.estimatedRowHeight = 145\n-            tableView?.rowHeight = UITableView.automaticDimension\n-\n-            if (fdaSlideMenuController()?.isLeftOpen())! {\n-                // Do Nothing\n-            } else {\n-                // Fetch User Preferences\n-                sendRequestToGetUserPreference()\n-            }\n-        } else { // For ananomous User\n-            tableView?.estimatedRowHeight = 140\n-            tableView?.rowHeight = UITableView.automaticDimension\n-            // Fetch StudyList\n-            sendRequestToGetStudyList()\n-        }\n-\n-        // UIApplication.shared.statusBarStyle = .default\n-        setNeedsStatusBarAppearanceUpdate()\n-        // Checking if registering notification is pending\n-        if ud.value(forKey: kNotificationRegistrationIsPending) != nil, ud.bool(forKey: kNotificationRegistrationIsPending) == true {\n-            appdelegate.askForNotification()\n-        }\n-\n-        // Handling StudyList Request Failure condition\n-        if studyListRequestFailed {\n-            labelHelperText.isHidden = false\n-            labelHelperText.text = kHelperTextForOffline\n-        }\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    addNavigationTitle()\n+    isComingFromFilterScreen = false\n+    DispatchQueue.main.async { [weak self] in\n+      self?.setupStudyListTableView()\n     }\n+  }\n \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  override func viewDidAppear(_ animated: Bool) {\n+    super.viewDidAppear(animated)\n+    if isComingFromFilterScreen {\n+      isComingFromFilterScreen = false\n+      return\n     }\n+    addRightNavigationItem()\n+    let appdelegate = (UIApplication.shared.delegate as? AppDelegate)!\n \n-    // MARK: - Helper Methods\n+    Study.currentStudy = nil\n \n-    /**\n-     addRightNavigationItem method updates the navigation bar items for current controller , by adding Notification Button, Notification Indicator & Filter Button\n-     */\n-    func addRightNavigationItem() {\n-        let view = UIView(frame: CGRect(x: 0, y: 4, width: 110, height: 40))\n+    let ud = UserDefaults.standard\n+    var ispasscodePending: Bool? = false\n \n-        // Notification Button\n-        let button = addNotificationButton()\n-        view.addSubview(button)\n-        button.isExclusiveTouch = true\n-\n-        // notification Indicator\n-        let label = addNotificationIndication()\n-        view.addSubview(label)\n-\n-        let ud = UserDefaults.standard\n-        let showNotification = ud.bool(forKey: kShowNotification)\n-\n-        if showNotification {\n-            label.isHidden = false\n-        } else {\n-            label.isHidden = true\n-        }\n-\n-        //  filter Button\n-        let filterButton = addFilterButton()\n-        view.addSubview(filterButton)\n-        filterButton.isExclusiveTouch = true\n-\n-        //  Search Button\n-        let searchButton = addSearchButton()\n-        view.addSubview(searchButton)\n-        searchButton.isExclusiveTouch = true\n-\n-        let barButton = UIBarButtonItem(customView: view)\n-        navigationItem.rightBarButtonItems = [barButton]\n-    }\n-\n-    func addSearchButton() -> UIButton {\n-        let searchButton = UIButton(type: .custom)\n-        searchButton.setImage(#imageLiteral(resourceName: \"search_small\"), for: UIControl.State.normal)\n-        searchButton.addTarget(self, action: #selector(searchButtonAction(_:)), for: .touchUpInside)\n-        searchButton.frame = CGRect(x: 0, y: 4, width: 30, height: 30)\n-        return searchButton\n+    // Checking if User has missed out setting the passcode/TouchId\n+    if ud.value(forKey: kPasscodeIsPending) != nil {\n+      ispasscodePending = (ud.value(forKey: kPasscodeIsPending) as? Bool)!\n     }\n \n-    func addFilterButton() -> UIButton {\n-        let filterButton = UIButton(type: .custom)\n-        filterButton.setImage(#imageLiteral(resourceName: \"filterIcon\"), for: UIControl.State.normal)\n-        filterButton.addTarget(self, action: #selector(filterAction(_:)), for: .touchUpInside)\n-        filterButton.frame = CGRect(x: 40, y: 4, width: 30, height: 30)\n-        return filterButton\n-    }\n-\n-    func addNotificationButton() -> UIButton {\n-        let button = UIButton(type: .custom)\n-\n-        button.setImage(#imageLiteral(resourceName: \"notification_grey\"), for: UIControl.State.normal)\n-        button.addTarget(self, action: #selector(buttonActionNotification(_:)), for: .touchUpInside)\n-        button.frame = CGRect(x: 80, y: 4, width: 30, height: 30)\n-        return button\n-    }\n-\n-    func addNotificationIndication() -> UILabel {\n-        let label = UILabel(frame: CGRect(x: 100, y: 4, width: 10, height: 10))\n-        label.font = UIFont.systemFont(ofSize: 10)\n-        label.textColor = UIColor.white\n-\n-        label.textAlignment = NSTextAlignment.center\n-        label.backgroundColor = kUIColorForSubmitButtonBackground\n-        label.layer.cornerRadius = 5\n-        label.clipsToBounds = true\n-        label.text = \"\"\n-        return label\n-    }\n-\n-    func checkIfNotificationEnabled() {\n-        var notificationEnabledFromAppSettings = false\n-\n-        // checking the app settings\n-        let notificationType = UIApplication.shared.currentUserNotificationSettings!.types\n-        if notificationType == [] {\n-            print(\"notifications are NOT enabled\")\n-        } else {\n-            print(\"notifications are enabled\")\n-            notificationEnabledFromAppSettings = true\n-        }\n-\n-        if (User.currentUser.settings?.remoteNotifications)!,\n-            (User.currentUser.settings?.localNotifications)!,\n-            notificationEnabledFromAppSettings { // Notifications are enabled\n-            // Do Nothing\n-        } else { // Notification is Disabled\n-            let ud = UserDefaults.standard\n-            let previousDate = ud.object(forKey: \"NotificationRemainder\") as? Date\n-            let todayDate = Date()\n-            var daysLastSeen = 0\n-            if previousDate != nil {\n-                daysLastSeen = Schedule().getNumberOfDaysBetween(startDate: previousDate!, endDate: todayDate)\n-            }\n-\n-            if daysLastSeen >= 7 { // Notification is disabled for 7 or more Days\n-                UIUtilities.showAlertWithTitleAndMessage(title: NSLocalizedString(\"FDA My Studies\", comment: \"\") as NSString, message: NSLocalizedString(kMessageAppNotificationOffRemainder, comment: \"\") as NSString)\n-\n-                ud.set(Date(), forKey: \"NotificationRemainder\")\n-                ud.synchronize()\n-            }\n-        }\n-    }\n-\n-    /**\n-     Used to load the test data from Studylist of type json\n-     */\n-    func loadTestData() {\n-        let filePath = Bundle.main.path(forResource: \"StudyList\", ofType: \"json\")\n-        let data = NSData(contentsOfFile: filePath!)\n-\n-        do {\n-            let response = try JSONSerialization.jsonObject(with: data! as Data, options: []) as? [String: Any]\n-\n-            let studies = (response?[kStudies] as? [[String: Any]])!\n-            var listOfStudies: [Study] = []\n-            for study in studies {\n-                let studyModelObj = Study(studyDetail: study)\n-                listOfStudies.append(studyModelObj)\n-            }\n-\n-            // assgin to Gateway\n-            Gateway.instance.studies = listOfStudies\n-\n-        } catch {\n-            print(\"json error: \\(error.localizedDescription)\")\n-        }\n+    if ispasscodePending == true {\n+      if User.currentUser.userType == .FDAUser {\n+        tableView?.isHidden = true\n+        // Fetch the User Profile\n+        UserServices().getUserProfile(self as NMWebServiceDelegate)\n+      }\n     }\n \n-    /**\n-     checkIfFetelKickCountRunning method verifies whether if FetalKick Task is Still running and calculate the time difference.\n-     */\n-    func checkIfFetelKickCountRunning() {\n-        let ud = UserDefaults.standard\n-\n-        if ud.bool(forKey: \"FKC\"), ud.object(forKey: kFetalKickStartTimeStamp) != nil {\n-            let studyId = (ud.object(forKey: kFetalkickStudyId) as? String)!\n-            let study = Gateway.instance.studies?.filter { $0.studyId == studyId }.last\n-\n-            if study?.userParticipateState.status == .inProgress, study?.status == .Active {\n-                Study.updateCurrentStudy(study: study!)\n-                pushToStudyDashboard(animated: false)\n-            }\n-        } else {\n-            checkIfNotificationEnabled()\n-            if NotificationHandler.instance.studyId.count > 0 {\n-                let studyId = NotificationHandler.instance.studyId\n-                let study = Gateway.instance.studies?.filter { $0.studyId == studyId }.first\n-                Study.updateCurrentStudy(study: study!)\n-\n-                NotificationHandler.instance.studyId = \"\"\n-                performTaskBasedOnStudyStatus()\n-            }\n-        }\n+    labelHelperText.isHidden = true\n+    setNavigationBarItem()\n+    navigationController?.setNavigationBarHidden(false, animated: true)\n+    navigationController?.navigationBar.isHidden = false\n+\n+    if User.currentUser.userType == .FDAUser {  // For LoggedIn User\n+      tableView?.estimatedRowHeight = 145\n+      tableView?.rowHeight = UITableView.automaticDimension\n+\n+      if !(fdaSlideMenuController()?.isLeftOpen())! {\n+        sendRequestToGetUserPreference()\n+      }\n+    } else {  // For ananomous User\n+      tableView?.estimatedRowHeight = 140\n+      tableView?.rowHeight = UITableView.automaticDimension\n+      // Fetch StudyList\n+      sendRequestToGetStudyList()\n     }\n \n-    /**\n-     Navigate to notification screen\n-     */\n-    func navigateToNotifications() {\n-        let gatewayStoryBoard = UIStoryboard(name: kStoryboardIdentifierGateway, bundle: Bundle.main)\n-        let notificationController = (gatewayStoryBoard.instantiateViewController(withIdentifier: kNotificationViewControllerIdentifier) as? NotificationViewController)!\n-        navigationController?.pushViewController(notificationController, animated: true)\n+    // UIApplication.shared.statusBarStyle = .default\n+    setNeedsStatusBarAppearanceUpdate()\n+    // Checking if registering notification is pending\n+    if ud.value(forKey: kNotificationRegistrationIsPending) != nil,\n+      ud.bool(forKey: kNotificationRegistrationIsPending) == true {\n+      appdelegate.askForNotification()\n     }\n \n-    /**\n-     Navigate to StudyHomeViewController screen\n-     */\n-    func navigateToStudyHome() {\n-        let studyStoryBoard = UIStoryboard(name: kStudyStoryboard, bundle: Bundle.main)\n-        let studyHomeController = (studyStoryBoard.instantiateViewController(withIdentifier: String(describing: StudyHomeViewController.classForCoder())) as? StudyHomeViewController)!\n-        studyHomeController.delegate = self\n-        navigationController?.pushViewController(studyHomeController, animated: true)\n+    // Handling StudyList Request Failure condition\n+    if studyListRequestFailed {\n+      labelHelperText.isHidden = false\n+      labelHelperText.text = kHelperTextForOffline\n     }\n+  }\n \n-    /**\n-     Navigate the screen to Study Dashboard tabbar viewcontroller screen\n-     */\n-    func pushToStudyDashboard(animated: Bool = true) {\n-        let studyStoryBoard = UIStoryboard(name: kStudyStoryboard, bundle: Bundle.main)\n+  // MARK: - UI Utils\n \n-        let studyDashboard = (studyStoryBoard.instantiateViewController(withIdentifier: kStudyDashboardTabbarControllerIdentifier) as? StudyDashboardTabbarViewController)!\n+  /// To update the navigation bar items , by adding Notification Button, Notification Indicator & Filter Button.\n+  func addRightNavigationItem() {\n+    let view = UIView(frame: CGRect(x: 0, y: 4, width: 110, height: 40))\n \n-        navigationController?.navigationBar.isHidden = true\n-        navigationController?.pushViewController(studyDashboard, animated: animated)\n-    }\n+    // Notification Button\n+    let button = addNotificationButton()\n+    view.addSubview(button)\n+    button.isExclusiveTouch = true\n \n-    /**\n-     Method to display taskViewController for passcode setup if\n-     passcode setup is enabled,called only once after signin.\n-     */\n-    func setPassCode() {\n-        // Remove Passcode if already exist\n-        ORKPasscodeViewController.removePasscodeFromKeychain()\n-\n-        let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n-        passcodeStep.passcodeType = .type4Digit\n-\n-        let task = ORKOrderedTask(identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n-        let taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n-        taskViewController.delegate = self\n-        taskViewController.isNavigationBarHidden = true\n-        taskViewController.modalPresentationStyle = .fullScreen\n-        navigationController?.present(taskViewController, animated: false, completion: {\n-            self.tableView?.isHidden = false\n-        })\n-    }\n+    // notification Indicator\n+    let label = addNotificationIndication()\n+    view.addSubview(label)\n \n-    /**\n-     Load the study data from Database\n-     */\n-    func loadStudiesFromDatabase() {\n-        Logger.sharedInstance.info(\"Fetching Studies From DB\")\n-        DBHandler.loadStudyListFromDatabase { studies in\n-            if studies.count > 0 {\n-                self.tableView?.isHidden = false\n-                \n-//                var sortedstudies2 = studies.sorted(by: { $0.name!.lowercased() < $1.name!.lowercased() })\n-            \n-                \n-//               Logger.sharedInstance.info(\"Sorting Studies\")\n-//                sortedstudies2 = sortedstudies2.sorted(by: { (study1: Study, study2: Study) -> Bool in\n-//                    // sorting based on UserParticipation status\n-//                    if study1.status == study2.status {\n-//                        return (study1.userParticipateState.status.sortIndex < study2.userParticipateState.status.sortIndex)\n-//                    }\n-//                    return (study1.status.sortIndex < study2.status.sortIndex)\n-//                })\n-                self.studiesList = studies\n-                self.tableView?.reloadData()\n-                Logger.sharedInstance.info(\"Studies displayed to user\")\n-\n-                self.previousStudyList = studies\n-                self.allStudyList = studies\n-                Gateway.instance.studies = studies\n-\n-                // Applying Filters\n-                if StudyFilterHandler.instance.previousAppliedFilters.count > 0 {\n-                    let previousCollectionData = StudyFilterHandler.instance.previousAppliedFilters\n-\n-                    if User.currentUser.userType == .FDAUser {\n-                        self.appliedFilter(studyStatus: previousCollectionData.first!, pariticipationsStatus: previousCollectionData[2], categories: previousCollectionData[3], searchText: \"\", bookmarked: previousCollectionData[1].count > 0 ? true : false)\n-                    } else {\n-                        self.appliedFilter(studyStatus: previousCollectionData.first!, pariticipationsStatus: [], categories: previousCollectionData[1], searchText: \"\", bookmarked: false)\n-                    }\n-                } else {\n-                    let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-\n-                    appDelegate.setDefaultFilters(previousCollectionData: [])\n-\n-                    // using default Filters\n-                    let filterStrings = appDelegate.getDefaultFilterStrings()\n-\n-                    self.appliedFilter(studyStatus: filterStrings.studyStatus, pariticipationsStatus: filterStrings.pariticipationsStatus, categories: filterStrings.categories, searchText: filterStrings.searchText, bookmarked: filterStrings.bookmark)\n-                }\n-                self.checkIfFetelKickCountRunning()\n-            } else {\n-                if !self.studyListRequestFailed {\n-                    self.labelHelperText.isHidden = true\n-                    self.tableView?.isHidden = false\n-                    self.studyListRequestFailed = false\n-\n-                    self.sendRequestToGetStudyList()\n-                } else {\n-                    self.tableView?.isHidden = true\n-                    self.labelHelperText.isHidden = false\n-                    self.labelHelperText.text = kHelperTextForOffline\n-                }\n-            }\n-        }\n-    }\n+    let ud = UserDefaults.standard\n+    let showNotification = ud.bool(forKey: kShowNotification)\n \n-    /**\n-     Sort Studies based on the Study Status\n-     */\n-    func getSortedStudies(studies: [Study]) -> [Study] {\n-        var sortedstudies2 = studies.sorted(by: { $0.name!.lowercased() < $1.name!.lowercased() })\n-        sortedstudies2 = sortedstudies2.sorted(by: { (study1: Study, study2: Study) -> Bool in\n-\n-            if study1.status == study2.status {\n-                return (study1.userParticipateState.status.sortIndex < study2.userParticipateState.status.sortIndex)\n-            }\n-            return (study1.status.sortIndex < study2.status.sortIndex)\n-        })\n-        return sortedstudies2\n+    if showNotification {\n+      label.isHidden = false\n+    } else {\n+      label.isHidden = true\n     }\n \n-    // MARK: - Button Actions\n-\n-    /**\n-     Navigate to notification screen on button clicked\n-     @param sender    accepts UIBarButtonItem in sender\n-     */\n-    @IBAction func buttonActionNotification(_: UIBarButtonItem) {\n-        navigateToNotifications()\n+    //  filter Button\n+    let filterButton = addFilterButton()\n+    view.addSubview(filterButton)\n+    filterButton.isExclusiveTouch = true\n+\n+    //  Search Button\n+    let searchButton = addSearchButton()\n+    view.addSubview(searchButton)\n+    searchButton.isExclusiveTouch = true\n+\n+    let barButton = UIBarButtonItem(customView: view)\n+    navigationItem.rightBarButtonItems = [barButton]\n+  }\n+\n+  func addSearchButton() -> UIButton {\n+    let searchButton = UIButton(type: .custom)\n+    searchButton.setImage(\n+      #imageLiteral(resourceName: \"search_small\"), for: UIControl.State.normal)\n+    searchButton.addTarget(self, action: #selector(searchButtonAction(_:)), for: .touchUpInside)\n+    searchButton.frame = CGRect(x: 0, y: 4, width: 30, height: 30)\n+    return searchButton\n+  }\n+\n+  func addFilterButton() -> UIButton {\n+    let filterButton = UIButton(type: .custom)\n+    filterButton.setImage(\n+      #imageLiteral(resourceName: \"filterIcon\"), for: UIControl.State.normal)\n+    filterButton.addTarget(self, action: #selector(filterAction(_:)), for: .touchUpInside)\n+    filterButton.frame = CGRect(x: 40, y: 4, width: 30, height: 30)\n+    return filterButton\n+  }\n+\n+  func addNotificationButton() -> UIButton {\n+    let button = UIButton(type: .custom)\n+\n+    button.setImage(\n+      #imageLiteral(resourceName: \"notification_grey\"), for: UIControl.State.normal)\n+    button.addTarget(self, action: #selector(buttonActionNotification(_:)), for: .touchUpInside)\n+    button.frame = CGRect(x: 80, y: 4, width: 30, height: 30)\n+    return button\n+  }\n+\n+  func addNotificationIndication() -> UILabel {\n+    let label = UILabel(frame: CGRect(x: 100, y: 4, width: 10, height: 10))\n+    label.font = UIFont.systemFont(ofSize: 10)\n+    label.textColor = UIColor.white\n+\n+    label.textAlignment = NSTextAlignment.center\n+    label.backgroundColor = kUIColorForSubmitButtonBackground\n+    label.layer.cornerRadius = 5\n+    label.clipsToBounds = true\n+    label.text = \"\"\n+    return label\n+  }\n+\n+  /// Add the navigation title from the branding plist.\n+  fileprivate func addNavigationTitle() {\n+    var infoDict: NSDictionary?\n+    if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n+      infoDict = NSDictionary(contentsOfFile: path)\n     }\n-\n-    @objc func refresh(sender _: AnyObject) {\n-        sendRequestToGetStudyList()\n+    let navTitle = infoDict![\"ProductTitleName\"] as! String\n+    let titleLabel = UILabel()\n+    titleLabel.text = NSLocalizedString(navTitle, comment: \"\")\n+    titleLabel.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n+    titleLabel.textAlignment = .left\n+    titleLabel.textColor = Utilities.getUIColorFromHex(0x007CBA)\n+    titleLabel.frame = CGRect(x: 0, y: 0, width: 300, height: 44)\n+\n+    navigationItem.titleView = titleLabel\n+  }\n+\n+  fileprivate func setupStudyListTableView() {\n+    let refresher = UIRefreshControl()\n+    refresher.addTarget(self, action: #selector(sendRequestToGetStudyList), for: .valueChanged)\n+    refresher.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n+    tableView.refreshControl = refresher\n+  }\n+\n+  /// Used to add left bar button item.\n+  func addLeftBarButton() {\n+    let button = UIButton(type: .custom)\n+    button.setTitle(\"FDA LISTENS!\", for: .normal)\n+    button.titleLabel?.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n+    button.frame = CGRect(x: 0, y: 0, width: 120, height: 30)\n+    button.contentHorizontalAlignment = .left\n+    button.setTitleColor(Utilities.getUIColorFromHex(0x007CBA), for: .normal)\n+\n+    let barItem = UIBarButtonItem(customView: button)\n+\n+    navigationItem.setLeftBarButton(barItem, animated: true)\n+  }\n+\n+  /// Used to add right bar button item.\n+  func addRightBarButton() {\n+    let button = UIButton(type: .custom)\n+    button.setImage(#imageLiteral(resourceName: \"filter_icn\"), for: .normal)\n+\n+    button.frame = CGRect(x: 0, y: 0, width: 19, height: 22.5)\n+    let barItem = UIBarButtonItem(customView: button)\n+\n+    navigationItem.setRightBarButton(barItem, animated: true)\n+  }\n+\n+  // MARK: - Utils\n+  func checkIfNotificationEnabled() {\n+\n+    var notificationEnabledFromAppSettings = false\n+    // Checking the app notification settings.\n+    LocalNotification.notificationsEnabled { (status) in\n+      notificationEnabledFromAppSettings = status\n     }\n \n-    /**\n-     Navigate to StudyFilter screen on button clicked\n-     @param sender    accepts UIBarButtonItem in sender\n-     */\n-    @IBAction func filterAction(_: UIBarButtonItem) {\n-        isComingFromFilterScreen = true\n-        performSegue(withIdentifier: filterListSegue, sender: nil)\n+    if (User.currentUser.settings?.remoteNotifications)!,\n+      (User.currentUser.settings?.localNotifications)!,\n+      notificationEnabledFromAppSettings {  // Notifications are enabled\n+      // Do Nothing\n+    } else {  // Notification is Disabled\n+      let ud = UserDefaults.standard\n+      let previousDate = ud.object(forKey: \"NotificationRemainder\") as? Date\n+      let todayDate = Date()\n+      var daysLastSeen = 0\n+      if previousDate != nil {\n+        daysLastSeen = Schedule().getNumberOfDaysBetween(\n+          startDate: previousDate!, endDate: todayDate)\n+      }\n+\n+      if daysLastSeen >= 7 {  // Notification is disabled for 7 or more Days\n+        UIUtilities.showAlertWithTitleAndMessage(\n+          title: NSLocalizedString(\"FDA My Studies\", comment: \"\") as NSString,\n+          message: NSLocalizedString(kMessageAppNotificationOffRemainder, comment: \"\")\n+            as NSString)\n+\n+        ud.set(Date(), forKey: \"NotificationRemainder\")\n+        ud.synchronize()\n+      }\n     }\n+  }\n \n-    @IBAction func searchButtonAction(_: UIBarButtonItem) {\n-        searchView = SearchBarView.instanceFromNib(frame: CGRect(x: 0, y: -200, width: view.frame.size.width, height: 64.0), detail: nil)\n-\n-        UIView.animate(withDuration: 0.2,\n-                       delay: 0.0,\n-                       options: UIView.AnimationOptions.preferredFramesPerSecond60,\n-                       animations: { () -> Void in\n-\n-                           let y: CGFloat = DeviceType.IS_IPHONE_X_OR_HIGH ? 20.0 : 0.0\n-\n-                           self.searchView?.frame = CGRect(x: 0, y: y, width: self.view.frame.size.width, height: 64.0)\n+  /// Used to load the test data from Studylist of type json.\n+  func loadTestData() {\n+    let filePath = Bundle.main.path(forResource: \"StudyList\", ofType: \"json\")\n+    let data = NSData(contentsOfFile: filePath!)\n \n-                           self.searchView?.textFieldSearch?.becomeFirstResponder()\n-                           self.searchView?.delegate = self\n+    do {\n+      let response = try JSONSerialization.jsonObject(with: data! as Data, options: [])\n+        as? [String: Any]\n \n-                           self.slideMenuController()?.leftPanGesture?.isEnabled = false\n+      let studies = (response?[kStudies] as? [[String: Any]])!\n+      var listOfStudies: [Study] = []\n+      for study in studies {\n+        let studyModelObj = Study(studyDetail: study)\n+        listOfStudies.append(studyModelObj)\n+      }\n \n-                           self.navigationController?.view.addSubview(self.searchView!)\n+      // assgin to Gateway\n+      Gateway.instance.studies = listOfStudies\n \n-                           if StudyFilterHandler.instance.searchText.count > 0 {\n-                               self.searchView?.textFieldSearch?.text = StudyFilterHandler.instance.searchText\n-                           }\n-\n-                       }, completion: { (_) -> Void in\n-\n-        })\n+    } catch {\n+      Logger.sharedInstance.info(\"json error: \\(error.localizedDescription)\")\n     }\n-\n-    // MARK: - Custom Bar Buttons\n-\n-    /**\n-     Used to add left bar button item\n-     */\n-    func addLeftBarButton() {\n-        let button = UIButton(type: .custom)\n-        button.setTitle(\"FDA LISTENS!\", for: .normal)\n-        button.titleLabel?.font = UIFont(name: \"HelveticaNeue-Medium\", size: 18)\n-        button.frame = CGRect(x: 0, y: 0, width: 120, height: 30)\n-        button.contentHorizontalAlignment = .left\n-        button.setTitleColor(Utilities.getUIColorFromHex(0x007CBA), for: .normal)\n-\n-        let barItem = UIBarButtonItem(customView: button)\n-\n-        navigationItem.setLeftBarButton(barItem, animated: true)\n+  }\n+\n+  /// CheckIfFetelKickCountRunning method verifies wheather if FetalKick Task is Still running and calculate the time difference.\n+  func checkIfFetelKickCountRunning() {\n+    let ud = UserDefaults.standard\n+\n+    if ud.bool(forKey: \"FKC\"), ud.object(forKey: kFetalKickStartTimeStamp) != nil {\n+      let studyId = (ud.object(forKey: kFetalkickStudyId) as? String)!\n+      let study = Gateway.instance.studies?.filter { $0.studyId == studyId }.last\n+\n+      if study?.userParticipateState.status == .inProgress, study?.status == .Active {\n+        Study.updateCurrentStudy(study: study!)\n+        pushToStudyDashboard(animated: false)\n+      }\n+    } else {\n+      checkIfNotificationEnabled()\n+      if NotificationHandler.instance.studyId.count > 0 {\n+        let studyId = NotificationHandler.instance.studyId\n+        let study = Gateway.instance.studies?.filter { $0.studyId == studyId }.first\n+        Study.updateCurrentStudy(study: study!)\n+\n+        NotificationHandler.instance.studyId = \"\"\n+        performTaskBasedOnStudyStatus()\n+      }\n     }\n+  }\n+\n+  /// Navigate to notification screen.\n+  func navigateToNotifications() {\n+    let gatewayStoryBoard = UIStoryboard(\n+      name: kStoryboardIdentifierGateway, bundle: Bundle.main)\n+    let notificationController = (\n+      gatewayStoryBoard.instantiateViewController(\n+        withIdentifier: kNotificationViewControllerIdentifier)\n+        as? NotificationViewController\n+    )!\n+    navigationController?.pushViewController(notificationController, animated: true)\n+  }\n+\n+  /// Navigate to StudyHomeViewController screen.\n+  func navigateToStudyHome() {\n+    let studyStoryBoard = UIStoryboard(name: kStudyStoryboard, bundle: Bundle.main)\n+    let studyHomeController = (\n+      studyStoryBoard.instantiateViewController(\n+        withIdentifier: String(describing: StudyHomeViewController.classForCoder()))\n+        as? StudyHomeViewController\n+    )!\n+    studyHomeController.delegate = self\n+    navigationController?.pushViewController(studyHomeController, animated: true)\n+  }\n+\n+  /// Navigate the screen to Study Dashboard tabbar viewcontroller screen.\n+  func pushToStudyDashboard(animated: Bool = true) {\n+    let studyStoryBoard = UIStoryboard(name: kStudyStoryboard, bundle: Bundle.main)\n+\n+    let studyDashboard = (\n+      studyStoryBoard.instantiateViewController(\n+        withIdentifier: kStudyDashboardTabbarControllerIdentifier)\n+        as? StudyDashboardTabbarViewController\n+    )!\n+\n+    navigationController?.navigationBar.isHidden = true\n+    navigationController?.pushViewController(studyDashboard, animated: animated)\n+  }\n+\n+  /// Method to display taskViewController for passcode setup if\n+  /// passcode setup is enabled,called only once after signin.\n+  func setPassCode() {\n+    // Remove Passcode if already exist\n+    ORKPasscodeViewController.removePasscodeFromKeychain()\n+\n+    let passcodeStep = ORKPasscodeStep(identifier: kPasscodeStepIdentifier)\n+    passcodeStep.passcodeType = .type4Digit\n+\n+    let task = ORKOrderedTask(identifier: kPasscodeTaskIdentifier, steps: [passcodeStep])\n+    let taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n+    taskViewController.delegate = self\n+    taskViewController.isNavigationBarHidden = true\n+    taskViewController.navigationBar.prefersLargeTitles = false\n+    taskViewController.modalPresentationStyle = .fullScreen\n+    navigationController?.present(\n+      taskViewController, animated: false,\n+      completion: {\n+        self.tableView?.isHidden = false\n+      })\n+  }\n+\n+  /// Load the study data from Database.\n+  func loadStudiesFromDatabase() {\n+    DBHandler.loadStudyListFromDatabase { studies in\n+      if studies.count > 0 {\n+        self.tableView?.isHidden = false\n+        self.studiesList = studies\n+        self.tableView?.reloadData()\n+\n+        self.previousStudyList = studies\n+        self.allStudyList = studies\n+        Gateway.instance.studies = studies\n+\n+        // Applying Filters\n+        let previousStudyFilters = StudyFilterHandler.instance.previousAppliedFilters\n+        if previousStudyFilters.count > 0 {\n+\n+          if User.currentUser.userType == .FDAUser {\n+            self.appliedFilter(\n+              studyStatus: previousStudyFilters.first!,\n+              pariticipationsStatus: previousStudyFilters[safe: 2] ?? [],\n+              categories: previousStudyFilters[safe: 3] ?? [], searchText: \"\",\n+              bookmarked: previousStudyFilters[1].count > 0 ? true : false)  // TBD: Crashed\n+          } else {\n+            self.appliedFilter(\n+              studyStatus: previousStudyFilters.first!, pariticipationsStatus: [],\n+              categories: previousStudyFilters[1], searchText: \"\", bookmarked: false\n+            )\n+          }\n+        } else {\n+          let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n \n-    /**\n-     Used to add right bar button item\n-     */\n-    func addRightBarButton() {\n-        let button = UIButton(type: .custom)\n-        button.setImage(#imageLiteral(resourceName: \"filter_icn\"), for: .normal)\n+          appDelegate.setDefaultFilters(previousCollectionData: [])\n \n-        button.frame = CGRect(x: 0, y: 0, width: 19, height: 22.5)\n-        let barItem = UIBarButtonItem(customView: button)\n+          // using default Filters\n+          let filterStrings = appDelegate.getDefaultFilterStrings()\n \n-        navigationItem.setRightBarButton(barItem, animated: true)\n+          self.appliedFilter(\n+            studyStatus: filterStrings.studyStatus,\n+            pariticipationsStatus: filterStrings.pariticipationsStatus,\n+            categories: filterStrings.categories, searchText: filterStrings.searchText,\n+            bookmarked: filterStrings.bookmark)\n+        }\n+        self.checkIfFetelKickCountRunning()\n+      } else {\n+        if !self.studyListRequestFailed {\n+          self.labelHelperText.isHidden = true\n+          self.tableView?.isHidden = false\n+          self.studyListRequestFailed = false\n+\n+          self.sendRequestToGetStudyList()\n+        } else {\n+          self.tableView?.isHidden = true\n+          self.labelHelperText.isHidden = false\n+          self.labelHelperText.text = kHelperTextForOffline\n+        }\n+      }\n     }\n+  }\n+\n+  /// Sort Studies based on the Study Status.\n+  func getSortedStudies(studies: [Study]) -> [Study] {\n+    var sortedstudies2 = studies.sorted(by: { $0.name!.lowercased() < $1.name!.lowercased() })\n+    sortedstudies2 = sortedstudies2.sorted(\n+      by: { (study1: Study, study2: Study) -> Bool in\n+\n+        if study1.status == study2.status {\n+          return (\n+            study1.userParticipateState.status.sortIndex < study2.userParticipateState\n+              .status\n+              .sortIndex\n+          )\n+        }\n+        return (study1.status.sortIndex < study2.status.sortIndex)\n+      })\n+    return sortedstudies2\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  /// Navigate to notification screen on button clicked.\n+  @IBAction func buttonActionNotification(_: UIBarButtonItem) {\n+    navigateToNotifications()\n+  }\n+\n+  /// Refresh the StudyList.\n+  @objc func refresh(sender _: AnyObject) {\n+    sendRequestToGetStudyList()\n+  }\n+\n+  /// Navigate to StudyFilter screen on button clicked.\n+  @IBAction func filterAction(_: UIBarButtonItem) {\n+    isComingFromFilterScreen = true\n+    performSegue(withIdentifier: filterListSegue, sender: nil)\n+  }\n+\n+  @IBAction func searchButtonAction(_: UIBarButtonItem) {\n+\n+    searchView = SearchBarView.instanceFromNib(\n+      frame: CGRect(x: 0, y: -200, width: view.frame.size.width, height: 64.0), detail: nil)\n+\n+    UIView.animate(\n+      withDuration: 0.2,\n+      delay: 0.0,\n+      options: UIView.AnimationOptions.preferredFramesPerSecond60,\n+      animations: { () -> Void in\n+\n+        let y: CGFloat = DeviceType.IS_IPHONE_X_OR_HIGH ? 20.0 : 0.0\n+        self.searchView?.frame = CGRect(\n+          x: 0, y: y, width: self.view.frame.size.width, height: 64.0)\n+        self.searchView?.textFieldSearch?.becomeFirstResponder()\n+        self.searchView?.delegate = self\n+        self.slideMenuController()?.leftPanGesture?.isEnabled = false\n+        self.navigationController?.view.addSubview(self.searchView!)\n+\n+        if StudyFilterHandler.instance.searchText.count > 0 {\n+          self.searchView?.textFieldSearch?.text = StudyFilterHandler.instance.searchText\n+        }\n+      }, completion: nil)\n \n-    // MARK: - Segue Methods\n+  }\n \n-    override func prepare(for segue: UIStoryboardSegue, sender _: Any?) {\n-        // Get the new view controller using segue.destinationViewController.\n-        // Pass the selected object to the new view controller.\n+  // MARK: - Segue Methods\n \n-        if segue.identifier == filterListSegue {\n-            let filterVc = (segue.destination as? StudyFilterViewController)!\n-           \n-            if StudyFilterHandler.instance.previousAppliedFilters.count > 0 {\n-                filterVc.previousCollectionData = StudyFilterHandler.instance.previousAppliedFilters\n-            }\n-            filterVc.delegate = self\n-        }\n-    }\n+  override func prepare(for segue: UIStoryboardSegue, sender _: Any?) {\n+    // Get the new view controller using segue.destinationViewController.\n+    // Pass the selected object to the new view controller.\n \n-    @IBAction func unwindToStudyList(_: UIStoryboardSegue) {\n-        // unwindStudyListSegue\n-    }\n+    if segue.identifier == filterListSegue {\n+      let filterVc = (segue.destination as? StudyFilterViewController)!\n \n-    // MARK: - Database Methods\n-\n-    func checkDatabaseForStudyInfo(study: Study) {\n-        DBHandler.loadStudyOverview(studyId: (study.studyId)!) { overview in\n-            if overview != nil {\n-                study.overview = overview\n-                // self.navigateBasedOnUserStatus()\n-                self.navigateToStudyHome()\n-            } else {\n-                self.sendRequestToGetStudyInfo(study: study)\n-            }\n-        }\n+      if StudyFilterHandler.instance.previousAppliedFilters.count > 0 {\n+        filterVc.previousCollectionData = StudyFilterHandler.instance.previousAppliedFilters\n+      }\n+      filterVc.delegate = self\n     }\n-\n-    // MARK: - Webservice Requests\n-\n-    /**\n-     Send the webservice request to get Study List\n-     */\n-    func sendRequestToGetStudyList() {\n-        WCPServices().getStudyList(self)\n+  }\n+\n+  @IBAction func unwindToStudyList(_: UIStoryboardSegue) {\n+    // unwindStudyListSegue\n+  }\n+\n+  // MARK: - Database Methods\n+\n+  /// Get the `Study` overview from DB if available and navigate.\n+  /// - Parameter study: Instance of `Study`.\n+  func checkDatabaseForStudyInfo(study: Study) {\n+    DBHandler.loadStudyOverview(studyId: (study.studyId)!) { overview in\n+      if overview != nil {\n+        study.overview = overview\n+        self.navigateToStudyHome()\n+      } else {\n+        // Call API to get StudyInfo.\n+        self.sendRequestToGetStudyInfo(study: study)\n+      }\n     }\n-\n-    /**\n-     Send the webservice request to get Study Info\n-     @param study    Access the data from the study class\n-     */\n-    func sendRequestToGetStudyInfo(study: Study) {\n-        WCPServices().getStudyInformation(studyId: study.studyId, delegate: self)\n+  }\n+\n+  // MARK: - Webservice Requests\n+\n+  /// Send the webservice request to get Study List.\n+  @objc fileprivate func sendRequestToGetStudyList() {\n+    WCPServices().getStudyList(self)\n+  }\n+\n+  /// Send the webservice request to get Study Info.\n+  /// - Parameter study: Instance of `Study`.\n+  func sendRequestToGetStudyInfo(study: Study) {\n+    WCPServices().getStudyInformation(studyId: study.studyId, delegate: self)\n+  }\n+\n+  ///  Send the webservice request to get UserPreferences.\n+  func sendRequestToGetUserPreference() {\n+    UserServices().getStudyStates(self)\n+  }\n+\n+  /// Send the webservice request to Update BookMarkStatus.\n+  /// - Parameter userStudyStatus: Instance of `UserStudyStatus`.\n+  func sendRequestToUpdateBookMarkStatus(userStudyStatus: UserStudyStatus) {\n+    UserServices().updateStudyBookmarkStatus(studyStatus: userStudyStatus, delegate: self)\n+  }\n+\n+  // MARK: - Webservice Responses\n+\n+  /// Handle the Study list webservice response.\n+  func handleStudyListResponse() {\n+    if (Gateway.instance.studies?.count)! > 0 {\n+      loadStudiesFromDatabase()\n+      let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+\n+      if appDelegate.notificationDetails != nil, User.currentUser.userType == .FDAUser {\n+        appDelegate.handleLocalAndRemoteNotification(\n+          userInfoDetails: appDelegate.notificationDetails!)\n+      }\n+    } else {\n+      tableView?.isHidden = true\n+      labelHelperText.text = kHelperTextForOffline\n+      labelHelperText.isHidden = false\n     }\n-\n-    /**\n-     Send the webservice request to get UserPreferences\n-     */\n-    func sendRequestToGetUserPreference() {\n-        UserServices().getStudyStates(self)\n+  }\n+\n+  /// Save information for study which feilds need to be updated.\n+  func handleStudyUpdatedInformation() {\n+    let currentStudy = Study.currentStudy\n+    if currentStudy?.userParticipateState.status == UserStudyStatus.StudyStatus.yetToJoin {\n+      StudyUpdates.studyConsentUpdated = false\n+      StudyUpdates.studyActivitiesUpdated = false\n+      StudyUpdates.studyResourcesUpdated = false\n+\n+      currentStudy?.version = StudyUpdates.studyVersion\n+      currentStudy?.newVersion = StudyUpdates.studyVersion\n     }\n \n-    /**\n-     Send the webservice request to Update BookMarkStatus\n-     @param userStudyStatus    Access the data from UserStudyStatus\n-     */\n-    func sendRequestToUpdateBookMarkStatus(userStudyStatus: UserStudyStatus) {\n-        UserServices().updateStudyBookmarkStatus(studyStauts: userStudyStatus, delegate: self)\n+    DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n+    if StudyUpdates.studyInfoUpdated {\n+      sendRequestToGetStudyInfo(study: Study.currentStudy!)\n+    } else {\n+      navigateBasedOnUserStatus()\n     }\n+  }\n \n-    // MARK: - Webservice Responses\n+  /// navigateBasedOnUserStatus method navigates to StudyDashBoard or StudyHome based on UserParticipationStatus.\n+  func navigateBasedOnUserStatus() {\n+    if User.currentUser.userType == UserType.FDAUser {\n+      if Study.currentStudy?.status == .Active {\n+        // handle accoring to UserStatus\n+        let userStudyStatus = (Study.currentStudy?.userParticipateState.status)!\n \n-    /**\n-     Handle the Study list webservice response\n-     */\n-    func handleStudyListResponse() {\n-        Logger.sharedInstance.info(\"Study Response Handler\")\n-\n-        if (Gateway.instance.studies?.count)! > 0 {\n-            loadStudiesFromDatabase()\n-            let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-\n-            if appDelegate.notificationDetails != nil, User.currentUser.userType == .FDAUser {\n-                appDelegate.handleLocalAndRemoteNotification(userInfoDetails: appDelegate.notificationDetails!)\n-            }\n+        if userStudyStatus == .completed || userStudyStatus == .inProgress {\n+          pushToStudyDashboard()\n         } else {\n-            tableView?.isHidden = true\n-            labelHelperText.text = kHelperTextForOffline\n-            labelHelperText.isHidden = false\n+          checkDatabaseForStudyInfo(study: Study.currentStudy!)\n         }\n+      } else {\n+        checkDatabaseForStudyInfo(study: Study.currentStudy!)\n+      }\n+    } else {\n+      checkDatabaseForStudyInfo(study: Study.currentStudy!)\n     }\n+  }\n \n-    /**\n-     save information for study which feilds need to be updated\n-     */\n-    func handleStudyUpdatedInformation() {\n-        let currentStudy = Study.currentStudy\n-        if currentStudy?.userParticipateState.status == UserStudyStatus.StudyStatus.yetToJoin {\n-            StudyUpdates.studyConsentUpdated = false\n-            StudyUpdates.studyActivitiesUpdated = false\n-            StudyUpdates.studyResourcesUpdated = false\n-\n-            currentStudy?.version = StudyUpdates.studyVersion\n-            currentStudy?.newVersion = StudyUpdates.studyVersion\n-        }\n+  /// Checks `Study` status and do the action.\n+  func performTaskBasedOnStudyStatus() {\n+    let study = Study.currentStudy\n \n-        DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n-        if StudyUpdates.studyInfoUpdated {\n-            sendRequestToGetStudyInfo(study: Study.currentStudy!)\n-        } else {\n-            navigateBasedOnUserStatus()\n-        }\n-    }\n+    if User.currentUser.userType == UserType.FDAUser {\n+      if Study.currentStudy?.status == .Active {\n+        let userStudyStatus = (Study.currentStudy?.userParticipateState.status)!\n \n-    /**\n-     navigateBasedOnUserStatus method navigates to StudyDashBoard or StudyHome based on UserParticipationStatus.\n-     */\n-    func navigateBasedOnUserStatus() {\n-        if User.currentUser.userType == UserType.FDAUser {\n-            if Study.currentStudy?.status == .Active {\n-                // handle accoring to UserStatus\n-                let userStudyStatus = (Study.currentStudy?.userParticipateState.status)!\n-\n-                if userStudyStatus == .completed || userStudyStatus == .inProgress {\n-                    pushToStudyDashboard()\n-                } else {\n-                    checkDatabaseForStudyInfo(study: Study.currentStudy!)\n-                }\n-            } else {\n-                checkDatabaseForStudyInfo(study: Study.currentStudy!)\n-            }\n+        if userStudyStatus == .completed || userStudyStatus == .inProgress {\n+          // check if study version is udpated\n+          if study?.version != study?.newVersion {\n+            WCPServices().getStudyUpdates(study: study!, delegate: self)\n+          } else {\n+            addProgressIndicator()\n+            perform(#selector(loadStudyDetails), with: self, afterDelay: 1)\n+          }\n         } else {\n-            checkDatabaseForStudyInfo(study: Study.currentStudy!)\n+          checkForStudyUpdate(study: study)\n         }\n-    }\n-\n-    func performTaskBasedOnStudyStatus() {\n-        let study = Study.currentStudy\n-\n-        if User.currentUser.userType == UserType.FDAUser {\n-            if Study.currentStudy?.status == .Active {\n-                let userStudyStatus = (Study.currentStudy?.userParticipateState.status)!\n-\n-                if userStudyStatus == .completed || userStudyStatus == .inProgress {\n-                    // check if study version is udpated\n-                    if study?.version != study?.newVersion {\n-                        WCPServices().getStudyUpdates(study: study!, delegate: self)\n-                    } else {\n-                        // let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-                        addProgressIndicator()\n-                        perform(#selector(loadStudyDetails), with: self, afterDelay: 1)\n-                    }\n-                } else {\n-                    checkForStudyUpdate(study: study)\n-                }\n-            } else if Study.currentStudy?.status == .Paused {\n-                let userStudyStatus = (Study.currentStudy?.userParticipateState.status)!\n-\n-                if userStudyStatus == .completed || userStudyStatus == .inProgress {\n-                    UIUtilities.showAlertWithTitleAndMessage(title: \"\", message: NSLocalizedString(kMessageForStudyPausedAfterJoiningState, comment: \"\") as NSString)\n-                } else {\n-                    checkForStudyUpdate(study: study)\n-                }\n-            } else {\n-                checkForStudyUpdate(study: study)\n-            }\n+      } else if Study.currentStudy?.status == .Paused {\n+        let userStudyStatus = (Study.currentStudy?.userParticipateState.status)!\n+\n+        if userStudyStatus == .completed || userStudyStatus == .inProgress {\n+          UIUtilities.showAlertWithTitleAndMessage(\n+            title: \"\",\n+            message: NSLocalizedString(\n+              kMessageForStudyPausedAfterJoiningState, comment: \"\")\n+              as NSString)\n         } else {\n-            checkForStudyUpdate(study: study)\n+          checkForStudyUpdate(study: study)\n         }\n+      } else {\n+        checkForStudyUpdate(study: study)\n+      }\n+    } else {\n+      checkForStudyUpdate(study: study)\n     }\n-\n-    @objc func loadStudyDetails() {\n-        let study = Study.currentStudy\n-        DBHandler.loadStudyDetailsToUpdate(studyId: (study?.studyId)!, completionHandler: { _ in\n-\n-            self.pushToStudyDashboard()\n-            self.removeProgressIndicator()\n-        })\n-    }\n-\n-    func checkForStudyUpdate(study: Study?) {\n-        if study?.version != study?.newVersion {\n-            WCPServices().getStudyUpdates(study: study!, delegate: self)\n-        } else {\n-            checkDatabaseForStudyInfo(study: study!)\n-        }\n+  }\n+\n+  @objc func loadStudyDetails() {\n+    let study = Study.currentStudy\n+    DBHandler.loadStudyDetailsToUpdate(\n+      studyId: (study?.studyId)!,\n+      completionHandler: { _ in\n+\n+        self.pushToStudyDashboard()\n+        self.removeProgressIndicator()\n+      })\n+  }\n+\n+  func checkForStudyUpdate(study: Study?) {\n+    if study?.version != study?.newVersion {\n+      WCPServices().getStudyUpdates(study: study!, delegate: self)\n+    } else {\n+      checkDatabaseForStudyInfo(study: study!)\n     }\n+  }\n }\n \n // MARK: - Applied filter delegate\n \n extension StudyListViewController: StudyFilterDelegates {\n-    // Based on applied filter call WS\n-    func appliedFilter(studyStatus: [String], pariticipationsStatus: [String], categories: [String], searchText: String, bookmarked: Bool) {\n-        var previousCollectionData: [[String]] = []\n-\n-        previousCollectionData.append(studyStatus)\n-\n-        if User.currentUser.userType == .FDAUser {\n-            previousCollectionData.append(bookmarked == true ? [\"Bookmarked\"] : [])\n-            previousCollectionData.append(pariticipationsStatus)\n-        }\n-\n-        previousCollectionData.append(categories.count == 0 ? [] : categories)\n-\n-        StudyFilterHandler.instance.previousAppliedFilters = previousCollectionData\n-\n-        StudyFilterHandler.instance.searchText = \"\"\n-\n-        // filter by study category\n-        var categoryFilteredStudies: [Study]! = []\n-        if categories.count > 0 {\n-            categoryFilteredStudies = allStudyList.filter { categories.contains($0.category!) }\n-        }\n-\n-        // filter by study status\n-        var statusFilteredStudies: [Study]! = []\n-        if studyStatus.count > 0 {\n-            statusFilteredStudies = allStudyList.filter { studyStatus.contains($0.status.rawValue) }\n-        }\n-\n-        // filter by study status\n-        var pariticipationsStatusFilteredStudies: [Study]! = []\n-        if pariticipationsStatus.count > 0 {\n-            pariticipationsStatusFilteredStudies = allStudyList.filter { pariticipationsStatus.contains($0.userParticipateState.status.description) }\n-        }\n-\n-        // filter by bookmark\n-        var bookmarkedStudies: [Study]! = []\n-\n-        if bookmarked {\n-            bookmarkedStudies = allStudyList.filter { $0.userParticipateState.bookmarked == bookmarked }\n-        }\n-\n-        // filter by searched Text\n-        var searchTextFilteredStudies: [Study]! = []\n-        if searchText.count > 0 {\n-            searchTextFilteredStudies = allStudyList.filter {\n-                ($0.name?.containsIgnoringCase(searchText))! || ($0.category?.containsIgnoringCase(searchText))! || ($0.description?.containsIgnoringCase(searchText))! || ($0.sponserName?.containsIgnoringCase(searchText))!\n-            }\n-        }\n \n-        // Intersection\n-        let setStudyStatus = Set<Study>(statusFilteredStudies)\n-\n-        let setpariticipationsStatus = Set<Study>(pariticipationsStatusFilteredStudies)\n-\n-        var statusFilteredSet = Set<Study>()\n-\n-        var allFilteredSet = Set<Study>()\n-\n-        // (setStudyStatus) ^ (setpariticipationsStatus)\n-\n-        if setStudyStatus.count > 0, setpariticipationsStatus.count > 0 {\n-            statusFilteredSet = setStudyStatus.intersection(setpariticipationsStatus)\n-        } else {\n-            if setStudyStatus.count > 0 {\n-                statusFilteredSet = setStudyStatus\n-\n-            } else if setpariticipationsStatus.count > 0 {\n-                statusFilteredSet = setpariticipationsStatus\n-            }\n-        }\n-\n-        var bookMarkAndCategorySet = Set<Study>()\n-\n-        let setCategories = Set<Study>(categoryFilteredStudies)\n+  // Based on applied filter call WS\n+  func appliedFilter(\n+    studyStatus: [String], pariticipationsStatus: [String], categories: [String],\n+    searchText: String, bookmarked: Bool\n+  ) {\n+    var previousCollectionData: [[String]] = []\n+\n+    previousCollectionData.append(studyStatus)\n+    let currentUser = User.currentUser.userType ?? .AnonymousUser\n+    if currentUser == .FDAUser {\n+      previousCollectionData.append(bookmarked == true ? [\"Bookmarked\"] : [])\n+      previousCollectionData.append(pariticipationsStatus)\n+    }\n \n-        let setBookmarkedStudies = Set<Study>(bookmarkedStudies)\n+    previousCollectionData.append(categories.count == 0 ? [] : categories)\n \n-        // (setCategories) ^ (setBookmarkedStudies)\n-        if setCategories.count > 0, setBookmarkedStudies.count > 0 {\n-            bookMarkAndCategorySet = setCategories.intersection(setBookmarkedStudies)\n-        } else {\n-            if setCategories.count > 0 {\n-                bookMarkAndCategorySet = setCategories\n-            } else if setBookmarkedStudies.count > 0 {\n-                bookMarkAndCategorySet = setBookmarkedStudies\n-            }\n-        }\n+    StudyFilterHandler.instance.previousAppliedFilters = previousCollectionData\n+    StudyFilterHandler.instance.searchText = \"\"\n \n-        // (statusFilteredSet) ^ (bookMarkAndCategorySet)\n+    if studyStatus.isEmpty\n+      || (pariticipationsStatus.isEmpty && currentUser != .AnonymousUser)\n+      || categories.isEmpty\n+      && searchText.isEmpty\n+      && !bookmarked {\n+      self.studiesList = []\n+      refreshTableViewWith(searchText: searchText)\n+      return\n+    }\n \n-        if statusFilteredSet.count > 0, bookMarkAndCategorySet.count > 0 {\n-            allFilteredSet = statusFilteredSet.intersection(bookMarkAndCategorySet)\n-        } else {\n-            if (statusFilteredSet.count > 0 && (bookmarked == true || categories.count > 0)) || (bookMarkAndCategorySet.count > 0 && (pariticipationsStatus.count > 0 || studyStatus.count > 0)) {\n-                allFilteredSet = bookMarkAndCategorySet.intersection(statusFilteredSet)\n-            } else {\n-                allFilteredSet = statusFilteredSet.union(bookMarkAndCategorySet)\n-            }\n-        }\n+    /// 1. Filter by study category.\n+    var categoryFilteredStudies: [Study] = []\n+    if categories.count > 0 {\n+      categoryFilteredStudies = allStudyList.filter { categories.contains($0.category!) }\n+    }\n \n-        // (studystatus ^ participantstatus ^ bookmarked ^ category) ^ (searchTextResult)\n-        let setSearchedTextStudies = Set<Study>(searchTextFilteredStudies)\n+    /// 2. Filter by study status.\n+    var statusFilteredStudies: [Study] = []\n+    if studyStatus.count > 0 {\n+      statusFilteredStudies = allStudyList.filter { studyStatus.contains($0.status.rawValue) }\n+    }\n \n-        if allFilteredSet.count > 0, setSearchedTextStudies.count > 0 {\n-            allFilteredSet = allFilteredSet.intersection(setSearchedTextStudies)\n-        } else {\n-            if setSearchedTextStudies.count > 0 {\n-                allFilteredSet = setSearchedTextStudies\n-            }\n-        }\n+    /// 3. Filter by user participation status.\n+    var participationFilteredStudies: [Study] = []\n+    if pariticipationsStatus.count > 0 {\n+      participationFilteredStudies = allStudyList.filter {\n+        pariticipationsStatus.contains($0.userParticipateState.status.description)\n+      }\n+    }\n \n-        // Assigning Filtered result to Studlist\n-        let allStudiesArray: [Study] = Array(allFilteredSet)\n+    /// 4. Filter bookmarked studies.\n+    var bookmarkedStudies: [Study] = []\n+    if bookmarked {\n+      bookmarkedStudies = allStudyList.filter {\n+        $0.userParticipateState.bookmarked == bookmarked\n+      }\n+    }\n \n-        if searchText.count == 0, bookmarked == false, studyStatus.count == 0,\n-            pariticipationsStatus.count == 0, categories.count == 0 {\n-            studiesList = getSortedStudies(studies: allStudyList)\n-        } else {\n-            studiesList = getSortedStudies(studies: allStudiesArray)\n-        }\n+    /// 5. Filter by searched text.\n+    var searchTextFilteredStudies: [Study] = []\n+    if !searchText.isEmpty {\n+      searchTextFilteredStudies = allStudyList.filter {\n+        ($0.name?.containsIgnoringCase(searchText))! || (\n+          $0.category?.containsIgnoringCase(searchText)\n+        )! || ($0.description?.containsIgnoringCase(searchText))! || (\n+          $0.sponserName?.containsIgnoringCase(searchText)\n+        )!\n+      }\n+    }\n \n-        previousStudyList = studiesList\n-        tableView?.reloadData()\n+    /// 6. Perform Intersections.\n+    let statusFilteredStudiesSet = Set<Study>(statusFilteredStudies)\n+    let pariticipationStatusFilteredSet = Set<Study>(participationFilteredStudies)\n+    let setCategories = Set<Study>(categoryFilteredStudies)\n+    let setBookmarkedStudies = Set<Study>(bookmarkedStudies)\n+    let setSearchedTextStudies = Set<Study>(searchTextFilteredStudies)\n \n-        if studiesList.count == 0 {\n-            tableView?.isHidden = true\n-            labelHelperText.isHidden = false\n-            if studyListRequestFailed {\n-                labelHelperText.text = kHelperTextForOffline\n+    var statusFilteredSet = Set<Study>()\n \n-            } else if searchText == \"\" {\n-                labelHelperText.text = kHelperTextForFilteredStudiesNotFound\n-            } else {\n-                labelHelperText.text = kHelperTextForSearchedStudiesNotFound\n-            }\n-        } else {\n-            tableView?.isHidden = false\n-            labelHelperText.isHidden = true\n-        }\n+    if currentUser == .FDAUser {\n+      statusFilteredSet = statusFilteredStudiesSet.intersection(pariticipationStatusFilteredSet)\n+    } else {\n+      statusFilteredSet = statusFilteredStudiesSet\n+    }\n+    statusFilteredSet = statusFilteredSet.intersection(setCategories)\n+    if bookmarked {\n+      statusFilteredSet = statusFilteredSet.intersection(setBookmarkedStudies)\n+    }\n+    if !setSearchedTextStudies.isEmpty, !searchText.isEmpty {\n+      statusFilteredSet = statusFilteredSet.intersection(setSearchedTextStudies)\n     }\n \n-    func didCancelFilter(_: Bool) {\n-        // Do Nothing\n+    // Assigning Filtered result to Studlist\n+    let allStudiesArray: [Study] = Array(statusFilteredSet)\n+    studiesList = getSortedStudies(studies: allStudiesArray)\n+    refreshTableViewWith(searchText: searchText)\n+  }\n+\n+  private func refreshTableViewWith(searchText: String) {\n+    previousStudyList = studiesList\n+    tableView?.reloadData()\n+\n+    if studiesList.count == 0 {\n+      tableView?.isHidden = true\n+      labelHelperText.isHidden = false\n+      if studyListRequestFailed {\n+        labelHelperText.text = kHelperTextForOffline\n+      } else if searchText.isEmpty {\n+        labelHelperText.text = kHelperTextForFilteredStudiesNotFound\n+      } else {\n+        labelHelperText.text = kHelperTextForSearchedStudiesNotFound\n+      }\n+    } else {\n+      tableView?.isHidden = false\n+      labelHelperText.isHidden = true\n     }\n+  }\n+\n+  func didCancelFilter(_: Bool) {\n+    // Do Nothing\n+  }\n }\n \n // MARK: - TableView Data source\n \n extension StudyListViewController: UITableViewDataSource {\n-    func tableView(_: UITableView, numberOfRowsInSection _: Int) -> Int {\n-        return studiesList.count\n-    }\n \n-    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n-        var cellIdentifier = \"studyCell\"\n+  func tableView(_: UITableView, numberOfRo", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 2057}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2MzMwNA==", "bodyText": "please remove commented code", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391763304", "createdAt": "2020-03-12T17:02:49Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ActivityUI/ActivitiesViewController.swift", "diffHunk": "@@ -1,1780 +1,1527 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n-import UIKit\n-import ResearchKit\n import IQKeyboardManagerSwift\n+import ResearchKit\n+import UIKit\n \n let kActivities = \"activities\"\n \n let kActivityUnwindToStudyListIdentifier = \"unwindeToStudyListIdentier\"\n-let kActivityAbondonedAlertMessage = \"You missed the previous run of this activity. Please wait till the next run becomes available. Run timings are given on the Activities list screen.\"\n+let kActivityAbondonedAlertMessage\n+  = \"You missed the previous run of this activity. Please wait till the next run becomes available. Run timings are given on the Activities list screen.\"\n \n-enum ActivityAvailabilityStatus:Int{\n-    case current\n-    case upcoming\n-    case past\n+enum ActivityAvailabilityStatus: Int {\n+  case current\n+  case upcoming\n+  case past\n }\n \n-class ActivitiesViewController : UIViewController{\n-    \n-    @IBOutlet var tableView : UITableView?\n-    @IBOutlet var labelNoNetworkAvailable: UILabel?\n-    \n-    var tableViewSections: Array<Dictionary<String,Any>>! = []\n-    var lastFetelKickIdentifer: String = \"\"  //TEMP\n-    var selectedIndexPath: IndexPath? = nil\n-    var isAnchorDateSet: Bool = false\n-    var taskControllerPresented = false\n-    var refreshControl: UIRefreshControl? //To fetch the updated Activities\n-    \n-    var allActivityList: Array<Dictionary<String,Any>>! = []\n-    var selectedFilter: ActivityFilterType? //Holds the applied FilterTypes\n-    \n-    private var managedResult: [String: Any] = [:]\n-    \n-    let labkeyResponseFetch = ResponseDataFetch()\n-    \n-    // MARK:- Viewcontroller Lifecycle\n-    fileprivate func presentUpdatedConsent() {\n-        let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-        appDelegate.checkConsentStatus(controller: self)\n+class ActivitiesViewController: UIViewController {\n+\n+  // MARK: - Outlets\n+  @IBOutlet var tableView: UITableView?\n+\n+  @IBOutlet var labelNoNetworkAvailable: UILabel?\n+\n+  // MARK: - Properties\n+  private lazy var tableViewSections: [[String: Any]]! = []\n+\n+  private lazy var lastFetelKickIdentifer: String = \"\"  //TEMP\n+  private lazy var selectedIndexPath: IndexPath? = nil\n+\n+  private lazy var isAnchorDateSet: Bool = false\n+  private lazy var taskControllerPresented = false\n+\n+  /// To fetch the updated Activities.\n+  var refreshControl: UIRefreshControl?\n+\n+  private lazy var allActivityList: [[String: Any]]! = []\n+\n+  /// Holds the applied FilterTypes.\n+  var selectedFilter: ActivityFilterType?\n+\n+  private lazy var managedResult: [String: Any] = [:]\n+\n+  let labkeyResponseFetch = ResponseDataFetch()\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  fileprivate func presentUpdatedConsent() {\n+    let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+    appDelegate.checkConsentStatus(controller: self)\n+  }\n+\n+  deinit {\n+    Logger.sharedInstance.info(\"\\(self): deinit\")\n+  }\n+\n+  // MARK: - Viewcontroller Lifecycle\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    selectedFilter = ActivityFilterType.all\n+\n+    self.tableView?.estimatedRowHeight = 126\n+    self.tableView?.rowHeight = UITableView.automaticDimension\n+\n+    self.navigationItem.title = NSLocalizedString(\"STUDY ACTIVITIES\", comment: \"\")\n+    self.tableView?.sectionHeaderHeight = 30\n+\n+    self.navigationController?.navigationItem.rightBarButtonItem?.tintColor = UIColor.gray\n+\n+    if (Study.currentStudy?.studyId) != nil {\n+      if StudyUpdates.studyConsentUpdated {\n+        NotificationHandler.instance.activityId = \"\"\n+        presentUpdatedConsent()\n+      }\n     }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        selectedFilter = ActivityFilterType.all\n-        \n-        self.tableView?.estimatedRowHeight = 126\n-        self.tableView?.rowHeight = UITableView.automaticDimension\n-        \n-        self.tabBarController?.delegate = self\n-        \n-        self.navigationItem.title = NSLocalizedString(\"STUDY ACTIVITIES\", comment: \"\")\n-        self.tableView?.sectionHeaderHeight = 30\n-        \n-        self.navigationController?.navigationItem.rightBarButtonItem?.tintColor = UIColor.gray\n-        \n-        if (Study.currentStudy?.studyId) != nil {\n-            if StudyUpdates.studyConsentUpdated {\n-                NotificationHandler.instance.activityId = \"\"\n-                presentUpdatedConsent()\n-            }\n-        }\n-        \n-        //create refresh control for pull to refresh\n-        refreshControl = UIRefreshControl()\n-        refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n-        refreshControl?.addTarget(self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n-        tableView?.addSubview(refreshControl!)\n+\n+    // create refresh control for pull to refresh\n+    refreshControl = UIRefreshControl()\n+    refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n+    refreshControl?.addTarget(\n+      self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n+    tableView?.addSubview(refreshControl!)\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+    self.navigationController?.interactivePopGestureRecognizer?.isEnabled = false\n+\n+    if Utilities.isStandaloneApp() {\n+      self.setNavigationBarItem()\n+    } else {\n+      self.addHomeButton()\n     }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        self.navigationController?.interactivePopGestureRecognizer?.isEnabled = false\n-        UIApplication.shared.statusBarStyle = .default\n-        \n-        if Utilities.isStandaloneApp() {\n-            self.setNavigationBarItem()\n-        }\n-        else {\n-            self.addHomeButton()\n-        }\n-       \n-        \n-        if !taskControllerPresented {\n-            taskControllerPresented = false\n-            self.checkForActivitiesUpdates()\n-        }\n-        \n-        if tableViewSections.count == 0 {\n-            self.tableView?.isHidden = true\n-            self.labelNoNetworkAvailable?.isHidden = false\n-            \n-        } else {\n-            self.tableView?.isHidden = false\n-            self.labelNoNetworkAvailable?.isHidden = true\n-        }\n-        \n-        \n+\n+    if !taskControllerPresented {\n+      taskControllerPresented = false\n+      self.checkForActivitiesUpdates()\n     }\n-    \n-    override func viewDidAppear(_ animated: Bool) {\n-        super.viewDidAppear(animated)\n-        \n-        let message =  \"The study \" + (Study.currentStudy?.name!)! + \" is 100 percent complete. Thank you for your participation.\"\n-       // UIUtilities.showAlertWithMessage(alertMessage: message)\n-        \n+\n+    if tableViewSections.count == 0 {\n+      self.tableView?.isHidden = true\n+      self.labelNoNetworkAvailable?.isHidden = false\n+\n+    } else {\n+      self.tableView?.isHidden = false\n+      self.labelNoNetworkAvailable?.isHidden = true\n     }\n-    \n-    // MARK: Helper Methods\n-    \n-    func getLabkeyResponse() {\n-        \n-        let ud = UserDefaults.standard\n-        let key = \"LabKeyResponse\" + (Study.currentStudy?.studyId)!\n-        if !(ud.bool(forKey: key)){\n-            labkeyResponseFetch.checkUpdates()\n-        }\n+\n+  }\n+\n+  // MARK: - Helper Methods\n+\n+  func getLabkeyResponse() {\n+\n+    let ud = UserDefaults.standard\n+    let key = \"LabKeyResponse\" + (Study.currentStudy?.studyId)!\n+    if !(ud.bool(forKey: key)) {\n+      labkeyResponseFetch.checkUpdates()\n     }\n-    \n-    func checkForActivitiesUpdates(){\n-        \n-        if StudyUpdates.studyActivitiesUpdated {\n-            \n-            self.sendRequestToGetActivityStates()\n-            \n-            //udpate status to false so notification can be registered again\n-            Study.currentStudy?.activitiesLocalNotificationUpdated = false\n-            DBHandler.updateLocalNotificaitonUpdated(studyId: (Study.currentStudy?.studyId)!,status: false)\n-            \n-        } else {\n-            \n-            if self.refreshControl != nil && (self.refreshControl?.isRefreshing)!{\n-                self.refreshControl?.endRefreshing()\n-            }\n-            //self.loadActivitiesFromDatabase()\n-            self.fetchActivityAnchorDateResponseFromLabkey()\n-        }\n+  }\n+\n+  /// Checks for Activity updates from WCP.\n+  func checkForActivitiesUpdates() {\n+\n+    if StudyUpdates.studyActivitiesUpdated {\n+\n+      self.sendRequestToGetActivityStates()\n+\n+      /// Update status to false so notification can be registered again.\n+      Study.currentStudy?.activitiesLocalNotificationUpdated = false\n+      DBHandler.updateLocalNotificationScheduleStatus(\n+        studyId: (Study.currentStudy?.studyId)!, status: false)\n+\n+    } else {\n+\n+      if self.refreshControl != nil && (self.refreshControl?.isRefreshing)! {\n+        self.refreshControl?.endRefreshing()\n+      }\n+      self.fetchActivityAnchorDateResponseFromLabkey()\n     }\n-    \n-    /**\n-     checkIfFetelKickCountRunning method verifies whether if FetalKick Task is Still running and calculate the time difference.\n-     */\n-    func checkIfFetelKickCountRunning(){\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if (ud.bool(forKey: \"FKC\") && ud.object(forKey: kFetalKickStartTimeStamp) != nil) {\n-            \n-            //let studyId = (ud.object(forKey: kFetalkickStudyId)  as? String)!\n-            let activityId = (ud.object(forKey: kFetalKickActivityId)  as? String)!\n-            let activity  = Study.currentStudy?.activities?.filter({$0.actvityId == activityId}).last\n-            \n-            Study.updateCurrentActivity(activity: activity!)\n-            //check in database\n-            DBHandler.loadActivityMetaData(activity: activity!, completionHandler: { (found) in\n-                \n-                if found {\n-                    self.createActivity()\n-                }\n-                \n-            })\n-            \n-        } else {\n-            //check if user navigated from notification\n-            \n-            if NotificationHandler.instance.activityId.count > 0 {\n-                \n-                let activityId = NotificationHandler.instance.activityId\n-                \n-                let rowDetail = tableViewSections[0]\n-                let activities = (rowDetail[\"activities\"] as? Array<Activity>)!\n-                let index = activities.index(where: {$0.actvityId == activityId})\n-                let ip = IndexPath.init(row: index!, section: 0)\n-                self.selectedIndexPath = ip\n-                self.tableView?.selectRow(at: ip, animated: true, scrollPosition: .middle)\n-                self.tableView?.delegate?.tableView!(self.tableView!, didSelectRowAt: ip)\n-                \n-                NotificationHandler.instance.activityId = \"\"\n-            }\n-        }\n+  }\n+\n+  /// Verifies whether if FetalKick Task is Still running and calculate the time difference.\n+  func checkIfFetelKickCountRunning() {\n+\n+    let ud = UserDefaults.standard\n+\n+    if ud.bool(forKey: \"FKC\") && ud.object(forKey: kFetalKickStartTimeStamp) != nil {\n+\n+      let activityId = (ud.object(forKey: kFetalKickActivityId) as? String)!\n+      let activity = Study.currentStudy?.activities?.filter({ $0.actvityId == activityId })\n+        .last\n+\n+      Study.updateCurrentActivity(activity: activity!)\n+      // check in database\n+      DBHandler.loadActivityMetaData(\n+        activity: activity!,\n+        completionHandler: { (found) in\n+\n+          if found {\n+            self.createActivity()\n+          }\n+\n+        })\n+\n+    } else {\n+      /// check if user navigated from notification\n+      if NotificationHandler.instance.activityId.count > 0 {\n+\n+        let activityId = NotificationHandler.instance.activityId\n+\n+        let rowDetail = tableViewSections[0]\n+        let activities = (rowDetail[\"activities\"] as? [Activity])!\n+        let index = activities.firstIndex(where: { $0.actvityId == activityId })\n+        let ip = IndexPath.init(row: index!, section: 0)\n+        self.selectedIndexPath = ip\n+        self.tableView?.selectRow(at: ip, animated: true, scrollPosition: .middle)\n+        self.tableView?.delegate?.tableView!(self.tableView!, didSelectRowAt: ip)\n+\n+        NotificationHandler.instance.activityId = \"\"\n+      }\n     }\n-    \n-    /**\n-     RegisterNotificationForAnchorDate method sets the notification for the available resource\n-     */\n-    \n-    func registerNotificationForAnchorDate(){\n-        \n-        DBHandler.getResourcesWithAnchorDateAvailable(studyId: (Study.currentStudy?.studyId)!) { (resourcesList) in\n-            if resourcesList.count > 0 {\n-                let todayDate = Date()\n-                for resource in resourcesList {\n-                    \n-                    if resource.startDate == nil && resource.endDate == nil {\n-                        \n-                        let anchorDateObject = Study.currentStudy?.anchorDate\n-                        //Fetch AnchorData based availablity\n-                        if(anchorDateObject != nil && (anchorDateObject?.isAnchorDateAvailable())!) {\n-                            \n-                            let anchorDate = Study.currentStudy?.anchorDate?.date?.startOfDay\n-                            \n-                            if anchorDate != nil {\n-                                \n-                                //also anchor date condition\n-                                let startDateInterval = TimeInterval(60*60*24*(resource.anchorDateStartDays))\n-                                \n-                                let endDateInterval = TimeInterval(60*60*24*(resource.anchorDateEndDays))\n-                                \n-                                let startAnchorDate = anchorDate?.addingTimeInterval(startDateInterval)\n-                                var endAnchorDate = anchorDate?.addingTimeInterval(endDateInterval)\n-                                \n-                                endAnchorDate = endAnchorDate?.endOfDay\n-                                let startDateResult = (startAnchorDate?.compare(todayDate))! as ComparisonResult\n-                                //let endDateResult = (endAnchorDate?.compare(todayDate))! as ComparisonResult\n-                                self.isAnchorDateSet = false\n-                                \n-                                if startDateResult == .orderedDescending {\n-                                    //upcoming\n-                                    let notfiId = resource.resourceId! + (Study.currentStudy?.studyId)!\n-                                    DBHandler.isNotificationSetFor(notification: notfiId\n-                                        , completionHandler: { (found) in\n-                                            if !found {\n-                                                \n-                                                //Create AppLocalNotification\n-                                                let notification = AppLocalNotification()\n-                                                notification.id = resource.resourceId! + (Study.currentStudy?.studyId)!\n-                                                notification.message = resource.notificationMessage\n-                                                notification.title = \"New Resource Available\"\n-                                                notification.startDate = startAnchorDate\n-                                                notification.endDate = endAnchorDate\n-                                                notification.type = AppNotification.NotificationType.Study\n-                                                notification.subType = AppNotification.NotificationSubType.Resource\n-                                                notification.audience = Audience.Limited\n-                                                notification.studyId = (Study.currentStudy?.studyId)!\n-                                                //notification.activityId = Study.currentActivity?.actvityId\n-                                                \n-                                                //Save Notification to Database\n-                                                DBHandler.saveLocalNotification(notification: notification)\n-                                                \n-                                                //register notification\n-                                                var notificationDate = startAnchorDate?.startOfDay\n-                                                notificationDate = notificationDate?.addingTimeInterval(43200)\n-                                                let message = resource.notificationMessage\n-                                                let userInfo = [\"studyId\": (Study.currentStudy?.studyId)!,\n-                                                                \"type\": \"resource\"];\n-                                                LocalNotification.scheduleNotificationOn(date: notificationDate!, message: message!, userInfo: userInfo, id: notification.id)\n-                                            }\n-                                    })\n-                                }\n-                            }\n-                        }\n-                    }\n+  }\n+\n+  /// Sets the notification for the available resource.\n+  func registerNotificationForAnchorDate() {\n+\n+    DBHandler.getResourcesWithAnchorDateAvailable(studyId: (Study.currentStudy?.studyId)!) {\n+      (resourcesList) in\n+      if resourcesList.count > 0 {\n+        let todayDate = Date()\n+        for resource in resourcesList {\n+\n+          if resource.startDate == nil && resource.endDate == nil {\n+\n+            let anchorDateObject = Study.currentStudy?.anchorDate\n+            // Fetch AnchorData based availablity\n+            if anchorDateObject != nil && (anchorDateObject?.isAnchorDateAvailable())! {\n+\n+              let anchorDate = Study.currentStudy?.anchorDate?.date?.startOfDay\n+\n+              if anchorDate != nil {\n+\n+                // also anchor date condition\n+                let startDateInterval = TimeInterval(\n+                  60*60*24*(resource.anchorDateStartDays))\n+\n+                let endDateInterval = TimeInterval(\n+                  60*60*24*(resource.anchorDateEndDays))\n+\n+                let startAnchorDate = anchorDate?.addingTimeInterval(\n+                  startDateInterval)\n+                var endAnchorDate = anchorDate?.addingTimeInterval(endDateInterval)\n+\n+                endAnchorDate = endAnchorDate?.endOfDay\n+                let startDateResult = (startAnchorDate?.compare(todayDate))!\n+                  as ComparisonResult\n+                self.isAnchorDateSet = false\n+\n+                if startDateResult == .orderedDescending {\n+                  // upcoming\n+                  let notfiId = resource.resourceId! + (\n+                    Study.currentStudy?.studyId\n+                  )!\n+                  DBHandler.isNotificationSetFor(\n+                    notification: notfiId,\n+                    completionHandler: { (found) in\n+                      if !found {\n+\n+                        // Create AppLocalNotification\n+                        let notification = AppLocalNotification()\n+                        notification.id = resource.resourceId! + (\n+                          Study.currentStudy?.studyId\n+                        )!\n+                        notification.message = resource.notificationMessage\n+                        notification.title = \"New Resource Available\"\n+                        notification.startDate = startAnchorDate\n+                        notification.endDate = endAnchorDate\n+                        notification.type = AppNotification.NotificationType\n+                          .Study\n+                        notification.subType = AppNotification\n+                          .NotificationSubType.Resource\n+                        notification.audience = Audience.Limited\n+                        notification.studyId = (\n+                          Study.currentStudy?.studyId\n+                        )!\n+                        // Save Notification to Database\n+                        DBHandler.saveLocalNotification(\n+                          notification: notification)\n+\n+                        // register notification\n+                        var notificationDate = startAnchorDate?.startOfDay\n+                        notificationDate = notificationDate?\n+                          .addingTimeInterval(43200)\n+                        let message = resource.notificationMessage\n+                        let userInfo = [\n+                          \"studyId\": (Study.currentStudy?.studyId)!,\n+                          \"type\": \"resource\"\n+                        ]\n+                        LocalNotification.scheduleNotificationOn(\n+                          date: notificationDate!, message: message!,\n+                          userInfo: userInfo,\n+                          id: notification.id)\n+                      }\n+                    })\n                 }\n+              }\n             }\n+          }\n         }\n+      }\n     }\n-    \n-    \n-    // MARK:- Button Actions\n-    \n-    /**\n-     Home Button Clicked\n-     @param sender    Accepts any kind of object\n-     */\n-    @IBAction func homeButtonAction(_ sender: AnyObject){\n-        self.performSegue(withIdentifier: kActivityUnwindToStudyListIdentifier, sender: self)\n+  }\n+\n+  func checkForDashBoardInfo() {\n+\n+    DBHandler.loadStatisticsForStudy(studyId: (Study.currentStudy?.studyId)!) {\n+      (statiticsList) in\n+\n+      if statiticsList.count != 0 {\n+        // Do Nothing\n+      } else {\n+        self.sendRequestToGetDashboardInfo()\n+      }\n     }\n-    \n-    @IBAction func filterButtonAction(_ sender: AnyObject){\n-        let frame = self.view.frame\n-        \n-        if self.selectedFilter == nil {\n-            self.selectedFilter = ActivityFilterType.all\n-        }\n-        //create and load FilterView\n-        let view = ActivityFilterView.instanceFromNib(frame: frame , selectedIndex: self.selectedFilter!)\n-        view.delegate = self\n-        self.tabBarController?.view.addSubview(view)\n+  }\n+\n+  @objc func refresh(sender: AnyObject) {\n+    WCPServices().getStudyUpdates(study: Study.currentStudy!, delegate: self)\n+  }\n+\n+  func fetchActivityAnchorDateResponseFromLabkey() {\n+    AnchorDateHandler().fetchActivityAnchorDateResponseFromLabkey { (_) in\n+      self.loadActivitiesFromDatabase()\n     }\n-    \n-    // MARK: Helper Methods\n-    func checkForDashBoardInfo(){\n-        \n-        DBHandler.loadStatisticsForStudy(studyId: (Study.currentStudy?.studyId)!) { (statiticsList) in\n-            \n-            if statiticsList.count != 0 {\n-                //Do Nothing\n-            } else {\n-                self.sendRequestToGetDashboardInfo()\n-            }\n+  }\n+\n+  /// To load the Activities data from database.\n+  func loadActivitiesFromDatabase() {\n+\n+    if DBHandler.isActivitiesEmpty((Study.currentStudy?.studyId)!) {\n+      self.sendRequestToGetActivityStates()\n+    } else {\n+\n+      DBHandler.loadActivityListFromDatabase(studyId: (Study.currentStudy?.studyId)!) {\n+        (activities) in\n+        if activities.count > 0 {\n+          Study.currentStudy?.activities = activities\n+          self.handleActivityListResponse()\n         }\n+      }\n     }\n-    \n-    \n-    @objc func refresh(sender:AnyObject) {\n-        \n-        Logger.sharedInstance.info(\"Request for study Updated...\")\n-        WCPServices().getStudyUpdates(study: Study.currentStudy!, delegate: self)\n-        //self.sendRequesToGetActivityList()\n-    }\n-    \n-    \n-    // MARK:-\n-    \n-    func fetchActivityAnchorDateResponseFromLabkey() {\n-        \n-        AnchorDateHandler().fetchActivityAnchorDateResponseFromLabkey { (status) in\n-            print(\"Finished 1\")\n-            //if status {\n-                //DispatchQueue.main.async {\n-                    self.loadActivitiesFromDatabase()\n-                //}\n-                \n-            //}\n-            \n-        }\n-        print(\"Finished 0\")\n+  }\n+\n+  /// To create an activity using ORKTaskViewController.\n+  func createActivity() {\n+\n+    IQKeyboardManager.shared.enableAutoToolbar = false\n+\n+    if Utilities.isValidObject(someObject: Study.currentActivity?.steps as AnyObject?) {\n+      // Create ActivityBuilder instance.\n+      ActivityBuilder.currentActivityBuilder = ActivityBuilder()\n+      ActivityBuilder.currentActivityBuilder.initWithActivity(\n+        activity: Study.currentActivity!)\n     }\n-    \n-    /**\n-     Used to load the Actif=vities data from database\n-     */\n-    func loadActivitiesFromDatabase(){\n-        \n-        if DBHandler.isActivitiesEmpty((Study.currentStudy?.studyId)!) {\n-            self.sendRequestToGetActivityStates()\n-        }\n-        else {\n-            \n-            DBHandler.loadActivityListFromDatabase(studyId: (Study.currentStudy?.studyId)!) { (activities) in\n-                if activities.count > 0 {\n-                    Study.currentStudy?.activities = activities\n-                    \n-                    self.handleActivityListResponse()\n-                    \n-                    \n-                } else {\n-                    \n-                    //self.sendRequestToGetActivityStates()\n-                }\n-            }\n-        }\n+\n+    let task: ORKTask?\n+    let taskViewController: ORKTaskViewController?\n+\n+    task = ActivityBuilder.currentActivityBuilder.createTask()\n+\n+    if task != nil {\n+\n+      // Check if restorationData is available.\n+      if Study.currentActivity?.currentRun.restortionData != nil {\n+        let restoredData = Study.currentActivity?.currentRun.restortionData\n+\n+        taskViewController = ORKTaskViewController(\n+          task: task, restorationData: restoredData, delegate: self)\n+      } else {\n+\n+        taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n+        taskViewController?.outputDirectory = FileManager.default.urls(\n+          for: .documentDirectory, in: .userDomainMask).first!\n+      }\n+\n+      taskViewController?.showsProgressInNavigationBar = true\n+\n+      taskViewController?.title = \"Activity\"\n+\n+      // Customize appearance of TaskViewController\n+      UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+        = kUIColorForSubmitButtonBackground\n+\n+      taskViewController?.delegate = self\n+      taskControllerPresented = true\n+      taskViewController?.navigationBar.prefersLargeTitles = false\n+\n+      taskViewController?.modalPresentationStyle = .fullScreen\n+      present(taskViewController!, animated: true, completion: nil)\n+\n+    } else {\n+      // Task creation failed\n+      UIUtilities.showAlertMessage(\n+        kAlertMessageText, errorMessage: NSLocalizedString(\"Invalid Data!\", comment: \"\"),\n+        errorAlertActionTitle: NSLocalizedString(\"OK\", comment: \"\"),\n+        viewControllerUsed: self)\n     }\n-    \n-    \n-    /**\n-     Used to create an activity using ORKTaskViewController\n-     */\n-    func createActivity(){\n-        \n-        //Disable Custom KeyPad with toolbars\n-//        IQKeyboardManager.sharedManager().enable = false\n-        IQKeyboardManager.shared.enableAutoToolbar = false\n-        \n-        if Utilities.isValidObject(someObject: Study.currentActivity?.steps as AnyObject?){\n-            \n-            //Create ActivityBuilder instance\n-            ActivityBuilder.currentActivityBuilder = ActivityBuilder()\n-            ActivityBuilder.currentActivityBuilder.initWithActivity(activity: Study.currentActivity! )\n-        }\n-        \n-        let task: ORKTask?\n-        let taskViewController: ORKTaskViewController?\n-        \n-        task = ActivityBuilder.currentActivityBuilder.createTask()\n-        \n-        if task != nil {\n-            \n-            //check if restorationData is available\n-            if Study.currentActivity?.currentRun.restortionData != nil {\n-                let restoredData = Study.currentActivity?.currentRun.restortionData\n-                \n-                //let result: ORKResult?\n-                taskViewController = ORKTaskViewController(task: task, restorationData: restoredData, delegate: self)\n-            } else {\n-                \n-                taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n-                taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-            }\n-            \n-            taskViewController?.showsProgressInNavigationBar = true\n-            \n-            taskViewController?.title = \"Activity\"\n-            \n-            //Customize appearance of TaskViewController\n-            UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-            \n-            taskViewController?.delegate = self\n-            UIApplication.shared.statusBarStyle = .default\n-            taskControllerPresented = true\n-            taskViewController?.modalPresentationStyle = .fullScreen\n-            present(taskViewController!, animated: true, completion: nil)\n-            \n-        } else {\n-            //Task creation failed\n-            UIUtilities.showAlertMessage(kAlertMessageText, errorMessage: NSLocalizedString(\"Invalid Data!\", comment: \"\"), errorAlertActionTitle: NSLocalizedString(\"OK\", comment: \"\"), viewControllerUsed: self)\n-        }\n-        \n+\n+  }\n+\n+  /// To get Activity Availability Status.\n+  /// - Parameter activity: Instance of `Activity` to check it's status.\n+  func getActivityAvailabilityStatus(activity: Activity) -> ActivityAvailabilityStatus {\n+\n+    var todayDate = Date().utcDate()\n+\n+    let difference = UserDefaults.standard.value(forKey: \"offset\") as? Int\n+    if difference != nil {\n+      todayDate = todayDate.addingTimeInterval(TimeInterval(difference!))\n     }\n-    \n-    \n-    /**\n-     Used to get Activity Availability Status\n-     @param activity    Accepts data from Activity class\n-     @return ActivityAvailabilityStatus\n-     */\n-    func getActivityAvailabilityStatus(activity: Activity) -> ActivityAvailabilityStatus {\n-        \n-        var todayDate = Date().utcDate()\n-        \n-        let difference = UserDefaults.standard.value(forKey: \"offset\") as? Int\n-        if difference != nil {\n-            todayDate = todayDate.addingTimeInterval(TimeInterval(difference!))\n-        }\n-        \n-        if activity.startDate != nil && activity.endDate != nil {\n-            \n-            let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n-            let endDateResult = (activity.endDate?.compare(todayDate))! as ComparisonResult\n-            \n-            if startDateResult == .orderedAscending && endDateResult == .orderedDescending{\n-                return .current\n-                \n-            } else if startDateResult == .orderedDescending {\n-                return .upcoming\n-                \n-            } else if endDateResult == .orderedAscending {\n-                return .past\n-            }\n-        } else if activity.startDate != nil {\n-            \n-            let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n-            \n-            if startDateResult == .orderedAscending{\n-                return .current\n-                \n-            } else if startDateResult == .orderedDescending {\n-                return .upcoming\n-            }\n-        }\n+\n+    if activity.startDate != nil && activity.endDate != nil {\n+\n+      let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n+      let endDateResult = (activity.endDate?.compare(todayDate))! as ComparisonResult\n+\n+      if startDateResult == .orderedAscending && endDateResult == .orderedDescending {\n         return .current\n+\n+      } else if startDateResult == .orderedDescending {\n+        return .upcoming\n+\n+      } else if endDateResult == .orderedAscending {\n+        return .past\n+      }\n+    } else if activity.startDate != nil {\n+\n+      let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n+\n+      if startDateResult == .orderedAscending {\n+        return .current\n+\n+      } else if startDateResult == .orderedDescending {\n+        return .upcoming\n+      }\n     }\n-    \n-    \n-    /**\n-     Used to handle Activity list response\n-     */\n-    func handleActivityListResponse(){\n-        \n-        tableViewSections = []\n-        allActivityList = []\n-        let activities = Study.currentStudy?.activities\n-        \n-        var currentActivities: Array<Activity> = []\n-        var upcomingActivities: Array<Activity> = []\n-        var pastActivities: Array<Activity> = []\n-        \n-        var isInActiveActivitiesAreAvailable: Bool! = false\n-        for activity in activities! {\n-            \n-            if activity.state == \"active\" || activity.state == nil {\n-                \n-                let status =  self.getActivityAvailabilityStatus(activity: activity)\n-                switch status {\n-                case .current:\n-                    currentActivities.append(activity)\n-                case .upcoming:\n-                    upcomingActivities.append(activity)\n-                case .past:\n-                    pastActivities.append(activity)\n-                }\n-            } else {\n-                \n-                isInActiveActivitiesAreAvailable = true\n-                DBHandler.deleteDBLocalNotification(activityId: activity.actvityId!,studyId: activity.studyId!)\n-            }\n-        }\n-        \n-        if isInActiveActivitiesAreAvailable {\n-            LocalNotification.refreshAllLocalNotification()\n-        }\n-        \n-        //sort as per start date\n-        currentActivities.sort(by: {$0.startDate?.compare($1.startDate!) == .orderedAscending})\n-        upcomingActivities.sort(by: {$0.startDate?.compare($1.startDate!) == .orderedAscending})\n-        pastActivities.sort(by: {$0.startDate?.compare($1.startDate!) == .orderedAscending})\n-        \n-        let  sortedCurrentActivities =  currentActivities.sorted(by: { (activity1: Activity, activity2: Activity) -> Bool in\n-            \n-            return (activity1.userParticipationStatus.status.sortIndex < activity2.userParticipationStatus.status.sortIndex)\n-        })\n-        \n-        \n-        let currentDetails = [\"title\": \"CURRENT\",\"activities\": sortedCurrentActivities] as [String : Any]\n-        let upcomingDetails = [\"title\": \"UPCOMING\",\"activities\": upcomingActivities] as [String : Any]\n-        let pastDetails = [\"title\": \"PAST\",\"activities\": pastActivities] as [String : Any]\n-        \n-        allActivityList.append(currentDetails)\n-        allActivityList.append(upcomingDetails)\n-        allActivityList.append(pastDetails)\n-        \n-        tableViewSections = allActivityList\n-        \n-        if self.selectedFilter == .tasks || self.selectedFilter == .surveys {\n-            \n-            let filterType:ActivityType! =  (selectedFilter == .surveys ? .Questionnaire : .activeTask)\n-            self.updateSectionArray(activityType: filterType)\n-        }\n-        \n-        DispatchQueue.main.async {\n-            \n-            self.tableView?.reloadData()\n-            self.tableView?.isHidden = false\n-            self.labelNoNetworkAvailable?.isHidden = true\n-            self.updateCompletionAdherence()\n-        }\n-        \n-        \n-        \n-        \n-        if (User.currentUser.settings?.localNotifications)! {\n-            print(\"localNotifications enabled\")\n-            if !(Study.currentStudy?.activitiesLocalNotificationUpdated)! {\n-                print(\"Registerig Notification\")\n-                //Register LocalNotifications\n-                LocalNotification.registerAllLocalNotificationFor(activities: (Study.currentStudy?.activities)!) { (finished,notificationlist) in\n-                    print(\"Notification set sucessfully\")\n-                    Study.currentStudy?.activitiesLocalNotificationUpdated = true\n-                    DBHandler.saveRegisteredLocaNotification(notificationList: notificationlist)\n-                    DBHandler.updateLocalNotificaitonUpdated(studyId: (Study.currentStudy?.studyId)!,status: true)\n-                    LocalNotification.refreshAllLocalNotification()\n-                }\n-                \n-            }\n-        }\n-        \n-        self.checkIfFetelKickCountRunning()\n-        \n-        Logger.sharedInstance.info(\"Activities Displayed to user\")\n-    }\n-    \n-    /**\n-     Used to update Activity Run Status\n-     @param status    Accepts data from UserActivityStatus class and ActivityStatus enum\n-     */\n-    func updateActivityRunStuatus(status: UserActivityStatus.ActivityStatus){\n-        \n-        let activity = Study.currentActivity!\n-        \n-        let activityStatus = User.currentUser.updateActivityStatus(studyId: activity.studyId!, activityId: activity.actvityId!,runId: String(activity.currentRunId), status: status)\n-        activityStatus.compeltedRuns = activity.compeltedRuns\n-        activityStatus.incompletedRuns = activity.incompletedRuns\n-        activityStatus.totalRuns = activity.totalRuns\n-        activityStatus.activityVersion = activity.version\n-        \n-        //Update participationStatus to server\n-        UserServices().updateUserActivityParticipatedStatus(studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n-        \n-        //Update participationStatus to DB\n-        DBHandler.updateActivityParticipationStatus(activity: activity)\n-        \n-        if status == .completed {\n-            self.updateCompletionAdherence()\n-        }\n-        \n-    }\n-    \n-    /**\n-     updateCompletionAdherence, calculates the Completion & Adherence based on following criteria\n-     completion = ((totalCompletedRuns + totalIncompletedRuns) * 100) / (totalRuns)\n-     adherence =  (totalCompletedRuns*100) / (totalCompletedRuns + totalIncompletedRuns)\n-     \n-     and alerts the user about the study Completion Status\n-     \n-     */\n-    func updateCompletionAdherence() {\n-        \n-        var totalRuns = 0\n-        var totalCompletedRuns = 0\n-        var totalIncompletedRuns = 0\n-        let activities = Study.currentStudy?.activities //.filter({$0.state == \"active\"})\n-        \n-        //Calculate Runs\n-        for activity in activities! {\n-            totalRuns += activity.totalRuns\n-            totalIncompletedRuns += activity.incompletedRuns\n-            totalCompletedRuns += activity.compeltedRuns\n-            \n-        }\n-        \n-        \n-        Study.currentStudy?.totalCompleteRuns = totalCompletedRuns\n-        Study.currentStudy?.totalIncompleteRuns = totalIncompletedRuns\n-        //Calculate Completion & Adherence\n-        let completion = ceil( Double(self.divide(lhs: (totalCompletedRuns + totalIncompletedRuns)*100, rhs: totalRuns)) )\n-        let adherence = ceil (Double(self.divide(lhs: totalCompletedRuns*100, rhs: (totalCompletedRuns + totalIncompletedRuns))))\n-        \n-        let studyid = (Study.currentStudy?.studyId)!\n-        \n-        let status = User.currentUser.udpateCompletionAndAdherence(studyId: studyid, completion: Int(completion), adherence: Int(adherence))\n-        \n-        //Update to server\n-        UserServices().updateCompletionAdherence(studyStauts: status, delegate: self)\n-        //Update Local DB\n-        DBHandler.updateStudyParticipationStatus(study: Study.currentStudy!)\n-        \n-        \n-        //Compose Alert based on Completion\n-        let halfCompletionKey = \"50pcShown\"  + (Study.currentStudy?.studyId)!\n-        let fullCompletionKey = \"100pcShown\"  + (Study.currentStudy?.studyId)!\n-        let missedKey = \"totalMissed\"  + (Study.currentStudy?.studyId)!\n-        \n-        let ud = UserDefaults.standard\n-        if completion > 50 && completion < 100 {\n-            \n-            if !(ud.bool(forKey: halfCompletionKey)) {\n-                let message =  \"The study \" + (Study.currentStudy?.name!)! + \" is now 50 percent complete. We look forward to your continued participation as the study progresses.\"\n-                //UIUtilities.showAlertWithMessage(alertMessage: message)\n-                ud.set(true, forKey: halfCompletionKey)\n-                \n-            }\n-            \n-        }\n-        \n-        if completion == 100 {\n-            \n-            if !(ud.bool(forKey: fullCompletionKey)) {\n-                let message =  \"The study \" + (Study.currentStudy?.name!)! + \" is 100 percent complete. Thank you for your participation.\"\n-                UIUtilities.showAlertWithMessage(alertMessage: message)\n-                ud.set(true, forKey: fullCompletionKey)\n-                \n-            }\n-        }\n-        \n-        //Alerts User about Completion\n-        if ud.object(forKey: missedKey) == nil {\n-            ud.set(totalIncompletedRuns, forKey: missedKey)\n-            \n-        } else {\n-            let previousMissed = (ud.object(forKey: missedKey) as? Int)!\n-            ud.set(totalIncompletedRuns, forKey: missedKey)\n-            if previousMissed < totalIncompletedRuns {\n-                //show alert\n-                \n-                let message = \"We noticed you missed an activity in \" + (Study.currentStudy?.name!)! + \" today. That\u2019s ok! We know you\u2019re busy, but we encourage you to complete study activities before they expire.\"\n-                UIUtilities.showAlertWithMessage(alertMessage: message)\n-            }\n-        }\n-        \n-        ud.synchronize()\n-        \n-    }\n-    \n-    func divide(lhs: Int, rhs: Int) -> Int {\n-        if rhs == 0 {\n-            return 0\n+    return .current\n+  }\n+\n+  /// To handle Activity list response.\n+  func handleActivityListResponse() {\n+\n+    tableViewSections = []\n+    allActivityList = []\n+    let activities = Study.currentStudy?.activities\n+\n+    var currentActivities: [Activity] = []\n+    var upcomingActivities: [Activity] = []\n+    var pastActivities: [Activity] = []\n+\n+    var isInActiveActivitiesAreAvailable: Bool! = false\n+    for activity in activities! {\n+\n+      if activity.state == \"active\" || activity.state == nil {\n+\n+        let status = self.getActivityAvailabilityStatus(activity: activity)\n+        switch status {\n+        case .current:\n+          currentActivities.append(activity)\n+        case .upcoming:\n+          upcomingActivities.append(activity)\n+        case .past:\n+          pastActivities.append(activity)\n         }\n-        return lhs/rhs\n+      } else {\n+\n+        isInActiveActivitiesAreAvailable = true\n+        DBHandler.deleteDBLocalNotification(\n+          activityId: activity.actvityId!, studyId: activity.studyId!)\n+      }\n     }\n-    \n-    /**\n-     Used to update Activity Status To InProgress\n-     */\n-    func updateActivityStatusToInProgress(){\n-        self.updateActivityRunStuatus(status: .inProgress)\n+\n+    if isInActiveActivitiesAreAvailable {\n+      LocalNotification.refreshAllLocalNotification()\n     }\n-    \n-    \n-    /**\n-     Used to update Activity Status To Complete\n-     */\n-    func updateActivityStatusToComplete(){\n-        self.updateActivityRunStuatus(status: .completed)\n+\n+    // Sort as per start date\n+    currentActivities.sort(by: { $0.startDate?.compare($1.startDate!) == .orderedAscending })\n+    upcomingActivities.sort(by: { $0.startDate?.compare($1.startDate!) == .orderedAscending })\n+    pastActivities.sort(by: { $0.startDate?.compare($1.startDate!) == .orderedAscending })\n+\n+    let sortedCurrentActivities = currentActivities.sorted(\n+      by: { (activity1: Activity, activity2: Activity) -> Bool in\n+\n+        return (\n+          activity1.userParticipationStatus.status.sortIndex < activity2\n+            .userParticipationStatus\n+            .status.sortIndex\n+        )\n+      })\n+\n+    let currentDetails = [\"title\": \"CURRENT\", \"activities\": sortedCurrentActivities] as [String: Any]\n+    let upcomingDetails = [\"title\": \"UPCOMING\", \"activities\": upcomingActivities] as [String: Any]\n+    let pastDetails = [\"title\": \"PAST\", \"activities\": pastActivities] as [String: Any]\n+\n+    allActivityList.append(currentDetails)\n+    allActivityList.append(upcomingDetails)\n+    allActivityList.append(pastDetails)\n+\n+    tableViewSections = allActivityList\n+\n+    if self.selectedFilter == .tasks || self.selectedFilter == .surveys {\n+\n+      let filterType: ActivityType! = (\n+        selectedFilter == .surveys ? .Questionnaire : .activeTask\n+      )\n+      self.updateSectionArray(activityType: filterType)\n     }\n-    \n-    //save completed staus in database\n-    func updateRunStatusToComplete(){\n-        \n-        let activity = Study.currentActivity!\n-        activity.compeltedRuns += 1\n-        DBHandler.updateRunToComplete(runId: activity.currentRunId, activityId: activity.actvityId!, studyId: activity.studyId!)\n-        self.updateActivityStatusToComplete()\n+\n+    DispatchQueue.main.async {\n+\n+      self.tableView?.reloadData()\n+      self.tableView?.isHidden = false\n+      self.labelNoNetworkAvailable?.isHidden = true\n+      self.updateCompletionAdherence()\n     }\n-    \n-    /**\n-     Update Run Status based on Run Id\n-     */\n-    func updateRunStatusForRunId(runId:Int){\n-        \n-        let activity = Study.currentActivity!\n-        activity.compeltedRuns += 1\n-        DBHandler.updateRunToComplete(runId: runId, activityId: activity.actvityId!, studyId: activity.studyId!)\n-        \n-        //update run count information\n-        let incompleteRuns = activity.currentRunId - activity.compeltedRuns\n-        activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n-        if activity.currentRun == nil {\n-            //Do Nothing\n-            \n-        } else {\n-            //Status is not completed\n-            if activity.userParticipationStatus.status != UserActivityStatus.ActivityStatus.completed {\n-                \n-                var incompleteRuns = activity.currentRunId - activity.compeltedRuns\n-                incompleteRuns -= 1\n-                activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n-            }\n-            \n+\n+    if (User.currentUser.settings?.localNotifications)! {\n+      if !(Study.currentStudy?.activitiesLocalNotificationUpdated)! {\n+        //Register LocalNotifications\n+        LocalNotification.registerAllLocalNotificationFor(\n+          activities: (Study.currentStudy?.activities)!\n+        ) { (_, notificationlist) in\n+          Study.currentStudy?.activitiesLocalNotificationUpdated = true\n+          DBHandler.saveRegisteredLocaNotifications(notificationList: notificationlist)\n+          DBHandler.updateLocalNotificationScheduleStatus(\n+            studyId: (Study.currentStudy?.studyId)!, status: true)\n+          LocalNotification.refreshAllLocalNotification()\n         }\n-        \n-        let activityStatus = User.currentUser.updateActivityStatus(studyId: activity.studyId!, activityId: activity.actvityId!,runId: String(runId), status: .completed)\n-        activityStatus.compeltedRuns = activity.compeltedRuns\n-        activityStatus.incompletedRuns = activity.incompletedRuns\n-        activityStatus.totalRuns = activity.totalRuns\n-        activityStatus.activityVersion = activity.version\n-        \n-        //Update User Participation Status to server\n-        UserServices().updateUserActivityParticipatedStatus(studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n-        \n-        //Update User Participation Status to DB\n-        DBHandler.updateActivityParticipationStatus(activity: activity)\n-        \n-        self.updateCompletionAdherence()\n-        self.tableView?.reloadData()\n-        \n+\n+      }\n     }\n-    \n-    /**\n-     Handler for studyUpdateResponse\n-     */\n-    func handleStudyUpdatesResponse() {\n-        \n-        Study.currentStudy?.newVersion = StudyUpdates.studyVersion\n-        DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n-        \n-        //Consent Updated\n-        if StudyUpdates.studyConsentUpdated {\n-            presentUpdatedConsent()\n-            \n-        } else if StudyUpdates.studyInfoUpdated {\n-            WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-            \n-        } else {\n-            self.checkForActivitiesUpdates()\n-        }\n-        \n+    self.checkIfFetelKickCountRunning()\n+  }\n+\n+  /// Updates Activity Run Status.\n+  /// - Parameter status: Status of the Activity.\n+  func updateActivityRun(status: UserActivityStatus.ActivityStatus) {\n+\n+    let activity = Study.currentActivity!\n+\n+    let activityStatus = User.currentUser.updateActivityStatus(\n+      studyId: activity.studyId!, activityId: activity.actvityId!,\n+      runId: String(activity.currentRunId), status: status)\n+    activityStatus.compeltedRuns = activity.compeltedRuns\n+    activityStatus.incompletedRuns = activity.incompletedRuns\n+    activityStatus.totalRuns = activity.totalRuns\n+    activityStatus.activityVersion = activity.version\n+\n+    /// Update participationStatus to server\n+    UserServices().updateUserActivityParticipatedStatus(\n+      studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n+\n+    /// Update participationStatus to DB\n+    DBHandler.updateParticipationStatus(for: activity)\n+\n+    if status == .completed {\n+      self.updateCompletionAdherence()\n     }\n-    \n-    // MARK: Api Calls\n-    \n-    /**\n-     Used to send Request To Get ActivityStates\n-     */\n-    func sendRequestToGetActivityStates(){\n-        UserServices().getUserActivityState(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+  }\n+\n+  /// Calculates the Completion & Adherence based on following criteria.\n+  ///\n+  ///     completion = ((totalCompletedRuns + totalIncompletedRuns) * 100) /  (totalRuns)\n+  ///     adherence =  (totalCompletedRuns*100) / (totalCompletedRuns + totalIncompletedRuns)\n+  ///\n+  /// Also alerts the user about the study Completion Status.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2MzY3Nw==", "bodyText": "else block is not needed, please remove", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391763677", "createdAt": "2020-03-12T17:03:25Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ActivityUI/ActivitiesViewController.swift", "diffHunk": "@@ -1,1780 +1,1527 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n-import UIKit\n-import ResearchKit\n import IQKeyboardManagerSwift\n+import ResearchKit\n+import UIKit\n \n let kActivities = \"activities\"\n \n let kActivityUnwindToStudyListIdentifier = \"unwindeToStudyListIdentier\"\n-let kActivityAbondonedAlertMessage = \"You missed the previous run of this activity. Please wait till the next run becomes available. Run timings are given on the Activities list screen.\"\n+let kActivityAbondonedAlertMessage\n+  = \"You missed the previous run of this activity. Please wait till the next run becomes available. Run timings are given on the Activities list screen.\"\n \n-enum ActivityAvailabilityStatus:Int{\n-    case current\n-    case upcoming\n-    case past\n+enum ActivityAvailabilityStatus: Int {\n+  case current\n+  case upcoming\n+  case past\n }\n \n-class ActivitiesViewController : UIViewController{\n-    \n-    @IBOutlet var tableView : UITableView?\n-    @IBOutlet var labelNoNetworkAvailable: UILabel?\n-    \n-    var tableViewSections: Array<Dictionary<String,Any>>! = []\n-    var lastFetelKickIdentifer: String = \"\"  //TEMP\n-    var selectedIndexPath: IndexPath? = nil\n-    var isAnchorDateSet: Bool = false\n-    var taskControllerPresented = false\n-    var refreshControl: UIRefreshControl? //To fetch the updated Activities\n-    \n-    var allActivityList: Array<Dictionary<String,Any>>! = []\n-    var selectedFilter: ActivityFilterType? //Holds the applied FilterTypes\n-    \n-    private var managedResult: [String: Any] = [:]\n-    \n-    let labkeyResponseFetch = ResponseDataFetch()\n-    \n-    // MARK:- Viewcontroller Lifecycle\n-    fileprivate func presentUpdatedConsent() {\n-        let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-        appDelegate.checkConsentStatus(controller: self)\n+class ActivitiesViewController: UIViewController {\n+\n+  // MARK: - Outlets\n+  @IBOutlet var tableView: UITableView?\n+\n+  @IBOutlet var labelNoNetworkAvailable: UILabel?\n+\n+  // MARK: - Properties\n+  private lazy var tableViewSections: [[String: Any]]! = []\n+\n+  private lazy var lastFetelKickIdentifer: String = \"\"  //TEMP\n+  private lazy var selectedIndexPath: IndexPath? = nil\n+\n+  private lazy var isAnchorDateSet: Bool = false\n+  private lazy var taskControllerPresented = false\n+\n+  /// To fetch the updated Activities.\n+  var refreshControl: UIRefreshControl?\n+\n+  private lazy var allActivityList: [[String: Any]]! = []\n+\n+  /// Holds the applied FilterTypes.\n+  var selectedFilter: ActivityFilterType?\n+\n+  private lazy var managedResult: [String: Any] = [:]\n+\n+  let labkeyResponseFetch = ResponseDataFetch()\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  fileprivate func presentUpdatedConsent() {\n+    let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+    appDelegate.checkConsentStatus(controller: self)\n+  }\n+\n+  deinit {\n+    Logger.sharedInstance.info(\"\\(self): deinit\")\n+  }\n+\n+  // MARK: - Viewcontroller Lifecycle\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    selectedFilter = ActivityFilterType.all\n+\n+    self.tableView?.estimatedRowHeight = 126\n+    self.tableView?.rowHeight = UITableView.automaticDimension\n+\n+    self.navigationItem.title = NSLocalizedString(\"STUDY ACTIVITIES\", comment: \"\")\n+    self.tableView?.sectionHeaderHeight = 30\n+\n+    self.navigationController?.navigationItem.rightBarButtonItem?.tintColor = UIColor.gray\n+\n+    if (Study.currentStudy?.studyId) != nil {\n+      if StudyUpdates.studyConsentUpdated {\n+        NotificationHandler.instance.activityId = \"\"\n+        presentUpdatedConsent()\n+      }\n     }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        selectedFilter = ActivityFilterType.all\n-        \n-        self.tableView?.estimatedRowHeight = 126\n-        self.tableView?.rowHeight = UITableView.automaticDimension\n-        \n-        self.tabBarController?.delegate = self\n-        \n-        self.navigationItem.title = NSLocalizedString(\"STUDY ACTIVITIES\", comment: \"\")\n-        self.tableView?.sectionHeaderHeight = 30\n-        \n-        self.navigationController?.navigationItem.rightBarButtonItem?.tintColor = UIColor.gray\n-        \n-        if (Study.currentStudy?.studyId) != nil {\n-            if StudyUpdates.studyConsentUpdated {\n-                NotificationHandler.instance.activityId = \"\"\n-                presentUpdatedConsent()\n-            }\n-        }\n-        \n-        //create refresh control for pull to refresh\n-        refreshControl = UIRefreshControl()\n-        refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n-        refreshControl?.addTarget(self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n-        tableView?.addSubview(refreshControl!)\n+\n+    // create refresh control for pull to refresh\n+    refreshControl = UIRefreshControl()\n+    refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n+    refreshControl?.addTarget(\n+      self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n+    tableView?.addSubview(refreshControl!)\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+    self.navigationController?.interactivePopGestureRecognizer?.isEnabled = false\n+\n+    if Utilities.isStandaloneApp() {\n+      self.setNavigationBarItem()\n+    } else {\n+      self.addHomeButton()\n     }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        self.navigationController?.interactivePopGestureRecognizer?.isEnabled = false\n-        UIApplication.shared.statusBarStyle = .default\n-        \n-        if Utilities.isStandaloneApp() {\n-            self.setNavigationBarItem()\n-        }\n-        else {\n-            self.addHomeButton()\n-        }\n-       \n-        \n-        if !taskControllerPresented {\n-            taskControllerPresented = false\n-            self.checkForActivitiesUpdates()\n-        }\n-        \n-        if tableViewSections.count == 0 {\n-            self.tableView?.isHidden = true\n-            self.labelNoNetworkAvailable?.isHidden = false\n-            \n-        } else {\n-            self.tableView?.isHidden = false\n-            self.labelNoNetworkAvailable?.isHidden = true\n-        }\n-        \n-        \n+\n+    if !taskControllerPresented {\n+      taskControllerPresented = false\n+      self.checkForActivitiesUpdates()\n     }\n-    \n-    override func viewDidAppear(_ animated: Bool) {\n-        super.viewDidAppear(animated)\n-        \n-        let message =  \"The study \" + (Study.currentStudy?.name!)! + \" is 100 percent complete. Thank you for your participation.\"\n-       // UIUtilities.showAlertWithMessage(alertMessage: message)\n-        \n+\n+    if tableViewSections.count == 0 {\n+      self.tableView?.isHidden = true\n+      self.labelNoNetworkAvailable?.isHidden = false\n+\n+    } else {\n+      self.tableView?.isHidden = false\n+      self.labelNoNetworkAvailable?.isHidden = true\n     }\n-    \n-    // MARK: Helper Methods\n-    \n-    func getLabkeyResponse() {\n-        \n-        let ud = UserDefaults.standard\n-        let key = \"LabKeyResponse\" + (Study.currentStudy?.studyId)!\n-        if !(ud.bool(forKey: key)){\n-            labkeyResponseFetch.checkUpdates()\n-        }\n+\n+  }\n+\n+  // MARK: - Helper Methods\n+\n+  func getLabkeyResponse() {\n+\n+    let ud = UserDefaults.standard\n+    let key = \"LabKeyResponse\" + (Study.currentStudy?.studyId)!\n+    if !(ud.bool(forKey: key)) {\n+      labkeyResponseFetch.checkUpdates()\n     }\n-    \n-    func checkForActivitiesUpdates(){\n-        \n-        if StudyUpdates.studyActivitiesUpdated {\n-            \n-            self.sendRequestToGetActivityStates()\n-            \n-            //udpate status to false so notification can be registered again\n-            Study.currentStudy?.activitiesLocalNotificationUpdated = false\n-            DBHandler.updateLocalNotificaitonUpdated(studyId: (Study.currentStudy?.studyId)!,status: false)\n-            \n-        } else {\n-            \n-            if self.refreshControl != nil && (self.refreshControl?.isRefreshing)!{\n-                self.refreshControl?.endRefreshing()\n-            }\n-            //self.loadActivitiesFromDatabase()\n-            self.fetchActivityAnchorDateResponseFromLabkey()\n-        }\n+  }\n+\n+  /// Checks for Activity updates from WCP.\n+  func checkForActivitiesUpdates() {\n+\n+    if StudyUpdates.studyActivitiesUpdated {\n+\n+      self.sendRequestToGetActivityStates()\n+\n+      /// Update status to false so notification can be registered again.\n+      Study.currentStudy?.activitiesLocalNotificationUpdated = false\n+      DBHandler.updateLocalNotificationScheduleStatus(\n+        studyId: (Study.currentStudy?.studyId)!, status: false)\n+\n+    } else {\n+\n+      if self.refreshControl != nil && (self.refreshControl?.isRefreshing)! {\n+        self.refreshControl?.endRefreshing()\n+      }\n+      self.fetchActivityAnchorDateResponseFromLabkey()\n     }\n-    \n-    /**\n-     checkIfFetelKickCountRunning method verifies whether if FetalKick Task is Still running and calculate the time difference.\n-     */\n-    func checkIfFetelKickCountRunning(){\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if (ud.bool(forKey: \"FKC\") && ud.object(forKey: kFetalKickStartTimeStamp) != nil) {\n-            \n-            //let studyId = (ud.object(forKey: kFetalkickStudyId)  as? String)!\n-            let activityId = (ud.object(forKey: kFetalKickActivityId)  as? String)!\n-            let activity  = Study.currentStudy?.activities?.filter({$0.actvityId == activityId}).last\n-            \n-            Study.updateCurrentActivity(activity: activity!)\n-            //check in database\n-            DBHandler.loadActivityMetaData(activity: activity!, completionHandler: { (found) in\n-                \n-                if found {\n-                    self.createActivity()\n-                }\n-                \n-            })\n-            \n-        } else {\n-            //check if user navigated from notification\n-            \n-            if NotificationHandler.instance.activityId.count > 0 {\n-                \n-                let activityId = NotificationHandler.instance.activityId\n-                \n-                let rowDetail = tableViewSections[0]\n-                let activities = (rowDetail[\"activities\"] as? Array<Activity>)!\n-                let index = activities.index(where: {$0.actvityId == activityId})\n-                let ip = IndexPath.init(row: index!, section: 0)\n-                self.selectedIndexPath = ip\n-                self.tableView?.selectRow(at: ip, animated: true, scrollPosition: .middle)\n-                self.tableView?.delegate?.tableView!(self.tableView!, didSelectRowAt: ip)\n-                \n-                NotificationHandler.instance.activityId = \"\"\n-            }\n-        }\n+  }\n+\n+  /// Verifies whether if FetalKick Task is Still running and calculate the time difference.\n+  func checkIfFetelKickCountRunning() {\n+\n+    let ud = UserDefaults.standard\n+\n+    if ud.bool(forKey: \"FKC\") && ud.object(forKey: kFetalKickStartTimeStamp) != nil {\n+\n+      let activityId = (ud.object(forKey: kFetalKickActivityId) as? String)!\n+      let activity = Study.currentStudy?.activities?.filter({ $0.actvityId == activityId })\n+        .last\n+\n+      Study.updateCurrentActivity(activity: activity!)\n+      // check in database\n+      DBHandler.loadActivityMetaData(\n+        activity: activity!,\n+        completionHandler: { (found) in\n+\n+          if found {\n+            self.createActivity()\n+          }\n+\n+        })\n+\n+    } else {\n+      /// check if user navigated from notification\n+      if NotificationHandler.instance.activityId.count > 0 {\n+\n+        let activityId = NotificationHandler.instance.activityId\n+\n+        let rowDetail = tableViewSections[0]\n+        let activities = (rowDetail[\"activities\"] as? [Activity])!\n+        let index = activities.firstIndex(where: { $0.actvityId == activityId })\n+        let ip = IndexPath.init(row: index!, section: 0)\n+        self.selectedIndexPath = ip\n+        self.tableView?.selectRow(at: ip, animated: true, scrollPosition: .middle)\n+        self.tableView?.delegate?.tableView!(self.tableView!, didSelectRowAt: ip)\n+\n+        NotificationHandler.instance.activityId = \"\"\n+      }\n     }\n-    \n-    /**\n-     RegisterNotificationForAnchorDate method sets the notification for the available resource\n-     */\n-    \n-    func registerNotificationForAnchorDate(){\n-        \n-        DBHandler.getResourcesWithAnchorDateAvailable(studyId: (Study.currentStudy?.studyId)!) { (resourcesList) in\n-            if resourcesList.count > 0 {\n-                let todayDate = Date()\n-                for resource in resourcesList {\n-                    \n-                    if resource.startDate == nil && resource.endDate == nil {\n-                        \n-                        let anchorDateObject = Study.currentStudy?.anchorDate\n-                        //Fetch AnchorData based availablity\n-                        if(anchorDateObject != nil && (anchorDateObject?.isAnchorDateAvailable())!) {\n-                            \n-                            let anchorDate = Study.currentStudy?.anchorDate?.date?.startOfDay\n-                            \n-                            if anchorDate != nil {\n-                                \n-                                //also anchor date condition\n-                                let startDateInterval = TimeInterval(60*60*24*(resource.anchorDateStartDays))\n-                                \n-                                let endDateInterval = TimeInterval(60*60*24*(resource.anchorDateEndDays))\n-                                \n-                                let startAnchorDate = anchorDate?.addingTimeInterval(startDateInterval)\n-                                var endAnchorDate = anchorDate?.addingTimeInterval(endDateInterval)\n-                                \n-                                endAnchorDate = endAnchorDate?.endOfDay\n-                                let startDateResult = (startAnchorDate?.compare(todayDate))! as ComparisonResult\n-                                //let endDateResult = (endAnchorDate?.compare(todayDate))! as ComparisonResult\n-                                self.isAnchorDateSet = false\n-                                \n-                                if startDateResult == .orderedDescending {\n-                                    //upcoming\n-                                    let notfiId = resource.resourceId! + (Study.currentStudy?.studyId)!\n-                                    DBHandler.isNotificationSetFor(notification: notfiId\n-                                        , completionHandler: { (found) in\n-                                            if !found {\n-                                                \n-                                                //Create AppLocalNotification\n-                                                let notification = AppLocalNotification()\n-                                                notification.id = resource.resourceId! + (Study.currentStudy?.studyId)!\n-                                                notification.message = resource.notificationMessage\n-                                                notification.title = \"New Resource Available\"\n-                                                notification.startDate = startAnchorDate\n-                                                notification.endDate = endAnchorDate\n-                                                notification.type = AppNotification.NotificationType.Study\n-                                                notification.subType = AppNotification.NotificationSubType.Resource\n-                                                notification.audience = Audience.Limited\n-                                                notification.studyId = (Study.currentStudy?.studyId)!\n-                                                //notification.activityId = Study.currentActivity?.actvityId\n-                                                \n-                                                //Save Notification to Database\n-                                                DBHandler.saveLocalNotification(notification: notification)\n-                                                \n-                                                //register notification\n-                                                var notificationDate = startAnchorDate?.startOfDay\n-                                                notificationDate = notificationDate?.addingTimeInterval(43200)\n-                                                let message = resource.notificationMessage\n-                                                let userInfo = [\"studyId\": (Study.currentStudy?.studyId)!,\n-                                                                \"type\": \"resource\"];\n-                                                LocalNotification.scheduleNotificationOn(date: notificationDate!, message: message!, userInfo: userInfo, id: notification.id)\n-                                            }\n-                                    })\n-                                }\n-                            }\n-                        }\n-                    }\n+  }\n+\n+  /// Sets the notification for the available resource.\n+  func registerNotificationForAnchorDate() {\n+\n+    DBHandler.getResourcesWithAnchorDateAvailable(studyId: (Study.currentStudy?.studyId)!) {\n+      (resourcesList) in\n+      if resourcesList.count > 0 {\n+        let todayDate = Date()\n+        for resource in resourcesList {\n+\n+          if resource.startDate == nil && resource.endDate == nil {\n+\n+            let anchorDateObject = Study.currentStudy?.anchorDate\n+            // Fetch AnchorData based availablity\n+            if anchorDateObject != nil && (anchorDateObject?.isAnchorDateAvailable())! {\n+\n+              let anchorDate = Study.currentStudy?.anchorDate?.date?.startOfDay\n+\n+              if anchorDate != nil {\n+\n+                // also anchor date condition\n+                let startDateInterval = TimeInterval(\n+                  60*60*24*(resource.anchorDateStartDays))\n+\n+                let endDateInterval = TimeInterval(\n+                  60*60*24*(resource.anchorDateEndDays))\n+\n+                let startAnchorDate = anchorDate?.addingTimeInterval(\n+                  startDateInterval)\n+                var endAnchorDate = anchorDate?.addingTimeInterval(endDateInterval)\n+\n+                endAnchorDate = endAnchorDate?.endOfDay\n+                let startDateResult = (startAnchorDate?.compare(todayDate))!\n+                  as ComparisonResult\n+                self.isAnchorDateSet = false\n+\n+                if startDateResult == .orderedDescending {\n+                  // upcoming\n+                  let notfiId = resource.resourceId! + (\n+                    Study.currentStudy?.studyId\n+                  )!\n+                  DBHandler.isNotificationSetFor(\n+                    notification: notfiId,\n+                    completionHandler: { (found) in\n+                      if !found {\n+\n+                        // Create AppLocalNotification\n+                        let notification = AppLocalNotification()\n+                        notification.id = resource.resourceId! + (\n+                          Study.currentStudy?.studyId\n+                        )!\n+                        notification.message = resource.notificationMessage\n+                        notification.title = \"New Resource Available\"\n+                        notification.startDate = startAnchorDate\n+                        notification.endDate = endAnchorDate\n+                        notification.type = AppNotification.NotificationType\n+                          .Study\n+                        notification.subType = AppNotification\n+                          .NotificationSubType.Resource\n+                        notification.audience = Audience.Limited\n+                        notification.studyId = (\n+                          Study.currentStudy?.studyId\n+                        )!\n+                        // Save Notification to Database\n+                        DBHandler.saveLocalNotification(\n+                          notification: notification)\n+\n+                        // register notification\n+                        var notificationDate = startAnchorDate?.startOfDay\n+                        notificationDate = notificationDate?\n+                          .addingTimeInterval(43200)\n+                        let message = resource.notificationMessage\n+                        let userInfo = [\n+                          \"studyId\": (Study.currentStudy?.studyId)!,\n+                          \"type\": \"resource\"\n+                        ]\n+                        LocalNotification.scheduleNotificationOn(\n+                          date: notificationDate!, message: message!,\n+                          userInfo: userInfo,\n+                          id: notification.id)\n+                      }\n+                    })\n                 }\n+              }\n             }\n+          }\n         }\n+      }\n     }\n-    \n-    \n-    // MARK:- Button Actions\n-    \n-    /**\n-     Home Button Clicked\n-     @param sender    Accepts any kind of object\n-     */\n-    @IBAction func homeButtonAction(_ sender: AnyObject){\n-        self.performSegue(withIdentifier: kActivityUnwindToStudyListIdentifier, sender: self)\n+  }\n+\n+  func checkForDashBoardInfo() {\n+\n+    DBHandler.loadStatisticsForStudy(studyId: (Study.currentStudy?.studyId)!) {\n+      (statiticsList) in\n+\n+      if statiticsList.count != 0 {\n+        // Do Nothing\n+      } else {\n+        self.sendRequestToGetDashboardInfo()\n+      }\n     }\n-    \n-    @IBAction func filterButtonAction(_ sender: AnyObject){\n-        let frame = self.view.frame\n-        \n-        if self.selectedFilter == nil {\n-            self.selectedFilter = ActivityFilterType.all\n-        }\n-        //create and load FilterView\n-        let view = ActivityFilterView.instanceFromNib(frame: frame , selectedIndex: self.selectedFilter!)\n-        view.delegate = self\n-        self.tabBarController?.view.addSubview(view)\n+  }\n+\n+  @objc func refresh(sender: AnyObject) {\n+    WCPServices().getStudyUpdates(study: Study.currentStudy!, delegate: self)\n+  }\n+\n+  func fetchActivityAnchorDateResponseFromLabkey() {\n+    AnchorDateHandler().fetchActivityAnchorDateResponseFromLabkey { (_) in\n+      self.loadActivitiesFromDatabase()\n     }\n-    \n-    // MARK: Helper Methods\n-    func checkForDashBoardInfo(){\n-        \n-        DBHandler.loadStatisticsForStudy(studyId: (Study.currentStudy?.studyId)!) { (statiticsList) in\n-            \n-            if statiticsList.count != 0 {\n-                //Do Nothing\n-            } else {\n-                self.sendRequestToGetDashboardInfo()\n-            }\n+  }\n+\n+  /// To load the Activities data from database.\n+  func loadActivitiesFromDatabase() {\n+\n+    if DBHandler.isActivitiesEmpty((Study.currentStudy?.studyId)!) {\n+      self.sendRequestToGetActivityStates()\n+    } else {\n+\n+      DBHandler.loadActivityListFromDatabase(studyId: (Study.currentStudy?.studyId)!) {\n+        (activities) in\n+        if activities.count > 0 {\n+          Study.currentStudy?.activities = activities\n+          self.handleActivityListResponse()\n         }\n+      }\n     }\n-    \n-    \n-    @objc func refresh(sender:AnyObject) {\n-        \n-        Logger.sharedInstance.info(\"Request for study Updated...\")\n-        WCPServices().getStudyUpdates(study: Study.currentStudy!, delegate: self)\n-        //self.sendRequesToGetActivityList()\n-    }\n-    \n-    \n-    // MARK:-\n-    \n-    func fetchActivityAnchorDateResponseFromLabkey() {\n-        \n-        AnchorDateHandler().fetchActivityAnchorDateResponseFromLabkey { (status) in\n-            print(\"Finished 1\")\n-            //if status {\n-                //DispatchQueue.main.async {\n-                    self.loadActivitiesFromDatabase()\n-                //}\n-                \n-            //}\n-            \n-        }\n-        print(\"Finished 0\")\n+  }\n+\n+  /// To create an activity using ORKTaskViewController.\n+  func createActivity() {\n+\n+    IQKeyboardManager.shared.enableAutoToolbar = false\n+\n+    if Utilities.isValidObject(someObject: Study.currentActivity?.steps as AnyObject?) {\n+      // Create ActivityBuilder instance.\n+      ActivityBuilder.currentActivityBuilder = ActivityBuilder()\n+      ActivityBuilder.currentActivityBuilder.initWithActivity(\n+        activity: Study.currentActivity!)\n     }\n-    \n-    /**\n-     Used to load the Actif=vities data from database\n-     */\n-    func loadActivitiesFromDatabase(){\n-        \n-        if DBHandler.isActivitiesEmpty((Study.currentStudy?.studyId)!) {\n-            self.sendRequestToGetActivityStates()\n-        }\n-        else {\n-            \n-            DBHandler.loadActivityListFromDatabase(studyId: (Study.currentStudy?.studyId)!) { (activities) in\n-                if activities.count > 0 {\n-                    Study.currentStudy?.activities = activities\n-                    \n-                    self.handleActivityListResponse()\n-                    \n-                    \n-                } else {\n-                    \n-                    //self.sendRequestToGetActivityStates()\n-                }\n-            }\n-        }\n+\n+    let task: ORKTask?\n+    let taskViewController: ORKTaskViewController?\n+\n+    task = ActivityBuilder.currentActivityBuilder.createTask()\n+\n+    if task != nil {\n+\n+      // Check if restorationData is available.\n+      if Study.currentActivity?.currentRun.restortionData != nil {\n+        let restoredData = Study.currentActivity?.currentRun.restortionData\n+\n+        taskViewController = ORKTaskViewController(\n+          task: task, restorationData: restoredData, delegate: self)\n+      } else {\n+\n+        taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n+        taskViewController?.outputDirectory = FileManager.default.urls(\n+          for: .documentDirectory, in: .userDomainMask).first!\n+      }\n+\n+      taskViewController?.showsProgressInNavigationBar = true\n+\n+      taskViewController?.title = \"Activity\"\n+\n+      // Customize appearance of TaskViewController\n+      UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+        = kUIColorForSubmitButtonBackground\n+\n+      taskViewController?.delegate = self\n+      taskControllerPresented = true\n+      taskViewController?.navigationBar.prefersLargeTitles = false\n+\n+      taskViewController?.modalPresentationStyle = .fullScreen\n+      present(taskViewController!, animated: true, completion: nil)\n+\n+    } else {\n+      // Task creation failed\n+      UIUtilities.showAlertMessage(\n+        kAlertMessageText, errorMessage: NSLocalizedString(\"Invalid Data!\", comment: \"\"),\n+        errorAlertActionTitle: NSLocalizedString(\"OK\", comment: \"\"),\n+        viewControllerUsed: self)\n     }\n-    \n-    \n-    /**\n-     Used to create an activity using ORKTaskViewController\n-     */\n-    func createActivity(){\n-        \n-        //Disable Custom KeyPad with toolbars\n-//        IQKeyboardManager.sharedManager().enable = false\n-        IQKeyboardManager.shared.enableAutoToolbar = false\n-        \n-        if Utilities.isValidObject(someObject: Study.currentActivity?.steps as AnyObject?){\n-            \n-            //Create ActivityBuilder instance\n-            ActivityBuilder.currentActivityBuilder = ActivityBuilder()\n-            ActivityBuilder.currentActivityBuilder.initWithActivity(activity: Study.currentActivity! )\n-        }\n-        \n-        let task: ORKTask?\n-        let taskViewController: ORKTaskViewController?\n-        \n-        task = ActivityBuilder.currentActivityBuilder.createTask()\n-        \n-        if task != nil {\n-            \n-            //check if restorationData is available\n-            if Study.currentActivity?.currentRun.restortionData != nil {\n-                let restoredData = Study.currentActivity?.currentRun.restortionData\n-                \n-                //let result: ORKResult?\n-                taskViewController = ORKTaskViewController(task: task, restorationData: restoredData, delegate: self)\n-            } else {\n-                \n-                taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n-                taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-            }\n-            \n-            taskViewController?.showsProgressInNavigationBar = true\n-            \n-            taskViewController?.title = \"Activity\"\n-            \n-            //Customize appearance of TaskViewController\n-            UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-            \n-            taskViewController?.delegate = self\n-            UIApplication.shared.statusBarStyle = .default\n-            taskControllerPresented = true\n-            taskViewController?.modalPresentationStyle = .fullScreen\n-            present(taskViewController!, animated: true, completion: nil)\n-            \n-        } else {\n-            //Task creation failed\n-            UIUtilities.showAlertMessage(kAlertMessageText, errorMessage: NSLocalizedString(\"Invalid Data!\", comment: \"\"), errorAlertActionTitle: NSLocalizedString(\"OK\", comment: \"\"), viewControllerUsed: self)\n-        }\n-        \n+\n+  }\n+\n+  /// To get Activity Availability Status.\n+  /// - Parameter activity: Instance of `Activity` to check it's status.\n+  func getActivityAvailabilityStatus(activity: Activity) -> ActivityAvailabilityStatus {\n+\n+    var todayDate = Date().utcDate()\n+\n+    let difference = UserDefaults.standard.value(forKey: \"offset\") as? Int\n+    if difference != nil {\n+      todayDate = todayDate.addingTimeInterval(TimeInterval(difference!))\n     }\n-    \n-    \n-    /**\n-     Used to get Activity Availability Status\n-     @param activity    Accepts data from Activity class\n-     @return ActivityAvailabilityStatus\n-     */\n-    func getActivityAvailabilityStatus(activity: Activity) -> ActivityAvailabilityStatus {\n-        \n-        var todayDate = Date().utcDate()\n-        \n-        let difference = UserDefaults.standard.value(forKey: \"offset\") as? Int\n-        if difference != nil {\n-            todayDate = todayDate.addingTimeInterval(TimeInterval(difference!))\n-        }\n-        \n-        if activity.startDate != nil && activity.endDate != nil {\n-            \n-            let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n-            let endDateResult = (activity.endDate?.compare(todayDate))! as ComparisonResult\n-            \n-            if startDateResult == .orderedAscending && endDateResult == .orderedDescending{\n-                return .current\n-                \n-            } else if startDateResult == .orderedDescending {\n-                return .upcoming\n-                \n-            } else if endDateResult == .orderedAscending {\n-                return .past\n-            }\n-        } else if activity.startDate != nil {\n-            \n-            let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n-            \n-            if startDateResult == .orderedAscending{\n-                return .current\n-                \n-            } else if startDateResult == .orderedDescending {\n-                return .upcoming\n-            }\n-        }\n+\n+    if activity.startDate != nil && activity.endDate != nil {\n+\n+      let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n+      let endDateResult = (activity.endDate?.compare(todayDate))! as ComparisonResult\n+\n+      if startDateResult == .orderedAscending && endDateResult == .orderedDescending {\n         return .current\n+\n+      } else if startDateResult == .orderedDescending {\n+        return .upcoming\n+\n+      } else if endDateResult == .orderedAscending {\n+        return .past\n+      }\n+    } else if activity.startDate != nil {\n+\n+      let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n+\n+      if startDateResult == .orderedAscending {\n+        return .current\n+\n+      } else if startDateResult == .orderedDescending {\n+        return .upcoming\n+      }\n     }\n-    \n-    \n-    /**\n-     Used to handle Activity list response\n-     */\n-    func handleActivityListResponse(){\n-        \n-        tableViewSections = []\n-        allActivityList = []\n-        let activities = Study.currentStudy?.activities\n-        \n-        var currentActivities: Array<Activity> = []\n-        var upcomingActivities: Array<Activity> = []\n-        var pastActivities: Array<Activity> = []\n-        \n-        var isInActiveActivitiesAreAvailable: Bool! = false\n-        for activity in activities! {\n-            \n-            if activity.state == \"active\" || activity.state == nil {\n-                \n-                let status =  self.getActivityAvailabilityStatus(activity: activity)\n-                switch status {\n-                case .current:\n-                    currentActivities.append(activity)\n-                case .upcoming:\n-                    upcomingActivities.append(activity)\n-                case .past:\n-                    pastActivities.append(activity)\n-                }\n-            } else {\n-                \n-                isInActiveActivitiesAreAvailable = true\n-                DBHandler.deleteDBLocalNotification(activityId: activity.actvityId!,studyId: activity.studyId!)\n-            }\n-        }\n-        \n-        if isInActiveActivitiesAreAvailable {\n-            LocalNotification.refreshAllLocalNotification()\n-        }\n-        \n-        //sort as per start date\n-        currentActivities.sort(by: {$0.startDate?.compare($1.startDate!) == .orderedAscending})\n-        upcomingActivities.sort(by: {$0.startDate?.compare($1.startDate!) == .orderedAscending})\n-        pastActivities.sort(by: {$0.startDate?.compare($1.startDate!) == .orderedAscending})\n-        \n-        let  sortedCurrentActivities =  currentActivities.sorted(by: { (activity1: Activity, activity2: Activity) -> Bool in\n-            \n-            return (activity1.userParticipationStatus.status.sortIndex < activity2.userParticipationStatus.status.sortIndex)\n-        })\n-        \n-        \n-        let currentDetails = [\"title\": \"CURRENT\",\"activities\": sortedCurrentActivities] as [String : Any]\n-        let upcomingDetails = [\"title\": \"UPCOMING\",\"activities\": upcomingActivities] as [String : Any]\n-        let pastDetails = [\"title\": \"PAST\",\"activities\": pastActivities] as [String : Any]\n-        \n-        allActivityList.append(currentDetails)\n-        allActivityList.append(upcomingDetails)\n-        allActivityList.append(pastDetails)\n-        \n-        tableViewSections = allActivityList\n-        \n-        if self.selectedFilter == .tasks || self.selectedFilter == .surveys {\n-            \n-            let filterType:ActivityType! =  (selectedFilter == .surveys ? .Questionnaire : .activeTask)\n-            self.updateSectionArray(activityType: filterType)\n-        }\n-        \n-        DispatchQueue.main.async {\n-            \n-            self.tableView?.reloadData()\n-            self.tableView?.isHidden = false\n-            self.labelNoNetworkAvailable?.isHidden = true\n-            self.updateCompletionAdherence()\n-        }\n-        \n-        \n-        \n-        \n-        if (User.currentUser.settings?.localNotifications)! {\n-            print(\"localNotifications enabled\")\n-            if !(Study.currentStudy?.activitiesLocalNotificationUpdated)! {\n-                print(\"Registerig Notification\")\n-                //Register LocalNotifications\n-                LocalNotification.registerAllLocalNotificationFor(activities: (Study.currentStudy?.activities)!) { (finished,notificationlist) in\n-                    print(\"Notification set sucessfully\")\n-                    Study.currentStudy?.activitiesLocalNotificationUpdated = true\n-                    DBHandler.saveRegisteredLocaNotification(notificationList: notificationlist)\n-                    DBHandler.updateLocalNotificaitonUpdated(studyId: (Study.currentStudy?.studyId)!,status: true)\n-                    LocalNotification.refreshAllLocalNotification()\n-                }\n-                \n-            }\n-        }\n-        \n-        self.checkIfFetelKickCountRunning()\n-        \n-        Logger.sharedInstance.info(\"Activities Displayed to user\")\n-    }\n-    \n-    /**\n-     Used to update Activity Run Status\n-     @param status    Accepts data from UserActivityStatus class and ActivityStatus enum\n-     */\n-    func updateActivityRunStuatus(status: UserActivityStatus.ActivityStatus){\n-        \n-        let activity = Study.currentActivity!\n-        \n-        let activityStatus = User.currentUser.updateActivityStatus(studyId: activity.studyId!, activityId: activity.actvityId!,runId: String(activity.currentRunId), status: status)\n-        activityStatus.compeltedRuns = activity.compeltedRuns\n-        activityStatus.incompletedRuns = activity.incompletedRuns\n-        activityStatus.totalRuns = activity.totalRuns\n-        activityStatus.activityVersion = activity.version\n-        \n-        //Update participationStatus to server\n-        UserServices().updateUserActivityParticipatedStatus(studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n-        \n-        //Update participationStatus to DB\n-        DBHandler.updateActivityParticipationStatus(activity: activity)\n-        \n-        if status == .completed {\n-            self.updateCompletionAdherence()\n-        }\n-        \n-    }\n-    \n-    /**\n-     updateCompletionAdherence, calculates the Completion & Adherence based on following criteria\n-     completion = ((totalCompletedRuns + totalIncompletedRuns) * 100) / (totalRuns)\n-     adherence =  (totalCompletedRuns*100) / (totalCompletedRuns + totalIncompletedRuns)\n-     \n-     and alerts the user about the study Completion Status\n-     \n-     */\n-    func updateCompletionAdherence() {\n-        \n-        var totalRuns = 0\n-        var totalCompletedRuns = 0\n-        var totalIncompletedRuns = 0\n-        let activities = Study.currentStudy?.activities //.filter({$0.state == \"active\"})\n-        \n-        //Calculate Runs\n-        for activity in activities! {\n-            totalRuns += activity.totalRuns\n-            totalIncompletedRuns += activity.incompletedRuns\n-            totalCompletedRuns += activity.compeltedRuns\n-            \n-        }\n-        \n-        \n-        Study.currentStudy?.totalCompleteRuns = totalCompletedRuns\n-        Study.currentStudy?.totalIncompleteRuns = totalIncompletedRuns\n-        //Calculate Completion & Adherence\n-        let completion = ceil( Double(self.divide(lhs: (totalCompletedRuns + totalIncompletedRuns)*100, rhs: totalRuns)) )\n-        let adherence = ceil (Double(self.divide(lhs: totalCompletedRuns*100, rhs: (totalCompletedRuns + totalIncompletedRuns))))\n-        \n-        let studyid = (Study.currentStudy?.studyId)!\n-        \n-        let status = User.currentUser.udpateCompletionAndAdherence(studyId: studyid, completion: Int(completion), adherence: Int(adherence))\n-        \n-        //Update to server\n-        UserServices().updateCompletionAdherence(studyStauts: status, delegate: self)\n-        //Update Local DB\n-        DBHandler.updateStudyParticipationStatus(study: Study.currentStudy!)\n-        \n-        \n-        //Compose Alert based on Completion\n-        let halfCompletionKey = \"50pcShown\"  + (Study.currentStudy?.studyId)!\n-        let fullCompletionKey = \"100pcShown\"  + (Study.currentStudy?.studyId)!\n-        let missedKey = \"totalMissed\"  + (Study.currentStudy?.studyId)!\n-        \n-        let ud = UserDefaults.standard\n-        if completion > 50 && completion < 100 {\n-            \n-            if !(ud.bool(forKey: halfCompletionKey)) {\n-                let message =  \"The study \" + (Study.currentStudy?.name!)! + \" is now 50 percent complete. We look forward to your continued participation as the study progresses.\"\n-                //UIUtilities.showAlertWithMessage(alertMessage: message)\n-                ud.set(true, forKey: halfCompletionKey)\n-                \n-            }\n-            \n-        }\n-        \n-        if completion == 100 {\n-            \n-            if !(ud.bool(forKey: fullCompletionKey)) {\n-                let message =  \"The study \" + (Study.currentStudy?.name!)! + \" is 100 percent complete. Thank you for your participation.\"\n-                UIUtilities.showAlertWithMessage(alertMessage: message)\n-                ud.set(true, forKey: fullCompletionKey)\n-                \n-            }\n-        }\n-        \n-        //Alerts User about Completion\n-        if ud.object(forKey: missedKey) == nil {\n-            ud.set(totalIncompletedRuns, forKey: missedKey)\n-            \n-        } else {\n-            let previousMissed = (ud.object(forKey: missedKey) as? Int)!\n-            ud.set(totalIncompletedRuns, forKey: missedKey)\n-            if previousMissed < totalIncompletedRuns {\n-                //show alert\n-                \n-                let message = \"We noticed you missed an activity in \" + (Study.currentStudy?.name!)! + \" today. That\u2019s ok! We know you\u2019re busy, but we encourage you to complete study activities before they expire.\"\n-                UIUtilities.showAlertWithMessage(alertMessage: message)\n-            }\n-        }\n-        \n-        ud.synchronize()\n-        \n-    }\n-    \n-    func divide(lhs: Int, rhs: Int) -> Int {\n-        if rhs == 0 {\n-            return 0\n+    return .current\n+  }\n+\n+  /// To handle Activity list response.\n+  func handleActivityListResponse() {\n+\n+    tableViewSections = []\n+    allActivityList = []\n+    let activities = Study.currentStudy?.activities\n+\n+    var currentActivities: [Activity] = []\n+    var upcomingActivities: [Activity] = []\n+    var pastActivities: [Activity] = []\n+\n+    var isInActiveActivitiesAreAvailable: Bool! = false\n+    for activity in activities! {\n+\n+      if activity.state == \"active\" || activity.state == nil {\n+\n+        let status = self.getActivityAvailabilityStatus(activity: activity)\n+        switch status {\n+        case .current:\n+          currentActivities.append(activity)\n+        case .upcoming:\n+          upcomingActivities.append(activity)\n+        case .past:\n+          pastActivities.append(activity)\n         }\n-        return lhs/rhs\n+      } else {\n+\n+        isInActiveActivitiesAreAvailable = true\n+        DBHandler.deleteDBLocalNotification(\n+          activityId: activity.actvityId!, studyId: activity.studyId!)\n+      }\n     }\n-    \n-    /**\n-     Used to update Activity Status To InProgress\n-     */\n-    func updateActivityStatusToInProgress(){\n-        self.updateActivityRunStuatus(status: .inProgress)\n+\n+    if isInActiveActivitiesAreAvailable {\n+      LocalNotification.refreshAllLocalNotification()\n     }\n-    \n-    \n-    /**\n-     Used to update Activity Status To Complete\n-     */\n-    func updateActivityStatusToComplete(){\n-        self.updateActivityRunStuatus(status: .completed)\n+\n+    // Sort as per start date\n+    currentActivities.sort(by: { $0.startDate?.compare($1.startDate!) == .orderedAscending })\n+    upcomingActivities.sort(by: { $0.startDate?.compare($1.startDate!) == .orderedAscending })\n+    pastActivities.sort(by: { $0.startDate?.compare($1.startDate!) == .orderedAscending })\n+\n+    let sortedCurrentActivities = currentActivities.sorted(\n+      by: { (activity1: Activity, activity2: Activity) -> Bool in\n+\n+        return (\n+          activity1.userParticipationStatus.status.sortIndex < activity2\n+            .userParticipationStatus\n+            .status.sortIndex\n+        )\n+      })\n+\n+    let currentDetails = [\"title\": \"CURRENT\", \"activities\": sortedCurrentActivities] as [String: Any]\n+    let upcomingDetails = [\"title\": \"UPCOMING\", \"activities\": upcomingActivities] as [String: Any]\n+    let pastDetails = [\"title\": \"PAST\", \"activities\": pastActivities] as [String: Any]\n+\n+    allActivityList.append(currentDetails)\n+    allActivityList.append(upcomingDetails)\n+    allActivityList.append(pastDetails)\n+\n+    tableViewSections = allActivityList\n+\n+    if self.selectedFilter == .tasks || self.selectedFilter == .surveys {\n+\n+      let filterType: ActivityType! = (\n+        selectedFilter == .surveys ? .Questionnaire : .activeTask\n+      )\n+      self.updateSectionArray(activityType: filterType)\n     }\n-    \n-    //save completed staus in database\n-    func updateRunStatusToComplete(){\n-        \n-        let activity = Study.currentActivity!\n-        activity.compeltedRuns += 1\n-        DBHandler.updateRunToComplete(runId: activity.currentRunId, activityId: activity.actvityId!, studyId: activity.studyId!)\n-        self.updateActivityStatusToComplete()\n+\n+    DispatchQueue.main.async {\n+\n+      self.tableView?.reloadData()\n+      self.tableView?.isHidden = false\n+      self.labelNoNetworkAvailable?.isHidden = true\n+      self.updateCompletionAdherence()\n     }\n-    \n-    /**\n-     Update Run Status based on Run Id\n-     */\n-    func updateRunStatusForRunId(runId:Int){\n-        \n-        let activity = Study.currentActivity!\n-        activity.compeltedRuns += 1\n-        DBHandler.updateRunToComplete(runId: runId, activityId: activity.actvityId!, studyId: activity.studyId!)\n-        \n-        //update run count information\n-        let incompleteRuns = activity.currentRunId - activity.compeltedRuns\n-        activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n-        if activity.currentRun == nil {\n-            //Do Nothing\n-            \n-        } else {\n-            //Status is not completed\n-            if activity.userParticipationStatus.status != UserActivityStatus.ActivityStatus.completed {\n-                \n-                var incompleteRuns = activity.currentRunId - activity.compeltedRuns\n-                incompleteRuns -= 1\n-                activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n-            }\n-            \n+\n+    if (User.currentUser.settings?.localNotifications)! {\n+      if !(Study.currentStudy?.activitiesLocalNotificationUpdated)! {\n+        //Register LocalNotifications\n+        LocalNotification.registerAllLocalNotificationFor(\n+          activities: (Study.currentStudy?.activities)!\n+        ) { (_, notificationlist) in\n+          Study.currentStudy?.activitiesLocalNotificationUpdated = true\n+          DBHandler.saveRegisteredLocaNotifications(notificationList: notificationlist)\n+          DBHandler.updateLocalNotificationScheduleStatus(\n+            studyId: (Study.currentStudy?.studyId)!, status: true)\n+          LocalNotification.refreshAllLocalNotification()\n         }\n-        \n-        let activityStatus = User.currentUser.updateActivityStatus(studyId: activity.studyId!, activityId: activity.actvityId!,runId: String(runId), status: .completed)\n-        activityStatus.compeltedRuns = activity.compeltedRuns\n-        activityStatus.incompletedRuns = activity.incompletedRuns\n-        activityStatus.totalRuns = activity.totalRuns\n-        activityStatus.activityVersion = activity.version\n-        \n-        //Update User Participation Status to server\n-        UserServices().updateUserActivityParticipatedStatus(studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n-        \n-        //Update User Participation Status to DB\n-        DBHandler.updateActivityParticipationStatus(activity: activity)\n-        \n-        self.updateCompletionAdherence()\n-        self.tableView?.reloadData()\n-        \n+\n+      }\n     }\n-    \n-    /**\n-     Handler for studyUpdateResponse\n-     */\n-    func handleStudyUpdatesResponse() {\n-        \n-        Study.currentStudy?.newVersion = StudyUpdates.studyVersion\n-        DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n-        \n-        //Consent Updated\n-        if StudyUpdates.studyConsentUpdated {\n-            presentUpdatedConsent()\n-            \n-        } else if StudyUpdates.studyInfoUpdated {\n-            WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-            \n-        } else {\n-            self.checkForActivitiesUpdates()\n-        }\n-        \n+    self.checkIfFetelKickCountRunning()\n+  }\n+\n+  /// Updates Activity Run Status.\n+  /// - Parameter status: Status of the Activity.\n+  func updateActivityRun(status: UserActivityStatus.ActivityStatus) {\n+\n+    let activity = Study.currentActivity!\n+\n+    let activityStatus = User.currentUser.updateActivityStatus(\n+      studyId: activity.studyId!, activityId: activity.actvityId!,\n+      runId: String(activity.currentRunId), status: status)\n+    activityStatus.compeltedRuns = activity.compeltedRuns\n+    activityStatus.incompletedRuns = activity.incompletedRuns\n+    activityStatus.totalRuns = activity.totalRuns\n+    activityStatus.activityVersion = activity.version\n+\n+    /// Update participationStatus to server\n+    UserServices().updateUserActivityParticipatedStatus(\n+      studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n+\n+    /// Update participationStatus to DB\n+    DBHandler.updateParticipationStatus(for: activity)\n+\n+    if status == .completed {\n+      self.updateCompletionAdherence()\n     }\n-    \n-    // MARK: Api Calls\n-    \n-    /**\n-     Used to send Request To Get ActivityStates\n-     */\n-    func sendRequestToGetActivityStates(){\n-        UserServices().getUserActivityState(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+  }\n+\n+  /// Calculates the Completion & Adherence based on following criteria.\n+  ///\n+  ///     completion = ((totalCompletedRuns + totalIncompletedRuns) * 100) /  (totalRuns)\n+  ///     adherence =  (totalCompletedRuns*100) / (totalCompletedRuns + totalIncompletedRuns)\n+  ///\n+  /// Also alerts the user about the study Completion Status.\n+  func updateCompletionAdherence() {\n+\n+    var totalRuns = 0\n+    var totalCompletedRuns = 0\n+    var totalIncompletedRuns = 0\n+    let activities = Study.currentStudy?.activities  //.filter({$0.state == \"active\"})\n+\n+    /// Calculate Runs\n+    for activity in activities! {\n+      totalRuns += activity.totalRuns\n+      totalIncompletedRuns += activity.incompletedRuns\n+      totalCompletedRuns += activity.compeltedRuns\n+\n     }\n-    \n-    \n-    /**\n-     Used to send Request To Get ActivityList\n-     */\n-    func sendRequesToGetActivityList(){\n-        WCPServices().getStudyActivityList(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+    Study.currentStudy?.totalCompleteRuns = totalCompletedRuns\n+    Study.currentStudy?.totalIncompleteRuns = totalIncompletedRuns\n+    /// Calculate Completion & Adherence\n+    let completion = ceil(\n+      Double(\n+        self.divide(lhs: (totalCompletedRuns + totalIncompletedRuns)*100, rhs: totalRuns)))\n+    let adherence = ceil(\n+      Double(\n+        self.divide(\n+          lhs: totalCompletedRuns*100, rhs: (totalCompletedRuns + totalIncompletedRuns))))\n+\n+    let studyid = (Study.currentStudy?.studyId)!\n+\n+    let status = User.currentUser.udpateCompletionAndAdherence(\n+      studyId: studyid, completion: Int(completion), adherence: Int(adherence))\n+\n+    /// Update to server\n+    UserServices().updateCompletionAdherence(studyStatus: status, delegate: self)\n+    /// Update Local DB\n+    DBHandler.updateStudyParticipationStatus(study: Study.currentStudy!)\n+\n+    /// Compose Alert based on Completion\n+    let halfCompletionKey = \"50pcShown\" + (Study.currentStudy?.studyId)!\n+    let fullCompletionKey = \"100pcShown\" + (Study.currentStudy?.studyId)!\n+    let missedKey = \"totalMissed\" + (Study.currentStudy?.studyId)!\n+\n+    let ud = UserDefaults.standard\n+    if completion > 50 && completion < 100 {\n+\n+      if !(ud.bool(forKey: halfCompletionKey)) {\n+        ud.set(true, forKey: halfCompletionKey)\n+      }\n+\n     }\n-    \n-    func sendRequestToGetDashboardInfo(){\n-        WCPServices().getStudyDashboardInfo(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+    if completion == 100 {\n+\n+      if !(ud.bool(forKey: fullCompletionKey)) {\n+        let message = \"The study \" + (Study.currentStudy?.name!)!\n+          + \" is 100 percent complete. Thank you for your participation.\"\n+        UIUtilities.showAlertWithMessage(alertMessage: message)\n+        ud.set(true, forKey: fullCompletionKey)\n+\n+      }\n     }\n-    func sendRequestToGetResourcesInfo(){\n-        WCPServices().getResourcesForStudy(studyId:(Study.currentStudy?.studyId)!, delegate: self)\n+\n+    // Alerts User about Completion\n+    if ud.object(forKey: missedKey) == nil {\n+      ud.set(totalIncompletedRuns, forKey: missedKey)\n+\n+    } else {\n+      let previousMissed = (ud.object(forKey: missedKey) as? Int)!\n+      ud.set(totalIncompletedRuns, forKey: missedKey)\n+      if previousMissed < totalIncompletedRuns {\n+        // show alert\n+        let message = \"We noticed you missed an activity in \" + (Study.currentStudy?.name!)!\n+          + \" today. That\u2019s ok! We know you\u2019re busy, but we encourage you to complete study activities before they expire.\"\n+        UIUtilities.showAlertWithMessage(alertMessage: message)\n+      }\n     }\n-    \n-}\n \n+    ud.synchronize()\n \n-// MARK:- TableView Datasource\n-extension ActivitiesViewController: UITableViewDataSource{\n-    \n-    func numberOfSections(in tableView: UITableView) -> Int {\n-        return tableViewSections.count\n+  }\n+\n+  func divide(lhs: Int, rhs: Int) -> Int {\n+    if rhs == 0 {\n+      return 0\n     }\n-    \n-    private func tableView(tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n-        return 30\n+    return lhs/rhs\n+  }\n+\n+  /// To update Activity Status To InProgress.\n+  func updateActivityStatusToInProgress() {\n+    self.updateActivityRun(status: .inProgress)\n+  }\n+\n+  /// To update Activity Status To Complete.\n+  func updateActivityStatusToComplete() {\n+    self.updateActivityRun(status: .completed)\n+  }\n+\n+  /// Save completed staus in database.\n+  func updateRunStatusToComplete() {\n+\n+    let activity = Study.currentActivity!\n+    activity.compeltedRuns += 1\n+    DBHandler.updateRunToComplete(\n+      runId: activity.currentRunId, activityId: activity.actvityId!,\n+      studyId: activity.studyId!)\n+    self.updateActivityStatusToComplete()\n+  }\n+\n+  /// Update Run Status based on Run Id.\n+  func updateRunStatusForRunId(runId: Int) {\n+\n+    let activity = Study.currentActivity!\n+    activity.compeltedRuns += 1\n+    DBHandler.updateRunToComplete(\n+      runId: runId, activityId: activity.actvityId!, studyId: activity.studyId!)\n+\n+    // update run count information\n+    let incompleteRuns = activity.currentRunId - activity.compeltedRuns\n+    activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n+    if activity.currentRun != nil {\n+      // Status is not completed\n+      if activity.userParticipationStatus.status != UserActivityStatus.ActivityStatus\n+        .completed {\n+        var incompleteRuns = activity.currentRunId - activity.compeltedRuns\n+        incompleteRuns -= 1\n+        activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n+      }\n     }\n-    \n-    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n-        \n-        let rowDetail = tableViewSections[section]\n-        let activities = (rowDetail[\"activities\"] as? Array<Activity>)!\n-        if activities.count == 0 {\n-            return 1\n-        }\n-        return activities.count\n+\n+    let activityStatus = User.currentUser.updateActivityStatus(\n+      studyId: activity.studyId!, activityId: activity.actvityId!, runId: String(runId),\n+      status: .completed)\n+    activityStatus.compeltedRuns = activity.compeltedRuns\n+    activityStatus.incompletedRuns = activity.incompletedRuns\n+    activityStatus.totalRuns = activity.totalRuns\n+    activityStatus.activityVersion = activity.version\n+\n+    // Update User Participation Status to server\n+    UserServices().updateUserActivityParticipatedStatus(\n+      studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n+\n+    // Update User Participation Status to DB\n+    DBHandler.updateParticipationStatus(for: activity)\n+\n+    self.updateCompletionAdherence()\n+    self.tableView?.reloadData()\n+\n+  }\n+\n+  /// Handler for studyUpdateResponse.\n+  func handleStudyUpdatesResponse() {\n+\n+    Study.currentStudy?.newVersion = StudyUpdates.studyVersion\n+    DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n+\n+    //Consent Updated\n+    if StudyUpdates.studyConsentUpdated {\n+      presentUpdatedConsent()\n+\n+    } else if StudyUpdates.studyInfoUpdated {\n+      WCPServices().getStudyInformation(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+    } else {\n+      self.checkForActivitiesUpdates()\n     }\n-    \n-    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {\n-        let view = UIView.init(frame: CGRect(x: 0, y: 0, width: tableView.frame.width, height: 30))\n-        view.backgroundColor = kBackgroundTableViewColor\n-        \n-        let dayData = tableViewSections[section]\n-        \n-        let statusText = (dayData[\"title\"] as? String)!\n-        \n-        let label = UILabel.init(frame: CGRect(x: 18, y: 0, width: view.frame.size.width, height: view.frame.size.height))\n-        label.textAlignment = NSTextAlignment.natural\n-        label.text = statusText\n-        label.font = UIFont.boldSystemFont(ofSize: 14)\n-        label.translatesAutoresizingMaskIntoConstraints = true\n-        label.textColor = kGreyColor\n-        view.addSubview(label)\n-        \n-        return view\n+\n+  }\n+\n+  // MARK: Api Calls\n+\n+  /// Send Request To Get ActivityStates.\n+  func sendRequestToGetActivityStates() {\n+    UserServices().getUserActivityState(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+  }\n+\n+  /// Send Request To Get ActivityList.\n+  func sendRequesToGetActivityList() {\n+    WCPServices().getStudyActivityList(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+  }\n+\n+  func sendRequestToGetDashboardInfo() {\n+    WCPServices().getStudyDashboardInfo(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+  }\n+\n+  func sendRequestToGetResourcesInfo() {\n+    WCPServices().getResourcesForStudy(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  @IBAction func homeButtonAction(_ sender: AnyObject) {\n+    self.performSegue(withIdentifier: kActivityUnwindToStudyListIdentifier, sender: self)\n+  }\n+\n+  @IBAction func filterButtonAction(_ sender: AnyObject) {\n+    let frame = self.view.frame\n+    if self.selectedFilter == nil {\n+      self.selectedFilter = ActivityFilterType.all\n+    }\n+    //create and load FilterView\n+    let view = ActivityFilterView.instanceFromNib(\n+      frame: frame, selectedIndex: self.selectedFilter!)\n+    view.delegate = self\n+    self.tabBarController?.view.addSubview(view)\n+  }\n+\n+}\n+\n+// MARK: - TableView Datasource\n+extension ActivitiesViewController: UITableViewDataSource {\n+\n+  func numberOfSections(in tableView: UITableView) -> Int {\n+    return tableViewSections.count\n+  }\n+\n+  private func tableView(tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n+    return 30\n+  }\n+\n+  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n+\n+    let rowDetail = tableViewSections[section]\n+    let activities = (rowDetail[\"activities\"] as? [Activity])!\n+    if activities.count == 0 {\n+      return 1\n     }\n-    \n-    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n-        \n-        let rowDetail = tableViewSections[indexPath.section]\n-        let activities = (rowDetail[\"activities\"] as? Array<Activity>)!\n-        \n-        if activities.count == 0 {\n-            \n-            let cell = tableView.dequeueReusableCell(withIdentifier: \"noData\", for: indexPath)\n-            cell.isUserInteractionEnabled = false\n-            return cell\n-        } else {\n-            var cell = (tableView.dequeueReusableCell(withIdentifier: kActivitiesTableViewCell, for: indexPath) as? ActivitiesTableViewCell)!\n-            cell.delegate = self\n-            \n-            //Cell Data Setup\n-            cell.backgroundColor = UIColor.clear\n-            //kActivitiesTableViewScheduledCell\n-            let availabilityStatus = ActivityAvailabilityStatus(rawValue: indexPath.section)\n-            \n-            let activity = activities[indexPath.row]\n-            \n-            //check for scheduled frequency\n-            if activity.frequencyType == .Scheduled {\n-                \n-                cell = (tableView.dequeueReusableCell(withIdentifier: kActivitiesTableViewScheduledCell, for: indexPath) as? ActivitiesTableViewCell)!\n-                cell.delegate = self\n-            }\n-            //Set Cell data\n-            cell.populateCellDataWithActivity(activity: activity, availablityStatus: availabilityStatus!)\n-            \n-            return cell\n-        }\n+    return activities.count\n+  }\n+\n+  func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {\n+    let view = UIView.init(frame: CGRect(x: 0, y: 0, width: tableView.frame.width, height: 30))\n+    view.backgroundColor = kBackgroundTableViewColor\n+\n+    let dayData = tableViewSections[section]\n+\n+    let statusText = (dayData[\"title\"] as? String)!\n+\n+    let label = UILabel.init(\n+      frame: CGRect(x: 18, y: 0, width: view.frame.size.width, height: view.frame.size.height)\n+    )\n+    label.textAlignment = NSTextAlignment.natural\n+    label.text = statusText\n+    label.font = UIFont.boldSystemFont(ofSize: 14)\n+    label.translatesAutoresizingMaskIntoConstraints = true\n+    label.textColor = kGreyColor\n+    view.addSubview(label)\n+\n+    return view\n+  }\n+\n+  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n+\n+    let rowDetail = tableViewSections[indexPath.section]\n+    let activities = (rowDetail[\"activities\"] as? [Activity])!\n+\n+    if activities.count == 0 {\n+\n+      let cell = tableView.dequeueReusableCell(withIdentifier: \"noData\", for: indexPath)\n+      cell.isUserInteractionEnabled = false\n+      return cell\n+    } else {\n+      var cell = (\n+        tableView.dequeueReusableCell(\n+          withIdentifier: kActivitiesTableViewCell, for: indexPath)\n+          as? ActivitiesTableViewCell\n+      )!\n+      cell.delegate = self\n+\n+      // Cell Data Setup\n+      cell.backgroundColor = UIColor.clear\n+      let availabilityStatus = ActivityAvailabilityStatus(rawValu", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1773}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2NDIxMw==", "bodyText": "error log should print error message, this is only logging requestName", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391764213", "createdAt": "2020-03-12T17:04:13Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ActivityUI/ActivitiesViewController.swift", "diffHunk": "@@ -1,1780 +1,1527 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n-import UIKit\n-import ResearchKit\n import IQKeyboardManagerSwift\n+import ResearchKit\n+import UIKit\n \n let kActivities = \"activities\"\n \n let kActivityUnwindToStudyListIdentifier = \"unwindeToStudyListIdentier\"\n-let kActivityAbondonedAlertMessage = \"You missed the previous run of this activity. Please wait till the next run becomes available. Run timings are given on the Activities list screen.\"\n+let kActivityAbondonedAlertMessage\n+  = \"You missed the previous run of this activity. Please wait till the next run becomes available. Run timings are given on the Activities list screen.\"\n \n-enum ActivityAvailabilityStatus:Int{\n-    case current\n-    case upcoming\n-    case past\n+enum ActivityAvailabilityStatus: Int {\n+  case current\n+  case upcoming\n+  case past\n }\n \n-class ActivitiesViewController : UIViewController{\n-    \n-    @IBOutlet var tableView : UITableView?\n-    @IBOutlet var labelNoNetworkAvailable: UILabel?\n-    \n-    var tableViewSections: Array<Dictionary<String,Any>>! = []\n-    var lastFetelKickIdentifer: String = \"\"  //TEMP\n-    var selectedIndexPath: IndexPath? = nil\n-    var isAnchorDateSet: Bool = false\n-    var taskControllerPresented = false\n-    var refreshControl: UIRefreshControl? //To fetch the updated Activities\n-    \n-    var allActivityList: Array<Dictionary<String,Any>>! = []\n-    var selectedFilter: ActivityFilterType? //Holds the applied FilterTypes\n-    \n-    private var managedResult: [String: Any] = [:]\n-    \n-    let labkeyResponseFetch = ResponseDataFetch()\n-    \n-    // MARK:- Viewcontroller Lifecycle\n-    fileprivate func presentUpdatedConsent() {\n-        let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-        appDelegate.checkConsentStatus(controller: self)\n+class ActivitiesViewController: UIViewController {\n+\n+  // MARK: - Outlets\n+  @IBOutlet var tableView: UITableView?\n+\n+  @IBOutlet var labelNoNetworkAvailable: UILabel?\n+\n+  // MARK: - Properties\n+  private lazy var tableViewSections: [[String: Any]]! = []\n+\n+  private lazy var lastFetelKickIdentifer: String = \"\"  //TEMP\n+  private lazy var selectedIndexPath: IndexPath? = nil\n+\n+  private lazy var isAnchorDateSet: Bool = false\n+  private lazy var taskControllerPresented = false\n+\n+  /// To fetch the updated Activities.\n+  var refreshControl: UIRefreshControl?\n+\n+  private lazy var allActivityList: [[String: Any]]! = []\n+\n+  /// Holds the applied FilterTypes.\n+  var selectedFilter: ActivityFilterType?\n+\n+  private lazy var managedResult: [String: Any] = [:]\n+\n+  let labkeyResponseFetch = ResponseDataFetch()\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  fileprivate func presentUpdatedConsent() {\n+    let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+    appDelegate.checkConsentStatus(controller: self)\n+  }\n+\n+  deinit {\n+    Logger.sharedInstance.info(\"\\(self): deinit\")\n+  }\n+\n+  // MARK: - Viewcontroller Lifecycle\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    selectedFilter = ActivityFilterType.all\n+\n+    self.tableView?.estimatedRowHeight = 126\n+    self.tableView?.rowHeight = UITableView.automaticDimension\n+\n+    self.navigationItem.title = NSLocalizedString(\"STUDY ACTIVITIES\", comment: \"\")\n+    self.tableView?.sectionHeaderHeight = 30\n+\n+    self.navigationController?.navigationItem.rightBarButtonItem?.tintColor = UIColor.gray\n+\n+    if (Study.currentStudy?.studyId) != nil {\n+      if StudyUpdates.studyConsentUpdated {\n+        NotificationHandler.instance.activityId = \"\"\n+        presentUpdatedConsent()\n+      }\n     }\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        selectedFilter = ActivityFilterType.all\n-        \n-        self.tableView?.estimatedRowHeight = 126\n-        self.tableView?.rowHeight = UITableView.automaticDimension\n-        \n-        self.tabBarController?.delegate = self\n-        \n-        self.navigationItem.title = NSLocalizedString(\"STUDY ACTIVITIES\", comment: \"\")\n-        self.tableView?.sectionHeaderHeight = 30\n-        \n-        self.navigationController?.navigationItem.rightBarButtonItem?.tintColor = UIColor.gray\n-        \n-        if (Study.currentStudy?.studyId) != nil {\n-            if StudyUpdates.studyConsentUpdated {\n-                NotificationHandler.instance.activityId = \"\"\n-                presentUpdatedConsent()\n-            }\n-        }\n-        \n-        //create refresh control for pull to refresh\n-        refreshControl = UIRefreshControl()\n-        refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n-        refreshControl?.addTarget(self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n-        tableView?.addSubview(refreshControl!)\n+\n+    // create refresh control for pull to refresh\n+    refreshControl = UIRefreshControl()\n+    refreshControl?.attributedTitle = NSAttributedString(string: \"Pull to refresh\")\n+    refreshControl?.addTarget(\n+      self, action: #selector(refresh(sender:)), for: UIControl.Event.valueChanged)\n+    tableView?.addSubview(refreshControl!)\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+    self.navigationController?.interactivePopGestureRecognizer?.isEnabled = false\n+\n+    if Utilities.isStandaloneApp() {\n+      self.setNavigationBarItem()\n+    } else {\n+      self.addHomeButton()\n     }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        self.navigationController?.interactivePopGestureRecognizer?.isEnabled = false\n-        UIApplication.shared.statusBarStyle = .default\n-        \n-        if Utilities.isStandaloneApp() {\n-            self.setNavigationBarItem()\n-        }\n-        else {\n-            self.addHomeButton()\n-        }\n-       \n-        \n-        if !taskControllerPresented {\n-            taskControllerPresented = false\n-            self.checkForActivitiesUpdates()\n-        }\n-        \n-        if tableViewSections.count == 0 {\n-            self.tableView?.isHidden = true\n-            self.labelNoNetworkAvailable?.isHidden = false\n-            \n-        } else {\n-            self.tableView?.isHidden = false\n-            self.labelNoNetworkAvailable?.isHidden = true\n-        }\n-        \n-        \n+\n+    if !taskControllerPresented {\n+      taskControllerPresented = false\n+      self.checkForActivitiesUpdates()\n     }\n-    \n-    override func viewDidAppear(_ animated: Bool) {\n-        super.viewDidAppear(animated)\n-        \n-        let message =  \"The study \" + (Study.currentStudy?.name!)! + \" is 100 percent complete. Thank you for your participation.\"\n-       // UIUtilities.showAlertWithMessage(alertMessage: message)\n-        \n+\n+    if tableViewSections.count == 0 {\n+      self.tableView?.isHidden = true\n+      self.labelNoNetworkAvailable?.isHidden = false\n+\n+    } else {\n+      self.tableView?.isHidden = false\n+      self.labelNoNetworkAvailable?.isHidden = true\n     }\n-    \n-    // MARK: Helper Methods\n-    \n-    func getLabkeyResponse() {\n-        \n-        let ud = UserDefaults.standard\n-        let key = \"LabKeyResponse\" + (Study.currentStudy?.studyId)!\n-        if !(ud.bool(forKey: key)){\n-            labkeyResponseFetch.checkUpdates()\n-        }\n+\n+  }\n+\n+  // MARK: - Helper Methods\n+\n+  func getLabkeyResponse() {\n+\n+    let ud = UserDefaults.standard\n+    let key = \"LabKeyResponse\" + (Study.currentStudy?.studyId)!\n+    if !(ud.bool(forKey: key)) {\n+      labkeyResponseFetch.checkUpdates()\n     }\n-    \n-    func checkForActivitiesUpdates(){\n-        \n-        if StudyUpdates.studyActivitiesUpdated {\n-            \n-            self.sendRequestToGetActivityStates()\n-            \n-            //udpate status to false so notification can be registered again\n-            Study.currentStudy?.activitiesLocalNotificationUpdated = false\n-            DBHandler.updateLocalNotificaitonUpdated(studyId: (Study.currentStudy?.studyId)!,status: false)\n-            \n-        } else {\n-            \n-            if self.refreshControl != nil && (self.refreshControl?.isRefreshing)!{\n-                self.refreshControl?.endRefreshing()\n-            }\n-            //self.loadActivitiesFromDatabase()\n-            self.fetchActivityAnchorDateResponseFromLabkey()\n-        }\n+  }\n+\n+  /// Checks for Activity updates from WCP.\n+  func checkForActivitiesUpdates() {\n+\n+    if StudyUpdates.studyActivitiesUpdated {\n+\n+      self.sendRequestToGetActivityStates()\n+\n+      /// Update status to false so notification can be registered again.\n+      Study.currentStudy?.activitiesLocalNotificationUpdated = false\n+      DBHandler.updateLocalNotificationScheduleStatus(\n+        studyId: (Study.currentStudy?.studyId)!, status: false)\n+\n+    } else {\n+\n+      if self.refreshControl != nil && (self.refreshControl?.isRefreshing)! {\n+        self.refreshControl?.endRefreshing()\n+      }\n+      self.fetchActivityAnchorDateResponseFromLabkey()\n     }\n-    \n-    /**\n-     checkIfFetelKickCountRunning method verifies whether if FetalKick Task is Still running and calculate the time difference.\n-     */\n-    func checkIfFetelKickCountRunning(){\n-        \n-        let ud = UserDefaults.standard\n-        \n-        if (ud.bool(forKey: \"FKC\") && ud.object(forKey: kFetalKickStartTimeStamp) != nil) {\n-            \n-            //let studyId = (ud.object(forKey: kFetalkickStudyId)  as? String)!\n-            let activityId = (ud.object(forKey: kFetalKickActivityId)  as? String)!\n-            let activity  = Study.currentStudy?.activities?.filter({$0.actvityId == activityId}).last\n-            \n-            Study.updateCurrentActivity(activity: activity!)\n-            //check in database\n-            DBHandler.loadActivityMetaData(activity: activity!, completionHandler: { (found) in\n-                \n-                if found {\n-                    self.createActivity()\n-                }\n-                \n-            })\n-            \n-        } else {\n-            //check if user navigated from notification\n-            \n-            if NotificationHandler.instance.activityId.count > 0 {\n-                \n-                let activityId = NotificationHandler.instance.activityId\n-                \n-                let rowDetail = tableViewSections[0]\n-                let activities = (rowDetail[\"activities\"] as? Array<Activity>)!\n-                let index = activities.index(where: {$0.actvityId == activityId})\n-                let ip = IndexPath.init(row: index!, section: 0)\n-                self.selectedIndexPath = ip\n-                self.tableView?.selectRow(at: ip, animated: true, scrollPosition: .middle)\n-                self.tableView?.delegate?.tableView!(self.tableView!, didSelectRowAt: ip)\n-                \n-                NotificationHandler.instance.activityId = \"\"\n-            }\n-        }\n+  }\n+\n+  /// Verifies whether if FetalKick Task is Still running and calculate the time difference.\n+  func checkIfFetelKickCountRunning() {\n+\n+    let ud = UserDefaults.standard\n+\n+    if ud.bool(forKey: \"FKC\") && ud.object(forKey: kFetalKickStartTimeStamp) != nil {\n+\n+      let activityId = (ud.object(forKey: kFetalKickActivityId) as? String)!\n+      let activity = Study.currentStudy?.activities?.filter({ $0.actvityId == activityId })\n+        .last\n+\n+      Study.updateCurrentActivity(activity: activity!)\n+      // check in database\n+      DBHandler.loadActivityMetaData(\n+        activity: activity!,\n+        completionHandler: { (found) in\n+\n+          if found {\n+            self.createActivity()\n+          }\n+\n+        })\n+\n+    } else {\n+      /// check if user navigated from notification\n+      if NotificationHandler.instance.activityId.count > 0 {\n+\n+        let activityId = NotificationHandler.instance.activityId\n+\n+        let rowDetail = tableViewSections[0]\n+        let activities = (rowDetail[\"activities\"] as? [Activity])!\n+        let index = activities.firstIndex(where: { $0.actvityId == activityId })\n+        let ip = IndexPath.init(row: index!, section: 0)\n+        self.selectedIndexPath = ip\n+        self.tableView?.selectRow(at: ip, animated: true, scrollPosition: .middle)\n+        self.tableView?.delegate?.tableView!(self.tableView!, didSelectRowAt: ip)\n+\n+        NotificationHandler.instance.activityId = \"\"\n+      }\n     }\n-    \n-    /**\n-     RegisterNotificationForAnchorDate method sets the notification for the available resource\n-     */\n-    \n-    func registerNotificationForAnchorDate(){\n-        \n-        DBHandler.getResourcesWithAnchorDateAvailable(studyId: (Study.currentStudy?.studyId)!) { (resourcesList) in\n-            if resourcesList.count > 0 {\n-                let todayDate = Date()\n-                for resource in resourcesList {\n-                    \n-                    if resource.startDate == nil && resource.endDate == nil {\n-                        \n-                        let anchorDateObject = Study.currentStudy?.anchorDate\n-                        //Fetch AnchorData based availablity\n-                        if(anchorDateObject != nil && (anchorDateObject?.isAnchorDateAvailable())!) {\n-                            \n-                            let anchorDate = Study.currentStudy?.anchorDate?.date?.startOfDay\n-                            \n-                            if anchorDate != nil {\n-                                \n-                                //also anchor date condition\n-                                let startDateInterval = TimeInterval(60*60*24*(resource.anchorDateStartDays))\n-                                \n-                                let endDateInterval = TimeInterval(60*60*24*(resource.anchorDateEndDays))\n-                                \n-                                let startAnchorDate = anchorDate?.addingTimeInterval(startDateInterval)\n-                                var endAnchorDate = anchorDate?.addingTimeInterval(endDateInterval)\n-                                \n-                                endAnchorDate = endAnchorDate?.endOfDay\n-                                let startDateResult = (startAnchorDate?.compare(todayDate))! as ComparisonResult\n-                                //let endDateResult = (endAnchorDate?.compare(todayDate))! as ComparisonResult\n-                                self.isAnchorDateSet = false\n-                                \n-                                if startDateResult == .orderedDescending {\n-                                    //upcoming\n-                                    let notfiId = resource.resourceId! + (Study.currentStudy?.studyId)!\n-                                    DBHandler.isNotificationSetFor(notification: notfiId\n-                                        , completionHandler: { (found) in\n-                                            if !found {\n-                                                \n-                                                //Create AppLocalNotification\n-                                                let notification = AppLocalNotification()\n-                                                notification.id = resource.resourceId! + (Study.currentStudy?.studyId)!\n-                                                notification.message = resource.notificationMessage\n-                                                notification.title = \"New Resource Available\"\n-                                                notification.startDate = startAnchorDate\n-                                                notification.endDate = endAnchorDate\n-                                                notification.type = AppNotification.NotificationType.Study\n-                                                notification.subType = AppNotification.NotificationSubType.Resource\n-                                                notification.audience = Audience.Limited\n-                                                notification.studyId = (Study.currentStudy?.studyId)!\n-                                                //notification.activityId = Study.currentActivity?.actvityId\n-                                                \n-                                                //Save Notification to Database\n-                                                DBHandler.saveLocalNotification(notification: notification)\n-                                                \n-                                                //register notification\n-                                                var notificationDate = startAnchorDate?.startOfDay\n-                                                notificationDate = notificationDate?.addingTimeInterval(43200)\n-                                                let message = resource.notificationMessage\n-                                                let userInfo = [\"studyId\": (Study.currentStudy?.studyId)!,\n-                                                                \"type\": \"resource\"];\n-                                                LocalNotification.scheduleNotificationOn(date: notificationDate!, message: message!, userInfo: userInfo, id: notification.id)\n-                                            }\n-                                    })\n-                                }\n-                            }\n-                        }\n-                    }\n+  }\n+\n+  /// Sets the notification for the available resource.\n+  func registerNotificationForAnchorDate() {\n+\n+    DBHandler.getResourcesWithAnchorDateAvailable(studyId: (Study.currentStudy?.studyId)!) {\n+      (resourcesList) in\n+      if resourcesList.count > 0 {\n+        let todayDate = Date()\n+        for resource in resourcesList {\n+\n+          if resource.startDate == nil && resource.endDate == nil {\n+\n+            let anchorDateObject = Study.currentStudy?.anchorDate\n+            // Fetch AnchorData based availablity\n+            if anchorDateObject != nil && (anchorDateObject?.isAnchorDateAvailable())! {\n+\n+              let anchorDate = Study.currentStudy?.anchorDate?.date?.startOfDay\n+\n+              if anchorDate != nil {\n+\n+                // also anchor date condition\n+                let startDateInterval = TimeInterval(\n+                  60*60*24*(resource.anchorDateStartDays))\n+\n+                let endDateInterval = TimeInterval(\n+                  60*60*24*(resource.anchorDateEndDays))\n+\n+                let startAnchorDate = anchorDate?.addingTimeInterval(\n+                  startDateInterval)\n+                var endAnchorDate = anchorDate?.addingTimeInterval(endDateInterval)\n+\n+                endAnchorDate = endAnchorDate?.endOfDay\n+                let startDateResult = (startAnchorDate?.compare(todayDate))!\n+                  as ComparisonResult\n+                self.isAnchorDateSet = false\n+\n+                if startDateResult == .orderedDescending {\n+                  // upcoming\n+                  let notfiId = resource.resourceId! + (\n+                    Study.currentStudy?.studyId\n+                  )!\n+                  DBHandler.isNotificationSetFor(\n+                    notification: notfiId,\n+                    completionHandler: { (found) in\n+                      if !found {\n+\n+                        // Create AppLocalNotification\n+                        let notification = AppLocalNotification()\n+                        notification.id = resource.resourceId! + (\n+                          Study.currentStudy?.studyId\n+                        )!\n+                        notification.message = resource.notificationMessage\n+                        notification.title = \"New Resource Available\"\n+                        notification.startDate = startAnchorDate\n+                        notification.endDate = endAnchorDate\n+                        notification.type = AppNotification.NotificationType\n+                          .Study\n+                        notification.subType = AppNotification\n+                          .NotificationSubType.Resource\n+                        notification.audience = Audience.Limited\n+                        notification.studyId = (\n+                          Study.currentStudy?.studyId\n+                        )!\n+                        // Save Notification to Database\n+                        DBHandler.saveLocalNotification(\n+                          notification: notification)\n+\n+                        // register notification\n+                        var notificationDate = startAnchorDate?.startOfDay\n+                        notificationDate = notificationDate?\n+                          .addingTimeInterval(43200)\n+                        let message = resource.notificationMessage\n+                        let userInfo = [\n+                          \"studyId\": (Study.currentStudy?.studyId)!,\n+                          \"type\": \"resource\"\n+                        ]\n+                        LocalNotification.scheduleNotificationOn(\n+                          date: notificationDate!, message: message!,\n+                          userInfo: userInfo,\n+                          id: notification.id)\n+                      }\n+                    })\n                 }\n+              }\n             }\n+          }\n         }\n+      }\n     }\n-    \n-    \n-    // MARK:- Button Actions\n-    \n-    /**\n-     Home Button Clicked\n-     @param sender    Accepts any kind of object\n-     */\n-    @IBAction func homeButtonAction(_ sender: AnyObject){\n-        self.performSegue(withIdentifier: kActivityUnwindToStudyListIdentifier, sender: self)\n+  }\n+\n+  func checkForDashBoardInfo() {\n+\n+    DBHandler.loadStatisticsForStudy(studyId: (Study.currentStudy?.studyId)!) {\n+      (statiticsList) in\n+\n+      if statiticsList.count != 0 {\n+        // Do Nothing\n+      } else {\n+        self.sendRequestToGetDashboardInfo()\n+      }\n     }\n-    \n-    @IBAction func filterButtonAction(_ sender: AnyObject){\n-        let frame = self.view.frame\n-        \n-        if self.selectedFilter == nil {\n-            self.selectedFilter = ActivityFilterType.all\n-        }\n-        //create and load FilterView\n-        let view = ActivityFilterView.instanceFromNib(frame: frame , selectedIndex: self.selectedFilter!)\n-        view.delegate = self\n-        self.tabBarController?.view.addSubview(view)\n+  }\n+\n+  @objc func refresh(sender: AnyObject) {\n+    WCPServices().getStudyUpdates(study: Study.currentStudy!, delegate: self)\n+  }\n+\n+  func fetchActivityAnchorDateResponseFromLabkey() {\n+    AnchorDateHandler().fetchActivityAnchorDateResponseFromLabkey { (_) in\n+      self.loadActivitiesFromDatabase()\n     }\n-    \n-    // MARK: Helper Methods\n-    func checkForDashBoardInfo(){\n-        \n-        DBHandler.loadStatisticsForStudy(studyId: (Study.currentStudy?.studyId)!) { (statiticsList) in\n-            \n-            if statiticsList.count != 0 {\n-                //Do Nothing\n-            } else {\n-                self.sendRequestToGetDashboardInfo()\n-            }\n+  }\n+\n+  /// To load the Activities data from database.\n+  func loadActivitiesFromDatabase() {\n+\n+    if DBHandler.isActivitiesEmpty((Study.currentStudy?.studyId)!) {\n+      self.sendRequestToGetActivityStates()\n+    } else {\n+\n+      DBHandler.loadActivityListFromDatabase(studyId: (Study.currentStudy?.studyId)!) {\n+        (activities) in\n+        if activities.count > 0 {\n+          Study.currentStudy?.activities = activities\n+          self.handleActivityListResponse()\n         }\n+      }\n     }\n-    \n-    \n-    @objc func refresh(sender:AnyObject) {\n-        \n-        Logger.sharedInstance.info(\"Request for study Updated...\")\n-        WCPServices().getStudyUpdates(study: Study.currentStudy!, delegate: self)\n-        //self.sendRequesToGetActivityList()\n-    }\n-    \n-    \n-    // MARK:-\n-    \n-    func fetchActivityAnchorDateResponseFromLabkey() {\n-        \n-        AnchorDateHandler().fetchActivityAnchorDateResponseFromLabkey { (status) in\n-            print(\"Finished 1\")\n-            //if status {\n-                //DispatchQueue.main.async {\n-                    self.loadActivitiesFromDatabase()\n-                //}\n-                \n-            //}\n-            \n-        }\n-        print(\"Finished 0\")\n+  }\n+\n+  /// To create an activity using ORKTaskViewController.\n+  func createActivity() {\n+\n+    IQKeyboardManager.shared.enableAutoToolbar = false\n+\n+    if Utilities.isValidObject(someObject: Study.currentActivity?.steps as AnyObject?) {\n+      // Create ActivityBuilder instance.\n+      ActivityBuilder.currentActivityBuilder = ActivityBuilder()\n+      ActivityBuilder.currentActivityBuilder.initWithActivity(\n+        activity: Study.currentActivity!)\n     }\n-    \n-    /**\n-     Used to load the Actif=vities data from database\n-     */\n-    func loadActivitiesFromDatabase(){\n-        \n-        if DBHandler.isActivitiesEmpty((Study.currentStudy?.studyId)!) {\n-            self.sendRequestToGetActivityStates()\n-        }\n-        else {\n-            \n-            DBHandler.loadActivityListFromDatabase(studyId: (Study.currentStudy?.studyId)!) { (activities) in\n-                if activities.count > 0 {\n-                    Study.currentStudy?.activities = activities\n-                    \n-                    self.handleActivityListResponse()\n-                    \n-                    \n-                } else {\n-                    \n-                    //self.sendRequestToGetActivityStates()\n-                }\n-            }\n-        }\n+\n+    let task: ORKTask?\n+    let taskViewController: ORKTaskViewController?\n+\n+    task = ActivityBuilder.currentActivityBuilder.createTask()\n+\n+    if task != nil {\n+\n+      // Check if restorationData is available.\n+      if Study.currentActivity?.currentRun.restortionData != nil {\n+        let restoredData = Study.currentActivity?.currentRun.restortionData\n+\n+        taskViewController = ORKTaskViewController(\n+          task: task, restorationData: restoredData, delegate: self)\n+      } else {\n+\n+        taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n+        taskViewController?.outputDirectory = FileManager.default.urls(\n+          for: .documentDirectory, in: .userDomainMask).first!\n+      }\n+\n+      taskViewController?.showsProgressInNavigationBar = true\n+\n+      taskViewController?.title = \"Activity\"\n+\n+      // Customize appearance of TaskViewController\n+      UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+        = kUIColorForSubmitButtonBackground\n+\n+      taskViewController?.delegate = self\n+      taskControllerPresented = true\n+      taskViewController?.navigationBar.prefersLargeTitles = false\n+\n+      taskViewController?.modalPresentationStyle = .fullScreen\n+      present(taskViewController!, animated: true, completion: nil)\n+\n+    } else {\n+      // Task creation failed\n+      UIUtilities.showAlertMessage(\n+        kAlertMessageText, errorMessage: NSLocalizedString(\"Invalid Data!\", comment: \"\"),\n+        errorAlertActionTitle: NSLocalizedString(\"OK\", comment: \"\"),\n+        viewControllerUsed: self)\n     }\n-    \n-    \n-    /**\n-     Used to create an activity using ORKTaskViewController\n-     */\n-    func createActivity(){\n-        \n-        //Disable Custom KeyPad with toolbars\n-//        IQKeyboardManager.sharedManager().enable = false\n-        IQKeyboardManager.shared.enableAutoToolbar = false\n-        \n-        if Utilities.isValidObject(someObject: Study.currentActivity?.steps as AnyObject?){\n-            \n-            //Create ActivityBuilder instance\n-            ActivityBuilder.currentActivityBuilder = ActivityBuilder()\n-            ActivityBuilder.currentActivityBuilder.initWithActivity(activity: Study.currentActivity! )\n-        }\n-        \n-        let task: ORKTask?\n-        let taskViewController: ORKTaskViewController?\n-        \n-        task = ActivityBuilder.currentActivityBuilder.createTask()\n-        \n-        if task != nil {\n-            \n-            //check if restorationData is available\n-            if Study.currentActivity?.currentRun.restortionData != nil {\n-                let restoredData = Study.currentActivity?.currentRun.restortionData\n-                \n-                //let result: ORKResult?\n-                taskViewController = ORKTaskViewController(task: task, restorationData: restoredData, delegate: self)\n-            } else {\n-                \n-                taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n-                taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-            }\n-            \n-            taskViewController?.showsProgressInNavigationBar = true\n-            \n-            taskViewController?.title = \"Activity\"\n-            \n-            //Customize appearance of TaskViewController\n-            UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-            \n-            taskViewController?.delegate = self\n-            UIApplication.shared.statusBarStyle = .default\n-            taskControllerPresented = true\n-            taskViewController?.modalPresentationStyle = .fullScreen\n-            present(taskViewController!, animated: true, completion: nil)\n-            \n-        } else {\n-            //Task creation failed\n-            UIUtilities.showAlertMessage(kAlertMessageText, errorMessage: NSLocalizedString(\"Invalid Data!\", comment: \"\"), errorAlertActionTitle: NSLocalizedString(\"OK\", comment: \"\"), viewControllerUsed: self)\n-        }\n-        \n+\n+  }\n+\n+  /// To get Activity Availability Status.\n+  /// - Parameter activity: Instance of `Activity` to check it's status.\n+  func getActivityAvailabilityStatus(activity: Activity) -> ActivityAvailabilityStatus {\n+\n+    var todayDate = Date().utcDate()\n+\n+    let difference = UserDefaults.standard.value(forKey: \"offset\") as? Int\n+    if difference != nil {\n+      todayDate = todayDate.addingTimeInterval(TimeInterval(difference!))\n     }\n-    \n-    \n-    /**\n-     Used to get Activity Availability Status\n-     @param activity    Accepts data from Activity class\n-     @return ActivityAvailabilityStatus\n-     */\n-    func getActivityAvailabilityStatus(activity: Activity) -> ActivityAvailabilityStatus {\n-        \n-        var todayDate = Date().utcDate()\n-        \n-        let difference = UserDefaults.standard.value(forKey: \"offset\") as? Int\n-        if difference != nil {\n-            todayDate = todayDate.addingTimeInterval(TimeInterval(difference!))\n-        }\n-        \n-        if activity.startDate != nil && activity.endDate != nil {\n-            \n-            let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n-            let endDateResult = (activity.endDate?.compare(todayDate))! as ComparisonResult\n-            \n-            if startDateResult == .orderedAscending && endDateResult == .orderedDescending{\n-                return .current\n-                \n-            } else if startDateResult == .orderedDescending {\n-                return .upcoming\n-                \n-            } else if endDateResult == .orderedAscending {\n-                return .past\n-            }\n-        } else if activity.startDate != nil {\n-            \n-            let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n-            \n-            if startDateResult == .orderedAscending{\n-                return .current\n-                \n-            } else if startDateResult == .orderedDescending {\n-                return .upcoming\n-            }\n-        }\n+\n+    if activity.startDate != nil && activity.endDate != nil {\n+\n+      let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n+      let endDateResult = (activity.endDate?.compare(todayDate))! as ComparisonResult\n+\n+      if startDateResult == .orderedAscending && endDateResult == .orderedDescending {\n         return .current\n+\n+      } else if startDateResult == .orderedDescending {\n+        return .upcoming\n+\n+      } else if endDateResult == .orderedAscending {\n+        return .past\n+      }\n+    } else if activity.startDate != nil {\n+\n+      let startDateResult = (activity.startDate?.compare(todayDate))! as ComparisonResult\n+\n+      if startDateResult == .orderedAscending {\n+        return .current\n+\n+      } else if startDateResult == .orderedDescending {\n+        return .upcoming\n+      }\n     }\n-    \n-    \n-    /**\n-     Used to handle Activity list response\n-     */\n-    func handleActivityListResponse(){\n-        \n-        tableViewSections = []\n-        allActivityList = []\n-        let activities = Study.currentStudy?.activities\n-        \n-        var currentActivities: Array<Activity> = []\n-        var upcomingActivities: Array<Activity> = []\n-        var pastActivities: Array<Activity> = []\n-        \n-        var isInActiveActivitiesAreAvailable: Bool! = false\n-        for activity in activities! {\n-            \n-            if activity.state == \"active\" || activity.state == nil {\n-                \n-                let status =  self.getActivityAvailabilityStatus(activity: activity)\n-                switch status {\n-                case .current:\n-                    currentActivities.append(activity)\n-                case .upcoming:\n-                    upcomingActivities.append(activity)\n-                case .past:\n-                    pastActivities.append(activity)\n-                }\n-            } else {\n-                \n-                isInActiveActivitiesAreAvailable = true\n-                DBHandler.deleteDBLocalNotification(activityId: activity.actvityId!,studyId: activity.studyId!)\n-            }\n-        }\n-        \n-        if isInActiveActivitiesAreAvailable {\n-            LocalNotification.refreshAllLocalNotification()\n-        }\n-        \n-        //sort as per start date\n-        currentActivities.sort(by: {$0.startDate?.compare($1.startDate!) == .orderedAscending})\n-        upcomingActivities.sort(by: {$0.startDate?.compare($1.startDate!) == .orderedAscending})\n-        pastActivities.sort(by: {$0.startDate?.compare($1.startDate!) == .orderedAscending})\n-        \n-        let  sortedCurrentActivities =  currentActivities.sorted(by: { (activity1: Activity, activity2: Activity) -> Bool in\n-            \n-            return (activity1.userParticipationStatus.status.sortIndex < activity2.userParticipationStatus.status.sortIndex)\n-        })\n-        \n-        \n-        let currentDetails = [\"title\": \"CURRENT\",\"activities\": sortedCurrentActivities] as [String : Any]\n-        let upcomingDetails = [\"title\": \"UPCOMING\",\"activities\": upcomingActivities] as [String : Any]\n-        let pastDetails = [\"title\": \"PAST\",\"activities\": pastActivities] as [String : Any]\n-        \n-        allActivityList.append(currentDetails)\n-        allActivityList.append(upcomingDetails)\n-        allActivityList.append(pastDetails)\n-        \n-        tableViewSections = allActivityList\n-        \n-        if self.selectedFilter == .tasks || self.selectedFilter == .surveys {\n-            \n-            let filterType:ActivityType! =  (selectedFilter == .surveys ? .Questionnaire : .activeTask)\n-            self.updateSectionArray(activityType: filterType)\n-        }\n-        \n-        DispatchQueue.main.async {\n-            \n-            self.tableView?.reloadData()\n-            self.tableView?.isHidden = false\n-            self.labelNoNetworkAvailable?.isHidden = true\n-            self.updateCompletionAdherence()\n-        }\n-        \n-        \n-        \n-        \n-        if (User.currentUser.settings?.localNotifications)! {\n-            print(\"localNotifications enabled\")\n-            if !(Study.currentStudy?.activitiesLocalNotificationUpdated)! {\n-                print(\"Registerig Notification\")\n-                //Register LocalNotifications\n-                LocalNotification.registerAllLocalNotificationFor(activities: (Study.currentStudy?.activities)!) { (finished,notificationlist) in\n-                    print(\"Notification set sucessfully\")\n-                    Study.currentStudy?.activitiesLocalNotificationUpdated = true\n-                    DBHandler.saveRegisteredLocaNotification(notificationList: notificationlist)\n-                    DBHandler.updateLocalNotificaitonUpdated(studyId: (Study.currentStudy?.studyId)!,status: true)\n-                    LocalNotification.refreshAllLocalNotification()\n-                }\n-                \n-            }\n-        }\n-        \n-        self.checkIfFetelKickCountRunning()\n-        \n-        Logger.sharedInstance.info(\"Activities Displayed to user\")\n-    }\n-    \n-    /**\n-     Used to update Activity Run Status\n-     @param status    Accepts data from UserActivityStatus class and ActivityStatus enum\n-     */\n-    func updateActivityRunStuatus(status: UserActivityStatus.ActivityStatus){\n-        \n-        let activity = Study.currentActivity!\n-        \n-        let activityStatus = User.currentUser.updateActivityStatus(studyId: activity.studyId!, activityId: activity.actvityId!,runId: String(activity.currentRunId), status: status)\n-        activityStatus.compeltedRuns = activity.compeltedRuns\n-        activityStatus.incompletedRuns = activity.incompletedRuns\n-        activityStatus.totalRuns = activity.totalRuns\n-        activityStatus.activityVersion = activity.version\n-        \n-        //Update participationStatus to server\n-        UserServices().updateUserActivityParticipatedStatus(studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n-        \n-        //Update participationStatus to DB\n-        DBHandler.updateActivityParticipationStatus(activity: activity)\n-        \n-        if status == .completed {\n-            self.updateCompletionAdherence()\n-        }\n-        \n-    }\n-    \n-    /**\n-     updateCompletionAdherence, calculates the Completion & Adherence based on following criteria\n-     completion = ((totalCompletedRuns + totalIncompletedRuns) * 100) / (totalRuns)\n-     adherence =  (totalCompletedRuns*100) / (totalCompletedRuns + totalIncompletedRuns)\n-     \n-     and alerts the user about the study Completion Status\n-     \n-     */\n-    func updateCompletionAdherence() {\n-        \n-        var totalRuns = 0\n-        var totalCompletedRuns = 0\n-        var totalIncompletedRuns = 0\n-        let activities = Study.currentStudy?.activities //.filter({$0.state == \"active\"})\n-        \n-        //Calculate Runs\n-        for activity in activities! {\n-            totalRuns += activity.totalRuns\n-            totalIncompletedRuns += activity.incompletedRuns\n-            totalCompletedRuns += activity.compeltedRuns\n-            \n-        }\n-        \n-        \n-        Study.currentStudy?.totalCompleteRuns = totalCompletedRuns\n-        Study.currentStudy?.totalIncompleteRuns = totalIncompletedRuns\n-        //Calculate Completion & Adherence\n-        let completion = ceil( Double(self.divide(lhs: (totalCompletedRuns + totalIncompletedRuns)*100, rhs: totalRuns)) )\n-        let adherence = ceil (Double(self.divide(lhs: totalCompletedRuns*100, rhs: (totalCompletedRuns + totalIncompletedRuns))))\n-        \n-        let studyid = (Study.currentStudy?.studyId)!\n-        \n-        let status = User.currentUser.udpateCompletionAndAdherence(studyId: studyid, completion: Int(completion), adherence: Int(adherence))\n-        \n-        //Update to server\n-        UserServices().updateCompletionAdherence(studyStauts: status, delegate: self)\n-        //Update Local DB\n-        DBHandler.updateStudyParticipationStatus(study: Study.currentStudy!)\n-        \n-        \n-        //Compose Alert based on Completion\n-        let halfCompletionKey = \"50pcShown\"  + (Study.currentStudy?.studyId)!\n-        let fullCompletionKey = \"100pcShown\"  + (Study.currentStudy?.studyId)!\n-        let missedKey = \"totalMissed\"  + (Study.currentStudy?.studyId)!\n-        \n-        let ud = UserDefaults.standard\n-        if completion > 50 && completion < 100 {\n-            \n-            if !(ud.bool(forKey: halfCompletionKey)) {\n-                let message =  \"The study \" + (Study.currentStudy?.name!)! + \" is now 50 percent complete. We look forward to your continued participation as the study progresses.\"\n-                //UIUtilities.showAlertWithMessage(alertMessage: message)\n-                ud.set(true, forKey: halfCompletionKey)\n-                \n-            }\n-            \n-        }\n-        \n-        if completion == 100 {\n-            \n-            if !(ud.bool(forKey: fullCompletionKey)) {\n-                let message =  \"The study \" + (Study.currentStudy?.name!)! + \" is 100 percent complete. Thank you for your participation.\"\n-                UIUtilities.showAlertWithMessage(alertMessage: message)\n-                ud.set(true, forKey: fullCompletionKey)\n-                \n-            }\n-        }\n-        \n-        //Alerts User about Completion\n-        if ud.object(forKey: missedKey) == nil {\n-            ud.set(totalIncompletedRuns, forKey: missedKey)\n-            \n-        } else {\n-            let previousMissed = (ud.object(forKey: missedKey) as? Int)!\n-            ud.set(totalIncompletedRuns, forKey: missedKey)\n-            if previousMissed < totalIncompletedRuns {\n-                //show alert\n-                \n-                let message = \"We noticed you missed an activity in \" + (Study.currentStudy?.name!)! + \" today. That\u2019s ok! We know you\u2019re busy, but we encourage you to complete study activities before they expire.\"\n-                UIUtilities.showAlertWithMessage(alertMessage: message)\n-            }\n-        }\n-        \n-        ud.synchronize()\n-        \n-    }\n-    \n-    func divide(lhs: Int, rhs: Int) -> Int {\n-        if rhs == 0 {\n-            return 0\n+    return .current\n+  }\n+\n+  /// To handle Activity list response.\n+  func handleActivityListResponse() {\n+\n+    tableViewSections = []\n+    allActivityList = []\n+    let activities = Study.currentStudy?.activities\n+\n+    var currentActivities: [Activity] = []\n+    var upcomingActivities: [Activity] = []\n+    var pastActivities: [Activity] = []\n+\n+    var isInActiveActivitiesAreAvailable: Bool! = false\n+    for activity in activities! {\n+\n+      if activity.state == \"active\" || activity.state == nil {\n+\n+        let status = self.getActivityAvailabilityStatus(activity: activity)\n+        switch status {\n+        case .current:\n+          currentActivities.append(activity)\n+        case .upcoming:\n+          upcomingActivities.append(activity)\n+        case .past:\n+          pastActivities.append(activity)\n         }\n-        return lhs/rhs\n+      } else {\n+\n+        isInActiveActivitiesAreAvailable = true\n+        DBHandler.deleteDBLocalNotification(\n+          activityId: activity.actvityId!, studyId: activity.studyId!)\n+      }\n     }\n-    \n-    /**\n-     Used to update Activity Status To InProgress\n-     */\n-    func updateActivityStatusToInProgress(){\n-        self.updateActivityRunStuatus(status: .inProgress)\n+\n+    if isInActiveActivitiesAreAvailable {\n+      LocalNotification.refreshAllLocalNotification()\n     }\n-    \n-    \n-    /**\n-     Used to update Activity Status To Complete\n-     */\n-    func updateActivityStatusToComplete(){\n-        self.updateActivityRunStuatus(status: .completed)\n+\n+    // Sort as per start date\n+    currentActivities.sort(by: { $0.startDate?.compare($1.startDate!) == .orderedAscending })\n+    upcomingActivities.sort(by: { $0.startDate?.compare($1.startDate!) == .orderedAscending })\n+    pastActivities.sort(by: { $0.startDate?.compare($1.startDate!) == .orderedAscending })\n+\n+    let sortedCurrentActivities = currentActivities.sorted(\n+      by: { (activity1: Activity, activity2: Activity) -> Bool in\n+\n+        return (\n+          activity1.userParticipationStatus.status.sortIndex < activity2\n+            .userParticipationStatus\n+            .status.sortIndex\n+        )\n+      })\n+\n+    let currentDetails = [\"title\": \"CURRENT\", \"activities\": sortedCurrentActivities] as [String: Any]\n+    let upcomingDetails = [\"title\": \"UPCOMING\", \"activities\": upcomingActivities] as [String: Any]\n+    let pastDetails = [\"title\": \"PAST\", \"activities\": pastActivities] as [String: Any]\n+\n+    allActivityList.append(currentDetails)\n+    allActivityList.append(upcomingDetails)\n+    allActivityList.append(pastDetails)\n+\n+    tableViewSections = allActivityList\n+\n+    if self.selectedFilter == .tasks || self.selectedFilter == .surveys {\n+\n+      let filterType: ActivityType! = (\n+        selectedFilter == .surveys ? .Questionnaire : .activeTask\n+      )\n+      self.updateSectionArray(activityType: filterType)\n     }\n-    \n-    //save completed staus in database\n-    func updateRunStatusToComplete(){\n-        \n-        let activity = Study.currentActivity!\n-        activity.compeltedRuns += 1\n-        DBHandler.updateRunToComplete(runId: activity.currentRunId, activityId: activity.actvityId!, studyId: activity.studyId!)\n-        self.updateActivityStatusToComplete()\n+\n+    DispatchQueue.main.async {\n+\n+      self.tableView?.reloadData()\n+      self.tableView?.isHidden = false\n+      self.labelNoNetworkAvailable?.isHidden = true\n+      self.updateCompletionAdherence()\n     }\n-    \n-    /**\n-     Update Run Status based on Run Id\n-     */\n-    func updateRunStatusForRunId(runId:Int){\n-        \n-        let activity = Study.currentActivity!\n-        activity.compeltedRuns += 1\n-        DBHandler.updateRunToComplete(runId: runId, activityId: activity.actvityId!, studyId: activity.studyId!)\n-        \n-        //update run count information\n-        let incompleteRuns = activity.currentRunId - activity.compeltedRuns\n-        activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n-        if activity.currentRun == nil {\n-            //Do Nothing\n-            \n-        } else {\n-            //Status is not completed\n-            if activity.userParticipationStatus.status != UserActivityStatus.ActivityStatus.completed {\n-                \n-                var incompleteRuns = activity.currentRunId - activity.compeltedRuns\n-                incompleteRuns -= 1\n-                activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n-            }\n-            \n+\n+    if (User.currentUser.settings?.localNotifications)! {\n+      if !(Study.currentStudy?.activitiesLocalNotificationUpdated)! {\n+        //Register LocalNotifications\n+        LocalNotification.registerAllLocalNotificationFor(\n+          activities: (Study.currentStudy?.activities)!\n+        ) { (_, notificationlist) in\n+          Study.currentStudy?.activitiesLocalNotificationUpdated = true\n+          DBHandler.saveRegisteredLocaNotifications(notificationList: notificationlist)\n+          DBHandler.updateLocalNotificationScheduleStatus(\n+            studyId: (Study.currentStudy?.studyId)!, status: true)\n+          LocalNotification.refreshAllLocalNotification()\n         }\n-        \n-        let activityStatus = User.currentUser.updateActivityStatus(studyId: activity.studyId!, activityId: activity.actvityId!,runId: String(runId), status: .completed)\n-        activityStatus.compeltedRuns = activity.compeltedRuns\n-        activityStatus.incompletedRuns = activity.incompletedRuns\n-        activityStatus.totalRuns = activity.totalRuns\n-        activityStatus.activityVersion = activity.version\n-        \n-        //Update User Participation Status to server\n-        UserServices().updateUserActivityParticipatedStatus(studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n-        \n-        //Update User Participation Status to DB\n-        DBHandler.updateActivityParticipationStatus(activity: activity)\n-        \n-        self.updateCompletionAdherence()\n-        self.tableView?.reloadData()\n-        \n+\n+      }\n     }\n-    \n-    /**\n-     Handler for studyUpdateResponse\n-     */\n-    func handleStudyUpdatesResponse() {\n-        \n-        Study.currentStudy?.newVersion = StudyUpdates.studyVersion\n-        DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n-        \n-        //Consent Updated\n-        if StudyUpdates.studyConsentUpdated {\n-            presentUpdatedConsent()\n-            \n-        } else if StudyUpdates.studyInfoUpdated {\n-            WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-            \n-        } else {\n-            self.checkForActivitiesUpdates()\n-        }\n-        \n+    self.checkIfFetelKickCountRunning()\n+  }\n+\n+  /// Updates Activity Run Status.\n+  /// - Parameter status: Status of the Activity.\n+  func updateActivityRun(status: UserActivityStatus.ActivityStatus) {\n+\n+    let activity = Study.currentActivity!\n+\n+    let activityStatus = User.currentUser.updateActivityStatus(\n+      studyId: activity.studyId!, activityId: activity.actvityId!,\n+      runId: String(activity.currentRunId), status: status)\n+    activityStatus.compeltedRuns = activity.compeltedRuns\n+    activityStatus.incompletedRuns = activity.incompletedRuns\n+    activityStatus.totalRuns = activity.totalRuns\n+    activityStatus.activityVersion = activity.version\n+\n+    /// Update participationStatus to server\n+    UserServices().updateUserActivityParticipatedStatus(\n+      studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n+\n+    /// Update participationStatus to DB\n+    DBHandler.updateParticipationStatus(for: activity)\n+\n+    if status == .completed {\n+      self.updateCompletionAdherence()\n     }\n-    \n-    // MARK: Api Calls\n-    \n-    /**\n-     Used to send Request To Get ActivityStates\n-     */\n-    func sendRequestToGetActivityStates(){\n-        UserServices().getUserActivityState(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+  }\n+\n+  /// Calculates the Completion & Adherence based on following criteria.\n+  ///\n+  ///     completion = ((totalCompletedRuns + totalIncompletedRuns) * 100) /  (totalRuns)\n+  ///     adherence =  (totalCompletedRuns*100) / (totalCompletedRuns + totalIncompletedRuns)\n+  ///\n+  /// Also alerts the user about the study Completion Status.\n+  func updateCompletionAdherence() {\n+\n+    var totalRuns = 0\n+    var totalCompletedRuns = 0\n+    var totalIncompletedRuns = 0\n+    let activities = Study.currentStudy?.activities  //.filter({$0.state == \"active\"})\n+\n+    /// Calculate Runs\n+    for activity in activities! {\n+      totalRuns += activity.totalRuns\n+      totalIncompletedRuns += activity.incompletedRuns\n+      totalCompletedRuns += activity.compeltedRuns\n+\n     }\n-    \n-    \n-    /**\n-     Used to send Request To Get ActivityList\n-     */\n-    func sendRequesToGetActivityList(){\n-        WCPServices().getStudyActivityList(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+    Study.currentStudy?.totalCompleteRuns = totalCompletedRuns\n+    Study.currentStudy?.totalIncompleteRuns = totalIncompletedRuns\n+    /// Calculate Completion & Adherence\n+    let completion = ceil(\n+      Double(\n+        self.divide(lhs: (totalCompletedRuns + totalIncompletedRuns)*100, rhs: totalRuns)))\n+    let adherence = ceil(\n+      Double(\n+        self.divide(\n+          lhs: totalCompletedRuns*100, rhs: (totalCompletedRuns + totalIncompletedRuns))))\n+\n+    let studyid = (Study.currentStudy?.studyId)!\n+\n+    let status = User.currentUser.udpateCompletionAndAdherence(\n+      studyId: studyid, completion: Int(completion), adherence: Int(adherence))\n+\n+    /// Update to server\n+    UserServices().updateCompletionAdherence(studyStatus: status, delegate: self)\n+    /// Update Local DB\n+    DBHandler.updateStudyParticipationStatus(study: Study.currentStudy!)\n+\n+    /// Compose Alert based on Completion\n+    let halfCompletionKey = \"50pcShown\" + (Study.currentStudy?.studyId)!\n+    let fullCompletionKey = \"100pcShown\" + (Study.currentStudy?.studyId)!\n+    let missedKey = \"totalMissed\" + (Study.currentStudy?.studyId)!\n+\n+    let ud = UserDefaults.standard\n+    if completion > 50 && completion < 100 {\n+\n+      if !(ud.bool(forKey: halfCompletionKey)) {\n+        ud.set(true, forKey: halfCompletionKey)\n+      }\n+\n     }\n-    \n-    func sendRequestToGetDashboardInfo(){\n-        WCPServices().getStudyDashboardInfo(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+    if completion == 100 {\n+\n+      if !(ud.bool(forKey: fullCompletionKey)) {\n+        let message = \"The study \" + (Study.currentStudy?.name!)!\n+          + \" is 100 percent complete. Thank you for your participation.\"\n+        UIUtilities.showAlertWithMessage(alertMessage: message)\n+        ud.set(true, forKey: fullCompletionKey)\n+\n+      }\n     }\n-    func sendRequestToGetResourcesInfo(){\n-        WCPServices().getResourcesForStudy(studyId:(Study.currentStudy?.studyId)!, delegate: self)\n+\n+    // Alerts User about Completion\n+    if ud.object(forKey: missedKey) == nil {\n+      ud.set(totalIncompletedRuns, forKey: missedKey)\n+\n+    } else {\n+      let previousMissed = (ud.object(forKey: missedKey) as? Int)!\n+      ud.set(totalIncompletedRuns, forKey: missedKey)\n+      if previousMissed < totalIncompletedRuns {\n+        // show alert\n+        let message = \"We noticed you missed an activity in \" + (Study.currentStudy?.name!)!\n+          + \" today. That\u2019s ok! We know you\u2019re busy, but we encourage you to complete study activities before they expire.\"\n+        UIUtilities.showAlertWithMessage(alertMessage: message)\n+      }\n     }\n-    \n-}\n \n+    ud.synchronize()\n \n-// MARK:- TableView Datasource\n-extension ActivitiesViewController: UITableViewDataSource{\n-    \n-    func numberOfSections(in tableView: UITableView) -> Int {\n-        return tableViewSections.count\n+  }\n+\n+  func divide(lhs: Int, rhs: Int) -> Int {\n+    if rhs == 0 {\n+      return 0\n     }\n-    \n-    private func tableView(tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n-        return 30\n+    return lhs/rhs\n+  }\n+\n+  /// To update Activity Status To InProgress.\n+  func updateActivityStatusToInProgress() {\n+    self.updateActivityRun(status: .inProgress)\n+  }\n+\n+  /// To update Activity Status To Complete.\n+  func updateActivityStatusToComplete() {\n+    self.updateActivityRun(status: .completed)\n+  }\n+\n+  /// Save completed staus in database.\n+  func updateRunStatusToComplete() {\n+\n+    let activity = Study.currentActivity!\n+    activity.compeltedRuns += 1\n+    DBHandler.updateRunToComplete(\n+      runId: activity.currentRunId, activityId: activity.actvityId!,\n+      studyId: activity.studyId!)\n+    self.updateActivityStatusToComplete()\n+  }\n+\n+  /// Update Run Status based on Run Id.\n+  func updateRunStatusForRunId(runId: Int) {\n+\n+    let activity = Study.currentActivity!\n+    activity.compeltedRuns += 1\n+    DBHandler.updateRunToComplete(\n+      runId: runId, activityId: activity.actvityId!, studyId: activity.studyId!)\n+\n+    // update run count information\n+    let incompleteRuns = activity.currentRunId - activity.compeltedRuns\n+    activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n+    if activity.currentRun != nil {\n+      // Status is not completed\n+      if activity.userParticipationStatus.status != UserActivityStatus.ActivityStatus\n+        .completed {\n+        var incompleteRuns = activity.currentRunId - activity.compeltedRuns\n+        incompleteRuns -= 1\n+        activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n+      }\n     }\n-    \n-    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n-        \n-        let rowDetail = tableViewSections[section]\n-        let activities = (rowDetail[\"activities\"] as? Array<Activity>)!\n-        if activities.count == 0 {\n-            return 1\n-        }\n-        return activities.count\n+\n+    let activityStatus = User.currentUser.updateActivityStatus(\n+      studyId: activity.studyId!, activityId: activity.actvityId!, runId: String(runId),\n+      status: .completed)\n+    activityStatus.compeltedRuns = activity.compeltedRuns\n+    activityStatus.incompletedRuns = activity.incompletedRuns\n+    activityStatus.totalRuns = activity.totalRuns\n+    activityStatus.activityVersion = activity.version\n+\n+    // Update User Participation Status to server\n+    UserServices().updateUserActivityParticipatedStatus(\n+      studyId: activity.studyId!, activityStatus: activityStatus, delegate: self)\n+\n+    // Update User Participation Status to DB\n+    DBHandler.updateParticipationStatus(for: activity)\n+\n+    self.updateCompletionAdherence()\n+    self.tableView?.reloadData()\n+\n+  }\n+\n+  /// Handler for studyUpdateResponse.\n+  func handleStudyUpdatesResponse() {\n+\n+    Study.currentStudy?.newVersion = StudyUpdates.studyVersion\n+    DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n+\n+    //Consent Updated\n+    if StudyUpdates.studyConsentUpdated {\n+      presentUpdatedConsent()\n+\n+    } else if StudyUpdates.studyInfoUpdated {\n+      WCPServices().getStudyInformation(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+    } else {\n+      self.checkForActivitiesUpdates()\n     }\n-    \n-    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {\n-        let view = UIView.init(frame: CGRect(x: 0, y: 0, width: tableView.frame.width, height: 30))\n-        view.backgroundColor = kBackgroundTableViewColor\n-        \n-        let dayData = tableViewSections[section]\n-        \n-        let statusText = (dayData[\"title\"] as? String)!\n-        \n-        let label = UILabel.init(frame: CGRect(x: 18, y: 0, width: view.frame.size.width, height: view.frame.size.height))\n-        label.textAlignment = NSTextAlignment.natural\n-        label.text = statusText\n-        label.font = UIFont.boldSystemFont(ofSize: 14)\n-        label.translatesAutoresizingMaskIntoConstraints = true\n-        label.textColor = kGreyColor\n-        view.addSubview(label)\n-        \n-        return view\n+\n+  }\n+\n+  // MARK: Api Calls\n+\n+  /// Send Request To Get ActivityStates.\n+  func sendRequestToGetActivityStates() {\n+    UserServices().getUserActivityState(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+  }\n+\n+  /// Send Request To Get ActivityList.\n+  func sendRequesToGetActivityList() {\n+    WCPServices().getStudyActivityList(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+  }\n+\n+  func sendRequestToGetDashboardInfo() {\n+    WCPServices().getStudyDashboardInfo(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+  }\n+\n+  func sendRequestToGetResourcesInfo() {\n+    WCPServices().getResourcesForStudy(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  @IBAction func homeButtonAction(_ sender: AnyObject) {\n+    self.performSegue(withIdentifier: kActivityUnwindToStudyListIdentifier, sender: self)\n+  }\n+\n+  @IBAction func filterButtonAction(_ sender: AnyObject) {\n+    let frame = self.view.frame\n+    if self.selectedFilter == nil {\n+      self.selectedFilter = ActivityFilterType.all\n+    }\n+    //create and load FilterView\n+    let view = ActivityFilterView.instanceFromNib(\n+      frame: frame, selectedIndex: self.selectedFilter!)\n+    view.delegate = self\n+    self.tabBarController?.view.addSubview(view)\n+  }\n+\n+}\n+\n+// MARK: - TableView Datasource\n+extension ActivitiesViewController: UITableViewDataSource {\n+\n+  func numberOfSections(in tableView: UITableView) -> Int {\n+    return tableViewSections.count\n+  }\n+\n+  private func tableView(tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {\n+    return 30\n+  }\n+\n+  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n+\n+    let rowDetail = tableViewSections[section]\n+    let activities = (rowDetail[\"activities\"] as? [Activity])!\n+    if activities.count == 0 {\n+      return 1\n     }\n-    \n-    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n-        \n-        let rowDetail = tableViewSections[indexPath.section]\n-        let activities = (rowDetail[\"activities\"] as? Array<Activity>)!\n-        \n-        if activities.count == 0 {\n-            \n-            let cell = tableView.dequeueReusableCell(withIdentifier: \"noData\", for: indexPath)\n-            cell.isUserInteractionEnabled = false\n-            return cell\n-        } else {\n-            var cell = (tableView.dequeueReusableCell(withIdentifier: kActivitiesTableViewCell, for: indexPath) as? ActivitiesTableViewCell)!\n-            cell.delegate = self\n-            \n-            //Cell Data Setup\n-            cell.backgroundColor = UIColor.clear\n-            //kActivitiesTableViewScheduledCell\n-            let availabilityStatus = ActivityAvailabilityStatus(rawValue: indexPath.section)\n-            \n-            let activity = activities[indexPath.row]\n-            \n-            //check for scheduled frequency\n-            if activity.frequencyType == .Scheduled {\n-                \n-                cell = (tableView.dequeueReusableCell(withIdentifier: kActivitiesTableViewScheduledCell, for: indexPath) as? ActivitiesTableViewCell)!\n-                cell.delegate = self\n-            }\n-            //Set Cell data\n-            cell.populateCellDataWithActivity(activity: activity, availablityStatus: availabilityStatus!)\n-            \n-            return cell\n-        }\n+    return activities.count\n+  }\n+\n+  func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {\n+    let view = UIView.init(frame: CGRect(x: 0, y: 0, width: tableView.frame.width, height: 30))\n+    view.backgroundColor = kBackgroundTableViewColor\n+\n+    let dayData = tableViewSections[section]\n+\n+    let statusText = (dayData[\"title\"] as? String)!\n+\n+    let label = UILabel.init(\n+      frame: CGRect(x: 18, y: 0, width: view.frame.size.width, height: view.frame.size.height)\n+    )\n+    label.textAlignment = NSTextAlignment.natural\n+    label.text = statusText\n+    label.font = UIFont.boldSystemFont(ofSize: 14)\n+    label.translatesAutoresizingMaskIntoConstraints = true\n+    label.textColor = kGreyColor\n+    view.addSubview(label)\n+\n+    return view\n+  }\n+\n+  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n+\n+    let rowDetail = tableViewSections[indexPath.section]\n+    let activities = (rowDetail[\"activities\"] as? [Activity])!\n+\n+    if activities.count == 0 {\n+\n+      let cell = tableView.dequeueReusableCell(withIdentifier: \"noData\", for: indexPath)\n+      cell.isUserInteractionEnabled = false\n+      return cell\n+    } else {\n+      var cell = (\n+        tableView.dequeueReusableCell(\n+          withIdentifier: kActivitiesTableViewCell, for: indexPath)\n+          as? ActivitiesTableViewCell\n+      )!\n+      cell.delegate = self\n+\n+      // Cell Data Setup\n+      cell.backgroundColor = UIColor.clear\n+      let availabilityStatus = ActivityAvailabilityStatus(rawValu", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 2071}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4NjM3MQ==", "bodyText": "remove debug log", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391786371", "createdAt": "2020-03-12T17:40:53Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ActivityUI/QuestionStepController/TextChoiceQuestionController.swift", "diffHunk": "@@ -1,733 +1,776 @@\n-//\n-//  TextChoiceQuestionController.swift\n-//  Survey-Demo\n-//\n-//  Created by Tushar on 3/20/19.\n-//  Copyright \u00a9 2019 Tushar. All rights reserved.\n-//\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n+\n import UIKit\n import ResearchKit\n \n+/// A value type whose instances will have Other Choice configuration in TextChoiceQuestionStep .\n struct OtherChoice {\n-    \n-    let isShowOtherCell: Bool\n-    let isShowOtherField: Bool\n-    let otherTitle: String\n-    let placeholder: String\n-    let isMandatory: Bool\n-    let detailText: String\n-    lazy var otherChoiceText = \"\"\n-    let isExclusive: Bool\n-    let value: String\n-    \n-    init(isShowOtherCell: Bool = false, isShowOtherField: Bool = true, otherTitle: String = \"Other\", placeholder: String = \"enter here\",isMandatory: Bool = true,isExclusive: Bool = false, detailText: String = \"\", value: String = \"\") {\n-        self.isShowOtherField = isShowOtherField\n-        self.otherTitle = otherTitle\n-        self.placeholder = placeholder\n-        self.isMandatory = isMandatory\n-        self.isShowOtherCell = isShowOtherCell\n-        self.isExclusive = isExclusive\n-        self.detailText = detailText\n-        self.value = value\n-    }\n+\n+  /// A Boolean value indicating other choice availablity.\n+  let isShowOtherCell: Bool\n+\n+  /// A Boolean value indicating other choice TextField availablity.\n+  let isShowOtherField: Bool\n+\n+  /// Text Choice title.\n+  let otherTitle: String\n+\n+  /// Text Choice field placeholder.\n+  let placeholder: String\n+\n+  /// A Boolean value indicating choice selection is mandatory.\n+  let isMandatory: Bool\n+\n+  /// Details text of the choice.\n+  let detailText: String\n+\n+  lazy var otherChoiceText = \"\"\n+  let isExclusive: Bool\n+  let value: String\n+\n+  init(\n+    isShowOtherCell: Bool = false, isShowOtherField: Bool = true, otherTitle: String = \"Other\",\n+    placeholder: String = \"enter here\", isMandatory: Bool = true, isExclusive: Bool = false,\n+    detailText: String = \"\", value: String = \"\"\n+  ) {\n+    self.isShowOtherField = isShowOtherField\n+    self.otherTitle = otherTitle\n+    self.placeholder = placeholder\n+    self.isMandatory = isMandatory\n+    self.isShowOtherCell = isShowOtherCell\n+    self.isExclusive = isExclusive\n+    self.detailText = detailText\n+    self.value = value\n+  }\n }\n \n+/// Subclass of `ORKQuestionStep` which includes the configuration of `OtherChoice`.\n class QuestionStep: ORKQuestionStep {\n-    \n-    lazy var otherChoice = OtherChoice()\n-    \n-    init(identifier: String, title: String?, question: String, answer: ORKAnswerFormat,otherChoice: OtherChoice) {\n-        super.init(identifier: identifier)\n-        self.title = title\n-        self.question = question\n-        self.answerFormat = answer\n-        self.otherChoice = otherChoice\n-    }\n-    \n-    required init(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-        fatalError(\"init(coder:) has not been implemented\")\n-    }\n-    \n+\n+  /// Instance of `OtherChoice` configuration.\n+  lazy var otherChoice = OtherChoice()\n+\n+  init(\n+    identifier: String, title: String?, question: String, answer: ORKAnswerFormat,\n+    otherChoice: OtherChoice\n+  ) {\n+    super.init(identifier: identifier)\n+    self.title = title\n+    self.question = question\n+    self.answerFormat = answer\n+    self.otherChoice = otherChoice\n+  }\n+\n+  required init(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+    fatalError(\"init(coder:) has not been implemented\")\n+  }\n+\n }\n \n class TextChoiceQuestionController: ORKQuestionStepViewController {\n-    \n-    \n-    ///  Table View ref from the Super class\n-    var tableView: UITableView?\n-    \n-    /// Current step\n-    var questionStep: QuestionStep?\n-    \n-    /// Continue button ref from the Super class\n-    private var continueBtn: UIButton?\n-    \n-    var answerFormat: ORKTextChoiceAnswerFormat? {\n-        return questionStep?.answerFormat as? ORKTextChoiceAnswerFormat\n-    }\n-    \n-    override var result: ORKStepResult? {\n-        \n-        let orkResult = super.result\n-        \n-        guard let identifier = step?.identifier else {return nil}\n-        let choiceResult = ORKChoiceQuestionResult(identifier: identifier)\n-        \n-        var choices: [Any] = []\n-        \n-        for choice in self.selectedChoices {\n-            choices.append(choice.value)\n-        }\n-        \n-        if self.isOtherCellSelected {\n-            var otherChoiceDict: [String:Any]!\n-            if self.otherChoice.isShowOtherField {\n-                otherChoiceDict = [\"other\": otherChoice.otherTitle,\"text\":otherChoice.otherChoiceText,\"otherValue\": otherChoice.value]\n-            } else {\n-                otherChoiceDict = [\"other\": otherChoice.otherTitle,\"otherValue\": otherChoice.value]\n-            }\n-            choices.append(otherChoiceDict  as  Any)\n-            choices.append(otherChoice.value)\n-        }\n-        \n-        if self.answerFormat?.style == .multipleChoice {\n-            choiceResult.questionType = .multipleChoice\n-        } else {\n-            choiceResult.questionType = .singleChoice\n-        }\n-        \n-        choiceResult.choiceAnswers = choices\n-        orkResult?.results = [choiceResult]\n-        return orkResult\n-        \n-    }\n-    \n-    \n-    /// Data sources\n-    lazy var textChoices: [ORKTextChoice]! = []\n-    lazy private(set) var selectedChoices: [ORKTextChoice] = []\n-    lazy var searchChoices: [ORKTextChoice] = []\n-    lazy var answers: [String]? = []\n-    \n-    private(set) var isOtherCellSelected = false\n-    \n-    //MARK:- UI\n-    \n-    /// Search bar\n-    private var searchBar: UISearchBar?\n-    \n-    /// Default font for question\n-    private let questionFont: UIFont = UIFont.boldSystemFont(ofSize: 25)\n-    \n-    /// Height used for search bar\n-    private let searchBarHeight: CGFloat = 44\n-    \n-    /// Returns wheather search bar is in editing mode\n-    lazy private var isSearching = false\n-    \n-    lazy var otherChoice = OtherChoice()\n-    \n-    var isShowSearchBar: Bool {\n-        if self.otherChoice.isShowOtherCell {\n-            return self.textChoices.count > 5\n-        } else {\n-            return self.textChoices.count > 6\n-        }\n+\n+  ///  Table View ref from the Super class\n+  var tableView: UITableView?\n+\n+  /// Current step\n+  var questionStep: QuestionStep?\n+\n+  /// Continue button ref from the Super class\n+  private var continueBtn: UIButton?\n+\n+  var answerFormat: ORKTextChoiceAnswerFormat? {\n+    return questionStep?.answerFormat as? ORKTextChoiceAnswerFormat\n+  }\n+\n+  override var result: ORKStepResult? {\n+\n+    let orkResult = super.result\n+\n+    guard let identifier = step?.identifier else { return nil }\n+    let choiceResult = ORKChoiceQuestionResult(identifier: identifier)\n+\n+    var choices: [Any] = []\n+\n+    for choice in self.selectedChoices {\n+      choices.append(choice.value)\n     }\n-    \n-    // Contructors\n-    override init(step: ORKStep?) {\n-        super.init(step: step)\n-    }\n-    \n-    override init(step: ORKStep, result: ORKResult) {\n-        super.init(step: step, result: result)\n-        \n-        if let stepResult = (result as? ORKStepResult),\n-            let choiceResult = stepResult.result(forIdentifier: step.identifier) as? ORKChoiceQuestionResult,\n-            let choices = choiceResult.choiceAnswers {\n-            \n-            for choice in choices {\n-                \n-                if let choice = choice as? String {\n-                    self.answers?.append(choice)\n-                } else if let choiceDict = choice as? JSONDictionary, let otherChoice = choiceDict[\"text\"] as? String {\n-                    self.answers?.append(otherChoice)\n-                }\n-            }\n-            \n-        }\n+\n+    if self.isOtherCellSelected {\n+      var otherChoiceDict: [String: Any]!\n+      if self.otherChoice.isShowOtherField {\n+        otherChoiceDict = [\n+          \"other\": otherChoice.otherTitle, \"text\": otherChoice.otherChoiceText,\n+          \"otherValue\": otherChoice.value\n+        ]\n+      } else {\n+        otherChoiceDict = [\"other\": otherChoice.otherTitle, \"otherValue\": otherChoice.value]\n+      }\n+      choices.append(otherChoiceDict as Any)\n+      choices.append(otherChoice.value)\n     }\n-    \n-    \n-    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {\n-        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n-    }\n-    \n-    required init?(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-    }\n-    \n-    func initData(otherChoice: OtherChoice) {\n-        self.otherChoice = otherChoice\n-    }\n-    \n-    // MARK:- Lifycycle\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        stepDidChange()\n-    }\n-    \n-    override func viewDidAppear(_ animated: Bool) {\n-        super.viewDidAppear(animated)\n-        \n-        self.tableView?.tableHeaderView = headerViewForAdditionalText()\n-        \n-        if self.answerFormat?.style == .multipleChoice {\n-            self.tableView?.allowsMultipleSelection = true\n-        } else {\n-            self.tableView?.allowsMultipleSelection = false\n+\n+    if self.answerFormat?.style == .multipleChoice {\n+      choiceResult.questionType = .multipleChoice\n+    } else {\n+      choiceResult.questionType = .singleChoice\n+    }\n+\n+    choiceResult.choiceAnswers = choices\n+    orkResult?.results = [choiceResult]\n+    return orkResult\n+\n+  }\n+\n+  /// Data sources\n+  lazy var textChoices: [ORKTextChoice]! = []\n+\n+  lazy private(set) var selectedChoices: [ORKTextChoice] = []\n+  lazy var searchChoices: [ORKTextChoice] = []\n+  lazy var answers: [String]? = []\n+\n+  private(set) var isOtherCellSelected = false\n+\n+  // MARK: - UI\n+\n+  /// Search bar\n+  private var searchBar: UISearchBar?\n+\n+  /// Default font for question\n+  private let questionFont: UIFont = UIFont.boldSystemFont(ofSize: 25)\n+\n+  /// Height used for search bar\n+  private let searchBarHeight: CGFloat = 44\n+\n+  /// Returns wheather search bar is in editing mode\n+  lazy private var isSearching = false\n+\n+  lazy var otherChoice = OtherChoice()\n+\n+  var isShowSearchBar: Bool {\n+    if self.otherChoice.isShowOtherCell {\n+      return self.textChoices.count > 5\n+    } else {\n+      return self.textChoices.count > 6\n+    }\n+  }\n+\n+  // Initializers\n+  override init(step: ORKStep?) {\n+    super.init(step: step)\n+  }\n+\n+  override init(step: ORKStep, result: ORKResult) {\n+    super.init(step: step, result: result)\n+\n+    if let stepResult = (result as? ORKStepResult),\n+      let choiceResult = stepResult.result(forIdentifier: step.identifier)\n+      as? ORKChoiceQuestionResult,\n+      let choices = choiceResult.choiceAnswers {\n+\n+      for choice in choices {\n+\n+        if let choice = choice as? String {\n+          self.answers?.append(choice)\n+        } else if let choiceDict = choice as? JSONDictionary,\n+          let otherChoice = choiceDict[\"text\"] as? String {\n+          self.answers?.append(otherChoice)\n         }\n-        \n-        tableView?.isHidden = false\n+      }\n+\n+    }\n+  }\n+\n+  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {\n+    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n+  }\n+\n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  func initData(otherChoice: OtherChoice) {\n+    self.otherChoice = otherChoice\n+  }\n+\n+  // MARK: - Lifycycle\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    stepDidChange()\n+  }\n+\n+  override func viewDidAppear(_ animated: Bool) {\n+    super.viewDidAppear(animated)\n+\n+    self.tableView?.tableHeaderView = headerViewForAdditionalText()\n+\n+    if self.answerFormat?.style == .multipleChoice {\n+      self.tableView?.allowsMultipleSelection = true\n+    } else {\n+      self.tableView?.allowsMultipleSelection = false\n+    }\n+\n+    tableView?.isHidden = false\n+    self.tableView?.reloadData()\n+    self.updateNextOrContinueBtnState()\n+\n+  }\n+\n+  /// Ready the view\n+  private func stepDidChange() {\n+\n+    guard let step = self.step as? QuestionStep, isViewLoaded else {\n+      return\n+    }\n+    self.questionStep = step\n+    self.textChoices = answerFormat?.textChoices ?? []\n+\n+    self.otherChoice = step.otherChoice\n+\n+    if let indexOfOtherChoiceValue = self.answers?.firstIndex(of: self.otherChoice.value) {\n+      self.answers?.remove(at: indexOfOtherChoiceValue)\n+    }\n+    /// Update the selected result here\n+    if let answers = self.answers {\n+      for answer in answers {\n+        if let selectedChoice = self.textChoices.filter({ $0.value as! String == answer })\n+          .first {\n+          self.selectedChoices.append(selectedChoice)\n+        } else {  // unable to find the answer in textchoices, perhaps other choice was selected\n+          self.isOtherCellSelected = true\n+          self.otherChoice.otherChoiceText = answer\n+        }\n+      }\n+      self.answers = nil\n+    }\n+\n+    // Get the ref of the super class table view\n+    if let tableView = self.view.allSubViewsOf(type: UITableView.self).first {\n+      self.tableView = tableView\n+      tableView.registerCell(cell: TextChoiceCell.self)\n+      tableView.registerCell(cell: OtherTextChoiceCell.self)\n+      tableView.isHidden = true\n+    }\n+\n+    if self.isShowSearchBar {\n+      self.searchBar = UISearchBar()\n+      searchBar?.delegate = self\n+    }\n+\n+    // Try to get the ref of the continue of the next button\n+    if let nextBtn = self.view.allSubViewsOf(type: ORKContinueButton.self).last {\n+      self.continueBtn = nextBtn\n+      continueBtn?.addTarget(\n+        self, action: #selector(didTapOnDoneOrNextBtn), for: .touchUpInside)\n+    } else {\n+      fatalError(\"Couldn't able to find continue Button\")\n+    }\n+  }\n+\n+  // MARK: - UI\n+\n+  /// Header View of the question displayed in the Table View section.\n+  private func getQuestionHeaderView() -> UIView {\n+    let newHeaderView = UIView()\n+    let questionLbl = UILabel()\n+\n+    UI:do {\n+      questionLbl.font = questionFont\n+      questionLbl.text = self.questionStep?.question\n+      questionLbl.textColor = .black\n+      questionLbl.textAlignment = .left\n+      questionLbl.numberOfLines = 0\n+      newHeaderView.backgroundColor = .white\n+      newHeaderView.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]\n+      newHeaderView.layer.cornerRadius = 10\n+      newHeaderView.clipsToBounds = true\n+    }\n+\n+    layout:do {\n+\n+      newHeaderView.addSubview(questionLbl)\n+      questionLbl.translatesAutoresizingMaskIntoConstraints = false\n+\n+      NSLayoutConstraint.activate(\n+        [\n+          questionLbl.topAnchor.constraint(\n+            equalTo: newHeaderView.topAnchor, constant: 12),\n+          questionLbl.leadingAnchor.constraint(\n+            equalTo: newHeaderView.leadingAnchor, constant: 12),\n+          questionLbl.trailingAnchor.constraint(\n+            equalTo: newHeaderView.trailingAnchor, constant: -12)\n+        ])\n+\n+      newHeaderView.sizeToFit()\n+    }\n+\n+    if isShowSearchBar {\n+      addSearchBar(on: newHeaderView, below: questionLbl)\n+    }\n+\n+    return newHeaderView\n+  }\n+\n+  /// Table Header View\n+  private func headerViewForAdditionalText() -> UIView? {\n+\n+    guard let text = self.questionStep?.text, let tableView = self.tableView else { return nil }\n+\n+    let headerView = UIView(frame: CGRect(x: 0, y: 0, width: tableView.frame.width, height: 60))\n+\n+    let textLabel = UILabel()\n+    textLabel.text = text\n+    textLabel.textAlignment = .left\n+    textLabel.numberOfLines = 2\n+    textLabel.font = UIFont.systemFont(ofSize: 17)\n+    textLabel.backgroundColor = UIColor.clear\n+    textLabel.textColor = UIColor.black\n+\n+    headerView.addSubview(textLabel)\n+\n+    textLabel.translatesAutoresizingMaskIntoConstraints = false\n+\n+    NSLayoutConstraint.activate(\n+      [\n+        textLabel.leftAnchor.constraint(equalTo: headerView.leftAnchor, constant: 8),\n+        textLabel.rightAnchor.constraint(equalTo: headerView.rightAnchor, constant: -16),\n+        textLabel.centerYAnchor.constraint(equalTo: headerView.centerYAnchor)\n+      ])\n+\n+    return headerView\n+\n+  }\n+\n+  private func addSearchBar(on newHeaderView: UIView, below questionLbl: UILabel) {\n+\n+    guard let searchBar = self.searchBar else { return }\n+\n+    searchBar.frame = CGRect()\n+    searchBar.searchBarStyle = UISearchBar.Style.minimal\n+    searchBar.placeholder = \" Search\"\n+    searchBar.sizeToFit()\n+    searchBar.showsCancelButton = false\n+    searchBar.returnKeyType = .done\n+    searchBar.enablesReturnKeyAutomatically = false\n+\n+    layout:do {\n+\n+      newHeaderView.addSubview(searchBar)\n+      searchBar.translatesAutoresizingMaskIntoConstraints = false\n+\n+      NSLayoutConstraint.activate(\n+        [\n+          searchBar.trailingAnchor.constraint(\n+            equalTo: newHeaderView.trailingAnchor, constant: -5),\n+          searchBar.leadingAnchor.constraint(\n+            equalTo: newHeaderView.leadingAnchor, constant: 5),\n+          searchBar.topAnchor.constraint(equalTo: questionLbl.bottomAnchor, constant: 10),\n+          searchBar.bottomAnchor.constraint(\n+            lessThanOrEqualTo: newHeaderView.bottomAnchor, constant: -12),\n+          searchBar.heightAnchor.constraint(equalToConstant: self.searchBarHeight)\n+        ])\n+    }\n+\n+  }\n+\n+  // MARK: - Utils\n+\n+  /// Inform if it's last cell of tableView, Other option cell.\n+  ///\n+  /// - Parameter indexPath: Indexpath of the tableView cell to check.\n+  /// - Returns: A Bool value indicating if it's Other cell indexPath or not.\n+  private func isLastCell(indexPath: IndexPath) -> Bool {\n+    if (indexPath.row == self.textChoices.count && !isSearching) || (\n+      indexPath.row == self.searchChoices.count && isSearching\n+    ) {\n+      return true\n+    } else {\n+      return false\n+    }\n+  }\n+\n+  /// Updates the SelectedChoices collection from options on tableView .\n+  ///\n+  /// - Parameter choice: Choice of the option selected by user.\n+  /// - Parameter isSelected: This indicate wheather to add choice or remove.\n+  private func updateSelectedChoice(choice: ORKTextChoice?, didSelected: Bool) {\n+\n+    func updateForSingleSelection() {\n+      self.selectedChoices.removeAll()\n+      guard choice != nil else { return }  // mil for OtherCell selection, remove all the choices selected\n+      self.selectedChoices.append(choice!)\n+    }\n+\n+    @discardableResult\n+    func removeOtherChoiceIfExclusive() -> Bool {\n+      if (self.otherChoice.isExclusive && self.isOtherCellSelected) || (\n+        choice?.exclusive ?? false && isOtherCellSelected\n+      ) {\n+        self.isOtherCellSelected = false\n         self.tableView?.reloadData()\n-        self.updateNextOrContinueBtnState()\n-        \n-    }\n-    \n-    \n-    /// Ready the view\n-    func stepDidChange() {\n-        \n-        guard let step = self.step as? QuestionStep, isViewLoaded else {\n-            return\n-        }\n-        self.questionStep = step\n-        self.textChoices = answerFormat?.textChoices ?? []\n-        \n-        self.otherChoice = step.otherChoice\n-        \n-        if let indexOfOtherChoiceValue = self.answers?.firstIndex(of: self.otherChoice.value) {\n-            self.answers?.remove(at: indexOfOtherChoiceValue)\n-        }\n-        /// Update the selected result here\n-        if let answers = self.answers {\n-            for answer in answers {\n-                if let selectedChoice = self.textChoices.filter({$0.value as! String == answer}).first {\n-                    self.selectedChoices.append(selectedChoice)\n-                } else { // unable to find the answer in textchoices, perhaps other choice was selected\n-                    self.isOtherCellSelected = true\n-                    self.otherChoice.otherChoiceText = answer\n-                }\n-            }\n-            self.answers = nil\n-        }\n-        \n-        print(self.result as Any,\"Result\")\n-        \n-        // Get the ref of the super class table view\n-        if let tableView = self.view.allSubViewsOf(type: UITableView.self).first {\n-            self.tableView = tableView\n-            tableView.registerCell(cell: TextChoiceCell.self)\n-            tableView.registerCell(cell: OtherTextChoiceCell.self)\n-            tableView.isHidden = true\n-        }\n-        \n-        if self.isShowSearchBar {\n-            self.searchBar = UISearchBar()\n-            searchBar?.delegate = self\n-        }\n-        \n-        // Try to get the ref of the continue of the next button\n-        if let nextBtn = self.view.allSubViewsOf(type: ORKContinueButton.self).last {\n-            self.continueBtn = nextBtn\n-            continueBtn?.addTarget(self, action: #selector(didTapOnDoneOrNextBtn), for: .touchUpInside)\n-        } else {\n-            fatalError(\"Couldn't able to find continue Button\")\n-        }\n+        return true\n+      }\n+      return false\n     }\n-    \n-    //MARK:- UI\n-    \n-    private func getQuestionHeaderView() -> UIView {\n-        let newHeaderView = UIView()\n-        let questionLbl = UILabel()\n-        \n-        UI: do {\n-            questionLbl.font = questionFont\n-            questionLbl.text = self.questionStep?.question\n-            questionLbl.textColor = .black\n-            questionLbl.textAlignment = .left\n-            questionLbl.numberOfLines = 0\n-            newHeaderView.backgroundColor = .white\n-            newHeaderView.layer.maskedCorners = [.layerMinXMinYCorner,.layerMaxXMinYCorner]\n-            newHeaderView.layer.cornerRadius = 10\n-            newHeaderView.clipsToBounds = true\n-        }\n-        \n-        layout: do {\n-            \n-            newHeaderView.addSubview(questionLbl)\n-            questionLbl.translatesAutoresizingMaskIntoConstraints = false\n-            \n-            NSLayoutConstraint.activate([\n-                questionLbl.topAnchor.constraint(equalTo: newHeaderView.topAnchor, constant: 12),\n-                questionLbl.leadingAnchor.constraint(equalTo: newHeaderView.leadingAnchor, constant: 12),\n-                questionLbl.trailingAnchor.constraint(equalTo: newHeaderView.trailingAnchor, constant: -12)\n-                ])\n-            \n-            newHeaderView.sizeToFit()\n-        }\n-        \n-        if isShowSearchBar {\n-            addSearchBar(on: newHeaderView, below: questionLbl)\n-        }\n-        \n-        return newHeaderView\n-    }\n-    \n-    private func headerViewForAdditionalText() -> UIView? {\n-        \n-        guard let text = self.questionStep?.text,let tableView = self.tableView else {return nil}\n-        \n-        let headerView = UIView(frame: CGRect(x: 0, y: 0, width: tableView.frame.width, height: 60))\n-        \n-        let textLabel = UILabel()\n-        textLabel.text = text\n-        textLabel.textAlignment = .left\n-        textLabel.numberOfLines = 2\n-        textLabel.font = UIFont.systemFont(ofSize: 17)\n-        textLabel.backgroundColor = UIColor.clear\n-        textLabel.textColor = UIColor.black\n-        \n-        headerView.addSubview(textLabel)\n-        \n-        textLabel.translatesAutoresizingMaskIntoConstraints = false\n-        \n-        NSLayoutConstraint.activate([\n-            textLabel.leftAnchor.constraint(equalTo: headerView.leftAnchor, constant: 8),\n-            textLabel.rightAnchor.constraint(equalTo: headerView.rightAnchor, constant: -16),\n-            textLabel.centerYAnchor.constraint(equalTo: headerView.centerYAnchor)\n-            ])\n-        \n-        return headerView\n-        \n-    }\n-    \n-    private func addSearchBar(on newHeaderView: UIView, below questionLbl: UILabel) {\n-        \n-        guard let searchBar = self.searchBar else {return}\n-        \n-        searchBar.frame = CGRect()\n-        searchBar.searchBarStyle = UISearchBar.Style.minimal\n-        searchBar.placeholder = \" Search\"\n-        searchBar.sizeToFit()\n-        searchBar.showsCancelButton = false\n-        searchBar.returnKeyType = .done\n-        searchBar.enablesReturnKeyAutomatically = false\n-        \n-        layout: do {\n-            \n-            newHeaderView.addSubview(searchBar)\n-            searchBar.translatesAutoresizingMaskIntoConstraints = false\n-            \n-            NSLayoutConstraint.activate([\n-                searchBar.trailingAnchor.constraint(equalTo: newHeaderView.trailingAnchor, constant: -5),\n-                searchBar.leadingAnchor.constraint(equalTo: newHeaderView.leadingAnchor, constant: 5),\n-                searchBar.topAnchor.constraint(equalTo: questionLbl.bottomAnchor, constant: 10),\n-                searchBar.bottomAnchor.constraint(lessThanOrEqualTo: newHeaderView.bottomAnchor, constant: -12),\n-                searchBar.heightAnchor.constraint(equalToConstant: self.searchBarHeight)\n-                ])\n-        }\n-        \n-    }\n-    \n-    //MARK:- Utils\n-    \n-    /**\n-     Inform if it's last cell of tableView, Other option cell.\n-     \n-     - Parameter indexPath: Indexpath of the tableView cell to check.\n-     \n-     - Returns: A Bool value indicating if it's Other cell indexPath or not.\n-     */\n-    private func isLastCell(indexPath: IndexPath) -> Bool {\n-        if (indexPath.row == self.textChoices.count && !isSearching) ||\n-            (indexPath.row == self.searchChoices.count && isSearching) {\n-            return true\n-        } else {\n-            return false\n-        }\n+\n+    func removeSelectedExclusiveChoices() {\n+      let exclusiveSelectedChoices = self.selectedChoices.filter({ $0.exclusive == true })\n+      if exclusiveSelectedChoices.count > 0 {\n+        updateForSingleSelection()\n+        self.tableView?.reloadData()\n+      }\n     }\n-    \n-    /**\n-     Updates the SelectedChoices collection from options on tableView .\n-     \n-     - Parameter choice: Choice of the option selected by user.\n-     - Parameter isSelected: This indicate wheather to add choice or remove\n-     \n-     */\n-    private func updateSelectedChoice(choice: ORKTextChoice?, didSelected: Bool) {\n-        \n-        func updateForSingleSelection() {\n-            self.selectedChoices.removeAll()\n-            guard choice != nil else {return} // mil for OtherCell selection, remove all the choices selected\n-            self.selectedChoices.append(choice!)\n-        }\n-        \n-        @discardableResult\n-        func removeOtherChoiceIfExclusive() -> Bool{\n-            if (self.otherChoice.isExclusive && self.isOtherCellSelected) ||\n-                (choice?.exclusive ?? false && isOtherCellSelected ){\n-                self.isOtherCellSelected = false\n-                self.tableView?.reloadData()\n-                return true\n-            }\n-            return false\n-        }\n-        \n-        func removeSelectedExclusiveChoices() {\n-            let exclusiveSelectedChoices = self.selectedChoices.filter({$0.exclusive == true})\n-            if exclusiveSelectedChoices.count > 0 {\n-                updateForSingleSelection()\n-                self.tableView?.reloadData()\n-            }\n+\n+    func updateForMultipleSelection() {\n+\n+      guard let choice = choice else {  // Other choice\n+        if self.otherChoice.isExclusive {\n+          self.selectedChoices.removeAll()\n         }\n-        \n-        func updateForMultipleSelection() {\n-            \n-            guard let choice = choice else { // Other choice\n-                if self.otherChoice.isExclusive {\n-                    self.selectedChoices.removeAll()\n-                }\n-                removeSelectedExclusiveChoices()\n-                return\n-            }\n-            \n-            if choice.exclusive {\n-                if didSelected {\n-                    updateForSingleSelection() // Make it behave like single selection\n-                    if !removeOtherChoiceIfExclusive() {\n-                        self.tableView?.reloadData()\n-                    }\n-                    return\n-                }\n-            } else {\n-                removeSelectedExclusiveChoices()\n-                removeOtherChoiceIfExclusive()\n-            }\n-            \n-            if let choiceIndex = self.selectedChoices.firstIndex(of: choice) {\n-                if !(didSelected) {\n-                    self.selectedChoices.remove(at: choiceIndex)\n-                }\n-            } else if didSelected {\n-                self.selectedChoices.append(choice)\n-            }\n+        removeSelectedExclusiveChoices()\n+        return\n+      }\n+\n+      if choice.exclusive {\n+        if didSelected {\n+          updateForSingleSelection()  // Make it behave like single selection\n+          if !removeOtherChoiceIfExclusive() {\n+            self.tableView?.reloadData()\n+          }\n+          return\n         }\n-        \n-        guard self.tableView != nil else {return}\n-        \n-        switch self.tableView!.allowsMultipleSelection {\n-            \n-        case true:\n-            updateForMultipleSelection()\n-            \n-        case false:\n-            updateForSingleSelection()\n-            \n+      } else {\n+        removeSelectedExclusiveChoices()\n+        removeOtherChoiceIfExclusive()\n+      }\n+\n+      if let choiceIndex = self.selectedChoices.firstIndex(of: choice) {\n+        if !(didSelected) {\n+          self.selectedChoices.remove(at: choiceIndex)\n         }\n-        \n+      } else if didSelected {\n+        self.selectedChoices.append(choice)\n+      }\n     }\n-    \n-    private func isChoiceSelected(choice: ORKTextChoice) -> Bool {\n-        if self.selectedChoices.firstIndex(of: choice) != nil {\n-            return true\n-        }\n-        return false\n-    }\n-    \n-    override func goBackward() {\n-        //super.delegate?.stepViewControllerResultDidChange(self)\n-        print(\"User did pressed on back button\")\n-        super.goBackward()\n-        \n-    }\n-    \n-    override func goForward() {\n-        //super.delegate?.stepViewControllerResultDidChange(self)\n-        \n-        if self.otherChoice.isMandatory, self.otherChoice.otherChoiceText == \"\" || self.otherChoice.otherChoiceText == \" \",self.isOtherCellSelected {\n-            \n-            let alertVC = UIAlertController(title: \"Answer required\", message: \"Please provide an input for the text field too.\", preferredStyle: .alert)\n-            \n-            let okAction = UIAlertAction(title: \"Ok\", style: .default) { [unowned self] (action) in\n-                alertVC.dismiss(animated: true, completion: nil)\n-                if let otherCell = self.tableView?.cellForRow(at: IndexPath(row: self.textChoices.count, section: 0)) as? OtherTextChoiceCell {\n-                    otherCell.otherField.becomeFirstResponder()\n-                }\n-                self.updateNextOrContinueBtnState()\n-            }\n-            \n-            \n-            alertVC.addAction(okAction)\n-            self.present(alertVC, animated: true, completion: nil)\n-            \n-            updateNextOrContinueBtnState()\n-        } else {\n-            super.goForward()\n-        }\n-        \n-    }\n-    \n-    \n-    \n-    @objc func didTapOnDoneOrNextBtn(_ sender: UIButton ) {\n-        print(\"next or done button pressed\")\n-    }\n-    \n-    \n-    \n-    private func didTapOnOtherCell(didSelect: Bool) {\n-        \n-        if didSelect {\n-            \n-            self.isOtherCellSelected = true\n-            updateSelectedChoice(choice: nil, didSelected: true)\n-            self.tableView?.reloadData()\n-            \n-            if isSearching {\n-                view.endEditing(true) // Will be handled in search bar end editing delegate\n-            } else {\n-                let otherCellIndex = IndexPath(row: self.textChoices.count, section: 0)\n-                let cell = self.tableView?.cellForRow(at: otherCellIndex) as? OtherTextChoiceCell\n-                if self.otherChoice.isShowOtherField, cell?.otherField.text == \"\" {\n-                    cell?.otherField.becomeFirstResponder()\n-                }\n-            }\n-            \n-        } else {\n-            self.isOtherCellSelected = false\n-            self.tableView?.reloadData()\n-        }\n-        \n-    }\n-    \n-    private func updateNextOrContinueBtnState() {\n-        \n-        if self.selectedChoices.count > 0 || self.isOtherCellSelected {\n-            self.continueBtn?.isEnabled = true\n-            self.continueBtn?.isUserInteractionEnabled = true\n-        } else {\n-            self.continueBtn?.isEnabled = false\n-            self.continueBtn?.isUserInteractionEnabled = false\n+\n+    guard self.tableView != nil else { return }\n+\n+    switch self.tableView!.allowsMultipleSelection {\n+\n+    case true:\n+      updateForMultipleSelection()\n+\n+    case false:\n+      updateForSingleSelection()\n+\n+    }\n+\n+  }\n+\n+  private func isChoiceSelected(choice: ORKTextChoice) -> Bool {\n+    if self.selectedChoices.firstIndex(of: choice) != nil {\n+      return true\n+    }\n+    return false\n+  }\n+\n+  override func goBackward() {\n+    //super.delegate?.stepViewControllerResultDidChange(self)\n+    Logger.sharedInstance.info(\"\\(self) User did pressed on back button\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1001}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4NjUwNg==", "bodyText": "same here", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391786506", "createdAt": "2020-03-12T17:41:03Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ActivityUI/QuestionStepController/TextChoiceQuestionController.swift", "diffHunk": "@@ -1,733 +1,776 @@\n-//\n-//  TextChoiceQuestionController.swift\n-//  Survey-Demo\n-//\n-//  Created by Tushar on 3/20/19.\n-//  Copyright \u00a9 2019 Tushar. All rights reserved.\n-//\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n+\n import UIKit\n import ResearchKit\n \n+/// A value type whose instances will have Other Choice configuration in TextChoiceQuestionStep .\n struct OtherChoice {\n-    \n-    let isShowOtherCell: Bool\n-    let isShowOtherField: Bool\n-    let otherTitle: String\n-    let placeholder: String\n-    let isMandatory: Bool\n-    let detailText: String\n-    lazy var otherChoiceText = \"\"\n-    let isExclusive: Bool\n-    let value: String\n-    \n-    init(isShowOtherCell: Bool = false, isShowOtherField: Bool = true, otherTitle: String = \"Other\", placeholder: String = \"enter here\",isMandatory: Bool = true,isExclusive: Bool = false, detailText: String = \"\", value: String = \"\") {\n-        self.isShowOtherField = isShowOtherField\n-        self.otherTitle = otherTitle\n-        self.placeholder = placeholder\n-        self.isMandatory = isMandatory\n-        self.isShowOtherCell = isShowOtherCell\n-        self.isExclusive = isExclusive\n-        self.detailText = detailText\n-        self.value = value\n-    }\n+\n+  /// A Boolean value indicating other choice availablity.\n+  let isShowOtherCell: Bool\n+\n+  /// A Boolean value indicating other choice TextField availablity.\n+  let isShowOtherField: Bool\n+\n+  /// Text Choice title.\n+  let otherTitle: String\n+\n+  /// Text Choice field placeholder.\n+  let placeholder: String\n+\n+  /// A Boolean value indicating choice selection is mandatory.\n+  let isMandatory: Bool\n+\n+  /// Details text of the choice.\n+  let detailText: String\n+\n+  lazy var otherChoiceText = \"\"\n+  let isExclusive: Bool\n+  let value: String\n+\n+  init(\n+    isShowOtherCell: Bool = false, isShowOtherField: Bool = true, otherTitle: String = \"Other\",\n+    placeholder: String = \"enter here\", isMandatory: Bool = true, isExclusive: Bool = false,\n+    detailText: String = \"\", value: String = \"\"\n+  ) {\n+    self.isShowOtherField = isShowOtherField\n+    self.otherTitle = otherTitle\n+    self.placeholder = placeholder\n+    self.isMandatory = isMandatory\n+    self.isShowOtherCell = isShowOtherCell\n+    self.isExclusive = isExclusive\n+    self.detailText = detailText\n+    self.value = value\n+  }\n }\n \n+/// Subclass of `ORKQuestionStep` which includes the configuration of `OtherChoice`.\n class QuestionStep: ORKQuestionStep {\n-    \n-    lazy var otherChoice = OtherChoice()\n-    \n-    init(identifier: String, title: String?, question: String, answer: ORKAnswerFormat,otherChoice: OtherChoice) {\n-        super.init(identifier: identifier)\n-        self.title = title\n-        self.question = question\n-        self.answerFormat = answer\n-        self.otherChoice = otherChoice\n-    }\n-    \n-    required init(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-        fatalError(\"init(coder:) has not been implemented\")\n-    }\n-    \n+\n+  /// Instance of `OtherChoice` configuration.\n+  lazy var otherChoice = OtherChoice()\n+\n+  init(\n+    identifier: String, title: String?, question: String, answer: ORKAnswerFormat,\n+    otherChoice: OtherChoice\n+  ) {\n+    super.init(identifier: identifier)\n+    self.title = title\n+    self.question = question\n+    self.answerFormat = answer\n+    self.otherChoice = otherChoice\n+  }\n+\n+  required init(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+    fatalError(\"init(coder:) has not been implemented\")\n+  }\n+\n }\n \n class TextChoiceQuestionController: ORKQuestionStepViewController {\n-    \n-    \n-    ///  Table View ref from the Super class\n-    var tableView: UITableView?\n-    \n-    /// Current step\n-    var questionStep: QuestionStep?\n-    \n-    /// Continue button ref from the Super class\n-    private var continueBtn: UIButton?\n-    \n-    var answerFormat: ORKTextChoiceAnswerFormat? {\n-        return questionStep?.answerFormat as? ORKTextChoiceAnswerFormat\n-    }\n-    \n-    override var result: ORKStepResult? {\n-        \n-        let orkResult = super.result\n-        \n-        guard let identifier = step?.identifier else {return nil}\n-        let choiceResult = ORKChoiceQuestionResult(identifier: identifier)\n-        \n-        var choices: [Any] = []\n-        \n-        for choice in self.selectedChoices {\n-            choices.append(choice.value)\n-        }\n-        \n-        if self.isOtherCellSelected {\n-            var otherChoiceDict: [String:Any]!\n-            if self.otherChoice.isShowOtherField {\n-                otherChoiceDict = [\"other\": otherChoice.otherTitle,\"text\":otherChoice.otherChoiceText,\"otherValue\": otherChoice.value]\n-            } else {\n-                otherChoiceDict = [\"other\": otherChoice.otherTitle,\"otherValue\": otherChoice.value]\n-            }\n-            choices.append(otherChoiceDict  as  Any)\n-            choices.append(otherChoice.value)\n-        }\n-        \n-        if self.answerFormat?.style == .multipleChoice {\n-            choiceResult.questionType = .multipleChoice\n-        } else {\n-            choiceResult.questionType = .singleChoice\n-        }\n-        \n-        choiceResult.choiceAnswers = choices\n-        orkResult?.results = [choiceResult]\n-        return orkResult\n-        \n-    }\n-    \n-    \n-    /// Data sources\n-    lazy var textChoices: [ORKTextChoice]! = []\n-    lazy private(set) var selectedChoices: [ORKTextChoice] = []\n-    lazy var searchChoices: [ORKTextChoice] = []\n-    lazy var answers: [String]? = []\n-    \n-    private(set) var isOtherCellSelected = false\n-    \n-    //MARK:- UI\n-    \n-    /// Search bar\n-    private var searchBar: UISearchBar?\n-    \n-    /// Default font for question\n-    private let questionFont: UIFont = UIFont.boldSystemFont(ofSize: 25)\n-    \n-    /// Height used for search bar\n-    private let searchBarHeight: CGFloat = 44\n-    \n-    /// Returns wheather search bar is in editing mode\n-    lazy private var isSearching = false\n-    \n-    lazy var otherChoice = OtherChoice()\n-    \n-    var isShowSearchBar: Bool {\n-        if self.otherChoice.isShowOtherCell {\n-            return self.textChoices.count > 5\n-        } else {\n-            return self.textChoices.count > 6\n-        }\n+\n+  ///  Table View ref from the Super class\n+  var tableView: UITableView?\n+\n+  /// Current step\n+  var questionStep: QuestionStep?\n+\n+  /// Continue button ref from the Super class\n+  private var continueBtn: UIButton?\n+\n+  var answerFormat: ORKTextChoiceAnswerFormat? {\n+    return questionStep?.answerFormat as? ORKTextChoiceAnswerFormat\n+  }\n+\n+  override var result: ORKStepResult? {\n+\n+    let orkResult = super.result\n+\n+    guard let identifier = step?.identifier else { return nil }\n+    let choiceResult = ORKChoiceQuestionResult(identifier: identifier)\n+\n+    var choices: [Any] = []\n+\n+    for choice in self.selectedChoices {\n+      choices.append(choice.value)\n     }\n-    \n-    // Contructors\n-    override init(step: ORKStep?) {\n-        super.init(step: step)\n-    }\n-    \n-    override init(step: ORKStep, result: ORKResult) {\n-        super.init(step: step, result: result)\n-        \n-        if let stepResult = (result as? ORKStepResult),\n-            let choiceResult = stepResult.result(forIdentifier: step.identifier) as? ORKChoiceQuestionResult,\n-            let choices = choiceResult.choiceAnswers {\n-            \n-            for choice in choices {\n-                \n-                if let choice = choice as? String {\n-                    self.answers?.append(choice)\n-                } else if let choiceDict = choice as? JSONDictionary, let otherChoice = choiceDict[\"text\"] as? String {\n-                    self.answers?.append(otherChoice)\n-                }\n-            }\n-            \n-        }\n+\n+    if self.isOtherCellSelected {\n+      var otherChoiceDict: [String: Any]!\n+      if self.otherChoice.isShowOtherField {\n+        otherChoiceDict = [\n+          \"other\": otherChoice.otherTitle, \"text\": otherChoice.otherChoiceText,\n+          \"otherValue\": otherChoice.value\n+        ]\n+      } else {\n+        otherChoiceDict = [\"other\": otherChoice.otherTitle, \"otherValue\": otherChoice.value]\n+      }\n+      choices.append(otherChoiceDict as Any)\n+      choices.append(otherChoice.value)\n     }\n-    \n-    \n-    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {\n-        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n-    }\n-    \n-    required init?(coder aDecoder: NSCoder) {\n-        super.init(coder: aDecoder)\n-    }\n-    \n-    func initData(otherChoice: OtherChoice) {\n-        self.otherChoice = otherChoice\n-    }\n-    \n-    // MARK:- Lifycycle\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        stepDidChange()\n-    }\n-    \n-    override func viewDidAppear(_ animated: Bool) {\n-        super.viewDidAppear(animated)\n-        \n-        self.tableView?.tableHeaderView = headerViewForAdditionalText()\n-        \n-        if self.answerFormat?.style == .multipleChoice {\n-            self.tableView?.allowsMultipleSelection = true\n-        } else {\n-            self.tableView?.allowsMultipleSelection = false\n+\n+    if self.answerFormat?.style == .multipleChoice {\n+      choiceResult.questionType = .multipleChoice\n+    } else {\n+      choiceResult.questionType = .singleChoice\n+    }\n+\n+    choiceResult.choiceAnswers = choices\n+    orkResult?.results = [choiceResult]\n+    return orkResult\n+\n+  }\n+\n+  /// Data sources\n+  lazy var textChoices: [ORKTextChoice]! = []\n+\n+  lazy private(set) var selectedChoices: [ORKTextChoice] = []\n+  lazy var searchChoices: [ORKTextChoice] = []\n+  lazy var answers: [String]? = []\n+\n+  private(set) var isOtherCellSelected = false\n+\n+  // MARK: - UI\n+\n+  /// Search bar\n+  private var searchBar: UISearchBar?\n+\n+  /// Default font for question\n+  private let questionFont: UIFont = UIFont.boldSystemFont(ofSize: 25)\n+\n+  /// Height used for search bar\n+  private let searchBarHeight: CGFloat = 44\n+\n+  /// Returns wheather search bar is in editing mode\n+  lazy private var isSearching = false\n+\n+  lazy var otherChoice = OtherChoice()\n+\n+  var isShowSearchBar: Bool {\n+    if self.otherChoice.isShowOtherCell {\n+      return self.textChoices.count > 5\n+    } else {\n+      return self.textChoices.count > 6\n+    }\n+  }\n+\n+  // Initializers\n+  override init(step: ORKStep?) {\n+    super.init(step: step)\n+  }\n+\n+  override init(step: ORKStep, result: ORKResult) {\n+    super.init(step: step, result: result)\n+\n+    if let stepResult = (result as? ORKStepResult),\n+      let choiceResult = stepResult.result(forIdentifier: step.identifier)\n+      as? ORKChoiceQuestionResult,\n+      let choices = choiceResult.choiceAnswers {\n+\n+      for choice in choices {\n+\n+        if let choice = choice as? String {\n+          self.answers?.append(choice)\n+        } else if let choiceDict = choice as? JSONDictionary,\n+          let otherChoice = choiceDict[\"text\"] as? String {\n+          self.answers?.append(otherChoice)\n         }\n-        \n-        tableView?.isHidden = false\n+      }\n+\n+    }\n+  }\n+\n+  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {\n+    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)\n+  }\n+\n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  func initData(otherChoice: OtherChoice) {\n+    self.otherChoice = otherChoice\n+  }\n+\n+  // MARK: - Lifycycle\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    stepDidChange()\n+  }\n+\n+  override func viewDidAppear(_ animated: Bool) {\n+    super.viewDidAppear(animated)\n+\n+    self.tableView?.tableHeaderView = headerViewForAdditionalText()\n+\n+    if self.answerFormat?.style == .multipleChoice {\n+      self.tableView?.allowsMultipleSelection = true\n+    } else {\n+      self.tableView?.allowsMultipleSelection = false\n+    }\n+\n+    tableView?.isHidden = false\n+    self.tableView?.reloadData()\n+    self.updateNextOrContinueBtnState()\n+\n+  }\n+\n+  /// Ready the view\n+  private func stepDidChange() {\n+\n+    guard let step = self.step as? QuestionStep, isViewLoaded else {\n+      return\n+    }\n+    self.questionStep = step\n+    self.textChoices = answerFormat?.textChoices ?? []\n+\n+    self.otherChoice = step.otherChoice\n+\n+    if let indexOfOtherChoiceValue = self.answers?.firstIndex(of: self.otherChoice.value) {\n+      self.answers?.remove(at: indexOfOtherChoiceValue)\n+    }\n+    /// Update the selected result here\n+    if let answers = self.answers {\n+      for answer in answers {\n+        if let selectedChoice = self.textChoices.filter({ $0.value as! String == answer })\n+          .first {\n+          self.selectedChoices.append(selectedChoice)\n+        } else {  // unable to find the answer in textchoices, perhaps other choice was selected\n+          self.isOtherCellSelected = true\n+          self.otherChoice.otherChoiceText = answer\n+        }\n+      }\n+      self.answers = nil\n+    }\n+\n+    // Get the ref of the super class table view\n+    if let tableView = self.view.allSubViewsOf(type: UITableView.self).first {\n+      self.tableView = tableView\n+      tableView.registerCell(cell: TextChoiceCell.self)\n+      tableView.registerCell(cell: OtherTextChoiceCell.self)\n+      tableView.isHidden = true\n+    }\n+\n+    if self.isShowSearchBar {\n+      self.searchBar = UISearchBar()\n+      searchBar?.delegate = self\n+    }\n+\n+    // Try to get the ref of the continue of the next button\n+    if let nextBtn = self.view.allSubViewsOf(type: ORKContinueButton.self).last {\n+      self.continueBtn = nextBtn\n+      continueBtn?.addTarget(\n+        self, action: #selector(didTapOnDoneOrNextBtn), for: .touchUpInside)\n+    } else {\n+      fatalError(\"Couldn't able to find continue Button\")\n+    }\n+  }\n+\n+  // MARK: - UI\n+\n+  /// Header View of the question displayed in the Table View section.\n+  private func getQuestionHeaderView() -> UIView {\n+    let newHeaderView = UIView()\n+    let questionLbl = UILabel()\n+\n+    UI:do {\n+      questionLbl.font = questionFont\n+      questionLbl.text = self.questionStep?.question\n+      questionLbl.textColor = .black\n+      questionLbl.textAlignment = .left\n+      questionLbl.numberOfLines = 0\n+      newHeaderView.backgroundColor = .white\n+      newHeaderView.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]\n+      newHeaderView.layer.cornerRadius = 10\n+      newHeaderView.clipsToBounds = true\n+    }\n+\n+    layout:do {\n+\n+      newHeaderView.addSubview(questionLbl)\n+      questionLbl.translatesAutoresizingMaskIntoConstraints = false\n+\n+      NSLayoutConstraint.activate(\n+        [\n+          questionLbl.topAnchor.constraint(\n+            equalTo: newHeaderView.topAnchor, constant: 12),\n+          questionLbl.leadingAnchor.constraint(\n+            equalTo: newHeaderView.leadingAnchor, constant: 12),\n+          questionLbl.trailingAnchor.constraint(\n+            equalTo: newHeaderView.trailingAnchor, constant: -12)\n+        ])\n+\n+      newHeaderView.sizeToFit()\n+    }\n+\n+    if isShowSearchBar {\n+      addSearchBar(on: newHeaderView, below: questionLbl)\n+    }\n+\n+    return newHeaderView\n+  }\n+\n+  /// Table Header View\n+  private func headerViewForAdditionalText() -> UIView? {\n+\n+    guard let text = self.questionStep?.text, let tableView = self.tableView else { return nil }\n+\n+    let headerView = UIView(frame: CGRect(x: 0, y: 0, width: tableView.frame.width, height: 60))\n+\n+    let textLabel = UILabel()\n+    textLabel.text = text\n+    textLabel.textAlignment = .left\n+    textLabel.numberOfLines = 2\n+    textLabel.font = UIFont.systemFont(ofSize: 17)\n+    textLabel.backgroundColor = UIColor.clear\n+    textLabel.textColor = UIColor.black\n+\n+    headerView.addSubview(textLabel)\n+\n+    textLabel.translatesAutoresizingMaskIntoConstraints = false\n+\n+    NSLayoutConstraint.activate(\n+      [\n+        textLabel.leftAnchor.constraint(equalTo: headerView.leftAnchor, constant: 8),\n+        textLabel.rightAnchor.constraint(equalTo: headerView.rightAnchor, constant: -16),\n+        textLabel.centerYAnchor.constraint(equalTo: headerView.centerYAnchor)\n+      ])\n+\n+    return headerView\n+\n+  }\n+\n+  private func addSearchBar(on newHeaderView: UIView, below questionLbl: UILabel) {\n+\n+    guard let searchBar = self.searchBar else { return }\n+\n+    searchBar.frame = CGRect()\n+    searchBar.searchBarStyle = UISearchBar.Style.minimal\n+    searchBar.placeholder = \" Search\"\n+    searchBar.sizeToFit()\n+    searchBar.showsCancelButton = false\n+    searchBar.returnKeyType = .done\n+    searchBar.enablesReturnKeyAutomatically = false\n+\n+    layout:do {\n+\n+      newHeaderView.addSubview(searchBar)\n+      searchBar.translatesAutoresizingMaskIntoConstraints = false\n+\n+      NSLayoutConstraint.activate(\n+        [\n+          searchBar.trailingAnchor.constraint(\n+            equalTo: newHeaderView.trailingAnchor, constant: -5),\n+          searchBar.leadingAnchor.constraint(\n+            equalTo: newHeaderView.leadingAnchor, constant: 5),\n+          searchBar.topAnchor.constraint(equalTo: questionLbl.bottomAnchor, constant: 10),\n+          searchBar.bottomAnchor.constraint(\n+            lessThanOrEqualTo: newHeaderView.bottomAnchor, constant: -12),\n+          searchBar.heightAnchor.constraint(equalToConstant: self.searchBarHeight)\n+        ])\n+    }\n+\n+  }\n+\n+  // MARK: - Utils\n+\n+  /// Inform if it's last cell of tableView, Other option cell.\n+  ///\n+  /// - Parameter indexPath: Indexpath of the tableView cell to check.\n+  /// - Returns: A Bool value indicating if it's Other cell indexPath or not.\n+  private func isLastCell(indexPath: IndexPath) -> Bool {\n+    if (indexPath.row == self.textChoices.count && !isSearching) || (\n+      indexPath.row == self.searchChoices.count && isSearching\n+    ) {\n+      return true\n+    } else {\n+      return false\n+    }\n+  }\n+\n+  /// Updates the SelectedChoices collection from options on tableView .\n+  ///\n+  /// - Parameter choice: Choice of the option selected by user.\n+  /// - Parameter isSelected: This indicate wheather to add choice or remove.\n+  private func updateSelectedChoice(choice: ORKTextChoice?, didSelected: Bool) {\n+\n+    func updateForSingleSelection() {\n+      self.selectedChoices.removeAll()\n+      guard choice != nil else { return }  // mil for OtherCell selection, remove all the choices selected\n+      self.selectedChoices.append(choice!)\n+    }\n+\n+    @discardableResult\n+    func removeOtherChoiceIfExclusive() -> Bool {\n+      if (self.otherChoice.isExclusive && self.isOtherCellSelected) || (\n+        choice?.exclusive ?? false && isOtherCellSelected\n+      ) {\n+        self.isOtherCellSelected = false\n         self.tableView?.reloadData()\n-        self.updateNextOrContinueBtnState()\n-        \n-    }\n-    \n-    \n-    /// Ready the view\n-    func stepDidChange() {\n-        \n-        guard let step = self.step as? QuestionStep, isViewLoaded else {\n-            return\n-        }\n-        self.questionStep = step\n-        self.textChoices = answerFormat?.textChoices ?? []\n-        \n-        self.otherChoice = step.otherChoice\n-        \n-        if let indexOfOtherChoiceValue = self.answers?.firstIndex(of: self.otherChoice.value) {\n-            self.answers?.remove(at: indexOfOtherChoiceValue)\n-        }\n-        /// Update the selected result here\n-        if let answers = self.answers {\n-            for answer in answers {\n-                if let selectedChoice = self.textChoices.filter({$0.value as! String == answer}).first {\n-                    self.selectedChoices.append(selectedChoice)\n-                } else { // unable to find the answer in textchoices, perhaps other choice was selected\n-                    self.isOtherCellSelected = true\n-                    self.otherChoice.otherChoiceText = answer\n-                }\n-            }\n-            self.answers = nil\n-        }\n-        \n-        print(self.result as Any,\"Result\")\n-        \n-        // Get the ref of the super class table view\n-        if let tableView = self.view.allSubViewsOf(type: UITableView.self).first {\n-            self.tableView = tableView\n-            tableView.registerCell(cell: TextChoiceCell.self)\n-            tableView.registerCell(cell: OtherTextChoiceCell.self)\n-            tableView.isHidden = true\n-        }\n-        \n-        if self.isShowSearchBar {\n-            self.searchBar = UISearchBar()\n-            searchBar?.delegate = self\n-        }\n-        \n-        // Try to get the ref of the continue of the next button\n-        if let nextBtn = self.view.allSubViewsOf(type: ORKContinueButton.self).last {\n-            self.continueBtn = nextBtn\n-            continueBtn?.addTarget(self, action: #selector(didTapOnDoneOrNextBtn), for: .touchUpInside)\n-        } else {\n-            fatalError(\"Couldn't able to find continue Button\")\n-        }\n+        return true\n+      }\n+      return false\n     }\n-    \n-    //MARK:- UI\n-    \n-    private func getQuestionHeaderView() -> UIView {\n-        let newHeaderView = UIView()\n-        let questionLbl = UILabel()\n-        \n-        UI: do {\n-            questionLbl.font = questionFont\n-            questionLbl.text = self.questionStep?.question\n-            questionLbl.textColor = .black\n-            questionLbl.textAlignment = .left\n-            questionLbl.numberOfLines = 0\n-            newHeaderView.backgroundColor = .white\n-            newHeaderView.layer.maskedCorners = [.layerMinXMinYCorner,.layerMaxXMinYCorner]\n-            newHeaderView.layer.cornerRadius = 10\n-            newHeaderView.clipsToBounds = true\n-        }\n-        \n-        layout: do {\n-            \n-            newHeaderView.addSubview(questionLbl)\n-            questionLbl.translatesAutoresizingMaskIntoConstraints = false\n-            \n-            NSLayoutConstraint.activate([\n-                questionLbl.topAnchor.constraint(equalTo: newHeaderView.topAnchor, constant: 12),\n-                questionLbl.leadingAnchor.constraint(equalTo: newHeaderView.leadingAnchor, constant: 12),\n-                questionLbl.trailingAnchor.constraint(equalTo: newHeaderView.trailingAnchor, constant: -12)\n-                ])\n-            \n-            newHeaderView.sizeToFit()\n-        }\n-        \n-        if isShowSearchBar {\n-            addSearchBar(on: newHeaderView, below: questionLbl)\n-        }\n-        \n-        return newHeaderView\n-    }\n-    \n-    private func headerViewForAdditionalText() -> UIView? {\n-        \n-        guard let text = self.questionStep?.text,let tableView = self.tableView else {return nil}\n-        \n-        let headerView = UIView(frame: CGRect(x: 0, y: 0, width: tableView.frame.width, height: 60))\n-        \n-        let textLabel = UILabel()\n-        textLabel.text = text\n-        textLabel.textAlignment = .left\n-        textLabel.numberOfLines = 2\n-        textLabel.font = UIFont.systemFont(ofSize: 17)\n-        textLabel.backgroundColor = UIColor.clear\n-        textLabel.textColor = UIColor.black\n-        \n-        headerView.addSubview(textLabel)\n-        \n-        textLabel.translatesAutoresizingMaskIntoConstraints = false\n-        \n-        NSLayoutConstraint.activate([\n-            textLabel.leftAnchor.constraint(equalTo: headerView.leftAnchor, constant: 8),\n-            textLabel.rightAnchor.constraint(equalTo: headerView.rightAnchor, constant: -16),\n-            textLabel.centerYAnchor.constraint(equalTo: headerView.centerYAnchor)\n-            ])\n-        \n-        return headerView\n-        \n-    }\n-    \n-    private func addSearchBar(on newHeaderView: UIView, below questionLbl: UILabel) {\n-        \n-        guard let searchBar = self.searchBar else {return}\n-        \n-        searchBar.frame = CGRect()\n-        searchBar.searchBarStyle = UISearchBar.Style.minimal\n-        searchBar.placeholder = \" Search\"\n-        searchBar.sizeToFit()\n-        searchBar.showsCancelButton = false\n-        searchBar.returnKeyType = .done\n-        searchBar.enablesReturnKeyAutomatically = false\n-        \n-        layout: do {\n-            \n-            newHeaderView.addSubview(searchBar)\n-            searchBar.translatesAutoresizingMaskIntoConstraints = false\n-            \n-            NSLayoutConstraint.activate([\n-                searchBar.trailingAnchor.constraint(equalTo: newHeaderView.trailingAnchor, constant: -5),\n-                searchBar.leadingAnchor.constraint(equalTo: newHeaderView.leadingAnchor, constant: 5),\n-                searchBar.topAnchor.constraint(equalTo: questionLbl.bottomAnchor, constant: 10),\n-                searchBar.bottomAnchor.constraint(lessThanOrEqualTo: newHeaderView.bottomAnchor, constant: -12),\n-                searchBar.heightAnchor.constraint(equalToConstant: self.searchBarHeight)\n-                ])\n-        }\n-        \n-    }\n-    \n-    //MARK:- Utils\n-    \n-    /**\n-     Inform if it's last cell of tableView, Other option cell.\n-     \n-     - Parameter indexPath: Indexpath of the tableView cell to check.\n-     \n-     - Returns: A Bool value indicating if it's Other cell indexPath or not.\n-     */\n-    private func isLastCell(indexPath: IndexPath) -> Bool {\n-        if (indexPath.row == self.textChoices.count && !isSearching) ||\n-            (indexPath.row == self.searchChoices.count && isSearching) {\n-            return true\n-        } else {\n-            return false\n-        }\n+\n+    func removeSelectedExclusiveChoices() {\n+      let exclusiveSelectedChoices = self.selectedChoices.filter({ $0.exclusive == true })\n+      if exclusiveSelectedChoices.count > 0 {\n+        updateForSingleSelection()\n+        self.tableView?.reloadData()\n+      }\n     }\n-    \n-    /**\n-     Updates the SelectedChoices collection from options on tableView .\n-     \n-     - Parameter choice: Choice of the option selected by user.\n-     - Parameter isSelected: This indicate wheather to add choice or remove\n-     \n-     */\n-    private func updateSelectedChoice(choice: ORKTextChoice?, didSelected: Bool) {\n-        \n-        func updateForSingleSelection() {\n-            self.selectedChoices.removeAll()\n-            guard choice != nil else {return} // mil for OtherCell selection, remove all the choices selected\n-            self.selectedChoices.append(choice!)\n-        }\n-        \n-        @discardableResult\n-        func removeOtherChoiceIfExclusive() -> Bool{\n-            if (self.otherChoice.isExclusive && self.isOtherCellSelected) ||\n-                (choice?.exclusive ?? false && isOtherCellSelected ){\n-                self.isOtherCellSelected = false\n-                self.tableView?.reloadData()\n-                return true\n-            }\n-            return false\n-        }\n-        \n-        func removeSelectedExclusiveChoices() {\n-            let exclusiveSelectedChoices = self.selectedChoices.filter({$0.exclusive == true})\n-            if exclusiveSelectedChoices.count > 0 {\n-                updateForSingleSelection()\n-                self.tableView?.reloadData()\n-            }\n+\n+    func updateForMultipleSelection() {\n+\n+      guard let choice = choice else {  // Other choice\n+        if self.otherChoice.isExclusive {\n+          self.selectedChoices.removeAll()\n         }\n-        \n-        func updateForMultipleSelection() {\n-            \n-            guard let choice = choice else { // Other choice\n-                if self.otherChoice.isExclusive {\n-                    self.selectedChoices.removeAll()\n-                }\n-                removeSelectedExclusiveChoices()\n-                return\n-            }\n-            \n-            if choice.exclusive {\n-                if didSelected {\n-                    updateForSingleSelection() // Make it behave like single selection\n-                    if !removeOtherChoiceIfExclusive() {\n-                        self.tableView?.reloadData()\n-                    }\n-                    return\n-                }\n-            } else {\n-                removeSelectedExclusiveChoices()\n-                removeOtherChoiceIfExclusive()\n-            }\n-            \n-            if let choiceIndex = self.selectedChoices.firstIndex(of: choice) {\n-                if !(didSelected) {\n-                    self.selectedChoices.remove(at: choiceIndex)\n-                }\n-            } else if didSelected {\n-                self.selectedChoices.append(choice)\n-            }\n+        removeSelectedExclusiveChoices()\n+        return\n+      }\n+\n+      if choice.exclusive {\n+        if didSelected {\n+          updateForSingleSelection()  // Make it behave like single selection\n+          if !removeOtherChoiceIfExclusive() {\n+            self.tableView?.reloadData()\n+          }\n+          return\n         }\n-        \n-        guard self.tableView != nil else {return}\n-        \n-        switch self.tableView!.allowsMultipleSelection {\n-            \n-        case true:\n-            updateForMultipleSelection()\n-            \n-        case false:\n-            updateForSingleSelection()\n-            \n+      } else {\n+        removeSelectedExclusiveChoices()\n+        removeOtherChoiceIfExclusive()\n+      }\n+\n+      if let choiceIndex = self.selectedChoices.firstIndex(of: choice) {\n+        if !(didSelected) {\n+          self.selectedChoices.remove(at: choiceIndex)\n         }\n-        \n+      } else if didSelected {\n+        self.selectedChoices.append(choice)\n+      }\n     }\n-    \n-    private func isChoiceSelected(choice: ORKTextChoice) -> Bool {\n-        if self.selectedChoices.firstIndex(of: choice) != nil {\n-            return true\n-        }\n-        return false\n-    }\n-    \n-    override func goBackward() {\n-        //super.delegate?.stepViewControllerResultDidChange(self)\n-        print(\"User did pressed on back button\")\n-        super.goBackward()\n-        \n-    }\n-    \n-    override func goForward() {\n-        //super.delegate?.stepViewControllerResultDidChange(self)\n-        \n-        if self.otherChoice.isMandatory, self.otherChoice.otherChoiceText == \"\" || self.otherChoice.otherChoiceText == \" \",self.isOtherCellSelected {\n-            \n-            let alertVC = UIAlertController(title: \"Answer required\", message: \"Please provide an input for the text field too.\", preferredStyle: .alert)\n-            \n-            let okAction = UIAlertAction(title: \"Ok\", style: .default) { [unowned self] (action) in\n-                alertVC.dismiss(animated: true, completion: nil)\n-                if let otherCell = self.tableView?.cellForRow(at: IndexPath(row: self.textChoices.count, section: 0)) as? OtherTextChoiceCell {\n-                    otherCell.otherField.becomeFirstResponder()\n-                }\n-                self.updateNextOrContinueBtnState()\n-            }\n-            \n-            \n-            alertVC.addAction(okAction)\n-            self.present(alertVC, animated: true, completion: nil)\n-            \n-            updateNextOrContinueBtnState()\n-        } else {\n-            super.goForward()\n-        }\n-        \n-    }\n-    \n-    \n-    \n-    @objc func didTapOnDoneOrNextBtn(_ sender: UIButton ) {\n-        print(\"next or done button pressed\")\n-    }\n-    \n-    \n-    \n-    private func didTapOnOtherCell(didSelect: Bool) {\n-        \n-        if didSelect {\n-            \n-            self.isOtherCellSelected = true\n-            updateSelectedChoice(choice: nil, didSelected: true)\n-            self.tableView?.reloadData()\n-            \n-            if isSearching {\n-                view.endEditing(true) // Will be handled in search bar end editing delegate\n-            } else {\n-                let otherCellIndex = IndexPath(row: self.textChoices.count, section: 0)\n-                let cell = self.tableView?.cellForRow(at: otherCellIndex) as? OtherTextChoiceCell\n-                if self.otherChoice.isShowOtherField, cell?.otherField.text == \"\" {\n-                    cell?.otherField.becomeFirstResponder()\n-                }\n-            }\n-            \n-        } else {\n-            self.isOtherCellSelected = false\n-            self.tableView?.reloadData()\n-        }\n-        \n-    }\n-    \n-    private func updateNextOrContinueBtnState() {\n-        \n-        if self.selectedChoices.count > 0 || self.isOtherCellSelected {\n-            self.continueBtn?.isEnabled = true\n-            self.continueBtn?.isUserInteractionEnabled = true\n-        } else {\n-            self.continueBtn?.isEnabled = false\n-            self.continueBtn?.isUserInteractionEnabled = false\n+\n+    guard self.tableView != nil else { return }\n+\n+    switch self.tableView!.allowsMultipleSelection {\n+\n+    case true:\n+      updateForMultipleSelection()\n+\n+    case false:\n+      updateForSingleSelection()\n+\n+    }\n+\n+  }\n+\n+  private func isChoiceSelected(choice: ORKTextChoice) -> Bool {\n+    if self.selectedChoices.firstIndex(of: choice) != nil {\n+      return true\n+    }\n+    return false\n+  }\n+\n+  override func goBackward() {\n+    //super.delegate?.stepViewControllerResultDidChange(self)\n+    Logger.sharedInstance.info(\"\\(self) User did pressed on back button\")\n+    super.goBackward()\n+  }\n+\n+  override func goForward() {\n+    //super.delegate?.stepViewControllerResultDidChange(self)\n+\n+    if self.otherChoice.isMandatory,\n+      self.otherChoice.otherChoiceText == \"\" || self.otherChoice.otherChoiceText == \" \",\n+      self.isOtherCellSelected {\n+\n+      let alertVC = UIAlertController(\n+        title: \"Answer required\",\n+        message: \"Please provide an input for the text field too.\",\n+        preferredStyle: .alert)\n+\n+      let okAction = UIAlertAction(title: \"Ok\", style: .default) { [unowned self] (_) in\n+        alertVC.dismiss(animated: true, completion: nil)\n+        if let otherCell = self.tableView?.cellForRow(\n+          at: IndexPath(row: self.textChoices.count, section: 0)) as? OtherTextChoiceCell {\n+          otherCell.otherField.becomeFirstResponder()\n         }\n-        \n+        self.updateNextOrContinueBtnState()\n+      }\n+\n+      alertVC.addAction(okAction)\n+      self.present(alertVC, animated: true, completion: nil)\n+\n+      updateNextOrContinueBtnState()\n+    } else {\n+      super.goForward()\n     }\n-    \n-    \n-}\n \n+  }\n+\n+  @objc func didTapOnDoneOrNextBtn(_ sender: UIButton) {\n+    Logger.sharedInstance.info(\"\\(self): Next or done button pressed.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1041}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4NzM5Mw==", "bodyText": "why is this an error?\nif it's a debug print please remove it", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391787393", "createdAt": "2020-03-12T17:42:33Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ResourceUI/GatewayResourceDetailViewController.swift", "diffHunk": "@@ -1,293 +1,284 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import MessageUI\n-\n+import UIKit\n \n let resourcesDownloadPath = AKUtility.baseFilePath + \"/Resources\"\n \n class GatewayResourceDetailViewController: UIViewController {\n-    \n-    \n-    @IBOutlet var webView: UIWebView?\n-    @IBOutlet var progressBar: UIProgressView?\n-    \n-    var activityIndicator: UIActivityIndicatorView!\n-    var requestLink: String?\n-    var type: String?\n-    var htmlString: String?\n-    var resource: Resource?\n-    var isEmailComposerPresented: Bool?\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        self.hidesBottomBarWhenPushed = true\n-        self.addBackBarButton()\n-        self.isEmailComposerPresented = false\n-        self.title = resource?.title\n-        \n-    }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-        \n-        if self.isEmailComposerPresented == false{\n-        \n-        \n-        if self.resource?.file?.link != nil {\n-            \n-            activityIndicator = UIActivityIndicatorView(style: .gray)\n-            activityIndicator.center = CGPoint(x: self.view.frame.midX, y: self.view.frame.midY-100)\n-            \n-           \n-            self.view.addSubview(activityIndicator)\n-            \n-            \n-            activityIndicator.startAnimating()\n-            \n-            if self.resource?.file?.mimeType == .pdf{\n-                \n-                if self.resource?.file?.localPath != nil {\n-                    \n-                    if self.resource?.file?.localPath == \"BundlePath\" {\n-                        \n-                        let path = Bundle.main.path(forResource: self.resource?.file?.link!, ofType: \".pdf\")\n-                        self.loadWebViewWithPath(path: path!)\n-                    } else {\n-                        let path = resourcesDownloadPath + \"/\" + (self.resource?.file?.localPath)!\n-                        let pdfData = FileDownloadManager.decrytFile(pathURL: URL(string: path))\n-                        self.loadWebViewWithData(data: pdfData!)\n-\n-                    }\n-                    \n-                                      //self.loadWebViewWithPath(path: (self.resource?.file?.localPath)!)\n-                } else {\n-                   //let path = resourcesDownloadPath + \"/PDF_linking.pdf\"\n-                    self.startDownloadingfile()\n-                    //let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                    //self.loadWebViewWithData(data: pdfData!)\n-                }\n-                \n-                \n+\n+  // MARK: - Outlets\n+  @IBOutlet var webView: UIWebView?\n+\n+  @IBOutlet var progressBar: UIProgressView?\n+\n+  // MARK: - Properties\n+  var activityIndicator: UIActivityIndicatorView!\n+\n+  var requestLink: String?\n+  var type: String?\n+  var htmlString: String?\n+  var resource: Resource?\n+  var isEmailComposerPresented: Bool?\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  // MARK: - UIViewController LifeCycle\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    self.hidesBottomBarWhenPushed = true\n+    self.addBackBarButton()\n+    self.isEmailComposerPresented = false\n+    self.title = resource?.title\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    if self.isEmailComposerPresented == false {\n+\n+      if self.resource?.file?.link != nil {\n+\n+        activityIndicator = UIActivityIndicatorView(style: .gray)\n+        activityIndicator.center = CGPoint(\n+          x: self.view.frame.midX, y: self.view.frame.midY-100)\n+\n+        self.view.addSubview(activityIndicator)\n+\n+        activityIndicator.startAnimating()\n+\n+        if self.resource?.file?.mimeType == .pdf {\n+\n+          if self.resource?.file?.localPath != nil {\n+\n+            if self.resource?.file?.localPath == \"BundlePath\" {\n+\n+              let path = Bundle.main.path(\n+                forResource: self.resource?.file?.link!, ofType: \".pdf\")\n+              self.loadWebViewWithPath(path: path!)\n             } else {\n-                webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+              let path = resourcesDownloadPath + \"/\" + (\n+                self.resource?.file?.localPath\n+              )!\n+              let pdfData = FileDownloadManager.decrytFile(pathURL: URL(string: path))\n+              self.loadWebViewWithData(data: pdfData!)\n+\n             }\n+          } else {\n+            self.startDownloadingfile()\n+          }\n         } else {\n-            \n-        }\n-       // webView?.scalesPageToFit = true\n-        webView?.delegate = self\n-        self.webView?.scalesPageToFit = true\n-        }\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-    }\n-    \n-    override func viewWillDisappear(_ animated: Bool) {\n-        // self.tabBar.isHidden = false\n-    }\n-    \n-    func loadWebViewWithPath(path: String) {\n-        \n-        let url: URL? = URL.init(string:path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n-        let urlRequest = URLRequest(url: url!)\n-        webView?.loadRequest(urlRequest)\n-    }\n-    func loadWebViewWithData(data: Data) {\n-       \n-        self.webView?.load(data, mimeType: \"application/pdf\", textEncodingName: \"UTF-8\", baseURL: URL.init(fileURLWithPath: \"\") )\n-        \n-//        let url:URL? = URL.init(string:path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n-//        let urlRequest = URLRequest(url: url!)\n-//        webView?.loadRequest(urlRequest)\n-    }\n-    \n-    func startDownloadingfile() {\n-        \n-        if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n-            try! FileManager.default.createDirectory(atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n+          webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n         }\n-        debugPrint(\"custom download path: \\(resourcesDownloadPath)\")\n-        \n-       \n-        \n-        let fileURL =  (self.resource?.file?.link)!\n-        \n-        let url = URL(string: fileURL)\n-        \n-        var fileName: NSString = url!.lastPathComponent as NSString\n-        \n-        fileName = AKUtility.getUniqueFileNameWithPath((resourcesDownloadPath as NSString).appendingPathComponent(fileName as String) as NSString)\n-        \n-        let fdm = FileDownloadManager()\n-        fdm.delegate = self\n-        guard let encodedUrl = fileURL.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) else {\n-            return\n-        } // Tush\n-        \n-        fdm.downloadFile(fileName as String, fileURL: encodedUrl , destinationPath: resourcesDownloadPath)\n-    }\n-    \n-    \n-    // MARK:Button Actions\n-    \n-    @IBAction func cancelButtonClicked(_ sender: Any){\n-        self.dismiss(animated: true, completion: nil)\n-    }\n-    \n-    @IBAction func buttonActionForward(_ sender: UIBarButtonItem){\n-        \n-        self.sendEmail()\n+      } else {\n+\n+      }\n+      webView?.delegate = self\n+      self.webView?.scalesPageToFit = true\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+\n+  }\n+\n+  func loadWebViewWithPath(path: String) {\n+\n+    let url: URL? = URL.init(\n+      string: path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n+    let urlRequest = URLRequest(url: url!)\n+    webView?.loadRequest(urlRequest)\n+  }\n+\n+  func loadWebViewWithData(data: Data) {\n+\n+    self.webView?.load(\n+      data, mimeType: \"application/pdf\", textEncodingName: \"UTF-8\",\n+      baseURL: URL.init(fileURLWithPath: \"\"))\n+\n+  }\n+\n+  func startDownloadingfile() {\n+\n+    if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n+      try! FileManager.default.createDirectory(\n+        atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n     }\n+    Logger.sharedInstance.error(\"custom download path: \\(resourcesDownloadPath)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4ODQ3MA==", "bodyText": "remove debug log", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391788470", "createdAt": "2020-03-12T17:44:17Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ResourceUI/ResourceDetailViewController.swift", "diffHunk": "@@ -1,498 +1,526 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import MessageUI\n-import WebKit\n import SafariServices\n-//let resourcesDownloadPath = AKUtility.baseFilePath + \"/Resources\"\n+import UIKit\n+import WebKit\n \n class ResourceDetailViewController: UIViewController {\n-    \n-    @IBOutlet var webViewContainer: UIView?\n-    var webView: WKWebView?\n-    \n-    @IBOutlet var progressBar: UIProgressView?\n-    @IBOutlet var bottomToolBar: UIToolbar?\n-    \n-    \n-    var activityIndicator: UIActivityIndicatorView!\n-    var requestLink: String?\n-    var type: String?\n-    var htmlString: String?\n-    var resource: Resource?\n-    var isEmailComposerPresented: Bool?\n-    var fdm:FileDownloadManager = FileDownloadManager()\n-    \n-    override func viewDidLoad() {\n-        \n-        super.viewDidLoad()\n-        self.hidesBottomBarWhenPushed = true\n-        self.addBackBarButton()\n-        self.isEmailComposerPresented = false\n-        self.title = resource?.title\n-        \n-        _ = WKWebViewConfiguration()\n-        \n-        let jscript = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n-        \n-        let userScript = WKUserScript(source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n-        \n-        let wkUController = WKUserContentController()\n-        \n-        wkUController.addUserScript(userScript)\n-        \n-        let wkWebConfig = WKWebViewConfiguration()\n-        \n-        wkWebConfig.userContentController = wkUController\n-        \n-        \n-        let webViewFrame = CGRect.init(x: 0, y: 0, width: (webViewContainer?.frame.width)!, height: (webViewContainer?.frame.height)! - 44.0)\n-        \n-        webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n-        \n-       \n-        webViewContainer?.addSubview(webView!)\n-       \n-    }\n-    \n-    override func viewDidLayoutSubviews() {\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer, attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer, attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer, attribute:.top, multiplier: 1.0, constant:0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer, attribute:.bottom, multiplier: 1.0, constant:-44.0).isActive = true\n-    \n-        webView?.translatesAutoresizingMaskIntoConstraints = false\n-        \n-    }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-        \n-        if self.isEmailComposerPresented == false{\n-        \n-        \n-        if self.resource?.file?.link != nil {\n-            \n-            activityIndicator = UIActivityIndicatorView(style: .gray)\n-            activityIndicator.center = CGPoint(x: self.view.frame.midX, y: self.view.frame.midY-100)\n-            \n-           \n-            self.view.addSubview(activityIndicator)\n-            \n-            \n-            activityIndicator.startAnimating()\n-             self.activityIndicator.hidesWhenStopped = true\n-            if self.resource?.file?.mimeType == .pdf {\n-                \n-                if self.resource?.file?.localPath != nil {\n-                    \n-                    if self.resource?.file?.localPath == \"BundlePath\" {\n-                        \n-                        let path = Bundle.main.path(forResource: self.resource?.file?.link!, ofType: \".pdf\")\n-                        self.loadWebViewWithPath(path: path!)\n-                    } else {\n-                        let path = resourcesDownloadPath + \"/\" + (self.resource?.file?.localPath)!\n-                        let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                        self.loadWebViewWithData(data: pdfData!)\n-\n-                    }\n-                    \n-                                      //self.loadWebViewWithPath(path: (self.resource?.file?.localPath)!)\n-                } else {\n-                   //let path = resourcesDownloadPath + \"/PDF_linking.pdf\"\n-                    self.startDownloadingfile()\n-                    //let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                    //self.loadWebViewWithData(data: pdfData!)\n-                }\n-            } else {\n-                \n-                 webView?.allowsBackForwardNavigationGestures = true\n-                \n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n-            }\n+\n+  // MARK: - Outles\n+  @IBOutlet var webViewContainer: UIView?\n+  @IBOutlet var progressBar: UIProgressView?\n+  @IBOutlet var bottomToolBar: UIToolbar?\n+\n+  // MARK: - Properties\n+  var webView: WKWebView?\n+\n+  var activityIndicator: UIActivityIndicatorView!\n+  var requestLink: String?\n+  var type: String?\n+  var htmlString: String?\n+  var resource: Resource?\n+  var isEmailComposerPresented: Bool?\n+  lazy var fdm: FileDownloadManager = FileDownloadManager()\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    self.hidesBottomBarWhenPushed = true\n+    self.addBackBarButton()\n+    self.isEmailComposerPresented = false\n+    self.title = resource?.title\n+\n+    _ = WKWebViewConfiguration()\n+\n+    let jscript\n+      = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n+\n+    let userScript = WKUserScript(\n+      source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n+\n+    let wkUController = WKUserContentController()\n+    wkUController.addUserScript(userScript)\n+\n+    let wkWebConfig = WKWebViewConfiguration()\n+    wkWebConfig.userContentController = wkUController\n+\n+    let bottomBarHeight: CGFloat = 44.0\n+\n+    let webViewFrame = CGRect(\n+      x: 0, y: 0, width: (webViewContainer?.frame.width)!,\n+      height: (webViewContainer?.frame.height)! - bottomBarHeight)\n+\n+    webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n+    webViewContainer?.addSubview(webView!)\n+\n+  }\n+\n+  override func viewDidLayoutSubviews() {\n+    super.viewDidLayoutSubviews()\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .top,\n+      multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .bottom, multiplier: 1.0, constant: -44.0).isActive = true\n+\n+    webView?.translatesAutoresizingMaskIntoConstraints = false\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    if self.isEmailComposerPresented == false,\n+      self.resource?.file?.link != nil {\n+\n+      activityIndicator = UIActivityIndicatorView(style: .gray)\n+      activityIndicator.center = CGPoint(\n+        x: self.view.frame.midX, y: self.view.frame.midY-100)\n+\n+      self.view.addSubview(activityIndicator)\n+\n+      activityIndicator.startAnimating()\n+      self.activityIndicator.hidesWhenStopped = true\n+      if self.resource?.file?.mimeType == .pdf {\n+\n+        if self.resource?.file?.localPath != nil {\n+\n+          if self.resource?.file?.localPath == \"BundlePath\" {\n+\n+            let path = Bundle.main.path(\n+              forResource: self.resource?.file?.link!, ofType: \".pdf\")\n+            self.loadWebViewWithPath(path: path!)\n+          } else {\n+            let path = resourcesDownloadPath + \"/\" + (\n+              self.resource?.file?.localPath\n+            )!\n+            let pdfData = FileDownloadManager.decrytFile(pathURL: URL(string: path))\n+            self.loadWebViewWithData(data: pdfData!)\n+\n+          }\n         } else {\n-            \n-        }\n-        \n-        webView?.uiDelegate = self\n-        webView?.navigationDelegate = self\n+          self.startDownloadingfile()\n         }\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-    }\n-    \n-    override func viewWillDisappear(_ animated: Bool) {\n-        // self.tabBar.isHidden = false\n-    }\n-    \n-    func loadWebViewWithPath(path:String) {\n-        \n-        let url:URL? = URL.init(string:path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n-        let urlRequest = URLRequest(url: url!)\n-        \n-        \n-    \n+      } else {\n         webView?.allowsBackForwardNavigationGestures = true\n-        _ = webView?.load(urlRequest)\n-       // webView?.loadRequest(urlRequest)\n-    }\n-    \n-    func loadWebViewWithData(data: Data) {\n-        \n-         webView?.allowsBackForwardNavigationGestures = true\n-        \n-       _ = self.webView?.load(data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\", baseURL: URL.init(fileURLWithPath: \"\"))\n-        \n-       // self.webView?.load(data, mimeType: \"application/pdf\", textEncodingName: \"UTF-8\", baseURL:URL.init(fileURLWithPath: \"\") )\n-        \n-    }\n-    \n-    func startDownloadingfile(){\n-        \n-        if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n-            try! FileManager.default.createDirectory(atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n-        }\n-        //debugprint(\"custom download path: \\(resourcesDownloadPath)\")\n-        \n-       \n-        \n-        let fileURL =  (self.resource?.file?.link)!\n-        \n-        let url = URL(string:fileURL)\n-        \n-        var fileName : NSString = url!.lastPathComponent as NSString\n-        \n-        fileName = AKUtility.getUniqueFileNameWithPath((resourcesDownloadPath as NSString).appendingPathComponent(fileName as String) as NSString)\n-        \n-        fdm = FileDownloadManager()\n-        fdm.delegate = self\n-        //let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!\n-        //fdm.downloadFile(fileName as String, fileURL: fileURL.addingPercentEscapes(using: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!, destinationPath: resourcesDownloadPath)\n-        guard let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed) else {return}\n-        fdm.downloadFile(fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n-    }\n-    \n-    \n-    // MARK:Button Actions\n-    \n-    @IBAction func cancelButtonClicked(_ sender : Any) {\n-        self.dismiss(animated: true, completion: nil)\n-    }\n-    \n-    @IBAction func buttonActionForward(_ sender : UIBarButtonItem) {\n-        \n-        self.sendEmail()\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+      }\n+\n+      webView?.uiDelegate = self\n+      webView?.navigationDelegate = self\n     }\n-    \n-    @IBAction func buttonActionBack(_ sender : UIBarButtonItem) {\n-       \n-        if (webView?.canGoBack)!{\n-           _ =  webView?.goBack()\n-        } else if webView?.backForwardList.backList.count == 0 {\n-            if  self.resource?.file?.mimeType != .pdf {\n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+  }\n \n-            }\n-        }\n+  /// To Load web page with `URL` string path.\n+  /// - Parameter path: Path of the url.\n+  func loadWebViewWithPath(path: String) {\n+\n+    guard\n+      let url: URL = URL(\n+        string: path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n+    else { return }\n+    let urlRequest = URLRequest(url: url)\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+    _ = webView?.load(urlRequest)\n+\n+  }\n+\n+  func loadWebViewWithData(data: Data) {\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+\n+    _ = self.webView?.load(\n+      data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\",\n+      baseURL: URL.init(fileURLWithPath: \"\"))\n+\n+  }\n+\n+  func startDownloadingfile() {\n+\n+    if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n+      try! FileManager.default.createDirectory(\n+        atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n     }\n-    \n-    @IBAction func buttonActionGoForward(_ sender : UIBarButtonItem) {\n-        if (webView?.canGoForward)! {\n-           _ = webView?.goForward()\n-        }\n+\n+    let fileURL = (self.resource?.file?.link)!\n+\n+    let url = URL(string: fileURL)\n+\n+    var fileName: NSString = url!.lastPathComponent as NSString\n+\n+    fileName = AKUtility.getUniqueFileNameWithPath(\n+      (resourcesDownloadPath as NSString).appendingPathComponent(fileName as String)\n+        as NSString)\n+\n+    fdm = FileDownloadManager()\n+    fdm.delegate = self\n+\n+    guard\n+      let encodedURL = fileURL.addingPercentEncoding(\n+        withAllowedCharacters: CharacterSet.urlQueryAllowed)\n+    else { return }\n+    fdm.downloadFile(\n+      fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  @IBAction func cancelButtonClicked(_ sender: Any) {\n+    self.dismiss(animated: true, completion: nil)\n+  }\n+\n+  @IBAction func buttonActionForward(_ sender: UIBarButtonItem) {\n+    self.sendEmail()\n+  }\n+\n+  @IBAction func buttonActionBack(_ sender: UIBarButtonItem) {\n+\n+    if (webView?.canGoBack)! {\n+      _ = webView?.goBack()\n+    } else if webView?.backForwardList.backList.count == 0 {\n+      if self.resource?.file?.mimeType != .pdf {\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+\n+      }\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  }\n+\n+  @IBAction func buttonActionGoForward(_ sender: UIBarButtonItem) {\n+    if (webView?.canGoForward)! {\n+      _ = webView?.goForward()\n     }\n+  }\n+\n }\n \n-extension ResourceDetailViewController:UIWebViewDelegate {\n-    \n-    func webViewDidFinishLoad(_ webView: UIWebView) {\n-        self.activityIndicator.stopAnimating()\n-       \n-    }\n-    func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n-        self.activityIndicator.stopAnimating()\n-      \n-        \n-        let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n-        let alert = UIAlertController(title:NSLocalizedString(kTitleError, comment: \"\"),message:error.localizedDescription,preferredStyle: UIAlertController.Style.alert)\n-        \n-        alert.addAction(UIAlertAction.init(title:buttonTitleOK, style: .default, handler: { (action) in\n-            \n-            self.dismiss(animated: true, completion: nil)\n-            \n+extension ResourceDetailViewController: UIWebViewDelegate {\n+\n+  func webViewDidFinishLoad(_ webView: UIWebView) {\n+    self.activityIndicator.stopAnimating()\n+  }\n+\n+  func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n+    self.activityIndicator.stopAnimating()\n+\n+    let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n+    let alert = UIAlertController(\n+      title: NSLocalizedString(kTitleError, comment: \"\"), message: error.localizedDescription,\n+      preferredStyle: UIAlertController.Style.alert)\n+\n+    alert.addAction(\n+      UIAlertAction.init(\n+        title: buttonTitleOK, style: .default,\n+        handler: { (_) in\n+\n+          self.dismiss(animated: true, completion: nil)\n+\n         }))\n-        \n-        \n-        self.present(alert, animated: true, completion: nil)\n-        \n-        \n-    }\n+\n+    self.present(alert, animated: true, completion: nil)\n+\n+  }\n }\n \n-extension ResourceDetailViewController:WKUIDelegate,WKNavigationDelegate{\n-    \n-    \n-    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: (@escaping (WKNavigationActionPolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationAction:\\(navigationAction) decisionHandler:\\(decisionHandler)\")\n-        \n-        switch navigationAction.navigationType {\n-        case .linkActivated:\n-            if navigationAction.targetFrame == nil {\n-                webView.load(navigationAction.request)\n-            }\n-        default:\n-            break\n-        }\n-        self.activityIndicator.startAnimating()\n-        decisionHandler(.allow)\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: (@escaping (WKNavigationResponsePolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationResponse:\\(navigationResponse) decisionHandler:\\(decisionHandler)\")\n-        \n-        decisionHandler(.allow)\n+extension ResourceDetailViewController: WKUIDelegate, WKNavigationDelegate {\n+\n+  func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 532}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4ODUzOQ==", "bodyText": "same here", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391788539", "createdAt": "2020-03-12T17:44:24Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ResourceUI/ResourceDetailViewController.swift", "diffHunk": "@@ -1,498 +1,526 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import MessageUI\n-import WebKit\n import SafariServices\n-//let resourcesDownloadPath = AKUtility.baseFilePath + \"/Resources\"\n+import UIKit\n+import WebKit\n \n class ResourceDetailViewController: UIViewController {\n-    \n-    @IBOutlet var webViewContainer: UIView?\n-    var webView: WKWebView?\n-    \n-    @IBOutlet var progressBar: UIProgressView?\n-    @IBOutlet var bottomToolBar: UIToolbar?\n-    \n-    \n-    var activityIndicator: UIActivityIndicatorView!\n-    var requestLink: String?\n-    var type: String?\n-    var htmlString: String?\n-    var resource: Resource?\n-    var isEmailComposerPresented: Bool?\n-    var fdm:FileDownloadManager = FileDownloadManager()\n-    \n-    override func viewDidLoad() {\n-        \n-        super.viewDidLoad()\n-        self.hidesBottomBarWhenPushed = true\n-        self.addBackBarButton()\n-        self.isEmailComposerPresented = false\n-        self.title = resource?.title\n-        \n-        _ = WKWebViewConfiguration()\n-        \n-        let jscript = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n-        \n-        let userScript = WKUserScript(source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n-        \n-        let wkUController = WKUserContentController()\n-        \n-        wkUController.addUserScript(userScript)\n-        \n-        let wkWebConfig = WKWebViewConfiguration()\n-        \n-        wkWebConfig.userContentController = wkUController\n-        \n-        \n-        let webViewFrame = CGRect.init(x: 0, y: 0, width: (webViewContainer?.frame.width)!, height: (webViewContainer?.frame.height)! - 44.0)\n-        \n-        webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n-        \n-       \n-        webViewContainer?.addSubview(webView!)\n-       \n-    }\n-    \n-    override func viewDidLayoutSubviews() {\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer, attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer, attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer, attribute:.top, multiplier: 1.0, constant:0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer, attribute:.bottom, multiplier: 1.0, constant:-44.0).isActive = true\n-    \n-        webView?.translatesAutoresizingMaskIntoConstraints = false\n-        \n-    }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-        \n-        if self.isEmailComposerPresented == false{\n-        \n-        \n-        if self.resource?.file?.link != nil {\n-            \n-            activityIndicator = UIActivityIndicatorView(style: .gray)\n-            activityIndicator.center = CGPoint(x: self.view.frame.midX, y: self.view.frame.midY-100)\n-            \n-           \n-            self.view.addSubview(activityIndicator)\n-            \n-            \n-            activityIndicator.startAnimating()\n-             self.activityIndicator.hidesWhenStopped = true\n-            if self.resource?.file?.mimeType == .pdf {\n-                \n-                if self.resource?.file?.localPath != nil {\n-                    \n-                    if self.resource?.file?.localPath == \"BundlePath\" {\n-                        \n-                        let path = Bundle.main.path(forResource: self.resource?.file?.link!, ofType: \".pdf\")\n-                        self.loadWebViewWithPath(path: path!)\n-                    } else {\n-                        let path = resourcesDownloadPath + \"/\" + (self.resource?.file?.localPath)!\n-                        let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                        self.loadWebViewWithData(data: pdfData!)\n-\n-                    }\n-                    \n-                                      //self.loadWebViewWithPath(path: (self.resource?.file?.localPath)!)\n-                } else {\n-                   //let path = resourcesDownloadPath + \"/PDF_linking.pdf\"\n-                    self.startDownloadingfile()\n-                    //let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                    //self.loadWebViewWithData(data: pdfData!)\n-                }\n-            } else {\n-                \n-                 webView?.allowsBackForwardNavigationGestures = true\n-                \n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n-            }\n+\n+  // MARK: - Outles\n+  @IBOutlet var webViewContainer: UIView?\n+  @IBOutlet var progressBar: UIProgressView?\n+  @IBOutlet var bottomToolBar: UIToolbar?\n+\n+  // MARK: - Properties\n+  var webView: WKWebView?\n+\n+  var activityIndicator: UIActivityIndicatorView!\n+  var requestLink: String?\n+  var type: String?\n+  var htmlString: String?\n+  var resource: Resource?\n+  var isEmailComposerPresented: Bool?\n+  lazy var fdm: FileDownloadManager = FileDownloadManager()\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    self.hidesBottomBarWhenPushed = true\n+    self.addBackBarButton()\n+    self.isEmailComposerPresented = false\n+    self.title = resource?.title\n+\n+    _ = WKWebViewConfiguration()\n+\n+    let jscript\n+      = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n+\n+    let userScript = WKUserScript(\n+      source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n+\n+    let wkUController = WKUserContentController()\n+    wkUController.addUserScript(userScript)\n+\n+    let wkWebConfig = WKWebViewConfiguration()\n+    wkWebConfig.userContentController = wkUController\n+\n+    let bottomBarHeight: CGFloat = 44.0\n+\n+    let webViewFrame = CGRect(\n+      x: 0, y: 0, width: (webViewContainer?.frame.width)!,\n+      height: (webViewContainer?.frame.height)! - bottomBarHeight)\n+\n+    webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n+    webViewContainer?.addSubview(webView!)\n+\n+  }\n+\n+  override func viewDidLayoutSubviews() {\n+    super.viewDidLayoutSubviews()\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .top,\n+      multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .bottom, multiplier: 1.0, constant: -44.0).isActive = true\n+\n+    webView?.translatesAutoresizingMaskIntoConstraints = false\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    if self.isEmailComposerPresented == false,\n+      self.resource?.file?.link != nil {\n+\n+      activityIndicator = UIActivityIndicatorView(style: .gray)\n+      activityIndicator.center = CGPoint(\n+        x: self.view.frame.midX, y: self.view.frame.midY-100)\n+\n+      self.view.addSubview(activityIndicator)\n+\n+      activityIndicator.startAnimating()\n+      self.activityIndicator.hidesWhenStopped = true\n+      if self.resource?.file?.mimeType == .pdf {\n+\n+        if self.resource?.file?.localPath != nil {\n+\n+          if self.resource?.file?.localPath == \"BundlePath\" {\n+\n+            let path = Bundle.main.path(\n+              forResource: self.resource?.file?.link!, ofType: \".pdf\")\n+            self.loadWebViewWithPath(path: path!)\n+          } else {\n+            let path = resourcesDownloadPath + \"/\" + (\n+              self.resource?.file?.localPath\n+            )!\n+            let pdfData = FileDownloadManager.decrytFile(pathURL: URL(string: path))\n+            self.loadWebViewWithData(data: pdfData!)\n+\n+          }\n         } else {\n-            \n-        }\n-        \n-        webView?.uiDelegate = self\n-        webView?.navigationDelegate = self\n+          self.startDownloadingfile()\n         }\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-    }\n-    \n-    override func viewWillDisappear(_ animated: Bool) {\n-        // self.tabBar.isHidden = false\n-    }\n-    \n-    func loadWebViewWithPath(path:String) {\n-        \n-        let url:URL? = URL.init(string:path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n-        let urlRequest = URLRequest(url: url!)\n-        \n-        \n-    \n+      } else {\n         webView?.allowsBackForwardNavigationGestures = true\n-        _ = webView?.load(urlRequest)\n-       // webView?.loadRequest(urlRequest)\n-    }\n-    \n-    func loadWebViewWithData(data: Data) {\n-        \n-         webView?.allowsBackForwardNavigationGestures = true\n-        \n-       _ = self.webView?.load(data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\", baseURL: URL.init(fileURLWithPath: \"\"))\n-        \n-       // self.webView?.load(data, mimeType: \"application/pdf\", textEncodingName: \"UTF-8\", baseURL:URL.init(fileURLWithPath: \"\") )\n-        \n-    }\n-    \n-    func startDownloadingfile(){\n-        \n-        if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n-            try! FileManager.default.createDirectory(atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n-        }\n-        //debugprint(\"custom download path: \\(resourcesDownloadPath)\")\n-        \n-       \n-        \n-        let fileURL =  (self.resource?.file?.link)!\n-        \n-        let url = URL(string:fileURL)\n-        \n-        var fileName : NSString = url!.lastPathComponent as NSString\n-        \n-        fileName = AKUtility.getUniqueFileNameWithPath((resourcesDownloadPath as NSString).appendingPathComponent(fileName as String) as NSString)\n-        \n-        fdm = FileDownloadManager()\n-        fdm.delegate = self\n-        //let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!\n-        //fdm.downloadFile(fileName as String, fileURL: fileURL.addingPercentEscapes(using: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!, destinationPath: resourcesDownloadPath)\n-        guard let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed) else {return}\n-        fdm.downloadFile(fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n-    }\n-    \n-    \n-    // MARK:Button Actions\n-    \n-    @IBAction func cancelButtonClicked(_ sender : Any) {\n-        self.dismiss(animated: true, completion: nil)\n-    }\n-    \n-    @IBAction func buttonActionForward(_ sender : UIBarButtonItem) {\n-        \n-        self.sendEmail()\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+      }\n+\n+      webView?.uiDelegate = self\n+      webView?.navigationDelegate = self\n     }\n-    \n-    @IBAction func buttonActionBack(_ sender : UIBarButtonItem) {\n-       \n-        if (webView?.canGoBack)!{\n-           _ =  webView?.goBack()\n-        } else if webView?.backForwardList.backList.count == 0 {\n-            if  self.resource?.file?.mimeType != .pdf {\n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+  }\n \n-            }\n-        }\n+  /// To Load web page with `URL` string path.\n+  /// - Parameter path: Path of the url.\n+  func loadWebViewWithPath(path: String) {\n+\n+    guard\n+      let url: URL = URL(\n+        string: path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n+    else { return }\n+    let urlRequest = URLRequest(url: url)\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+    _ = webView?.load(urlRequest)\n+\n+  }\n+\n+  func loadWebViewWithData(data: Data) {\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+\n+    _ = self.webView?.load(\n+      data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\",\n+      baseURL: URL.init(fileURLWithPath: \"\"))\n+\n+  }\n+\n+  func startDownloadingfile() {\n+\n+    if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n+      try! FileManager.default.createDirectory(\n+        atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n     }\n-    \n-    @IBAction func buttonActionGoForward(_ sender : UIBarButtonItem) {\n-        if (webView?.canGoForward)! {\n-           _ = webView?.goForward()\n-        }\n+\n+    let fileURL = (self.resource?.file?.link)!\n+\n+    let url = URL(string: fileURL)\n+\n+    var fileName: NSString = url!.lastPathComponent as NSString\n+\n+    fileName = AKUtility.getUniqueFileNameWithPath(\n+      (resourcesDownloadPath as NSString).appendingPathComponent(fileName as String)\n+        as NSString)\n+\n+    fdm = FileDownloadManager()\n+    fdm.delegate = self\n+\n+    guard\n+      let encodedURL = fileURL.addingPercentEncoding(\n+        withAllowedCharacters: CharacterSet.urlQueryAllowed)\n+    else { return }\n+    fdm.downloadFile(\n+      fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  @IBAction func cancelButtonClicked(_ sender: Any) {\n+    self.dismiss(animated: true, completion: nil)\n+  }\n+\n+  @IBAction func buttonActionForward(_ sender: UIBarButtonItem) {\n+    self.sendEmail()\n+  }\n+\n+  @IBAction func buttonActionBack(_ sender: UIBarButtonItem) {\n+\n+    if (webView?.canGoBack)! {\n+      _ = webView?.goBack()\n+    } else if webView?.backForwardList.backList.count == 0 {\n+      if self.resource?.file?.mimeType != .pdf {\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+\n+      }\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  }\n+\n+  @IBAction func buttonActionGoForward(_ sender: UIBarButtonItem) {\n+    if (webView?.canGoForward)! {\n+      _ = webView?.goForward()\n     }\n+  }\n+\n }\n \n-extension ResourceDetailViewController:UIWebViewDelegate {\n-    \n-    func webViewDidFinishLoad(_ webView: UIWebView) {\n-        self.activityIndicator.stopAnimating()\n-       \n-    }\n-    func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n-        self.activityIndicator.stopAnimating()\n-      \n-        \n-        let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n-        let alert = UIAlertController(title:NSLocalizedString(kTitleError, comment: \"\"),message:error.localizedDescription,preferredStyle: UIAlertController.Style.alert)\n-        \n-        alert.addAction(UIAlertAction.init(title:buttonTitleOK, style: .default, handler: { (action) in\n-            \n-            self.dismiss(animated: true, completion: nil)\n-            \n+extension ResourceDetailViewController: UIWebViewDelegate {\n+\n+  func webViewDidFinishLoad(_ webView: UIWebView) {\n+    self.activityIndicator.stopAnimating()\n+  }\n+\n+  func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n+    self.activityIndicator.stopAnimating()\n+\n+    let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n+    let alert = UIAlertController(\n+      title: NSLocalizedString(kTitleError, comment: \"\"), message: error.localizedDescription,\n+      preferredStyle: UIAlertController.Style.alert)\n+\n+    alert.addAction(\n+      UIAlertAction.init(\n+        title: buttonTitleOK, style: .default,\n+        handler: { (_) in\n+\n+          self.dismiss(animated: true, completion: nil)\n+\n         }))\n-        \n-        \n-        self.present(alert, animated: true, completion: nil)\n-        \n-        \n-    }\n+\n+    self.present(alert, animated: true, completion: nil)\n+\n+  }\n }\n \n-extension ResourceDetailViewController:WKUIDelegate,WKNavigationDelegate{\n-    \n-    \n-    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: (@escaping (WKNavigationActionPolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationAction:\\(navigationAction) decisionHandler:\\(decisionHandler)\")\n-        \n-        switch navigationAction.navigationType {\n-        case .linkActivated:\n-            if navigationAction.targetFrame == nil {\n-                webView.load(navigationAction.request)\n-            }\n-        default:\n-            break\n-        }\n-        self.activityIndicator.startAnimating()\n-        decisionHandler(.allow)\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: (@escaping (WKNavigationResponsePolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationResponse:\\(navigationResponse) decisionHandler:\\(decisionHandler)\")\n-        \n-        decisionHandler(.allow)\n+extension ResourceDetailViewController: WKUIDelegate, WKNavigationDelegate {\n+\n+  func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 536}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4ODY3Ng==", "bodyText": "same", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391788676", "createdAt": "2020-03-12T17:44:40Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ResourceUI/ResourceDetailViewController.swift", "diffHunk": "@@ -1,498 +1,526 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import MessageUI\n-import WebKit\n import SafariServices\n-//let resourcesDownloadPath = AKUtility.baseFilePath + \"/Resources\"\n+import UIKit\n+import WebKit\n \n class ResourceDetailViewController: UIViewController {\n-    \n-    @IBOutlet var webViewContainer: UIView?\n-    var webView: WKWebView?\n-    \n-    @IBOutlet var progressBar: UIProgressView?\n-    @IBOutlet var bottomToolBar: UIToolbar?\n-    \n-    \n-    var activityIndicator: UIActivityIndicatorView!\n-    var requestLink: String?\n-    var type: String?\n-    var htmlString: String?\n-    var resource: Resource?\n-    var isEmailComposerPresented: Bool?\n-    var fdm:FileDownloadManager = FileDownloadManager()\n-    \n-    override func viewDidLoad() {\n-        \n-        super.viewDidLoad()\n-        self.hidesBottomBarWhenPushed = true\n-        self.addBackBarButton()\n-        self.isEmailComposerPresented = false\n-        self.title = resource?.title\n-        \n-        _ = WKWebViewConfiguration()\n-        \n-        let jscript = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n-        \n-        let userScript = WKUserScript(source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n-        \n-        let wkUController = WKUserContentController()\n-        \n-        wkUController.addUserScript(userScript)\n-        \n-        let wkWebConfig = WKWebViewConfiguration()\n-        \n-        wkWebConfig.userContentController = wkUController\n-        \n-        \n-        let webViewFrame = CGRect.init(x: 0, y: 0, width: (webViewContainer?.frame.width)!, height: (webViewContainer?.frame.height)! - 44.0)\n-        \n-        webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n-        \n-       \n-        webViewContainer?.addSubview(webView!)\n-       \n-    }\n-    \n-    override func viewDidLayoutSubviews() {\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer, attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer, attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer, attribute:.top, multiplier: 1.0, constant:0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer, attribute:.bottom, multiplier: 1.0, constant:-44.0).isActive = true\n-    \n-        webView?.translatesAutoresizingMaskIntoConstraints = false\n-        \n-    }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-        \n-        if self.isEmailComposerPresented == false{\n-        \n-        \n-        if self.resource?.file?.link != nil {\n-            \n-            activityIndicator = UIActivityIndicatorView(style: .gray)\n-            activityIndicator.center = CGPoint(x: self.view.frame.midX, y: self.view.frame.midY-100)\n-            \n-           \n-            self.view.addSubview(activityIndicator)\n-            \n-            \n-            activityIndicator.startAnimating()\n-             self.activityIndicator.hidesWhenStopped = true\n-            if self.resource?.file?.mimeType == .pdf {\n-                \n-                if self.resource?.file?.localPath != nil {\n-                    \n-                    if self.resource?.file?.localPath == \"BundlePath\" {\n-                        \n-                        let path = Bundle.main.path(forResource: self.resource?.file?.link!, ofType: \".pdf\")\n-                        self.loadWebViewWithPath(path: path!)\n-                    } else {\n-                        let path = resourcesDownloadPath + \"/\" + (self.resource?.file?.localPath)!\n-                        let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                        self.loadWebViewWithData(data: pdfData!)\n-\n-                    }\n-                    \n-                                      //self.loadWebViewWithPath(path: (self.resource?.file?.localPath)!)\n-                } else {\n-                   //let path = resourcesDownloadPath + \"/PDF_linking.pdf\"\n-                    self.startDownloadingfile()\n-                    //let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                    //self.loadWebViewWithData(data: pdfData!)\n-                }\n-            } else {\n-                \n-                 webView?.allowsBackForwardNavigationGestures = true\n-                \n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n-            }\n+\n+  // MARK: - Outles\n+  @IBOutlet var webViewContainer: UIView?\n+  @IBOutlet var progressBar: UIProgressView?\n+  @IBOutlet var bottomToolBar: UIToolbar?\n+\n+  // MARK: - Properties\n+  var webView: WKWebView?\n+\n+  var activityIndicator: UIActivityIndicatorView!\n+  var requestLink: String?\n+  var type: String?\n+  var htmlString: String?\n+  var resource: Resource?\n+  var isEmailComposerPresented: Bool?\n+  lazy var fdm: FileDownloadManager = FileDownloadManager()\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    self.hidesBottomBarWhenPushed = true\n+    self.addBackBarButton()\n+    self.isEmailComposerPresented = false\n+    self.title = resource?.title\n+\n+    _ = WKWebViewConfiguration()\n+\n+    let jscript\n+      = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n+\n+    let userScript = WKUserScript(\n+      source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n+\n+    let wkUController = WKUserContentController()\n+    wkUController.addUserScript(userScript)\n+\n+    let wkWebConfig = WKWebViewConfiguration()\n+    wkWebConfig.userContentController = wkUController\n+\n+    let bottomBarHeight: CGFloat = 44.0\n+\n+    let webViewFrame = CGRect(\n+      x: 0, y: 0, width: (webViewContainer?.frame.width)!,\n+      height: (webViewContainer?.frame.height)! - bottomBarHeight)\n+\n+    webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n+    webViewContainer?.addSubview(webView!)\n+\n+  }\n+\n+  override func viewDidLayoutSubviews() {\n+    super.viewDidLayoutSubviews()\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .top,\n+      multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .bottom, multiplier: 1.0, constant: -44.0).isActive = true\n+\n+    webView?.translatesAutoresizingMaskIntoConstraints = false\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    if self.isEmailComposerPresented == false,\n+      self.resource?.file?.link != nil {\n+\n+      activityIndicator = UIActivityIndicatorView(style: .gray)\n+      activityIndicator.center = CGPoint(\n+        x: self.view.frame.midX, y: self.view.frame.midY-100)\n+\n+      self.view.addSubview(activityIndicator)\n+\n+      activityIndicator.startAnimating()\n+      self.activityIndicator.hidesWhenStopped = true\n+      if self.resource?.file?.mimeType == .pdf {\n+\n+        if self.resource?.file?.localPath != nil {\n+\n+          if self.resource?.file?.localPath == \"BundlePath\" {\n+\n+            let path = Bundle.main.path(\n+              forResource: self.resource?.file?.link!, ofType: \".pdf\")\n+            self.loadWebViewWithPath(path: path!)\n+          } else {\n+            let path = resourcesDownloadPath + \"/\" + (\n+              self.resource?.file?.localPath\n+            )!\n+            let pdfData = FileDownloadManager.decrytFile(pathURL: URL(string: path))\n+            self.loadWebViewWithData(data: pdfData!)\n+\n+          }\n         } else {\n-            \n-        }\n-        \n-        webView?.uiDelegate = self\n-        webView?.navigationDelegate = self\n+          self.startDownloadingfile()\n         }\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-    }\n-    \n-    override func viewWillDisappear(_ animated: Bool) {\n-        // self.tabBar.isHidden = false\n-    }\n-    \n-    func loadWebViewWithPath(path:String) {\n-        \n-        let url:URL? = URL.init(string:path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n-        let urlRequest = URLRequest(url: url!)\n-        \n-        \n-    \n+      } else {\n         webView?.allowsBackForwardNavigationGestures = true\n-        _ = webView?.load(urlRequest)\n-       // webView?.loadRequest(urlRequest)\n-    }\n-    \n-    func loadWebViewWithData(data: Data) {\n-        \n-         webView?.allowsBackForwardNavigationGestures = true\n-        \n-       _ = self.webView?.load(data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\", baseURL: URL.init(fileURLWithPath: \"\"))\n-        \n-       // self.webView?.load(data, mimeType: \"application/pdf\", textEncodingName: \"UTF-8\", baseURL:URL.init(fileURLWithPath: \"\") )\n-        \n-    }\n-    \n-    func startDownloadingfile(){\n-        \n-        if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n-            try! FileManager.default.createDirectory(atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n-        }\n-        //debugprint(\"custom download path: \\(resourcesDownloadPath)\")\n-        \n-       \n-        \n-        let fileURL =  (self.resource?.file?.link)!\n-        \n-        let url = URL(string:fileURL)\n-        \n-        var fileName : NSString = url!.lastPathComponent as NSString\n-        \n-        fileName = AKUtility.getUniqueFileNameWithPath((resourcesDownloadPath as NSString).appendingPathComponent(fileName as String) as NSString)\n-        \n-        fdm = FileDownloadManager()\n-        fdm.delegate = self\n-        //let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!\n-        //fdm.downloadFile(fileName as String, fileURL: fileURL.addingPercentEscapes(using: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!, destinationPath: resourcesDownloadPath)\n-        guard let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed) else {return}\n-        fdm.downloadFile(fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n-    }\n-    \n-    \n-    // MARK:Button Actions\n-    \n-    @IBAction func cancelButtonClicked(_ sender : Any) {\n-        self.dismiss(animated: true, completion: nil)\n-    }\n-    \n-    @IBAction func buttonActionForward(_ sender : UIBarButtonItem) {\n-        \n-        self.sendEmail()\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+      }\n+\n+      webView?.uiDelegate = self\n+      webView?.navigationDelegate = self\n     }\n-    \n-    @IBAction func buttonActionBack(_ sender : UIBarButtonItem) {\n-       \n-        if (webView?.canGoBack)!{\n-           _ =  webView?.goBack()\n-        } else if webView?.backForwardList.backList.count == 0 {\n-            if  self.resource?.file?.mimeType != .pdf {\n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+  }\n \n-            }\n-        }\n+  /// To Load web page with `URL` string path.\n+  /// - Parameter path: Path of the url.\n+  func loadWebViewWithPath(path: String) {\n+\n+    guard\n+      let url: URL = URL(\n+        string: path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n+    else { return }\n+    let urlRequest = URLRequest(url: url)\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+    _ = webView?.load(urlRequest)\n+\n+  }\n+\n+  func loadWebViewWithData(data: Data) {\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+\n+    _ = self.webView?.load(\n+      data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\",\n+      baseURL: URL.init(fileURLWithPath: \"\"))\n+\n+  }\n+\n+  func startDownloadingfile() {\n+\n+    if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n+      try! FileManager.default.createDirectory(\n+        atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n     }\n-    \n-    @IBAction func buttonActionGoForward(_ sender : UIBarButtonItem) {\n-        if (webView?.canGoForward)! {\n-           _ = webView?.goForward()\n-        }\n+\n+    let fileURL = (self.resource?.file?.link)!\n+\n+    let url = URL(string: fileURL)\n+\n+    var fileName: NSString = url!.lastPathComponent as NSString\n+\n+    fileName = AKUtility.getUniqueFileNameWithPath(\n+      (resourcesDownloadPath as NSString).appendingPathComponent(fileName as String)\n+        as NSString)\n+\n+    fdm = FileDownloadManager()\n+    fdm.delegate = self\n+\n+    guard\n+      let encodedURL = fileURL.addingPercentEncoding(\n+        withAllowedCharacters: CharacterSet.urlQueryAllowed)\n+    else { return }\n+    fdm.downloadFile(\n+      fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  @IBAction func cancelButtonClicked(_ sender: Any) {\n+    self.dismiss(animated: true, completion: nil)\n+  }\n+\n+  @IBAction func buttonActionForward(_ sender: UIBarButtonItem) {\n+    self.sendEmail()\n+  }\n+\n+  @IBAction func buttonActionBack(_ sender: UIBarButtonItem) {\n+\n+    if (webView?.canGoBack)! {\n+      _ = webView?.goBack()\n+    } else if webView?.backForwardList.backList.count == 0 {\n+      if self.resource?.file?.mimeType != .pdf {\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+\n+      }\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  }\n+\n+  @IBAction func buttonActionGoForward(_ sender: UIBarButtonItem) {\n+    if (webView?.canGoForward)! {\n+      _ = webView?.goForward()\n     }\n+  }\n+\n }\n \n-extension ResourceDetailViewController:UIWebViewDelegate {\n-    \n-    func webViewDidFinishLoad(_ webView: UIWebView) {\n-        self.activityIndicator.stopAnimating()\n-       \n-    }\n-    func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n-        self.activityIndicator.stopAnimating()\n-      \n-        \n-        let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n-        let alert = UIAlertController(title:NSLocalizedString(kTitleError, comment: \"\"),message:error.localizedDescription,preferredStyle: UIAlertController.Style.alert)\n-        \n-        alert.addAction(UIAlertAction.init(title:buttonTitleOK, style: .default, handler: { (action) in\n-            \n-            self.dismiss(animated: true, completion: nil)\n-            \n+extension ResourceDetailViewController: UIWebViewDelegate {\n+\n+  func webViewDidFinishLoad(_ webView: UIWebView) {\n+    self.activityIndicator.stopAnimating()\n+  }\n+\n+  func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n+    self.activityIndicator.stopAnimating()\n+\n+    let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n+    let alert = UIAlertController(\n+      title: NSLocalizedString(kTitleError, comment: \"\"), message: error.localizedDescription,\n+      preferredStyle: UIAlertController.Style.alert)\n+\n+    alert.addAction(\n+      UIAlertAction.init(\n+        title: buttonTitleOK, style: .default,\n+        handler: { (_) in\n+\n+          self.dismiss(animated: true, completion: nil)\n+\n         }))\n-        \n-        \n-        self.present(alert, animated: true, completion: nil)\n-        \n-        \n-    }\n+\n+    self.present(alert, animated: true, completion: nil)\n+\n+  }\n }\n \n-extension ResourceDetailViewController:WKUIDelegate,WKNavigationDelegate{\n-    \n-    \n-    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: (@escaping (WKNavigationActionPolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationAction:\\(navigationAction) decisionHandler:\\(decisionHandler)\")\n-        \n-        switch navigationAction.navigationType {\n-        case .linkActivated:\n-            if navigationAction.targetFrame == nil {\n-                webView.load(navigationAction.request)\n-            }\n-        default:\n-            break\n-        }\n-        self.activityIndicator.startAnimating()\n-        decisionHandler(.allow)\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: (@escaping (WKNavigationResponsePolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationResponse:\\(navigationResponse) decisionHandler:\\(decisionHandler)\")\n-        \n-        decisionHandler(.allow)\n+extension ResourceDetailViewController: WKUIDelegate, WKNavigationDelegate {\n+\n+  func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction,\n+    decisionHandler: (@escaping (WKNavigationActionPolicy) -> Void)\n+  ) {\n+    switch navigationAction.navigationType {\n+    case .linkActivated:\n+      if navigationAction.targetFrame == nil {\n+        webView.load(navigationAction.request)\n+      }\n+    default:\n+      break\n     }\n-    \n-    func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n-        print(\"webView:\\(webView) didReceiveAuthenticationChallenge:\\(challenge) completionHandler:\\(completionHandler)\")\n-        \n-        switch (challenge.protectionSpace.authenticationMethod) {\n-        case NSURLAuthenticationMethodHTTPBasic:\n-            let alertController = UIAlertController(title: \"Authentication Required\", message: webView.url?.host, preferredStyle: .alert)\n-            weak var usernameTextField: UITextField!\n-            alertController.addTextField { textField in\n-                textField.placeholder = \"Username\"\n-                usernameTextField = textField\n-            }\n-            weak var passwordTextField: UITextField!\n-            alertController.addTextField { textField in\n-                textField.placeholder = \"Password\"\n-                textField.isSecureTextEntry = true\n-                passwordTextField = textField\n+    self.activityIndicator.startAnimating()\n+    decisionHandler(.allow)\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse,\n+    decisionHandler: (@escaping (WKNavigationResponsePolicy) -> Void)\n+  ) {\n+    decisionHandler(.allow)\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge,\n+    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void\n+  ) {\n+\n+    switch challenge.protectionSpace.authenticationMethod {\n+    case NSURLAuthenticationMethodHTTPBasic:\n+      let alertController = UIAlertController(\n+        title: \"Authentication Required\", message: webView.url?.host, preferredStyle: .alert\n+      )\n+      weak var usernameTextField: UITextField!\n+      alertController.addTextField { textField in\n+        textField.placeholder = \"Username\"\n+        usernameTextField = textField\n+      }\n+      weak var passwordTextField: UITextField!\n+      alertController.addTextField { textField in\n+        textField.placeholder = \"Password\"\n+        textField.isSecureTextEntry = true\n+        passwordTextField = textField\n+      }\n+      alertController.addAction(\n+        UIAlertAction(\n+          title: \"Cancel\", style: .cancel,\n+          handler: { _ in\n+            completionHandler(.cancelAuthenticationChallenge, nil)\n+          }))\n+      alertController.addAction(\n+        UIAlertAction(\n+          title: \"Log In\", style: .default,\n+          handler: { _ in\n+            guard let username = usernameTextField.text,\n+              let password = passwordTextField.text\n+            else {\n+              completionHandler(.rejectProtectionSpace, nil)\n+              return\n             }\n-            alertController.addAction(UIAlertAction(title: \"Cancel\", style: .cancel, handler: { action in\n-                completionHandler(.cancelAuthenticationChallenge, nil)\n-            }))\n-            alertController.addAction(UIAlertAction(title: \"Log In\", style: .default, handler: { action in\n-                guard let username = usernameTextField.text, let password = passwordTextField.text else {\n-                    completionHandler(.rejectProtectionSpace, nil)\n-                    return\n-                }\n-                let credential = URLCredential(user: username, password: password, persistence: URLCredential.Persistence.forSession)\n-                completionHandler(.useCredential, credential)\n-            }))\n-            present(alertController, animated: true, completion: nil)\n-        default:\n-            completionHandler(.rejectProtectionSpace, nil);\n-        }\n-    }\n-    \n-    func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didReceiveServerRedirectForProvisionalNavigation:\\(navigation)\")\n-    }\n- \n-    \n-    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didFinishNavigation:\\(navigation)\")\n-        \n-        self.activityIndicator.stopAnimating()\n-        \n-    }\n-    \n-    func webView(_ webView: WKWebView, didFail navigation: WKNavigation, withError error: Error) {\n-        print(\"webView:\\(webView) didFailNavigation:\\(navigation) withError:\\(error)\")\n-        \n-        let alert = UIAlertController(title: \"Error\", message: error.localizedDescription, preferredStyle: .alert)\n-        alert.addAction(UIAlertAction(title: \"Ok\", style: .default, handler: nil))\n-        present(alert, animated: true, completion: nil)\n+            let credential = URLCredential(\n+              user: username, password: password,\n+              persistence: URLCredential.Persistence.forSession)\n+            completionHandler(.useCredential, credential)\n+          }))\n+      present(alertController, animated: true, completion: nil)\n+    default:\n+      completionHandler(.rejectProtectionSpace, nil)\n     }\n-    \n-    func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation, withError error: Error) {\n-        print(\"webView:\\(webView) didFailProvisionalNavigation:\\(navigation) withError:\\(error)\")\n-    }\n-    \n-    // MARK: WKUIDelegate methods\n-    \n-    func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: (@escaping () -> Void)) {\n-        print(\"webView:\\(webView) runJavaScriptAlertPanelWithMessage:\\(message) initiatedByFrame:\\(frame) completionHandler:\\(completionHandler)\")\n-        \n-        let alertController = UIAlertController(title: frame.request.url?.host, message: message, preferredStyle: .alert)\n-        alertController.addAction(UIAlertAction(title: \"OK\", style: .default, handler: { action in\n-            completionHandler()\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView,\n+    didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation\n+  ) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didReceiveServerRedirectForProvisionalNavigation:\\(navigation)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 679}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4ODcyNw==", "bodyText": "and here", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391788727", "createdAt": "2020-03-12T17:44:46Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ResourceUI/ResourceDetailViewController.swift", "diffHunk": "@@ -1,498 +1,526 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import MessageUI\n-import WebKit\n import SafariServices\n-//let resourcesDownloadPath = AKUtility.baseFilePath + \"/Resources\"\n+import UIKit\n+import WebKit\n \n class ResourceDetailViewController: UIViewController {\n-    \n-    @IBOutlet var webViewContainer: UIView?\n-    var webView: WKWebView?\n-    \n-    @IBOutlet var progressBar: UIProgressView?\n-    @IBOutlet var bottomToolBar: UIToolbar?\n-    \n-    \n-    var activityIndicator: UIActivityIndicatorView!\n-    var requestLink: String?\n-    var type: String?\n-    var htmlString: String?\n-    var resource: Resource?\n-    var isEmailComposerPresented: Bool?\n-    var fdm:FileDownloadManager = FileDownloadManager()\n-    \n-    override func viewDidLoad() {\n-        \n-        super.viewDidLoad()\n-        self.hidesBottomBarWhenPushed = true\n-        self.addBackBarButton()\n-        self.isEmailComposerPresented = false\n-        self.title = resource?.title\n-        \n-        _ = WKWebViewConfiguration()\n-        \n-        let jscript = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n-        \n-        let userScript = WKUserScript(source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n-        \n-        let wkUController = WKUserContentController()\n-        \n-        wkUController.addUserScript(userScript)\n-        \n-        let wkWebConfig = WKWebViewConfiguration()\n-        \n-        wkWebConfig.userContentController = wkUController\n-        \n-        \n-        let webViewFrame = CGRect.init(x: 0, y: 0, width: (webViewContainer?.frame.width)!, height: (webViewContainer?.frame.height)! - 44.0)\n-        \n-        webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n-        \n-       \n-        webViewContainer?.addSubview(webView!)\n-       \n-    }\n-    \n-    override func viewDidLayoutSubviews() {\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer, attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer, attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer, attribute:.top, multiplier: 1.0, constant:0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer, attribute:.bottom, multiplier: 1.0, constant:-44.0).isActive = true\n-    \n-        webView?.translatesAutoresizingMaskIntoConstraints = false\n-        \n-    }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-        \n-        if self.isEmailComposerPresented == false{\n-        \n-        \n-        if self.resource?.file?.link != nil {\n-            \n-            activityIndicator = UIActivityIndicatorView(style: .gray)\n-            activityIndicator.center = CGPoint(x: self.view.frame.midX, y: self.view.frame.midY-100)\n-            \n-           \n-            self.view.addSubview(activityIndicator)\n-            \n-            \n-            activityIndicator.startAnimating()\n-             self.activityIndicator.hidesWhenStopped = true\n-            if self.resource?.file?.mimeType == .pdf {\n-                \n-                if self.resource?.file?.localPath != nil {\n-                    \n-                    if self.resource?.file?.localPath == \"BundlePath\" {\n-                        \n-                        let path = Bundle.main.path(forResource: self.resource?.file?.link!, ofType: \".pdf\")\n-                        self.loadWebViewWithPath(path: path!)\n-                    } else {\n-                        let path = resourcesDownloadPath + \"/\" + (self.resource?.file?.localPath)!\n-                        let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                        self.loadWebViewWithData(data: pdfData!)\n-\n-                    }\n-                    \n-                                      //self.loadWebViewWithPath(path: (self.resource?.file?.localPath)!)\n-                } else {\n-                   //let path = resourcesDownloadPath + \"/PDF_linking.pdf\"\n-                    self.startDownloadingfile()\n-                    //let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                    //self.loadWebViewWithData(data: pdfData!)\n-                }\n-            } else {\n-                \n-                 webView?.allowsBackForwardNavigationGestures = true\n-                \n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n-            }\n+\n+  // MARK: - Outles\n+  @IBOutlet var webViewContainer: UIView?\n+  @IBOutlet var progressBar: UIProgressView?\n+  @IBOutlet var bottomToolBar: UIToolbar?\n+\n+  // MARK: - Properties\n+  var webView: WKWebView?\n+\n+  var activityIndicator: UIActivityIndicatorView!\n+  var requestLink: String?\n+  var type: String?\n+  var htmlString: String?\n+  var resource: Resource?\n+  var isEmailComposerPresented: Bool?\n+  lazy var fdm: FileDownloadManager = FileDownloadManager()\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    self.hidesBottomBarWhenPushed = true\n+    self.addBackBarButton()\n+    self.isEmailComposerPresented = false\n+    self.title = resource?.title\n+\n+    _ = WKWebViewConfiguration()\n+\n+    let jscript\n+      = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n+\n+    let userScript = WKUserScript(\n+      source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n+\n+    let wkUController = WKUserContentController()\n+    wkUController.addUserScript(userScript)\n+\n+    let wkWebConfig = WKWebViewConfiguration()\n+    wkWebConfig.userContentController = wkUController\n+\n+    let bottomBarHeight: CGFloat = 44.0\n+\n+    let webViewFrame = CGRect(\n+      x: 0, y: 0, width: (webViewContainer?.frame.width)!,\n+      height: (webViewContainer?.frame.height)! - bottomBarHeight)\n+\n+    webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n+    webViewContainer?.addSubview(webView!)\n+\n+  }\n+\n+  override func viewDidLayoutSubviews() {\n+    super.viewDidLayoutSubviews()\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .top,\n+      multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .bottom, multiplier: 1.0, constant: -44.0).isActive = true\n+\n+    webView?.translatesAutoresizingMaskIntoConstraints = false\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    if self.isEmailComposerPresented == false,\n+      self.resource?.file?.link != nil {\n+\n+      activityIndicator = UIActivityIndicatorView(style: .gray)\n+      activityIndicator.center = CGPoint(\n+        x: self.view.frame.midX, y: self.view.frame.midY-100)\n+\n+      self.view.addSubview(activityIndicator)\n+\n+      activityIndicator.startAnimating()\n+      self.activityIndicator.hidesWhenStopped = true\n+      if self.resource?.file?.mimeType == .pdf {\n+\n+        if self.resource?.file?.localPath != nil {\n+\n+          if self.resource?.file?.localPath == \"BundlePath\" {\n+\n+            let path = Bundle.main.path(\n+              forResource: self.resource?.file?.link!, ofType: \".pdf\")\n+            self.loadWebViewWithPath(path: path!)\n+          } else {\n+            let path = resourcesDownloadPath + \"/\" + (\n+              self.resource?.file?.localPath\n+            )!\n+            let pdfData = FileDownloadManager.decrytFile(pathURL: URL(string: path))\n+            self.loadWebViewWithData(data: pdfData!)\n+\n+          }\n         } else {\n-            \n-        }\n-        \n-        webView?.uiDelegate = self\n-        webView?.navigationDelegate = self\n+          self.startDownloadingfile()\n         }\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-    }\n-    \n-    override func viewWillDisappear(_ animated: Bool) {\n-        // self.tabBar.isHidden = false\n-    }\n-    \n-    func loadWebViewWithPath(path:String) {\n-        \n-        let url:URL? = URL.init(string:path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n-        let urlRequest = URLRequest(url: url!)\n-        \n-        \n-    \n+      } else {\n         webView?.allowsBackForwardNavigationGestures = true\n-        _ = webView?.load(urlRequest)\n-       // webView?.loadRequest(urlRequest)\n-    }\n-    \n-    func loadWebViewWithData(data: Data) {\n-        \n-         webView?.allowsBackForwardNavigationGestures = true\n-        \n-       _ = self.webView?.load(data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\", baseURL: URL.init(fileURLWithPath: \"\"))\n-        \n-       // self.webView?.load(data, mimeType: \"application/pdf\", textEncodingName: \"UTF-8\", baseURL:URL.init(fileURLWithPath: \"\") )\n-        \n-    }\n-    \n-    func startDownloadingfile(){\n-        \n-        if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n-            try! FileManager.default.createDirectory(atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n-        }\n-        //debugprint(\"custom download path: \\(resourcesDownloadPath)\")\n-        \n-       \n-        \n-        let fileURL =  (self.resource?.file?.link)!\n-        \n-        let url = URL(string:fileURL)\n-        \n-        var fileName : NSString = url!.lastPathComponent as NSString\n-        \n-        fileName = AKUtility.getUniqueFileNameWithPath((resourcesDownloadPath as NSString).appendingPathComponent(fileName as String) as NSString)\n-        \n-        fdm = FileDownloadManager()\n-        fdm.delegate = self\n-        //let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!\n-        //fdm.downloadFile(fileName as String, fileURL: fileURL.addingPercentEscapes(using: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!, destinationPath: resourcesDownloadPath)\n-        guard let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed) else {return}\n-        fdm.downloadFile(fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n-    }\n-    \n-    \n-    // MARK:Button Actions\n-    \n-    @IBAction func cancelButtonClicked(_ sender : Any) {\n-        self.dismiss(animated: true, completion: nil)\n-    }\n-    \n-    @IBAction func buttonActionForward(_ sender : UIBarButtonItem) {\n-        \n-        self.sendEmail()\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+      }\n+\n+      webView?.uiDelegate = self\n+      webView?.navigationDelegate = self\n     }\n-    \n-    @IBAction func buttonActionBack(_ sender : UIBarButtonItem) {\n-       \n-        if (webView?.canGoBack)!{\n-           _ =  webView?.goBack()\n-        } else if webView?.backForwardList.backList.count == 0 {\n-            if  self.resource?.file?.mimeType != .pdf {\n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+  }\n \n-            }\n-        }\n+  /// To Load web page with `URL` string path.\n+  /// - Parameter path: Path of the url.\n+  func loadWebViewWithPath(path: String) {\n+\n+    guard\n+      let url: URL = URL(\n+        string: path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n+    else { return }\n+    let urlRequest = URLRequest(url: url)\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+    _ = webView?.load(urlRequest)\n+\n+  }\n+\n+  func loadWebViewWithData(data: Data) {\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+\n+    _ = self.webView?.load(\n+      data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\",\n+      baseURL: URL.init(fileURLWithPath: \"\"))\n+\n+  }\n+\n+  func startDownloadingfile() {\n+\n+    if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n+      try! FileManager.default.createDirectory(\n+        atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n     }\n-    \n-    @IBAction func buttonActionGoForward(_ sender : UIBarButtonItem) {\n-        if (webView?.canGoForward)! {\n-           _ = webView?.goForward()\n-        }\n+\n+    let fileURL = (self.resource?.file?.link)!\n+\n+    let url = URL(string: fileURL)\n+\n+    var fileName: NSString = url!.lastPathComponent as NSString\n+\n+    fileName = AKUtility.getUniqueFileNameWithPath(\n+      (resourcesDownloadPath as NSString).appendingPathComponent(fileName as String)\n+        as NSString)\n+\n+    fdm = FileDownloadManager()\n+    fdm.delegate = self\n+\n+    guard\n+      let encodedURL = fileURL.addingPercentEncoding(\n+        withAllowedCharacters: CharacterSet.urlQueryAllowed)\n+    else { return }\n+    fdm.downloadFile(\n+      fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  @IBAction func cancelButtonClicked(_ sender: Any) {\n+    self.dismiss(animated: true, completion: nil)\n+  }\n+\n+  @IBAction func buttonActionForward(_ sender: UIBarButtonItem) {\n+    self.sendEmail()\n+  }\n+\n+  @IBAction func buttonActionBack(_ sender: UIBarButtonItem) {\n+\n+    if (webView?.canGoBack)! {\n+      _ = webView?.goBack()\n+    } else if webView?.backForwardList.backList.count == 0 {\n+      if self.resource?.file?.mimeType != .pdf {\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+\n+      }\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  }\n+\n+  @IBAction func buttonActionGoForward(_ sender: UIBarButtonItem) {\n+    if (webView?.canGoForward)! {\n+      _ = webView?.goForward()\n     }\n+  }\n+\n }\n \n-extension ResourceDetailViewController:UIWebViewDelegate {\n-    \n-    func webViewDidFinishLoad(_ webView: UIWebView) {\n-        self.activityIndicator.stopAnimating()\n-       \n-    }\n-    func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n-        self.activityIndicator.stopAnimating()\n-      \n-        \n-        let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n-        let alert = UIAlertController(title:NSLocalizedString(kTitleError, comment: \"\"),message:error.localizedDescription,preferredStyle: UIAlertController.Style.alert)\n-        \n-        alert.addAction(UIAlertAction.init(title:buttonTitleOK, style: .default, handler: { (action) in\n-            \n-            self.dismiss(animated: true, completion: nil)\n-            \n+extension ResourceDetailViewController: UIWebViewDelegate {\n+\n+  func webViewDidFinishLoad(_ webView: UIWebView) {\n+    self.activityIndicator.stopAnimating()\n+  }\n+\n+  func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n+    self.activityIndicator.stopAnimating()\n+\n+    let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n+    let alert = UIAlertController(\n+      title: NSLocalizedString(kTitleError, comment: \"\"), message: error.localizedDescription,\n+      preferredStyle: UIAlertController.Style.alert)\n+\n+    alert.addAction(\n+      UIAlertAction.init(\n+        title: buttonTitleOK, style: .default,\n+        handler: { (_) in\n+\n+          self.dismiss(animated: true, completion: nil)\n+\n         }))\n-        \n-        \n-        self.present(alert, animated: true, completion: nil)\n-        \n-        \n-    }\n+\n+    self.present(alert, animated: true, completion: nil)\n+\n+  }\n }\n \n-extension ResourceDetailViewController:WKUIDelegate,WKNavigationDelegate{\n-    \n-    \n-    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: (@escaping (WKNavigationActionPolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationAction:\\(navigationAction) decisionHandler:\\(decisionHandler)\")\n-        \n-        switch navigationAction.navigationType {\n-        case .linkActivated:\n-            if navigationAction.targetFrame == nil {\n-                webView.load(navigationAction.request)\n-            }\n-        default:\n-            break\n-        }\n-        self.activityIndicator.startAnimating()\n-        decisionHandler(.allow)\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: (@escaping (WKNavigationResponsePolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationResponse:\\(navigationResponse) decisionHandler:\\(decisionHandler)\")\n-        \n-        decisionHandler(.allow)\n+extension ResourceDetailViewController: WKUIDelegate, WKNavigationDelegate {\n+\n+  func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction,\n+    decisionHandler: (@escaping (WKNavigationActionPolicy) -> Void)\n+  ) {\n+    switch navigationAction.navigationType {\n+    case .linkActivated:\n+      if navigationAction.targetFrame == nil {\n+        webView.load(navigationAction.request)\n+      }\n+    default:\n+      break\n     }\n-    \n-    func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n-        print(\"webView:\\(webView) didReceiveAuthenticationChallenge:\\(challenge) completionHandler:\\(completionHandler)\")\n-        \n-        switch (challenge.protectionSpace.authenticationMethod) {\n-        case NSURLAuthenticationMethodHTTPBasic:\n-            let alertController = UIAlertController(title: \"Authentication Required\", message: webView.url?.host, preferredStyle: .alert)\n-            weak var usernameTextField: UITextField!\n-            alertController.addTextField { textField in\n-                textField.placeholder = \"Username\"\n-                usernameTextField = textField\n-            }\n-            weak var passwordTextField: UITextField!\n-            alertController.addTextField { textField in\n-                textField.placeholder = \"Password\"\n-                textField.isSecureTextEntry = true\n-                passwordTextField = textField\n+    self.activityIndicator.startAnimating()\n+    decisionHandler(.allow)\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse,\n+    decisionHandler: (@escaping (WKNavigationResponsePolicy) -> Void)\n+  ) {\n+    decisionHandler(.allow)\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge,\n+    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void\n+  ) {\n+\n+    switch challenge.protectionSpace.authenticationMethod {\n+    case NSURLAuthenticationMethodHTTPBasic:\n+      let alertController = UIAlertController(\n+        title: \"Authentication Required\", message: webView.url?.host, preferredStyle: .alert\n+      )\n+      weak var usernameTextField: UITextField!\n+      alertController.addTextField { textField in\n+        textField.placeholder = \"Username\"\n+        usernameTextField = textField\n+      }\n+      weak var passwordTextField: UITextField!\n+      alertController.addTextField { textField in\n+        textField.placeholder = \"Password\"\n+        textField.isSecureTextEntry = true\n+        passwordTextField = textField\n+      }\n+      alertController.addAction(\n+        UIAlertAction(\n+          title: \"Cancel\", style: .cancel,\n+          handler: { _ in\n+            completionHandler(.cancelAuthenticationChallenge, nil)\n+          }))\n+      alertController.addAction(\n+        UIAlertAction(\n+          title: \"Log In\", style: .default,\n+          handler: { _ in\n+            guard let username = usernameTextField.text,\n+              let password = passwordTextField.text\n+            else {\n+              completionHandler(.rejectProtectionSpace, nil)\n+              return\n             }\n-            alertController.addAction(UIAlertAction(title: \"Cancel\", style: .cancel, handler: { action in\n-                completionHandler(.cancelAuthenticationChallenge, nil)\n-            }))\n-            alertController.addAction(UIAlertAction(title: \"Log In\", style: .default, handler: { action in\n-                guard let username = usernameTextField.text, let password = passwordTextField.text else {\n-                    completionHandler(.rejectProtectionSpace, nil)\n-                    return\n-                }\n-                let credential = URLCredential(user: username, password: password, persistence: URLCredential.Persistence.forSession)\n-                completionHandler(.useCredential, credential)\n-            }))\n-            present(alertController, animated: true, completion: nil)\n-        default:\n-            completionHandler(.rejectProtectionSpace, nil);\n-        }\n-    }\n-    \n-    func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didReceiveServerRedirectForProvisionalNavigation:\\(navigation)\")\n-    }\n- \n-    \n-    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didFinishNavigation:\\(navigation)\")\n-        \n-        self.activityIndicator.stopAnimating()\n-        \n-    }\n-    \n-    func webView(_ webView: WKWebView, didFail navigation: WKNavigation, withError error: Error) {\n-        print(\"webView:\\(webView) didFailNavigation:\\(navigation) withError:\\(error)\")\n-        \n-        let alert = UIAlertController(title: \"Error\", message: error.localizedDescription, preferredStyle: .alert)\n-        alert.addAction(UIAlertAction(title: \"Ok\", style: .default, handler: nil))\n-        present(alert, animated: true, completion: nil)\n+            let credential = URLCredential(\n+              user: username, password: password,\n+              persistence: URLCredential.Persistence.forSession)\n+            completionHandler(.useCredential, credential)\n+          }))\n+      present(alertController, animated: true, completion: nil)\n+    default:\n+      completionHandler(.rejectProtectionSpace, nil)\n     }\n-    \n-    func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation, withError error: Error) {\n-        print(\"webView:\\(webView) didFailProvisionalNavigation:\\(navigation) withError:\\(error)\")\n-    }\n-    \n-    // MARK: WKUIDelegate methods\n-    \n-    func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: (@escaping () -> Void)) {\n-        print(\"webView:\\(webView) runJavaScriptAlertPanelWithMessage:\\(message) initiatedByFrame:\\(frame) completionHandler:\\(completionHandler)\")\n-        \n-        let alertController = UIAlertController(title: frame.request.url?.host, message: message, preferredStyle: .alert)\n-        alertController.addAction(UIAlertAction(title: \"OK\", style: .default, handler: { action in\n-            completionHandler()\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView,\n+    didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation\n+  ) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didReceiveServerRedirectForProvisionalNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(_ webView: WKWebView, didFinish navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didFinishNavigation:\\(navigation)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 683}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4ODc5Ng==", "bodyText": "and here", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391788796", "createdAt": "2020-03-12T17:44:53Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ResourceUI/ResourceDetailViewController.swift", "diffHunk": "@@ -1,498 +1,526 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import MessageUI\n-import WebKit\n import SafariServices\n-//let resourcesDownloadPath = AKUtility.baseFilePath + \"/Resources\"\n+import UIKit\n+import WebKit\n \n class ResourceDetailViewController: UIViewController {\n-    \n-    @IBOutlet var webViewContainer: UIView?\n-    var webView: WKWebView?\n-    \n-    @IBOutlet var progressBar: UIProgressView?\n-    @IBOutlet var bottomToolBar: UIToolbar?\n-    \n-    \n-    var activityIndicator: UIActivityIndicatorView!\n-    var requestLink: String?\n-    var type: String?\n-    var htmlString: String?\n-    var resource: Resource?\n-    var isEmailComposerPresented: Bool?\n-    var fdm:FileDownloadManager = FileDownloadManager()\n-    \n-    override func viewDidLoad() {\n-        \n-        super.viewDidLoad()\n-        self.hidesBottomBarWhenPushed = true\n-        self.addBackBarButton()\n-        self.isEmailComposerPresented = false\n-        self.title = resource?.title\n-        \n-        _ = WKWebViewConfiguration()\n-        \n-        let jscript = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n-        \n-        let userScript = WKUserScript(source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n-        \n-        let wkUController = WKUserContentController()\n-        \n-        wkUController.addUserScript(userScript)\n-        \n-        let wkWebConfig = WKWebViewConfiguration()\n-        \n-        wkWebConfig.userContentController = wkUController\n-        \n-        \n-        let webViewFrame = CGRect.init(x: 0, y: 0, width: (webViewContainer?.frame.width)!, height: (webViewContainer?.frame.height)! - 44.0)\n-        \n-        webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n-        \n-       \n-        webViewContainer?.addSubview(webView!)\n-       \n-    }\n-    \n-    override func viewDidLayoutSubviews() {\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer, attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer, attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer, attribute:.top, multiplier: 1.0, constant:0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer, attribute:.bottom, multiplier: 1.0, constant:-44.0).isActive = true\n-    \n-        webView?.translatesAutoresizingMaskIntoConstraints = false\n-        \n-    }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-        \n-        if self.isEmailComposerPresented == false{\n-        \n-        \n-        if self.resource?.file?.link != nil {\n-            \n-            activityIndicator = UIActivityIndicatorView(style: .gray)\n-            activityIndicator.center = CGPoint(x: self.view.frame.midX, y: self.view.frame.midY-100)\n-            \n-           \n-            self.view.addSubview(activityIndicator)\n-            \n-            \n-            activityIndicator.startAnimating()\n-             self.activityIndicator.hidesWhenStopped = true\n-            if self.resource?.file?.mimeType == .pdf {\n-                \n-                if self.resource?.file?.localPath != nil {\n-                    \n-                    if self.resource?.file?.localPath == \"BundlePath\" {\n-                        \n-                        let path = Bundle.main.path(forResource: self.resource?.file?.link!, ofType: \".pdf\")\n-                        self.loadWebViewWithPath(path: path!)\n-                    } else {\n-                        let path = resourcesDownloadPath + \"/\" + (self.resource?.file?.localPath)!\n-                        let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                        self.loadWebViewWithData(data: pdfData!)\n-\n-                    }\n-                    \n-                                      //self.loadWebViewWithPath(path: (self.resource?.file?.localPath)!)\n-                } else {\n-                   //let path = resourcesDownloadPath + \"/PDF_linking.pdf\"\n-                    self.startDownloadingfile()\n-                    //let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                    //self.loadWebViewWithData(data: pdfData!)\n-                }\n-            } else {\n-                \n-                 webView?.allowsBackForwardNavigationGestures = true\n-                \n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n-            }\n+\n+  // MARK: - Outles\n+  @IBOutlet var webViewContainer: UIView?\n+  @IBOutlet var progressBar: UIProgressView?\n+  @IBOutlet var bottomToolBar: UIToolbar?\n+\n+  // MARK: - Properties\n+  var webView: WKWebView?\n+\n+  var activityIndicator: UIActivityIndicatorView!\n+  var requestLink: String?\n+  var type: String?\n+  var htmlString: String?\n+  var resource: Resource?\n+  var isEmailComposerPresented: Bool?\n+  lazy var fdm: FileDownloadManager = FileDownloadManager()\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    self.hidesBottomBarWhenPushed = true\n+    self.addBackBarButton()\n+    self.isEmailComposerPresented = false\n+    self.title = resource?.title\n+\n+    _ = WKWebViewConfiguration()\n+\n+    let jscript\n+      = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n+\n+    let userScript = WKUserScript(\n+      source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n+\n+    let wkUController = WKUserContentController()\n+    wkUController.addUserScript(userScript)\n+\n+    let wkWebConfig = WKWebViewConfiguration()\n+    wkWebConfig.userContentController = wkUController\n+\n+    let bottomBarHeight: CGFloat = 44.0\n+\n+    let webViewFrame = CGRect(\n+      x: 0, y: 0, width: (webViewContainer?.frame.width)!,\n+      height: (webViewContainer?.frame.height)! - bottomBarHeight)\n+\n+    webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n+    webViewContainer?.addSubview(webView!)\n+\n+  }\n+\n+  override func viewDidLayoutSubviews() {\n+    super.viewDidLayoutSubviews()\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .top,\n+      multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .bottom, multiplier: 1.0, constant: -44.0).isActive = true\n+\n+    webView?.translatesAutoresizingMaskIntoConstraints = false\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    if self.isEmailComposerPresented == false,\n+      self.resource?.file?.link != nil {\n+\n+      activityIndicator = UIActivityIndicatorView(style: .gray)\n+      activityIndicator.center = CGPoint(\n+        x: self.view.frame.midX, y: self.view.frame.midY-100)\n+\n+      self.view.addSubview(activityIndicator)\n+\n+      activityIndicator.startAnimating()\n+      self.activityIndicator.hidesWhenStopped = true\n+      if self.resource?.file?.mimeType == .pdf {\n+\n+        if self.resource?.file?.localPath != nil {\n+\n+          if self.resource?.file?.localPath == \"BundlePath\" {\n+\n+            let path = Bundle.main.path(\n+              forResource: self.resource?.file?.link!, ofType: \".pdf\")\n+            self.loadWebViewWithPath(path: path!)\n+          } else {\n+            let path = resourcesDownloadPath + \"/\" + (\n+              self.resource?.file?.localPath\n+            )!\n+            let pdfData = FileDownloadManager.decrytFile(pathURL: URL(string: path))\n+            self.loadWebViewWithData(data: pdfData!)\n+\n+          }\n         } else {\n-            \n-        }\n-        \n-        webView?.uiDelegate = self\n-        webView?.navigationDelegate = self\n+          self.startDownloadingfile()\n         }\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-    }\n-    \n-    override func viewWillDisappear(_ animated: Bool) {\n-        // self.tabBar.isHidden = false\n-    }\n-    \n-    func loadWebViewWithPath(path:String) {\n-        \n-        let url:URL? = URL.init(string:path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n-        let urlRequest = URLRequest(url: url!)\n-        \n-        \n-    \n+      } else {\n         webView?.allowsBackForwardNavigationGestures = true\n-        _ = webView?.load(urlRequest)\n-       // webView?.loadRequest(urlRequest)\n-    }\n-    \n-    func loadWebViewWithData(data: Data) {\n-        \n-         webView?.allowsBackForwardNavigationGestures = true\n-        \n-       _ = self.webView?.load(data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\", baseURL: URL.init(fileURLWithPath: \"\"))\n-        \n-       // self.webView?.load(data, mimeType: \"application/pdf\", textEncodingName: \"UTF-8\", baseURL:URL.init(fileURLWithPath: \"\") )\n-        \n-    }\n-    \n-    func startDownloadingfile(){\n-        \n-        if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n-            try! FileManager.default.createDirectory(atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n-        }\n-        //debugprint(\"custom download path: \\(resourcesDownloadPath)\")\n-        \n-       \n-        \n-        let fileURL =  (self.resource?.file?.link)!\n-        \n-        let url = URL(string:fileURL)\n-        \n-        var fileName : NSString = url!.lastPathComponent as NSString\n-        \n-        fileName = AKUtility.getUniqueFileNameWithPath((resourcesDownloadPath as NSString).appendingPathComponent(fileName as String) as NSString)\n-        \n-        fdm = FileDownloadManager()\n-        fdm.delegate = self\n-        //let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!\n-        //fdm.downloadFile(fileName as String, fileURL: fileURL.addingPercentEscapes(using: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!, destinationPath: resourcesDownloadPath)\n-        guard let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed) else {return}\n-        fdm.downloadFile(fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n-    }\n-    \n-    \n-    // MARK:Button Actions\n-    \n-    @IBAction func cancelButtonClicked(_ sender : Any) {\n-        self.dismiss(animated: true, completion: nil)\n-    }\n-    \n-    @IBAction func buttonActionForward(_ sender : UIBarButtonItem) {\n-        \n-        self.sendEmail()\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+      }\n+\n+      webView?.uiDelegate = self\n+      webView?.navigationDelegate = self\n     }\n-    \n-    @IBAction func buttonActionBack(_ sender : UIBarButtonItem) {\n-       \n-        if (webView?.canGoBack)!{\n-           _ =  webView?.goBack()\n-        } else if webView?.backForwardList.backList.count == 0 {\n-            if  self.resource?.file?.mimeType != .pdf {\n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+  }\n \n-            }\n-        }\n+  /// To Load web page with `URL` string path.\n+  /// - Parameter path: Path of the url.\n+  func loadWebViewWithPath(path: String) {\n+\n+    guard\n+      let url: URL = URL(\n+        string: path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n+    else { return }\n+    let urlRequest = URLRequest(url: url)\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+    _ = webView?.load(urlRequest)\n+\n+  }\n+\n+  func loadWebViewWithData(data: Data) {\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+\n+    _ = self.webView?.load(\n+      data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\",\n+      baseURL: URL.init(fileURLWithPath: \"\"))\n+\n+  }\n+\n+  func startDownloadingfile() {\n+\n+    if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n+      try! FileManager.default.createDirectory(\n+        atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n     }\n-    \n-    @IBAction func buttonActionGoForward(_ sender : UIBarButtonItem) {\n-        if (webView?.canGoForward)! {\n-           _ = webView?.goForward()\n-        }\n+\n+    let fileURL = (self.resource?.file?.link)!\n+\n+    let url = URL(string: fileURL)\n+\n+    var fileName: NSString = url!.lastPathComponent as NSString\n+\n+    fileName = AKUtility.getUniqueFileNameWithPath(\n+      (resourcesDownloadPath as NSString).appendingPathComponent(fileName as String)\n+        as NSString)\n+\n+    fdm = FileDownloadManager()\n+    fdm.delegate = self\n+\n+    guard\n+      let encodedURL = fileURL.addingPercentEncoding(\n+        withAllowedCharacters: CharacterSet.urlQueryAllowed)\n+    else { return }\n+    fdm.downloadFile(\n+      fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  @IBAction func cancelButtonClicked(_ sender: Any) {\n+    self.dismiss(animated: true, completion: nil)\n+  }\n+\n+  @IBAction func buttonActionForward(_ sender: UIBarButtonItem) {\n+    self.sendEmail()\n+  }\n+\n+  @IBAction func buttonActionBack(_ sender: UIBarButtonItem) {\n+\n+    if (webView?.canGoBack)! {\n+      _ = webView?.goBack()\n+    } else if webView?.backForwardList.backList.count == 0 {\n+      if self.resource?.file?.mimeType != .pdf {\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+\n+      }\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  }\n+\n+  @IBAction func buttonActionGoForward(_ sender: UIBarButtonItem) {\n+    if (webView?.canGoForward)! {\n+      _ = webView?.goForward()\n     }\n+  }\n+\n }\n \n-extension ResourceDetailViewController:UIWebViewDelegate {\n-    \n-    func webViewDidFinishLoad(_ webView: UIWebView) {\n-        self.activityIndicator.stopAnimating()\n-       \n-    }\n-    func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n-        self.activityIndicator.stopAnimating()\n-      \n-        \n-        let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n-        let alert = UIAlertController(title:NSLocalizedString(kTitleError, comment: \"\"),message:error.localizedDescription,preferredStyle: UIAlertController.Style.alert)\n-        \n-        alert.addAction(UIAlertAction.init(title:buttonTitleOK, style: .default, handler: { (action) in\n-            \n-            self.dismiss(animated: true, completion: nil)\n-            \n+extension ResourceDetailViewController: UIWebViewDelegate {\n+\n+  func webViewDidFinishLoad(_ webView: UIWebView) {\n+    self.activityIndicator.stopAnimating()\n+  }\n+\n+  func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n+    self.activityIndicator.stopAnimating()\n+\n+    let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n+    let alert = UIAlertController(\n+      title: NSLocalizedString(kTitleError, comment: \"\"), message: error.localizedDescription,\n+      preferredStyle: UIAlertController.Style.alert)\n+\n+    alert.addAction(\n+      UIAlertAction.init(\n+        title: buttonTitleOK, style: .default,\n+        handler: { (_) in\n+\n+          self.dismiss(animated: true, completion: nil)\n+\n         }))\n-        \n-        \n-        self.present(alert, animated: true, completion: nil)\n-        \n-        \n-    }\n+\n+    self.present(alert, animated: true, completion: nil)\n+\n+  }\n }\n \n-extension ResourceDetailViewController:WKUIDelegate,WKNavigationDelegate{\n-    \n-    \n-    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: (@escaping (WKNavigationActionPolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationAction:\\(navigationAction) decisionHandler:\\(decisionHandler)\")\n-        \n-        switch navigationAction.navigationType {\n-        case .linkActivated:\n-            if navigationAction.targetFrame == nil {\n-                webView.load(navigationAction.request)\n-            }\n-        default:\n-            break\n-        }\n-        self.activityIndicator.startAnimating()\n-        decisionHandler(.allow)\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: (@escaping (WKNavigationResponsePolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationResponse:\\(navigationResponse) decisionHandler:\\(decisionHandler)\")\n-        \n-        decisionHandler(.allow)\n+extension ResourceDetailViewController: WKUIDelegate, WKNavigationDelegate {\n+\n+  func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction,\n+    decisionHandler: (@escaping (WKNavigationActionPolicy) -> Void)\n+  ) {\n+    switch navigationAction.navigationType {\n+    case .linkActivated:\n+      if navigationAction.targetFrame == nil {\n+        webView.load(navigationAction.request)\n+      }\n+    default:\n+      break\n     }\n-    \n-    func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n-        print(\"webView:\\(webView) didReceiveAuthenticationChallenge:\\(challenge) completionHandler:\\(completionHandler)\")\n-        \n-        switch (challenge.protectionSpace.authenticationMethod) {\n-        case NSURLAuthenticationMethodHTTPBasic:\n-            let alertController = UIAlertController(title: \"Authentication Required\", message: webView.url?.host, preferredStyle: .alert)\n-            weak var usernameTextField: UITextField!\n-            alertController.addTextField { textField in\n-                textField.placeholder = \"Username\"\n-                usernameTextField = textField\n-            }\n-            weak var passwordTextField: UITextField!\n-            alertController.addTextField { textField in\n-                textField.placeholder = \"Password\"\n-                textField.isSecureTextEntry = true\n-                passwordTextField = textField\n+    self.activityIndicator.startAnimating()\n+    decisionHandler(.allow)\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse,\n+    decisionHandler: (@escaping (WKNavigationResponsePolicy) -> Void)\n+  ) {\n+    decisionHandler(.allow)\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge,\n+    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void\n+  ) {\n+\n+    switch challenge.protectionSpace.authenticationMethod {\n+    case NSURLAuthenticationMethodHTTPBasic:\n+      let alertController = UIAlertController(\n+        title: \"Authentication Required\", message: webView.url?.host, preferredStyle: .alert\n+      )\n+      weak var usernameTextField: UITextField!\n+      alertController.addTextField { textField in\n+        textField.placeholder = \"Username\"\n+        usernameTextField = textField\n+      }\n+      weak var passwordTextField: UITextField!\n+      alertController.addTextField { textField in\n+        textField.placeholder = \"Password\"\n+        textField.isSecureTextEntry = true\n+        passwordTextField = textField\n+      }\n+      alertController.addAction(\n+        UIAlertAction(\n+          title: \"Cancel\", style: .cancel,\n+          handler: { _ in\n+            completionHandler(.cancelAuthenticationChallenge, nil)\n+          }))\n+      alertController.addAction(\n+        UIAlertAction(\n+          title: \"Log In\", style: .default,\n+          handler: { _ in\n+            guard let username = usernameTextField.text,\n+              let password = passwordTextField.text\n+            else {\n+              completionHandler(.rejectProtectionSpace, nil)\n+              return\n             }\n-            alertController.addAction(UIAlertAction(title: \"Cancel\", style: .cancel, handler: { action in\n-                completionHandler(.cancelAuthenticationChallenge, nil)\n-            }))\n-            alertController.addAction(UIAlertAction(title: \"Log In\", style: .default, handler: { action in\n-                guard let username = usernameTextField.text, let password = passwordTextField.text else {\n-                    completionHandler(.rejectProtectionSpace, nil)\n-                    return\n-                }\n-                let credential = URLCredential(user: username, password: password, persistence: URLCredential.Persistence.forSession)\n-                completionHandler(.useCredential, credential)\n-            }))\n-            present(alertController, animated: true, completion: nil)\n-        default:\n-            completionHandler(.rejectProtectionSpace, nil);\n-        }\n-    }\n-    \n-    func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didReceiveServerRedirectForProvisionalNavigation:\\(navigation)\")\n-    }\n- \n-    \n-    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didFinishNavigation:\\(navigation)\")\n-        \n-        self.activityIndicator.stopAnimating()\n-        \n-    }\n-    \n-    func webView(_ webView: WKWebView, didFail navigation: WKNavigation, withError error: Error) {\n-        print(\"webView:\\(webView) didFailNavigation:\\(navigation) withError:\\(error)\")\n-        \n-        let alert = UIAlertController(title: \"Error\", message: error.localizedDescription, preferredStyle: .alert)\n-        alert.addAction(UIAlertAction(title: \"Ok\", style: .default, handler: nil))\n-        present(alert, animated: true, completion: nil)\n+            let credential = URLCredential(\n+              user: username, password: password,\n+              persistence: URLCredential.Persistence.forSession)\n+            completionHandler(.useCredential, credential)\n+          }))\n+      present(alertController, animated: true, completion: nil)\n+    default:\n+      completionHandler(.rejectProtectionSpace, nil)\n     }\n-    \n-    func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation, withError error: Error) {\n-        print(\"webView:\\(webView) didFailProvisionalNavigation:\\(navigation) withError:\\(error)\")\n-    }\n-    \n-    // MARK: WKUIDelegate methods\n-    \n-    func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: (@escaping () -> Void)) {\n-        print(\"webView:\\(webView) runJavaScriptAlertPanelWithMessage:\\(message) initiatedByFrame:\\(frame) completionHandler:\\(completionHandler)\")\n-        \n-        let alertController = UIAlertController(title: frame.request.url?.host, message: message, preferredStyle: .alert)\n-        alertController.addAction(UIAlertAction(title: \"OK\", style: .default, handler: { action in\n-            completionHandler()\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView,\n+    didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation\n+  ) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didReceiveServerRedirectForProvisionalNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(_ webView: WKWebView, didFinish navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didFinishNavigation:\\(navigation)\")\n+\n+    self.activityIndicator.stopAnimating()\n+\n+  }\n+\n+  func webView(_ webView: WKWebView, didFail navigation: WKNavigation, withError error: Error) {\n+    Logger.sharedInstance.error(\"webView:\\(webView) didFailNavigation:\\(navigation) withError:\\(error)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 690}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4ODk0MQ==", "bodyText": "more debug logs", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391788941", "createdAt": "2020-03-12T17:45:07Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ResourceUI/ResourceDetailViewController.swift", "diffHunk": "@@ -1,498 +1,526 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import MessageUI\n-import WebKit\n import SafariServices\n-//let resourcesDownloadPath = AKUtility.baseFilePath + \"/Resources\"\n+import UIKit\n+import WebKit\n \n class ResourceDetailViewController: UIViewController {\n-    \n-    @IBOutlet var webViewContainer: UIView?\n-    var webView: WKWebView?\n-    \n-    @IBOutlet var progressBar: UIProgressView?\n-    @IBOutlet var bottomToolBar: UIToolbar?\n-    \n-    \n-    var activityIndicator: UIActivityIndicatorView!\n-    var requestLink: String?\n-    var type: String?\n-    var htmlString: String?\n-    var resource: Resource?\n-    var isEmailComposerPresented: Bool?\n-    var fdm:FileDownloadManager = FileDownloadManager()\n-    \n-    override func viewDidLoad() {\n-        \n-        super.viewDidLoad()\n-        self.hidesBottomBarWhenPushed = true\n-        self.addBackBarButton()\n-        self.isEmailComposerPresented = false\n-        self.title = resource?.title\n-        \n-        _ = WKWebViewConfiguration()\n-        \n-        let jscript = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n-        \n-        let userScript = WKUserScript(source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n-        \n-        let wkUController = WKUserContentController()\n-        \n-        wkUController.addUserScript(userScript)\n-        \n-        let wkWebConfig = WKWebViewConfiguration()\n-        \n-        wkWebConfig.userContentController = wkUController\n-        \n-        \n-        let webViewFrame = CGRect.init(x: 0, y: 0, width: (webViewContainer?.frame.width)!, height: (webViewContainer?.frame.height)! - 44.0)\n-        \n-        webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n-        \n-       \n-        webViewContainer?.addSubview(webView!)\n-       \n-    }\n-    \n-    override func viewDidLayoutSubviews() {\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer, attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer, attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer, attribute:.top, multiplier: 1.0, constant:0.0).isActive = true\n-        \n-        NSLayoutConstraint(item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer, attribute:.bottom, multiplier: 1.0, constant:-44.0).isActive = true\n-    \n-        webView?.translatesAutoresizingMaskIntoConstraints = false\n-        \n-    }\n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-        \n-        if self.isEmailComposerPresented == false{\n-        \n-        \n-        if self.resource?.file?.link != nil {\n-            \n-            activityIndicator = UIActivityIndicatorView(style: .gray)\n-            activityIndicator.center = CGPoint(x: self.view.frame.midX, y: self.view.frame.midY-100)\n-            \n-           \n-            self.view.addSubview(activityIndicator)\n-            \n-            \n-            activityIndicator.startAnimating()\n-             self.activityIndicator.hidesWhenStopped = true\n-            if self.resource?.file?.mimeType == .pdf {\n-                \n-                if self.resource?.file?.localPath != nil {\n-                    \n-                    if self.resource?.file?.localPath == \"BundlePath\" {\n-                        \n-                        let path = Bundle.main.path(forResource: self.resource?.file?.link!, ofType: \".pdf\")\n-                        self.loadWebViewWithPath(path: path!)\n-                    } else {\n-                        let path = resourcesDownloadPath + \"/\" + (self.resource?.file?.localPath)!\n-                        let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                        self.loadWebViewWithData(data: pdfData!)\n-\n-                    }\n-                    \n-                                      //self.loadWebViewWithPath(path: (self.resource?.file?.localPath)!)\n-                } else {\n-                   //let path = resourcesDownloadPath + \"/PDF_linking.pdf\"\n-                    self.startDownloadingfile()\n-                    //let pdfData = FileDownloadManager.decrytFile(pathURL:URL(string:path))\n-                    //self.loadWebViewWithData(data: pdfData!)\n-                }\n-            } else {\n-                \n-                 webView?.allowsBackForwardNavigationGestures = true\n-                \n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n-            }\n+\n+  // MARK: - Outles\n+  @IBOutlet var webViewContainer: UIView?\n+  @IBOutlet var progressBar: UIProgressView?\n+  @IBOutlet var bottomToolBar: UIToolbar?\n+\n+  // MARK: - Properties\n+  var webView: WKWebView?\n+\n+  var activityIndicator: UIActivityIndicatorView!\n+  var requestLink: String?\n+  var type: String?\n+  var htmlString: String?\n+  var resource: Resource?\n+  var isEmailComposerPresented: Bool?\n+  lazy var fdm: FileDownloadManager = FileDownloadManager()\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    self.hidesBottomBarWhenPushed = true\n+    self.addBackBarButton()\n+    self.isEmailComposerPresented = false\n+    self.title = resource?.title\n+\n+    _ = WKWebViewConfiguration()\n+\n+    let jscript\n+      = \"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"\n+\n+    let userScript = WKUserScript(\n+      source: jscript, injectionTime: .atDocumentEnd, forMainFrameOnly: true)\n+\n+    let wkUController = WKUserContentController()\n+    wkUController.addUserScript(userScript)\n+\n+    let wkWebConfig = WKWebViewConfiguration()\n+    wkWebConfig.userContentController = wkUController\n+\n+    let bottomBarHeight: CGFloat = 44.0\n+\n+    let webViewFrame = CGRect(\n+      x: 0, y: 0, width: (webViewContainer?.frame.width)!,\n+      height: (webViewContainer?.frame.height)! - bottomBarHeight)\n+\n+    webView = WKWebView.init(frame: webViewFrame, configuration: wkWebConfig)\n+    webViewContainer?.addSubview(webView!)\n+\n+  }\n+\n+  override func viewDidLayoutSubviews() {\n+    super.viewDidLayoutSubviews()\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .left, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .left, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .right, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .right, multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .top, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .top,\n+      multiplier: 1.0, constant: 0.0).isActive = true\n+\n+    NSLayoutConstraint(\n+      item: webView!, attribute: .bottom, relatedBy: .equal, toItem: webViewContainer,\n+      attribute: .bottom, multiplier: 1.0, constant: -44.0).isActive = true\n+\n+    webView?.translatesAutoresizingMaskIntoConstraints = false\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    if self.isEmailComposerPresented == false,\n+      self.resource?.file?.link != nil {\n+\n+      activityIndicator = UIActivityIndicatorView(style: .gray)\n+      activityIndicator.center = CGPoint(\n+        x: self.view.frame.midX, y: self.view.frame.midY-100)\n+\n+      self.view.addSubview(activityIndicator)\n+\n+      activityIndicator.startAnimating()\n+      self.activityIndicator.hidesWhenStopped = true\n+      if self.resource?.file?.mimeType == .pdf {\n+\n+        if self.resource?.file?.localPath != nil {\n+\n+          if self.resource?.file?.localPath == \"BundlePath\" {\n+\n+            let path = Bundle.main.path(\n+              forResource: self.resource?.file?.link!, ofType: \".pdf\")\n+            self.loadWebViewWithPath(path: path!)\n+          } else {\n+            let path = resourcesDownloadPath + \"/\" + (\n+              self.resource?.file?.localPath\n+            )!\n+            let pdfData = FileDownloadManager.decrytFile(pathURL: URL(string: path))\n+            self.loadWebViewWithData(data: pdfData!)\n+\n+          }\n         } else {\n-            \n-        }\n-        \n-        webView?.uiDelegate = self\n-        webView?.navigationDelegate = self\n+          self.startDownloadingfile()\n         }\n-        \n-        UIApplication.shared.statusBarStyle = .default\n-    }\n-    \n-    override func viewWillDisappear(_ animated: Bool) {\n-        // self.tabBar.isHidden = false\n-    }\n-    \n-    func loadWebViewWithPath(path:String) {\n-        \n-        let url:URL? = URL.init(string:path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n-        let urlRequest = URLRequest(url: url!)\n-        \n-        \n-    \n+      } else {\n         webView?.allowsBackForwardNavigationGestures = true\n-        _ = webView?.load(urlRequest)\n-       // webView?.loadRequest(urlRequest)\n-    }\n-    \n-    func loadWebViewWithData(data: Data) {\n-        \n-         webView?.allowsBackForwardNavigationGestures = true\n-        \n-       _ = self.webView?.load(data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\", baseURL: URL.init(fileURLWithPath: \"\"))\n-        \n-       // self.webView?.load(data, mimeType: \"application/pdf\", textEncodingName: \"UTF-8\", baseURL:URL.init(fileURLWithPath: \"\") )\n-        \n-    }\n-    \n-    func startDownloadingfile(){\n-        \n-        if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n-            try! FileManager.default.createDirectory(atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n-        }\n-        //debugprint(\"custom download path: \\(resourcesDownloadPath)\")\n-        \n-       \n-        \n-        let fileURL =  (self.resource?.file?.link)!\n-        \n-        let url = URL(string:fileURL)\n-        \n-        var fileName : NSString = url!.lastPathComponent as NSString\n-        \n-        fileName = AKUtility.getUniqueFileNameWithPath((resourcesDownloadPath as NSString).appendingPathComponent(fileName as String) as NSString)\n-        \n-        fdm = FileDownloadManager()\n-        fdm.delegate = self\n-        //let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!\n-        //fdm.downloadFile(fileName as String, fileURL: fileURL.addingPercentEscapes(using: String.Encoding(rawValue: String.Encoding.utf8.rawValue))!, destinationPath: resourcesDownloadPath)\n-        guard let encodedURL = fileURL.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed) else {return}\n-        fdm.downloadFile(fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n-    }\n-    \n-    \n-    // MARK:Button Actions\n-    \n-    @IBAction func cancelButtonClicked(_ sender : Any) {\n-        self.dismiss(animated: true, completion: nil)\n-    }\n-    \n-    @IBAction func buttonActionForward(_ sender : UIBarButtonItem) {\n-        \n-        self.sendEmail()\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+      }\n+\n+      webView?.uiDelegate = self\n+      webView?.navigationDelegate = self\n     }\n-    \n-    @IBAction func buttonActionBack(_ sender : UIBarButtonItem) {\n-       \n-        if (webView?.canGoBack)!{\n-           _ =  webView?.goBack()\n-        } else if webView?.backForwardList.backList.count == 0 {\n-            if  self.resource?.file?.mimeType != .pdf {\n-                _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+  }\n \n-            }\n-        }\n+  /// To Load web page with `URL` string path.\n+  /// - Parameter path: Path of the url.\n+  func loadWebViewWithPath(path: String) {\n+\n+    guard\n+      let url: URL = URL(\n+        string: path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!)\n+    else { return }\n+    let urlRequest = URLRequest(url: url)\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+    _ = webView?.load(urlRequest)\n+\n+  }\n+\n+  func loadWebViewWithData(data: Data) {\n+\n+    webView?.allowsBackForwardNavigationGestures = true\n+\n+    _ = self.webView?.load(\n+      data, mimeType: \"application/pdf\", characterEncodingName: \"UTF-8\",\n+      baseURL: URL.init(fileURLWithPath: \"\"))\n+\n+  }\n+\n+  func startDownloadingfile() {\n+\n+    if !FileManager.default.fileExists(atPath: resourcesDownloadPath) {\n+      try! FileManager.default.createDirectory(\n+        atPath: resourcesDownloadPath, withIntermediateDirectories: true, attributes: nil)\n     }\n-    \n-    @IBAction func buttonActionGoForward(_ sender : UIBarButtonItem) {\n-        if (webView?.canGoForward)! {\n-           _ = webView?.goForward()\n-        }\n+\n+    let fileURL = (self.resource?.file?.link)!\n+\n+    let url = URL(string: fileURL)\n+\n+    var fileName: NSString = url!.lastPathComponent as NSString\n+\n+    fileName = AKUtility.getUniqueFileNameWithPath(\n+      (resourcesDownloadPath as NSString).appendingPathComponent(fileName as String)\n+        as NSString)\n+\n+    fdm = FileDownloadManager()\n+    fdm.delegate = self\n+\n+    guard\n+      let encodedURL = fileURL.addingPercentEncoding(\n+        withAllowedCharacters: CharacterSet.urlQueryAllowed)\n+    else { return }\n+    fdm.downloadFile(\n+      fileName as String, fileURL: encodedURL, destinationPath: resourcesDownloadPath)\n+  }\n+\n+  // MARK: - Button Actions\n+\n+  @IBAction func cancelButtonClicked(_ sender: Any) {\n+    self.dismiss(animated: true, completion: nil)\n+  }\n+\n+  @IBAction func buttonActionForward(_ sender: UIBarButtonItem) {\n+    self.sendEmail()\n+  }\n+\n+  @IBAction func buttonActionBack(_ sender: UIBarButtonItem) {\n+\n+    if (webView?.canGoBack)! {\n+      _ = webView?.goBack()\n+    } else if webView?.backForwardList.backList.count == 0 {\n+      if self.resource?.file?.mimeType != .pdf {\n+        _ = webView?.loadHTMLString(self.requestLink!, baseURL: nil)\n+\n+      }\n     }\n-    \n-    override func didReceiveMemoryWarning() {\n-        super.didReceiveMemoryWarning()\n-        // Dispose of any resources that can be recreated.\n+  }\n+\n+  @IBAction func buttonActionGoForward(_ sender: UIBarButtonItem) {\n+    if (webView?.canGoForward)! {\n+      _ = webView?.goForward()\n     }\n+  }\n+\n }\n \n-extension ResourceDetailViewController:UIWebViewDelegate {\n-    \n-    func webViewDidFinishLoad(_ webView: UIWebView) {\n-        self.activityIndicator.stopAnimating()\n-       \n-    }\n-    func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n-        self.activityIndicator.stopAnimating()\n-      \n-        \n-        let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n-        let alert = UIAlertController(title:NSLocalizedString(kTitleError, comment: \"\"),message:error.localizedDescription,preferredStyle: UIAlertController.Style.alert)\n-        \n-        alert.addAction(UIAlertAction.init(title:buttonTitleOK, style: .default, handler: { (action) in\n-            \n-            self.dismiss(animated: true, completion: nil)\n-            \n+extension ResourceDetailViewController: UIWebViewDelegate {\n+\n+  func webViewDidFinishLoad(_ webView: UIWebView) {\n+    self.activityIndicator.stopAnimating()\n+  }\n+\n+  func webView(_ webView: UIWebView, didFailLoadWithError error: Error) {\n+    self.activityIndicator.stopAnimating()\n+\n+    let buttonTitleOK = NSLocalizedString(\"OK\", comment: \"\")\n+    let alert = UIAlertController(\n+      title: NSLocalizedString(kTitleError, comment: \"\"), message: error.localizedDescription,\n+      preferredStyle: UIAlertController.Style.alert)\n+\n+    alert.addAction(\n+      UIAlertAction.init(\n+        title: buttonTitleOK, style: .default,\n+        handler: { (_) in\n+\n+          self.dismiss(animated: true, completion: nil)\n+\n         }))\n-        \n-        \n-        self.present(alert, animated: true, completion: nil)\n-        \n-        \n-    }\n+\n+    self.present(alert, animated: true, completion: nil)\n+\n+  }\n }\n \n-extension ResourceDetailViewController:WKUIDelegate,WKNavigationDelegate{\n-    \n-    \n-    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: (@escaping (WKNavigationActionPolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationAction:\\(navigationAction) decisionHandler:\\(decisionHandler)\")\n-        \n-        switch navigationAction.navigationType {\n-        case .linkActivated:\n-            if navigationAction.targetFrame == nil {\n-                webView.load(navigationAction.request)\n-            }\n-        default:\n-            break\n-        }\n-        self.activityIndicator.startAnimating()\n-        decisionHandler(.allow)\n-    }\n-    \n-    func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: (@escaping (WKNavigationResponsePolicy) -> Void)) {\n-        print(\"webView:\\(webView) decidePolicyForNavigationResponse:\\(navigationResponse) decisionHandler:\\(decisionHandler)\")\n-        \n-        decisionHandler(.allow)\n+extension ResourceDetailViewController: WKUIDelegate, WKNavigationDelegate {\n+\n+  func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didStartProvisionalNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(_ webView: WKWebView, didCommit navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didCommitNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction,\n+    decisionHandler: (@escaping (WKNavigationActionPolicy) -> Void)\n+  ) {\n+    switch navigationAction.navigationType {\n+    case .linkActivated:\n+      if navigationAction.targetFrame == nil {\n+        webView.load(navigationAction.request)\n+      }\n+    default:\n+      break\n     }\n-    \n-    func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n-        print(\"webView:\\(webView) didReceiveAuthenticationChallenge:\\(challenge) completionHandler:\\(completionHandler)\")\n-        \n-        switch (challenge.protectionSpace.authenticationMethod) {\n-        case NSURLAuthenticationMethodHTTPBasic:\n-            let alertController = UIAlertController(title: \"Authentication Required\", message: webView.url?.host, preferredStyle: .alert)\n-            weak var usernameTextField: UITextField!\n-            alertController.addTextField { textField in\n-                textField.placeholder = \"Username\"\n-                usernameTextField = textField\n-            }\n-            weak var passwordTextField: UITextField!\n-            alertController.addTextField { textField in\n-                textField.placeholder = \"Password\"\n-                textField.isSecureTextEntry = true\n-                passwordTextField = textField\n+    self.activityIndicator.startAnimating()\n+    decisionHandler(.allow)\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse,\n+    decisionHandler: (@escaping (WKNavigationResponsePolicy) -> Void)\n+  ) {\n+    decisionHandler(.allow)\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge,\n+    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void\n+  ) {\n+\n+    switch challenge.protectionSpace.authenticationMethod {\n+    case NSURLAuthenticationMethodHTTPBasic:\n+      let alertController = UIAlertController(\n+        title: \"Authentication Required\", message: webView.url?.host, preferredStyle: .alert\n+      )\n+      weak var usernameTextField: UITextField!\n+      alertController.addTextField { textField in\n+        textField.placeholder = \"Username\"\n+        usernameTextField = textField\n+      }\n+      weak var passwordTextField: UITextField!\n+      alertController.addTextField { textField in\n+        textField.placeholder = \"Password\"\n+        textField.isSecureTextEntry = true\n+        passwordTextField = textField\n+      }\n+      alertController.addAction(\n+        UIAlertAction(\n+          title: \"Cancel\", style: .cancel,\n+          handler: { _ in\n+            completionHandler(.cancelAuthenticationChallenge, nil)\n+          }))\n+      alertController.addAction(\n+        UIAlertAction(\n+          title: \"Log In\", style: .default,\n+          handler: { _ in\n+            guard let username = usernameTextField.text,\n+              let password = passwordTextField.text\n+            else {\n+              completionHandler(.rejectProtectionSpace, nil)\n+              return\n             }\n-            alertController.addAction(UIAlertAction(title: \"Cancel\", style: .cancel, handler: { action in\n-                completionHandler(.cancelAuthenticationChallenge, nil)\n-            }))\n-            alertController.addAction(UIAlertAction(title: \"Log In\", style: .default, handler: { action in\n-                guard let username = usernameTextField.text, let password = passwordTextField.text else {\n-                    completionHandler(.rejectProtectionSpace, nil)\n-                    return\n-                }\n-                let credential = URLCredential(user: username, password: password, persistence: URLCredential.Persistence.forSession)\n-                completionHandler(.useCredential, credential)\n-            }))\n-            present(alertController, animated: true, completion: nil)\n-        default:\n-            completionHandler(.rejectProtectionSpace, nil);\n-        }\n-    }\n-    \n-    func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didReceiveServerRedirectForProvisionalNavigation:\\(navigation)\")\n-    }\n- \n-    \n-    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation) {\n-        print(\"webView:\\(webView) didFinishNavigation:\\(navigation)\")\n-        \n-        self.activityIndicator.stopAnimating()\n-        \n-    }\n-    \n-    func webView(_ webView: WKWebView, didFail navigation: WKNavigation, withError error: Error) {\n-        print(\"webView:\\(webView) didFailNavigation:\\(navigation) withError:\\(error)\")\n-        \n-        let alert = UIAlertController(title: \"Error\", message: error.localizedDescription, preferredStyle: .alert)\n-        alert.addAction(UIAlertAction(title: \"Ok\", style: .default, handler: nil))\n-        present(alert, animated: true, completion: nil)\n+            let credential = URLCredential(\n+              user: username, password: password,\n+              persistence: URLCredential.Persistence.forSession)\n+            completionHandler(.useCredential, credential)\n+          }))\n+      present(alertController, animated: true, completion: nil)\n+    default:\n+      completionHandler(.rejectProtectionSpace, nil)\n     }\n-    \n-    func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation, withError error: Error) {\n-        print(\"webView:\\(webView) didFailProvisionalNavigation:\\(navigation) withError:\\(error)\")\n-    }\n-    \n-    // MARK: WKUIDelegate methods\n-    \n-    func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: (@escaping () -> Void)) {\n-        print(\"webView:\\(webView) runJavaScriptAlertPanelWithMessage:\\(message) initiatedByFrame:\\(frame) completionHandler:\\(completionHandler)\")\n-        \n-        let alertController = UIAlertController(title: frame.request.url?.host, message: message, preferredStyle: .alert)\n-        alertController.addAction(UIAlertAction(title: \"OK\", style: .default, handler: { action in\n-            completionHandler()\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView,\n+    didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation\n+  ) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didReceiveServerRedirectForProvisionalNavigation:\\(navigation)\")\n+  }\n+\n+  func webView(_ webView: WKWebView, didFinish navigation: WKNavigation) {\n+    Logger.sharedInstance.info(\"webView:\\(webView) didFinishNavigation:\\(navigation)\")\n+\n+    self.activityIndicator.stopAnimating()\n+\n+  }\n+\n+  func webView(_ webView: WKWebView, didFail navigation: WKNavigation, withError error: Error) {\n+    Logger.sharedInstance.error(\"webView:\\(webView) didFailNavigation:\\(navigation) withError:\\(error)\")\n+\n+    let alert = UIAlertController(\n+      title: \"Error\", message: error.localizedDescription, preferredStyle: .alert)\n+    alert.addAction(UIAlertAction(title: \"Ok\", style: .default, handler: nil))\n+    present(alert, animated: true, completion: nil)\n+  }\n+\n+  func webView(\n+    _ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation,\n+    withError error: Error\n+  ) {\n+    Logger.sharedInstance.error(\"webView:\\(webView) didFailProvisionalNavigation:\\(navigation) withError:\\(error)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 702}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5MDQyNw==", "bodyText": "is that a TODO?\nif no action is needed, can we remove action2 ?", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391790427", "createdAt": "2020-03-12T17:47:37Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ResourceUI/ResourcesViewController.swift", "diffHunk": "@@ -1,886 +1,762 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n import UIKit\n \n-\n let kConsentPdfKey = \"consent\"\n \n let kUnwindToStudyListIdentifier = \"unwindeToStudyListResourcesIdentifier\"\n \n-class ResourcesViewController: UIViewController{\n-    \n-    var tableViewRowDetails: [AnyObject]? = []\n-    \n-    @IBOutlet var tableView: UITableView?\n-    var resourceLink: String?\n-    var fileType: String?\n-    var navigateToStudyOverview: Bool? = false\n-    var withdrawlInformationNotFound = false\n-    var shouldDeleteData: Bool? = false\n-    \n-    var leaveStudy:String = \"Leave Study\"\n-    var aboutTheStudy:String = \"About the Study\"\n-    var consentPDF:String = \"Consent PDF\"\n-    \n-    override var preferredStatusBarStyle: UIStatusBarStyle{\n-        return .default\n-    }\n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        \n-        \n-        //load plist info\n-        //let plistPath = Bundle.main.path(forResource: \"ResourcesUI\", ofType: \".plist\", inDirectory:nil)\n-        //tableViewRowDetails = NSMutableArray(contentsOfFile: plistPath!) as [AnyObject]?\n-        \n-        //if (Study.currentStudy?.studySettings.rejoinStudyAfterWithdrawn)! == false {\n-        //    tableViewRowDetails?.removeLast()\n-        //}\n-        \n-        self.navigationItem.title = NSLocalizedString(\"Resources\", comment: \"\")\n-        //Next Phase\n-        //WCPServices().getResourcesForStudy(studyId:(Study.currentStudy?.studyId)!, delegate: self)\n-        \n-        \n-        if StudyUpdates.studyConsentUpdated {\n-            let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-             appDelegate.checkConsentStatus(controller: self)\n-        }\n-        \n-        \n-        //Branding\n-        let brandingDetail = Utilities.getBrandingDetails()\n-        if let leavetitle =  brandingDetail?[BrandingConstant.LeaveStudy] as? String{\n-            leaveStudy = leavetitle\n-        }\n-        \n-        if let consent =  brandingDetail?[BrandingConstant.ConsentPDF] as? String{\n-            consentPDF = consent\n-        }\n-        \n-    }\n-    \n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        self.tableView?.estimatedRowHeight = 65\n-        self.tableView?.rowHeight = UITableView.automaticDimension\n-        \n-        if Utilities.isStandaloneApp() {\n-            self.setNavigationBarItem()\n-        }\n-        else {\n-            self.addHomeButton()\n-        }\n-        setNeedsStatusBarAppearanceUpdate()\n-         //UIApplication.shared.statusBarStyle = .default\n-        self.navigationController?.setNavigationBarHidden(false, animated: true)\n-        \n-        self.tabBarController?.tabBar.isHidden = false\n-        \n-        if Study.currentStudy?.withdrawalConfigration?.message == nil && ( Study.currentStudy?.withdrawalConfigration?.type == nil || Study.currentStudy?.withdrawalConfigration?.type == .notAvailable ){\n-            WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-            \n-        } else if StudyUpdates.studyInfoUpdated {\n-            WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-            \n-        } else {\n-            self.checkForResourceUpdate()\n-        }\n-        \n-        //self.checkForResourceUpdate()\n-        \n-        //self.checkForInfoUpdate()\n-        \n-        \n+class ResourcesViewController: UIViewController {\n+\n+  var tableViewRowDetails: [AnyObject]? = []\n+\n+  @IBOutlet var tableView: UITableView?\n+  var resourceLink: String?\n+  var fileType: String?\n+  var navigateToStudyOverview: Bool? = false\n+  var withdrawlInformationNotFound = false\n+  var shouldDeleteData: Bool? = false\n+\n+  var leaveStudy: String = \"Leave Study\"\n+  var aboutTheStudy: String = \"About the Study\"\n+  var consentPDF: String = \"Consent PDF\"\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  deinit {\n+    Logger.sharedInstance.info(\"\\(self): deinit\")\n+  }\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    self.navigationItem.title = NSLocalizedString(\"Resources\", comment: \"\")\n+\n+    if StudyUpdates.studyConsentUpdated {\n+      let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+      appDelegate.checkConsentStatus(controller: self)\n     }\n-    \n-    override func viewDidAppear(_ animated: Bool) {\n-        super.viewDidAppear(animated)\n-               \n+\n+    // Branding\n+    let brandingDetail = Utilities.getBrandingDetails()\n+    if let leavetitle = brandingDetail?[BrandingConstant.LeaveStudy] as? String {\n+      leaveStudy = leavetitle\n     }\n-    \n-    func checkForResourceUpdate(){\n-        \n-        if StudyUpdates.studyResourcesUpdated {\n-            WCPServices().getResourcesForStudy(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-        } else {\n-            self.checkIfResourcePresent()\n-        }\n+\n+    if let consent = brandingDetail?[BrandingConstant.ConsentPDF] as? String {\n+      consentPDF = consent\n     }\n-    \n-    func checkForInfoUpdate(){\n-        \n-        if StudyUpdates.studyInfoUpdated {\n-             WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-        }\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    self.tableView?.estimatedRowHeight = 65\n+    self.tableView?.rowHeight = UITableView.automaticDimension\n+\n+    if Utilities.isStandaloneApp() {\n+      self.setNavigationBarItem()\n+    } else {\n+      self.addHomeButton()\n     }\n-    \n-    func updateAnchorDateLifeTime() {\n-        \n-        AnchorDateHandler().fetchActivityAnchorDateForResourceFromLabkey { (status) in\n-            if status {\n-                self.loadResourceFromDatabase()\n-            }\n-        }\n+    setNeedsStatusBarAppearanceUpdate()\n+\n+    self.navigationController?.setNavigationBarHidden(false, animated: true)\n+\n+    self.tabBarController?.tabBar.isHidden = false\n+\n+    if Study.currentStudy?.withdrawalConfigration?.message == nil && (\n+      Study.currentStudy?.withdrawalConfigration?.type == nil || Study.currentStudy?\n+        .withdrawalConfigration?.type == .notAvailable\n+    ) {\n+      WCPServices().getStudyInformation(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+    } else if StudyUpdates.studyInfoUpdated {\n+      WCPServices().getStudyInformation(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+    } else {\n+      self.checkForResourceUpdate()\n     }\n-    \n-    func checkIfResourcePresent(){\n-        if DBHandler.isResourcesEmpty((Study.currentStudy?.studyId)!) {\n-            WCPServices().getResourcesForStudy(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-        }\n-        else {\n-            self.loadResourceFromDatabase()\n-        }\n+\n+  }\n+\n+  override func viewDidAppear(_ animated: Bool) {\n+    super.viewDidAppear(animated)\n+  }\n+\n+  func checkForResourceUpdate() {\n+\n+    if StudyUpdates.studyResourcesUpdated {\n+      WCPServices().getResourcesForStudy(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+    } else {\n+      self.checkIfResourcePresent()\n     }\n-    \n-    func loadResourceFromDatabase() {\n-        \n-        \n-        DBHandler.loadResourcesForStudy(studyId: (Study.currentStudy?.studyId)!) { (resources) in\n-            Study.currentStudy?.resources = resources\n-            self.handleResourcesReponse()\n-            self.updateAnchorDateLifeTime()\n-        }\n-        \n+  }\n+\n+  func checkForInfoUpdate() {\n+\n+    if StudyUpdates.studyInfoUpdated {\n+      WCPServices().getStudyInformation(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n     }\n-    \n-    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n-        if segue.identifier == \"ResourceDetailViewControllerIdentifier\"{\n-            \n-            let resourceDetail = (segue.destination as? GatewayResourceDetailViewController)!\n-            resourceDetail.resource = (sender as? Resource)!\n-            if self.resourceLink != nil{\n-                resourceDetail.requestLink = self.resourceLink!\n-            }\n-            if self.fileType != nil {\n-                resourceDetail.type = self.fileType!\n-            }\n-            resourceDetail.hidesBottomBarWhenPushed = true\n-            \n-        } else if segue.identifier == \"ResourceDetailViewSegueIdentifier\" {\n-            \n-            let resourceDetail = (segue.destination as? ResourceDetailViewController)!\n-            resourceDetail.resource = (sender as? Resource)!\n-            if self.resourceLink != nil{\n-                resourceDetail.requestLink = self.resourceLink!\n-            }\n-            if self.fileType != nil {\n-                resourceDetail.type = self.fileType!\n-            }\n-            resourceDetail.hidesBottomBarWhenPushed = true\n-            \n-        }\n+  }\n+\n+  func updateAnchorDateLifeTime() {\n+\n+    AnchorDateHandler().fetchActivityAnchorDateForResourceFromLabkey { (status) in\n+      if status {\n+        self.loadResourceFromDatabase()\n+      }\n     }\n-    \n-    \n-    @IBAction func homeButtonAction(_ sender: AnyObject){\n-        self.navigationController?.navigationBar.isHidden = false\n-        self.performSegue(withIdentifier: kUnwindToStudyListIdentifier, sender: self)\n-        \n+  }\n+\n+  func checkIfResourcePresent() {\n+    if DBHandler.isResourcesEmpty((Study.currentStudy?.studyId)!) {\n+      WCPServices().getResourcesForStudy(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+    } else {\n+      self.loadResourceFromDatabase()\n     }\n-    \n-    func addDefaultList(){\n-        \n-        //add default List\n-        \n-        tableViewRowDetails?.append(aboutTheStudy as AnyObject)\n-        tableViewRowDetails?.append(consentPDF as AnyObject)\n-        \n-//        let plistPath = Bundle.main.path(forResource: \"ResourcesUI\", ofType: \".plist\", inDirectory: nil)\n-//\n-//        let array = NSMutableArray(contentsOfFile: plistPath!) as [AnyObject]?\n-//\n-//        for title in array!{\n-//            tableViewRowDetails?.append(title)\n-//        }\n-        \n+  }\n+\n+  func loadResourceFromDatabase() {\n+\n+    DBHandler.loadResourcesForStudy(studyId: (Study.currentStudy?.studyId)!) { (resources) in\n+      Study.currentStudy?.resources = resources\n+      self.handleResourcesReponse()\n+      self.updateAnchorDateLifeTime()\n     }\n-    \n-    func appendLeaveStudy(){\n-        \n-        //append Leave Study row\n-        //if (Study.currentStudy?.studySettings.rejoinStudyAfterWithdrawn)! != false {\n-            tableViewRowDetails?.append(leaveStudy as AnyObject)\n-        //}\n+\n+  }\n+\n+  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n+    if segue.identifier == \"ResourceDetailViewControllerIdentifier\" {\n+\n+      let resourceDetail = (segue.destination as? GatewayResourceDetailViewController)!\n+      resourceDetail.resource = (sender as? Resource)!\n+      if self.resourceLink != nil {\n+        resourceDetail.requestLink = self.resourceLink!\n+      }\n+      if self.fileType != nil {\n+        resourceDetail.type = self.fileType!\n+      }\n+      resourceDetail.hidesBottomBarWhenPushed = true\n+\n+    } else if segue.identifier == \"ResourceDetailViewSegueIdentifier\" {\n+\n+      let resourceDetail = (segue.destination as? ResourceDetailViewController)!\n+      resourceDetail.resource = (sender as? Resource)!\n+      if self.resourceLink != nil {\n+        resourceDetail.requestLink = self.resourceLink!\n+      }\n+      if self.fileType != nil {\n+        resourceDetail.type = self.fileType!\n+      }\n+      resourceDetail.hidesBottomBarWhenPushed = true\n+\n     }\n-    \n-    func handleResourcesReponse() {\n-        \n-        tableViewRowDetails = []\n-        \n-        self.addDefaultList()\n-        self.appendLeaveStudy()\n-        \n-        let todayDate = Date()\n-        \n-        for  resource in (Study.currentStudy?.resources)!{\n-            \n-            if resource.startDate != nil && resource.endDate != nil {\n-                \n-                \n-                let start = resource.startDate//.startOfDay\n-                let end = resource.endDate//.endOfDay\n-                \n-                let startDateResult = (start?.compare(todayDate))! as ComparisonResult\n-                let endDateResult = (end?.compare(todayDate))! as ComparisonResult\n-                \n-                //compare lifetime\n-                if ((startDateResult == .orderedAscending || startDateResult == .orderedSame) && (endDateResult == .orderedDescending || endDateResult == .orderedSame)){\n-                    print(\"current\")\n-                    \n-                    tableViewRowDetails?.append(resource)\n-                    \n-                    //compare for today\n-                    let endOfToday = resource.startDate//.endOfDay\n-                    \n-                    if (todayDate >= start! && todayDate <= endOfToday!){\n-                        resource.availableToday = true\n-                    }\n-                    \n-                }\n-            }\n-            else {\n-                tableViewRowDetails?.append(resource)\n-            }\n+  }\n+\n+  @IBAction func homeButtonAction(_ sender: AnyObject) {\n+    self.navigationController?.navigationBar.isHidden = false\n+    self.performSegue(withIdentifier: kUnwindToStudyListIdentifier, sender: self)\n+\n+  }\n+\n+  func addDefaultList() {\n+    tableViewRowDetails?.append(aboutTheStudy as AnyObject)\n+    tableViewRowDetails?.append(consentPDF as AnyObject)\n+  }\n+\n+  func appendLeaveStudy() {\n+    // append Leave Study row\n+    tableViewRowDetails?.append(leaveStudy as AnyObject)\n+  }\n+\n+  func handleResourcesReponse() {\n+\n+    tableViewRowDetails = []\n+\n+    self.addDefaultList()\n+    self.appendLeaveStudy()\n+\n+    let todayDate = Date()\n+\n+    for resource in (Study.currentStudy?.resources)! {\n+\n+      if resource.startDate != nil && resource.endDate != nil {\n+\n+        let start = resource.startDate\n+        let end = resource.endDate\n+\n+        let startDateResult = (start?.compare(todayDate))! as ComparisonResult\n+        let endDateResult = (end?.compare(todayDate))! as ComparisonResult\n+\n+        // compare lifetime\n+        if (startDateResult == .orderedAscending || startDateResult == .orderedSame) &&\n+            (endDateResult == .orderedDescending || endDateResult == .orderedSame) {\n+\n+          tableViewRowDetails?.append(resource)\n+\n+          // compare for today\n+          let endOfToday = resource.startDate\n+\n+          if todayDate >= start! && todayDate <= endOfToday! {\n+            resource.availableToday = true\n+          }\n \n         }\n+      } else {\n+        tableViewRowDetails?.append(resource)\n+      }\n \n-        \n-        \n-        //Add resources list\n-//        for  resource in (Study.currentStudy?.resources)!{\n-//\n-//            if resource.povAvailable{\n-//                //check for startDate and endDate\n-//                if resource.startDate != nil && resource.endDate != nil {\n-//\n-//                    let start = resource.startDate?.startOfDay\n-//                    let end = resource.endDate?.endOfDay\n-//\n-//                    let startDateResult = (start?.compare(todayDate))! as ComparisonResult\n-//                    let endDateResult = (end?.compare(todayDate))! as ComparisonResult\n-//\n-//\n-//                    if ((startDateResult == .orderedAscending || startDateResult == .orderedSame) && (endDateResult == .orderedDescending || endDateResult == .orderedSame)){\n-//                        print(\"current\")\n-//\n-//                        tableViewRowDetails?.append(resource)\n-//\n-//                    }\n-//                } //check for anchorDate\n-//                else if resource.anchorDateStartDays != nil && resource.anchorDateEndDays != nil {\n-//\n-//                    let anchorDateObject = Study.currentStudy?.anchorDate\n-//                    if(anchorDateObject != nil && (anchorDateObject?.isAnchorDateAvailable())!) {\n-//\n-//\n-//\n-//                        let anchorDate = Study.currentStudy?.anchorDate?.date?.startOfDay\n-//\n-//                        if anchorDate != nil {\n-//\n-//                            //also anchor date condition\n-//                            let startDateInterval = TimeInterval(60*60*24*(resource.anchorDateStartDays)!)\n-//                            let endDateInterval = TimeInterval(60*60*24*(resource.anchorDateEndDays)!)\n-//\n-//                            let startAnchorDate = anchorDate?.addingTimeInterval(startDateInterval)\n-//                            var endAnchorDate = anchorDate?.addingTimeInterval(endDateInterval)\n-//\n-//                            endAnchorDate = endAnchorDate?.endOfDay\n-//                            let startDateResult = (startAnchorDate?.compare(todayDate))! as ComparisonResult\n-//                            let endDateResult = (endAnchorDate?.compare(todayDate))! as ComparisonResult\n-//\n-//                            if ((startDateResult == .orderedAscending || startDateResult == .orderedSame) && (endDateResult == .orderedDescending || endDateResult == .orderedSame)){\n-//\n-//                                tableViewRowDetails?.append(resource)\n-//\n-//                            } else if startDateResult == .orderedDescending {\n-//                                //upcoming\n-//                                let notfiId = resource.resourcesId! + (Study.currentStudy?.studyId)!\n-//                                DBHandler.isNotificationSetFor(notification: notfiId\n-//                                    , completionHandler: { (found) in\n-//                                        if !found {\n-//\n-//                                            let notification = AppLocalNotification()\n-//                                            notification.id = resource.resourcesId! + (Study.currentStudy?.studyId)!\n-//                                            notification.message = resource.notificationMessage\n-//                                            notification.title = \"New Resource Available\"\n-//                                            notification.startDate = startAnchorDate\n-//                                            notification.endDate = endAnchorDate\n-//                                            notification.type = AppNotification.NotificationType.Study\n-//                                            notification.subType = AppNotification.NotificationSubType.Resource\n-//                                            notification.audience = Audience.Limited\n-//                                            notification.studyId = (Study.currentStudy?.studyId)!\n-//                                            //notification.activityId = Study.currentActivity?.actvityId\n-//\n-//                                            DBHandler.saveLocalNotification(notification: notification)\n-//\n-//                                            //register notification\n-//                                            var notificationDate = startAnchorDate?.startOfDay\n-//                                            notificationDate = notificationDate?.addingTimeInterval(43200)\n-//                                            let message = resource.notificationMessage\n-//                                            let userInfo = [\"studyId\": (Study.currentStudy?.studyId)!,\n-//                                                            \"type\": \"resource\"];\n-//                                            LocalNotification.scheduleNotificationOn(date: notificationDate!, message: message!, userInfo: userInfo)\n-//                                        }\n-//                                })\n-//\n-//                            }\n-//                        }\n-//\n-//                    } else {\n-//                        tableViewRowDetails?.append(resource)\n-//                    }\n-//\n-//                } else {\n-//                    tableViewRowDetails?.append(resource)\n-//                }\n-//            } else {\n-//                 tableViewRowDetails?.append(resource)\n-//            }\n-//\n-//        }\n-        \n-        \n-        tableView?.isHidden =  false\n-        tableView?.reloadData()\n-        \n-        StudyUpdates.studyResourcesUpdated = false\n-        DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n     }\n-    \n-    func handleLeaveStudy() {\n-        \n-        var withdrawalMessage = Study.currentStudy?.withdrawalConfigration?.message\n-        \n-        var withdrawalType = Study.currentStudy?.withdrawalConfigration?.type\n-        \n-        if withdrawalMessage == nil {\n-            withdrawalMessage = \"Are you sure you want to \" + leaveStudy + \"?\"\n-        }\n-        \n-        if withdrawalType == nil || withdrawalType == .notAvailable {\n-            \n-            withdrawlInformationNotFound = true\n-            withdrawalType = .notAvailable\n-            WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-            return\n-        }\n-        \n-        \n-        UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString((leaveStudy + \" ?\"), comment: \"\"), errorMessage: NSLocalizedString(withdrawalMessage!, comment: \"\"), errorAlertActionTitle: NSLocalizedString(\"Proceed\", comment: \"\"),\n-                                                             errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"), viewControllerUsed: self,\n-                                                             action1: {\n-                                                                \n-                                                                \n-                                                                switch withdrawalType! as StudyWithdrawalConfigrationType {\n-                                                                    \n-                                                                case .askUser :\n-                                                                    \n-                                                                    UIUtilities.showAlertMessageWithThreeActionsAndHandler(kImportantNoteMessage, errorMessage: \"You are choosing to leave the study. Please choose if your response data can be retained and used for research purposes OR if your response data should be deleted.\", errorAlertActionTitle: \"Retain my data\", errorAlertActionTitle2: \"Delete my data\", errorAlertActionTitle3: \"Cancel\", viewControllerUsed: self, action1: {\n-                                                                        // Retain Action\n-                                                                        \n-                                                                        self.shouldDeleteData = false\n-                                                                        self.withdrawalFromStudy(deleteResponse: false)\n-                                                                        \n-                                                                        \n-                                                                        \n-                                                                    }, action2: {\n-                                                                        \n-                                                                        // Delete action\n-                                                                        self.shouldDeleteData = true\n-                                                                        self.withdrawalFromStudy(deleteResponse: true)\n-                                                                        \n-                                                                    }, action3: {\n-                                                                        // Cancel Action\n-                                                                    })\n-                                                                    \n-                                                                    \n-                                                                case .deleteData:\n-                                                                    \n-                                                                    UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(\"Are you sure? Tap Ok to confirm.\", comment: \"\"), errorMessage: NSLocalizedString(\"\", comment: \"\"), errorAlertActionTitle: NSLocalizedString(\"Ok\", comment: \"\"),\n-                                                                                                                         errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"), viewControllerUsed: self,\n-                                                                                                                         action1: {\n-                                                                                                                            self.shouldDeleteData = true\n-                                                                                                                            self.withdrawalFromStudy(deleteResponse: true)\n-                                                                    },\n-                                                                                                                         action2: {\n-                                                                                                                            \n-                                                                    })\n-                                                                    \n-                                                                case .noAction :\n-                                                                    \n-                                                                    UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(\"Are you sure? Tap Ok to confirm.\", comment: \"\"), errorMessage: NSLocalizedString(\"\", comment: \"\"), errorAlertActionTitle: NSLocalizedString(\"Ok\", comment: \"\"),\n-                                                                                                                         errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"), viewControllerUsed: self,\n-                                                                                                                         action1: {\n-                                                                                                                            self.shouldDeleteData = false\n-                                                                                                                            self.withdrawalFromStudy(deleteResponse: false)\n-                                                                    },\n-                                                                                                                         action2: {\n-                                                                                                                            \n-                                                                    })\n-                                                                    \n-                                                                default : break\n-                                                                }\n-                                                                \n-                                                                \n-        },\n-                                                             action2: {\n-                                                                \n-        })\n-        \n-        \n+\n+    tableView?.isHidden = false\n+    tableView?.reloadData()\n+\n+    StudyUpdates.studyResourcesUpdated = false\n+    DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n+  }\n+\n+  func handleLeaveStudy() {\n+\n+    var withdrawalMessage = Study.currentStudy?.withdrawalConfigration?.message\n+\n+    var withdrawalType = Study.currentStudy?.withdrawalConfigration?.type\n+\n+    if withdrawalMessage == nil {\n+      withdrawalMessage = \"Are you sure you want to \" + leaveStudy + \"?\"\n     }\n-    \n-    func navigateToStudyHome(){\n-        \n-        let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n-        let studyHomeController = (studyStoryBoard.instantiateViewController(withIdentifier: String(describing: StudyHomeViewController.classForCoder())) as? StudyHomeViewController)!\n-        studyHomeController.hideViewConsentAfterJoining = true\n-        studyHomeController.loadViewFrom = .resource\n-        studyHomeController.hidesBottomBarWhenPushed = true\n-        self.navigationController?.pushViewController(studyHomeController, animated: true)\n-        \n+\n+    if withdrawalType == nil || withdrawalType == .notAvailable {\n+\n+      withdrawlInformationNotFound = true\n+      withdrawalType = .notAvailable\n+      WCPServices().getStudyInformation(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+      return\n     }\n-    \n-    \n-    func navigateToWebView(link: String?,htmlText: String?,pdfData: Data?){\n-        \n-        let loginStoryboard = UIStoryboard.init(name: \"Main\", bundle: Bundle.main)\n-        let webViewController = (loginStoryboard.instantiateViewController(withIdentifier: \"WebViewController\") as? UINavigationController)!\n-        let webView = (webViewController.viewControllers[0] as? WebViewController)!\n-        webView.isEmailAvailable = true\n-        \n-        if pdfData != nil {\n-            webView.pdfData = pdfData\n+\n+    UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+      NSLocalizedString((leaveStudy + \" ?\"), comment: \"\"),\n+      errorMessage: NSLocalizedString(withdrawalMessage!, comment: \"\"),\n+      errorAlertActionTitle: NSLocalizedString(\"Proceed\", comment: \"\"),\n+      errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"),\n+      viewControllerUsed: self,\n+      action1: {\n+\n+        switch withdrawalType! as StudyWithdrawalConfigrationType {\n+\n+        case .askUser:\n+\n+          UIUtilities.showAlertMessageWithThreeActionsAndHandler(\n+            kImportantNoteMessage,\n+            errorMessage:\n+              \"You are choosing to leave the study. Please choose if your response data can be retained and used for research purposes OR if your response data should be deleted.\",\n+            errorAlertActionTitle: \"Retain my data\",\n+            errorAlertActionTitle2: \"Delete my data\",\n+            errorAlertActionTitle3: \"Cancel\", viewControllerUsed: self,\n+            action1: {\n+              // Retain Action\n+\n+              self.shouldDeleteData = false\n+              self.withdrawalFromStudy(deleteResponse: false)\n+\n+            },\n+            action2: {\n+\n+              // Delete action\n+              self.shouldDeleteData = true\n+              self.withdrawalFromStudy(deleteResponse: true)\n+\n+            },\n+            action3: {\n+              // Cancel Action\n+            })\n+\n+        case .deleteData:\n+\n+          UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+            NSLocalizedString(\"Are you sure? Tap Ok to confirm.\", comment: \"\"),\n+            errorMessage: NSLocalizedString(\"\", comment: \"\"),\n+            errorAlertActionTitle: NSLocalizedString(\"Ok\", comment: \"\"),\n+            errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"),\n+            viewControllerUsed: self,\n+            action1: {\n+              self.shouldDeleteData = true\n+              self.withdrawalFromStudy(deleteResponse: true)\n+            },\n+            action2: {\n+\n+            })\n+\n+        case .noAction:\n+\n+          UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+            NSLocalizedString(\"Are you sure? Tap Ok to confirm.\", comment: \"\"),\n+            errorMessage: NSLocalizedString(\"\", comment: \"\"),\n+            errorAlertActionTitle: NSLocalizedString(\"Ok\", comment: \"\"),\n+            errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"),\n+            viewControllerUsed: self,\n+            action1: {\n+              self.shouldDeleteData = false\n+              self.withdrawalFromStudy(deleteResponse: false)\n+            },\n+            action2: {\n+\n+            })\n+\n+        default: break\n         }\n-        \n-        self.navigationController?.present(webViewController, animated: true, completion: nil)\n+\n+      },\n+      action2: {\n+          // Handle cancel action\n+      })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 793}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5MjU3Nw==", "bodyText": "what's the url? is it provided by user? if yes, we should not log it since it could contain PII", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391792577", "createdAt": "2020-03-12T17:51:17Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/StudyUI/ResourceUI/ResourcesViewController.swift", "diffHunk": "@@ -1,886 +1,762 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n import UIKit\n \n-\n let kConsentPdfKey = \"consent\"\n \n let kUnwindToStudyListIdentifier = \"unwindeToStudyListResourcesIdentifier\"\n \n-class ResourcesViewController: UIViewController{\n-    \n-    var tableViewRowDetails: [AnyObject]? = []\n-    \n-    @IBOutlet var tableView: UITableView?\n-    var resourceLink: String?\n-    var fileType: String?\n-    var navigateToStudyOverview: Bool? = false\n-    var withdrawlInformationNotFound = false\n-    var shouldDeleteData: Bool? = false\n-    \n-    var leaveStudy:String = \"Leave Study\"\n-    var aboutTheStudy:String = \"About the Study\"\n-    var consentPDF:String = \"Consent PDF\"\n-    \n-    override var preferredStatusBarStyle: UIStatusBarStyle{\n-        return .default\n-    }\n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        \n-        \n-        \n-        //load plist info\n-        //let plistPath = Bundle.main.path(forResource: \"ResourcesUI\", ofType: \".plist\", inDirectory:nil)\n-        //tableViewRowDetails = NSMutableArray(contentsOfFile: plistPath!) as [AnyObject]?\n-        \n-        //if (Study.currentStudy?.studySettings.rejoinStudyAfterWithdrawn)! == false {\n-        //    tableViewRowDetails?.removeLast()\n-        //}\n-        \n-        self.navigationItem.title = NSLocalizedString(\"Resources\", comment: \"\")\n-        //Next Phase\n-        //WCPServices().getResourcesForStudy(studyId:(Study.currentStudy?.studyId)!, delegate: self)\n-        \n-        \n-        if StudyUpdates.studyConsentUpdated {\n-            let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-             appDelegate.checkConsentStatus(controller: self)\n-        }\n-        \n-        \n-        //Branding\n-        let brandingDetail = Utilities.getBrandingDetails()\n-        if let leavetitle =  brandingDetail?[BrandingConstant.LeaveStudy] as? String{\n-            leaveStudy = leavetitle\n-        }\n-        \n-        if let consent =  brandingDetail?[BrandingConstant.ConsentPDF] as? String{\n-            consentPDF = consent\n-        }\n-        \n-    }\n-    \n-    \n-    override func viewWillAppear(_ animated: Bool) {\n-        super.viewWillAppear(animated)\n-        \n-        self.tableView?.estimatedRowHeight = 65\n-        self.tableView?.rowHeight = UITableView.automaticDimension\n-        \n-        if Utilities.isStandaloneApp() {\n-            self.setNavigationBarItem()\n-        }\n-        else {\n-            self.addHomeButton()\n-        }\n-        setNeedsStatusBarAppearanceUpdate()\n-         //UIApplication.shared.statusBarStyle = .default\n-        self.navigationController?.setNavigationBarHidden(false, animated: true)\n-        \n-        self.tabBarController?.tabBar.isHidden = false\n-        \n-        if Study.currentStudy?.withdrawalConfigration?.message == nil && ( Study.currentStudy?.withdrawalConfigration?.type == nil || Study.currentStudy?.withdrawalConfigration?.type == .notAvailable ){\n-            WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-            \n-        } else if StudyUpdates.studyInfoUpdated {\n-            WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-            \n-        } else {\n-            self.checkForResourceUpdate()\n-        }\n-        \n-        //self.checkForResourceUpdate()\n-        \n-        //self.checkForInfoUpdate()\n-        \n-        \n+class ResourcesViewController: UIViewController {\n+\n+  var tableViewRowDetails: [AnyObject]? = []\n+\n+  @IBOutlet var tableView: UITableView?\n+  var resourceLink: String?\n+  var fileType: String?\n+  var navigateToStudyOverview: Bool? = false\n+  var withdrawlInformationNotFound = false\n+  var shouldDeleteData: Bool? = false\n+\n+  var leaveStudy: String = \"Leave Study\"\n+  var aboutTheStudy: String = \"About the Study\"\n+  var consentPDF: String = \"Consent PDF\"\n+\n+  override var preferredStatusBarStyle: UIStatusBarStyle {\n+    return .default\n+  }\n+\n+  deinit {\n+    Logger.sharedInstance.info(\"\\(self): deinit\")\n+  }\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+\n+    self.navigationItem.title = NSLocalizedString(\"Resources\", comment: \"\")\n+\n+    if StudyUpdates.studyConsentUpdated {\n+      let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+      appDelegate.checkConsentStatus(controller: self)\n     }\n-    \n-    override func viewDidAppear(_ animated: Bool) {\n-        super.viewDidAppear(animated)\n-               \n+\n+    // Branding\n+    let brandingDetail = Utilities.getBrandingDetails()\n+    if let leavetitle = brandingDetail?[BrandingConstant.LeaveStudy] as? String {\n+      leaveStudy = leavetitle\n     }\n-    \n-    func checkForResourceUpdate(){\n-        \n-        if StudyUpdates.studyResourcesUpdated {\n-            WCPServices().getResourcesForStudy(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-        } else {\n-            self.checkIfResourcePresent()\n-        }\n+\n+    if let consent = brandingDetail?[BrandingConstant.ConsentPDF] as? String {\n+      consentPDF = consent\n     }\n-    \n-    func checkForInfoUpdate(){\n-        \n-        if StudyUpdates.studyInfoUpdated {\n-             WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-        }\n+\n+  }\n+\n+  override func viewWillAppear(_ animated: Bool) {\n+    super.viewWillAppear(animated)\n+\n+    self.tableView?.estimatedRowHeight = 65\n+    self.tableView?.rowHeight = UITableView.automaticDimension\n+\n+    if Utilities.isStandaloneApp() {\n+      self.setNavigationBarItem()\n+    } else {\n+      self.addHomeButton()\n     }\n-    \n-    func updateAnchorDateLifeTime() {\n-        \n-        AnchorDateHandler().fetchActivityAnchorDateForResourceFromLabkey { (status) in\n-            if status {\n-                self.loadResourceFromDatabase()\n-            }\n-        }\n+    setNeedsStatusBarAppearanceUpdate()\n+\n+    self.navigationController?.setNavigationBarHidden(false, animated: true)\n+\n+    self.tabBarController?.tabBar.isHidden = false\n+\n+    if Study.currentStudy?.withdrawalConfigration?.message == nil && (\n+      Study.currentStudy?.withdrawalConfigration?.type == nil || Study.currentStudy?\n+        .withdrawalConfigration?.type == .notAvailable\n+    ) {\n+      WCPServices().getStudyInformation(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+    } else if StudyUpdates.studyInfoUpdated {\n+      WCPServices().getStudyInformation(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+\n+    } else {\n+      self.checkForResourceUpdate()\n     }\n-    \n-    func checkIfResourcePresent(){\n-        if DBHandler.isResourcesEmpty((Study.currentStudy?.studyId)!) {\n-            WCPServices().getResourcesForStudy(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-        }\n-        else {\n-            self.loadResourceFromDatabase()\n-        }\n+\n+  }\n+\n+  override func viewDidAppear(_ animated: Bool) {\n+    super.viewDidAppear(animated)\n+  }\n+\n+  func checkForResourceUpdate() {\n+\n+    if StudyUpdates.studyResourcesUpdated {\n+      WCPServices().getResourcesForStudy(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+    } else {\n+      self.checkIfResourcePresent()\n     }\n-    \n-    func loadResourceFromDatabase() {\n-        \n-        \n-        DBHandler.loadResourcesForStudy(studyId: (Study.currentStudy?.studyId)!) { (resources) in\n-            Study.currentStudy?.resources = resources\n-            self.handleResourcesReponse()\n-            self.updateAnchorDateLifeTime()\n-        }\n-        \n+  }\n+\n+  func checkForInfoUpdate() {\n+\n+    if StudyUpdates.studyInfoUpdated {\n+      WCPServices().getStudyInformation(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n     }\n-    \n-    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n-        if segue.identifier == \"ResourceDetailViewControllerIdentifier\"{\n-            \n-            let resourceDetail = (segue.destination as? GatewayResourceDetailViewController)!\n-            resourceDetail.resource = (sender as? Resource)!\n-            if self.resourceLink != nil{\n-                resourceDetail.requestLink = self.resourceLink!\n-            }\n-            if self.fileType != nil {\n-                resourceDetail.type = self.fileType!\n-            }\n-            resourceDetail.hidesBottomBarWhenPushed = true\n-            \n-        } else if segue.identifier == \"ResourceDetailViewSegueIdentifier\" {\n-            \n-            let resourceDetail = (segue.destination as? ResourceDetailViewController)!\n-            resourceDetail.resource = (sender as? Resource)!\n-            if self.resourceLink != nil{\n-                resourceDetail.requestLink = self.resourceLink!\n-            }\n-            if self.fileType != nil {\n-                resourceDetail.type = self.fileType!\n-            }\n-            resourceDetail.hidesBottomBarWhenPushed = true\n-            \n-        }\n+  }\n+\n+  func updateAnchorDateLifeTime() {\n+\n+    AnchorDateHandler().fetchActivityAnchorDateForResourceFromLabkey { (status) in\n+      if status {\n+        self.loadResourceFromDatabase()\n+      }\n     }\n-    \n-    \n-    @IBAction func homeButtonAction(_ sender: AnyObject){\n-        self.navigationController?.navigationBar.isHidden = false\n-        self.performSegue(withIdentifier: kUnwindToStudyListIdentifier, sender: self)\n-        \n+  }\n+\n+  func checkIfResourcePresent() {\n+    if DBHandler.isResourcesEmpty((Study.currentStudy?.studyId)!) {\n+      WCPServices().getResourcesForStudy(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+    } else {\n+      self.loadResourceFromDatabase()\n     }\n-    \n-    func addDefaultList(){\n-        \n-        //add default List\n-        \n-        tableViewRowDetails?.append(aboutTheStudy as AnyObject)\n-        tableViewRowDetails?.append(consentPDF as AnyObject)\n-        \n-//        let plistPath = Bundle.main.path(forResource: \"ResourcesUI\", ofType: \".plist\", inDirectory: nil)\n-//\n-//        let array = NSMutableArray(contentsOfFile: plistPath!) as [AnyObject]?\n-//\n-//        for title in array!{\n-//            tableViewRowDetails?.append(title)\n-//        }\n-        \n+  }\n+\n+  func loadResourceFromDatabase() {\n+\n+    DBHandler.loadResourcesForStudy(studyId: (Study.currentStudy?.studyId)!) { (resources) in\n+      Study.currentStudy?.resources = resources\n+      self.handleResourcesReponse()\n+      self.updateAnchorDateLifeTime()\n     }\n-    \n-    func appendLeaveStudy(){\n-        \n-        //append Leave Study row\n-        //if (Study.currentStudy?.studySettings.rejoinStudyAfterWithdrawn)! != false {\n-            tableViewRowDetails?.append(leaveStudy as AnyObject)\n-        //}\n+\n+  }\n+\n+  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n+    if segue.identifier == \"ResourceDetailViewControllerIdentifier\" {\n+\n+      let resourceDetail = (segue.destination as? GatewayResourceDetailViewController)!\n+      resourceDetail.resource = (sender as? Resource)!\n+      if self.resourceLink != nil {\n+        resourceDetail.requestLink = self.resourceLink!\n+      }\n+      if self.fileType != nil {\n+        resourceDetail.type = self.fileType!\n+      }\n+      resourceDetail.hidesBottomBarWhenPushed = true\n+\n+    } else if segue.identifier == \"ResourceDetailViewSegueIdentifier\" {\n+\n+      let resourceDetail = (segue.destination as? ResourceDetailViewController)!\n+      resourceDetail.resource = (sender as? Resource)!\n+      if self.resourceLink != nil {\n+        resourceDetail.requestLink = self.resourceLink!\n+      }\n+      if self.fileType != nil {\n+        resourceDetail.type = self.fileType!\n+      }\n+      resourceDetail.hidesBottomBarWhenPushed = true\n+\n     }\n-    \n-    func handleResourcesReponse() {\n-        \n-        tableViewRowDetails = []\n-        \n-        self.addDefaultList()\n-        self.appendLeaveStudy()\n-        \n-        let todayDate = Date()\n-        \n-        for  resource in (Study.currentStudy?.resources)!{\n-            \n-            if resource.startDate != nil && resource.endDate != nil {\n-                \n-                \n-                let start = resource.startDate//.startOfDay\n-                let end = resource.endDate//.endOfDay\n-                \n-                let startDateResult = (start?.compare(todayDate))! as ComparisonResult\n-                let endDateResult = (end?.compare(todayDate))! as ComparisonResult\n-                \n-                //compare lifetime\n-                if ((startDateResult == .orderedAscending || startDateResult == .orderedSame) && (endDateResult == .orderedDescending || endDateResult == .orderedSame)){\n-                    print(\"current\")\n-                    \n-                    tableViewRowDetails?.append(resource)\n-                    \n-                    //compare for today\n-                    let endOfToday = resource.startDate//.endOfDay\n-                    \n-                    if (todayDate >= start! && todayDate <= endOfToday!){\n-                        resource.availableToday = true\n-                    }\n-                    \n-                }\n-            }\n-            else {\n-                tableViewRowDetails?.append(resource)\n-            }\n+  }\n+\n+  @IBAction func homeButtonAction(_ sender: AnyObject) {\n+    self.navigationController?.navigationBar.isHidden = false\n+    self.performSegue(withIdentifier: kUnwindToStudyListIdentifier, sender: self)\n+\n+  }\n+\n+  func addDefaultList() {\n+    tableViewRowDetails?.append(aboutTheStudy as AnyObject)\n+    tableViewRowDetails?.append(consentPDF as AnyObject)\n+  }\n+\n+  func appendLeaveStudy() {\n+    // append Leave Study row\n+    tableViewRowDetails?.append(leaveStudy as AnyObject)\n+  }\n+\n+  func handleResourcesReponse() {\n+\n+    tableViewRowDetails = []\n+\n+    self.addDefaultList()\n+    self.appendLeaveStudy()\n+\n+    let todayDate = Date()\n+\n+    for resource in (Study.currentStudy?.resources)! {\n+\n+      if resource.startDate != nil && resource.endDate != nil {\n+\n+        let start = resource.startDate\n+        let end = resource.endDate\n+\n+        let startDateResult = (start?.compare(todayDate))! as ComparisonResult\n+        let endDateResult = (end?.compare(todayDate))! as ComparisonResult\n+\n+        // compare lifetime\n+        if (startDateResult == .orderedAscending || startDateResult == .orderedSame) &&\n+            (endDateResult == .orderedDescending || endDateResult == .orderedSame) {\n+\n+          tableViewRowDetails?.append(resource)\n+\n+          // compare for today\n+          let endOfToday = resource.startDate\n+\n+          if todayDate >= start! && todayDate <= endOfToday! {\n+            resource.availableToday = true\n+          }\n \n         }\n+      } else {\n+        tableViewRowDetails?.append(resource)\n+      }\n \n-        \n-        \n-        //Add resources list\n-//        for  resource in (Study.currentStudy?.resources)!{\n-//\n-//            if resource.povAvailable{\n-//                //check for startDate and endDate\n-//                if resource.startDate != nil && resource.endDate != nil {\n-//\n-//                    let start = resource.startDate?.startOfDay\n-//                    let end = resource.endDate?.endOfDay\n-//\n-//                    let startDateResult = (start?.compare(todayDate))! as ComparisonResult\n-//                    let endDateResult = (end?.compare(todayDate))! as ComparisonResult\n-//\n-//\n-//                    if ((startDateResult == .orderedAscending || startDateResult == .orderedSame) && (endDateResult == .orderedDescending || endDateResult == .orderedSame)){\n-//                        print(\"current\")\n-//\n-//                        tableViewRowDetails?.append(resource)\n-//\n-//                    }\n-//                } //check for anchorDate\n-//                else if resource.anchorDateStartDays != nil && resource.anchorDateEndDays != nil {\n-//\n-//                    let anchorDateObject = Study.currentStudy?.anchorDate\n-//                    if(anchorDateObject != nil && (anchorDateObject?.isAnchorDateAvailable())!) {\n-//\n-//\n-//\n-//                        let anchorDate = Study.currentStudy?.anchorDate?.date?.startOfDay\n-//\n-//                        if anchorDate != nil {\n-//\n-//                            //also anchor date condition\n-//                            let startDateInterval = TimeInterval(60*60*24*(resource.anchorDateStartDays)!)\n-//                            let endDateInterval = TimeInterval(60*60*24*(resource.anchorDateEndDays)!)\n-//\n-//                            let startAnchorDate = anchorDate?.addingTimeInterval(startDateInterval)\n-//                            var endAnchorDate = anchorDate?.addingTimeInterval(endDateInterval)\n-//\n-//                            endAnchorDate = endAnchorDate?.endOfDay\n-//                            let startDateResult = (startAnchorDate?.compare(todayDate))! as ComparisonResult\n-//                            let endDateResult = (endAnchorDate?.compare(todayDate))! as ComparisonResult\n-//\n-//                            if ((startDateResult == .orderedAscending || startDateResult == .orderedSame) && (endDateResult == .orderedDescending || endDateResult == .orderedSame)){\n-//\n-//                                tableViewRowDetails?.append(resource)\n-//\n-//                            } else if startDateResult == .orderedDescending {\n-//                                //upcoming\n-//                                let notfiId = resource.resourcesId! + (Study.currentStudy?.studyId)!\n-//                                DBHandler.isNotificationSetFor(notification: notfiId\n-//                                    , completionHandler: { (found) in\n-//                                        if !found {\n-//\n-//                                            let notification = AppLocalNotification()\n-//                                            notification.id = resource.resourcesId! + (Study.currentStudy?.studyId)!\n-//                                            notification.message = resource.notificationMessage\n-//                                            notification.title = \"New Resource Available\"\n-//                                            notification.startDate = startAnchorDate\n-//                                            notification.endDate = endAnchorDate\n-//                                            notification.type = AppNotification.NotificationType.Study\n-//                                            notification.subType = AppNotification.NotificationSubType.Resource\n-//                                            notification.audience = Audience.Limited\n-//                                            notification.studyId = (Study.currentStudy?.studyId)!\n-//                                            //notification.activityId = Study.currentActivity?.actvityId\n-//\n-//                                            DBHandler.saveLocalNotification(notification: notification)\n-//\n-//                                            //register notification\n-//                                            var notificationDate = startAnchorDate?.startOfDay\n-//                                            notificationDate = notificationDate?.addingTimeInterval(43200)\n-//                                            let message = resource.notificationMessage\n-//                                            let userInfo = [\"studyId\": (Study.currentStudy?.studyId)!,\n-//                                                            \"type\": \"resource\"];\n-//                                            LocalNotification.scheduleNotificationOn(date: notificationDate!, message: message!, userInfo: userInfo)\n-//                                        }\n-//                                })\n-//\n-//                            }\n-//                        }\n-//\n-//                    } else {\n-//                        tableViewRowDetails?.append(resource)\n-//                    }\n-//\n-//                } else {\n-//                    tableViewRowDetails?.append(resource)\n-//                }\n-//            } else {\n-//                 tableViewRowDetails?.append(resource)\n-//            }\n-//\n-//        }\n-        \n-        \n-        tableView?.isHidden =  false\n-        tableView?.reloadData()\n-        \n-        StudyUpdates.studyResourcesUpdated = false\n-        DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n     }\n-    \n-    func handleLeaveStudy() {\n-        \n-        var withdrawalMessage = Study.currentStudy?.withdrawalConfigration?.message\n-        \n-        var withdrawalType = Study.currentStudy?.withdrawalConfigration?.type\n-        \n-        if withdrawalMessage == nil {\n-            withdrawalMessage = \"Are you sure you want to \" + leaveStudy + \"?\"\n-        }\n-        \n-        if withdrawalType == nil || withdrawalType == .notAvailable {\n-            \n-            withdrawlInformationNotFound = true\n-            withdrawalType = .notAvailable\n-            WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-            return\n-        }\n-        \n-        \n-        UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString((leaveStudy + \" ?\"), comment: \"\"), errorMessage: NSLocalizedString(withdrawalMessage!, comment: \"\"), errorAlertActionTitle: NSLocalizedString(\"Proceed\", comment: \"\"),\n-                                                             errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"), viewControllerUsed: self,\n-                                                             action1: {\n-                                                                \n-                                                                \n-                                                                switch withdrawalType! as StudyWithdrawalConfigrationType {\n-                                                                    \n-                                                                case .askUser :\n-                                                                    \n-                                                                    UIUtilities.showAlertMessageWithThreeActionsAndHandler(kImportantNoteMessage, errorMessage: \"You are choosing to leave the study. Please choose if your response data can be retained and used for research purposes OR if your response data should be deleted.\", errorAlertActionTitle: \"Retain my data\", errorAlertActionTitle2: \"Delete my data\", errorAlertActionTitle3: \"Cancel\", viewControllerUsed: self, action1: {\n-                                                                        // Retain Action\n-                                                                        \n-                                                                        self.shouldDeleteData = false\n-                                                                        self.withdrawalFromStudy(deleteResponse: false)\n-                                                                        \n-                                                                        \n-                                                                        \n-                                                                    }, action2: {\n-                                                                        \n-                                                                        // Delete action\n-                                                                        self.shouldDeleteData = true\n-                                                                        self.withdrawalFromStudy(deleteResponse: true)\n-                                                                        \n-                                                                    }, action3: {\n-                                                                        // Cancel Action\n-                                                                    })\n-                                                                    \n-                                                                    \n-                                                                case .deleteData:\n-                                                                    \n-                                                                    UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(\"Are you sure? Tap Ok to confirm.\", comment: \"\"), errorMessage: NSLocalizedString(\"\", comment: \"\"), errorAlertActionTitle: NSLocalizedString(\"Ok\", comment: \"\"),\n-                                                                                                                         errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"), viewControllerUsed: self,\n-                                                                                                                         action1: {\n-                                                                                                                            self.shouldDeleteData = true\n-                                                                                                                            self.withdrawalFromStudy(deleteResponse: true)\n-                                                                    },\n-                                                                                                                         action2: {\n-                                                                                                                            \n-                                                                    })\n-                                                                    \n-                                                                case .noAction :\n-                                                                    \n-                                                                    UIUtilities.showAlertMessageWithTwoActionsAndHandler(NSLocalizedString(\"Are you sure? Tap Ok to confirm.\", comment: \"\"), errorMessage: NSLocalizedString(\"\", comment: \"\"), errorAlertActionTitle: NSLocalizedString(\"Ok\", comment: \"\"),\n-                                                                                                                         errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"), viewControllerUsed: self,\n-                                                                                                                         action1: {\n-                                                                                                                            self.shouldDeleteData = false\n-                                                                                                                            self.withdrawalFromStudy(deleteResponse: false)\n-                                                                    },\n-                                                                                                                         action2: {\n-                                                                                                                            \n-                                                                    })\n-                                                                    \n-                                                                default : break\n-                                                                }\n-                                                                \n-                                                                \n-        },\n-                                                             action2: {\n-                                                                \n-        })\n-        \n-        \n+\n+    tableView?.isHidden = false\n+    tableView?.reloadData()\n+\n+    StudyUpdates.studyResourcesUpdated = false\n+    DBHandler.updateMetaDataToUpdateForStudy(study: Study.currentStudy!, updateDetails: nil)\n+  }\n+\n+  func handleLeaveStudy() {\n+\n+    var withdrawalMessage = Study.currentStudy?.withdrawalConfigration?.message\n+\n+    var withdrawalType = Study.currentStudy?.withdrawalConfigration?.type\n+\n+    if withdrawalMessage == nil {\n+      withdrawalMessage = \"Are you sure you want to \" + leaveStudy + \"?\"\n     }\n-    \n-    func navigateToStudyHome(){\n-        \n-        let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n-        let studyHomeController = (studyStoryBoard.instantiateViewController(withIdentifier: String(describing: StudyHomeViewController.classForCoder())) as? StudyHomeViewController)!\n-        studyHomeController.hideViewConsentAfterJoining = true\n-        studyHomeController.loadViewFrom = .resource\n-        studyHomeController.hidesBottomBarWhenPushed = true\n-        self.navigationController?.pushViewController(studyHomeController, animated: true)\n-        \n+\n+    if withdrawalType == nil || withdrawalType == .notAvailable {\n+\n+      withdrawlInformationNotFound = true\n+      withdrawalType = .notAvailable\n+      WCPServices().getStudyInformation(\n+        studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+      return\n     }\n-    \n-    \n-    func navigateToWebView(link: String?,htmlText: String?,pdfData: Data?){\n-        \n-        let loginStoryboard = UIStoryboard.init(name: \"Main\", bundle: Bundle.main)\n-        let webViewController = (loginStoryboard.instantiateViewController(withIdentifier: \"WebViewController\") as? UINavigationController)!\n-        let webView = (webViewController.viewControllers[0] as? WebViewController)!\n-        webView.isEmailAvailable = true\n-        \n-        if pdfData != nil {\n-            webView.pdfData = pdfData\n+\n+    UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+      NSLocalizedString((leaveStudy + \" ?\"), comment: \"\"),\n+      errorMessage: NSLocalizedString(withdrawalMessage!, comment: \"\"),\n+      errorAlertActionTitle: NSLocalizedString(\"Proceed\", comment: \"\"),\n+      errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"),\n+      viewControllerUsed: self,\n+      action1: {\n+\n+        switch withdrawalType! as StudyWithdrawalConfigrationType {\n+\n+        case .askUser:\n+\n+          UIUtilities.showAlertMessageWithThreeActionsAndHandler(\n+            kImportantNoteMessage,\n+            errorMessage:\n+              \"You are choosing to leave the study. Please choose if your response data can be retained and used for research purposes OR if your response data should be deleted.\",\n+            errorAlertActionTitle: \"Retain my data\",\n+            errorAlertActionTitle2: \"Delete my data\",\n+            errorAlertActionTitle3: \"Cancel\", viewControllerUsed: self,\n+            action1: {\n+              // Retain Action\n+\n+              self.shouldDeleteData = false\n+              self.withdrawalFromStudy(deleteResponse: false)\n+\n+            },\n+            action2: {\n+\n+              // Delete action\n+              self.shouldDeleteData = true\n+              self.withdrawalFromStudy(deleteResponse: true)\n+\n+            },\n+            action3: {\n+              // Cancel Action\n+            })\n+\n+        case .deleteData:\n+\n+          UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+            NSLocalizedString(\"Are you sure? Tap Ok to confirm.\", comment: \"\"),\n+            errorMessage: NSLocalizedString(\"\", comment: \"\"),\n+            errorAlertActionTitle: NSLocalizedString(\"Ok\", comment: \"\"),\n+            errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"),\n+            viewControllerUsed: self,\n+            action1: {\n+              self.shouldDeleteData = true\n+              self.withdrawalFromStudy(deleteResponse: true)\n+            },\n+            action2: {\n+\n+            })\n+\n+        case .noAction:\n+\n+          UIUtilities.showAlertMessageWithTwoActionsAndHandler(\n+            NSLocalizedString(\"Are you sure? Tap Ok to confirm.\", comment: \"\"),\n+            errorMessage: NSLocalizedString(\"\", comment: \"\"),\n+            errorAlertActionTitle: NSLocalizedString(\"Ok\", comment: \"\"),\n+            errorAlertActionTitle2: NSLocalizedString(\"Cancel\", comment: \"\"),\n+            viewControllerUsed: self,\n+            action1: {\n+              self.shouldDeleteData = false\n+              self.withdrawalFromStudy(deleteResponse: false)\n+            },\n+            action2: {\n+\n+            })\n+\n+        default: break\n         }\n-        \n-        self.navigationController?.present(webViewController, animated: true, completion: nil)\n+\n+      },\n+      action2: {\n+          // Handle cancel action\n+      })\n+\n+  }\n+\n+  func navigateToStudyHome() {\n+\n+    let studyStoryBoard = UIStoryboard.init(name: kStudyStoryboard, bundle: Bundle.main)\n+    let studyHomeController = (\n+      studyStoryBoard.instantiateViewController(\n+        withIdentifier: String(describing: StudyHomeViewController.classForCoder()))\n+        as? StudyHomeViewController\n+    )!\n+    studyHomeController.hideViewConsentAfterJoining = true\n+    studyHomeController.loadViewFrom = .resource\n+    studyHomeController.hidesBottomBarWhenPushed = true\n+    self.navigationController?.pushViewController(studyHomeController, animated: true)\n+\n+  }\n+\n+  func navigateToWebView(link: String?, htmlText: String?, pdfData: Data?) {\n+\n+    let loginStoryboard = UIStoryboard.init(name: \"Main\", bundle: Bundle.main)\n+    let webViewController = (\n+      loginStoryboard.instantiateViewController(withIdentifier: \"WebViewController\")\n+        as? UINavigationController\n+    )!\n+    let webView = (webViewController.viewControllers[0] as? WebViewController)!\n+    webView.isEmailAvailable = true\n+\n+    if pdfData != nil {\n+      webView.pdfData = pdfData\n     }\n-    \n-    \n-    \n-    func checkDatabaseForStudyInfo(study: Study){\n-        \n-        DBHandler.loadStudyOverview(studyId: (study.studyId)!) { (overview) in\n-            if overview != nil {\n-                study.overview = overview\n-                self.navigateToStudyHome()\n-                \n-            } else {\n-                \n-                self.navigateToStudyOverview = true\n-                self.sendRequestToGetStudyInfo(study: study)\n-            }\n-        }\n+\n+    self.navigationController?.present(webViewController, animated: true, completion: nil)\n+  }\n+\n+  func checkDatabaseForStudyInfo(study: Study) {\n+\n+    DBHandler.loadStudyOverview(studyId: (study.studyId)!) { (overview) in\n+      if overview != nil {\n+        study.overview = overview\n+        self.navigateToStudyHome()\n+\n+      } else {\n+\n+        self.navigateToStudyOverview = true\n+        self.sendRequestToGetStudyInfo(study: study)\n+      }\n     }\n-    func sendRequestToGetStudyInfo(study: Study){\n-        \n-        \n-        \n-        WCPServices().getStudyInformation(studyId: study.studyId, delegate: self)\n+  }\n+\n+  func sendRequestToGetStudyInfo(study: Study) {\n+\n+    WCPServices().getStudyInformation(studyId: study.studyId, delegate: self)\n+  }\n+\n+  func pushToResourceDetails() {\n+\n+    let path = AKUtility.baseFilePath + \"/study\"\n+    let consentPath = Study.currentStudy?.signedConsentFilePath\n+\n+    let fullPath = path + \"/\" + consentPath!\n+\n+    let pdfData = FileDownloadManager.decrytFile(pathURL: URL.init(string: fullPath))\n+\n+    var isPDF: Bool = false\n+    if (pdfData?.count)! >= 1024  // only check if bigger\n+    {\n+      var pdfBytes = [UInt8]()\n+      pdfBytes = [0x25, 0x50, 0x44, 0x46]\n+      let pdfHeader = NSData(bytes: pdfBytes, length: 4)\n+\n+      let myRange: Range = 0 ..< 1024\n+      let foundRange = pdfData?.range(of: pdfHeader as Data, options: .anchored, in: myRange)\n+      if foundRange != nil && (foundRange?.count)! > 0 {\n+        isPDF = true\n+      } else {\n+        isPDF = false\n+        UserServices().getConsentPDFForStudy(\n+          studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+      }\n     }\n-    \n-    func pushToResourceDetails(){\n-        \n-        let path = AKUtility.baseFilePath + \"/study\"\n-        let consentPath = Study.currentStudy?.signedConsentFilePath\n-        \n-        let fullPath = path + \"/\" + consentPath!\n-        \n-        let pdfData = FileDownloadManager.decrytFile(pathURL: URL.init(string: fullPath))\n-        \n-        var isPDF: Bool = false\n-        if (pdfData?.count)! >= 1024 //only check if bigger\n-        {\n-            var pdfBytes = [UInt8]()\n-            pdfBytes = [ 0x25, 0x50, 0x44, 0x46]\n-            let pdfHeader = NSData(bytes: pdfBytes, length: 4)\n-            \n-            let myRange: Range = 0..<1024\n-            let foundRange = pdfData?.range(of: pdfHeader as Data, options: .anchored, in: myRange) //rangeOfData(pdfHeader, options: nil, range: NSMakeRange(0, 1024))\n-            if foundRange != nil && (foundRange?.count)! > 0\n-            {\n-                isPDF = true\n-                print(\"pdf\")\n-            } else {\n-                isPDF = false\n-                print(\"not pdf\")\n-                UserServices().getConsentPDFForStudy(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-            }\n-        }\n-        \n-        if pdfData != nil && isPDF{\n-            self.navigateToWebView(link: \"\", htmlText: \"\",pdfData: pdfData)\n-        }\n+\n+    if pdfData != nil && isPDF {\n+      self.navigateToWebView(link: \"\", htmlText: \"\", pdfData: pdfData)\n     }\n-    \n-    \n-    func saveConsentPdfToLocal(base64dataString: String){\n-        \n-        let consentData = NSData(base64Encoded: base64dataString, options: .ignoreUnknownCharacters)\n-        \n-        var fullPath: String!\n-        let path =  AKUtility.baseFilePath + \"/study\"\n-        let fileName: String = \"Consent\" +  \"_\" + \"\\((Study.currentStudy?.studyId)!)\" + \".pdf\"\n-        \n-        fullPath = path + \"/\" + fileName\n-        \n-        if !FileManager.default.fileExists(atPath: path) {\n-            try! FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n-        }\n-        \n-        do {\n-            \n-            if FileManager.default.fileExists(atPath: fullPath){\n-                \n-                try FileManager.default.removeItem(atPath: fullPath)\n-                \n-            }\n-            FileManager.default.createFile(atPath: fullPath , contents: consentData as Data?, attributes: [:])\n-            \n-            let defaultPath = fullPath\n-            \n-            fullPath = \"file://\" + \"\\(fullPath!)\"\n-            \n-            try consentData?.write(to:  URL(string: fullPath!)!)\n-            \n-            FileDownloadManager.encyptFile(pathURL: URL(string: defaultPath!)!)\n-            \n-            Study.currentStudy?.signedConsentFilePath = fileName\n-            DBHandler.saveConsentInformation(study: Study.currentStudy!)\n-            \n-            self.pushToResourceDetails()\n-            \n-            \n-        } catch let error as NSError {\n-            print(\"error writing to url \\(String(describing: fullPath))\")\n-            print(error.localizedDescription)\n-        }\n+  }\n+\n+  func saveConsentPdfToLocal(base64dataString: String) {\n+\n+    let consentData = NSData(base64Encoded: base64dataString, options: .ignoreUnknownCharacters)\n+\n+    var fullPath: String!\n+    let path = AKUtility.baseFilePath + \"/study\"\n+    let fileName: String = \"Consent\" + \"_\" + \"\\((Study.currentStudy?.studyId)!)\" + \".pdf\"\n+\n+    fullPath = path + \"/\" + fileName\n+\n+    if !FileManager.default.fileExists(atPath: path) {\n+      try! FileManager.default.createDirectory(\n+        atPath: path, withIntermediateDirectories: true, attributes: nil)\n+    }\n+\n+    do {\n+\n+      if FileManager.default.fileExists(atPath: fullPath) {\n+        try FileManager.default.removeItem(atPath: fullPath)\n+      }\n+\n+      FileManager.default.createFile(\n+        atPath: fullPath, contents: consentData as Data?, attributes: [:])\n+\n+      let defaultPath = fullPath\n+\n+      fullPath = \"file://\" + \"\\(fullPath!)\"\n+\n+      try consentData?.write(to: URL(string: fullPath!)!)\n \n+      FileDownloadManager.encyptFile(pathURL: URL(string: defaultPath!)!)\n+\n+      Study.currentStudy?.signedConsentFilePath = fileName\n+      DBHandler.saveConsentInformation(study: Study.currentStudy!)\n+\n+      self.pushToResourceDetails()\n+\n+    } catch let error as NSError {\n+      Logger.sharedInstance.warn(\"Error writing to url: \\(String(describing: fullPath))\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1016}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMDc3NQ==", "bodyText": "should be .error", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391810775", "createdAt": "2020-03-12T18:24:25Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/ViewController.swift", "diffHunk": "@@ -1,377 +1,329 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import ResearchKit\n+import UIKit\n \n //let user = User()\n-let activityBuilder:ActivityBuilder? = ActivityBuilder.currentActivityBuilder\n-let consentbuilder:ConsentBuilder? = ConsentBuilder()\n+let activityBuilder: ActivityBuilder? = ActivityBuilder.currentActivityBuilder\n+let consentbuilder: ConsentBuilder? = ConsentBuilder()\n //var user = User.currentUser\n \n-\n-let resourceArray : Array<Any>? = nil\n+let resourceArray: [Any]? = nil\n class ViewController: UIViewController {\n-    var user = User.currentUser\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        // Do any additional setup after loading the view, typically from a nib.\n-        \n-        self.userProfile()\n-        self.setPrefereneces()\n-        self.addResources()\n-        \n-        self.buildTask()\n-       // self.kickCounterTaskTest()\n-        \n-        \n-        \n-        \n-        //user.bookmarkStudy(studyId: \"121\")\n-        \n-        //user.updateStudyStatus(studyId: \"121\", status:.yetToJoin)\n-        \n-       // user.bookmarkActivity(studyId: \"121\", activityId: \"151\")\n-        \n-       // print(user.getStudyStatus(studyId: \"121\").description)\n-        \n-        //not available\n-//        let start = \"2017-03-01\"\n-//        let end = \"2017-03-05\"\n-        \n-        \n-        //run completed\n-        let start = \"2017-01-26 10:00:00\"\n-        let end = \"2017-01-30\"\n-        let runtime = \"2017-03-12\"\n-        \n-        \n-        let dateFormatter = DateFormatter()\n-        dateFormatter.dateFormat = \"yyyy-MM-dd\"\n-        let endDate:Date = dateFormatter.date(from: end)!\n-        \n-        \n-        let sdateFormatter = DateFormatter()\n-        sdateFormatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n-        let startDate:Date = sdateFormatter.date(from: start)!\n-        \n-        \n-        \n-        let rdateFormatter = DateFormatter()\n-        rdateFormatter.dateFormat = \"yyyy-MM-dd\"\n-        let rendDate:Date = rdateFormatter.date(from: runtime)!\n-        \n-        let schedular = Schedule()\n-        schedular.startTime = startDate\n-        schedular.endTime = endDate\n-        schedular.lastRunTime = rendDate\n-        \n-        //schedular.setDailyRuns()\n-        //schedular.setWeeklyRuns()\n-        //schedular.setMonthlyRuns()\n-        //schedular.setDailyFrequenyRuns()\n-        schedular.setScheduledRuns()\n-        \n-    }\n-    \n-    \n-    \n-    // MARK: methods\n-    \n-    \n-    func kickCounterTaskTest()   {\n-        \n-        let fetalKickCouterTask:FetalKickCounterTask? = FetalKickCounterTask()\n-        let task:ORKTask?\n-        let taskViewController:ORKTaskViewController?\n-        \n-        task = fetalKickCouterTask?.getTask()\n-        taskViewController = ORKTaskViewController(task:task, taskRun: nil)\n-        taskViewController?.delegate = self\n-        taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-         UIApplication.shared.statusBarStyle = .default\n-        \n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        taskViewController?.modalPresentationStyle = .fullScreen\n-        present(taskViewController!, animated: true, completion: nil)\n-\n-        \n-    }\n-    \n-    \n-    \n-    func buildTask()  {\n-        \n-        // let filePath  = Bundle.main.path(forResource: \"LatestActive_Taskdocument\", ofType: \"json\")\n-        \n-        //let filePath  = Bundle.main.path(forResource: \"ActiveTask\", ofType: \"json\")\n-        \n-         let filePath  = Bundle.main.path(forResource: \"TaskSchema\", ofType: \"json\")\n-        \n-        //let filePath  = Bundle.main.path(forResource: \"Acivity_Question\", ofType: \"json\")\n-        \n-        let data = NSData(contentsOfFile: filePath!)\n-        \n-        \n-        do {\n-            let dataDict = try JSONSerialization.jsonObject(with: data! as Data, options: []) as? Dictionary<String,Any>\n-            \n-            if  Utilities.isValidObject(someObject: dataDict as AnyObject?) && (dataDict?.count)! > 0 {\n-                \n-                \n-                let task:ORKTask?\n-                let taskViewController:ORKTaskViewController?\n-                \n-                if Utilities.isValidObject(someObject: dataDict?[\"Result\"] as? Dictionary<String, Any> as AnyObject?){\n-                    \n-                    \n-                     activityBuilder?.initActivityWithDict(dict: dataDict?[\"Result\"] as! Dictionary<String, Any>)\n-                    \n-                   \n-                    \n-                     task = activityBuilder?.createTask()\n-                    \n-                \n-                   // consentbuilder?.initWithMetaData(metaDataDict:dataDict?[\"Result\"] as! Dictionary<String, Any> )\n-                   // task = consentbuilder?.createConsentTask()\n-                    \n-                    taskViewController = ORKTaskViewController(task:task, taskRun: nil)\n-                    \n-                   // consentbuilder?.consentResult =   ConsentResult()\n-                   // consentbuilder?.consentResult?.consentDocument =  consentbuilder?.consentDocument\n-                    \n-                    taskViewController?.delegate = self\n-                    taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-                    \n-                     UIApplication.shared.statusBarStyle = .default\n-                     taskViewController?.modalPresentationStyle = .fullScreen\n-                    present(taskViewController!, animated: true, completion: nil)\n-                }\n-            }\n-            \n-            // use anyObj here\n-        } catch {\n-            print(\"json error: \\(error.localizedDescription)\")\n+\n+  var user = User.currentUser\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    // Do any additional setup after loading the view, typically from a nib.\n+\n+    self.userProfile()\n+    self.setPrefereneces()\n+    self.addResources()\n+\n+    self.buildTask()\n+\n+    // run completed\n+    let start = \"2017-01-26 10:00:00\"\n+    let end = \"2017-01-30\"\n+    let runtime = \"2017-03-12\"\n+\n+    let dateFormatter = DateFormatter()\n+    dateFormatter.dateFormat = \"yyyy-MM-dd\"\n+    let endDate: Date = dateFormatter.date(from: end)!\n+\n+    let sdateFormatter = DateFormatter()\n+    sdateFormatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n+    let startDate: Date = sdateFormatter.date(from: start)!\n+\n+    let rdateFormatter = DateFormatter()\n+    rdateFormatter.dateFormat = \"yyyy-MM-dd\"\n+    let rendDate: Date = rdateFormatter.date(from: runtime)!\n+\n+    let schedular = Schedule()\n+    schedular.startTime = startDate\n+    schedular.endTime = endDate\n+    schedular.lastRunTime = rendDate\n+    schedular.setScheduledRuns()\n+\n+  }\n+\n+  // MARK: methods\n+\n+  /// Presents `ORKTaskViewController` of type task `FetalKickCounterTask`\n+  func kickCounterTaskTest() {\n+\n+    let fetalKickCouterTask: FetalKickCounterTask? = FetalKickCounterTask()\n+    let task: ORKTask?\n+    let taskViewController: ORKTaskViewController?\n+\n+    task = fetalKickCouterTask?.getTask()\n+    taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n+    taskViewController?.delegate = self\n+    taskViewController?.outputDirectory = FileManager.default.urls(\n+      for: .documentDirectory, in: .userDomainMask).first!\n+    setNeedsStatusBarAppearanceUpdate()\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+    taskViewController?.navigationBar.prefersLargeTitles = false\n+    taskViewController?.modalPresentationStyle = .fullScreen\n+    present(taskViewController!, animated: true, completion: nil)\n+\n+  }\n+\n+  /// Creates `ORKTask` instance and presents `ORKTaskViewController`\n+  func buildTask() {\n+\n+    let filePath = Bundle.main.path(forResource: \"TaskSchema\", ofType: \"json\")\n+    let data = NSData(contentsOfFile: filePath!)\n+\n+    do {\n+      let dataDict = try JSONSerialization.jsonObject(with: data! as Data, options: [])\n+        as? [String: Any]\n+\n+      if Utilities.isValidObject(someObject: dataDict as AnyObject?) && (dataDict?.count)! > 0 {\n+\n+        let task: ORKTask?\n+        let taskViewController: ORKTaskViewController?\n+\n+        if Utilities.isValidObject(\n+          someObject: dataDict?[\"Result\"] as? [String: Any] as AnyObject?) {\n+\n+          activityBuilder?.initActivityWithDict(\n+            dict: dataDict?[\"Result\"] as! [String: Any])\n+\n+          task = activityBuilder?.createTask()\n+\n+          taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n+          taskViewController?.delegate = self\n+          taskViewController?.outputDirectory = FileManager.default.urls(\n+            for: .documentDirectory, in: .userDomainMask).first!\n+\n+          setNeedsStatusBarAppearanceUpdate()\n+          taskViewController?.navigationBar.prefersLargeTitles = false\n+          taskViewController?.modalPresentationStyle = .fullScreen\n+          present(taskViewController!, animated: true, completion: nil)\n         }\n-        \n-      \n-        \n+      }\n+\n+      // use anyObj here\n+    } catch {\n+      Logger.sharedInstance.info(\"json error: \\(error.localizedDescription)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMTU3MA==", "bodyText": "why is the same information logged with both info and error?\nPlease remove both if it's a debug log or if it contains PII.\notherwise use the level that's appropriate, I am guessing it's .info", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391811570", "createdAt": "2020-03-12T18:25:55Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Controllers/ViewController.swift", "diffHunk": "@@ -1,377 +1,329 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import ResearchKit\n+import UIKit\n \n //let user = User()\n-let activityBuilder:ActivityBuilder? = ActivityBuilder.currentActivityBuilder\n-let consentbuilder:ConsentBuilder? = ConsentBuilder()\n+let activityBuilder: ActivityBuilder? = ActivityBuilder.currentActivityBuilder\n+let consentbuilder: ConsentBuilder? = ConsentBuilder()\n //var user = User.currentUser\n \n-\n-let resourceArray : Array<Any>? = nil\n+let resourceArray: [Any]? = nil\n class ViewController: UIViewController {\n-    var user = User.currentUser\n-    \n-    override func viewDidLoad() {\n-        super.viewDidLoad()\n-        // Do any additional setup after loading the view, typically from a nib.\n-        \n-        self.userProfile()\n-        self.setPrefereneces()\n-        self.addResources()\n-        \n-        self.buildTask()\n-       // self.kickCounterTaskTest()\n-        \n-        \n-        \n-        \n-        //user.bookmarkStudy(studyId: \"121\")\n-        \n-        //user.updateStudyStatus(studyId: \"121\", status:.yetToJoin)\n-        \n-       // user.bookmarkActivity(studyId: \"121\", activityId: \"151\")\n-        \n-       // print(user.getStudyStatus(studyId: \"121\").description)\n-        \n-        //not available\n-//        let start = \"2017-03-01\"\n-//        let end = \"2017-03-05\"\n-        \n-        \n-        //run completed\n-        let start = \"2017-01-26 10:00:00\"\n-        let end = \"2017-01-30\"\n-        let runtime = \"2017-03-12\"\n-        \n-        \n-        let dateFormatter = DateFormatter()\n-        dateFormatter.dateFormat = \"yyyy-MM-dd\"\n-        let endDate:Date = dateFormatter.date(from: end)!\n-        \n-        \n-        let sdateFormatter = DateFormatter()\n-        sdateFormatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n-        let startDate:Date = sdateFormatter.date(from: start)!\n-        \n-        \n-        \n-        let rdateFormatter = DateFormatter()\n-        rdateFormatter.dateFormat = \"yyyy-MM-dd\"\n-        let rendDate:Date = rdateFormatter.date(from: runtime)!\n-        \n-        let schedular = Schedule()\n-        schedular.startTime = startDate\n-        schedular.endTime = endDate\n-        schedular.lastRunTime = rendDate\n-        \n-        //schedular.setDailyRuns()\n-        //schedular.setWeeklyRuns()\n-        //schedular.setMonthlyRuns()\n-        //schedular.setDailyFrequenyRuns()\n-        schedular.setScheduledRuns()\n-        \n-    }\n-    \n-    \n-    \n-    // MARK: methods\n-    \n-    \n-    func kickCounterTaskTest()   {\n-        \n-        let fetalKickCouterTask:FetalKickCounterTask? = FetalKickCounterTask()\n-        let task:ORKTask?\n-        let taskViewController:ORKTaskViewController?\n-        \n-        task = fetalKickCouterTask?.getTask()\n-        taskViewController = ORKTaskViewController(task:task, taskRun: nil)\n-        taskViewController?.delegate = self\n-        taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-         UIApplication.shared.statusBarStyle = .default\n-        \n-        \n-        UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor = kUIColorForSubmitButtonBackground\n-        taskViewController?.modalPresentationStyle = .fullScreen\n-        present(taskViewController!, animated: true, completion: nil)\n-\n-        \n-    }\n-    \n-    \n-    \n-    func buildTask()  {\n-        \n-        // let filePath  = Bundle.main.path(forResource: \"LatestActive_Taskdocument\", ofType: \"json\")\n-        \n-        //let filePath  = Bundle.main.path(forResource: \"ActiveTask\", ofType: \"json\")\n-        \n-         let filePath  = Bundle.main.path(forResource: \"TaskSchema\", ofType: \"json\")\n-        \n-        //let filePath  = Bundle.main.path(forResource: \"Acivity_Question\", ofType: \"json\")\n-        \n-        let data = NSData(contentsOfFile: filePath!)\n-        \n-        \n-        do {\n-            let dataDict = try JSONSerialization.jsonObject(with: data! as Data, options: []) as? Dictionary<String,Any>\n-            \n-            if  Utilities.isValidObject(someObject: dataDict as AnyObject?) && (dataDict?.count)! > 0 {\n-                \n-                \n-                let task:ORKTask?\n-                let taskViewController:ORKTaskViewController?\n-                \n-                if Utilities.isValidObject(someObject: dataDict?[\"Result\"] as? Dictionary<String, Any> as AnyObject?){\n-                    \n-                    \n-                     activityBuilder?.initActivityWithDict(dict: dataDict?[\"Result\"] as! Dictionary<String, Any>)\n-                    \n-                   \n-                    \n-                     task = activityBuilder?.createTask()\n-                    \n-                \n-                   // consentbuilder?.initWithMetaData(metaDataDict:dataDict?[\"Result\"] as! Dictionary<String, Any> )\n-                   // task = consentbuilder?.createConsentTask()\n-                    \n-                    taskViewController = ORKTaskViewController(task:task, taskRun: nil)\n-                    \n-                   // consentbuilder?.consentResult =   ConsentResult()\n-                   // consentbuilder?.consentResult?.consentDocument =  consentbuilder?.consentDocument\n-                    \n-                    taskViewController?.delegate = self\n-                    taskViewController?.outputDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\n-                    \n-                     UIApplication.shared.statusBarStyle = .default\n-                     taskViewController?.modalPresentationStyle = .fullScreen\n-                    present(taskViewController!, animated: true, completion: nil)\n-                }\n-            }\n-            \n-            // use anyObj here\n-        } catch {\n-            print(\"json error: \\(error.localizedDescription)\")\n+\n+  var user = User.currentUser\n+\n+  override func viewDidLoad() {\n+    super.viewDidLoad()\n+    // Do any additional setup after loading the view, typically from a nib.\n+\n+    self.userProfile()\n+    self.setPrefereneces()\n+    self.addResources()\n+\n+    self.buildTask()\n+\n+    // run completed\n+    let start = \"2017-01-26 10:00:00\"\n+    let end = \"2017-01-30\"\n+    let runtime = \"2017-03-12\"\n+\n+    let dateFormatter = DateFormatter()\n+    dateFormatter.dateFormat = \"yyyy-MM-dd\"\n+    let endDate: Date = dateFormatter.date(from: end)!\n+\n+    let sdateFormatter = DateFormatter()\n+    sdateFormatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n+    let startDate: Date = sdateFormatter.date(from: start)!\n+\n+    let rdateFormatter = DateFormatter()\n+    rdateFormatter.dateFormat = \"yyyy-MM-dd\"\n+    let rendDate: Date = rdateFormatter.date(from: runtime)!\n+\n+    let schedular = Schedule()\n+    schedular.startTime = startDate\n+    schedular.endTime = endDate\n+    schedular.lastRunTime = rendDate\n+    schedular.setScheduledRuns()\n+\n+  }\n+\n+  // MARK: methods\n+\n+  /// Presents `ORKTaskViewController` of type task `FetalKickCounterTask`\n+  func kickCounterTaskTest() {\n+\n+    let fetalKickCouterTask: FetalKickCounterTask? = FetalKickCounterTask()\n+    let task: ORKTask?\n+    let taskViewController: ORKTaskViewController?\n+\n+    task = fetalKickCouterTask?.getTask()\n+    taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n+    taskViewController?.delegate = self\n+    taskViewController?.outputDirectory = FileManager.default.urls(\n+      for: .documentDirectory, in: .userDomainMask).first!\n+    setNeedsStatusBarAppearanceUpdate()\n+\n+    UIView.appearance(whenContainedInInstancesOf: [ORKTaskViewController.self]).tintColor\n+      = kUIColorForSubmitButtonBackground\n+    taskViewController?.navigationBar.prefersLargeTitles = false\n+    taskViewController?.modalPresentationStyle = .fullScreen\n+    present(taskViewController!, animated: true, completion: nil)\n+\n+  }\n+\n+  /// Creates `ORKTask` instance and presents `ORKTaskViewController`\n+  func buildTask() {\n+\n+    let filePath = Bundle.main.path(forResource: \"TaskSchema\", ofType: \"json\")\n+    let data = NSData(contentsOfFile: filePath!)\n+\n+    do {\n+      let dataDict = try JSONSerialization.jsonObject(with: data! as Data, options: [])\n+        as? [String: Any]\n+\n+      if Utilities.isValidObject(someObject: dataDict as AnyObject?) && (dataDict?.count)! > 0 {\n+\n+        let task: ORKTask?\n+        let taskViewController: ORKTaskViewController?\n+\n+        if Utilities.isValidObject(\n+          someObject: dataDict?[\"Result\"] as? [String: Any] as AnyObject?) {\n+\n+          activityBuilder?.initActivityWithDict(\n+            dict: dataDict?[\"Result\"] as! [String: Any])\n+\n+          task = activityBuilder?.createTask()\n+\n+          taskViewController = ORKTaskViewController(task: task, taskRun: nil)\n+          taskViewController?.delegate = self\n+          taskViewController?.outputDirectory = FileManager.default.urls(\n+            for: .documentDirectory, in: .userDomainMask).first!\n+\n+          setNeedsStatusBarAppearanceUpdate()\n+          taskViewController?.navigationBar.prefersLargeTitles = false\n+          taskViewController?.modalPresentationStyle = .fullScreen\n+          present(taskViewController!, animated: true, completion: nil)\n         }\n-        \n-      \n-        \n+      }\n+\n+      // use anyObj here\n+    } catch {\n+      Logger.sharedInstance.info(\"json error: \\(error.localizedDescription)\")\n     }\n-    \n-    \n-    \n-    \n-    \n-    func addResources()  {\n-        \n-        if let path = Bundle.main.path(forResource: \"Resources\", ofType: \"plist\") {\n-            \n-            if let responseArray = NSArray(contentsOfFile: path) {\n-                \n-                if Utilities.isValidObject(someObject: responseArray) {\n-                    \n-                    for i in 0 ..< responseArray.count {\n-                        \n-                        if Utilities.isValidObject(someObject:responseArray[i] as AnyObject? )  {\n-                            let resource:Resource? = Resource()\n-                            \n-                            resource?.setResource(dict:(responseArray[i] as? NSDictionary)! )\n-                            responseArray.adding(resource as Any)\n-                        }\n-                        \n-                    }\n-                }\n-                \n-            }\n-            \n-            if let dict = NSDictionary(contentsOfFile: path) as? [String:Any] {\n-                user.setUser(dict:dict as NSDictionary)\n-                \n-                Logger.sharedInstance.debug(dict)\n-                Logger.sharedInstance.info(dict)\n-                Logger.sharedInstance.error(dict)\n-                \n-                \n+\n+  }\n+\n+  /// Loads Resources from local path and sets to `User` object\n+  func addResources() {\n+\n+    if let path = Bundle.main.path(forResource: \"Resources\", ofType: \"plist\") {\n+\n+      if let responseArray = NSArray(contentsOfFile: path) {\n+\n+        if Utilities.isValidObject(someObject: responseArray) {\n+\n+          for i in 0 ..< responseArray.count {\n+\n+            if Utilities.isValidObject(someObject: responseArray[i] as AnyObject?) {\n+              let resource: Resource? = Resource()\n+\n+              resource?.setResource(dict: (responseArray[i] as? NSDictionary)!)\n+              responseArray.adding(resource as Any)\n             }\n+\n+          }\n         }\n-        \n+\n+      }\n+\n+      if let dict = NSDictionary(contentsOfFile: path) as? [String: Any] {\n+        user.setUser(dict: dict as NSDictionary)\n+\n+        Logger.sharedInstance.debug(dict)\n+        Logger.sharedInstance.info(dict)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 365}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzNDQxOQ==", "bodyText": "typo", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391834419", "createdAt": "2020-03-12T19:09:25Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Models/Activity/ActivityBuilder/ActivityBuilder.swift", "diffHunk": "@@ -31,622 +28,792 @@ let kCompletionStep = \"CompletionStep\"\n let kMinimumValue = \"minValue\"\n \n enum OperatorType: String {\n-    case equal = \"e\"\n-    case lessThan = \"lt\"\n-    case lessThanOrEqual = \"lte\"\n-    case greaterThan = \"gt\"\n-    case greaterThanOrEqual = \"gte\"\n-    case notEqual = \"ne\"\n-    case range = \"range\"\n+  case equal = \"e\"\n+  case lessThan = \"lt\"\n+  case lessThanOrEqual = \"lte\"\n+  case greaterThan = \"gt\"\n+  case greaterThanOrEqual = \"gte\"\n+  case notEqual = \"ne\"\n+  case range = \"range\"\n }\n \n-\n class ActivityBuilder {\n-    \n-    static var currentActivityBuilder = ActivityBuilder()\n-    \n-    var activity: Activity?\n-    var actvityResult: ActivityResult?\n-    public var task: ORKTask?\n-    init() {\n-        activity = Activity()\n-        actvityResult = ActivityResult()\n+\n+  static var currentActivityBuilder = ActivityBuilder()\n+\n+  var activity: Activity?\n+  var actvityResult: ActivityResult?\n+  public var task: ORKTask?\n+\n+  /// Default Initializer\n+  init() {\n+    activity = Activity()\n+    actvityResult = ActivityResult()\n+  }\n+\n+  /// Initialize all properties\n+  /// - Parameter dict: `JSONDictionary` contains all properties\n+  func initActivityWithDict(dict: [String: Any]) {\n+\n+    if Utilities.isValidObject(someObject: dict as AnyObject) {\n+      self.activity?.setActivityMetaData(activityDict: dict)\n     }\n-    \n-    func initActivityWithDict(dict:Dictionary<String,Any>) {\n-        \n-        \n-        if Utilities.isValidObject(someObject: dict as AnyObject) {\n-            self.activity?.setActivityMetaData(activityDict: dict)\n-        }\n-        self.actvityResult = ActivityResult()\n-        self.actvityResult?.setActivity(activity: self.activity!)\n-        \n-        \n+    self.actvityResult = ActivityResult()\n+    self.actvityResult?.setActivity(activity: self.activity!)\n+\n+  }\n+\n+  /// Initialize all proeprties\n+  /// - Parameter activity: Instance of `Activity`\n+  func initWithActivity(activity: Activity) {\n+    if (activity.steps?.count)! > 0 {\n+      self.activity = activity\n+      self.actvityResult = ActivityResult()\n+      self.actvityResult?.setActivity(activity: self.activity!)\n     }\n-    \n-    func initWithActivity(activity:Activity)  {\n-        if (activity.steps?.count)! > 0 {\n-            self.activity = activity\n-            self.actvityResult = ActivityResult()\n-            self.actvityResult?.setActivity(activity: self.activity!)\n-        } else {\n-            Logger.sharedInstance.debug(\"Activity:activity.steps is null:\\(activity)\")\n+  }\n+\n+  /// Sets ActivtyResult using `ORKTaskResult` instance\n+  /// - Parameter taskResult: Instance of `ORKTaskResult`\n+  func setActivityResultWithORKResult(taskResult: ORKTaskResult) {\n+    actvityResult?.initWithORKTaskResult(taskResult: taskResult)\n+  }\n+\n+  /// Creates `ORKTask` instance based on ActivityType\n+  /// - Returns: `ORKTask` instance\n+  func createTask() -> ORKTask? {\n+\n+    if (activity?.type) != nil {\n+\n+      var orkStepArray: [ORKStep]?\n+\n+      orkStepArray = [ORKStep]()\n+\n+      var activityStepArray: [ActivityStep]? = [ActivityStep]()\n+\n+      switch (activity?.type!)! as ActivityType {\n+\n+      // MARK: Questionnaire\n+      case .Questionnaire:\n+        // creating step array\n+        for stepDict in (activity?.steps!)! {\n+\n+          if Utilities.isValidObject(someObject: stepDict as AnyObject?) {\n+\n+            if Utilities.isValidValue(\n+              someObject: stepDict[kActivityStepType] as AnyObject) {\n+\n+              switch ActivityStepType(\n+                rawValue: (stepDict[kActivityStepType] as? String)!)!\n+                as ActivityStepType {\n+\n+              case .instruction:\n+\n+                let instructionStep: ActivityInstructionStep?\n+                  = ActivityInstructionStep()\n+                instructionStep?.initWithDict(stepDict: stepDict)\n+                orkStepArray?.append((instructionStep?.getInstructionStep())!)\n+                activityStepArray?.append(instructionStep!)\n+\n+              case .question:\n+\n+                let questionStep: ActivityQuestionStep? = ActivityQuestionStep()\n+                questionStep?.initWithDict(stepDict: stepDict)\n+\n+                if let step = (questionStep?.getQuestionStep()) {\n+\n+                  orkStepArray?.append(step)\n+                  activityStepArray?.append(questionStep!)\n+                }\n+              case .form:\n+\n+                let formStep: ActivityFormStep? = ActivityFormStep()\n+                formStep?.initWithDict(stepDict: stepDict)\n+                orkStepArray?.append((formStep?.getFormStep())!)\n+                activityStepArray?.append(formStep!)\n+\n+              default: break\n+              }\n+            }\n+          } else {\n+            break\n+          }\n         }\n-    }\n-    \n-    func setActivityResultWithORKResult(taskResult: ORKTaskResult) {\n-        actvityResult?.initWithORKTaskResult(taskResult: taskResult)\n-    }\n-    \n-    func createTask()->ORKTask? {\n-        \n-        if  ((activity?.type) != nil) {\n-            \n-            var orkStepArray: [ORKStep]?\n-            \n-            orkStepArray = Array<ORKStep>()\n-            \n-            var activityStepArray: [ActivityStep]? = Array<ActivityStep>()\n-            \n-            switch (activity?.type!)! as ActivityType {\n-                \n-            // MARK: Questionnaire\n-            case .Questionnaire:\n-                \n-                // creating step array\n-                \n-                for var stepDict in (activity?.steps!)! {\n-                    \n-                    if Utilities.isValidObject(someObject: stepDict as AnyObject?) {\n-                        \n-                        if Utilities.isValidValue(someObject: stepDict[kActivityStepType] as AnyObject ) {\n-                            \n-                            switch ActivityStepType(rawValue:(stepDict[kActivityStepType] as? String)!)! as  ActivityStepType {\n-                                \n-                            case .instruction:\n-                                \n-                                let instructionStep: ActivityInstructionStep? = ActivityInstructionStep()\n-                                instructionStep?.initWithDict(stepDict: stepDict)\n-                                orkStepArray?.append((instructionStep?.getInstructionStep())!)\n-                                activityStepArray?.append(instructionStep!)\n-                                \n-                            case .question:\n-                                \n-                                let questionStep: ActivityQuestionStep? = ActivityQuestionStep()\n-                                questionStep?.initWithDict(stepDict: stepDict)\n-                                \n-                                if let step = (questionStep?.getQuestionStep()) {\n-                                    \n-                                    orkStepArray?.append(step)\n-                                    activityStepArray?.append(questionStep!)\n-                                }\n-                            case .form:\n-                                \n-                                let formStep: ActivityFormStep? = ActivityFormStep()\n-                                formStep?.initWithDict(stepDict: stepDict)\n-                                orkStepArray?.append((formStep?.getFormStep())!)\n-                                activityStepArray?.append(formStep!)\n-                                \n-                            default: break\n-                            }\n-                        }\n-                    } else {\n-                        Logger.sharedInstance.debug(\"Activity:stepDict is null:\\(stepDict)\")\n-                        break;\n-                    }\n+\n+        if (orkStepArray?.count)! > 0 {\n+\n+          self.activity?.setORKSteps(orkStepArray: orkStepArray!)\n+          self.activity?.setActivityStepArray(stepArray: activityStepArray!)\n+\n+          // addding completion step\n+          let completionStep = ORKCompletionStep(identifier: kCompletionStep)\n+\n+          completionStep.title = \"Activity Completed\"\n+          completionStep.image = #imageLiteral(resourceName: \"successBlueBig\")\n+          completionStep.detailText\n+            = \"Tap Done to submit responses. Responses cannot be modified after submission\"\n+          orkStepArray?.append(completionStep)\n+\n+          // Creating ordered or navigable task\n+          if (orkStepArray?.count)! > 0 {\n+\n+            task = ORKOrderedTask(\n+              identifier: (activity?.actvityId!)!, steps: orkStepArray)\n+\n+            if self.activity?.branching == true {  //For Branching/Navigable Task\n+              task = ORKNavigableOrderedTask(\n+                identifier: (activity?.actvityId)!, steps: orkStepArray)\n+\n+            } else {\n+              // For OrderedTask\n+              task = ORKOrderedTask(\n+                identifier: (activity?.actvityId)!, steps: orkStepArray)\n+            }\n+          }\n+          var i: Int? = 0\n+\n+          if self.activity?.branching == true {\n+\n+            for step in orkStepArray! {\n+              // Setting ActivityStep\n+              if step.isKind(of: ORKQuestionStep.self) || step is RepeatableFormStep\n+                || step\n+                is ORKFormStep || (\n+                  step.isKind(of: ORKInstructionStep.self) && step.isKind(\n+                    of: ORKCompletionStep.self) == false\n+                ) {\n+\n+                let activityStep: ActivityStep?\n+\n+                if step.isKind(of: ORKQuestionStep.self) || (\n+                  step.isKind(of: ORKInstructionStep.self) == false && step\n+                    .isKind(\n+                      of: ORKCompletionStep.self) == false\n+                ) {\n+                  activityStep = activityStepArray?[(i!)] as? ActivityQuestionStep\n+\n+                } else if step.isKind(of: ORKFormStep.self) || step.isKind(\n+                  of: RepeatableFormStep.self) {\n+                  activityStep = activityStepArray?[(i!)] as? ActivityFormStep\n+\n+                } else {\n+                  activityStep = activityStepArray?[(i!)]\n+                    as? ActivityInstructionStep\n                 }\n-                \n-                if (orkStepArray?.count)! > 0 {\n-                    \n-                    self.activity?.setORKSteps(orkStepArray: orkStepArray!)\n-                    self.activity?.setActivityStepArray(stepArray: activityStepArray!)\n-                    \n-                    //addding completion step\n-                    let completionStep = ORKCompletionStep(identifier: kCompletionStep)\n-                    \n-                    completionStep.title = \"Activity Completed\"\n-                    completionStep.image = #imageLiteral(resourceName: \"successBlueBig\")\n-                    completionStep.detailText = \"Tap Done to submit responses. Responses cannot be modified after submission\"\n-                    orkStepArray?.append(completionStep)\n-                    \n-                    //Creating ordered or navigable task\n-                    if (orkStepArray?.count)! > 0 {\n-                        \n-                        task =  ORKOrderedTask(identifier: (activity?.actvityId!)!, steps: orkStepArray)\n-                        \n-                        if self.activity?.branching == true { //For Branching/Navigable Task\n-                            task =  ORKNavigableOrderedTask(identifier: (activity?.actvityId)!, steps: orkStepArray)\n-                            \n-                        } else { //For OrderedTask\n-                            task =  ORKOrderedTask(identifier: (activity?.actvityId)!, steps: orkStepArray)\n+\n+                if activityStep?.destinations != nil && (\n+                  activityStep?.destinations?.count\n+                )! > 0 {\n+\n+                  var defaultStepIdentifier: String = \"\"\n+\n+                  // Setting Next Step as Default destination\n+                  if i! + 1 < (activityStepArray?.count)! {\n+                    defaultStepIdentifier = (activityStepArray?[(i!+1)].key)!\n+\n+                  } else {  // Setting Completion Step as Default destination\n+                    defaultStepIdentifier = kCompletionStep\n+                  }\n+\n+                  var defaultStepExist: Bool? = false\n+                  let resultSelector: ORKResultSelector?\n+                  var predicateRule: ORKPredicateStepNavigationRule?\n+\n+                  // Creating Result Selector\n+                  resultSelector = ORKResultSelector(\n+                    stepIdentifier: step.identifier,\n+                    resultIdentifier: step.identifier)\n+                  let questionStep: ORKStep?\n+\n+                  // Intializing Question Step\n+                  if step.isKind(of: ORKQuestionStep.self) {\n+                    questionStep = (step as? ORKQuestionStep)!\n+\n+                  } else if step is RepeatableFormStep {\n+                    questionStep = (step as? RepeatableFormStep)!\n+\n+                  } else if step is ORKFormStep {\n+                    questionStep = (step as? ORKFormStep)!\n+\n+                  } else {\n+                    questionStep = (step as? ORKInstructionStep)!\n+                  }\n+\n+                  // Choicearray and destination array will hold predicates & their respective destination\n+                  var choicePredicate: [NSPredicate] = [NSPredicate]()\n+                  var destination: [String]? = [String]()\n+\n+                  for dict in (activityStep?.destinations)! {\n+\n+                    var predicateQuestionChoiceA: NSPredicate = NSPredicate()\n+\n+                    // Condition is not nil\n+                    if Utilities.isValidValue(\n+                      someObject: dict[kCondtion] as AnyObject) {\n+\n+                      switch (questionStep as? ORKQuestionStep)!.answerFormat {\n+\n+                      case is ORKTextChoiceAnswerFormat,\n+                        is ORKTextScaleAnswerFormat,\n+                        is ORKImageChoiceAnswerFormat:\n+\n+                        predicateQuestionChoiceA = ORKResultPredicate\n+                          .predicateForChoiceQuestionResult(\n+                            with: resultSelector!,\n+                            expectedAnswerValue: dict[kCondtion]\n+                              as! NSCoding & NSCopying\n+                              & NSObjectProtocol)\n+\n+                        choicePredicate.append(predicateQuestionChoiceA)\n+\n+                        if dict[kCondtion] != nil && dict[kDestination]\n+                          != nil && (\n+                            dict[kDestination] as? String\n+                          )! == \"\" {\n+                          // this means c = value & d = \"\"\n+                          destination?.append(kCompletionStep)\n+\n+                        } else {\n+                          // this means c = value && d =  value\n+                          destination?.append(\n+                            (dict[kDestination]! as? String)!)\n                         }\n-                    }\n-                    var i: Int? = 0\n-                    \n-                    if self.activity?.branching == true {\n-                        \n-                        for step in orkStepArray! {\n-                            //Setting ActivityStep\n-                            if step.isKind(of: ORKQuestionStep.self) || step is RepeatableFormStep || step is ORKFormStep || (step.isKind(of: ORKInstructionStep.self) && step.isKind(of: ORKCompletionStep.self) == false) {\n-                                \n-                                let activityStep: ActivityStep?\n-                                \n-                                if step.isKind(of: ORKQuestionStep.self) || (step.isKind(of: ORKInstructionStep.self) == false && step.isKind(of: ORKCompletionStep.self) == false) {\n-                                    activityStep = activityStepArray?[(i!)] as?  ActivityQuestionStep\n-                                    \n-                                } else if step.isKind(of: ORKFormStep.self) || step.isKind(of: RepeatableFormStep.self) {\n-                                    activityStep = activityStepArray?[(i!)] as?  ActivityFormStep\n-                                    \n-                                } else {\n-                                    activityStep = activityStepArray?[(i!)] as?  ActivityInstructionStep\n-                                }\n-                                \n-                                if activityStep?.destinations != nil && (activityStep?.destinations?.count)! > 0 {\n-                                    \n-                                    var defaultStepIdentifier: String = \"\"\n-                                    \n-                                    //Setting Next Step as Default destination\n-                                    if i! + 1 < (activityStepArray?.count)! {\n-                                        defaultStepIdentifier = (activityStepArray?[(i!+1)].key)!\n-                                        \n-                                    } else { //Setting Completion Step as Default destination\n-                                        defaultStepIdentifier = kCompletionStep\n-                                    }\n-                                    \n-                                    var defaultStepExist: Bool? = false\n-                                    let resultSelector: ORKResultSelector?\n-                                    var predicateRule: ORKPredicateStepNavigationRule?\n-                                    \n-                                    //Creating Result Selector\n-                                    resultSelector =  ORKResultSelector(stepIdentifier: step.identifier, resultIdentifier: step.identifier)\n-                                    let questionStep: ORKStep?\n-                                    \n-                                    //Intializing Question Step\n-                                    if step.isKind(of: ORKQuestionStep.self) {\n-                                        questionStep = (step as? ORKQuestionStep)!\n-                                        \n-                                    } else if step is RepeatableFormStep {\n-                                        questionStep = (step as? RepeatableFormStep)!\n-                                        \n-                                    } else if step is ORKFormStep {\n-                                        questionStep = (step as? ORKFormStep)!\n-                                        \n-                                    } else {\n-                                        questionStep = (step as? ORKInstructionStep)!\n-                                    }\n-                                    \n-                                    //choicearray and destination array will hold predicates & their respective destination\n-                                    var choicePredicate: [NSPredicate] = [NSPredicate]()\n-                                    var destination: Array<String>? = Array<String>()\n-                                    \n-                                    for dict in (activityStep?.destinations)! {\n-                                        \n-                                        var predicateQuestionChoiceA: NSPredicate = NSPredicate()\n-                                        \n-                                        //Condition is not nil\n-                                        if Utilities.isValidValue(someObject: dict[kCondtion] as AnyObject) {\n-                                            \n-                                            switch (questionStep as? ORKQuestionStep)!.answerFormat {\n-                                                \n-                                            case is ORKTextChoiceAnswerFormat, is ORKTextScaleAnswerFormat, is ORKImageChoiceAnswerFormat:\n-                                                \n-                                                predicateQuestionChoiceA = ORKResultPredicate.predicateForChoiceQuestionResult(with: resultSelector! , expectedAnswerValue: dict[kCondtion] as! NSCoding & NSCopying & NSObjectProtocol)\n-                                                \n-                                                choicePredicate.append(predicateQuestionChoiceA)\n-                                                \n-                                                if dict[kCondtion] != nil && dict[kDestination] != nil && (dict[kDestination] as? String)! == \"\" {\n-                                                    // this means c = value & d = \"\"\n-                                                    destination?.append( kCompletionStep )\n-                                                    \n-                                                } else {\n-                                                    // this means c = value && d =  value\n-                                                    destination?.append( (dict[kDestination]! as? String)!)\n-                                                }\n-                                                \n-                                            case is ORKNumericAnswerFormat ,is ORKScaleAnswerFormat,is ORKTimeIntervalAnswerFormat,is ORKHeightAnswerFormat, is ORKContinuousScaleAnswerFormat,is ORKHealthKitQuantityTypeAnswerFormat:\n-                                                \n-                                                if let operatorValue = dict[kOperator] as? String {\n-                                                    \n-                                                    let condition: String = (dict[kCondtion] as? String)!\n-                                                    let  conditionValue = condition.components(separatedBy: CharacterSet.init(charactersIn: \",\"))\n-                                                    \n-                                                    var lhs: Double? = 0.0\n-                                                    var rhs: Double? = 0.0\n-                                                    \n-                                                    lhs = Double(conditionValue.first!)\n-                                                    if conditionValue.count == 2 { //multiple conditions exists\n-                                                        rhs = Double(conditionValue.last!)\n-                                                    }\n-                                                    let operatorType:OperatorType = OperatorType(rawValue: operatorValue)!\n-                                                    \n-                                                    switch((questionStep as? ORKQuestionStep)!.answerFormat) {\n-                                                    case is ORKNumericAnswerFormat,is ORKHeightAnswerFormat,is ORKHealthKitQuantityTypeAnswerFormat: //Height & Numeric Question\n-                                                        \n-                                                        var minimumValue = (activityStep as? ActivityQuestionStep)!.formatDict![kMinimumValue] as? Float\n-                                                        \n-                                                        var style = \"\"\n-                                                        \n-                                                        if ((questionStep as? ORKQuestionStep)!.answerFormat! is ORKHeightAnswerFormat ) {\n-                                                            minimumValue = 0\n-                                                            \n-                                                        } else {\n-                                                            style = ((activityStep as? ActivityQuestionStep)!.formatDict![kStepQuestionNumericStyle] as? String)!\n-                                                        }\n-                                                        \n-                                                        predicateQuestionChoiceA = self.getPredicateForNumeric(resultSelector: resultSelector!, lhs: lhs!, minimumValue: minimumValue!, operatorType: operatorType,answerFormat: (questionStep as? ORKQuestionStep)!.answerFormat!,style: style)\n-                                                        \n-                                                    case is ORKTimeIntervalAnswerFormat: //TimeInterval\n-                                                        \n-                                                        predicateQuestionChoiceA = self.getPredicateForTimeInterval(resultSelector: resultSelector!, lhs: lhs!, minimumValue: 0.0, operatorType: operatorType)\n-                                                        \n-                                                    case is ORKScaleAnswerFormat, is ORKContinuousScaleAnswerFormat: //Scale & Continuos Scale\n-                                                        \n-                                                        let minimumValue = (activityStep as? ActivityQuestionStep)!.formatDict![kMinimumValue] as? Float\n-                                                        \n-                                                        predicateQuestionChoiceA = self.getPredicateForScale(resultSelector: resultSelector!, lhs: lhs!, minimumValue: minimumValue!, operatorType: operatorType,rhs: rhs!, resultType: ((questionStep as? ORKQuestionStep)!.answerFormat)!,activityStep:activityStep!)\n-                                                        \n-                                                    case .none: break\n-                                                        \n-                                                    case .some(_): break\n-                                                        \n-                                                    }\n-                                                    choicePredicate.append(predicateQuestionChoiceA)\n-                                                    \n-                                                    if dict[kCondtion] != nil && dict[kDestination] != nil && (dict[kDestination] as? String)! == \"\" {\n-                                                        // this means c = value & d = \"\"\n-                                                        destination?.append( kCompletionStep )\n-                                                        \n-                                                    } else {\n-                                                        // this means c = value && d =  value\n-                                                        destination?.append( (dict[kDestination]! as? String)!)\n-                                                    }\n-                                                } else {\n-                                                }\n-                                                \n-                                            case is ORKBooleanAnswerFormat :\n-                                                \n-                                                var boolValue: Bool? = false\n-                                                \n-                                                if (dict[kCondtion] as? String)!.caseInsensitiveCompare(\"true\") ==  ComparisonResult.orderedSame {\n-                                                    boolValue = true\n-                                                    \n-                                                } else {\n-                                                    if (dict[kCondtion] as? String)!.caseInsensitiveCompare(\"false\") ==  ComparisonResult.orderedSame {\n-                                                        boolValue = false\n-                                                        \n-                                                    } else if (dict[kCondtion] as? String)! == \"\" {\n-                                                        boolValue = nil\n-                                                        if Utilities.isValidValue(someObject: dict[kDestination] as AnyObject? ) {\n-                                                            \n-                                                            defaultStepIdentifier = (dict[kDestination]! as? String)!\n-                                                        }\n-                                                    }\n-                                                }\n-                                                \n-                                                if  boolValue != nil {\n-                                                    \n-                                                    predicateQuestionChoiceA = ORKResultPredicate.predicateForBooleanQuestionResult(with: resultSelector!, expectedAnswer: boolValue!)\n-                                                }\n-                                                choicePredicate.append(predicateQuestionChoiceA)\n-                                                \n-                                                if dict[kCondtion] != nil && dict[kDestination] != nil && (dict[kDestination] as? String)! == \"\" {\n-                                                    // this means c = value & d = \"\"\n-                                                    destination?.append( kCompletionStep )\n-                                                    \n-                                                } else {\n-                                                    // this means c = value && d =  value\n-                                                    destination?.append( (dict[kDestination]! as? String)!)\n-                                                }\n-                                            default: break\n-                                            }\n-                                        } else {\n-                                            // it means condition is empty\n-                                            if dict[kCondtion] != nil && (dict[kCondtion] as? String)! == \"\" {\n-                                                \n-                                                defaultStepExist = true\n-                                                if Utilities.isValidValue(someObject: dict[kDestination] as AnyObject? ) {\n-                                                    // means we ahave valid destination\n-                                                    defaultStepIdentifier = (dict[kDestination]! as? String)!\n-                                                    \n-                                                } else {\n-                                                    // invalid destination i.e condition = \"\" && destination = \"\"\n-                                                    defaultStepIdentifier = kCompletionStep\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                    if choicePredicate.count == 0 {\n-                                        \n-                                        // if condition is empty\n-                                        \n-                                        if (destination?.count)! > 0 {\n-                                            \n-                                            // if destination is not empty but condition is empty\n-                                            \n-                                            for destinationId in destination! {\n-                                                \n-                                                if destinationId.count != 0 {\n-                                                    \n-                                                    let  directRule = ORKDirectStepNavigationRule(destinationStepIdentifier: destinationId)\n-                                                    \n-                                                    (task as? ORKNavigableOrderedTask)!.setNavigationRule(directRule, forTriggerStepIdentifier: step.identifier)\n-                                                }\n-                                            }\n-                                        } else {\n-                                            // if both destination and condition are empty\n-                                            let  directRule: ORKDirectStepNavigationRule!\n-                                            \n-                                            if defaultStepExist == false {\n-                                                directRule = ORKDirectStepNavigationRule(destinationStepIdentifier: kCompletionStep)\n-                                            } else {\n-                                                directRule = ORKDirectStepNavigationRule(destinationStepIdentifier: defaultStepIdentifier)\n-                                            }\n-                                            \n-                                            (task as? ORKNavigableOrderedTask)!.setNavigationRule(directRule!, forTriggerStepIdentifier:step.identifier)\n-                                        }\n-                                    } else {\n-                                        \n-                                        predicateRule = ORKPredicateStepNavigationRule(resultPredicates: choicePredicate, destinationStepIdentifiers: destination!, defaultStepIdentifier: defaultStepIdentifier, validateArrays: true)\n-                                        \n-                                        (task as? ORKNavigableOrderedTask)!.setNavigationRule(predicateRule!, forTriggerStepIdentifier:step.identifier)\n-                                    }\n-                                } else {\n-                                    //destination array is empty - Do Nothing\n-                                }\n+\n+                      case is ORKNumericAnswerFormat, is ORKScaleAnswerFormat,\n+                        is ORKTimeIntervalAnswerFormat,\n+                        is ORKHeightAnswerFormat,\n+                        is ORKContinuousScaleAnswerFormat,\n+                        is ORKHealthKitQuantityTypeAnswerFormat:\n+\n+                        if let operatorValue = dict[kOperator] as? String {\n+\n+                          let condition: String = (\n+                            dict[kCondtion] as? String\n+                          )!\n+                          let conditionValue = condition.components(\n+                            separatedBy: CharacterSet.init(\n+                              charactersIn: \",\"))\n+\n+                          var lhs: Double? = 0.0\n+                          var rhs: Double? = 0.0\n+\n+                          lhs = Double(conditionValue.first!)\n+                          if conditionValue.count == 2 {  // multiple conditions exists\n+                            rhs = Double(conditionValue.last!)\n+                          }\n+                          let operatorType: OperatorType = OperatorType(\n+                            rawValue: operatorValue)!\n+\n+                          switch\n+                            (questionStep as? ORKQuestionStep)!\n+                              .answerFormat {\n+                          case is ORKNumericAnswerFormat,\n+                            is ORKHeightAnswerFormat,\n+                            is ORKHealthKitQuantityTypeAnswerFormat:  // Height & Numeric Question\n+\n+                            var minimumValue = (\n+                              activityStep as? ActivityQuestionStep\n+                            )!.formatDict![\n+                              kMinimumValue] as? Float\n+\n+                            var style = \"\"\n+\n+                            if\n+                              (questionStep as? ORKQuestionStep)!\n+                                .answerFormat!\n+                                is ORKHeightAnswerFormat {\n+                              minimumValue = 0\n+\n                             } else {\n-                                //this is not question step\n+                              style = (\n+                                (\n+                                  activityStep\n+                                    as? ActivityQuestionStep\n+                                )!.formatDict![\n+                                  kStepQuestionNumericStyle]\n+                                  as? String\n+                              )!\n                             }\n-                            i = i! + 1\n+\n+                            predicateQuestionChoiceA = self\n+                              .getPredicateForNumeric(\n+                                resultSelector: resultSelector!,\n+                                lhs: lhs!,\n+                                minimumValue: minimumValue!,\n+                                operatorType: operatorType,\n+                                answerFormat: (\n+                                  questionStep as? ORKQuestionStep\n+                                )!.answerFormat!,\n+                                style: style)\n+\n+                          case is ORKTimeIntervalAnswerFormat:  // TimeInterval\n+\n+                            predicateQuestionChoiceA = self\n+                              .getPredicateForTimeInterval(\n+                                resultSelector: resultSelector!,\n+                                lhs: lhs!, minimumValue: 0.0,\n+                                operatorType: operatorType)\n+\n+                          case is ORKScaleAnswerFormat,\n+                            is ORKContinuousScaleAnswerFormat:  // Scale & Continuos Scale\n+\n+                            let minimumValue = (\n+                              activityStep as? ActivityQuestionStep\n+                            )!.formatDict![\n+                              kMinimumValue] as? Float\n+\n+                            predicateQuestionChoiceA = self\n+                              .getPredicateForScale(\n+                                resultSelector: resultSelector!,\n+                                lhs: lhs!,\n+                                minimumValue: minimumValue!,\n+                                operatorType: operatorType,\n+                                rhs: rhs!,\n+                                resultType: (\n+                                  (\n+                                    questionStep\n+                                      as? ORKQuestionStep\n+                                  )!.answerFormat\n+                                )!,\n+                                activityStep: activityStep!)\n+\n+                          case .none: break\n+\n+                          case .some: break\n+\n+                          }\n+                          choicePredicate.append(predicateQuestionChoiceA)\n+\n+                          if dict[kCondtion] != nil && dict[kDestination]\n+                            != nil && (\n+                              dict[kDestination] as? String\n+                            )! == \"\" {\n+                            // this means c = value & d = \"\"\n+                            destination?.append(kCompletionStep)\n+\n+                          } else {\n+                            // this means c = value && d =  value\n+                            destination?.append(\n+                              (dict[kDestination]! as? String)!)\n+                          }\n+                        } else {\n                         }\n-                    }\n-                    if task != nil {\n-                        \n-                        if (self.activity?.branching)! {\n-                            return (task as? ORKNavigableOrderedTask)!\n+\n+                      case is ORKBooleanAnswerFormat:\n+\n+                        var boolValue: Bool? = false\n+\n+                        if (dict[kCondtion] as? String)!\n+                          .caseInsensitiveCompare(\"true\")\n+                          == ComparisonResult.orderedSame {\n+                          boolValue = true\n+\n+                        } else {\n+                          if (dict[kCondtion] as? String)!\n+                            .caseInsensitiveCompare(\"false\")\n+                            == ComparisonResult.orderedSame {\n+                            boolValue = false\n+\n+                          } else if (dict[kCondtion] as? String)! == \"\" {\n+                            boolValue = nil\n+                            if Utilities.isValidValue(\n+                              someObject: dict[kDestination]\n+                                as AnyObject?) {\n+\n+                              defaultStepIdentifier = (\n+                                dict[kDestination]! as? String\n+                              )!\n+                            }\n+                          }\n+                        }\n+\n+                        if boolValue != nil {\n+\n+                          predicateQuestionChoiceA = ORKResultPredicate\n+                            .predicateForBooleanQuestionResult(\n+                              with: resultSelector!,\n+                              expectedAnswer: boolValue!)\n+                        }\n+                        choicePredicate.append(predicateQuestionChoiceA)\n+\n+                        if dict[kCondtion] != nil && dict[kDestination]\n+                          != nil && (\n+                            dict[kDestination] as? String\n+                          )! == \"\" {\n+                          // this means c = value & d = \"\"\n+                          destination?.append(kCompletionStep)\n+\n                         } else {\n-                            return (task as? ORKOrderedTask)!\n+                          // this means c = value && d =  value\n+                          destination?.append(\n+                            (dict[kDestination]! as? String)!)\n                         }\n+                      default: break\n+                      }\n                     } else {\n-                        return nil\n+                      // it means condition is empty\n+                      if dict[kCondtion] != nil && (\n+                        dict[kCondtion] as? String\n+                      )! == \"\" {\n+\n+                        defaultStepExist = true\n+                        if Utilities.isValidValue(\n+                          someObject: dict[kDestination] as AnyObject?) {\n+                          // means we ahave valid destination", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 844}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzNTIzMg==", "bodyText": "these comments are not needed.", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391835232", "createdAt": "2020-03-12T19:11:03Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Models/Activity/ActivityBuilder/ActivityBuilder.swift", "diffHunk": "@@ -31,622 +28,792 @@ let kCompletionStep = \"CompletionStep\"\n let kMinimumValue = \"minValue\"\n \n enum OperatorType: String {\n-    case equal = \"e\"\n-    case lessThan = \"lt\"\n-    case lessThanOrEqual = \"lte\"\n-    case greaterThan = \"gt\"\n-    case greaterThanOrEqual = \"gte\"\n-    case notEqual = \"ne\"\n-    case range = \"range\"\n+  case equal = \"e\"\n+  case lessThan = \"lt\"\n+  case lessThanOrEqual = \"lte\"\n+  case greaterThan = \"gt\"\n+  case greaterThanOrEqual = \"gte\"\n+  case notEqual = \"ne\"\n+  case range = \"range\"\n }\n \n-\n class ActivityBuilder {\n-    \n-    static var currentActivityBuilder = ActivityBuilder()\n-    \n-    var activity: Activity?\n-    var actvityResult: ActivityResult?\n-    public var task: ORKTask?\n-    init() {\n-        activity = Activity()\n-        actvityResult = ActivityResult()\n+\n+  static var currentActivityBuilder = ActivityBuilder()\n+\n+  var activity: Activity?\n+  var actvityResult: ActivityResult?\n+  public var task: ORKTask?\n+\n+  /// Default Initializer\n+  init() {\n+    activity = Activity()\n+    actvityResult = ActivityResult()\n+  }\n+\n+  /// Initialize all properties\n+  /// - Parameter dict: `JSONDictionary` contains all properties\n+  func initActivityWithDict(dict: [String: Any]) {\n+\n+    if Utilities.isValidObject(someObject: dict as AnyObject) {\n+      self.activity?.setActivityMetaData(activityDict: dict)\n     }\n-    \n-    func initActivityWithDict(dict:Dictionary<String,Any>) {\n-        \n-        \n-        if Utilities.isValidObject(someObject: dict as AnyObject) {\n-            self.activity?.setActivityMetaData(activityDict: dict)\n-        }\n-        self.actvityResult = ActivityResult()\n-        self.actvityResult?.setActivity(activity: self.activity!)\n-        \n-        \n+    self.actvityResult = ActivityResult()\n+    self.actvityResult?.setActivity(activity: self.activity!)\n+\n+  }\n+\n+  /// Initialize all proeprties\n+  /// - Parameter activity: Instance of `Activity`\n+  func initWithActivity(activity: Activity) {\n+    if (activity.steps?.count)! > 0 {\n+      self.activity = activity\n+      self.actvityResult = ActivityResult()\n+      self.actvityResult?.setActivity(activity: self.activity!)\n     }\n-    \n-    func initWithActivity(activity:Activity)  {\n-        if (activity.steps?.count)! > 0 {\n-            self.activity = activity\n-            self.actvityResult = ActivityResult()\n-            self.actvityResult?.setActivity(activity: self.activity!)\n-        } else {\n-            Logger.sharedInstance.debug(\"Activity:activity.steps is null:\\(activity)\")\n+  }\n+\n+  /// Sets ActivtyResult using `ORKTaskResult` instance\n+  /// - Parameter taskResult: Instance of `ORKTaskResult`\n+  func setActivityResultWithORKResult(taskResult: ORKTaskResult) {\n+    actvityResult?.initWithORKTaskResult(taskResult: taskResult)\n+  }\n+\n+  /// Creates `ORKTask` instance based on ActivityType\n+  /// - Returns: `ORKTask` instance\n+  func createTask() -> ORKTask? {\n+\n+    if (activity?.type) != nil {\n+\n+      var orkStepArray: [ORKStep]?\n+\n+      orkStepArray = [ORKStep]()\n+\n+      var activityStepArray: [ActivityStep]? = [ActivityStep]()\n+\n+      switch (activity?.type!)! as ActivityType {\n+\n+      // MARK: Questionnaire\n+      case .Questionnaire:\n+        // creating step array\n+        for stepDict in (activity?.steps!)! {\n+\n+          if Utilities.isValidObject(someObject: stepDict as AnyObject?) {\n+\n+            if Utilities.isValidValue(\n+              someObject: stepDict[kActivityStepType] as AnyObject) {\n+\n+              switch ActivityStepType(\n+                rawValue: (stepDict[kActivityStepType] as? String)!)!\n+                as ActivityStepType {\n+\n+              case .instruction:\n+\n+                let instructionStep: ActivityInstructionStep?\n+                  = ActivityInstructionStep()\n+                instructionStep?.initWithDict(stepDict: stepDict)\n+                orkStepArray?.append((instructionStep?.getInstructionStep())!)\n+                activityStepArray?.append(instructionStep!)\n+\n+              case .question:\n+\n+                let questionStep: ActivityQuestionStep? = ActivityQuestionStep()\n+                questionStep?.initWithDict(stepDict: stepDict)\n+\n+                if let step = (questionStep?.getQuestionStep()) {\n+\n+                  orkStepArray?.append(step)\n+                  activityStepArray?.append(questionStep!)\n+                }\n+              case .form:\n+\n+                let formStep: ActivityFormStep? = ActivityFormStep()\n+                formStep?.initWithDict(stepDict: stepDict)\n+                orkStepArray?.append((formStep?.getFormStep())!)\n+                activityStepArray?.append(formStep!)\n+\n+              default: break\n+              }\n+            }\n+          } else {\n+            break\n+          }\n         }\n-    }\n-    \n-    func setActivityResultWithORKResult(taskResult: ORKTaskResult) {\n-        actvityResult?.initWithORKTaskResult(taskResult: taskResult)\n-    }\n-    \n-    func createTask()->ORKTask? {\n-        \n-        if  ((activity?.type) != nil) {\n-            \n-            var orkStepArray: [ORKStep]?\n-            \n-            orkStepArray = Array<ORKStep>()\n-            \n-            var activityStepArray: [ActivityStep]? = Array<ActivityStep>()\n-            \n-            switch (activity?.type!)! as ActivityType {\n-                \n-            // MARK: Questionnaire\n-            case .Questionnaire:\n-                \n-                // creating step array\n-                \n-                for var stepDict in (activity?.steps!)! {\n-                    \n-                    if Utilities.isValidObject(someObject: stepDict as AnyObject?) {\n-                        \n-                        if Utilities.isValidValue(someObject: stepDict[kActivityStepType] as AnyObject ) {\n-                            \n-                            switch ActivityStepType(rawValue:(stepDict[kActivityStepType] as? String)!)! as  ActivityStepType {\n-                                \n-                            case .instruction:\n-                                \n-                                let instructionStep: ActivityInstructionStep? = ActivityInstructionStep()\n-                                instructionStep?.initWithDict(stepDict: stepDict)\n-                                orkStepArray?.append((instructionStep?.getInstructionStep())!)\n-                                activityStepArray?.append(instructionStep!)\n-                                \n-                            case .question:\n-                                \n-                                let questionStep: ActivityQuestionStep? = ActivityQuestionStep()\n-                                questionStep?.initWithDict(stepDict: stepDict)\n-                                \n-                                if let step = (questionStep?.getQuestionStep()) {\n-                                    \n-                                    orkStepArray?.append(step)\n-                                    activityStepArray?.append(questionStep!)\n-                                }\n-                            case .form:\n-                                \n-                                let formStep: ActivityFormStep? = ActivityFormStep()\n-                                formStep?.initWithDict(stepDict: stepDict)\n-                                orkStepArray?.append((formStep?.getFormStep())!)\n-                                activityStepArray?.append(formStep!)\n-                                \n-                            default: break\n-                            }\n-                        }\n-                    } else {\n-                        Logger.sharedInstance.debug(\"Activity:stepDict is null:\\(stepDict)\")\n-                        break;\n-                    }\n+\n+        if (orkStepArray?.count)! > 0 {\n+\n+          self.activity?.setORKSteps(orkStepArray: orkStepArray!)\n+          self.activity?.setActivityStepArray(stepArray: activityStepArray!)\n+\n+          // addding completion step\n+          let completionStep = ORKCompletionStep(identifier: kCompletionStep)\n+\n+          completionStep.title = \"Activity Completed\"\n+          completionStep.image = #imageLiteral(resourceName: \"successBlueBig\")\n+          completionStep.detailText\n+            = \"Tap Done to submit responses. Responses cannot be modified after submission\"\n+          orkStepArray?.append(completionStep)\n+\n+          // Creating ordered or navigable task\n+          if (orkStepArray?.count)! > 0 {\n+\n+            task = ORKOrderedTask(\n+              identifier: (activity?.actvityId!)!, steps: orkStepArray)\n+\n+            if self.activity?.branching == true {  //For Branching/Navigable Task\n+              task = ORKNavigableOrderedTask(\n+                identifier: (activity?.actvityId)!, steps: orkStepArray)\n+\n+            } else {\n+              // For OrderedTask\n+              task = ORKOrderedTask(\n+                identifier: (activity?.actvityId)!, steps: orkStepArray)\n+            }\n+          }\n+          var i: Int? = 0\n+\n+          if self.activity?.branching == true {\n+\n+            for step in orkStepArray! {\n+              // Setting ActivityStep\n+              if step.isKind(of: ORKQuestionStep.self) || step is RepeatableFormStep\n+                || step\n+                is ORKFormStep || (\n+                  step.isKind(of: ORKInstructionStep.self) && step.isKind(\n+                    of: ORKCompletionStep.self) == false\n+                ) {\n+\n+                let activityStep: ActivityStep?\n+\n+                if step.isKind(of: ORKQuestionStep.self) || (\n+                  step.isKind(of: ORKInstructionStep.self) == false && step\n+                    .isKind(\n+                      of: ORKCompletionStep.self) == false\n+                ) {\n+                  activityStep = activityStepArray?[(i!)] as? ActivityQuestionStep\n+\n+                } else if step.isKind(of: ORKFormStep.self) || step.isKind(\n+                  of: RepeatableFormStep.self) {\n+                  activityStep = activityStepArray?[(i!)] as? ActivityFormStep\n+\n+                } else {\n+                  activityStep = activityStepArray?[(i!)]\n+                    as? ActivityInstructionStep\n                 }\n-                \n-                if (orkStepArray?.count)! > 0 {\n-                    \n-                    self.activity?.setORKSteps(orkStepArray: orkStepArray!)\n-                    self.activity?.setActivityStepArray(stepArray: activityStepArray!)\n-                    \n-                    //addding completion step\n-                    let completionStep = ORKCompletionStep(identifier: kCompletionStep)\n-                    \n-                    completionStep.title = \"Activity Completed\"\n-                    completionStep.image = #imageLiteral(resourceName: \"successBlueBig\")\n-                    completionStep.detailText = \"Tap Done to submit responses. Responses cannot be modified after submission\"\n-                    orkStepArray?.append(completionStep)\n-                    \n-                    //Creating ordered or navigable task\n-                    if (orkStepArray?.count)! > 0 {\n-                        \n-                        task =  ORKOrderedTask(identifier: (activity?.actvityId!)!, steps: orkStepArray)\n-                        \n-                        if self.activity?.branching == true { //For Branching/Navigable Task\n-                            task =  ORKNavigableOrderedTask(identifier: (activity?.actvityId)!, steps: orkStepArray)\n-                            \n-                        } else { //For OrderedTask\n-                            task =  ORKOrderedTask(identifier: (activity?.actvityId)!, steps: orkStepArray)\n+\n+                if activityStep?.destinations != nil && (\n+                  activityStep?.destinations?.count\n+                )! > 0 {\n+\n+                  var defaultStepIdentifier: String = \"\"\n+\n+                  // Setting Next Step as Default destination\n+                  if i! + 1 < (activityStepArray?.count)! {\n+                    defaultStepIdentifier = (activityStepArray?[(i!+1)].key)!\n+\n+                  } else {  // Setting Completion Step as Default destination\n+                    defaultStepIdentifier = kCompletionStep\n+                  }\n+\n+                  var defaultStepExist: Bool? = false\n+                  let resultSelector: ORKResultSelector?\n+                  var predicateRule: ORKPredicateStepNavigationRule?\n+\n+                  // Creating Result Selector\n+                  resultSelector = ORKResultSelector(\n+                    stepIdentifier: step.identifier,\n+                    resultIdentifier: step.identifier)\n+                  let questionStep: ORKStep?\n+\n+                  // Intializing Question Step\n+                  if step.isKind(of: ORKQuestionStep.self) {\n+                    questionStep = (step as? ORKQuestionStep)!\n+\n+                  } else if step is RepeatableFormStep {\n+                    questionStep = (step as? RepeatableFormStep)!\n+\n+                  } else if step is ORKFormStep {\n+                    questionStep = (step as? ORKFormStep)!\n+\n+                  } else {\n+                    questionStep = (step as? ORKInstructionStep)!\n+                  }\n+\n+                  // Choicearray and destination array will hold predicates & their respective destination\n+                  var choicePredicate: [NSPredicate] = [NSPredicate]()\n+                  var destination: [String]? = [String]()\n+\n+                  for dict in (activityStep?.destinations)! {\n+\n+                    var predicateQuestionChoiceA: NSPredicate = NSPredicate()\n+\n+                    // Condition is not nil\n+                    if Utilities.isValidValue(\n+                      someObject: dict[kCondtion] as AnyObject) {\n+\n+                      switch (questionStep as? ORKQuestionStep)!.answerFormat {\n+\n+                      case is ORKTextChoiceAnswerFormat,\n+                        is ORKTextScaleAnswerFormat,\n+                        is ORKImageChoiceAnswerFormat:\n+\n+                        predicateQuestionChoiceA = ORKResultPredicate\n+                          .predicateForChoiceQuestionResult(\n+                            with: resultSelector!,\n+                            expectedAnswerValue: dict[kCondtion]\n+                              as! NSCoding & NSCopying\n+                              & NSObjectProtocol)\n+\n+                        choicePredicate.append(predicateQuestionChoiceA)\n+\n+                        if dict[kCondtion] != nil && dict[kDestination]\n+                          != nil && (\n+                            dict[kDestination] as? String\n+                          )! == \"\" {\n+                          // this means c = value & d = \"\"\n+                          destination?.append(kCompletionStep)\n+\n+                        } else {\n+                          // this means c = value && d =  value\n+                          destination?.append(\n+                            (dict[kDestination]! as? String)!)\n                         }\n-                    }\n-                    var i: Int? = 0\n-                    \n-                    if self.activity?.branching == true {\n-                        \n-                        for step in orkStepArray! {\n-                            //Setting ActivityStep\n-                            if step.isKind(of: ORKQuestionStep.self) || step is RepeatableFormStep || step is ORKFormStep || (step.isKind(of: ORKInstructionStep.self) && step.isKind(of: ORKCompletionStep.self) == false) {\n-                                \n-                                let activityStep: ActivityStep?\n-                                \n-                                if step.isKind(of: ORKQuestionStep.self) || (step.isKind(of: ORKInstructionStep.self) == false && step.isKind(of: ORKCompletionStep.self) == false) {\n-                                    activityStep = activityStepArray?[(i!)] as?  ActivityQuestionStep\n-                                    \n-                                } else if step.isKind(of: ORKFormStep.self) || step.isKind(of: RepeatableFormStep.self) {\n-                                    activityStep = activityStepArray?[(i!)] as?  ActivityFormStep\n-                                    \n-                                } else {\n-                                    activityStep = activityStepArray?[(i!)] as?  ActivityInstructionStep\n-                                }\n-                                \n-                                if activityStep?.destinations != nil && (activityStep?.destinations?.count)! > 0 {\n-                                    \n-                                    var defaultStepIdentifier: String = \"\"\n-                                    \n-                                    //Setting Next Step as Default destination\n-                                    if i! + 1 < (activityStepArray?.count)! {\n-                                        defaultStepIdentifier = (activityStepArray?[(i!+1)].key)!\n-                                        \n-                                    } else { //Setting Completion Step as Default destination\n-                                        defaultStepIdentifier = kCompletionStep\n-                                    }\n-                                    \n-                                    var defaultStepExist: Bool? = false\n-                                    let resultSelector: ORKResultSelector?\n-                                    var predicateRule: ORKPredicateStepNavigationRule?\n-                                    \n-                                    //Creating Result Selector\n-                                    resultSelector =  ORKResultSelector(stepIdentifier: step.identifier, resultIdentifier: step.identifier)\n-                                    let questionStep: ORKStep?\n-                                    \n-                                    //Intializing Question Step\n-                                    if step.isKind(of: ORKQuestionStep.self) {\n-                                        questionStep = (step as? ORKQuestionStep)!\n-                                        \n-                                    } else if step is RepeatableFormStep {\n-                                        questionStep = (step as? RepeatableFormStep)!\n-                                        \n-                                    } else if step is ORKFormStep {\n-                                        questionStep = (step as? ORKFormStep)!\n-                                        \n-                                    } else {\n-                                        questionStep = (step as? ORKInstructionStep)!\n-                                    }\n-                                    \n-                                    //choicearray and destination array will hold predicates & their respective destination\n-                                    var choicePredicate: [NSPredicate] = [NSPredicate]()\n-                                    var destination: Array<String>? = Array<String>()\n-                                    \n-                                    for dict in (activityStep?.destinations)! {\n-                                        \n-                                        var predicateQuestionChoiceA: NSPredicate = NSPredicate()\n-                                        \n-                                        //Condition is not nil\n-                                        if Utilities.isValidValue(someObject: dict[kCondtion] as AnyObject) {\n-                                            \n-                                            switch (questionStep as? ORKQuestionStep)!.answerFormat {\n-                                                \n-                                            case is ORKTextChoiceAnswerFormat, is ORKTextScaleAnswerFormat, is ORKImageChoiceAnswerFormat:\n-                                                \n-                                                predicateQuestionChoiceA = ORKResultPredicate.predicateForChoiceQuestionResult(with: resultSelector! , expectedAnswerValue: dict[kCondtion] as! NSCoding & NSCopying & NSObjectProtocol)\n-                                                \n-                                                choicePredicate.append(predicateQuestionChoiceA)\n-                                                \n-                                                if dict[kCondtion] != nil && dict[kDestination] != nil && (dict[kDestination] as? String)! == \"\" {\n-                                                    // this means c = value & d = \"\"\n-                                                    destination?.append( kCompletionStep )\n-                                                    \n-                                                } else {\n-                                                    // this means c = value && d =  value\n-                                                    destination?.append( (dict[kDestination]! as? String)!)\n-                                                }\n-                                                \n-                                            case is ORKNumericAnswerFormat ,is ORKScaleAnswerFormat,is ORKTimeIntervalAnswerFormat,is ORKHeightAnswerFormat, is ORKContinuousScaleAnswerFormat,is ORKHealthKitQuantityTypeAnswerFormat:\n-                                                \n-                                                if let operatorValue = dict[kOperator] as? String {\n-                                                    \n-                                                    let condition: String = (dict[kCondtion] as? String)!\n-                                                    let  conditionValue = condition.components(separatedBy: CharacterSet.init(charactersIn: \",\"))\n-                                                    \n-                                                    var lhs: Double? = 0.0\n-                                                    var rhs: Double? = 0.0\n-                                                    \n-                                                    lhs = Double(conditionValue.first!)\n-                                                    if conditionValue.count == 2 { //multiple conditions exists\n-                                                        rhs = Double(conditionValue.last!)\n-                                                    }\n-                                                    let operatorType:OperatorType = OperatorType(rawValue: operatorValue)!\n-                                                    \n-                                                    switch((questionStep as? ORKQuestionStep)!.answerFormat) {\n-                                                    case is ORKNumericAnswerFormat,is ORKHeightAnswerFormat,is ORKHealthKitQuantityTypeAnswerFormat: //Height & Numeric Question\n-                                                        \n-                                                        var minimumValue = (activityStep as? ActivityQuestionStep)!.formatDict![kMinimumValue] as? Float\n-                                                        \n-                                                        var style = \"\"\n-                                                        \n-                                                        if ((questionStep as? ORKQuestionStep)!.answerFormat! is ORKHeightAnswerFormat ) {\n-                                                            minimumValue = 0\n-                                                            \n-                                                        } else {\n-                                                            style = ((activityStep as? ActivityQuestionStep)!.formatDict![kStepQuestionNumericStyle] as? String)!\n-                                                        }\n-                                                        \n-                                                        predicateQuestionChoiceA = self.getPredicateForNumeric(resultSelector: resultSelector!, lhs: lhs!, minimumValue: minimumValue!, operatorType: operatorType,answerFormat: (questionStep as? ORKQuestionStep)!.answerFormat!,style: style)\n-                                                        \n-                                                    case is ORKTimeIntervalAnswerFormat: //TimeInterval\n-                                                        \n-                                                        predicateQuestionChoiceA = self.getPredicateForTimeInterval(resultSelector: resultSelector!, lhs: lhs!, minimumValue: 0.0, operatorType: operatorType)\n-                                                        \n-                                                    case is ORKScaleAnswerFormat, is ORKContinuousScaleAnswerFormat: //Scale & Continuos Scale\n-                                                        \n-                                                        let minimumValue = (activityStep as? ActivityQuestionStep)!.formatDict![kMinimumValue] as? Float\n-                                                        \n-                                                        predicateQuestionChoiceA = self.getPredicateForScale(resultSelector: resultSelector!, lhs: lhs!, minimumValue: minimumValue!, operatorType: operatorType,rhs: rhs!, resultType: ((questionStep as? ORKQuestionStep)!.answerFormat)!,activityStep:activityStep!)\n-                                                        \n-                                                    case .none: break\n-                                                        \n-                                                    case .some(_): break\n-                                                        \n-                                                    }\n-                                                    choicePredicate.append(predicateQuestionChoiceA)\n-                                                    \n-                                                    if dict[kCondtion] != nil && dict[kDestination] != nil && (dict[kDestination] as? String)! == \"\" {\n-                                                        // this means c = value & d = \"\"\n-                                                        destination?.append( kCompletionStep )\n-                                                        \n-                                                    } else {\n-                                                        // this means c = value && d =  value\n-                                                        destination?.append( (dict[kDestination]! as? String)!)\n-                                                    }\n-                                                } else {\n-                                                }\n-                                                \n-                                            case is ORKBooleanAnswerFormat :\n-                                                \n-                                                var boolValue: Bool? = false\n-                                                \n-                                                if (dict[kCondtion] as? String)!.caseInsensitiveCompare(\"true\") ==  ComparisonResult.orderedSame {\n-                                                    boolValue = true\n-                                                    \n-                                                } else {\n-                                                    if (dict[kCondtion] as? String)!.caseInsensitiveCompare(\"false\") ==  ComparisonResult.orderedSame {\n-                                                        boolValue = false\n-                                                        \n-                                                    } else if (dict[kCondtion] as? String)! == \"\" {\n-                                                        boolValue = nil\n-                                                        if Utilities.isValidValue(someObject: dict[kDestination] as AnyObject? ) {\n-                                                            \n-                                                            defaultStepIdentifier = (dict[kDestination]! as? String)!\n-                                                        }\n-                                                    }\n-                                                }\n-                                                \n-                                                if  boolValue != nil {\n-                                                    \n-                                                    predicateQuestionChoiceA = ORKResultPredicate.predicateForBooleanQuestionResult(with: resultSelector!, expectedAnswer: boolValue!)\n-                                                }\n-                                                choicePredicate.append(predicateQuestionChoiceA)\n-                                                \n-                                                if dict[kCondtion] != nil && dict[kDestination] != nil && (dict[kDestination] as? String)! == \"\" {\n-                                                    // this means c = value & d = \"\"\n-                                                    destination?.append( kCompletionStep )\n-                                                    \n-                                                } else {\n-                                                    // this means c = value && d =  value\n-                                                    destination?.append( (dict[kDestination]! as? String)!)\n-                                                }\n-                                            default: break\n-                                            }\n-                                        } else {\n-                                            // it means condition is empty\n-                                            if dict[kCondtion] != nil && (dict[kCondtion] as? String)! == \"\" {\n-                                                \n-                                                defaultStepExist = true\n-                                                if Utilities.isValidValue(someObject: dict[kDestination] as AnyObject? ) {\n-                                                    // means we ahave valid destination\n-                                                    defaultStepIdentifier = (dict[kDestination]! as? String)!\n-                                                    \n-                                                } else {\n-                                                    // invalid destination i.e condition = \"\" && destination = \"\"\n-                                                    defaultStepIdentifier = kCompletionStep\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                    if choicePredicate.count == 0 {\n-                                        \n-                                        // if condition is empty\n-                                        \n-                                        if (destination?.count)! > 0 {\n-                                            \n-                                            // if destination is not empty but condition is empty\n-                                            \n-                                            for destinationId in destination! {\n-                                                \n-                                                if destinationId.count != 0 {\n-                                                    \n-                                                    let  directRule = ORKDirectStepNavigationRule(destinationStepIdentifier: destinationId)\n-                                                    \n-                                                    (task as? ORKNavigableOrderedTask)!.setNavigationRule(directRule, forTriggerStepIdentifier: step.identifier)\n-                                                }\n-                                            }\n-                                        } else {\n-                                            // if both destination and condition are empty\n-                                            let  directRule: ORKDirectStepNavigationRule!\n-                                            \n-                                            if defaultStepExist == false {\n-                                                directRule = ORKDirectStepNavigationRule(destinationStepIdentifier: kCompletionStep)\n-                                            } else {\n-                                                directRule = ORKDirectStepNavigationRule(destinationStepIdentifier: defaultStepIdentifier)\n-                                            }\n-                                            \n-                                            (task as? ORKNavigableOrderedTask)!.setNavigationRule(directRule!, forTriggerStepIdentifier:step.identifier)\n-                                        }\n-                                    } else {\n-                                        \n-                                        predicateRule = ORKPredicateStepNavigationRule(resultPredicates: choicePredicate, destinationStepIdentifiers: destination!, defaultStepIdentifier: defaultStepIdentifier, validateArrays: true)\n-                                        \n-                                        (task as? ORKNavigableOrderedTask)!.setNavigationRule(predicateRule!, forTriggerStepIdentifier:step.identifier)\n-                                    }\n-                                } else {\n-                                    //destination array is empty - Do Nothing\n-                                }\n+\n+                      case is ORKNumericAnswerFormat, is ORKScaleAnswerFormat,\n+                        is ORKTimeIntervalAnswerFormat,\n+                        is ORKHeightAnswerFormat,\n+                        is ORKContinuousScaleAnswerFormat,\n+                        is ORKHealthKitQuantityTypeAnswerFormat:\n+\n+                        if let operatorValue = dict[kOperator] as? String {\n+\n+                          let condition: String = (\n+                            dict[kCondtion] as? String\n+                          )!\n+                          let conditionValue = condition.components(\n+                            separatedBy: CharacterSet.init(\n+                              charactersIn: \",\"))\n+\n+                          var lhs: Double? = 0.0\n+                          var rhs: Double? = 0.0\n+\n+                          lhs = Double(conditionValue.first!)\n+                          if conditionValue.count == 2 {  // multiple conditions exists\n+                            rhs = Double(conditionValue.last!)\n+                          }\n+                          let operatorType: OperatorType = OperatorType(\n+                            rawValue: operatorValue)!\n+\n+                          switch\n+                            (questionStep as? ORKQuestionStep)!\n+                              .answerFormat {\n+                          case is ORKNumericAnswerFormat,\n+                            is ORKHeightAnswerFormat,\n+                            is ORKHealthKitQuantityTypeAnswerFormat:  // Height & Numeric Question\n+\n+                            var minimumValue = (\n+                              activityStep as? ActivityQuestionStep\n+                            )!.formatDict![\n+                              kMinimumValue] as? Float\n+\n+                            var style = \"\"\n+\n+                            if\n+                              (questionStep as? ORKQuestionStep)!\n+                                .answerFormat!\n+                                is ORKHeightAnswerFormat {\n+                              minimumValue = 0\n+\n                             } else {\n-                                //this is not question step\n+                              style = (\n+                                (\n+                                  activityStep\n+                                    as? ActivityQuestionStep\n+                                )!.formatDict![\n+                                  kStepQuestionNumericStyle]\n+                                  as? String\n+                              )!\n                             }\n-                            i = i! + 1\n+\n+                            predicateQuestionChoiceA = self\n+                              .getPredicateForNumeric(\n+                                resultSelector: resultSelector!,\n+                                lhs: lhs!,\n+                                minimumValue: minimumValue!,\n+                                operatorType: operatorType,\n+                                answerFormat: (\n+                                  questionStep as? ORKQuestionStep\n+                                )!.answerFormat!,\n+                                style: style)\n+\n+                          case is ORKTimeIntervalAnswerFormat:  // TimeInterval\n+\n+                            predicateQuestionChoiceA = self\n+                              .getPredicateForTimeInterval(\n+                                resultSelector: resultSelector!,\n+                                lhs: lhs!, minimumValue: 0.0,\n+                                operatorType: operatorType)\n+\n+                          case is ORKScaleAnswerFormat,\n+                            is ORKContinuousScaleAnswerFormat:  // Scale & Continuos Scale\n+\n+                            let minimumValue = (\n+                              activityStep as? ActivityQuestionStep\n+                            )!.formatDict![\n+                              kMinimumValue] as? Float\n+\n+                            predicateQuestionChoiceA = self\n+                              .getPredicateForScale(\n+                                resultSelector: resultSelector!,\n+                                lhs: lhs!,\n+                                minimumValue: minimumValue!,\n+                                operatorType: operatorType,\n+                                rhs: rhs!,\n+                                resultType: (\n+                                  (\n+                                    questionStep\n+                                      as? ORKQuestionStep\n+                                  )!.answerFormat\n+                                )!,\n+                                activityStep: activityStep!)\n+\n+                          case .none: break\n+\n+                          case .some: break\n+\n+                          }\n+                          choicePredicate.append(predicateQuestionChoiceA)\n+\n+                          if dict[kCondtion] != nil && dict[kDestination]\n+                            != nil && (\n+                              dict[kDestination] as? String\n+                            )! == \"\" {\n+                            // this means c = value & d = \"\"\n+                            destination?.append(kCompletionStep)\n+\n+                          } else {\n+                            // this means c = value && d =  value\n+                            destination?.append(\n+                              (dict[kDestination]! as? String)!)\n+                          }\n+                        } else {\n                         }\n-                    }\n-                    if task != nil {\n-                        \n-                        if (self.activity?.branching)! {\n-                            return (task as? ORKNavigableOrderedTask)!\n+\n+                      case is ORKBooleanAnswerFormat:\n+\n+                        var boolValue: Bool? = false\n+\n+                        if (dict[kCondtion] as? String)!\n+                          .caseInsensitiveCompare(\"true\")\n+                          == ComparisonResult.orderedSame {\n+                          boolValue = true\n+\n+                        } else {\n+                          if (dict[kCondtion] as? String)!\n+                            .caseInsensitiveCompare(\"false\")\n+                            == ComparisonResult.orderedSame {\n+                            boolValue = false\n+\n+                          } else if (dict[kCondtion] as? String)! == \"\" {\n+                            boolValue = nil\n+                            if Utilities.isValidValue(\n+                              someObject: dict[kDestination]\n+                                as AnyObject?) {\n+\n+                              defaultStepIdentifier = (\n+                                dict[kDestination]! as? String\n+                              )!\n+                            }\n+                          }\n+                        }\n+\n+                        if boolValue != nil {\n+\n+                          predicateQuestionChoiceA = ORKResultPredicate\n+                            .predicateForBooleanQuestionResult(\n+                              with: resultSelector!,\n+                              expectedAnswer: boolValue!)\n+                        }\n+                        choicePredicate.append(predicateQuestionChoiceA)\n+\n+                        if dict[kCondtion] != nil && dict[kDestination]\n+                          != nil && (\n+                            dict[kDestination] as? String\n+                          )! == \"\" {\n+                          // this means c = value & d = \"\"\n+                          destination?.append(kCompletionStep)\n+\n                         } else {\n-                            return (task as? ORKOrderedTask)!\n+                          // this means c = value && d =  value\n+                          destination?.append(\n+                            (dict[kDestination]! as? String)!)\n                         }\n+                      default: break\n+                      }\n                     } else {\n-                        return nil\n+                      // it means condition is empty\n+                      if dict[kCondtion] != nil && (\n+                        dict[kCondtion] as? String\n+                      )! == \"\" {\n+\n+                        defaultStepExist = true\n+                        if Utilities.isValidValue(\n+                          someObject: dict[kDestination] as AnyObject?) {\n+                          // means we ahave valid destination\n+                          defaultStepIdentifier = (\n+                            dict[kDestination]! as? String\n+                          )!\n+\n+                        } else {\n+                          // invalid destination i.e condition = \"\" && destination = \"\"\n+                          defaultStepIdentifier = kCompletionStep\n+                        }\n+                      }\n                     }\n-                }\n-            // MARK: Active Task\n-            case .activeTask:\n-                \n-                for var stepDict in (activity?.steps!)! {\n-                    \n-                    if Utilities.isValidObject(someObject: stepDict as AnyObject?) {\n-                        \n-                        if Utilities.isValidValue(someObject: stepDict[kActivityStepType] as AnyObject ) {\n-                            \n-                            switch ActivityStepType(rawValue: (stepDict[kActivityStepType] as? String)!)! as  ActivityStepType {\n-                                \n-                            case .instruction:\n-                                \n-                                let instructionStep:ActivityInstructionStep? = ActivityInstructionStep()\n-                                instructionStep?.initWithDict(stepDict: stepDict)\n-                                orkStepArray?.append((instructionStep?.getInstructionStep())!)\n-                                \n-                            case .question:\n-                                \n-                                let questionStep:ActivityQuestionStep? = ActivityQuestionStep()\n-                                questionStep?.initWithDict(stepDict: stepDict)\n-                                orkStepArray?.append((questionStep?.getQuestionStep())!)\n-                                \n-                            case   .active , .taskSpatialSpanMemory , .taskTowerOfHanoi :\n-                                \n-                                var localTask: ORKOrderedTask?\n-                                \n-                                let activeStep:ActivityActiveStep? = ActivityActiveStep()\n-                                activeStep?.initWithDict(stepDict: stepDict)\n-                                localTask = activeStep?.getActiveTask() as! ORKOrderedTask?\n-                                activityStepArray?.append(activeStep!)\n-                                \n-                                if (localTask?.steps) != nil && ((localTask?.steps)?.count)! > 0 {\n-                                    \n-                                    for step  in (localTask?.steps)! {\n-                                        orkStepArray?.append(step)\n-                                    }\n-                                }\n-                            default: break\n-                            }\n+                  }\n+                  if choicePredicate.count == 0 {\n+\n+                    // if condition is empty\n+\n+                    if (destination?.count)! > 0 {\n+\n+                      // if destination is not empty but condition is empty\n+\n+                      for destinationId in destination! {\n+\n+                        if destinationId.count != 0 {\n+\n+                          let directRule = ORKDirectStepNavigationRule(\n+                            destinationStepIdentifier: destinationId)\n+\n+                          (task as? ORKNavigableOrderedTask)!\n+                            .setNavigationRule(\n+                              directRule,\n+                              forTriggerStepIdentifier: step\n+                                .identifier)\n                         }\n-                        \n+                      }\n                     } else {\n-                        Logger.sharedInstance.debug(\"Activity:stepDict is null:\\(stepDict)\")\n-                        break;\n-                    }\n-                }\n-                \n-                if (orkStepArray?.count)! > 0 {\n-                    \n-                    if (activityStepArray?.count)! > 0 {\n-                        \n-                        self.activity?.setActivityStepArray(stepArray: activityStepArray!)\n-                    }\n-                    self.activity?.setORKSteps(orkStepArray: orkStepArray!)\n-                    \n-                    if (orkStepArray?.count)! > 0 {\n-                        task =  ORKOrderedTask(identifier: (activity?.actvityId!)!, steps: orkStepArray)\n+                      // if both destination and condition are empty\n+                      let directRule: ORKDirectStepNavigationRule!\n+\n+                      if defaultStepExist == false {\n+                        directRule = ORKDirectStepNavigationRule(\n+                          destinationStepIdentifier: kCompletionStep)\n+                      } else {\n+                        directRule = ORKDirectStepNavigationRule(\n+                          destinationStepIdentifier: defaultStepIdentifier\n+                        )\n+                      }\n+\n+                      (task as? ORKNavigableOrderedTask)!.setNavigationRule(\n+                        directRule!,\n+                        forTriggerStepIdentifier: step.identifier)\n                     }\n-                    return task!\n-                    \n+                  } else {\n+\n+                    predicateRule = ORKPredicateStepNavigationRule(\n+                      resultPredicates: choicePredicate,\n+                      destinationStepIdentifiers: destination!,\n+                      defaultStepIdentifier: defaultStepIdentifier,\n+                      validateArrays: true)\n+\n+                    (task as? ORKNavigableOrderedTask)!.setNavigationRule(\n+                      predicateRule!,\n+                      forTriggerStepIdentifier: step.identifier)\n+                  }\n                 } else {\n-                    return nil\n+                  // destination array is empty - Do Nothing\n                 }\n+              }\n+              i = i! + 1\n             }\n-        } else {\n-            Logger.sharedInstance.debug(\"activity is null\")\n-        }\n-        return nil\n-        //self.actvityResult?.setActivity(activity: self.activity!)\n-    }\n-    // MARK: Predicates For QuestionTypes\n-    \n-    /*\n-     getPredicateForNumeric generates predicate for the Numeric Question Type\n-     @resultSelector: instance of ORKResultSelector for specific QuestionStep\n-     @lhs:Boundary Value for predicate\n-     @OperatorType: repersents the operation type\n-     \n-     */\n-    \n-    func getPredicateForNumeric(resultSelector: ORKResultSelector, lhs: Double,minimumValue: Float, operatorType: OperatorType,answerFormat: ORKAnswerFormat,style: String) ->NSPredicate {\n-        \n-        var predicate:NSPredicate = NSPredicate()\n-        \n-        switch(operatorType) {\n-            \n-        case .equal: //Equal\n-            \n-            if answerFormat is ORKNumericAnswerFormat || answerFormat is ORKHealthKitQuantityTypeAnswerFormat {\n-                \n-                if style == \"Decimal\"{\n-                    predicate =  NSPredicate.init(format: \"SUBQUERY(SELF, $x, $x.identifier == $ORK_TASK_IDENTIFIER AND SUBQUERY($x.results, $y, $y.identifier == \\\"\\(resultSelector.resultIdentifier)\\\" AND $y.isPreviousResult == 0 AND SUBQUERY($y.results, $z, $z.identifier == \\\"\\(resultSelector.resultIdentifier)\\\" AND $z.answer >= \\(lhs) AND $z.answer < \\(lhs + 0.1)).@count > 0).@count > 0).@count > 0\" , argumentArray: [])\n-                    \n-                } else {\n-                    predicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, expectedAnswer: Int(lhs))\n-                }\n+          }\n+          if task != nil {\n+\n+            if (self.activity?.branching)! {\n+              return (task as? ORKNavigableOrderedTask)!\n             } else {\n-                predicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, expectedAnswer: Int(lhs))\n+              return (task as? ORKOrderedTask)!\n             }\n-            \n-        case .notEqual : //NotEqual\n-            let equalPredicate: NSPredicate!\n-            \n-            if answerFormat is ORKNumericAnswerFormat {\n-                \n-                if style == \"Decimal\" {\n-                    equalPredicate =  NSPredicate.init(format: \"SUBQUERY(SELF, $x, $x.identifier == $ORK_TASK_IDENTIFIER AND SUBQUERY($x.results, $y, $y.identifier == \\\"\\(resultSelector.resultIdentifier)\\\" AND $y.isPreviousResult == 0 AND SUBQUERY($y.results, $z, $z.identifier == \\\"\\(resultSelector.resultIdentifier)\\\" AND $z.answer >= \\(lhs) AND $z.answer < \\(lhs + 0.1)).@count > 0).@count > 0).@count > 0\" , argumentArray: [])\n-                } else {\n-                    equalPredicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, expectedAnswer: Int(lhs))\n+          } else {\n+            return nil\n+          }\n+        }\n+      // MARK: Active Task\n+      case .activeTask:\n+\n+        for stepDict in (activity?.steps!)! {\n+\n+          if Utilities.isValidObject(someObject: stepDict as AnyObject?) {\n+\n+            if Utilities.isValidValue(\n+              someObject: stepDict[kActivityStepType] as AnyObject) {\n+\n+              switch ActivityStepType(\n+                rawValue: (stepDict[kActivityStepType] as? String)!)!\n+                as ActivityStepType {\n+\n+              case .instruction:\n+\n+                let instructionStep: ActivityInstructionStep?\n+                  = ActivityInstructionStep()\n+                instructionStep?.initWithDict(stepDict: stepDict)\n+                orkStepArray?.append((instructionStep?.getInstructionStep())!)\n+\n+              case .question:\n+\n+                let questionStep: ActivityQuestionStep? = ActivityQuestionStep()\n+                questionStep?.initWithDict(stepDict: stepDict)\n+                orkStepArray?.append((questionStep?.getQuestionStep())!)\n+\n+              case .active, .taskSpatialSpanMemory, .taskTowerOfHanoi:\n+\n+                var localTask: ORKOrderedTask?\n+\n+                let activeStep: ActivityActiveStep? = ActivityActiveStep()\n+                activeStep?.initWithDict(stepDict: stepDict)\n+                localTask = activeStep?.getActiveTask() as! ORKOrderedTask?\n+                activityStepArray?.append(activeStep!)\n+\n+                if (localTask?.steps) != nil && ((localTask?.steps)?.count)! > 0 {\n+\n+                  for step in (localTask?.steps)! {\n+                    orkStepArray?.append(step)\n+                  }\n                 }\n-            } else {\n-                equalPredicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, expectedAnswer: Int(lhs))\n+              default: break\n+              }\n             }\n-            \n-            predicate = NSCompoundPredicate.init(notPredicateWithSubpredicate: equalPredicate)\n-            \n-        case .greaterThan : //GreaterThan\n-            \n-            predicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, minimumExpectedAnswerValue: lhs + 1  , maximumExpectedAnswerValue: Double.infinity )\n-        case .lessThan : //LessThan\n-            \n-            predicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, minimumExpectedAnswerValue: Double(minimumValue ), maximumExpectedAnswerValue: lhs - 1 )\n-            \n-        case .greaterThanOrEqual : //GreaterThanOrEqual\n-            \n-            predicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, minimumExpectedAnswerValue: lhs)\n-        case .lessThanOrEqual : //LessThanOrEqual\n-            predicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, maximumExpectedAnswerValue: lhs)                                                        case .range :break //Range\n-            \n-       // default: break\n-            \n+\n+          } else {\n+            break\n+          }\n         }\n-        return predicate\n+\n+        if (orkStepArray?.count)! > 0 {\n+\n+          if (activityStepArray?.count)! > 0 {\n+\n+            self.activity?.setActivityStepArray(stepArray: activityStepArray!)\n+          }\n+          self.activity?.setORKSteps(orkStepArray: orkStepArray!)\n+\n+          if (orkStepArray?.count)! > 0 {\n+            task = ORKOrderedTask(\n+              identifier: (activity?.actvityId!)!, steps: orkStepArray)\n+          }\n+          return task!\n+\n+        } else {\n+          return nil\n+        }\n+      }\n     }\n-    \n-    /*\n-     getPredicateForTimeInterval generates predicate for the Numeric Question Type\n-     @resultSelector: instance of ORKResultSelector for specific QuestionStep\n-     @lhs:Boundary Value for predicate\n-     @OperatorType: repersents the operation type\n-     \n-     */\n-    \n-    func getPredicateForTimeInterval(resultSelector: ORKResultSelector, lhs: Double,minimumValue: Float, operatorType: OperatorType) ->NSPredicate {\n-        \n-        var predicate:NSPredicate = NSPredicate()\n-        \n-        switch(operatorType) {\n-            \n-        case .equal: //Equal\n-            predicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, expectedAnswer: Int(lhs))\n-        case .notEqual: //NotEqual\n-            let equalPredicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, expectedAnswer: Int(lhs))\n-            predicate = NSCompoundPredicate.init(notPredicateWithSubpredicate: equalPredicate)\n-            \n-        case .greaterThan : //GreaterThan\n-            predicate = ORKResultPredicate.predicateForTimeIntervalQuestionResult(with: resultSelector, minimumExpectedAnswerValue: lhs + 1, maximumExpectedAnswerValue: Double.infinity)\n-            \n-        case .lessThan : //LessThan\n-            predicate = ORKResultPredicate.predicateForTimeIntervalQuestionResult(with: resultSelector, minimumExpectedAnswerValue: 0.0, maximumExpectedAnswerValue: lhs - 1 )\n-            \n-        case .greaterThanOrEqual : //GreaterThanOrEqual\n-            predicate = ORKResultPredicate.predicateForTimeIntervalQuestionResult(with: resultSelector, minimumExpectedAnswerValue: lhs)\n-            \n-        case .lessThanOrEqual : //LessThanOrEqual\n-            predicate = ORKResultPredicate.predicateForTimeIntervalQuestionResult(with: resultSelector, maximumExpectedAnswerValue: lhs)\n-            \n-        case .range : break\n-            \n-        //default: break\n-            \n+    return nil\n+  }\n+\n+  /// Generates predicate for the Numeric Question Type\n+  /// - Parameters:\n+  ///   - resultSelector: Instance of `ORKResultSelector` for specific QuestionStep\n+  ///   - lhs: Boundary Value for predicate\n+  ///   - minimumValue: Minimum Value for predicate\n+  ///   - operatorType: Represents the operation type\n+  ///   - answerFormat: Instance of `ORKAnswerFormat`\n+  ///   - style: Style type\n+  func getPredicateForNumeric(\n+    resultSelector: ORKResultSelector, lhs: Double, minimumValue: Float,\n+    operatorType: OperatorType,\n+    answerFormat: ORKAnswerFormat, style: String\n+  ) -> NSPredicate {\n+\n+    var predicate: NSPredicate = NSPredicate()\n+\n+    switch operatorType {\n+\n+    case .equal:\n+      if answerFormat is ORKNumericAnswerFormat ||\n+        answerFormat is ORKHealthKitQuantityTypeAnswerFormat {\n+\n+        if style == \"Decimal\" {\n+          predicate = NSPredicate.init(\n+            format:\n+              \"SUBQUERY(SELF, $x, $x.identifier == $ORK_TASK_IDENTIFIER AND SUBQUERY($x.results, $y, $y.identifier == \\\"\\(resultSelector.resultIdentifier)\\\" AND $y.isPreviousResult == 0 AND SUBQUERY($y.results, $z, $z.identifier == \\\"\\(resultSelector.resultIdentifier)\\\" AND $z.answer >= \\(lhs) AND $z.answer < \\(lhs + 0.1)).@count > 0).@count > 0).@count > 0\",\n+            argumentArray: [])\n+\n+        } else {\n+          predicate = ORKResultPredicate.predicateForNumericQuestionResult(\n+            with: resultSelector, expectedAnswer: Int(lhs))\n         }\n-        return predicate\n+      } else {\n+        predicate = ORKResultPredicate.predicateForNumericQuestionResult(\n+          with: resultSelector, expectedAnswer: Int(lhs))\n+      }\n+\n+    case .notEqual:\n+      let equalPredicate: NSPredicate!\n+\n+      if answerFormat is ORKNumericAnswerFormat {\n+\n+        if style == \"Decimal\" {\n+          equalPredicate = NSPredicate.init(\n+            format:\n+              \"SUBQUERY(SELF, $x, $x.identifier == $ORK_TASK_IDENTIFIER AND SUBQUERY($x.results, $y, $y.identifier == \\\"\\(resultSelector.resultIdentifier)\\\" AND $y.isPreviousResult == 0 AND SUBQUERY($y.results, $z, $z.identifier == \\\"\\(resultSelector.resultIdentifier)\\\" AND $z.answer >= \\(lhs) AND $z.answer < \\(lhs + 0.1)).@count > 0).@count > 0).@count > 0\",\n+            argumentArray: [])\n+        } else {\n+          equalPredicate = ORKResultPredicate.predicateForNumericQuestionResult(\n+            with: resultSelector, expectedAnswer: Int(lhs))\n+        }\n+      } else {\n+        equalPredicate = ORKResultPredicate.predicateForNumericQuestionResult(\n+          with: resultSelector, expectedAnswer: Int(lhs))\n+      }\n+      predicate = NSCompoundPredicate.init(notPredicateWithSubpredicate: equalPredicate)\n+\n+    case .greaterThan:\n+      predicate = ORKResultPredicate.predicateForNumericQuestionResult(\n+        with: resultSelector, minimumExpectedAnswerValue: lhs + 1,\n+        maximumExpectedAnswerValue: Double.infinity)\n+\n+    case .lessThan:\n+      predicate = ORKResultPredicate.predicateForNumericQuestionResult(\n+        with: resultSelector, minimumExpectedAnswerValue: Double(minimumValue),\n+        maximumExpectedAnswerValue: lhs - 1)\n+\n+    case .greaterThanOrEqual:\n+      predicate = ORKResultPredicate.predicateForNumericQuestionResult(\n+        with: resultSelector, minimumExpectedAnswerValue: lhs)\n+\n+    case .lessThanOrEqual:\n+      predicate = ORKResultPredicate.predicateForNumericQuestionResult(\n+        with: resultSelector, maximumExpectedAnswerValue: lhs)\n+\n+    case .range: break\n+\n     }\n-    \n-    /*\n-     getPredicateForScale generates predicate for the Numeric Question Type\n-     @resultSelector: instance of ORKResultSelector for specific QuestionStep\n-     @lhs:Boundary Value for predicate\n-     @OperatorType: repersents the operation type\n-     \n-     */\n-    \n-    func getPredicateForScale(resultSelector: ORKResultSelector, lhs: Double,minimumValue: Float, operatorType: OperatorType,rhs: Double,resultType: ORKAnswerFormat,activityStep: ActivityStep) ->NSPredicate {\n-        \n-        var predicate: NSPredicate = NSPredicate()\n-        \n-        switch(operatorType) {\n-            \n-        case .equal: //Equal\n-            //\n-            \n-            if resultType is ORKScaleAnswerFormat {\n-                predicate = ORKResultPredicate.predicateForScaleQuestionResult(with: resultSelector, expectedAnswer: Int(lhs))\n-            } else {\n-                \n-                var offset: Double? = 0.0\n-                let maxFraction = (activityStep as? ActivityQuestionStep)!.formatDict![kStepQuestionContinuosScaleMaxFractionDigits] as? Int\n-                \n-                switch(maxFraction) {\n-                case 0?:\n-                    offset = -0.25\n-                case 1?,2?,3?:\n-                    offset = 0.0\n-                case .none: break\n-                case .some(_): break\n-                }\n-                \n-                predicate =  NSPredicate.init(format: \"SUBQUERY(SELF, $x, $x.identifier == $ORK_TASK_IDENTIFIER AND SUBQUERY($x.results, $y, $y.identifier == \\\"\\(resultSelector.resultIdentifier)\\\" AND $y.isPreviousResult == 0 AND SUBQUERY($y.results, $z, $z.identifier == \\\"\\(resultSelector.resultIdentifier)\\\" AND $z.answer >= \\(lhs + offset!) AND $z.answer < \\(lhs + 0.1)).@count > 0).@count > 0).@count > 0\" , argumentArray: [])\n-            }\n-            \n-        case .notEqual: //Not Equal\n-            \n-            let equalPredicate = ORKResultPredicate.predicateForNumericQuestionResult(with: resultSelector, expectedAnswer: Int(lhs))\n-            predicate = NSCompoundPredicate.init(notPredicateWithSubpredicate: equalPredicate)\n-            \n-        case .greaterThan: //GreaterThan\n-            predicate = ORKResultPredicate.predicateForScaleQuestionResult(with: resultSelector, minimumExpectedAnswerValue: lhs + 1, maximumExpectedAnswerValue: Double.infinity)\n-            \n-        case .lessThan: //LessThan\n-            predicate = ORKResultPredicate.predicateForScaleQuestionResult(with: resultSelector, minimumExpectedAnswerValue: Double(minimumValue), maximumExpectedAnswerValue: lhs - 1 )\n-            \n-        case .greaterThanOrEqual: //GreaterThanOrEqual\n-            predicate = ORKResultPredicate.predicateForScaleQuestionResult(with: resultSelector, minimumExpectedAnswerValue: lhs)\n-            \n-        case .lessThanOrEqual: //LessThanOrEqual\n-            predicate = ORKResultPredicate.predicateForScaleQuestionResult(with: resultSelector, maximumExpectedAnswerValue: lhs)\n-            \n-        case .range:\n-            predicate = ORKResultPredicate.predicateForScaleQuestionResult(with: resultSelector, minimumExpectedAnswerValue: lhs, maximumExpectedAnswerValue: rhs  )\n-            \n-        //default: break\n-            \n+    return predicate\n+  }\n+\n+  /// Generates predicate for the Numeric Question Type\n+  /// - Parameters:\n+  ///   - resultSelector: Instance of ORKResultSelector for specific QuestionStep\n+  ///   - lhs: Boundary value for predicate\n+  ///   - minimumValue: Min Value for predicate\n+  ///   - operatorType: Repersents the operation type\n+  func getPredicateForTimeInterval(\n+    resultSelector: ORKResultSelector, lhs: Double, minimumValue: Float,\n+    operatorType: OperatorType\n+  ) -> NSPredicate {\n+\n+    var predicate: NSPredicate = NSPredicate()\n+\n+    switch operatorType {\n+\n+    case .equal:  //Equal", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzODc5OA==", "bodyText": "nit: extra line.", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391838798", "createdAt": "2020-03-12T19:18:16Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Models/Database/DBHandler.swift", "diffHunk": "@@ -1,700 +1,803 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import RealmSwift\n+import UIKit\n \n class DBHandler: NSObject {\n \n-    fileprivate class func getRealmObject() -> Realm! {\n-        \n-        var realm: Realm!\n-        do {\n-            realm = try Realm()\n-        } catch {\n-            return nil\n+  fileprivate class func getRealmObject() -> Realm! {\n+\n+    let key = FDAKeychain.shared[kRealmEncryptionKeychainKey]\n+    let data = Data.init(base64Encoded: key!)\n+    let encryptionConfig = Realm.Configuration(encryptionKey: data)\n+    var realm: Realm!\n+    do {\n+      realm = try Realm(configuration: encryptionConfig)\n+    } catch let error {\n+      Logger.sharedInstance.error(error)\n+    }\n+    return realm\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0MTU4NQ==", "bodyText": "nit: extra space", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391841585", "createdAt": "2020-03-12T19:23:55Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Models/Database/DBHandler.swift", "diffHunk": "@@ -1,700 +1,803 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n import RealmSwift\n+import UIKit\n \n class DBHandler: NSObject {\n \n-    fileprivate class func getRealmObject() -> Realm! {\n-        \n-        var realm: Realm!\n-        do {\n-            realm = try Realm()\n-        } catch {\n-            return nil\n+  fileprivate class func getRealmObject() -> Realm! {\n+\n+    let key = FDAKeychain.shared[kRealmEncryptionKeychainKey]\n+    let data = Data.init(base64Encoded: key!)\n+    let encryptionConfig = Realm.Configuration(encryptionKey: data)\n+    var realm: Realm!\n+    do {\n+      realm = try Realm(configuration: encryptionConfig)\n+    } catch let error {\n+      Logger.sharedInstance.error(error)\n+    }\n+    return realm\n+\n+  }\n+\n+  /// Used to save user details like userid, authkey, first name , last name etc\n+  func saveCurrentUser(user: User) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let dbUsers = realm.objects(DBUser.self)\n+    var dbUser = dbUsers.last\n+\n+    if dbUser == nil {\n+\n+      dbUser = DBUser()\n+      dbUser?.userType = (user.userType?.rawValue)!\n+      dbUser?.emailId = user.emailId!\n+      dbUser?.userId = user.userId\n+      dbUser?.verified = user.verified\n+\n+      try? realm.write {\n+          realm.add(dbUser!, update: .all)\n         }\n-        return realm\n-    }\n-    \n-    \n-    /* Used to save user details like userid, authkey, first name , last name etc*/\n-    func saveCurrentUser(user: User){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbUsers = realm.objects(DBUser.self)\n-        var dbUser = dbUsers.last\n-        \n-        if dbUser == nil {\n-            \n-            dbUser = DBUser()\n+    } else {\n+      let user = User.currentUser\n+      do {\n+        try realm.write {\n             dbUser?.userType = (user.userType?.rawValue)!\n             dbUser?.emailId = user.emailId!\n             dbUser?.authToken = user.authToken\n-            dbUser?.userId = user.userId\n-            //dbUser.firstName = user.firstName\n-            //dbUser.lastName = user.lastName\n             dbUser?.verified = user.verified\n-            \n             dbUser?.refreshToken = user.refreshToken\n-            \n-            try? realm.write({\n-                realm.add(dbUser!, update: true)\n-                \n-            })\n-        }\n-        else {\n-            let user = User.currentUser\n-            do {\n-                try realm.write({\n-                    \n-                    dbUser?.userType = (user.userType?.rawValue)!\n-                    dbUser?.emailId = user.emailId!\n-                    dbUser?.authToken = user.authToken\n-                    \n-                    //dbUser.firstName = user.firstName\n-                    //dbUser.lastName = user.lastName\n-                    dbUser?.verified = user.verified\n-                    \n-                    dbUser?.refreshToken = user.refreshToken\n-                    \n-                })\n-            } catch let error {\n-                print(error)\n-            }\n-            \n-//            try? realm.write({\n-//\n-//                dbUser?.userType = (user.userType?.rawValue)!\n-//                dbUser?.emailId = user.emailId!\n-//                dbUser?.authToken = user.authToken\n-//                dbUser?.userId = user.userId\n-//                //dbUser.firstName = user.firstName\n-//                //dbUser.lastName = user.lastName\n-//                dbUser?.verified = user.verified\n-//\n-//                dbUser?.refreshToken = user.refreshToken\n-//\n-//            })\n-           \n-        }\n-        \n-        \n-        \n-       \n-//        print(\"DBPath : varealm.configuration.fileURL)\")\n-//        try? realm.write({\n-//            realm.add(dbUser!, update: true)\n-//\n-//        })\n-    }\n-    \n-    /* Used to initialize the current logged in user*/\n-    func initilizeCurrentUser(){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbUsers = realm.objects(DBUser.self)\n-        let dbUser = dbUsers.last\n-        \n-        if dbUser != nil {\n-            let currentUser = User.currentUser\n-            currentUser.firstName = dbUser?.firstName\n-            currentUser.lastName  = dbUser?.lastName\n-            currentUser.verified = dbUser?.verified\n-            currentUser.authToken = dbUser?.authToken\n-            currentUser.userId = dbUser?.userId\n-            currentUser.emailId = dbUser?.emailId\n-            currentUser.userType =  (dbUser?.userType).map { UserType(rawValue: $0) }!\n-            currentUser.refreshToken = dbUser?.refreshToken\n-          \n-            let settings = Settings()\n-            settings.localNotifications = dbUser?.localNotificationEnabled\n-            settings.passcode = dbUser?.passcodeEnabled\n-            settings.remoteNotifications = dbUser?.remoteNotificationEnabled\n-            \n-            currentUser.settings = settings\n-        }\n-        \n-    }\n-    \n-    class func saveUserSettingsToDatabase(){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbUsers = realm.objects(DBUser.self)\n-        let dbUser = dbUsers.last\n-        \n-        try? realm.write({\n-            \n-            let user = User.currentUser\n-            dbUser?.passcodeEnabled = (user.settings?.passcode)!\n-            dbUser?.localNotificationEnabled = (user.settings?.localNotifications)!\n-            dbUser?.remoteNotificationEnabled = (user.settings?.remoteNotifications)!\n-            \n-        })\n+          }\n+      } catch let error {\n+        Logger.sharedInstance.error(error)\n+      }\n     }\n-    \n-    class func resetAuthToken(){\n-        \n-        let realm = try! Realm()\n-        let dbUsers = realm.objects(DBUser.self)\n-        let dbUser = dbUsers.last\n-        \n-        try! realm.write({\n-            \n-            dbUser?.authToken = \"\"\n-            dbUser?.userType =  UserType.AnonymousUser.rawValue//(user.userType?.rawValue)!\n-            \n-        })\n+  }\n+\n+  // Used to initialize the current logged in user\n+  func initilizeCurrentUser() -> Bool {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let dbUsers = realm.objects(DBUser.self)\n+    let dbUser = dbUsers.last\n+\n+    if dbUser != nil {\n+      let currentUser = User.currentUser\n+      currentUser.firstName = dbUser?.firstName\n+      currentUser.lastName = dbUser?.lastName\n+      currentUser.verified = dbUser?.verified\n+      currentUser.userId = dbUser?.userId\n+      currentUser.emailId = dbUser?.emailId\n+      currentUser.userType = (dbUser?.userType).map { UserType(rawValue: $0) }!\n+\n+      let settings = Settings()\n+      settings.localNotifications = dbUser?.localNotificationEnabled\n+      settings.passcode = dbUser?.passcodeEnabled\n+      settings.remoteNotifications = dbUser?.remoteNotificationEnabled\n+\n+      currentUser.settings = settings\n+\n+      return true\n     }\n-    \n-    /* Used to delete current logged in user*/\n-    class func deleteCurrentUser(){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbUsers = realm.objects(DBUser.self)\n-        let dbUser = dbUsers.last\n-        try? realm.write {\n-            realm.delete(dbUser!)\n-        }\n+    return false\n+  }\n+\n+  /// This method will save new user App settings like passcode & notifications.\n+  class func saveUserSettingsToDatabase() {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let dbUsers = realm.objects(DBUser.self)\n+    let dbUser = dbUsers.last\n+\n+    try? realm.write {\n+        let user = User.currentUser\n+        dbUser?.passcodeEnabled = (user.settings?.passcode)!\n+        dbUser?.localNotificationEnabled = (user.settings?.localNotifications)!\n+        dbUser?.remoteNotificationEnabled = (user.settings?.remoteNotifications)!\n+\n+      }\n+  }\n+\n+  class func resetAuthToken() {\n+\n+    let realm = try! Realm()\n+    let dbUsers = realm.objects(DBUser.self)\n+    let dbUser = dbUsers.last\n+\n+    try? realm.write {\n+        dbUser?.authToken = \"\"\n+        dbUser?.userType = UserType.AnonymousUser.rawValue\n+      }\n+  }\n+\n+  /// Used to delete current logged in user\n+  class func deleteCurrentUser() {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let dbUsers = realm.objects(DBUser.self)\n+    let dbUser = dbUsers.last\n+    try? realm.write {\n+      realm.delete(dbUser!)\n     }\n-    \n-     // MARK:Study\n-    /* Save studies \n-     @params: studies - Array\n-     */\n-    func saveStudies(studies: Array<Study>){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbStudiesArray = realm.objects(DBStudy.self)\n-      \n-        var dbStudies: Array<DBStudy> = []\n-        for study in studies {\n-            \n-            //some studies are already present in db\n-            var dbStudy: DBStudy?\n-            if dbStudiesArray.count > 0 {\n-                 dbStudy = dbStudiesArray.filter({$0.studyId ==  study.studyId}).last\n-            }\n-            \n-            if dbStudy == nil {\n-                dbStudy = DBHandler.getDBStudy(study: study)\n-                dbStudies.append(dbStudy!)\n-            }else {\n-                \n-                try? realm.write({\n-                    dbStudy?.category = study.category\n-                    dbStudy?.name = study.name\n-                    dbStudy?.sponserName = study.sponserName\n-                    dbStudy?.tagLine = study.description\n-                    dbStudy?.logoURL = study.logoURL\n-                    dbStudy?.startDate = study.startDate\n-                    dbStudy?.endEnd = study.endEnd\n-                    dbStudy?.status = study.status.rawValue\n-                    dbStudy?.enrolling = study.studySettings.enrollingAllowed\n-                    dbStudy?.rejoin = study.studySettings.rejoinStudyAfterWithdrawn\n-                    dbStudy?.platform = study.studySettings.platform\n-                    dbStudy?.participatedStatus = study.userParticipateState.status.rawValue\n-                    dbStudy?.participatedId = study.userParticipateState.participantId\n-                    dbStudy?.joiningDate = study.userParticipateState.joiningDate\n-                    dbStudy?.completion = study.userParticipateState.completion\n-                    dbStudy?.adherence = study.userParticipateState.adherence\n-                    dbStudy?.bookmarked = study.userParticipateState.bookmarked\n-                    \n-                    if dbStudy?.participatedStatus == UserStudyStatus.StudyStatus.inProgress.rawValue {\n-                        dbStudy?.updatedVersion = study.version\n-                        \n-                    }else {\n-                        dbStudy?.updatedVersion = study.version\n-                    }\n-                    \n-                })\n-                \n-            }\n-           \n-        }\n-        \n+  }\n+\n+  // MARK: - Study\n+\n+  /// Save studies objects in Database.\n+  ///\n+  /// - Parameter studies: Ordered collection of Study Instances.\n+  func saveStudies(studies: [Study]) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let dbStudiesArray = realm.objects(DBStudy.self)\n+\n+    var dbStudies: [DBStudy] = []\n+    for study in studies {\n+\n+      // Some studies are already present in db\n+      var dbStudy: DBStudy?\n+      if dbStudiesArray.count > 0 {\n+        dbStudy = dbStudiesArray.filter({ $0.studyId == study.studyId }).last\n+      }\n+\n+      if dbStudy == nil {\n+        dbStudy = DBHandler.getDBStudy(study: study)\n+        dbStudies.append(dbStudy!)\n+      } else {\n+\n         try? realm.write({\n-            realm.add(dbStudies, update: true)\n-            \n-        })\n-        \n-        Logger.sharedInstance.info(\"Studies Saved in DB\")\n-    }\n-    \n-    /**\n-     creates an instance of DBStudy\n-    */\n-    private class func getDBStudy(study: Study) ->DBStudy {\n-        \n-        let dbStudy = DBStudy()\n-        dbStudy.studyId = study.studyId\n-        dbStudy.category = study.category\n-        dbStudy.name = study.name\n-        dbStudy.sponserName = study.sponserName\n-        dbStudy.tagLine = study.description\n-        dbStudy.version = study.version\n-        dbStudy.updatedVersion = study.version\n-        dbStudy.logoURL = study.logoURL\n-        dbStudy.startDate = study.startDate\n-        dbStudy.endEnd = study.endEnd\n-        dbStudy.enrolling = study.studySettings.enrollingAllowed\n-        dbStudy.rejoin = study.studySettings.rejoinStudyAfterWithdrawn\n-        dbStudy.platform = study.studySettings.platform\n-        dbStudy.status = study.status.rawValue\n-        dbStudy.participatedStatus = study.userParticipateState.status.rawValue\n-        dbStudy.participatedId = study.userParticipateState.participantId\n-        dbStudy.joiningDate = study.userParticipateState.joiningDate\n-        dbStudy.completion = study.userParticipateState.completion\n-        dbStudy.adherence = study.userParticipateState.adherence\n-        dbStudy.bookmarked = study.userParticipateState.bookmarked\n-        dbStudy.withdrawalConfigrationMessage = study.withdrawalConfigration?.message\n-        dbStudy.withdrawalConfigrationType = study.withdrawalConfigration?.type?.rawValue\n-        return dbStudy\n-        \n-    }\n-    \n-    /**\n-     Fetches list of Studies from DB\n-     return completion handler with array of studies\n-    */\n-    class func loadStudyListFromDatabase(completionHandler: @escaping (Array<Study>) -> ()) {\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbStudies = realm.objects(DBStudy.self)\n-        \n-        User.currentUser.participatedStudies.removeAll()\n-        var studies: Array<Study> = []\n-        for dbStudy in dbStudies {\n-\n-            let study = Study()\n-            study.studyId = dbStudy.studyId\n-            study.category = dbStudy.category\n-            study.name = dbStudy.name\n-            study.sponserName = dbStudy.sponserName\n-            study.description = dbStudy.tagLine\n-            study.version = dbStudy.version\n-            study.newVersion = dbStudy.updatedVersion\n-            study.logoURL = dbStudy.logoURL\n-            study.startDate = dbStudy.startDate\n-            study.endEnd = dbStudy.endEnd\n-            study.status = StudyStatus(rawValue: dbStudy.status!)!\n-            study.signedConsentVersion = dbStudy.signedConsentVersion\n-            study.signedConsentFilePath = dbStudy.signedConsentFilePath\n-            study.activitiesLocalNotificationUpdated = dbStudy.activitiesLocalNotificationUpdated\n-            \n-            //settings\n-            let studySettings = StudySettings()\n-            studySettings.enrollingAllowed = dbStudy.enrolling\n-            studySettings.rejoinStudyAfterWithdrawn = dbStudy.rejoin\n-            studySettings.platform = dbStudy.platform!\n-            study.studySettings = studySettings\n-            \n-            //status\n-            let participatedStatus = UserStudyStatus()\n-            participatedStatus.status = UserStudyStatus.StudyStatus(rawValue: dbStudy.participatedStatus)!\n-            participatedStatus.bookmarked = dbStudy.bookmarked\n-            participatedStatus.studyId = dbStudy.studyId\n-            participatedStatus.participantId = dbStudy.participatedId\n-            participatedStatus.adherence = dbStudy.adherence\n-            participatedStatus.completion = dbStudy.completion\n-            participatedStatus.joiningDate = dbStudy.joiningDate\n-            \n-            study.userParticipateState = participatedStatus\n-            \n-            print(\"status \\(dbStudy.participatedStatus)\");\n-            \n-            //append to user class participatesStudies also\n-            User.currentUser.participatedStudies.append(participatedStatus)\n-            \n-            //anchorDate\n-            let anchorDate = StudyAnchorDate()\n-            anchorDate.anchorDateActivityId = dbStudy.anchorDateActivityId\n-            anchorDate.anchorDateQuestionKey = dbStudy.anchorDateType\n-            anchorDate.anchorDateActivityVersion = dbStudy.anchorDateActivityVersion\n-            anchorDate.anchorDateQuestionKey = dbStudy.anchorDateQuestionKey\n-            anchorDate.anchorDateType = dbStudy.anchorDateType\n-            anchorDate.date = dbStudy.anchorDate\n-            \n-            study.anchorDate = anchorDate\n-            \n-            let withdrawalInfo = StudyWithdrawalConfigration()\n-            withdrawalInfo.message = dbStudy.withdrawalConfigrationMessage\n-            \n-            \n-            if dbStudy.withdrawalConfigrationType != nil {\n-                 withdrawalInfo.type = StudyWithdrawalConfigrationType(rawValue: dbStudy.withdrawalConfigrationType!)\n-            }else {\n-                 withdrawalInfo.type = .notAvailable\n+            dbStudy?.category = study.category\n+            dbStudy?.name = study.name\n+            dbStudy?.sponserName = study.sponserName\n+            dbStudy?.tagLine = study.description\n+            dbStudy?.logoURL = study.logoURL\n+            dbStudy?.startDate = study.startDate\n+            dbStudy?.endEnd = study.endEnd\n+            dbStudy?.status = study.status.rawValue\n+            dbStudy?.enrolling = study.studySettings.enrollingAllowed\n+            dbStudy?.rejoin = study.studySettings.rejoinStudyAfterWithdrawn\n+            dbStudy?.platform = study.studySettings.platform\n+            dbStudy?.participatedStatus = study.userParticipateState.status.rawValue\n+            dbStudy?.participatedId = study.userParticipateState.participantId\n+            dbStudy?.joiningDate = study.userParticipateState.joiningDate\n+            dbStudy?.completion = study.userParticipateState.completion\n+            dbStudy?.adherence = study.userParticipateState.adherence\n+            dbStudy?.bookmarked = study.userParticipateState.bookmarked\n+\n+            if dbStudy?.participatedStatus == UserStudyStatus.StudyStatus.inProgress\n+              .rawValue {\n+              dbStudy?.updatedVersion = study.version\n+\n+            } else {\n+              dbStudy?.updatedVersion = study.version\n             }\n-            study.withdrawalConfigration = withdrawalInfo\n-            studies.append(study)\n-        }\n-       \n-        completionHandler(studies)\n-    }\n-\n-    /* Save study overview\n-     @params: overview , String\n-     */\n-    class func saveStudyOverview(overview: Overview , studyId: String) {\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let studies =  realm.objects(DBStudy.self).filter(\"studyId == %@\",studyId)\n-        let dbStudy = studies.last\n-        \n-        //save overview\n-        let dbStudies = List<DBOverviewSection>()\n-        for sectionIndex in 0...(overview.sections.count-1) {\n-            \n-            let section = overview.sections[sectionIndex]\n-            let dbOverviewSection = DBOverviewSection()\n-            dbOverviewSection.title = section.title\n-            dbOverviewSection.link  = section.link\n-            dbOverviewSection.imageURL = section.imageURL\n-            dbOverviewSection.text = section.text\n-            dbOverviewSection.type = section.type\n-            dbOverviewSection.studyId = studyId\n-            dbOverviewSection.sectionId = studyId + \"screen\\(sectionIndex)\"\n-            dbStudies.append(dbOverviewSection)\n-        }\n-        \n-        try? realm.write({\n-            \n-            realm.add(dbStudies,update: true)\n-            dbStudy?.websiteLink = overview.websiteLink\n \n-        })\n-        \n-    }\n-    \n-    /**\n-     saves withdrawal configration to DB\n-     @param withdrawalConfigration, instance of StudyWithdrawalConfigration\n-     @param studyId, study for which configrations are to be updated\n-    */\n-    class func saveWithdrawalConfigration(withdrawalConfigration: StudyWithdrawalConfigration, studyId: String){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let studies =  realm.objects(DBStudy.self).filter(\"studyId == %@\",studyId)\n-        let dbStudy = studies.last\n-        \n-        try? realm.write({\n-            \n-            dbStudy?.withdrawalConfigrationMessage = withdrawalConfigration.message\n-            dbStudy?.withdrawalConfigrationType = withdrawalConfigration.type?.rawValue\n-        })\n-        \n-    }\n-\n-    /**\n-     saves anchor data to DB\n-     @param anchorDate, instance of StudyAnchorDate\n-     @param studyId, study for which anchorDate are to be updated\n-     */\n-    class func saveAnchorDateDetail(anchorDate: StudyAnchorDate , studyId: String){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let studies =  realm.objects(DBStudy.self).filter(\"studyId == %@\",studyId)\n-        let dbStudy = studies.last\n-        \n-        try? realm.write({\n-            \n-            dbStudy?.anchorDateActivityId = anchorDate.anchorDateActivityId\n-            dbStudy?.anchorDateType = anchorDate.anchorDateType\n-            dbStudy?.anchorDateActivityVersion = anchorDate.anchorDateActivityVersion\n-            dbStudy?.anchorDateQuestionKey = anchorDate.anchorDateQuestionKey\n-        })\n+          })\n+\n+      }\n+\n     }\n-    \n-    /**\n-     saves anchor data to DB\n-     @param anchorDate, instance of StudyAnchorDate\n-     @param studyId, study for which configrations are to be updated\n-     */\n-    class func saveAnchorDate(date: Date,studyId: String){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let studies =  realm.objects(DBStudy.self).filter(\"studyId == %@\",studyId)\n-        let dbStudy = studies.last\n-        \n-        try? realm.write({\n-            \n-            dbStudy?.anchorDate = date\n-        })\n \n+    try? realm.write {\n+        realm.add(dbStudies, update: .modified)\n+      }\n+  }\n+\n+  /// Creates an instance of DBStudy.\n+  ///\n+  /// - Parameter study: Ordered collection of Study Objects.\n+  ///  - Returns: Realm object of `DBStudy`\n+  private class func getDBStudy(study: Study) -> DBStudy {\n+\n+    let dbStudy = DBStudy()\n+    dbStudy.studyId = study.studyId\n+    dbStudy.category = study.category\n+    dbStudy.name = study.name\n+    dbStudy.sponserName = study.sponserName\n+    dbStudy.tagLine = study.description\n+    dbStudy.version = study.version\n+    dbStudy.updatedVersion = study.version\n+    dbStudy.logoURL = study.logoURL\n+    dbStudy.startDate = study.startDate\n+    dbStudy.endEnd = study.endEnd\n+    dbStudy.enrolling = study.studySettings.enrollingAllowed\n+    dbStudy.rejoin = study.studySettings.rejoinStudyAfterWithdrawn\n+    dbStudy.platform = study.studySettings.platform\n+    dbStudy.status = study.status.rawValue\n+    dbStudy.participatedStatus = study.userParticipateState.status.rawValue\n+    dbStudy.participatedId = study.userParticipateState.participantId\n+    dbStudy.joiningDate = study.userParticipateState.joiningDate\n+    dbStudy.completion = study.userParticipateState.completion\n+    dbStudy.adherence = study.userParticipateState.adherence\n+    dbStudy.bookmarked = study.userParticipateState.bookmarked\n+    dbStudy.withdrawalConfigrationMessage = study.withdrawalConfigration?.message\n+    dbStudy.withdrawalConfigrationType = study.withdrawalConfigration?.type?.rawValue\n+    return dbStudy\n+\n+  }\n+\n+  /// Fetches list of Studies from DB.\n+  ///\n+  /// - Parameter completionHandler: Completion handler with array of studies and returns nothing\n+  class func loadStudyListFromDatabase(completionHandler: @escaping ([Study]) -> Void) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let dbStudies = realm.objects(DBStudy.self)\n+\n+    User.currentUser.participatedStudies.removeAll()\n+    var studies: [Study] = []\n+    for dbStudy in dbStudies {\n+\n+      let study = Study()\n+      study.studyId = dbStudy.studyId\n+      study.category = dbStudy.category\n+      study.name = dbStudy.name\n+      study.sponserName = dbStudy.sponserName\n+      study.description = dbStudy.tagLine\n+      study.version = dbStudy.version\n+      study.newVersion = dbStudy.updatedVersion\n+      study.logoURL = dbStudy.logoURL\n+      study.startDate = dbStudy.startDate\n+      study.endEnd = dbStudy.endEnd\n+      study.status = StudyStatus(rawValue: dbStudy.status!)!\n+      study.signedConsentVersion = dbStudy.signedConsentVersion\n+      study.signedConsentFilePath = dbStudy.signedConsentFilePath\n+      study.activitiesLocalNotificationUpdated = dbStudy.activitiesLocalNotificationUpdated\n+\n+      // Settings\n+      let studySettings = StudySettings()\n+      studySettings.enrollingAllowed = dbStudy.enrolling\n+      studySettings.rejoinStudyAfterWithdrawn = dbStudy.rejoin\n+      studySettings.platform = dbStudy.platform ?? \"\"\n+      study.studySettings = studySettings\n+\n+      // Status\n+      let participatedStatus = UserStudyStatus()\n+      participatedStatus.status = UserStudyStatus.StudyStatus(\n+        rawValue: dbStudy.participatedStatus)!\n+      participatedStatus.bookmarked = dbStudy.bookmarked\n+      participatedStatus.studyId = dbStudy.studyId\n+      participatedStatus.participantId = dbStudy.participatedId\n+      participatedStatus.adherence = dbStudy.adherence\n+      participatedStatus.completion = dbStudy.completion\n+      participatedStatus.joiningDate = dbStudy.joiningDate\n+\n+      study.userParticipateState = participatedStatus\n+\n+      // Append to user class participatesStudies also\n+      User.currentUser.participatedStudies.append(participatedStatus)\n+\n+      // AnchorDate\n+      let anchorDate = StudyAnchorDate()\n+      anchorDate.anchorDateActivityId = dbStudy.anchorDateActivityId\n+      anchorDate.anchorDateQuestionKey = dbStudy.anchorDateType\n+      anchorDate.anchorDateActivityVersion = dbStudy.anchorDateActivityVersion\n+      anchorDate.anchorDateQuestionKey = dbStudy.anchorDateQuestionKey\n+      anchorDate.anchorDateType = dbStudy.anchorDateType\n+      anchorDate.date = dbStudy.anchorDate\n+\n+      study.anchorDate = anchorDate\n+\n+      let withdrawalInfo = StudyWithdrawalConfigration()\n+      withdrawalInfo.message = dbStudy.withdrawalConfigrationMessage\n+\n+      if dbStudy.withdrawalConfigrationType != nil {\n+        withdrawalInfo.type = StudyWithdrawalConfigrationType(\n+          rawValue: dbStudy.withdrawalConfigrationType!)\n+      } else {\n+        withdrawalInfo.type = .notAvailable\n+      }\n+      study.withdrawalConfigration = withdrawalInfo\n+      studies.append(study)\n     }\n-    \n-    /**\n-     Fetches overview from DB\n-     return completion handler with instance of overview\n-     */\n-    class func loadStudyOverview(studyId: String,completionHandler: @escaping (Overview?) -> ()){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let studies =  realm.objects(DBOverviewSection.self).filter(\"studyId == %@\",studyId)\n-        let study =  realm.objects(DBStudy.self).filter(\"studyId == %@\",studyId).last\n-        \n-        if studies.count > 0 {\n-            \n-            // inilize OverviewSection from database\n-            var overviewSections: Array<OverviewSection> = []\n-            for dbSection in studies {\n-                let section = OverviewSection()\n-                \n-                section.title = dbSection.title\n-                section.imageURL = dbSection.imageURL\n-                section.link = dbSection.link\n-                section.type = dbSection.type\n-                section.text = dbSection.text\n-                overviewSections.append(section)\n-            }\n-            \n-            //Create Overview object  \n-            let overview = Overview()\n-            overview.type = .study\n-            overview.websiteLink = study?.websiteLink\n-            overview.sections = overviewSections\n-            completionHandler(overview)\n-            \n-        }else {\n-            completionHandler(nil)\n-        }\n+\n+    completionHandler(studies)\n+  }\n+\n+  /// Save study overview.\n+  ///\n+  /// - Parameters:\n+  ///   - overview: Object of `Overview`\n+  ///   - studyId: StudyID to query `DBStudy` object from DB\n+  class func saveStudyOverview(overview: Overview, studyId: String) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let studies = realm.objects(DBStudy.self).filter(\"studyId == %@\", studyId)\n+    let dbStudy = studies.last\n+\n+    //save overview\n+    let dbStudies = List<DBOverviewSection>()\n+    for sectionIndex in 0...(overview.sections.count-1) {\n+\n+      let section = overview.sections[sectionIndex]\n+      let dbOverviewSection = DBOverviewSection()\n+      dbOverviewSection.title = section.title\n+      dbOverviewSection.link = section.link\n+      dbOverviewSection.imageURL = section.imageURL\n+      dbOverviewSection.text = section.text\n+      dbOverviewSection.type = section.type\n+      dbOverviewSection.studyId = studyId\n+      dbOverviewSection.sectionId = studyId + \"screen\\(sectionIndex)\"\n+      dbStudies.append(dbOverviewSection)\n     }\n-    \n-    /**\n-     updates studyUpdates to DB\n-     @param updateDetails, instance of StudyUpdates\n-     @param study, study for which configrations are to be updated\n-     */\n-    class func updateMetaDataToUpdateForStudy(study: Study , updateDetails: StudyUpdates?) {\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let studies =  realm.objects(DBStudy.self).filter(\"studyId == %@\",study.studyId)\n-        let dbStudy = studies.last\n-        \n-        try? realm.write({\n-            \n-            dbStudy?.updateResources = StudyUpdates.studyResourcesUpdated\n-            dbStudy?.updateConsent = StudyUpdates.studyConsentUpdated\n-            dbStudy?.updateActivities = StudyUpdates.studyActivitiesUpdated\n-            dbStudy?.updateInfo = StudyUpdates.studyInfoUpdated\n-            if StudyUpdates.studyVersion != nil {\n-                dbStudy?.version = StudyUpdates.studyVersion\n-                \n-            }else {\n-                dbStudy?.version = dbStudy?.updatedVersion\n-            }\n-        })\n+\n+    try? realm.write {\n+\n+      realm.add(dbStudies, update: .all)\n+      dbStudy?.websiteLink = overview.websiteLink\n+\n     }\n-    \n-    /**\n-     Updates StudyParticipation status of user to DB\n-    */\n-    class func updateStudyParticipationStatus(study: Study) {\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let studies =  realm.objects(DBStudy.self).filter(\"studyId == %@\",study.studyId)\n-        let dbStudy = studies.last\n-        \n-        try? realm.write({\n-            \n-             dbStudy?.participatedStatus = study.userParticipateState.status.rawValue\n-             dbStudy?.participatedId = study.userParticipateState.participantId\n-             dbStudy?.joiningDate = study.userParticipateState.joiningDate\n-             dbStudy?.completion = study.userParticipateState.completion\n-             dbStudy?.adherence = study.userParticipateState.adherence\n-        })\n+\n+  }\n+\n+  /// Saves withdrawal configration to DB.\n+  ///\n+  /// - Parameters:\n+  ///   - withdrawalConfigration:  instance of StudyWithdrawalConfigration.\n+  ///   - studyId: study for which configrations are to be updated.\n+  class func saveWithdrawalConfigration(\n+    withdrawalConfigration: StudyWithdrawalConfigration,\n+    studyId: String\n+  ) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let studies = realm.objects(DBStudy.self).filter(\"studyId == %@\", studyId)\n+    let dbStudy = studies.last\n+\n+    try? realm.write {\n+      dbStudy?.withdrawalConfigrationMessage = withdrawalConfigration.message\n+      dbStudy?.withdrawalConfigrationType = withdrawalConfigration.type?.rawValue\n     }\n-    \n-    /**\n-     Fetches StudyDetails from DB\n-     return completion handler with boolean\n-     */\n-    class func loadStudyDetailsToUpdate(studyId: String,completionHandler: @escaping (Bool) -> ()) {\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let studies =  realm.objects(DBStudy.self).filter(\"studyId == %@\",studyId)\n-        let dbStudy = studies.last\n-        \n-        StudyUpdates.studyActivitiesUpdated = (dbStudy?.updateActivities)!\n-        StudyUpdates.studyConsentUpdated = (dbStudy?.updateConsent)!\n-        StudyUpdates.studyResourcesUpdated = (dbStudy?.updateResources)!\n-        StudyUpdates.studyInfoUpdated = (dbStudy?.updateInfo)!\n-        completionHandler(true)\n-    }\n-    \n-    /**\n-     saves study consent Info to DB\n-    */\n-    class func saveConsentInformation(study: Study){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let studies =  realm.objects(DBStudy.self).filter(\"studyId == %@\",study.studyId)\n-        let dbStudy = studies.last\n-        \n-        try? realm.write({\n-            \n-            dbStudy?.signedConsentFilePath = study.signedConsentFilePath\n-            dbStudy?.signedConsentVersion = study.signedConsentVersion\n-        })\n+\n+  }\n+\n+  /// Saves anchor date to DB.\n+  ///\n+  /// - Parameters:\n+  ///   - anchorDate: Instance of StudyAnchorDate.\n+  ///   - studyId: Study for which anchorDate are to be updated.\n+  class func saveAnchorDateDetail(anchorDate: StudyAnchorDate, studyId: String) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let studies = realm.objects(DBStudy.self).filter(\"studyId == %@\", studyId)\n+    let dbStudy = studies.last\n+\n+    try? realm.write {\n+      dbStudy?.anchorDateActivityId = anchorDate.anchorDateActivityId\n+      dbStudy?.anchorDateType = anchorDate.anchorDateType\n+      dbStudy?.anchorDateActivityVersion = anchorDate.anchorDateActivityVersion\n+      dbStudy?.anchorDateQuestionKey = anchorDate.anchorDateQuestionKey\n     }\n-    \n-    /**\n-     updates local Notification status for the study.\n-    */\n-    class func updateLocalNotificaitonUpdated(studyId: String,status: Bool) {\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let study = realm.object(ofType: DBStudy.self, forPrimaryKey: studyId)\n-        try? realm.write({\n-            study?.activitiesLocalNotificationUpdated = status\n-        })\n-        \n-    }\n-    \n-     // MARK:Activity\n-    \n-    /**\n-     Saves Activities to DB\n-     @param activityies, is list or Activities\n-    */\n-    \n-    class func saveActivities(activityies: Array<Activity>) {\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let study = Study.currentStudy\n-        let dbActivityArray = realm.objects(DBActivity.self).filter({$0.studyId == study?.studyId})\n-        \n-        var dbActivities: Array<DBActivity> = []\n-        var activityUpdated = false\n-        for activity in activityies {\n-          \n-            var dbActivity: DBActivity?\n-            if dbActivityArray.count != 0 {\n-                dbActivity = dbActivityArray.filter({$0.actvityId == activity.actvityId!}).last\n-                \n-                if dbActivity == nil { //newly added activity\n-                    dbActivity = DBHandler.getDBActivity(activity: activity)\n-                    dbActivities.append(dbActivity!)\n-                    activityUpdated  = true\n-                }\n-                else {\n-                    \n-                    //check if version is updated\n-                    if dbActivity?.version != activity.version {\n-                        \n-                        try? realm.write({\n-                            realm.delete((dbActivity?.activityRuns)!)\n-                            realm.delete(dbActivity!)\n-                        })\n-                        \n-                        let updatedActivity = DBHandler.getDBActivity(activity: activity)\n-                        dbActivities.append(updatedActivity)\n-                        DBHandler.deleteMetaDataForActivity(activityId: activity.actvityId!, studyId: activity.studyId!)\n-                        activityUpdated = true\n-                        \n-                    }else {\n-                         try? realm.write({\n-                            \n-                            dbActivity?.currentRunId = activity.userParticipationStatus.activityRunId\n-                            dbActivity?.participationStatus = activity.userParticipationStatus.status.rawValue\n-                            dbActivity?.completedRuns = activity.userParticipationStatus.compeltedRuns\n-                            dbActivity?.state = activity.state\n-                         })\n-                    }\n-                }\n-                \n-            }else {\n-                dbActivity = DBHandler.getDBActivity(activity: activity)\n-                dbActivities.append(dbActivity!)\n-                activityUpdated = true\n+  }\n+\n+  /// Saves anchor date to DB.\n+  ///\n+  /// - Parameters:\n+  ///   - date: New date of Anchor.\n+  ///   - studyId: Study for which configrations are to be updated.\n+  class func saveAnchorDate(date: Date, studyId: String) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let studies = realm.objects(DBStudy.self).filter(\"studyId == %@\", studyId)\n+    let dbStudy = studies.last\n+\n+    try? realm.write {\n+        dbStudy?.anchorDate = date\n+      }\n+  }\n+\n+  /// Fetches overview from DB.\n+  ///\n+  /// - Parameters:\n+  ///   - studyId: StudyID for which overview needs to be fetched.\n+  ///   - completionHandler: completion handler with instance of overview.\n+  class func loadStudyOverview(studyId: String, completionHandler: @escaping (Overview?) -> Void) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let studies = realm.objects(DBOverviewSection.self).filter(\"studyId == %@\", studyId)\n+    let study = realm.objects(DBStudy.self).filter(\"studyId == %@\", studyId).last\n+\n+    if studies.count > 0 {\n+\n+      /// initialize OverviewSection from database\n+      var overviewSections: [OverviewSection] = []\n+      for dbSection in studies {\n+        let section = OverviewSection()\n+\n+        section.title = dbSection.title\n+        section.imageURL = dbSection.imageURL\n+        section.link = dbSection.link\n+        section.type = dbSection.type\n+        section.text = dbSection.text\n+        overviewSections.append(section)\n+      }\n+\n+      // Create Overview object\n+      let overview = Overview()\n+      overview.type = .study\n+      overview.websiteLink = study?.websiteLink\n+      overview.sections = overviewSections\n+      completionHandler(overview)\n+\n+    } else {\n+      completionHandler(nil)\n+    }\n+  }\n+\n+  /// Updates `StudyUpdates` to DB.\n+  ///\n+  /// - Parameters:\n+  ///   - studyId: StudyID for which overview needs to be fetched.\n+  ///   - completionHandler: completion handler with instance of overview.\n+  class func updateMetaDataToUpdateForStudy(study: Study, updateDetails: StudyUpdates?) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let studies = realm.objects(DBStudy.self).filter(\"studyId == %@\", study.studyId ?? \"\")\n+    let dbStudy = studies.last\n+\n+    try? realm.write {\n+      dbStudy?.updateResources = StudyUpdates.studyResourcesUpdated\n+      dbStudy?.updateConsent = StudyUpdates.studyConsentUpdated\n+      dbStudy?.updateActivities = StudyUpdates.studyActivitiesUpdated\n+      dbStudy?.updateInfo = StudyUpdates.studyInfoUpdated\n+      if StudyUpdates.studyVersion != nil {\n+        dbStudy?.version = StudyUpdates.studyVersion\n+      } else {\n+        dbStudy?.version = dbStudy?.updatedVersion\n+      }\n+    }\n+\n+  }\n+\n+  /// This method will update the participation status of the study.\n+  /// - Parameter study: Instance of the study participated.\n+  class func updateStudyParticipationStatus(study: Study) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let studies = realm.objects(DBStudy.self).filter(\"studyId == %@\", study.studyId ?? \"\")\n+    let dbStudy = studies.last\n+\n+    try? realm.write {\n+        dbStudy?.participatedStatus = study.userParticipateState.status.rawValue\n+        dbStudy?.participatedId = study.userParticipateState.participantId\n+        dbStudy?.joiningDate = study.userParticipateState.joiningDate\n+        dbStudy?.completion = study.userParticipateState.completion\n+        dbStudy?.adherence = study.userParticipateState.adherence\n+      }\n+  }\n+\n+  /// Fetches StudyDetails from DB.\n+  /// - Parameters:\n+  ///   - studyId: ID of the Study to fetch details from Database.\n+  ///   - completionHandler: Bool to indicate if the Study detail available in Database or not.\n+  class func loadStudyDetailsToUpdate(\n+    studyId: String,\n+    completionHandler: @escaping (Bool) -> Void\n+  ) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+    let studies = realm.objects(DBStudy.self).filter(\"studyId == %@\", studyId)\n+    let dbStudy = studies.last\n+\n+    StudyUpdates.studyActivitiesUpdated = (dbStudy?.updateActivities)!\n+    StudyUpdates.studyConsentUpdated = (dbStudy?.updateConsent)!\n+    StudyUpdates.studyResourcesUpdated = (dbStudy?.updateResources)!\n+    StudyUpdates.studyInfoUpdated = (dbStudy?.updateInfo)!\n+    completionHandler(true)\n+  }\n+\n+  ///  Saves study consent Info to DB.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0MjYxMQ==", "bodyText": "comment within comment? looks like a mistake", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391842611", "createdAt": "2020-03-12T19:25:56Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Models/Database/DBHandler.swift", "diffHunk": "@@ -703,1528 +806,1372 @@ class DBHandler: NSObject {\n             dbActivityRun.runId = activityRun.runId\n             dbActivityRun.isCompleted = activityRun.isCompleted\n             dbActivityRuns.append(dbActivityRun)\n-        }\n-        \n-        //save anchor date\n-        dbActivity.sourceType = activity.anchorDate?.sourceType\n-        dbActivity.sourceActivityId = activity.anchorDate?.sourceActivityId\n-        dbActivity.sourceKey = activity.anchorDate?.sourceKey\n-        dbActivity.sourceFormKey = activity.anchorDate?.sourceFormKey\n-        dbActivity.startDays = activity.anchorDate?.startDays ?? 0\n-        dbActivity.startTime = activity.anchorDate?.startTime\n-        dbActivity.endDays = activity.anchorDate?.endDays ?? 0\n-        dbActivity.repeatInterval = activity.anchorDate?.repeatInterval ?? 0\n-        dbActivity.endTime = activity.anchorDate?.endTime\n-        \n-        dbActivity.activityRuns.append(objectsIn: dbActivityRuns)\n-        return dbActivity\n-    }\n-    \n-    /**\n-     updates Activity restortion data for the questionare\n-     @param activity, activity in which restortion data to be updated\n-     @param studyId, study which contains activity\n-     @param restortionData, restortion data for the questionare\n-    */\n-    class func updateActivityRestortionDataFor(activity: Activity,studyId: String,restortionData: Data?){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbActivities = realm.objects(DBActivityRun.self).filter({$0.activityId == activity.actvityId && $0.studyId == studyId && $0.runId == activity.currentRun.runId})\n-        let dbActivity = dbActivities.last\n-        \n-        try? realm.write({\n-            dbActivity?.restortionData = restortionData\n+          }\n+\n+          try? realm.write {\n+              dbActivity.activityRuns.append(objectsIn: dbActivityRuns)\n+              dbActivity.startDate = startdate\n+              dbActivity.endDate = endDate\n+              dbActivity.anchorDateValue = date\n+            }\n         })\n+\n     }\n-    \n-    class func updateTargetActivityAnchorDateDetail(studyId:String, activityId:String, response:[String:Any]) -> Bool {\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbActivities = realm.objects(DBActivity.self).filter({$0.sourceActivityId == activityId && $0.studyId == studyId && $0.startDate == nil})\n-        \n-        guard let dbActivity = dbActivities.last else {\n-            return false\n-        }\n-        \n-        //get source question value and key\n-        let results = response[\"results\"] as! Array<Dictionary<String,Any>>\n-        var quesStepKey:String\n-        var dictionary:[String:Any] = [:]\n-        let sourceKey = (dbActivity.sourceKey)!\n-        if dbActivity.sourceFormKey != nil && dbActivity.sourceFormKey!.count > 0{\n-            quesStepKey = dbActivity.sourceFormKey!\n-            let quesResults = results.filter({$0[\"key\"] as! String == quesStepKey}).first\n-            let resultsArray =  ((quesResults![\"value\"] as? [[Any]])?.first) as? [[String:Any]]\n-            dictionary = resultsArray!.filter({$0[\"key\"] as! String == sourceKey}).first!\n-            \n-        }\n-        else {\n-            dictionary = results.filter({$0[\"key\"] as! String == sourceKey}).first!\n-        }\n-        \n-        //let dictionary = results.filter({$0[\"key\"] as! String == sourceKey}).first\n-        \n-        guard let userInputDate = dictionary[\"value\"] as? String else{\n-            return false\n-        }\n-        \n-        \n-        let date = Utilities.getDateFromString(dateString: userInputDate)\n-        \n-        for activity in dbActivities {\n-            self.updateActivityLifeTimeFor(activity, anchorDate: date!)\n-        }\n-        \n-        DBHandler.updateResourceLifeTime(studyId, activityId: activityId, questionKey: sourceKey, anchorDateValue: date!)\n-        \n-        return true\n-    }\n-    \n-    class func updateActivityLifeTimeFor(_ dbActivity:DBActivity, anchorDate:Date) {\n-        \n-        var date = anchorDate\n-        let realm = DBHandler.getRealmObject()!\n-        \n-        //update start date\n-        var startDateStringEnrollment =  Utilities.formatterShort?.string(from: date)\n-        let startTimeEnrollment =  \"00:00:00\"\n-        startDateStringEnrollment = (startDateStringEnrollment ?? \"\") + \" \" + startTimeEnrollment\n-        date = Utilities.findDateFromString(dateString: startDateStringEnrollment ?? \"\")!\n-        \n-        let frequency = Frequency(rawValue: (dbActivity.frequencyType)!)!\n-        let lifeTime = DBHandler.getLifeTime(date,\n-                                             frequency:frequency,\n-                                             startDays: (dbActivity.startDays),\n-                                             endDays: (dbActivity.endDays),\n-                                             repeatInterval: (dbActivity.repeatInterval))\n-        \n-        \n-        //update start date\n-        var startDateString =  Utilities.formatterShort?.string(from: lifeTime.0!)\n-        let startTime =  (dbActivity.startTime == nil) ? \"00:00:00\" : (dbActivity.startTime)!\n-        startDateString = (startDateString ?? \"\") + \" \" + startTime\n-        let startdate = Utilities.findDateFromString(dateString: startDateString ?? \"\")\n-        \n-        //update end date\n-        var endDateString =  Utilities.formatterShort?.string(from: lifeTime.1!)\n-        let endTime =  (dbActivity.endTime == nil) ? \"23:59:59\" : (dbActivity.endTime)!\n-        endDateString = (endDateString ?? \"\") + \" \" + endTime\n-        let endDate = Utilities.findDateFromString(dateString: endDateString ?? \"\")\n-        \n-        if startdate != nil && endDate != nil {\n-            //calcuate runs for activity\n-            let currentDate = DBHandler.getCurrentDateWithTimeDifference()\n-            \n-            let activity = DBHandler.getActivityFromDBActivity(dbActivity, runDate: currentDate)\n-            activity.startDate = startdate\n-            activity.endDate = endDate\n-            activity.anchorDate?.anchorDateValue = date\n-            Schedule().getRunsForActivity(activity: activity, handler: { (runs) in\n-                //if runs.count > 0 {\n-                    activity.activityRuns = runs\n-                    \n-                    //save overview\n-                    let dbActivityRuns = List<DBActivityRun>()\n-                    for activityRun in activity.activityRuns {\n-                        \n-                        let dbActivityRun = DBActivityRun()\n-                        dbActivityRun.startDate = activityRun.startDate\n-                        dbActivityRun.endDate = activityRun.endDate\n-                        dbActivityRun.activityId = activity.actvityId\n-                        dbActivityRun.studyId = activity.studyId\n-                        dbActivityRun.runId = activityRun.runId\n-                        dbActivityRun.isCompleted = activityRun.isCompleted\n-                        dbActivityRuns.append(dbActivityRun)\n-                    }\n-                    \n-                    \n-                    try? realm.write({\n-                        dbActivity.activityRuns.append(objectsIn: dbActivityRuns)\n-                        dbActivity.startDate = startdate\n-                        dbActivity.endDate = endDate\n-                        dbActivity.anchorDateValue = date\n-                    })\n-                    \n-               // }\n-               \n-            })\n-            \n-        }\n+  }\n+\n+  /// This method will calculate lifetime of Activity.\n+  /// - Parameters:\n+  ///   - date: Anchor date of the `Activity`.\n+  ///   - frequency: Frequency of `Activity`.\n+  ///   - startDays: Number of days to calculate start date from Anchor date.\n+  ///   - endDays: Number of days to calculate end date for **OneTime frequency** `Activity` from Anchor date.\n+  ///   - repeatInterval: To calculate end date for  **Daily, Weekly, Monthly**  frequencies `Activity` from Anchor date.\n+  /// - Returns: Start date and End date.\n+  private class func getLifeTime(\n+    _ date: Date,\n+    frequency: Frequency,\n+    startDays: Int,\n+    endDays: Int,\n+    repeatInterval: Int\n+  ) -> (Date?, Date?) {\n+\n+    var startDate: Date!\n+    var endDate: Date!\n+\n+    switch frequency {\n+    case .One_Time:\n+      let startDateInterval = TimeInterval(60*60*24*(startDays))\n+      let endDateInterval = TimeInterval(60*60*24*(endDays))\n+      startDate = date.addingTimeInterval(startDateInterval)\n+      endDate = date.addingTimeInterval(endDateInterval)\n+\n+    case .Daily:\n+      let startDateInterval = TimeInterval(60*60*24*(startDays))\n+      let endDateInterval = TimeInterval(60*60*24*(repeatInterval))\n+      startDate = date.addingTimeInterval(startDateInterval)\n+      endDate = startDate.addingTimeInterval(endDateInterval)\n+\n+    case .Weekly:\n+      let startDateInterval = TimeInterval(60*60*24*(startDays))\n+      let endDateInterval = TimeInterval(60*60*24*7*(repeatInterval))\n+      startDate = date.addingTimeInterval(startDateInterval)\n+      endDate = startDate.addingTimeInterval(endDateInterval)\n+\n+    case .Monthly:\n+      let startDateInterval = TimeInterval(60*60*24*(startDays))\n+      startDate = date.addingTimeInterval(startDateInterval)\n+      let calender = Calendar.current\n+      endDate = calender.date(byAdding: .month, value: (repeatInterval), to: startDate)\n+\n+    case .Scheduled:\n+      let startDateInterval = TimeInterval(60*60*24*(startDays))\n+      let endDateInterval = TimeInterval(60*60*24*(endDays))\n+      startDate = date.addingTimeInterval(startDateInterval)\n+      endDate = date.addingTimeInterval(endDateInterval)\n+\n     }\n-    \n-    private class func getLifeTime(_ date:Date,\n-                           frequency:Frequency,\n-                           startDays:Int,\n-                           endDays:Int,\n-                           repeatInterval:Int) -> (Date?,Date?) {\n-        \n-        \n-        var startDate:Date!\n-        var endDate:Date!\n-   \n-        \n-        switch frequency {\n-        case .One_Time:\n-            \n-            let startDateInterval = TimeInterval(60*60*24*(startDays))\n-            let endDateInterval = TimeInterval(60*60*24*(endDays))\n-            \n-            startDate = date.addingTimeInterval(startDateInterval)\n-            endDate = date.addingTimeInterval(endDateInterval)\n-            \n-        case .Daily:\n-            \n-            let startDateInterval = TimeInterval(60*60*24*(startDays))\n-            let endDateInterval = TimeInterval(60*60*24*(repeatInterval))\n-            startDate = date.addingTimeInterval(startDateInterval)\n-            endDate = startDate.addingTimeInterval(endDateInterval)\n-            \n-        case .Weekly:\n-            \n-            let startDateInterval = TimeInterval(60*60*24*(startDays))\n-            let endDateInterval = TimeInterval(60*60*24*7*(repeatInterval))\n-            startDate = date.addingTimeInterval(startDateInterval)\n-            endDate = startDate.addingTimeInterval(endDateInterval)\n-        case .Monthly:\n-            \n-            let startDateInterval = TimeInterval(60*60*24*(startDays))\n-            startDate = date.addingTimeInterval(startDateInterval)\n-            \n-            //let endDateInterval = TimeInterval(-1)\n-            let calender = Calendar.current\n-            endDate = calender.date(byAdding: .month, value: (repeatInterval), to: startDate)\n-            //endDate = endDate.addingTimeInterval(endDateInterval)\n-        case .Scheduled:\n-            \n-            let startDateInterval = TimeInterval(60*60*24*(startDays))\n-            let endDateInterval = TimeInterval(60*60*24*(endDays))\n-            \n-            startDate = date.addingTimeInterval(startDateInterval)\n-            endDate = date.addingTimeInterval(endDateInterval)\n-            \n-        }\n-        \n-        return (startDate,endDate)\n-    }\n-    \n-    class func getActivitiesWithEmptyAnchorDateValue(_ studyId:String) -> [DBActivity] {\n-        let realm = DBHandler.getRealmObject()!\n-        let dbActivities:Array<DBActivity> = realm.objects(DBActivity.self).filter({$0.studyId == studyId && $0.anchorDateValue == nil && $0.sourceType == \"ActivityResponse\"})\n-        return dbActivities\n-    }\n-    \n-    /**\n-     updates activity meta data to DB\n-    */\n-    class func updateActivityMetaData(activity: Activity){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbActivities = realm.objects(DBActivity.self).filter({$0.actvityId == activity.actvityId && $0.studyId == activity.studyId})\n-        let dbActivity = dbActivities.last\n-        \n-        try? realm.write({\n-            dbActivity?.shortName = activity.shortName\n-            \n-        })\n-        \n-    }\n-    \n-    /**\n-     loads activity list from DB for the study provided\n-     return completion handler with array of activities\n-    */\n-    class func loadActivityListFromDatabase(studyId: String,completionHandler: @escaping (Array<Activity>) -> ()){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        //let dbActivities = realm.objects(DBActivity.self).filter(\"studyId == %@\",studyId)\n-        let dbActivities = realm.objects(DBActivity.self).filter({$0.studyId == studyId && $0.startDate != nil})\n-    \n-        let date = DBHandler.getCurrentDateWithTimeDifference()\n-        var activities: Array<Activity> = []\n-        for dbActivity in dbActivities {\n-            \n-            let activity = DBHandler.getActivityFromDBActivity(dbActivity,runDate: date)\n-            activities.append(activity)\n-        }\n-        completionHandler(activities)\n-    }\n-    \n-    private class func getCurrentDateWithTimeDifference() -> Date {\n-        \n-        var date = Date().utcDate()\n-        \n-        let difference = UserDefaults.standard.value(forKey: \"offset\") as? Int\n-        if difference != nil {\n-            date = date.addingTimeInterval(TimeInterval(difference!))\n-        }\n-        \n-        return date\n-    }\n-    \n-    private class func getActivityFromDBActivity(_ dbActivity:DBActivity, runDate date:Date) -> Activity {\n-        \n-        //create activity instance\n-        let activity = Activity()\n-        activity.actvityId  = dbActivity.actvityId\n-        activity.studyId    = dbActivity.studyId\n-        activity.name       = dbActivity.name\n-        activity.startDate  = dbActivity.startDate\n-        activity.endDate    = dbActivity.endDate\n-        activity.type       = ActivityType(rawValue: dbActivity.type!)\n-        activity.frequencyType = Frequency(rawValue: dbActivity.frequencyType!)!\n-        activity.schedulingType = ActivityScheduleType(rawValue: dbActivity.schedulingType!)!\n-        activity.totalRuns = dbActivity.activityRuns.count\n-        activity.version = dbActivity.version\n-        activity.branching = dbActivity.branching\n-        activity.state = dbActivity.state\n-        activity.taskSubType = dbActivity.taskSubType\n-        do {\n-            let frequencyRuns = try JSONSerialization.jsonObject(with: dbActivity.frequencyRunsData!, options: []) as! [String: Any]\n-            activity.frequencyRuns = frequencyRuns[\"data\"] as! Array<Dictionary<String, Any>>?\n-            \n-        }catch {\n-        }\n-        \n-        do {\n-            let frequencyRuns = try JSONSerialization.jsonObject(with: dbActivity.anchorRunsData!, options: []) as! [String: Any]\n-            activity.anchorRuns = frequencyRuns[\"data\"] as! Array<Dictionary<String, Any>>?\n-            \n-        }catch {\n-        }\n-        \n-        if activity.totalRuns != 0 {\n-            \n-            //create activity run\n-            var runs: Array<ActivityRun> = []\n-            for dbRun in dbActivity.activityRuns {\n-                let run = ActivityRun()\n-                run .activityId = dbRun.activityId\n-                run.complitionDate = dbRun.complitionDate\n-                run.startDate = dbRun.startDate\n-                run.endDate = dbRun.endDate\n-                run.runId = dbRun.runId\n-                run.studyId = dbRun.studyId\n-                run.isCompleted = dbRun.isCompleted\n-                run.restortionData = dbRun.restortionData\n-                runs.append(run)\n-            }\n-            activity.activityRuns = runs\n-            \n-            var runsBeforeToday: Array<ActivityRun>! = []\n-            var run: ActivityRun!\n-            \n-            if activity.frequencyType == Frequency.One_Time && activity.endDate == nil {\n-                run = runs.last\n-                \n-            }else {\n-                \n-                runsBeforeToday = runs.filter({$0.endDate <= date})\n-                run = runs.filter({$0.startDate <= date && $0.endDate > date}).first //current run\n-            }\n-            \n-            let completedRuns = runs.filter({$0.isCompleted == true})\n-            activity.compeltedRuns = completedRuns.count\n-            activity.currentRunId =  (run != nil) ? (run?.runId)!: runsBeforeToday.count\n-            activity.currentRun = run\n-            activity.compeltedRuns = dbActivity.completedRuns\n-        }\n-        let userStatus = UserActivityStatus()\n-        userStatus.activityId = dbActivity.actvityId\n-        userStatus.activityRunId = String(activity.currentRunId)\n-        userStatus.studyId = dbActivity.studyId\n-        \n-        if String(activity.currentRunId) == dbActivity.currentRunId {\n-            userStatus.status = UserActivityStatus.ActivityStatus(rawValue: dbActivity.participationStatus)!\n-        }\n-        \n-        userStatus.compeltedRuns = activity.compeltedRuns\n-        userStatus.incompletedRuns = activity.incompletedRuns\n-        userStatus.totalRuns = activity.totalRuns\n-        \n-        let incompleteRuns = activity.currentRunId - activity.compeltedRuns\n-        activity.incompletedRuns = ((incompleteRuns < 0) || activity.totalRuns == 0) ? 0 :incompleteRuns\n-        \n-        if activity.currentRun == nil {\n-            userStatus.status = UserActivityStatus.ActivityStatus.abandoned\n-            \n-        }else {\n-            \n-            if userStatus.status != UserActivityStatus.ActivityStatus.completed {\n-                \n-                var incompleteRuns = activity.currentRunId - activity.compeltedRuns\n-                incompleteRuns -= 1\n-                activity.incompletedRuns = (incompleteRuns < 0) ? 0 :incompleteRuns\n-            }\n-            \n-        }\n-        activity.userParticipationStatus = userStatus\n-        \n-        //append to user class participatesStudies also\n-        let activityStatus = User.currentUser.participatedActivites.filter({$0.activityId == activity.actvityId && $0.studyId == activity.studyId}).first\n-        let index = User.currentUser.participatedActivites.index(where: {$0.activityId == activity.actvityId && $0.studyId == activity.studyId })\n-        if activityStatus != nil {\n-            User.currentUser.participatedActivites[index!] = userStatus\n-            \n-        }else {\n-            User.currentUser.participatedActivites.append(userStatus)\n-        }\n-        \n-        \n-        //save anchor date\n-        let anchorDate = AnchorDate()\n-        anchorDate.sourceType = dbActivity.sourceType\n-        anchorDate.sourceActivityId = dbActivity.sourceActivityId\n-        anchorDate.sourceKey = dbActivity.sourceKey\n-        anchorDate.sourceFormKey = dbActivity.sourceFormKey\n-        anchorDate.startDays = dbActivity.startDays\n-        anchorDate.startTime = dbActivity.startTime\n-        anchorDate.endDays = dbActivity.endDays\n-        anchorDate.repeatInterval = dbActivity.repeatInterval\n-        anchorDate.endTime = dbActivity.endTime\n-        activity.anchorDate = anchorDate\n-        \n-        return activity\n-    }\n-    \n-    /**\n-     loads studyRuns and returns completion and adherence for the runs\n-    */\n-    class func loadAllStudyRuns(studyId: String,completionHandler: @escaping (_ completion: Int,_ adherence: Int) -> ()){\n-        \n-        let date = Date()\n-        let realm = DBHandler.getRealmObject()!\n-        let studyRuns = realm.objects(DBActivityRun.self).filter(\"studyId == %@\",studyId)\n-        let completedRuns = studyRuns.filter({$0.isCompleted == true})\n-        let runsBeforeToday = studyRuns.filter({($0.endDate == nil) || ($0.endDate <= date)})\n-        var incompleteRuns = runsBeforeToday.count - completedRuns.count\n-        \n-        if incompleteRuns < 0 {\n-            incompleteRuns = 0\n-        }\n-        \n-        let completion = ceil( Double(self.divide(lhs: (completedRuns.count + incompleteRuns)*100, rhs: studyRuns.count)) )\n-        let adherence = ceil (Double(self.divide(lhs: (completedRuns.count)*100, rhs: (completedRuns.count + incompleteRuns))))\n-       \n-        completionHandler(Int(completion),Int(adherence))\n-        print(\"complete: \\(completedRuns.count) , incomplete: \\(incompleteRuns)\")\n-        \n-    }\n-    static func divide(lhs: Int, rhs: Int) -> Int {\n-        if rhs == 0 {\n-            return 0\n-        }\n-        return lhs/rhs\n-    }\n-    \n-    /**\n-     saves ActivityRuns to DB\n-     @param activity, activity in which ActivityRun to be updated\n-     @param studyId, study which contains activity\n-     @param runs, contains list of ActvityRun\n-    */\n-    class func saveActivityRuns(activityId: String,studyId: String,runs: Array<ActivityRun>){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbActivities = realm.objects(DBActivity.self).filter(\"studyId == %@ && actvityId == %@\",studyId,activityId)\n-        let dbActivity = dbActivities.last\n-        \n-        //save overview\n-        let dbActivityRuns = List<DBActivityRun>()\n-        for sectionIndex in 0...(runs.count-1) {\n-            \n-            let activityRun = runs[sectionIndex]\n-            let dbActivityRun = DBActivityRun()\n-            dbActivityRun.startDate = activityRun.startDate\n-            dbActivityRun.endDate = activityRun.endDate\n-            dbActivityRun.activityId = activityId\n-            dbActivityRun.studyId = studyId\n-            dbActivityRun.runId = activityRun.runId\n-            dbActivityRun.isCompleted = activityRun.isCompleted\n-            \n-            dbActivityRuns.append(dbActivityRun)\n-        }\n-        \n-        try? realm.write({\n-            dbActivity?.activityRuns.append(objectsIn: dbActivityRuns)\n-        })\n-        \n-    }\n-    \n-    class func updateRunToComplete(runId:Int,activityId: String,studyId: String){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbRuns = realm.objects(DBActivityRun.self).filter(\"studyId == %@ && activityId == %@ && runId == %d\",studyId,activityId,runId)\n-        let dbRun = dbRuns.last\n-        \n-        try? realm.write({\n-           dbRun?.isCompleted = true\n-        })\n-        \n-    }\n-    \n-    class func updateActivityParticipationStatus(activity: Activity){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let studies =  realm.objects(DBActivity.self).filter({$0.actvityId == activity.actvityId && $0.studyId == activity.studyId})\n-        let dbActivity = studies.last\n-        \n-        try? realm.write({\n-            \n-            dbActivity?.currentRunId = activity.userParticipationStatus.activityRunId\n-            dbActivity?.participationStatus = activity.userParticipationStatus.status.rawValue\n-            dbActivity?.completedRuns = activity.compeltedRuns\n-        })\n+\n+    return (startDate, endDate)\n+  }\n+\n+  /// This method will calculate the collection of `Activity` with `nil` anchor date.\n+  /// - Parameter studyId: StudyID to query `DBActivity` objects.\n+  class func getActivitiesWithEmptyAnchorDateValue(_ studyId: String) -> [DBActivity] {\n+    let realm = DBHandler.getRealmObject()!\n+    let dbActivities: [DBActivity] = realm.objects(DBActivity.self)\n+      .filter {\n+      $0.studyId == studyId\n+        && $0.anchorDateValue == nil\n+        && $0.sourceType == \"ActivityResponse\"\n     }\n-    \n-    /**\n-     saves response data for activity and sets the flag to be synched with server\n-    */\n-    class func saveResponseDataFor(activity: Activity,toBeSynced: Bool,data: Dictionary<String,Any>){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let currentRun = activity.currentRun\n-        let dbRuns = realm.objects(DBActivityRun.self).filter({$0.studyId == currentRun?.studyId && $0.activityId == activity.actvityId && $0.runId == currentRun?.runId})\n-        let dbRun = dbRuns.last\n-        \n-        try? realm.write({\n-            \n-            dbRun?.toBeSynced = true\n-            do {\n-                let json = [\"data\": data]\n-                let jsonData =  try JSONSerialization.data(withJSONObject: json, options: JSONSerialization.WritingOptions.prettyPrinted)\n-                dbRun?.responseData = jsonData\n-            }catch {\n-            }\n-        })\n+    return dbActivities\n+  }\n+\n+  /// Updates `Activity` meta data to DB.\n+  /// - Parameter activity: Instance of `Activity` to query `DBActivity` object.\n+  class func updateActivityMetaData(activity: Activity) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+\n+    let dbActivities = realm.objects(DBActivity.self)\n+      .filter {\n+      $0.actvityId == activity.actvityId\n+        && $0.studyId == activity.studyId\n     }\n-    \n-    /**\n-     saves the requestInformation for the missed requests due to network failure for offline support.\n-     @param params, request params\n-     @param headers, request Headers\n-     @param method, method type\n-     @param server, server string\n-    */\n-    class func saveRequestInformation(params: Dictionary<String,Any>?,headers: Dictionary<String,Any>?,method: String,server: String) {\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dataSync = DBDataOfflineSync()\n-        \n-        if params != nil {\n-            do {\n-                let paramData =  try JSONSerialization.data(withJSONObject: params!, options: JSONSerialization.WritingOptions.prettyPrinted)\n-                dataSync.requestParams = paramData\n-            }catch {\n-            }\n-        }\n-        \n-        if headers != nil {\n-            do {\n-                let headerData =  try JSONSerialization.data(withJSONObject: headers!, options: JSONSerialization.WritingOptions.prettyPrinted)\n-                dataSync.headerParams = headerData\n-            }catch {\n-            }\n-        }\n-        dataSync.method = method\n-        dataSync.server = server\n-        dataSync.date = Date()\n-        \n-        try? realm.write({\n-            realm.add(dataSync)\n+\n+    let dbActivity = dbActivities.last\n+\n+    try? realm.write {\n+      dbActivity?.shortName = activity.shortName\n+    }\n+\n+  }\n+\n+  ///  Loads activity collection from DB for the study provided.\n+  /// - Parameters:\n+  ///   - studyId: StudyID to query related `DBActivity` object.\n+  ///   - completionHandler:  Returns the collection of `Activity` instances.\n+  class func loadActivityListFromDatabase(\n+    studyId: String, completionHandler: @escaping ([Activity]) -> Void\n+  ) {\n+\n+    let realm = DBHandler.getRealmObject()!\n+\n+    let dbActivities = realm.objects(DBActivity.self)\n+      .filter {\n+      $0.studyId == studyId\n+        && $0.startDate != nil\n+    }\n+\n+    let date = DBHandler.getCurrentDateWithTimeDifference()\n+    var activities: [Activity] = []\n+\n+    dbActivities.forEach { (activity) in\n+      let activity = DBHandler.getActivityFromDBActivity(activity, runDate: date)\n+      activities.append(activity)\n+    }\n+    completionHandler(activities)\n+\n+  }\n+\n+  private class func getCurrentDateWithTimeDifference() -> Date {\n+\n+    var date = Date().utcDate()\n+\n+    let difference = UserDefaults.standard.value(forKey: \"offset\") as? Int\n+    if difference != nil {\n+      date = date.addingTimeInterval(TimeInterval(difference!))\n+    }\n+\n+    return date\n+  }\n+\n+  /// This method is the query unmanaged `Activity` instance from `DBActivity` object for particular run date.\n+  /// - Parameters:\n+  ///   - dbActivity: Instance of  `DBActivity`.\n+  ///   - date: Run data,\n+  private class func getActivityFromDBActivity(_ dbActivity: DBActivity, runDate date: Date)\n+    -> Activity {\n+\n+    // create activity instance\n+    let activity = Activity()\n+    activity.actvityId = dbActivity.actvityId\n+    activity.studyId = dbActivity.studyId\n+    activity.name = dbActivity.name\n+    activity.startDate = dbActivity.startDate\n+    activity.endDate = dbActivity.endDate\n+    activity.type = ActivityType(rawValue: dbActivity.type!)\n+    activity.frequencyType = Frequency(rawValue: dbActivity.frequencyType!)!\n+    activity.schedulingType = ActivityScheduleType(rawValue: dbActivity.schedulingType!)!\n+    activity.totalRuns = dbActivity.activityRuns.count\n+    activity.version = dbActivity.version\n+    activity.branching = dbActivity.branching\n+    activity.state = dbActivity.state\n+    activity.taskSubType = dbActivity.taskSubType\n+\n+    let frequencyRuns = try? JSONSerialization.jsonObject(\n+      with: dbActivity.frequencyRunsData!, options: []) as? JSONDictionary\n+    activity.frequencyRuns = frequencyRuns?[\"data\"] as? [JSONDictionary]\n+\n+    let anchorRuns = try? JSONSerialization.jsonObject(\n+      with: dbActivity.anchorRunsData!, options: []) as? JSONDictionary\n+    activity.anchorRuns = anchorRuns?[\"data\"] as? [JSONDictionary]\n+\n+    if activity.totalRuns != 0 {\n+\n+      // create activity run\n+      var runs: [ActivityRun] = []\n+      dbActivity.activityRuns.forEach { runs.append(ActivityRun(dbActivityRun: $0)) }\n+\n+      activity.activityRuns = runs\n+\n+      var runsBeforeToday: [ActivityRun]! = []\n+      var run: ActivityRun!\n+\n+      if activity.frequencyType == Frequency.One_Time && activity.endDate == nil {\n+        run = runs.last\n+      } else {\n+        runsBeforeToday = runs.filter({ $0.endDate <= date })\n+        run = runs.filter {\n+          $0.startDate <= date\n+            && $0.endDate > date\n+        }.first  // current run\n+      }\n+\n+      let completedRuns = runs.filter { $0.isCompleted == true }\n+      activity.compeltedRuns = completedRuns.count\n+      activity.currentRunId = (run != nil) ? (run?.runId)! : runsBeforeToday.count\n+      activity.currentRun = run\n+      activity.compeltedRuns = dbActivity.completedRuns\n+    }\n+    let userStatus = UserActivityStatus()\n+    userStatus.activityId = dbActivity.actvityId\n+    userStatus.activityRunId = String(activity.currentRunId)\n+    userStatus.studyId = dbActivity.studyId\n+\n+    if String(activity.currentRunId) == dbActivity.currentRunId {\n+      userStatus.status = UserActivityStatus.ActivityStatus(\n+        rawValue: dbActivity.participationStatus)!\n+    }\n+\n+    userStatus.compeltedRuns = activity.compeltedRuns\n+    userStatus.incompletedRuns = activity.incompletedRuns\n+    userStatus.totalRuns = activity.totalRuns\n+\n+    let incompleteRuns = activity.currentRunId - activity.compeltedRuns\n+    activity.incompletedRuns = ((incompleteRuns < 0) || activity.totalRuns == 0)\n+      ? 0 : incompleteRuns\n+\n+    if activity.currentRun == nil {\n+      userStatus.status = UserActivityStatus.ActivityStatus.abandoned\n+\n+    } else {\n+\n+      if userStatus.status != UserActivityStatus.ActivityStatus.completed {\n+\n+        var incompleteRuns = activity.currentRunId - activity.compeltedRuns\n+        incompleteRuns -= 1\n+        activity.incompletedRuns = (incompleteRuns < 0) ? 0 : incompleteRuns\n+      }\n+\n+    }\n+    activity.userParticipationStatus = userStatus\n+\n+    // append to user class participatesStudies also\n+    let activityStatus = User.currentUser.participatedActivites.filter({ $0.activityId == activity.actvityId && $0.studyId == activity.studyId }).first\n+    let index = User.currentUser.participatedActivites\n+      .firstIndex(\n+        where: {\n+          $0.activityId == activity.actvityId\n+            && $0.studyId == activity.studyId\n         })\n-        \n-    }\n-    \n-    class func isDataAvailableToSync(completionHandler: @escaping (Bool) -> ()){\n-        \n-        let realm = DBHandler.getRealmObject()!\n-        let dbRuns = realm.objects(DBDataOfflineSync.self)\n-        \n-        if dbRuns.count > 0{\n-            completionHandler(true)\n-        }else {\n-            completionHandler(false)\n+\n+    if activityStatus != nil {\n+      User.currentUser.participatedActivites[index!] = userStatus\n+    } else {\n+      User.currentUser.participatedActivites.append(userStatus)\n+    }\n+\n+    // save anchor date\n+    let anchorDate = AnchorDate()\n+    anchorDate.sourceType = dbActivity.sourceType\n+    anchorDate.sourceActivityId = dbActivity.sourceActivityId\n+    anchorDate.sourceKey = dbActivity.sourceKey\n+    anchorDate.sourceFormKey = dbActivity.sourceFormKey\n+    anchorDate.startDays = dbActivity.startDays\n+    anchorDate.startTime = dbActivity.startTime\n+    anchorDate.endDays = dbActivity.endDays\n+    anchorDate.repeatInterval = dbActivity.repeatInterval\n+    anchorDate.endTime = dbActivity.endTime\n+    activity.anchorDate = anchorDate\n+\n+    return activity\n+  }\n+\n+  /// Loads studyRuns and returns completion and adherence for the runs.\n+  /// - Parameters:\n+  ///   - studyId: studyId description.  // TBD:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 2278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0Nzk2NA==", "bodyText": "empty block may be written as {}", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391847964", "createdAt": "2020-03-12T19:37:14Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Networking/APIs/UserServices.swift", "diffHunk": "@@ -89,898 +73,965 @@ let kActivityRunId = \"activityRunId\"\n let kCompletion = \"completion\"\n let kAdherence = \"adherence\"\n \n-// MARK: Logout Api constants\n+// MARK: - Logout Api constants\n let kLogoutReason = \"reason\"\n let kLogoutReasonValue = \"Logout\"\n \n-// MARK: Refresh token constants\n-\n+// MARK: - Refresh token constants\n let kRefreshToken = \"refreshToken\"\n \n struct FailedUserServices {\n-    \n-    var requestParams: [String: Any]? = [:]\n-    var headerParams: [String: String]? = [:]\n-    var method: Method!\n+  var requestParams: [String: Any]? = [:]\n+  var headerParams: [String: String]? = [:]\n+  var method: Method!\n }\n \n+class UserServices: NSObject {\n \n+  let networkManager = NetworkManager.sharedInstance()\n+  var delegate: NMWebServiceDelegate?\n+  var requestParams: [String: Any]? = [:]\n+  var headerParams: [String: String]? = [:]\n+  var method: Method!\n+  var failedRequestServices = FailedUserServices()\n \n-class UserServices: NSObject {\n-    \n-    let networkManager = NetworkManager.sharedInstance()\n-    var delegate: NMWebServiceDelegate! = nil\n-    var requestParams: Dictionary<String,Any>? = [:]\n-    var headerParams: Dictionary<String,String>? = [:]\n-    var method: Method!\n-    var failedRequestServices = FailedUserServices()\n-    \n-    \n-    // MARK: Requests\n-    \n-    /*\n-    func checkForAppUpdates(delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        let method = RegistrationMethods.versionInfo.method\n-        self.sendRequestWith(method: method, params: nil, headers: nil)\n-    }*/\n-    \n-    \n-    func loginUser(_ delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let params = [kUserEmailId: user.emailId!,\n-                      kUserPassword: user.password!,\n-                      \"appId\":Utilities.getBundleIdentifier()]\n-        \n-        let method = RegistrationMethods.login.method\n-        \n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-        \n-    }\n-    \n-    func registerUser(_ delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        \n-        let params = [kUserEmailId: user.emailId!,\n-                      kUserPassword: user.password!,\n-                      \"appId\":Utilities.getBundleIdentifier()\n-                      ]\n-        \n-        let method = RegistrationMethods.register.method\n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-        \n-    }\n-    \n-    func confirmUserRegistration(_ delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId!]\n-        let method = RegistrationMethods.confirmRegistration.method\n-        self.sendRequestWith(method: method, params: nil, headers: headerParams)\n-        \n-    }\n-    \n-    \n-    func verifyEmail(emailId: String,verificationCode: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        //let user = User.currentUser\n-        \n-        let param = [kVerifyCode: verificationCode,\n-                     kUserEmailId: emailId]\n-        let method = RegistrationMethods.verify.method\n-        self.sendRequestWith(method: method, params: param, headers: nil)\n-        \n-    }\n-    \n-    \n-    func resendEmailConfirmation(emailId: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        let params = [kUserEmailId: emailId]\n-        let method = RegistrationMethods.resendConfirmation.method\n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-        \n-    }\n-    \n-    \n-    func logoutUser(_ delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId!]\n-        let params = [kUserLogoutReason: user.logoutReason.rawValue]\n-        \n-        let method = RegistrationMethods.logout.method\n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-        \n-    }\n-    \n-    func deleteAccount(_ delegate: NMWebServiceDelegate)  {\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserAuthToken: user.authToken] as Dictionary<String,String>\n-        let method = RegistrationMethods.deleteAccount.method\n-        self.sendRequestWith(method: method, params: nil, headers: headerParams)\n-    }\n-    \n-    func deActivateAccount(listOfStudyIds: Array<String> , delegate: NMWebServiceDelegate)  {\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserAuthToken: user.authToken,\n-                            kUserId: user.userId!] as Dictionary<String,String>\n-        \n-        let params = [kDeactivateAccountDeleteData: listOfStudyIds]\n-        \n-        let method = RegistrationMethods.deactivate.method\n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    \n-    func forgotPassword(email: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-       // let user = User.currentUser\n-        let params = [kUserEmailId: email]\n-        let method = RegistrationMethods.forgotPassword.method\n-        \n-        self.sendRequestWith(method: method, params: params, headers: nil )\n-    }\n-    \n-    func changePassword(oldPassword: String,newPassword: String,delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId!]\n-        let params = [kUserOldPassword: oldPassword,\n-                      kUserNewPassword: newPassword]\n-        \n-        let method = RegistrationMethods.changePassword.method\n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func getUserProfile(_ delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        \n-        let headerParams = [kUserId: user.userId!]\n-        let method = RegistrationMethods.userProfile.method\n-        self.sendRequestWith(method: method, params: nil, headers: headerParams)\n-    }\n-    \n-    func updateUserProfile(_ delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId!]\n-        \n-        let settings = [kSettingsRemoteNotifications: (user.settings?.remoteNotifications)! as Bool,\n-                        kSettingsTouchId: (user.settings?.touchId)! as Bool,\n-                        kSettingsPassCode: (user.settings?.passcode)! as Bool,\n-                        kSettingsLocalNotifications: (user.settings?.localNotifications)! as Bool,\n-                        kSettingsLeadTime: (user.settings?.leadTime)! as String,\n-                        kSettingsLocale: (user.settings?.locale)! as String\n-            ] as [String: Any]\n-        \n-        let version = Utilities.getAppVersion()\n-        let token = Utilities.getBundleIdentifier()\n-        let info = [kAppVersion: version,\n-                    kOSType: \"ios\",\n-                    kDeviceToken: token\n-        ]\n-        \n-        let params = [\n-            kUserSettings: settings,\n-            kBasicInfo: info,\n-            kParticipantInfo: []] as [String: Any]\n-        \n-        let method = RegistrationMethods.updateUserProfile.method\n-        \n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func updateUserProfile(deviceToken: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId!]\n-        \n-//        let settings = [kSettingsRemoteNotifications: (user.settings?.remoteNotifications)! as Bool,\n-//                        kSettingsTouchId: (user.settings?.touchId)! as Bool,\n-//                        kSettingsPassCode: (user.settings?.passcode)! as Bool,\n-//                        kSettingsLocalNotifications: (user.settings?.localNotifications)! as Bool,\n-//                        kSettingsLeadTime: (user.settings?.leadTime)! as String,\n-//                        kSettingsLocale: (user.settings?.locale)! as String\n-//            ] as [String: Any]\n-        \n-        let version = Utilities.getAppVersion()\n-        let info = [kAppVersion: version,\n-                    kOSType: \"ios\",\n-                    kDeviceToken: deviceToken\n-        ]\n-        \n-        let params = [\n-            \n-            kBasicInfo: info,\n-            kParticipantInfo: []] as [String: Any]\n-        \n-        let method = RegistrationMethods.updateUserProfile.method\n-        \n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func getUserPreference(_ delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId!,\n-                            kUserAuthToken: user.authToken] as Dictionary<String, String>\n-        \n-        let method = RegistrationMethods.userPreferences.method\n-        \n-        self.sendRequestWith(method: method, params: nil, headers: headerParams)\n-    }\n-    \n-    \n-    func getStudyStates(_ delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId!] as Dictionary<String, String>\n-        let method = RegistrationMethods.studyState.method\n-        \n-        self.sendRequestWith(method: method, params: nil, headers: headerParams)\n-    }\n-    \n-    func updateCompletionAdherence(studyStauts: UserStudyStatus , delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId!]\n-        \n-        let params = [kStudies: [studyStauts.getCompletionAdherence()]] as [String: Any]\n-        let method = RegistrationMethods.updateStudyState.method\n-        \n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func updateStudyBookmarkStatus(studyStauts: UserStudyStatus , delegate: NMWebServiceDelegate){\n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId!]\n-        \n-        let params = [kStudies: [studyStauts.getBookmarkUserStudyStatus()]] as [String: Any]\n-        let method = RegistrationMethods.updateStudyState.method\n-        \n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func updateActivityBookmarkStatus(activityStauts: UserActivityStatus , delegate: NMWebServiceDelegate){\n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId] as Dictionary<String, String>\n-        \n-        let params = [kActivites: [activityStauts.getBookmarkUserActivityStatus()]] as [String : Any]\n-        let method = RegistrationMethods.updateActivityState.method\n-        \n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func updateUserParticipatedStatus(studyStauts: UserStudyStatus, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId] as Dictionary<String, String>\n-        let params = [kStudies: [studyStauts.getParticipatedUserStudyStatus()]] as [String: Any]\n-        let method = RegistrationMethods.updateStudyState.method\n-        \n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func updateUserActivityParticipatedStatus(studyId: String, activityStatus: UserActivityStatus, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId] as Dictionary<String, String>\n-        let params = [kStudyId: studyId,\n-                      kActivity: [activityStatus.getParticipatedUserActivityStatus()]] as [String: Any]\n-        let method = RegistrationMethods.updateActivityState.method\n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func updateUserEligibilityConsentStatus(eligibilityStatus: Bool,consentStatus: ConsentStatus, delegate: NMWebServiceDelegate){\n-        \n-        \n-        self.delegate = delegate\n-        \n-       \n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId! as String,\n-                            kUserAuthToken: user.authToken! as String]\n-        \n-        let consentVersion: String?\n-        if (ConsentBuilder.currentConsent?.version?.count)! > 0 {\n-            consentVersion = ConsentBuilder.currentConsent?.version!\n-        } else {\n-            consentVersion = \"1\"\n-        }\n-        \n-        let base64data = ConsentBuilder.currentConsent?.consentResult?.consentPdfData!.base64EncodedString()\n-        \n-        let consent = [ kConsentDocumentVersion: consentVersion! as String,\n-                        kStatus: consentStatus.rawValue,\n-                        kConsentpdf: \"\\(base64data!)\" as Any] as [String: Any]\n-        \n-        \n-        let params = [kStudyId: (Study.currentStudy?.studyId!)! as String,\n-                      kEligibility: eligibilityStatus,\n-                      kConsent: consent,\n-                      kConsentSharing: \"\"] as [String : Any]\n-        let method = RegistrationMethods.updateEligibilityConsentStatus.method\n-        \n-        //print(\" doc == \\(ConsentBuilder.currentConsent?.consentResult?.consentPdfData)\")\n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func getConsentPDFForStudy(studyId: String , delegate: NMWebServiceDelegate) {\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let params = [kStudyId: studyId,\n-                      \"consentVersion\": \"\"]\n-        \n-        let headerParams = [kUserId: user.userId!]\n-        let method = RegistrationMethods.consentPDF.method\n-        \n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func updateUserActivityState(_ delegate: NMWebServiceDelegate) {\n-        \n-        self.delegate = delegate\n-        \n-        //INCOMPLETE\n-        //let method = RegistrationMethods.updateActivityState.method\n-    }\n-    \n-    func getUserActivityState(studyId: String , delegate: NMWebServiceDelegate) {\n-        \n-        self.delegate = delegate\n-        \n-        let user = User.currentUser\n-        let params = [kStudyId: studyId]\n-        let headerParams = [kUserId: user.userId!]\n-        let method = RegistrationMethods.activityState.method\n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func withdrawFromStudy(studyId: String ,shouldDeleteData: Bool, delegate: NMWebServiceDelegate){\n-        \n-        \n-        self.delegate = delegate\n-        let user = User.currentUser\n-        let headerParams = [kUserId: user.userId! as String]\n-        \n-        let params = [\n-            kStudyId: studyId,\n-            kDeleteData: shouldDeleteData] as [String: Any]\n-        \n-        let method = RegistrationMethods.withdraw.method\n-        \n-        self.sendRequestWith(method: method, params: params, headers: headerParams)\n-    }\n-    \n-    func updateToken(){\n-        \n-        let user = User.currentUser\n-        \n-        let param = [kRefreshToken: user.refreshToken!]\n-        let method = RegistrationMethods.refreshToken.method\n-        self.sendRequestWith(method: method, params: param, headers: nil)\n-        \n-    }\n-    \n-    func syncOfflineSavedData(method: Method, params: Dictionary<String, Any>?,headers: Dictionary<String, String>? , delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        self.sendRequestWith(method: method, params: params, headers: headers)\n-    }\n-    \n-    \n-    // MARK:Parsers\n-    func handleUserLoginResponse(response: Dictionary<String, Any>){\n-        \n-        let user = User.currentUser\n-        user.userId     = (response[kUserId] as? String)!\n-        user.verified   = (response[kUserVerified] as? Bool)!\n-        user.authToken  = (response[kUserAuthToken] as? String)!\n-        if let refreshToken = response[kRefreshToken] as? String {\n-            user.refreshToken = refreshToken\n-            \n-        }\n-        \n-        if let isTempPassword = response[kUserIsTempPassword] as? Bool {\n-            user.isLoginWithTempPassword = isTempPassword\n-        }\n-        \n-        if user.verified! && !user.isLoginWithTempPassword {\n-            \n-            //set user type & save current user to DB\n-            user.userType = UserType.FDAUser\n-            DBHandler().saveCurrentUser(user: user)\n-            \n-            //Updating Key & Vector\n-            let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n-            appDelegate.updateKeyAndInitializationVector()\n-            \n-            \n-            //TEMP : Need to save these values in Realm\n-            let ud = UserDefaults.standard\n-            ud.set(user.authToken, forKey: kUserAuthToken)\n-            ud.set(user.userId!, forKey: kUserId)\n-            ud.set(true, forKey: kPasscodeIsPending)\n-            ud.synchronize()\n-            \n-            StudyFilterHandler.instance.previousAppliedFilters = []\n-            \n-        }\n-        \n-    }\n-    \n-    func handleUserRegistrationResponse(response: Dictionary<String, Any>){\n-        \n-        let user = User.currentUser\n-        user.userId     = (response[kUserId] as? String)!\n-        user.verified   = (response[kUserVerified] as? Bool)!\n-        user.authToken  = (response[kUserAuthToken] as? String)!\n-        \n-        user.refreshToken = (response[kRefreshToken] as? String)!\n-        StudyFilterHandler.instance.previousAppliedFilters = []\n-        \n-    }\n-    \n-    func handleConfirmRegistrationResponse(response: Dictionary<String, Any>){\n-        \n-        let user = User.currentUser\n-        if let varified = response[kUserVerified] as? Bool {\n-            \n-            user.verified = varified\n-            if user.verified! {\n-                \n-                user.userType = UserType.FDAUser\n-                \n-                //TEMP : Need to save these values in Realm\n-                let ud = UserDefaults.standard\n-                ud.set(user.authToken, forKey: kUserAuthToken)\n-                ud.set(user.userId!, forKey: kUserId)\n-                ud.synchronize()\n-                //Save Current User to DB\n-                DBHandler().saveCurrentUser(user: user)\n-                StudyFilterHandler.instance.previousAppliedFilters = []\n-            }\n-        }\n-    }\n-    \n-    func handleEmailVerifyResponse(response: Dictionary<String, Any>){\n-        \n-        let user = User.currentUser\n-        user.verified = true\n-        \n-        if user.verified! {\n-            \n-            if user.authToken != nil {\n-                \n-                user.userType = UserType.FDAUser\n-                \n-                //TEMP : Need to save these values in Realm\n-                let ud = UserDefaults.standard\n-                ud.set(user.authToken, forKey: kUserAuthToken)\n-                ud.set(user.userId!, forKey: kUserId)\n-                ud.set(true, forKey: kPasscodeIsPending)\n-                ud.synchronize()\n-                \n-                DBHandler().saveCurrentUser(user: user)\n-            }\n-        }\n-    }\n-    \n-    func handleGetUserProfileResponse(response: Dictionary<String, Any>) {\n-        \n-        let user = User.currentUser\n-        \n-        //settings\n-        let settings = (response[kUserSettings] as? Dictionary<String, Any>)!\n-        let userSettings = Settings()\n-        userSettings.setSettings(dict: settings as NSDictionary)\n-        user.settings = userSettings\n-        \n-        DBHandler.saveUserSettingsToDatabase()\n-        \n-        //profile\n-        let profile = (response[kUserProfile] as? Dictionary<String, Any>)!\n-        user.emailId = profile[kUserEmailId] as? String\n-        user.firstName = profile[kUserFirstName] as? String\n-        user.lastName = profile[kUserLastName] as? String\n-    }\n-    \n-    func handleUpdateUserProfileResponse(response: Dictionary<String, Any>) {\n-    }\n-    \n-    func handleResendEmailConfirmationResponse(response: Dictionary<String, Any>) {\n-    }\n-    \n-    \n-    func handleChangePasswordResponse(response: Dictionary<String, Any>) {\n-        \n-        let user = User.currentUser\n-        if user.verified! {\n-            \n-            user.userType = UserType.FDAUser\n-            \n-            DBHandler().saveCurrentUser(user: user)\n-            \n-            //TEMP : Need to save these values in Realm\n-            let ud = UserDefaults.standard\n-            ud.set(user.authToken, forKey: kUserAuthToken)\n-            ud.set(user.userId!, forKey: kUserId)\n-            ud.synchronize()\n-        }\n-        \n-    }\n-    \n-    \n-    func handleGetPreferenceResponse(response: Dictionary<String, Any>){\n-        \n-        let user = User.currentUser\n-\n-        //studies\n-        if let studies = response[kStudies] as? Array<Dictionary<String, Any>> {\n-            \n-            for study in studies {\n-                let participatedStudy = UserStudyStatus(detail: study)\n-                user.participatedStudies.append(participatedStudy)\n-            }\n-        }\n-        \n-        //activities\n-//        if let activites = response[kActivites]  as? Array<Dictionary<String, Any>> {\n-//            for _ in activites {\n-//                // let participatedActivity = UserActivityStatus(detail: activity)\n-//                // user.participatedActivites.append(participatedActivity)\n-//            }\n-//        }\n-    }\n-    \n-    func handleGetStudyStatesResponse(response: Dictionary<String, Any>){\n-        let user = User.currentUser\n-        //studies\n-        user.participatedStudies.removeAll()\n-        if let studies = response[kStudies] as? Array<Dictionary<String, Any>> {\n-            \n-            for study in studies {\n-                let participatedStudy = UserStudyStatus(detail: study)\n-                user.participatedStudies.append(participatedStudy)\n-            }\n-        }\n-    }\n-    func handleGetActivityStatesResponse(response: Dictionary<String, Any>){\n-        let user = User.currentUser\n-        //activities\n-        if let activites = response[kActivites]  as? Array<Dictionary<String, Any>> {\n-            if Study.currentStudy != nil {\n-                for activity in activites {\n-                    let participatedActivity = UserActivityStatus(detail: activity,studyId:(Study.currentStudy?.studyId)!)\n-                    user.participatedActivites.append(participatedActivity)\n-                }\n-            }\n-        }\n-    }\n-    func handleUpdateEligibilityConsentStatusResponse(response: Dictionary<String, Any>){\n-        \n-    }\n-    \n-    func handleGetConsentPDFResponse(response: Dictionary<String, Any>){\n-        \n-        //let user = User.currentUser\n-        if Utilities.isValidValue(someObject: response[kConsent] as AnyObject?) {\n-            //Do nothing\n-        }\n+  // MARK: - Requests\n+\n+  /// Creates a request to login an `User`\n+  /// - Parameter delegate: Class object to receive response\n+  func loginUser(_ delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let params = [\n+      kUserEmailId: user.emailId!,\n+      kUserPassword: user.password!,\n+      \"appId\": Utilities.getBundleIdentifier()\n+    ]\n+\n+    let method = RegistrationMethods.login.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+\n+  }\n+\n+  /// Creates a request for new `User`\n+  /// - Parameter delegate: Class object to receive response\n+  func registerUser(_ delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+\n+    let params = [\n+      kUserEmailId: user.emailId!,\n+      kUserPassword: user.password!,\n+      \"appId\": Utilities.getBundleIdentifier()\n+    ]\n+\n+    let method = RegistrationMethods.register.method\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+\n+  }\n+\n+  /// Creates a request to confirm `User` registation\n+  /// - Parameter delegate: Class object to receive response\n+  func confirmUserRegistration(_ delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId!]\n+    let method = RegistrationMethods.confirmRegistration.method\n+    self.sendRequestWith(method: method, params: nil, headers: headerParams)\n+\n+  }\n+\n+  /// Creates a request to verify an `User`\n+  /// - Parameters:\n+  ///   - emailId: Email Id of the`User ` to verify\n+  ///   - verificationCode: Code which is to be verified\n+  ///   - delegate: Class object to receive response\n+  func verifyEmail(emailId: String, verificationCode: String, delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let param = [\n+      kVerifyCode: verificationCode,\n+      kUserEmailId: emailId\n+    ]\n+    let method = RegistrationMethods.verify.method\n+    self.sendRequestWith(method: method, params: param, headers: nil)\n+\n+  }\n+\n+  /// Creates a request to reconfirm an `User`\n+  /// - Parameters:\n+  ///   - emailId: Email Id of the `User\n+  ///   - delegate: Class object to receive response\n+  func resendEmailConfirmation(emailId: String, delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+    let params = [kUserEmailId: emailId]\n+    let method = RegistrationMethods.resendConfirmation.method\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+\n+  }\n+\n+  /// Creates a request to logout an `User`\n+  /// - Parameter delegate: Class object to receive response\n+  func logoutUser(_ delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId!]\n+    let params = [kUserLogoutReason: user.logoutReason.rawValue]\n+\n+    let method = RegistrationMethods.logout.method\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+\n+  }\n+\n+  /// Creates a request to delete an `User` account\n+  /// - Parameter delegate: Class object to receive response\n+  func deleteAccount(_ delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserAuthToken: user.authToken] as [String: String]\n+    let method = RegistrationMethods.deleteAccount.method\n+    self.sendRequestWith(method: method, params: nil, headers: headerParams)\n+  }\n+\n+  /// Creates a request to deactivate an `User` account\n+  /// - Parameters:\n+  ///   - listOfStudyIds: Collection of Study Id\n+  ///   - delegate: Class object to receive response\n+  func deActivateAccount(listOfStudyIds: [String], delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [\n+      kUserAuthToken: user.authToken,\n+      kUserId: user.userId!\n+    ] as [String: String]\n+\n+    let params = [kDeactivateAccountDeleteData: listOfStudyIds]\n+\n+    let method = RegistrationMethods.deactivate.method\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to reset the `User` password\n+  /// - Parameters:\n+  ///   - email: Email Id of the`User `\n+  ///   - delegate: Class object to receive response\n+  func forgotPassword(email: String, delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    // let user = User.currentUser\n+    let params = [kUserEmailId: email]\n+    let method = RegistrationMethods.forgotPassword.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+  }\n+\n+  /// Creates a request to change the `User` password\n+  /// - Parameters:\n+  ///   - oldPassword:\n+  ///   - newPassword:\n+  ///   - delegate: Class object to receive response\n+  func changePassword(oldPassword: String, newPassword: String, delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId!]\n+    let params = [\n+      kUserOldPassword: oldPassword,\n+      kUserNewPassword: newPassword\n+    ]\n+\n+    let method = RegistrationMethods.changePassword.method\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to get `User` profile information\n+  /// - Parameter delegate: Class object to receive response\n+  func getUserProfile(_ delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+\n+    let headerParams = [kUserId: user.userId!]\n+    let method = RegistrationMethods.userProfile.method\n+    self.sendRequestWith(method: method, params: nil, headers: headerParams)\n+  }\n+\n+  /// Creates a request to update `User` profile\n+  /// - Parameter delegate: Class object to receive response\n+  func updateUserProfile(_ delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId!]\n+\n+    let settings = [\n+      kSettingsRemoteNotifications: (user.settings?.remoteNotifications)! as Bool,\n+      kSettingsTouchId: (user.settings?.touchId)! as Bool,\n+      kSettingsPassCode: (user.settings?.passcode)! as Bool,\n+      kSettingsLocalNotifications: (user.settings?.localNotifications)! as Bool,\n+      kSettingsLeadTime: (user.settings?.leadTime)! as String,\n+      kSettingsLocale: (user.settings?.locale)! as String\n+    ] as [String: Any]\n+\n+    let version = Utilities.getAppVersion()\n+    let token = Utilities.getBundleIdentifier()\n+    let info = [\n+      kAppVersion: version,\n+      kOSType: \"ios\",\n+      kDeviceToken: token\n+    ]\n+\n+    let params = [\n+      kUserSettings: settings,\n+      kBasicInfo: info,\n+      kParticipantInfo: []\n+    ] as [String: Any]\n+\n+    let method = RegistrationMethods.updateUserProfile.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to update `User` profile\n+  /// - Parameters:\n+  ///   - deviceToken:\n+  ///   - delegate: Class object to receive response\n+  func updateUserProfile(deviceToken: String, delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId!]\n+    let version = Utilities.getAppVersion()\n+    let info = [\n+      kAppVersion: version,\n+      kOSType: \"ios\",\n+      kDeviceToken: deviceToken\n+    ]\n+\n+    let params = [\n+\n+      kBasicInfo: info,\n+      kParticipantInfo: []\n+    ] as [String: Any]\n+\n+    let method = RegistrationMethods.updateUserProfile.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to get `User`preferences\n+  /// - Parameter delegate: Class object to receive response\n+  func getUserPreference(_ delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [\n+      kUserId: user.userId!,\n+      kUserAuthToken: user.authToken\n+    ] as [String: String]\n+\n+    let method = RegistrationMethods.userPreferences.method\n+\n+    self.sendRequestWith(method: method, params: nil, headers: headerParams)\n+  }\n+\n+  /// Creates a request to get `Study` States\n+  /// - Parameter delegate: Class object to receive response\n+  func getStudyStates(_ delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId!] as [String: String]\n+    let method = RegistrationMethods.studyState.method\n+\n+    self.sendRequestWith(method: method, params: nil, headers: headerParams)\n+  }\n+\n+  /// Creates a request to update `Study` status\n+  /// - Parameters:\n+  ///   - studyStatus: Instance of `UserStudyStatus` to update\n+  ///   - delegate: Class object to receive response\n+  func updateCompletionAdherence(studyStatus: UserStudyStatus, delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId!]\n+\n+    let params = [kStudies: [studyStatus.getCompletionAdherence()]] as [String: Any]\n+    let method = RegistrationMethods.updateStudyState.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to update `Study` bookmark status\n+  /// - Parameters:\n+  ///   - studyStatus: Instance of `UserStudyStatus` to update\n+  ///   - delegate: Class object to receive response\n+  func updateStudyBookmarkStatus(studyStatus: UserStudyStatus, delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId!]\n+\n+    let params = [kStudies: [studyStatus.getBookmarkUserStudyStatus()]] as [String: Any]\n+    let method = RegistrationMethods.updateStudyState.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to update `Activity` bookmark status\n+  /// - Parameters:\n+  ///   - activityStauts: Instance of `UserActivityStatus` to update\n+  ///   - delegate: Class object to receive response\n+  func updateActivityBookmarkStatus(\n+    activityStauts: UserActivityStatus, delegate: NMWebServiceDelegate\n+  ) {\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId] as [String: String]\n+\n+    let params = [kActivites: [activityStauts.getBookmarkUserActivityStatus()]] as [String: Any]\n+    let method = RegistrationMethods.updateActivityState.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to update `Study` participation status\n+  /// - Parameters:\n+  ///   - studyStauts: Instance of `UserStudyStatus` to update\n+  ///   - delegate: Class object to receive response\n+  func updateUserParticipatedStatus(studyStauts: UserStudyStatus, delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId] as [String: String]\n+    let params = [kStudies: [studyStauts.getParticipatedUserStudyStatus()]] as [String: Any]\n+    let method = RegistrationMethods.updateStudyState.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to update `Activity` participation status\n+  /// - Parameters:\n+  ///   - studyId: ID of Study\n+  ///   - activityStatus: Instance of `UserActivityStatus` to update\n+  ///   - delegate: Class object to receive response\n+  func updateUserActivityParticipatedStatus(\n+    studyId: String, activityStatus: UserActivityStatus, delegate: NMWebServiceDelegate\n+  ) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId] as [String: String]\n+    let params = [\n+      kStudyId: studyId,\n+      kActivity: [activityStatus.getParticipatedUserActivityStatus()]\n+    ] as [String: Any]\n+    let method = RegistrationMethods.updateActivityState.method\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to update Consent status\n+  /// - Parameters:\n+  ///   - eligibilityStatus:\n+  ///   - consentStatus: Instance of `ConsentStatus`\n+  ///   - delegate: Class object to receive response\n+  func updateUserEligibilityConsentStatus(\n+    eligibilityStatus: Bool, consentStatus: ConsentStatus, delegate: NMWebServiceDelegate\n+  ) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let headerParams = [\n+      kUserId: user.userId! as String,\n+      kUserAuthToken: user.authToken! as String\n+    ]\n+\n+    let consentVersion: String?\n+    if (ConsentBuilder.currentConsent?.version?.count)! > 0 {\n+      consentVersion = ConsentBuilder.currentConsent?.version!\n+    } else {\n+      consentVersion = \"1\"\n     }\n-    \n-    func handleUpdateActivityStateResponse(response: Dictionary<String, Any>){\n-        \n+\n+    let base64data = ConsentBuilder.currentConsent?.consentResult?.consentPdfData!\n+      .base64EncodedString()\n+\n+    let consent = [\n+      kConsentDocumentVersion: consentVersion! as String,\n+      kStatus: consentStatus.rawValue,\n+      kConsentpdf: \"\\(base64data!)\" as Any\n+    ] as [String: Any]\n+\n+    let params = [\n+      kStudyId: (Study.currentStudy?.studyId!)! as String,\n+      kEligibility: eligibilityStatus,\n+      kConsent: consent,\n+      kConsentSharing: \"\"\n+    ] as [String: Any]\n+    let method = RegistrationMethods.updateEligibilityConsentStatus.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to get Consent pdf\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - delegate: Class object to receive response\n+  func getConsentPDFForStudy(studyId: String, delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let params = [\n+      kStudyId: studyId,\n+      \"consentVersion\": \"\"\n+    ]\n+\n+    let headerParams = [kUserId: user.userId!]\n+    let method = RegistrationMethods.consentPDF.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to update `Activity` status\n+  /// - Parameter delegate: Class object to receive response\n+  func updateUserActivityState(_ delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+  }\n+\n+  /// Creates a request to get `Activity` status\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - delegate: Class object to receive response\n+  func getUserActivityState(studyId: String, delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+\n+    let user = User.currentUser\n+    let params = [kStudyId: studyId]\n+    let headerParams = [kUserId: user.userId!]\n+    let method = RegistrationMethods.activityState.method\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to withdraw from `Study`\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - shouldDeleteData: withdraw status\n+  ///   - delegate: Class object to receive response\n+  func withdrawFromStudy(studyId: String, shouldDeleteData: Bool, delegate: NMWebServiceDelegate) {\n+\n+    self.delegate = delegate\n+    let user = User.currentUser\n+    let headerParams = [kUserId: user.userId! as String]\n+\n+    let params = [\n+      kStudyId: studyId,\n+      kDeleteData: shouldDeleteData\n+    ] as [String: Any]\n+\n+    let method = RegistrationMethods.withdraw.method\n+\n+    self.sendRequestWith(method: method, params: params, headers: headerParams)\n+  }\n+\n+  /// Creates a request to update RefreshToken\n+  func updateToken() {\n+\n+    let user = User.currentUser\n+\n+    let param = [kRefreshToken: user.refreshToken!]\n+    let method = RegistrationMethods.refreshToken.method\n+    self.sendRequestWith(method: method, params: param, headers: nil)\n+\n+  }\n+\n+  /// Creattes a request to sync offline data\n+  /// - Parameters:\n+  ///   - method: Instance of `Method`\n+  ///   - params:  Request Params\n+  ///   - headers: Request headers\n+  ///   - delegate: Class object to receive response\n+  func syncOfflineSavedData(\n+    method: Method, params: [String: Any]?, headers: [String: String]?,\n+    delegate: NMWebServiceDelegate\n+  ) {\n+\n+    self.delegate = delegate\n+    self.sendRequestWith(method: method, params: params, headers: headers)\n+  }\n+\n+  // MARK: Parsers\n+\n+  /// Handles login response\n+  /// - Parameter response: Webservice response\n+  func handleUserLoginResponse(response: [String: Any]) {\n+\n+    let user = User.currentUser\n+    user.userId = (response[kUserId] as? String)!\n+    user.verified = (response[kUserVerified] as? Bool)!\n+    user.authToken = (response[kUserAuthToken] as? String)!\n+    if let refreshToken = response[kRefreshToken] as? String {\n+      user.refreshToken = refreshToken\n+\n     }\n-    \n-    func handleGetActivityStateResponse(response: Dictionary<String, Any>){\n-        \n-        //let user = User.currentUser\n-        \n-        //activities\n-        _ = (response[kActivites]  as? Array<Dictionary<String, Any>>)!\n-//        for activity in activites {\n-//\n-//            //let participatedActivity = UserActivityStatus(detail: activity)\n-//            // user.participatedActivites.append(participatedActivity)\n-//        }\n+\n+    if let isTempPassword = response[kUserIsTempPassword] as? Bool {\n+      user.isLoginWithTempPassword = isTempPassword\n     }\n-    \n-    func handleWithdrawFromStudyResponse(response: Dictionary<String, Any>){\n+\n+    if user.verified! && !user.isLoginWithTempPassword {\n+\n+      // Set user type & save current user to DB\n+      user.userType = UserType.FDAUser\n+      DBHandler().saveCurrentUser(user: user)\n+\n+      // Updating Key & Vector\n+      let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+      appDelegate.updateKeyAndInitializationVector()\n+\n+      FDAKeychain.shared[kUserAuthTokenKeychainKey] = user.authToken\n+      FDAKeychain.shared[kUserRefreshTokenKeychainKey] = user.refreshToken\n+\n+      let ud = UserDefaults.standard\n+      ud.set(true, forKey: kPasscodeIsPending)\n+      ud.synchronize()\n+\n+      StudyFilterHandler.instance.previousAppliedFilters = []\n+\n     }\n-    \n-    func handleLogoutResponse(response: Dictionary<String, Any>)  {\n-        \n-        //TEMP\n-        let ud = UserDefaults.standard\n-        ud.removeObject(forKey: kUserAuthToken)\n-        ud.removeObject(forKey: kUserId)\n-        ud.synchronize()\n-        \n-        let appDomain = Bundle.main.bundleIdentifier!\n-        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n-        UserDefaults.standard.synchronize()\n-        \n-        //Delete from database\n-        DBHandler.deleteCurrentUser()\n-        \n-        //reset user object\n-        User.resetCurrentUser()\n-        \n-        //delete complete database\n-        DBHandler.deleteAll()\n-        \n-        //cancel all local notification\n-        LocalNotification.cancelAllLocalNotification()\n-        \n-        //reset Filters\n+\n+  }\n+\n+  /// Handles registration response\n+  /// - Parameter response: Webservice response\n+  func handleUserRegistrationResponse(response: [String: Any]) {\n+\n+    let user = User.currentUser\n+    user.userId = (response[kUserId] as? String)!\n+    user.verified = (response[kUserVerified] as? Bool)!\n+    user.authToken = (response[kUserAuthToken] as? String)!\n+\n+    user.refreshToken = (response[kRefreshToken] as? String)!\n+    StudyFilterHandler.instance.previousAppliedFilters = []\n+\n+  }\n+\n+  /// Handles registration confirmation response\n+  /// - Parameter response: Webservice response\n+  func handleConfirmRegistrationResponse(response: [String: Any]) {\n+\n+    let user = User.currentUser\n+    if let varified = response[kUserVerified] as? Bool {\n+\n+      user.verified = varified\n+      if user.verified! {\n+\n+        user.userType = UserType.FDAUser\n+\n+        FDAKeychain.shared[kUserAuthTokenKeychainKey] = user.authToken\n+        FDAKeychain.shared[kUserRefreshTokenKeychainKey] = user.refreshToken\n+\n+        // Save Current User to DB\n+        DBHandler().saveCurrentUser(user: user)\n         StudyFilterHandler.instance.previousAppliedFilters = []\n-        StudyFilterHandler.instance.searchText = \"\"\n-        \n+      }\n     }\n-    \n-    func handleDeleteAccountResponse(response: Dictionary<String, Any>) {\n+  }\n+\n+  /// Handles email verification response\n+  /// - Parameter response: Webservice response\n+  func handleEmailVerifyResponse(response: [String: Any]) {\n+\n+    let user = User.currentUser\n+    user.verified = true\n+\n+    if user.verified! {\n+\n+      if user.authToken != nil {\n+\n+        user.userType = UserType.FDAUser\n+\n+        FDAKeychain.shared[kUserAuthTokenKeychainKey] = user.authToken\n+        FDAKeychain.shared[kUserRefreshTokenKeychainKey] = user.refreshToken\n+\n         let ud = UserDefaults.standard\n-        ud.removeObject(forKey: kUserAuthToken)\n-        ud.removeObject(forKey: kUserId)\n+        ud.set(true, forKey: kPasscodeIsPending)\n         ud.synchronize()\n-        \n-        let appDomain = Bundle.main.bundleIdentifier!\n-        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n-        UserDefaults.standard.synchronize()\n-        \n-        //Delete from database\n-        DBHandler.deleteCurrentUser()\n-        \n-        //reset user object\n-        User.resetCurrentUser()\n-        \n-        //delete complete database\n-        DBHandler.deleteAll()\n-        \n-        //cancel all local notification\n-        LocalNotification.cancelAllLocalNotification()\n-        \n-        //reset Filters\n-        StudyFilterHandler.instance.previousAppliedFilters = []\n-        StudyFilterHandler.instance.searchText = \"\"\n+\n+        DBHandler().saveCurrentUser(user: user)\n+      }\n     }\n-    \n-    func handleDeActivateAccountResponse(response: Dictionary<String, Any>) {\n-        let ud = UserDefaults.standard\n-        ud.removeObject(forKey: kUserAuthToken)\n-        ud.removeObject(forKey: kUserId)\n-        ud.synchronize()\n-        \n-        let appDomain = Bundle.main.bundleIdentifier!\n-        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n-        UserDefaults.standard.synchronize()\n-        \n-        //Delete from database\n-        DBHandler.deleteCurrentUser()\n-        \n-        //reset user object\n-        User.resetCurrentUser()\n-        \n-        //delete complete database\n-        DBHandler.deleteAll()\n-        \n-        //cancel all local notification\n-        LocalNotification.cancelAllLocalNotification()\n-        \n-        //reset Filters\n-        StudyFilterHandler.instance.previousAppliedFilters = []\n-        StudyFilterHandler.instance.searchText = \"\"\n+  }\n+\n+  /// handles `User` profile response\n+  /// - Parameter response: Webservice response\n+  func handleGetUserProfileResponse(response: [String: Any]) {\n+\n+    let user = User.currentUser\n+\n+    // settings\n+    let settings = (response[kUserSettings] as? [String: Any])!\n+    let userSettings = Settings()\n+    userSettings.setSettings(dict: settings as NSDictionary)\n+    user.settings = userSettings\n+\n+    DBHandler.saveUserSettingsToDatabase()\n+\n+    // profile\n+    let profile = (response[kUserProfile] as? [String: Any])!\n+    user.emailId = profile[kUserEmailId] as? String\n+    user.firstName = profile[kUserFirstName] as? String\n+    user.lastName = profile[kUserLastName] as? String\n+  }\n+\n+  func handleUpdateUserProfileResponse(response: [String: Any]) {\n+  }\n+\n+  func handleResendEmailConfirmationResponse(response: [String: Any]) {\n+  }\n+\n+  /// Handles change password response\n+  /// - Parameter response: Webservice response\n+  func handleChangePasswordResponse(response: [String: Any]) {\n+\n+    let user = User.currentUser\n+    if user.verified! {\n+      user.userType = UserType.FDAUser\n+      DBHandler().saveCurrentUser(user: user)\n+      let ud = UserDefaults.standard\n+      ud.set(user.userId!, forKey: kUserId)\n+      ud.synchronize()\n     }\n-    \n-    func handleUpdateTokenResponse(response: Dictionary<String, Any>){\n-        \n-        let user = User.currentUser\n-        user.authToken  = (response[kUserAuthToken] as? String)!\n-        //user.refreshToken = response[kRefreshToken] as! String\n-        //self.failedRequestServices.headerParams![kUserAuthToken] = user.accessToken\n-        \n-        DBHandler().saveCurrentUser(user: user)\n-        //re-send request which failed due to session expired\n-        \n-       // let requestParams = self.failedRequestServices.requestParams == nil ? nil : self.failedRequestServices.requestParams\n-        \n-        let headerParams = self.failedRequestServices.headerParams == nil ? [:] : self.failedRequestServices.headerParams\n-//\n-        self.sendRequestWith(method: self.failedRequestServices.method, params: (self.requestParams == nil ?  nil : self.requestParams) , headers: headerParams)\n-        \n+\n+  }\n+\n+  /// Handles `User` preference response\n+  /// - Parameter response: Webservice response\n+  func handleGetPreferenceResponse(response: [String: Any]) {\n+\n+    let user = User.currentUser\n+    if let studies = response[kStudies] as? [[String: Any]] {\n+      for study in studies {\n+        let participatedStudy = UserStudyStatus(detail: study)\n+        user.participatedStudies.append(participatedStudy)\n+      }\n     }\n-    \n-    \n-    private func sendRequestWith(method: Method, params: Dictionary<String, Any>?,headers: Dictionary<String, String>?){\n-        \n-        self.requestParams = params\n-        self.headerParams = headers\n-        self.method = method\n-        networkManager.composeRequest(RegistrationServerConfiguration.configuration,\n-                                      method: method,\n-                                      params: params as NSDictionary?,\n-                                      headers: headers as NSDictionary?,\n-                                      delegate: self)\n+\n+  }\n+\n+  /// Handles `Study` status response\n+  /// - Parameter response: Webservice response\n+  func handleGetStudyStatesResponse(response: [String: Any]) {\n+    let user = User.currentUser\n+    user.participatedStudies.removeAll()\n+    if let studies = response[kStudies] as? [[String: Any]] {\n+\n+      for study in studies {\n+        let participatedStudy = UserStudyStatus(detail: study)\n+        user.participatedStudies.append(participatedStudy)\n+      }\n     }\n-    \n-}\n-extension UserServices: NMWebServiceDelegate{\n-    func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n-        //  Logger.sharedInstance.info(\"RUS Request Called: \\(requestName)\")\n-        if delegate != nil {\n-            delegate.startedRequest(manager, requestName: requestName)\n+  }\n+\n+  /// Handles `Activity` status response\n+  /// - Parameter response: Webservice response\n+  func handleGetActivityStatesResponse(response: [String: Any]) {\n+    let user = User.currentUser\n+    if let activites = response[kActivites] as? [[String: Any]] {\n+      if Study.currentStudy != nil {\n+        for activity in activites {\n+          let participatedActivity = UserActivityStatus(\n+            detail: activity, studyId: (Study.currentStudy?.studyId)!)\n+          user.participatedActivites.append(participatedActivity)\n         }\n+      }\n     }\n-    func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n-        Logger.sharedInstance.info(\"RUS Received Data: \\(requestName), \\(String(describing: response))\")\n-        switch requestName {\n-        case RegistrationMethods.login.description as String:\n-            \n-            self.handleUserLoginResponse(response: (response as? Dictionary<String, Any>)!)\n-            \n-        case RegistrationMethods.register.description as String:\n-            \n-            self.handleUserRegistrationResponse(response: (response as? Dictionary<String, Any>)!)\n-            \n-        case RegistrationMethods.confirmRegistration.description as String:\n-            \n-            self.handleConfirmRegistrationResponse(response: (response as? Dictionary<String, Any>)!)\n-            \n-        case RegistrationMethods.verify.description as String:\n-            \n-            self.handleEmailVerifyResponse(response: (response as? Dictionary<String, Any>)!)\n-            \n-        case RegistrationMethods.userProfile.description as String:\n-            \n-            self.handleGetUserProfileResponse(response: (response as? Dictionary<String, Any>)!)\n-            \n-        case RegistrationMethods.updateUserProfile.description as String:\n-            \n-            self.handleUpdateUserProfileResponse(response: (response as? Dictionary<String, Any>)!)\n-            \n-        case RegistrationMethods.userPreferences.description as String:\n-            \n-            \n-            self.handleGetPreferenceResponse(response: (response as? Dictionary<String, Any>)!)\n-        case RegistrationMethods.changePassword.description as String:\n-            \n-            self.handleChangePasswordResponse(response: (response as? Dictionary<String, Any>)!)\n-            \n-        case RegistrationMethods.updatePreferences.description as String: break //did not handled response\n-            \n-        case RegistrationMethods.updateEligibilityConsentStatus.description as String: break\n-        case RegistrationMethods.consentPDF.description as String: break\n-        case RegistrationMethods.studyState.description as String:\n-            self.handleGetStudyStatesResponse(response:  (response as? Dictionary<String, Any>)!)\n-        case RegistrationMethods.updateStudyState.description as String: break\n-        case RegistrationMethods.updateActivityState.description as String: break\n-        case RegistrationMethods.activityState.description as String:\n-            self.handleGetActivityStatesResponse(response:  (response as? Dictionary<String, Any>)!)\n-        case RegistrationMethods.withdraw.description as String: break\n-        case RegistrationMethods.forgotPassword.description as String: break\n-            \n-        case RegistrationMethods.logout.description as String:\n-            self.handleLogoutResponse(response: (response as? Dictionary<String, Any>)!)\n-            \n-        case RegistrationMethods.deleteAccount.description as String:\n-            self.handleDeleteAccountResponse(response: (response as? Dictionary<String, Any>)!)\n-            \n-        case RegistrationMethods.deactivate.description as String:\n-            self.handleDeActivateAccountResponse(response: (response as? Dictionary<String, Any>)!)\n-        case RegistrationMethods.refreshToken.description as String:\n-            self.handleUpdateTokenResponse(response: (response as? Dictionary<String, Any>)!)\n-        default : break\n-        }\n-        \n-        if delegate != nil {\n-            delegate.finishedRequest(manager, requestName: requestName, response: response)\n-        }\n+  }\n+\n+  func handleUpdateEligibilityConsentStatusResponse(response: [String: Any]) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1616}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0ODkyMQ==", "bodyText": "please remove debug logs", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391848921", "createdAt": "2020-03-12T19:39:14Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Networking/APIs/WCPServices.swift", "diffHunk": "@@ -67,597 +62,591 @@ let kNotificationMessage = \"message\"\n let kNotificationStudyId = \"studyId\"\n let kNotificationActivityId = \"activityId\"\n \n-\n-//feedback\n+// MARK: - Feedback constants\n let kFeedbackSubject = \"subject\"\n let kFeedbackBody = \"body\"\n \n-//contactus\n+// MARK: - Contact-Us constants\n let kContactusEmail = \"email\"\n let kContactusFirstname = \"firstName\"\n \n-//studyupdates\n+// MARK: - Study updates constants\n let kStudyUpdates = \"updates\"\n let kStudyCurrentVersion = \"currentVersion\"\n let kStudyConsent = \"consent\"\n let kStudyActivities = \"activities\"\n let kStudyResources = \"resources\"\n let kStudyInfo = \"info\"\n \n-\n-//StudyWithdrawalConfigration\n+// MARK: - Study Withdrawal Configuration constants\n let kStudyWithdrawalConfigration = \"withdrawalConfig\"\n let kStudyWithdrawalMessage = \"message\"\n let kStudyWithdrawalType = \"type\"\n \n-//study AnchorDate\n-\n+// MARK: - Study AnchorDate constants\n let kStudyAnchorDate = \"anchorDate\"\n let kStudyAnchorDateType = \"type\"\n let kStudyAnchorDateActivityId = \"activityId\"\n let kStudyAnchorDateActivityVersion = \"activityVersion\"\n let kStudyAnchorDateQuestionKey = \"key\"\n let kStudyAnchorDateQuestionInfo = \"questionInfo\"\n \n+class WCPServices: NSObject {\n+  let networkManager = NetworkManager.sharedInstance()\n+  var delegate: NMWebServiceDelegate?\n+  var delegateSource: NMWebServiceDelegate?\n \n+  // MARK: Requests\n \n-class WCPServices: NSObject {\n-    let networkManager = NetworkManager.sharedInstance()\n-    var delegate: NMWebServiceDelegate! = nil\n-    var delegateSource: NMWebServiceDelegate?\n-    \n-    // MARK:Requests\n-    \n-    func checkForAppUpdates(delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        let method = WCPMethods.versionInfo.method\n-        self.sendRequestWith(method: method, params: nil, headers: nil)\n-    }\n-    \n-    func getStudyBasicInfo(_ delegate:NMWebServiceDelegate) {\n-        \n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.study.method\n-        let params:Dictionary<String, String> = [\"studyId\":Utilities.standaloneStudyId()]\n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-    }\n-    func getStudyList(_ delegate: NMWebServiceDelegate){\n-        \n-        print(\"StudyList Start \\(Date())\")\n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.studyList.method\n-        let params = Dictionary<String, Any>()\n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-    }\n-    \n-    func getConsentDocument(studyId: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let header = [kStudyId: studyId,\"consentVersion\": \"\"]\n-        let method = WCPMethods.consentDocument.method\n-        \n-        self.sendRequestWith(method: method, params: header, headers: nil)\n-    }\n-    \n-    func getGatewayResources(delegate: NMWebServiceDelegate){\n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.gatewayInfo.method\n-        let params = Dictionary<String, Any>()\n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-    }\n-    \n-    func getEligibilityConsentMetadata(studyId: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.eligibilityConsent.method\n-        let headerParams = [kStudyId: studyId]\n-        self.sendRequestWith(method: method, params: headerParams, headers: nil)\n-    }\n-    func getResourcesForStudy(studyId: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.resources.method\n-        let headerParams = [kStudyId: studyId]\n-        self.sendRequestWith(method: method, params: headerParams, headers: nil )\n-    }\n-    \n-    func getStudyInformation(studyId: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.studyInfo.method\n-        let params = [kStudyId: studyId]\n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-    }\n-    \n-    func getStudyActivityList(studyId: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.activityList.method\n-        let headerParams = [kStudyId: studyId]\n-        self.sendRequestWith(method: method, params: headerParams, headers: nil)\n-    }\n-    \n-    func getStudyActivityMetadata(studyId: String, activityId: String,activityVersion: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        \n-        let method = WCPMethods.activity.method\n-        let headerParams = [kStudyId: studyId,\n-                            kActivityId: activityId,\n-                            kActivityVersion: activityVersion]\n-        self.sendRequestWith(method: method, params: headerParams, headers: nil)\n-    }\n-    \n-    func getStudyDashboardInfo(studyId: String, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        let method = WCPMethods.studyDashboard.method\n-        let params = [kStudyId: studyId]\n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-    }\n-    \n-    func getTermsPolicy(studyId:String, delegate:NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.termsPolicy.method\n-        let params = [kStudyId: studyId]\n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-    }\n-    \n-    func getTermsPolicy(delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        let method = WCPMethods.termsPolicy.method\n-        self.sendRequestWith(method: method, params: nil, headers: nil)\n-    }\n-    \n-    func getNotification(skip: Int, delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        let method = WCPMethods.notifications.method\n-        let headerParams = [kNotificationSkip: \"\\(skip)\"]\n-        self.sendRequestWith(method: method, params: headerParams, headers: nil)\n-        \n-    }\n-    \n-    func sendUserFeedback(delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.feedback.method\n-        let params = [kFeedbackBody: FeedbackDetail.feedback,\n-                      kFeedbackSubject: FeedbackDetail.subject]\n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-        \n-    }\n-    \n-    func sendUserContactUsRequest(delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.contactUs.method\n-        let params = [kFeedbackBody:ContactUsFeilds.message,\n-                      kFeedbackSubject:ContactUsFeilds.subject,\n-                      kContactusEmail:ContactUsFeilds.email,\n-                      kContactusFirstname:ContactUsFeilds.firstName]\n-        self.sendRequestWith(method: method, params: params, headers: nil)\n-        \n-    }\n-    \n-    func getStudyUpdates(study: Study,delegate: NMWebServiceDelegate){\n-        self.delegate = delegate\n-        \n-        let method = WCPMethods.studyUpdates.method\n-        let headerParams = [kStudyId: study.studyId!,\n-                            kStudyVersion: study.version!]\n-        self.sendRequestWith(method: method, params: headerParams, headers: nil)\n-        \n-    }\n-    \n-    /*\n-    func checkForAppUpdates(delegate: NMWebServiceDelegate){\n-        \n-        self.delegate = delegate\n-        let method = WCPMethods.appUpdates.method\n-        let headerParams = [kAppVersion: Utilities.getAppVersion(),\n-                            kOSType: \"ios\"]\n-        self.sendRequestWith(method: method, params: headerParams, headers: nil)\n-    }\n-     */\n-    \n-    // MARK:Parsers\n-    func handleStudyBasicInfo(response: Dictionary<String, Any>){\n-        print(\"handleStudyBasicInfo\")\n-        \n-        let studies = response[kStudies] as! Array<Dictionary<String,Any>>\n-        var listOfStudies: Array<Study> = []\n-        for study in studies{\n-            let studyModelObj = Study(studyDetail: study)\n-            listOfStudies.append(studyModelObj)\n-        }\n-        Logger.sharedInstance.info(\"Studies Parsing Finished\")\n-        //assgin to Gateway\n-        Gateway.instance.studies = listOfStudies\n-        \n-        Logger.sharedInstance.info(\"Studies Saving in DB\")\n-        //save in database\n-        DBHandler().saveStudies(studies: listOfStudies)\n-    }\n-    func handleStudyList(response: Dictionary<String, Any>){\n-        \n-        print(\"StudyList Parsing Start \\(Date().timeIntervalSince1970)\")\n-        Logger.sharedInstance.info(\"Studies Parsing Start\")\n-        \n-        let studies = response[kStudies] as! Array<Dictionary<String,Any>>\n-        var listOfStudies: Array<Study> = []\n-        for study in studies{\n-            let studyModelObj = Study(studyDetail: study)\n-            listOfStudies.append(studyModelObj)\n-        }\n-        Logger.sharedInstance.info(\"Studies Parsing Finished\")\n-        //assgin to Gateway\n-        Gateway.instance.studies = listOfStudies\n-        \n-        Logger.sharedInstance.info(\"Studies Saving in DB\")\n-        //save in database\n-        DBHandler().saveStudies(studies: listOfStudies)\n-        print(\"StudyList Parsing Finished \\(Date().timeIntervalSince1970)\")\n-    }\n-    \n-    func handleEligibilityConsentMetaData(response: Dictionary<String, Any>){\n-        let consent = response[kConsent] as! Dictionary<String, Any>\n-        let eligibility = response[kEligibility] as! Dictionary<String, Any>\n-        \n-        if Utilities.isValidObject(someObject: consent as AnyObject?){\n-            ConsentBuilder.currentConsent = ConsentBuilder()\n-            ConsentBuilder.currentConsent?.initWithMetaData(metaDataDict: consent)\n-        }\n-        \n-        if Utilities.isValidObject(someObject: eligibility as AnyObject?){\n-            EligibilityBuilder.currentEligibility = EligibilityBuilder()\n-            EligibilityBuilder.currentEligibility?.initEligibilityWithDict(eligibilityDict: eligibility )\n-        }\n-        \n+  /// Creates a request for App Updates\n+  /// - Parameter delegate: Class object to receive response\n+  func checkForAppUpdates(delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.versionInfo.method\n+    self.sendRequestWith(method: method, params: nil, headers: nil)\n+  }\n+\n+  /// Creates a request to receive `Study` information\n+  /// - Parameter delegate: Class object to receive response\n+  func getStudyBasicInfo(_ delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.study.method\n+    let params: [String: String] = [\"studyId\": Utilities.standaloneStudyId()]\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+  }\n+\n+  /// Creates a request to receive collection of `Study`\n+  /// - Parameter delegate: Class object to receive response\n+  func getStudyList(_ delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.studyList.method\n+    let params = [String: Any]()\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+  }\n+\n+  /// Creates a request to receive Consent Document\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - delegate: Class object to receive response\n+  func getConsentDocument(studyId: String, delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let header = [kStudyId: studyId, \"consentVersion\": \"\"]\n+    let method = WCPMethods.consentDocument.method\n+    self.sendRequestWith(method: method, params: header, headers: nil)\n+  }\n+\n+  /// Creates a request to receive Gateway Resources\n+  /// - Parameter delegate: Class object to receive response\n+  func getGatewayResources(delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.gatewayInfo.method\n+    let params = [String: Any]()\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+  }\n+\n+  /// Creates a request to receive Eligibility Consent Metadata\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - delegate: Class object to receive response\n+  func getEligibilityConsentMetadata(studyId: String, delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.eligibilityConsent.method\n+    let headerParams = [kStudyId: studyId]\n+    self.sendRequestWith(method: method, params: headerParams, headers: nil)\n+  }\n+\n+  /// Creates a request to receive `Study` Resources\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - delegate: Class object to receive response\n+  func getResourcesForStudy(studyId: String, delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.resources.method\n+    let headerParams = [kStudyId: studyId]\n+    self.sendRequestWith(method: method, params: headerParams, headers: nil)\n+  }\n+\n+  /// Creates a request to receive `Study` information\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - delegate: Class object to receive response\n+  func getStudyInformation(studyId: String, delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.studyInfo.method\n+    let params = [kStudyId: studyId]\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+  }\n+\n+  /// Creates a request to receive collection of `Activity`\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - delegate: Class object to receive response\n+  func getStudyActivityList(studyId: String, delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.activityList.method\n+    let headerParams = [kStudyId: studyId]\n+    self.sendRequestWith(method: method, params: headerParams, headers: nil)\n+  }\n+\n+  /// Creates a request to receive `Activity` metadata\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - activityId: ID of `Activity`\n+  ///   - activityVersion: `Activity` Version\n+  ///   - delegate: Class object to receive response\n+  func getStudyActivityMetadata(\n+    studyId: String, activityId: String, activityVersion: String, delegate: NMWebServiceDelegate\n+  ) {\n+    self.delegate = delegate\n+    let method = WCPMethods.activity.method\n+    let headerParams = [\n+      kStudyId: studyId,\n+      kActivityId: activityId,\n+      kActivityVersion: activityVersion\n+    ]\n+    self.sendRequestWith(method: method, params: headerParams, headers: nil)\n+  }\n+\n+  /// Creates a request to receive `Study` dashboard information\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - delegate: Class object to receive response\n+  func getStudyDashboardInfo(studyId: String, delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.studyDashboard.method\n+    let params = [kStudyId: studyId]\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+  }\n+\n+  /// Creates a request to receive Terms and Policy Url\n+  /// - Parameters:\n+  ///   - studyId: ID of `Study`\n+  ///   - delegate: Class object to receive response\n+  func getTermsPolicy(studyId: String, delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.termsPolicy.method\n+    let params = [kStudyId: studyId]\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+  }\n+\n+  /// Creates a request to receive Terms and Policy Url\n+  /// - Parameter delegate: Class object to receive response\n+  func getTermsPolicy(delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.termsPolicy.method\n+    self.sendRequestWith(method: method, params: nil, headers: nil)\n+  }\n+\n+  /// Creates a request to receive collection of Notification\n+  /// - Parameters:\n+  ///   - skip: Notification Count\n+  ///   - delegate: Class object to receive response\n+  func getNotification(skip: Int, delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.notifications.method\n+    let headerParams = [kNotificationSkip: \"\\(skip)\"]\n+    self.sendRequestWith(method: method, params: headerParams, headers: nil)\n+  }\n+\n+  /// Creates a request to send `User` feedback\n+  /// - Parameter delegate: Class object to receive response\n+  func sendUserFeedback(delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.feedback.method\n+    let params = [\n+      kFeedbackBody: FeedbackDetail.feedback,\n+      kFeedbackSubject: FeedbackDetail.subject\n+    ]\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+\n+  }\n+\n+  /// Creates a request to send ContactUs Request\n+  /// - Parameter delegate: Class object to receive response\n+  func sendUserContactUsRequest(delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.contactUs.method\n+    let params = [\n+      kFeedbackBody: ContactUsFeilds.message,\n+      kFeedbackSubject: ContactUsFeilds.subject,\n+      kContactusEmail: ContactUsFeilds.email,\n+      kContactusFirstname: ContactUsFeilds.firstName\n+    ]\n+    self.sendRequestWith(method: method, params: params, headers: nil)\n+  }\n+\n+  /// Creates a request to receive `Study` updates\n+  /// - Parameters:\n+  ///   - study: ID of `Study`\n+  ///   - delegate: Class object to receive response\n+  func getStudyUpdates(study: Study, delegate: NMWebServiceDelegate) {\n+    self.delegate = delegate\n+    let method = WCPMethods.studyUpdates.method\n+    let headerParams = [\n+      kStudyId: study.studyId!,\n+      kStudyVersion: study.version!\n+    ]\n+    self.sendRequestWith(method: method, params: headerParams, headers: nil)\n+  }\n+\n+  // MARK: Parsers\n+\n+  /// Handles `Study` information response\n+  /// - Parameter response: Webservice response\n+  func handleStudyBasicInfo(response: [String: Any]) {\n+\n+    let studies = response[kStudies] as! [[String: Any]]\n+    var listOfStudies: [Study] = []\n+    for study in studies {\n+      let studyModelObj = Study(studyDetail: study)\n+      listOfStudies.append(studyModelObj)\n+    }\n+    // assgin to Gateway\n+    Gateway.instance.studies = listOfStudies\n+\n+    // save in database\n+    DBHandler().saveStudies(studies: listOfStudies)\n+  }\n+\n+  /// Handles `Study` list response\n+  /// - Parameter response: Webservice response\n+  func handleStudyList(response: [String: Any]) {\n+\n+    let studies = response[kStudies] as! [[String: Any]]\n+    var listOfStudies: [Study] = []\n+    for study in studies {\n+      let studyModelObj = Study(studyDetail: study)\n+      listOfStudies.append(studyModelObj)\n+    }\n+    // assgin to Gateway\n+    Gateway.instance.studies = listOfStudies\n+    // save in database\n+    DBHandler().saveStudies(studies: listOfStudies)\n+\n+  }\n+\n+  /// Handles Consent Metadata response\n+  /// - Parameter response: Webservice response\n+  func handleEligibilityConsentMetaData(response: [String: Any]) {\n+    let consent = response[kConsent] as! [String: Any]\n+    let eligibility = response[kEligibility] as! [String: Any]\n+\n+    if Utilities.isValidObject(someObject: consent as AnyObject?) {\n+      ConsentBuilder.currentConsent = ConsentBuilder()\n+      ConsentBuilder.currentConsent?.initWithMetaData(metaDataDict: consent)\n     }\n-    \n-    \n-    func handleResourceListForGateway(response: Dictionary<String, Any>) {\n-        \n-        let resources = response[kResources] as! Array<Dictionary<String,Any>>\n-        var listOfResources: Array<Resource>! = []\n-        for resource in resources{\n-            let resourceObj = Resource(detail: resource)\n-            listOfResources.append(resourceObj)\n-        }\n-        \n-        //assgin to Gateway\n-        Gateway.instance.resources = listOfResources\n+\n+    if Utilities.isValidObject(someObject: eligibility as AnyObject?) {\n+      EligibilityBuilder.currentEligibility = EligibilityBuilder()\n+      EligibilityBuilder.currentEligibility?.initEligibilityWithDict(\n+        eligibilityDict: eligibility)\n     }\n-    \n-    func handleResourceForStudy(response: Dictionary<String, Any>){\n-        \n-        //Testing\n-//        let filePath  = Bundle.main.path(forResource: \"ResourceList\", ofType: \"json\")\n-//        let data = NSData(contentsOfFile: filePath!)\n-//\n-//        var resources:Array<Dictionary<String,Any>> = []\n-//        do {\n-//            let res = try JSONSerialization.jsonObject(with: data! as Data, options: []) as? Dictionary<String,Any>\n-//\n-//            resources = res?[kResources] as! Array<Dictionary<String,Any>>\n-//        }\n-//        catch {\n-//            print(\"json error: \\(error.localizedDescription)\")\n-//        }\n-        \n-        //Actual\n-        let resources = response[kResources] as! Array<Dictionary<String,Any>>\n-        var listOfResources: Array<Resource>! = []\n-        for resource in resources{\n-            let resourceObj = Resource()\n-            resourceObj.level = ResourceLevel.study\n-            resourceObj.setResource(dict: resource as NSDictionary)\n-            \n-            listOfResources.append(resourceObj)\n-        }\n-        \n-        \n-        //save in database\n-        DBHandler.saveResourcesForStudy(studyId: (Study.currentStudy?.studyId)!, resources: listOfResources)\n-        \n-        //assign to Gateway\n-        Study.currentStudy?.resources = listOfResources\n-        \n+\n+  }\n+\n+  /// Handles Gateway Resource List response\n+  /// - Parameter response: Webservice response\n+  func handleResourceListForGateway(response: [String: Any]) {\n+\n+    let resources = response[kResources] as! [[String: Any]]\n+    var listOfResources: [Resource]! = []\n+    for resource in resources {\n+      let resourceObj = Resource(detail: resource)\n+      listOfResources.append(resourceObj)\n     }\n-    \n-    func handleStudyDashboard(response: Dictionary<String, Any>){\n-        \n-        guard let dashboard = response[\"dashboard\"] as? Dictionary<String, Any> else { return }\n-        \n-        if Utilities.isValidObject(someObject: dashboard as AnyObject?){\n-            \n-            if Study.currentStudy != nil {\n-                \n-                //stats\n-                let statsList = dashboard[\"statistics\"] as! Array<Dictionary<String,Any>>\n-                var listOfStats: Array<DashboardStatistics>! = []\n-                for stat in statsList{\n-                    \n-                    let dashboardStat = DashboardStatistics.init(detail: stat)\n-                    listOfStats.append(dashboardStat)\n-                }\n-                \n-                StudyDashboard.instance.statistics = listOfStats\n-                //save stats in database\n-                DBHandler.saveDashBoardStatistics(studyId: (Study.currentStudy?.studyId)!, statistics: listOfStats)\n-                \n-                //charts\n-                let chartList = dashboard[\"charts\"] as! Array<Dictionary<String,Any>>\n-                var listOfCharts: Array<DashboardCharts>! = []\n-                for chart in chartList{\n-                    \n-                    let dashboardChart = DashboardCharts.init(detail: chart)\n-                    listOfCharts.append(dashboardChart)\n-                }\n-                \n-                StudyDashboard.instance.charts = listOfCharts\n-                \n-                //save charts in database\n-                DBHandler.saveDashBoardCharts(studyId: (Study.currentStudy?.studyId)!, charts: listOfCharts)\n-            }\n-        }\n+\n+    // assgin to Gateway\n+    Gateway.instance.resources = listOfResources\n+  }\n+\n+  /// Handles Study Resources response\n+  /// - Parameter response: Webservice response\n+  func handleResourceForStudy(response: [String: Any]) {\n+\n+    let resources = response[kResources] as! [[String: Any]]\n+    var listOfResources: [Resource]! = []\n+    for resource in resources {\n+      let resourceObj = Resource()\n+      resourceObj.level = ResourceLevel.study\n+      resourceObj.setResource(dict: resource as NSDictionary)\n+\n+      listOfResources.append(resourceObj)\n     }\n-    \n-    func handleConsentDocument(response: Dictionary<String, Any>){\n-        \n-        let consentDict = response[kConsent] as! Dictionary<String, Any>\n-        \n-        if Utilities.isValidObject(someObject: consentDict as AnyObject?) {\n-            \n-            Study.currentStudy?.consentDocument = ConsentDocument()\n-            Study.currentStudy?.consentDocument?.initData(consentDoucumentdict: consentDict)\n+\n+    // save in database\n+    DBHandler.saveResourcesForStudy(\n+      studyId: (Study.currentStudy?.studyId)!, resources: listOfResources)\n+\n+    // assign to Gateway\n+    Study.currentStudy?.resources = listOfResources\n+\n+  }\n+\n+  /// Handles `Study` dashboard response\n+  /// - Parameter response: Webserive response\n+  func handleStudyDashboard(response: [String: Any]) {\n+\n+    guard let dashboard = response[\"dashboard\"] as? [String: Any] else { return }\n+\n+    if Utilities.isValidObject(someObject: dashboard as AnyObject?) {\n+\n+      if Study.currentStudy != nil {\n+\n+        //stats\n+        let statsList = dashboard[\"statistics\"] as! [[String: Any]]\n+        var listOfStats: [DashboardStatistics]! = []\n+        for stat in statsList {\n+\n+          let dashboardStat = DashboardStatistics.init(detail: stat)\n+          listOfStats.append(dashboardStat)\n         }\n-        \n-    }\n-    \n-    \n-    func handleTermsAndPolicy(response: Dictionary<String, Any>){\n-        \n-        TermsAndPolicy.currentTermsAndPolicy =  TermsAndPolicy()\n-        TermsAndPolicy.currentTermsAndPolicy?.initWithDict(dict: response)\n-        \n-    }\n-    \n-    \n-    func handleStudyInfo(response: Dictionary<String, Any>){\n-        \n-        if Study.currentStudy != nil {\n-            \n-            let overviewList = response[kOverViewInfo] as! Array<Dictionary<String,Any>>\n-            var listOfOverviews: Array<OverviewSection> = []\n-            for overview in overviewList{\n-                let overviewObj = OverviewSection(detail: overview)\n-                listOfOverviews.append(overviewObj)\n-            }\n-            \n-            //create new Overview object\n-            let overview = Overview()\n-            overview.type = .study\n-            overview.sections = listOfOverviews\n-            overview.websiteLink = response[kOverViewWebsiteLink] as? String\n-            \n-            \n-            //update overview object to current study\n-            Study.currentStudy?.overview = overview\n-            \n-            //anchorDate\n-            if Utilities.isValidObject(someObject: response[kStudyAnchorDate] as AnyObject?){\n-                \n-                let studyAndhorDate = StudyAnchorDate.init(detail: response[kStudyAnchorDate] as! Dictionary<String,Any>)\n-                \n-                //update anchorDate to current study\n-                Study.currentStudy?.anchorDate = studyAndhorDate\n-                \n-                DBHandler.saveAnchorDateDetail(anchorDate: studyAndhorDate, studyId: (Study.currentStudy?.studyId)!)\n-            }\n-            \n-            //WithdrawalConfigration\n-            if Utilities.isValidObject(someObject: response[kStudyWithdrawalConfigration] as AnyObject?){\n-                \n-                let studyWithdrawalConfig = StudyWithdrawalConfigration.init(withdrawalConfigration: response[kStudyWithdrawalConfigration] as! Dictionary<String,Any>)\n-                \n-                \n-                //update anchorDate to current study\n-                Study.currentStudy?.withdrawalConfigration = studyWithdrawalConfig\n-                DBHandler.saveWithdrawalConfigration(withdrawalConfigration:studyWithdrawalConfig ,studyId: (Study.currentStudy?.studyId)!)\n-            }\n-            \n-            //save in database\n-            DBHandler.saveStudyOverview(overview: overview, studyId: (Study.currentStudy?.studyId)!)\n+\n+        StudyDashboard.instance.statistics = listOfStats\n+        // save stats in database\n+        DBHandler.saveDashBoardStatistics(\n+          studyId: (Study.currentStudy?.studyId)!, statistics: listOfStats)\n+\n+        // charts\n+        let chartList = dashboard[\"charts\"] as! [[String: Any]]\n+        var listOfCharts: [DashboardCharts]! = []\n+        for chart in chartList {\n+\n+          let dashboardChart = DashboardCharts.init(detail: chart)\n+          listOfCharts.append(dashboardChart)\n         }\n-        \n+\n+        StudyDashboard.instance.charts = listOfCharts\n+\n+        // save charts in database\n+        DBHandler.saveDashBoardCharts(\n+          studyId: (Study.currentStudy?.studyId)!, charts: listOfCharts)\n+      }\n     }\n-    \n-    func handleStudyActivityList(response: Dictionary<String, Any>){\n-        \n-        Logger.sharedInstance.info(\"Activities Parsing Start\")\n-        \n-//        //Testing\n-//        let filePath  = Bundle.main.path(forResource: \"Activitylist\", ofType: \"json\")\n-//        let data = NSData(contentsOfFile: filePath!)\n-//\n-//        var activities:Array<Dictionary<String,Any>> = []\n-//        do {\n-//            let res = try JSONSerialization.jsonObject(with: data! as Data, options: []) as? Dictionary<String,Any>\n-//\n-//            activities = res?[kActivites] as! Array<Dictionary<String, Any>>\n-//        }\n-//        catch {\n-//            print(\"json error: \\(error.localizedDescription)\")\n-//        }\n-        \n-        //Actual\n-        let activities = response[kActivites] as! Array<Dictionary<String,Any>>\n-        \n-        if Utilities.isValidObject(someObject: activities as AnyObject? ) {\n-            \n-            if Study.currentStudy != nil {\n-                var activityList: Array<Activity> = []\n-                for activityDict in activities{\n-                    \n-                    let activity = Activity.init(studyId: (Study.currentStudy?.studyId)!, infoDict: activityDict)\n-                    activityList.append(activity)\n-                }\n-                \n-                Logger.sharedInstance.info(\"Activities Parsing Finished\")\n-                //save to current study object\n-                Study.currentStudy?.activities = activityList\n-                Logger.sharedInstance.info(\"Activities Saving in DB\")\n-                //save in database\n-                DBHandler.saveActivities(activityies: (Study.currentStudy?.activities)!)\n-            }\n-        } else {\n-            Logger.sharedInstance.debug(\"activities is null:\\(activities)\")\n-        }\n-        \n+  }\n+\n+  /// Handles Consent Document response\n+  /// - Parameter response: Webserive response\n+  func handleConsentDocument(response: [String: Any]) {\n+\n+    let consentDict = response[kConsent] as! [String: Any]\n+\n+    if Utilities.isValidObject(someObject: consentDict as AnyObject?) {\n+\n+      Study.currentStudy?.consentDocument = ConsentDocument()\n+      Study.currentStudy?.consentDocument?.initData(consentDoucumentdict: consentDict)\n     }\n-    \n-    func handleGetStudyActivityMetadata(response: Dictionary<String, Any>){\n-        \n-        /*\n-        let filePath  = Bundle.main.path(forResource: \"Activity_Metadata_Other\", ofType: \"json\")\n-        let data = NSData(contentsOfFile: filePath!)\n-        \n-        var activities: [String:Any] = [:]\n-        \n-        do {\n-            let res = try JSONSerialization.jsonObject(with: data! as Data, options: []) as? Dictionary<String,Any>\n-            \n-            activities = res?[kActivity] as! [String: Any]\n-        }\n-        catch {\n-            print(\"json error: \\(error.localizedDescription)\")\n-        }\n-        */\n-       // Study.currentActivity?.setActivityMetaData(activityDict: activities)\n-        \n-        Study.currentActivity?.setActivityMetaData(activityDict: response[kActivity] as! Dictionary<String, Any>)\n-        \n-        if Utilities.isValidObject(someObject: Study.currentActivity?.steps as AnyObject?){\n-            \n-            ActivityBuilder.currentActivityBuilder = ActivityBuilder()\n-            ActivityBuilder.currentActivityBuilder.initWithActivity(activity:Study.currentActivity! )\n-        }\n-        \n-        //Save and Update activity meta data\n-        DBHandler.saveActivityMetaData(activity: Study.currentActivity!, data: response)\n-        DBHandler.updateActivityMetaData(activity: Study.currentActivity!)\n-        \n+\n+  }\n+\n+  /// Hnadles Terms and Policy response\n+  /// - Parameter response: Webservice response\n+  func handleTermsAndPolicy(response: [String: Any]) {\n+\n+    TermsAndPolicy.currentTermsAndPolicy = TermsAndPolicy()\n+    TermsAndPolicy.currentTermsAndPolicy?.initWithDict(dict: response)\n+\n+  }\n+\n+  /// Handles `Study`  information\n+  /// - Parameter response: Webservice response\n+  func handleStudyInfo(response: [String: Any]) {\n+\n+    if Study.currentStudy != nil {\n+\n+      let overviewList = response[kOverViewInfo] as! [[String: Any]]\n+      var listOfOverviews: [OverviewSection] = []\n+      for overview in overviewList {\n+        let overviewObj = OverviewSection(detail: overview)\n+        listOfOverviews.append(overviewObj)\n+      }\n+\n+      // create new Overview object\n+      let overview = Overview()\n+      overview.type = .study\n+      overview.sections = listOfOverviews\n+      overview.websiteLink = response[kOverViewWebsiteLink] as? String\n+\n+      // update overview object to current study\n+      Study.currentStudy?.overview = overview\n+\n+      // anchorDate\n+      if Utilities.isValidObject(someObject: response[kStudyAnchorDate] as AnyObject?) {\n+\n+        let studyAndhorDate = StudyAnchorDate.init(\n+          detail: response[kStudyAnchorDate] as! [String: Any])\n+\n+        // update anchorDate to current study\n+        Study.currentStudy?.anchorDate = studyAndhorDate\n+\n+        DBHandler.saveAnchorDateDetail(\n+          anchorDate: studyAndhorDate, studyId: (Study.currentStudy?.studyId)!)\n+      }\n+\n+      // WithdrawalConfigration\n+      if Utilities.isValidObject(\n+        someObject: response[kStudyWithdrawalConfigration] as AnyObject?) {\n+\n+        let studyWithdrawalConfig = StudyWithdrawalConfigration.init(\n+          withdrawalConfigration: response[kStudyWithdrawalConfigration] as! [String: Any]\n+        )\n+\n+        // update anchorDate to current study\n+        Study.currentStudy?.withdrawalConfigration = studyWithdrawalConfig\n+        DBHandler.saveWithdrawalConfigration(\n+          withdrawalConfigration: studyWithdrawalConfig,\n+          studyId: (Study.currentStudy?.studyId)!)\n+      }\n+\n+      // save in database\n+      DBHandler.saveStudyOverview(overview: overview, studyId: (Study.currentStudy?.studyId)!)\n     }\n-    \n-    func handleGetNotification(response: Dictionary<String, Any>){\n-        \n-        let notifications = response[kNotifications] as! Array<Dictionary<String,Any>>\n-        var listOfNotifications: Array<AppNotification>! = []\n-        for notification in notifications{\n-            let overviewObj = AppNotification(detail: notification)\n-            listOfNotifications.append(overviewObj)\n+\n+  }\n+\n+  /// Handles Activity List response\n+  /// - Parameter response: Webservice response\n+  func handleStudyActivityList(response: [String: Any]) {\n+\n+    // Actual\n+    let activities = response[kActivites] as! [[String: Any]]\n+\n+    if Utilities.isValidObject(someObject: activities as AnyObject?) {\n+\n+      if Study.currentStudy != nil {\n+        var activityList: [Activity] = []\n+        for activityDict in activities {\n+\n+          let activity = Activity.init(\n+            studyId: (Study.currentStudy?.studyId)!, infoDict: activityDict)\n+          activityList.append(activity)\n         }\n-        \n-        Gateway.instance.notification = listOfNotifications\n-        \n-        //save in database\n-        DBHandler().saveNotifications(notifications: listOfNotifications )\n-        \n+        // save to current study object\n+        Study.currentStudy?.activities = activityList\n+        // save in database\n+        DBHandler.saveActivities(activities: (Study.currentStudy?.activities)!)\n+      }\n+    } else {\n+      Logger.sharedInstance.debug(\"activities is null:\\(activities)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1028}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1MDEzMw==", "bodyText": "please remove", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391850133", "createdAt": "2020-03-12T19:41:46Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Networking/NetworkConstants.swift", "diffHunk": "@@ -39,78 +38,74 @@ fileprivate func > <T : Comparable>(lhs: T?, rhs: T?) -> Bool {\n   }\n }\n \n-\n-\n // MARK: WebRequestMethods\n //let kSM\n \n-\n-\n-\n-struct NetworkConnectionConstants {\n-    static let ConnectionTimeoutInterval = 30.0\n-    static let NoOfRequestRetry  = 3\n-    static let EnableRequestRetry = false\n+enum NetworkConnectionConstants {\n+  static let ConnectionTimeoutInterval = 30.0\n+  static let NoOfRequestRetry = 3\n+  static let EnableRequestRetry = false\n }\n \n-struct TrustedHosts {\n-    static let TrustedHost1 = \"\"\n-    static let TrustedHost2 = \"\"\n-    static let TrustedHost3 = \"\"\n+enum TrustedHosts {\n+  static let TrustedHost1 = \"\"\n+  static let TrustedHost2 = \"\"\n+  static let TrustedHost3 = \"\"\n }\n \n-struct HTTPHeaderKeys {\n-    static let SetCookie = \"Set-Cookie\"\n-    static let ContentType = \"Content-Type\"\n+enum HTTPHeaderKeys {\n+  static let SetCookie = \"Set-Cookie\"\n+  static let ContentType = \"Content-Type\"\n }\n \n-struct HTTPHeaderValues {\n-    static  let ContentTypeJson = \"application/json\"\n+enum HTTPHeaderValues {\n+  static let ContentTypeJson = \"application/json\"\n }\n \n-struct NetworkURLConstants {\n-    //TODO: Set the server end points\n-    \n-    static let ProductionURL = \"\"\n-    static let DevelopmentURL = \"\"\n-    \n+enum NetworkURLConstants {\n+  // Set the server end points\n+  static let ProductionURL = \"\"\n+  static let DevelopmentURL = \"\"\n }\n \n class NetworkConstants: NSObject {\n-    //TODO: Configure common parameters for requests here.\n-    class func getCommonRequestParameters()-> NSDictionary? {\n-        return nil\n-    }\n-    \n-    class func getCommonHeaderParameters() -> NSDictionary? {\n-        //let cookie = UserDefaults.standard.value(forKey: \"cookies\")\n-        let headers : NSDictionary? =  nil\n-        /*\n-        if (cookie != nil && (cookie as AnyObject).length > 0){\n-            headers = [\"cookie\" : cookie!]\n-        }\n-         */\n-        return headers\n-    }\n-    \n-    fileprivate func getTrustedHosts()-> NSArray{\n-        let array = [TrustedHosts.TrustedHost1,TrustedHosts.TrustedHost2,TrustedHosts.TrustedHost3]\n-        return array as NSArray\n-    }\n-    \n-    class func checkResponseHeaders(_ response : URLResponse)-> (NSInteger,String){\n-        let httpResponse = response as? HTTPURLResponse\n-       \n-        let headers = httpResponse!.allHeaderFields as NSDictionary\n-        let statusCode = httpResponse!.statusCode\n-        var statusMessage = \"\"\n-        \n-        if let message = headers[\"StatusMessage\"] {\n-            // now val is not nil and the Optional has been unwrapped, so use it\n-            statusMessage = message as! String\n-        }\n-        \n-        return (statusCode,statusMessage)\n+\n+  /// Configure common parameters for requests here.\n+  class func getCommonRequestParameters() -> NSDictionary? {\n+    return nil\n+  }\n+\n+  /// Retrives common header parameters of type dictionary\n+  class func getCommonHeaderParameters() -> NSDictionary? {\n+    //let cookie = UserDefaults.standard.value(forKey: \"cookies\")\n+    let headers: NSDictionary? = nil\n+    // if (cookie != nil && (cookie as AnyObject).length > 0){\n+    //            headers = [\"cookie\" : cookie!]\n+    //        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1MDE3Mg==", "bodyText": "please remove", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391850172", "createdAt": "2020-03-12T19:41:52Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Networking/NetworkConstants.swift", "diffHunk": "@@ -39,78 +38,74 @@ fileprivate func > <T : Comparable>(lhs: T?, rhs: T?) -> Bool {\n   }\n }\n \n-\n-\n // MARK: WebRequestMethods\n //let kSM\n \n-\n-\n-\n-struct NetworkConnectionConstants {\n-    static let ConnectionTimeoutInterval = 30.0\n-    static let NoOfRequestRetry  = 3\n-    static let EnableRequestRetry = false\n+enum NetworkConnectionConstants {\n+  static let ConnectionTimeoutInterval = 30.0\n+  static let NoOfRequestRetry = 3\n+  static let EnableRequestRetry = false\n }\n \n-struct TrustedHosts {\n-    static let TrustedHost1 = \"\"\n-    static let TrustedHost2 = \"\"\n-    static let TrustedHost3 = \"\"\n+enum TrustedHosts {\n+  static let TrustedHost1 = \"\"\n+  static let TrustedHost2 = \"\"\n+  static let TrustedHost3 = \"\"\n }\n \n-struct HTTPHeaderKeys {\n-    static let SetCookie = \"Set-Cookie\"\n-    static let ContentType = \"Content-Type\"\n+enum HTTPHeaderKeys {\n+  static let SetCookie = \"Set-Cookie\"\n+  static let ContentType = \"Content-Type\"\n }\n \n-struct HTTPHeaderValues {\n-    static  let ContentTypeJson = \"application/json\"\n+enum HTTPHeaderValues {\n+  static let ContentTypeJson = \"application/json\"\n }\n \n-struct NetworkURLConstants {\n-    //TODO: Set the server end points\n-    \n-    static let ProductionURL = \"\"\n-    static let DevelopmentURL = \"\"\n-    \n+enum NetworkURLConstants {\n+  // Set the server end points\n+  static let ProductionURL = \"\"\n+  static let DevelopmentURL = \"\"\n }\n \n class NetworkConstants: NSObject {\n-    //TODO: Configure common parameters for requests here.\n-    class func getCommonRequestParameters()-> NSDictionary? {\n-        return nil\n-    }\n-    \n-    class func getCommonHeaderParameters() -> NSDictionary? {\n-        //let cookie = UserDefaults.standard.value(forKey: \"cookies\")\n-        let headers : NSDictionary? =  nil\n-        /*\n-        if (cookie != nil && (cookie as AnyObject).length > 0){\n-            headers = [\"cookie\" : cookie!]\n-        }\n-         */\n-        return headers\n-    }\n-    \n-    fileprivate func getTrustedHosts()-> NSArray{\n-        let array = [TrustedHosts.TrustedHost1,TrustedHosts.TrustedHost2,TrustedHosts.TrustedHost3]\n-        return array as NSArray\n-    }\n-    \n-    class func checkResponseHeaders(_ response : URLResponse)-> (NSInteger,String){\n-        let httpResponse = response as? HTTPURLResponse\n-       \n-        let headers = httpResponse!.allHeaderFields as NSDictionary\n-        let statusCode = httpResponse!.statusCode\n-        var statusMessage = \"\"\n-        \n-        if let message = headers[\"StatusMessage\"] {\n-            // now val is not nil and the Optional has been unwrapped, so use it\n-            statusMessage = message as! String\n-        }\n-        \n-        return (statusCode,statusMessage)\n+\n+  /// Configure common parameters for requests here.\n+  class func getCommonRequestParameters() -> NSDictionary? {\n+    return nil\n+  }\n+\n+  /// Retrives common header parameters of type dictionary\n+  class func getCommonHeaderParameters() -> NSDictionary? {\n+    //let cookie = UserDefaults.standard.value(forKey: \"cookies\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1MzEzNQ==", "bodyText": "please remove these dividers", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391853135", "createdAt": "2020-03-12T19:48:10Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Extension/Cell+Extensions.swift", "diffHunk": "@@ -1,106 +1,99 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import UIKit\n \n-\n-/**\n- The `CellConfigurable` protocol is adopted by cells that want to provide an easy\n- way to obtain the `UINib` and a `reuseIdentifier`.\n- \n- This framework has a default implementation that uses the name of the class\n- for the `reuseIdentifier` and assumes the nib name is the same as the\n- `reuseIdentifier`, in case your nib name is different you can either return\n- the name of your nib in the `reuseIdentifier` variable or return your nib\n- implementing the `nib` variable.\n- \n- This framework also adds conformance to the protocol to `UITableViewCell` and\n- `UICollectionViewCell`\n- */\n+/// The `CellConfigurable` protocol is adopted by cells that want to provide an easy\n+/// way to obtain the `UINib` and a `reuseIdentifier`.\n+/// \n+/// This framework has a default implementation that uses the name of the class\n+/// for the `reuseIdentifier` and assumes the nib name is the same as the\n+/// `reuseIdentifier`, in case your nib name is different you can either return\n+/// the name of your nib in the `reuseIdentifier` variable or return your nib\n+/// implementing the `nib` variable.\n+/// \n+/// This framework also adds conformance to the protocol to `UITableViewCell` and\n+/// `UICollectionViewCell`\n public protocol CellConfigurable {\n-    static var reuseIdentifier: String { get }\n-    static var nib: UINib { get }\n+  static var reuseIdentifier: String { get }\n+  static var nib: UINib { get }\n }\n \n-extension CellConfigurable where Self : UITableViewCell{\n-    public static var reuseIdentifier: String {\n-        return String(describing: self)\n-    }\n-    \n-    public static var nib: UINib {\n-        return UINib(nibName: reuseIdentifier, bundle: nil)\n-    }\n+extension CellConfigurable where Self: UITableViewCell {\n+  public static var reuseIdentifier: String {\n+    return String(describing: self)\n+  }\n+\n+  public static var nib: UINib {\n+    return UINib(nibName: reuseIdentifier, bundle: nil)\n+  }\n }\n \n-extension CellConfigurable where Self : UICollectionViewCell{\n-    public static var reuseIdentifier: String {\n-        return String(describing: self)\n-    }\n-    \n-    public static var nib: UINib {\n-        return UINib(nibName: reuseIdentifier, bundle: nil)\n-    }\n+extension CellConfigurable where Self: UICollectionViewCell {\n+  public static var reuseIdentifier: String {\n+    return String(describing: self)\n+  }\n+\n+  public static var nib: UINib {\n+    return UINib(nibName: reuseIdentifier, bundle: nil)\n+  }\n }\n \n extension UITableViewCell: CellConfigurable {}\n extension UICollectionViewCell: CellConfigurable {}\n \n-/*========================================================*/\n+// ========================================================", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1MzQxOQ==", "bodyText": "why was this file deleted", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r391853419", "createdAt": "2020-03-12T19:48:46Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Extension/NavigationBackButton.swift", "diffHunk": "@@ -1,70 +0,0 @@\n-/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIzMDQ0MQ==", "bodyText": "please use the correct copyright header", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392230441", "createdAt": "2020-03-13T13:35:21Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Extension/UIApplication+Extensions.swift", "diffHunk": "@@ -6,26 +7,29 @@\n //  Copyright \u00a9 2015 Yuji Hato. All rights reserved.\n //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIzMDk4NA==", "bodyText": "nit: please remove empty line", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392230984", "createdAt": "2020-03-13T13:36:15Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Helpers/AnchorDateHandler.swift", "diffHunk": "@@ -1,245 +1,239 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import UIKit\n \n class EmptyAnchordDates {\n-    \n-    enum FetchAnchorDateFor {\n-        case activity\n-        case resource\n-    }\n-    \n-    var activity:DBActivity!\n-    var resource:DBResources!\n-    var sourceKey:String!\n-    var sourceActivityId:String!\n-    var sourceFormKey:String?\n-    var anchorDate:Date?\n-    var sourceFormId:String!\n-    var isFinishedFetching:Bool = false\n-    var fetchAnchorDateFor:FetchAnchorDateFor = .activity\n-    \n-    init() {\n-        \n-    }\n-    \n+\n+  enum FetchAnchorDateFor {\n+    case activity\n+    case resource\n+  }\n+\n+  var activity: DBActivity!\n+  var resource: DBResources!\n+  var sourceKey: String!\n+  var sourceActivityId: String!\n+  var sourceFormKey: String?\n+  var anchorDate: Date?\n+  var sourceFormId: String!\n+  var isFinishedFetching: Bool = false\n+  var fetchAnchorDateFor: FetchAnchorDateFor = .activity\n+\n+  init() {\n+\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIzNjI5MQ==", "bodyText": "use logger", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392236291", "createdAt": "2020-03-13T13:45:55Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Helpers/DownloadManager/AKUtility.swift", "diffHunk": "@@ -1,125 +1,135 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// Copyright (c) 2016, Arpad Goretity https://github.com/H2CO3/HCDownload.git\n+// Copyright (c) 2016, Muhammad Zeeshan https://github.com/mzeeshanid/MZDownloadManager.git\n+// All rights reserved.\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import UIKit\n \n open class AKUtility: NSObject {\n-    \n-    public static let DownloadCompletedNotif: String = {\n-        return \"com.MZDownloadManager.DownloadCompletedNotif\"\n-    }()\n-    \n-    public static let baseFilePath: String = {\n-        return (NSHomeDirectory() as NSString).appendingPathComponent(\"Documents\") as String\n-    }()\n-\n-    open class func getUniqueFileNameWithPath(_ filePath : NSString) -> NSString {\n-        let fullFileName: NSString = filePath.lastPathComponent as NSString\n-        let fileName: NSString = fullFileName.deletingPathExtension as NSString\n-        let fileExtension: NSString = fullFileName.pathExtension as NSString\n-        var suggestedFileName: NSString = fileName\n-        \n-        var isUnique: Bool = false\n-        var fileNumber: Int = 0\n-        \n-        let fileManger: FileManager = FileManager.default\n-        \n-        repeat {\n-            var fileDocDirectoryPath: NSString?\n-            \n-            if fileExtension.length > 0 {\n-                fileDocDirectoryPath = \"\\(filePath.deletingLastPathComponent)/\\(suggestedFileName).\\(fileExtension)\" as NSString?\n-            } else {\n-                fileDocDirectoryPath = \"\\(filePath.deletingLastPathComponent)/\\(suggestedFileName)\" as NSString?\n-            }\n-            \n-            let isFileAlreadyExists: Bool = fileManger.fileExists(atPath: fileDocDirectoryPath! as String)\n-            \n-            if isFileAlreadyExists {\n-                fileNumber += 1\n-                suggestedFileName = \"\\(fileName)(\\(fileNumber))\" as NSString\n-            } else {\n-                isUnique = true\n-                if fileExtension.length > 0 {\n-                    suggestedFileName = \"\\(suggestedFileName).\\(fileExtension)\" as NSString\n-                }\n-            }\n-        \n-        } while isUnique == false\n-        \n-        return suggestedFileName\n-    }\n-    \n-    open class func calculateFileSizeInUnit(_ contentLength: Int64) -> Float {\n-        let dataLength: Float64 = Float64(contentLength)\n-        if dataLength >= (1024.0*1024.0*1024.0) {\n-            return Float(dataLength/(1024.0*1024.0*1024.0))\n-        } else if dataLength >= 1024.0*1024.0 {\n-            return Float(dataLength/(1024.0*1024.0))\n-        } else if dataLength >= 1024.0 {\n-            return Float(dataLength/1024.0)\n-        } else {\n-            return Float(dataLength)\n+\n+  public static let DownloadCompletedNotif: String = {\n+    return \"com.MZDownloadManager.DownloadCompletedNotif\"\n+  }()\n+\n+  public static let baseFilePath: String = {\n+    return (NSHomeDirectory() as NSString).appendingPathComponent(\"Documents\") as String\n+  }()\n+\n+  open class func getUniqueFileNameWithPath(_ filePath: NSString) -> NSString {\n+    let fullFileName: NSString = filePath.lastPathComponent as NSString\n+    let fileName: NSString = fullFileName.deletingPathExtension as NSString\n+    let fileExtension: NSString = fullFileName.pathExtension as NSString\n+    var suggestedFileName: NSString = fileName\n+\n+    var isUnique: Bool = false\n+    var fileNumber: Int = 0\n+\n+    let fileManger: FileManager = FileManager.default\n+\n+    repeat {\n+      var fileDocDirectoryPath: NSString?\n+\n+      if fileExtension.length > 0 {\n+        fileDocDirectoryPath\n+          = \"\\(filePath.deletingLastPathComponent)/\\(suggestedFileName).\\(fileExtension)\"\n+          as NSString?\n+      } else {\n+        fileDocDirectoryPath = \"\\(filePath.deletingLastPathComponent)/\\(suggestedFileName)\"\n+          as NSString?\n+      }\n+\n+      let isFileAlreadyExists: Bool = fileManger.fileExists(\n+        atPath: fileDocDirectoryPath! as String)\n+\n+      if isFileAlreadyExists {\n+        fileNumber += 1\n+        suggestedFileName = \"\\(fileName)(\\(fileNumber))\" as NSString\n+      } else {\n+        isUnique = true\n+        if fileExtension.length > 0 {\n+          suggestedFileName = \"\\(suggestedFileName).\\(fileExtension)\" as NSString\n         }\n+      }\n+\n+    } while isUnique == false\n+\n+    return suggestedFileName\n+  }\n+\n+  open class func calculateFileSizeInUnit(_ contentLength: Int64) -> Float {\n+    let dataLength: Float64 = Float64(contentLength)\n+    if dataLength >= (1024.0*1024.0*1024.0) {\n+      return Float(dataLength/(1024.0*1024.0*1024.0))\n+    } else if dataLength >= 1024.0*1024.0 {\n+      return Float(dataLength/(1024.0*1024.0))\n+    } else if dataLength >= 1024.0 {\n+      return Float(dataLength/1024.0)\n+    } else {\n+      return Float(dataLength)\n     }\n-    \n-    open class func calculateUnit(_ contentLength: Int64) -> NSString {\n-        if(contentLength >= (1024*1024*1024)) {\n-            return \"GB\"\n-        } else if contentLength >= (1024*1024) {\n-            return \"MB\"\n-        } else if contentLength >= 1024 {\n-            return \"KB\"\n-        } else {\n-            return \"Bytes\"\n-        }\n+  }\n+\n+  open class func calculateUnit(_ contentLength: Int64) -> NSString {\n+    if contentLength >= (1024*1024*1024) {\n+      return \"GB\"\n+    } else if contentLength >= (1024*1024) {\n+      return \"MB\"\n+    } else if contentLength >= 1024 {\n+      return \"KB\"\n+    } else {\n+      return \"Bytes\"\n     }\n-    \n-    open class func addSkipBackupAttributeToItemAtURL(_ docDirectoryPath: NSString) -> Bool {\n-        let url: URL = URL(fileURLWithPath: docDirectoryPath as String)\n-        let fileManager = FileManager.default\n-        if fileManager.fileExists(atPath: url.path) {\n-            \n-            do {\n-                try (url as NSURL).setResourceValue(NSNumber(value: true as Bool), forKey: URLResourceKey.isExcludedFromBackupKey)\n-                return true\n-            } catch let error as NSError {\n-                print(\"Error excluding \\(url.lastPathComponent) from backup \\(error)\")\n-                return false\n-            }\n-\n-        } else {\n-            return false\n-        }\n+  }\n+\n+  open class func addSkipBackupAttributeToItemAtURL(_ docDirectoryPath: NSString) -> Bool {\n+    let url: URL = URL(fileURLWithPath: docDirectoryPath as String)\n+    let fileManager = FileManager.default\n+    if fileManager.fileExists(atPath: url.path) {\n+\n+      do {\n+        try (url as NSURL).setResourceValue(\n+          NSNumber(value: true as Bool), forKey: URLResourceKey.isExcludedFromBackupKey)\n+        return true\n+      } catch let error as NSError {\n+        print(\"Error excluding \\(url.lastPathComponent) from backup \\(error)\")\n+        return false\n+      }\n+\n+    } else {\n+      return false\n     }\n-    \n-    open class func getFreeDiskspace() -> Int64? {\n-        let documentDirectoryPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)\n-        let systemAttributes: AnyObject?\n-        do {\n-            systemAttributes = try FileManager.default.attributesOfFileSystem(forPath: documentDirectoryPath.last!) as AnyObject?\n-            let freeSize = systemAttributes?[FileAttributeKey.systemFreeSize] as? NSNumber\n-            return freeSize?.int64Value\n-        } catch let error as NSError {\n-            print(\"Error Obtaining System Memory Info: Domain = \\(error.domain), Code = \\(error.code)\")\n-            return nil;\n-        }\n+  }\n+\n+  open class func getFreeDiskspace() -> Int64? {\n+    let documentDirectoryPath = NSSearchPathForDirectoriesInDomains(\n+      .documentDirectory, .userDomainMask, true)\n+    let systemAttributes: AnyObject?\n+    do {\n+      systemAttributes = try FileManager.default.attributesOfFileSystem(\n+        forPath: documentDirectoryPath.last!) as AnyObject?\n+      let freeSize = systemAttributes?[FileAttributeKey.systemFreeSize] as? NSNumber\n+      return freeSize?.int64Value\n+    } catch let error as NSError {\n+      print(\n+        \"Error Obtaining System Memory Info: Domain = \\(error.domain), Code = \\(error.code)\"\n+      )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIzNjkyMg==", "bodyText": "use logger and remove debug print", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392236922", "createdAt": "2020-03-13T13:46:57Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Helpers/DownloadManager/FileDownloadManager.swift", "diffHunk": "@@ -1,228 +1,213 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// Copyright (c) 2016, Arpad Goretity https://github.com/H2CO3/HCDownload.git\n+// Copyright (c) 2016, Muhammad Zeeshan https://github.com/mzeeshanid/MZDownloadManager.git\n+// All rights reserved.\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import Foundation\n import CryptoSwift\n+import Foundation\n+import UIKit\n \n-protocol FileDownloadManagerDelegates {\n-    func download(manager: FileDownloadManager,didUpdateProgress progress: Float)\n-    func download(manager: FileDownloadManager,didFinishDownloadingAtPath path: String)\n-    func download(manager: FileDownloadManager,didFailedWithError error: Error)\n+protocol FileDownloadManagerDelegates: class {\n+  func download(manager: FileDownloadManager, didUpdateProgress progress: Float)\n+  func download(manager: FileDownloadManager, didFinishDownloadingAtPath path: String)\n+  func download(manager: FileDownloadManager, didFailedWithError error: Error)\n }\n \n let kdefaultKeyForEncrytion = \"passwordpasswordpasswordpassword\"\n let kdefaultIVForEncryption = \"drowssapdrowssap\"\n \n-class FileDownloadManager: NSObject,URLSessionDelegate,URLSessionDownloadDelegate {\n-    \n-    var sessionManager: Foundation.URLSession!\n-    open var downloadingArray: [FileDownloadModel] = []\n-    var delegate: FileDownloadManagerDelegates?\n-    let taskStartedDate = Date()\n-    func downloadFile(_ fileName: String, fileURL: String, destinationPath: String){\n-        \n-        let url = URL(string: fileURL as String)!\n-        let request = URLRequest(url: url)\n-        let config = URLSessionConfiguration.default\n-        sessionManager = Foundation.URLSession.init(configuration: config, delegate: self , delegateQueue: nil)\n-        let downloadTask = sessionManager.downloadTask(with: request)\n-        \n-        downloadTask.taskDescription = [fileName, fileURL, destinationPath].joined(separator: \",\")\n-        downloadTask.resume()\n-        \n-        \n-        let downloadModel = FileDownloadModel.init(fileName: fileName, fileURL: fileURL, destinationPath: destinationPath)\n-        downloadModel.startTime = Date()\n-        downloadModel.status = TaskStatus.downloading.description()\n-        downloadModel.task = downloadTask\n-        \n-        downloadingArray.append(downloadModel)\n-    }\n+class FileDownloadManager: NSObject, URLSessionDelegate, URLSessionDownloadDelegate {\n \n+  var sessionManager: Foundation.URLSession!\n+  open var downloadingArray: [FileDownloadModel] = []\n+  weak var delegate: FileDownloadManagerDelegates?\n+  let taskStartedDate = Date()\n \n+  func downloadFile(_ fileName: String, fileURL: String, destinationPath: String) {\n \n+    let url = URL(string: fileURL as String)!\n+    let request = URLRequest(url: url)\n+    let config = URLSessionConfiguration.default\n+    sessionManager = Foundation.URLSession.init(\n+      configuration: config, delegate: self, delegateQueue: nil)\n+    let downloadTask = sessionManager.downloadTask(with: request)\n \n-//extension FileDownloadManager: URLSessionDelegate{\n+    downloadTask.taskDescription = [fileName, fileURL, destinationPath].joined(separator: \",\")\n+    downloadTask.resume()\n \n-    func urlSession(_ session: Foundation.URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {\n-        \n-        DispatchQueue.main.async(execute: { () -> Void in\n-            \n-            let receivedBytesCount = Double(downloadTask.countOfBytesReceived)\n-            let totalBytesCount = Double(downloadTask.countOfBytesExpectedToReceive)\n-            let progress = Float(receivedBytesCount / totalBytesCount)\n-            \n-            self.delegate?.download(manager: self, didUpdateProgress: progress)\n-        })\n-    }\n-    func urlSession(_ session: Foundation.URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n-        \n-        debugPrint(\"didFinishDownloadingToURL location \\(location)\")\n-        \n-        for (_, downloadModel) in downloadingArray.enumerated() {\n-            if downloadTask.isEqual(downloadModel.task) {\n-                let fileName = downloadModel.fileName as NSString\n-                let basePath = downloadModel.destinationPath == \"\" ? AKUtility.baseFilePath : downloadModel.destinationPath\n-                let destinationPath = (basePath as NSString).appendingPathComponent(fileName as String)\n-                \n-                let fileManager: FileManager = FileManager.default\n-                \n-                //If all set just move downloaded file to the destination\n-                //if fileManager.fileExists(atPath: basePath) {\n-                let fileURL = URL(fileURLWithPath: destinationPath as String)\n-                debugPrint(\"directory path = \\(destinationPath)\")\n-                \n-                do {\n-                    try fileManager.moveItem(at: location, to: fileURL)\n-                    \n-                    // encryt the data present at filepath fileURL\n-                    \n-                    FileDownloadManager.encyptFile(pathURL: fileURL)\n-                    \n-                    self.delegate?.download(manager: self, didFinishDownloadingAtPath: fileName as String)\n-                } catch let error as NSError {\n-                    debugPrint(\"Error while moving downloaded file to destination path:\\(error)\")\n-                    DispatchQueue.main.async(execute: { () -> Void in\n-                        self.delegate?.download(manager: self, didFailedWithError: error)\n-                    })\n-                }\n-                \n-                break\n-            }\n+    let downloadModel = FileDownloadModel.init(\n+      fileName: fileName, fileURL: fileURL, destinationPath: destinationPath)\n+    downloadModel.startTime = Date()\n+    downloadModel.status = TaskStatus.downloading.description()\n+    downloadModel.task = downloadTask\n+\n+    downloadingArray.append(downloadModel)\n+  }\n+\n+  func urlSession(\n+    _ session: Foundation.URLSession, downloadTask: URLSessionDownloadTask,\n+    didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64\n+  ) {\n+\n+    DispatchQueue.main.async(\n+      execute: { () -> Void in\n+\n+        let receivedBytesCount = Double(downloadTask.countOfBytesReceived)\n+        let totalBytesCount = Double(downloadTask.countOfBytesExpectedToReceive)\n+        let progress = Float(receivedBytesCount / totalBytesCount)\n+\n+        self.delegate?.download(manager: self, didUpdateProgress: progress)\n+      })\n+  }\n+\n+  func urlSession(\n+    _ session: Foundation.URLSession, downloadTask: URLSessionDownloadTask,\n+    didFinishDownloadingTo location: URL\n+  ) {\n+\n+    debugPrint(\"didFinishDownloadingToURL location \\(location)\")\n+\n+    for (_, downloadModel) in downloadingArray.enumerated() {\n+      if downloadTask.isEqual(downloadModel.task) {\n+        let fileName = downloadModel.fileName as NSString\n+        let basePath = downloadModel.destinationPath == \"\"\n+          ? AKUtility.baseFilePath : downloadModel.destinationPath\n+        let destinationPath = (basePath as NSString).appendingPathComponent(\n+          fileName as String)\n+\n+        let fileManager: FileManager = FileManager.default\n+\n+        // If all set just move downloaded file to the destination\n+        // if fileManager.fileExists(atPath: basePath) {\n+        let fileURL = URL(fileURLWithPath: destinationPath as String)\n+        debugPrint(\"directory path = \\(destinationPath)\")\n+\n+        do {\n+          try fileManager.moveItem(at: location, to: fileURL)\n+\n+          // encryt the data present at filepath fileURL\n+          FileDownloadManager.encyptFile(pathURL: fileURL)\n+\n+          self.delegate?.download(\n+            manager: self, didFinishDownloadingAtPath: fileName as String)\n+        } catch let error as NSError {\n+          debugPrint(\"Error while moving downloaded file to destination path:\\(error)\")\n+          DispatchQueue.main.async(\n+            execute: { () -> Void in\n+              self.delegate?.download(manager: self, didFailedWithError: error)\n+            })\n         }\n+\n+        break\n+      }\n     }\n-    func URLSession(_ session: Foundation.URLSession, task: URLSessionTask, didCompleteWithError error: NSError?) {\n-       // debugPrint(\"task id: \\(task.taskIdentifier)\")\n-       // debugPrint(\"Completed with error \\(error?.localizedDescription)\")\n-        if error != nil {\n-            self.delegate?.download(manager: self, didFailedWithError: error!)\n-        }\n-        \n+  }\n+\n+  func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {\n+    if error != nil {\n+      self.delegate?.download(manager: self, didFailedWithError: error!)\n     }\n-    public func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n-    \n+  }\n+\n+  /// decrypts file at the URL specified using the  Key & IV, AES256 decryption is used\n+  class func decrytFile(pathURL: URL?) -> Data? {\n+\n+    var pathString = \"file://\" + \"\\((pathURL?.absoluteString)!)\"\n+    if (pathURL?.absoluteString.contains(\"file://\"))! {\n+      pathString = (pathURL?.absoluteString)!\n     }\n-    \n-    /**\n-     decrypts file at the URL specified using the  Key & IV, AES256 decryption is used\n-     */\n-    class func decrytFile(pathURL: URL?) -> Data?{\n-        \n-        var pathString = \"file://\" + \"\\((pathURL?.absoluteString)!)\"\n-        if (pathURL?.absoluteString.contains(\"file://\"))! {\n-            pathString = (pathURL?.absoluteString)!\n-        }\n-        \n-        if !FileManager.default.fileExists(atPath: pathString) {\n-        \n-        do{\n-            \n-            let ud = UserDefaults.standard\n-            \n-            var key = \"\"\n-            var initializationVector = \"\"\n-            \n-            if ud.value(forKey: kEncryptionKey) != nil {\n-                key = ud.value(forKey: kEncryptionKey) as! String\n-            }\n-            else{\n-                key = kdefaultKeyForEncrytion\n-            }\n-            if ud.value(forKey: kEncryptionIV) != nil {\n-                initializationVector = ud.value(forKey: kEncryptionIV) as! String\n-            }\n-            else{\n-                initializationVector = kdefaultIVForEncryption\n-            }\n-            // key = kdefaultKeyForEncrytion\n-            //initializationVector = kdefaultIVForEncryption\n-            \n-            let data = try Data.init(contentsOf: URL.init(string: pathString)!)\n-            let aes = try AES(key: key, iv: initializationVector)\n-            let deCipherText = try aes.decrypt(Array(data))\n-            let deCryptedData = Data(deCipherText)\n-            return deCryptedData\n-            \n-        }catch let error as NSError {\n-            \n-             debugPrint(\"Decrypting data failed \\(error.localizedDescription)\")\n-            print(error)\n-            \n-            return nil\n+\n+    if !FileManager.default.fileExists(atPath: pathString) {\n+\n+      do {\n+\n+        var key = \"\"\n+        var initializationVector = \"\"\n+\n+        if let ekey = FDAKeychain.shared[kEncryptionKey] {\n+          key = ekey\n+        } else {\n+          key = kdefaultKeyForEncrytion\n         }\n-           \n-        }else {\n-            return nil\n+        if let ekey = FDAKeychain.shared[kEncryptionIV] {\n+          initializationVector = ekey\n+        } else {\n+          initializationVector = kdefaultIVForEncryption\n         }\n+\n+        let data = try Data.init(contentsOf: URL.init(string: pathString)!)\n+        let aes = try AES(key: key, iv: initializationVector)\n+        let deCipherText = try aes.decrypt(Array(data))\n+        let deCryptedData = Data(deCipherText)\n+        return deCryptedData\n+\n+      } catch let error as NSError {\n+        debugPrint(\"Decrypting data failed \\(error.localizedDescription)\")\n+        print(error)\n+        return nil\n+      }\n+\n+    } else {\n+      return nil\n     }\n-    \n-/**\n-  encrypts file at the URL specified using the random generated Key & IV, AES256 encryption is used\n- */\n-   class func encyptFile(pathURL: URL?){\n-    \n+  }\n+\n+  /// encrypts file at the URL specified using the random generated Key & IV, AES256 encryption is used\n+  class func encyptFile(pathURL: URL?) {\n+\n     var pathString = \"file://\" + \"\\((pathURL?.absoluteString)!)\"\n     if (pathURL?.absoluteString.contains(\"file://\"))! {\n-        pathString = (pathURL?.absoluteString)!\n+      pathString = (pathURL?.absoluteString)!\n     }\n-        if !FileManager.default.fileExists(atPath: pathString) {\n-            \n-            do{\n-                let ud = UserDefaults.standard\n-                \n-                var key = \"\"\n-                var initializationVector = \"\"\n-                \n-                if ud.value(forKey: kEncryptionKey) != nil {\n-                    key = ud.value(forKey: kEncryptionKey) as! String\n-                }\n-                else{\n-                    key = kdefaultKeyForEncrytion\n-                }\n-                if ud.value(forKey: kEncryptionIV) != nil {\n-                     initializationVector = ud.value(forKey: kEncryptionIV) as! String\n-                }\n-                else{\n-                    initializationVector = kdefaultIVForEncryption\n-                }\n-                 //key = kdefaultKeyForEncrytion\n-                //initializationVector = kdefaultIVForEncryption\n-                let data = try Data.init(contentsOf: URL.init(string: pathString)!)\n-                let aes = try AES(key: key, iv: initializationVector) // aes128\n-                \n-                let ciphertext = try aes.encrypt(Array(data))\n-                \n-                let encryptedData =  Data(ciphertext)\n-                \n-                do{\n-                    try encryptedData.write(to: URL.init(string: pathString)!, options: Data.WritingOptions.atomic)\n-                    \n-                }catch let error as NSError{\n-                    print(error)\n-                    debugPrint(\"Writing encrypted data to path failed \\(error.localizedDescription)\")\n-                }\n-            }catch let error as NSError {\n-                print(error)\n-                debugPrint(\"Encryting data failed \\(error.localizedDescription)\")\n-            }\n+    if !FileManager.default.fileExists(atPath: pathString) {\n+\n+      do {\n+        var key = \"\"\n+        var initializationVector = \"\"\n+\n+        if let ekey = FDAKeychain.shared[kEncryptionKey] {\n+          key = ekey\n+        } else {\n+          key = kdefaultKeyForEncrytion\n+        }\n+        if let ekey = FDAKeychain.shared[kEncryptionIV] {\n+          initializationVector = ekey\n+        } else {\n+          initializationVector = kdefaultIVForEncryption\n+        }\n+        let data = try Data.init(contentsOf: URL.init(string: pathString)!)\n+        let aes = try AES(key: key, iv: initializationVector)  // aes128\n+        let ciphertext = try aes.encrypt(Array(data))\n+        let encryptedData = Data(ciphertext)\n+\n+        do {\n+          try encryptedData.write(\n+            to: URL.init(string: pathString)!, options: Data.WritingOptions.atomic)\n+        } catch let error as NSError {\n+          print(error)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIzNzAwMQ==", "bodyText": "same here", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392237001", "createdAt": "2020-03-13T13:47:05Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Helpers/DownloadManager/FileDownloadManager.swift", "diffHunk": "@@ -1,228 +1,213 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// Copyright (c) 2016, Arpad Goretity https://github.com/H2CO3/HCDownload.git\n+// Copyright (c) 2016, Muhammad Zeeshan https://github.com/mzeeshanid/MZDownloadManager.git\n+// All rights reserved.\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import UIKit\n-import Foundation\n import CryptoSwift\n+import Foundation\n+import UIKit\n \n-protocol FileDownloadManagerDelegates {\n-    func download(manager: FileDownloadManager,didUpdateProgress progress: Float)\n-    func download(manager: FileDownloadManager,didFinishDownloadingAtPath path: String)\n-    func download(manager: FileDownloadManager,didFailedWithError error: Error)\n+protocol FileDownloadManagerDelegates: class {\n+  func download(manager: FileDownloadManager, didUpdateProgress progress: Float)\n+  func download(manager: FileDownloadManager, didFinishDownloadingAtPath path: String)\n+  func download(manager: FileDownloadManager, didFailedWithError error: Error)\n }\n \n let kdefaultKeyForEncrytion = \"passwordpasswordpasswordpassword\"\n let kdefaultIVForEncryption = \"drowssapdrowssap\"\n \n-class FileDownloadManager: NSObject,URLSessionDelegate,URLSessionDownloadDelegate {\n-    \n-    var sessionManager: Foundation.URLSession!\n-    open var downloadingArray: [FileDownloadModel] = []\n-    var delegate: FileDownloadManagerDelegates?\n-    let taskStartedDate = Date()\n-    func downloadFile(_ fileName: String, fileURL: String, destinationPath: String){\n-        \n-        let url = URL(string: fileURL as String)!\n-        let request = URLRequest(url: url)\n-        let config = URLSessionConfiguration.default\n-        sessionManager = Foundation.URLSession.init(configuration: config, delegate: self , delegateQueue: nil)\n-        let downloadTask = sessionManager.downloadTask(with: request)\n-        \n-        downloadTask.taskDescription = [fileName, fileURL, destinationPath].joined(separator: \",\")\n-        downloadTask.resume()\n-        \n-        \n-        let downloadModel = FileDownloadModel.init(fileName: fileName, fileURL: fileURL, destinationPath: destinationPath)\n-        downloadModel.startTime = Date()\n-        downloadModel.status = TaskStatus.downloading.description()\n-        downloadModel.task = downloadTask\n-        \n-        downloadingArray.append(downloadModel)\n-    }\n+class FileDownloadManager: NSObject, URLSessionDelegate, URLSessionDownloadDelegate {\n \n+  var sessionManager: Foundation.URLSession!\n+  open var downloadingArray: [FileDownloadModel] = []\n+  weak var delegate: FileDownloadManagerDelegates?\n+  let taskStartedDate = Date()\n \n+  func downloadFile(_ fileName: String, fileURL: String, destinationPath: String) {\n \n+    let url = URL(string: fileURL as String)!\n+    let request = URLRequest(url: url)\n+    let config = URLSessionConfiguration.default\n+    sessionManager = Foundation.URLSession.init(\n+      configuration: config, delegate: self, delegateQueue: nil)\n+    let downloadTask = sessionManager.downloadTask(with: request)\n \n-//extension FileDownloadManager: URLSessionDelegate{\n+    downloadTask.taskDescription = [fileName, fileURL, destinationPath].joined(separator: \",\")\n+    downloadTask.resume()\n \n-    func urlSession(_ session: Foundation.URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {\n-        \n-        DispatchQueue.main.async(execute: { () -> Void in\n-            \n-            let receivedBytesCount = Double(downloadTask.countOfBytesReceived)\n-            let totalBytesCount = Double(downloadTask.countOfBytesExpectedToReceive)\n-            let progress = Float(receivedBytesCount / totalBytesCount)\n-            \n-            self.delegate?.download(manager: self, didUpdateProgress: progress)\n-        })\n-    }\n-    func urlSession(_ session: Foundation.URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n-        \n-        debugPrint(\"didFinishDownloadingToURL location \\(location)\")\n-        \n-        for (_, downloadModel) in downloadingArray.enumerated() {\n-            if downloadTask.isEqual(downloadModel.task) {\n-                let fileName = downloadModel.fileName as NSString\n-                let basePath = downloadModel.destinationPath == \"\" ? AKUtility.baseFilePath : downloadModel.destinationPath\n-                let destinationPath = (basePath as NSString).appendingPathComponent(fileName as String)\n-                \n-                let fileManager: FileManager = FileManager.default\n-                \n-                //If all set just move downloaded file to the destination\n-                //if fileManager.fileExists(atPath: basePath) {\n-                let fileURL = URL(fileURLWithPath: destinationPath as String)\n-                debugPrint(\"directory path = \\(destinationPath)\")\n-                \n-                do {\n-                    try fileManager.moveItem(at: location, to: fileURL)\n-                    \n-                    // encryt the data present at filepath fileURL\n-                    \n-                    FileDownloadManager.encyptFile(pathURL: fileURL)\n-                    \n-                    self.delegate?.download(manager: self, didFinishDownloadingAtPath: fileName as String)\n-                } catch let error as NSError {\n-                    debugPrint(\"Error while moving downloaded file to destination path:\\(error)\")\n-                    DispatchQueue.main.async(execute: { () -> Void in\n-                        self.delegate?.download(manager: self, didFailedWithError: error)\n-                    })\n-                }\n-                \n-                break\n-            }\n+    let downloadModel = FileDownloadModel.init(\n+      fileName: fileName, fileURL: fileURL, destinationPath: destinationPath)\n+    downloadModel.startTime = Date()\n+    downloadModel.status = TaskStatus.downloading.description()\n+    downloadModel.task = downloadTask\n+\n+    downloadingArray.append(downloadModel)\n+  }\n+\n+  func urlSession(\n+    _ session: Foundation.URLSession, downloadTask: URLSessionDownloadTask,\n+    didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64\n+  ) {\n+\n+    DispatchQueue.main.async(\n+      execute: { () -> Void in\n+\n+        let receivedBytesCount = Double(downloadTask.countOfBytesReceived)\n+        let totalBytesCount = Double(downloadTask.countOfBytesExpectedToReceive)\n+        let progress = Float(receivedBytesCount / totalBytesCount)\n+\n+        self.delegate?.download(manager: self, didUpdateProgress: progress)\n+      })\n+  }\n+\n+  func urlSession(\n+    _ session: Foundation.URLSession, downloadTask: URLSessionDownloadTask,\n+    didFinishDownloadingTo location: URL\n+  ) {\n+\n+    debugPrint(\"didFinishDownloadingToURL location \\(location)\")\n+\n+    for (_, downloadModel) in downloadingArray.enumerated() {\n+      if downloadTask.isEqual(downloadModel.task) {\n+        let fileName = downloadModel.fileName as NSString\n+        let basePath = downloadModel.destinationPath == \"\"\n+          ? AKUtility.baseFilePath : downloadModel.destinationPath\n+        let destinationPath = (basePath as NSString).appendingPathComponent(\n+          fileName as String)\n+\n+        let fileManager: FileManager = FileManager.default\n+\n+        // If all set just move downloaded file to the destination\n+        // if fileManager.fileExists(atPath: basePath) {\n+        let fileURL = URL(fileURLWithPath: destinationPath as String)\n+        debugPrint(\"directory path = \\(destinationPath)\")\n+\n+        do {\n+          try fileManager.moveItem(at: location, to: fileURL)\n+\n+          // encryt the data present at filepath fileURL\n+          FileDownloadManager.encyptFile(pathURL: fileURL)\n+\n+          self.delegate?.download(\n+            manager: self, didFinishDownloadingAtPath: fileName as String)\n+        } catch let error as NSError {\n+          debugPrint(\"Error while moving downloaded file to destination path:\\(error)\")\n+          DispatchQueue.main.async(\n+            execute: { () -> Void in\n+              self.delegate?.download(manager: self, didFailedWithError: error)\n+            })\n         }\n+\n+        break\n+      }\n     }\n-    func URLSession(_ session: Foundation.URLSession, task: URLSessionTask, didCompleteWithError error: NSError?) {\n-       // debugPrint(\"task id: \\(task.taskIdentifier)\")\n-       // debugPrint(\"Completed with error \\(error?.localizedDescription)\")\n-        if error != nil {\n-            self.delegate?.download(manager: self, didFailedWithError: error!)\n-        }\n-        \n+  }\n+\n+  func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {\n+    if error != nil {\n+      self.delegate?.download(manager: self, didFailedWithError: error!)\n     }\n-    public func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n-    \n+  }\n+\n+  /// decrypts file at the URL specified using the  Key & IV, AES256 decryption is used\n+  class func decrytFile(pathURL: URL?) -> Data? {\n+\n+    var pathString = \"file://\" + \"\\((pathURL?.absoluteString)!)\"\n+    if (pathURL?.absoluteString.contains(\"file://\"))! {\n+      pathString = (pathURL?.absoluteString)!\n     }\n-    \n-    /**\n-     decrypts file at the URL specified using the  Key & IV, AES256 decryption is used\n-     */\n-    class func decrytFile(pathURL: URL?) -> Data?{\n-        \n-        var pathString = \"file://\" + \"\\((pathURL?.absoluteString)!)\"\n-        if (pathURL?.absoluteString.contains(\"file://\"))! {\n-            pathString = (pathURL?.absoluteString)!\n-        }\n-        \n-        if !FileManager.default.fileExists(atPath: pathString) {\n-        \n-        do{\n-            \n-            let ud = UserDefaults.standard\n-            \n-            var key = \"\"\n-            var initializationVector = \"\"\n-            \n-            if ud.value(forKey: kEncryptionKey) != nil {\n-                key = ud.value(forKey: kEncryptionKey) as! String\n-            }\n-            else{\n-                key = kdefaultKeyForEncrytion\n-            }\n-            if ud.value(forKey: kEncryptionIV) != nil {\n-                initializationVector = ud.value(forKey: kEncryptionIV) as! String\n-            }\n-            else{\n-                initializationVector = kdefaultIVForEncryption\n-            }\n-            // key = kdefaultKeyForEncrytion\n-            //initializationVector = kdefaultIVForEncryption\n-            \n-            let data = try Data.init(contentsOf: URL.init(string: pathString)!)\n-            let aes = try AES(key: key, iv: initializationVector)\n-            let deCipherText = try aes.decrypt(Array(data))\n-            let deCryptedData = Data(deCipherText)\n-            return deCryptedData\n-            \n-        }catch let error as NSError {\n-            \n-             debugPrint(\"Decrypting data failed \\(error.localizedDescription)\")\n-            print(error)\n-            \n-            return nil\n+\n+    if !FileManager.default.fileExists(atPath: pathString) {\n+\n+      do {\n+\n+        var key = \"\"\n+        var initializationVector = \"\"\n+\n+        if let ekey = FDAKeychain.shared[kEncryptionKey] {\n+          key = ekey\n+        } else {\n+          key = kdefaultKeyForEncrytion\n         }\n-           \n-        }else {\n-            return nil\n+        if let ekey = FDAKeychain.shared[kEncryptionIV] {\n+          initializationVector = ekey\n+        } else {\n+          initializationVector = kdefaultIVForEncryption\n         }\n+\n+        let data = try Data.init(contentsOf: URL.init(string: pathString)!)\n+        let aes = try AES(key: key, iv: initializationVector)\n+        let deCipherText = try aes.decrypt(Array(data))\n+        let deCryptedData = Data(deCipherText)\n+        return deCryptedData\n+\n+      } catch let error as NSError {\n+        debugPrint(\"Decrypting data failed \\(error.localizedDescription)\")\n+        print(error)\n+        return nil\n+      }\n+\n+    } else {\n+      return nil\n     }\n-    \n-/**\n-  encrypts file at the URL specified using the random generated Key & IV, AES256 encryption is used\n- */\n-   class func encyptFile(pathURL: URL?){\n-    \n+  }\n+\n+  /// encrypts file at the URL specified using the random generated Key & IV, AES256 encryption is used\n+  class func encyptFile(pathURL: URL?) {\n+\n     var pathString = \"file://\" + \"\\((pathURL?.absoluteString)!)\"\n     if (pathURL?.absoluteString.contains(\"file://\"))! {\n-        pathString = (pathURL?.absoluteString)!\n+      pathString = (pathURL?.absoluteString)!\n     }\n-        if !FileManager.default.fileExists(atPath: pathString) {\n-            \n-            do{\n-                let ud = UserDefaults.standard\n-                \n-                var key = \"\"\n-                var initializationVector = \"\"\n-                \n-                if ud.value(forKey: kEncryptionKey) != nil {\n-                    key = ud.value(forKey: kEncryptionKey) as! String\n-                }\n-                else{\n-                    key = kdefaultKeyForEncrytion\n-                }\n-                if ud.value(forKey: kEncryptionIV) != nil {\n-                     initializationVector = ud.value(forKey: kEncryptionIV) as! String\n-                }\n-                else{\n-                    initializationVector = kdefaultIVForEncryption\n-                }\n-                 //key = kdefaultKeyForEncrytion\n-                //initializationVector = kdefaultIVForEncryption\n-                let data = try Data.init(contentsOf: URL.init(string: pathString)!)\n-                let aes = try AES(key: key, iv: initializationVector) // aes128\n-                \n-                let ciphertext = try aes.encrypt(Array(data))\n-                \n-                let encryptedData =  Data(ciphertext)\n-                \n-                do{\n-                    try encryptedData.write(to: URL.init(string: pathString)!, options: Data.WritingOptions.atomic)\n-                    \n-                }catch let error as NSError{\n-                    print(error)\n-                    debugPrint(\"Writing encrypted data to path failed \\(error.localizedDescription)\")\n-                }\n-            }catch let error as NSError {\n-                print(error)\n-                debugPrint(\"Encryting data failed \\(error.localizedDescription)\")\n-            }\n+    if !FileManager.default.fileExists(atPath: pathString) {\n+\n+      do {\n+        var key = \"\"\n+        var initializationVector = \"\"\n+\n+        if let ekey = FDAKeychain.shared[kEncryptionKey] {\n+          key = ekey\n+        } else {\n+          key = kdefaultKeyForEncrytion\n+        }\n+        if let ekey = FDAKeychain.shared[kEncryptionIV] {\n+          initializationVector = ekey\n+        } else {\n+          initializationVector = kdefaultIVForEncryption\n+        }\n+        let data = try Data.init(contentsOf: URL.init(string: pathString)!)\n+        let aes = try AES(key: key, iv: initializationVector)  // aes128\n+        let ciphertext = try aes.encrypt(Array(data))\n+        let encryptedData = Data(ciphertext)\n+\n+        do {\n+          try encryptedData.write(\n+            to: URL.init(string: pathString)!, options: Data.WritingOptions.atomic)\n+        } catch let error as NSError {\n+          print(error)\n+          debugPrint(\n+            \"Writing encrypted data to path failed \\(error.localizedDescription)\")\n         }\n+      } catch let error as NSError {\n+        print(error)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 410}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIzNzg0MA==", "bodyText": "copyright header should be on top, please remove these lines", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392237840", "createdAt": "2020-03-13T13:48:23Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Helpers/KeychainStore/KeyChain.swift", "diffHunk": "@@ -0,0 +1,90 @@\n+//\n+//  Keychain.swift\n+//  HPHC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIzODQ3Mg==", "bodyText": "Is this class part of an external library?\nif not, please add the general license", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392238472", "createdAt": "2020-03-13T13:49:28Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Helpers/Logger/Formatter.swift", "diffHunk": "@@ -8,12 +8,12 @@\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjIzODkxMw==", "bodyText": "missing copyright.", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392238913", "createdAt": "2020-03-13T13:50:13Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Helpers/Logger/Logger.swift", "diffHunk": "@@ -9,52 +9,50 @@\n import UIKit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI0MjEwNg==", "bodyText": "nit: missing space after //", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392242106", "createdAt": "2020-03-13T13:55:38Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Helpers/Managers/LocalNotification.swift", "diffHunk": "@@ -1,384 +1,370 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import UIKit\n import UserNotifications\n \n-/**\n- LocalNotification manages registration and refreshing notification for the activities and studies\n- */\n+/// LocalNotification manages registration and refreshing notification for the activities and studies\n class LocalNotification: NSObject {\n-    \n-    static var studies: Array<Study> = [] //StudyList\n-    static var notificationList: Array<AppLocalNotification> = [] //NotificationList\n-    static var handler: ((Bool) -> ()) = {_ in }\n-    class func registerLocalNotificationForJoinedStudies(completionHandler: @escaping (Bool) -> ()) {\n-        \n-        studies = (Gateway.instance.studies?.filter({$0.userParticipateState.status == UserStudyStatus.StudyStatus.inProgress && $0.status == .Active}))!\n-        \n-        handler = completionHandler\n-        LocalNotification.registerForStudy()\n-        \n-    }\n-    \n-    class func registerForStudy() {\n-        \n-        if studies.count > 0 {\n-            \n-            let study = studies.first\n-            LocalNotification.registerForStudy(study: study!) { (done) in\n-                if done {\n-                    if (studies.count) > 0 {\n-                        studies.removeFirst()\n-                        LocalNotification.registerForStudy()\n-                    }\n-                    \n-                }\n-            }\n-            \n-        } else {\n-            handler(true)\n-        }\n-    }\n-    \n-    /**\n-     registerForStudy method registers all local notification for study and returns and completion handler with bool\n-     */\n-    class func registerForStudy(study: Study,completionHandler: @escaping (Bool) -> ()) {\n-        \n-        DBHandler.loadActivityListFromDatabase(studyId: study.studyId) { (activities) in\n-            if activities.count > 0 {\n-              \n-                LocalNotification.registerAllLocalNotificationFor(activities: activities, completionHandler: {\n-                    (done,_)   in\n-                    completionHandler(true)\n-                })\n-            } else {\n-                completionHandler(true)\n-            }\n-        }\n-    }\n-    \n-    /**\n-     registerAllLocalNotificationFor registers local notification for activities based on the frequency type and availability and returns a completion handler with status and array of localNotifications\n-     */\n-    class func registerAllLocalNotificationFor(activities: Array<Activity>,completionHandler: @escaping (Bool,Array<AppLocalNotification>) -> ()) {\n-        \n-        LocalNotification.notificationList.removeAll()\n-        \n-        let date = Date()\n-        for activity in activities {\n-            \n-            var runsBeforeToday: Array<ActivityRun> = []\n-            if activity.frequencyType == Frequency.One_Time && activity.endDate == nil {\n-                //runsBeforeToday = runs\n-                runsBeforeToday = activity.activityRuns\n-                \n-            } else {\n-                \n-                runsBeforeToday = activity.activityRuns.filter({$0.endDate >= date})\n-            }\n-            \n-            for run in runsBeforeToday {\n-                \n-                switch activity.frequencyType {\n-                case .One_Time:\n-                    \n-                    if run.endDate != nil {\n-                        let date = run.endDate.addingTimeInterval(-24*3600) // 24 hours before\n-                        let message = \"The activity \" + activity.name! + \" will expire in 24 hours. Your participation is important. Please visit the study to complete it now.\"\n-                        \n-                        LocalNotification.composeRunNotification(startDate: date, endDate: run.endDate, message: message, run: run)\n-                    }\n-                    \n-                case .Daily:\n-                    if activity.frequencyRuns?.count == 1 {\n-                        \n-                        let date = run.startDate! // 24 hours before\n-                        let message = \"A new run of the daily activity \" + activity.name! + \", is now available. Your participation is important. Please visit the study to complete it now.\"\n-                        //let userInfo = [kStudyId: run.studyId,\n-                         //               kActivityId: run.activityId]\n-                        \n-                        LocalNotification.composeRunNotification(startDate: date, endDate: run.endDate, message: message, run: run)\n-                        \n-                    } else {\n-                        \n-                        let date = run.startDate! // 24 hours before\n-                        let message1 = \"A new run of the daily activity \" + activity.name!\n-                        let message2 = \", is now available and is valid until \" + LocalNotification.timeFormatter.string(from: run.endDate!)\n-                        let messgge3 = \". Your participation is important. Please visit the study to complete it now.\"\n-                        let message = message1 + message2 + messgge3\n-//                        let userInfo = [kStudyId: run.studyId,\n-//                                        kActivityId: run.activityId]\n-                        \n-                        LocalNotification.composeRunNotification(startDate: date, endDate: run.endDate, message: message, run: run)\n-                    }\n-                    \n-                case .Weekly:\n-                    \n-                    //expiry notificaiton\n-                    let date = run.endDate.addingTimeInterval(-24*3600)\n-                    let message = \"The current run of the weekly activity \" + activity.name! + \" will expire in 24 hours. Your participation is important. Please visit the study to complete it now.\"\n-//                    let userInfo = [kStudyId: run.studyId,\n-//                                    kActivityId: run.activityId]\n-                    \n-                    LocalNotification.composeRunNotification(startDate: date, endDate: run.endDate, message: message, run: run)\n-                    \n-                    //start notification\n-                    let startMessage = \"A new run of the weekly activity \" + activity.name! + \", is now available. Please visit the study to complete it now.\"\n-                    \n-                    LocalNotification.composeRunNotification(startDate: run.startDate!, endDate: run.endDate, message: startMessage, run: run)\n-                    \n-                case .Monthly:\n-                    \n-                    let date = run.endDate.addingTimeInterval(-72*3600)\n-                    let message = \"The current run of the monthly activity \" + activity.name! + \" will expire in 3 days. Your participation is important. Please visit the study to complete it now.\"\n-//                    let userInfo = [kStudyId: run.studyId,\n-//                                    kActivityId: run.activityId]\n-                    LocalNotification.composeRunNotification(startDate: date, endDate: run.endDate, message: message, run: run)\n-                    \n-                    //start notification\n-                    let startMessage = \"A new run of the monthly activity \" + activity.name! + \", is now available. Please visit the study to complete it now.\"\n-                    LocalNotification.composeRunNotification(startDate: run.startDate!, endDate: run.endDate, message: startMessage, run: run)\n-                    \n-                case .Scheduled:\n-                    \n-                    let date = run.startDate! // 24 hours before\n-                    let endDate = LocalNotification.oneTimeFormatter.string(from: run.endDate!)\n-                    let message1 = \"A new run of the scheduled activity \" + activity.name!\n-                    let message2 = \", is now available and is valid until \" + \"\\(endDate)\"\n-                    let message3 = \". Your participation is important. Please visit the study to complete it now.\"\n-                    let message = message1 + message2 + message3\n-//                    let userInfo = [kStudyId: run.studyId,\n-//                                    kActivityId: run.activityId]\n-                    \n-                    LocalNotification.composeRunNotification(startDate: date, endDate: run.endDate, message: message, run: run)\n-                }\n-            }\n+\n+  /// StudyList\n+  static var studies: [Study] = []\n+\n+  /// NotificationList\n+  static var notificationList: [AppLocalNotification] = []\n+\n+  static var handler: ((Bool) -> Void) = { _ in }\n+\n+  /// Registers local ntification for joined studies\n+  /// - Parameter completionHandler: returns bool value\n+  class func registerLocalNotificationForJoinedStudies(\n+    completionHandler: @escaping (Bool) -> Void\n+  ) {\n+\n+    studies = (\n+      Gateway.instance.studies?.filter({\n+          $0.userParticipateState.status == UserStudyStatus.StudyStatus.inProgress && $0\n+            .status\n+            == .Active\n+        })\n+    )!\n+\n+    handler = completionHandler\n+    LocalNotification.registerForStudy()\n+\n+  }\n+\n+  /// This method is used to register for study\n+  class func registerForStudy() {\n+\n+    if studies.count > 0 {\n+\n+      let study = studies.first\n+      LocalNotification.registerForStudy(study: study!) { (done) in\n+        if done {\n+          if (studies.count) > 0 {\n+            studies.removeFirst()\n+            LocalNotification.registerForStudy()\n+          }\n         }\n-        completionHandler(true,LocalNotification.notificationList)\n+      }\n+    } else {\n+      handler(true)\n     }\n-    \n-    /**\n-     composeRunNotification creates a notification for the dates & message of ActivityRun specfied and saves to the notificationList\n-     */\n-    class func composeRunNotification(startDate: Date,endDate: Date,message: String,run: ActivityRun) {\n-        \n-        _ = [kStudyId: run.studyId,\n-                        kActivityId: run.activityId] as [String: String]\n-        \n-        //create App local notification object\n-        \n-        //let randomString = Utilities.randomString(length: 5)\n-        \n-        let notification = AppLocalNotification()\n-        notification.id =  String(run.runId) + run.activityId + run.studyId\n-        notification.message = message\n-        notification.activityId = run.activityId\n-        notification.title = \"\"\n-        notification.startDate = startDate\n-        notification.endDate = endDate\n-        notification.type = AppNotification.NotificationType.Study\n-        notification.subType = AppNotification.NotificationSubType.Activity\n-        notification.audience = Audience.Limited\n-        notification.studyId =  run.studyId //(Study.currentStudy?.studyId)!\n-        \n-        LocalNotification.notificationList.append(notification)\n+  }\n+\n+  /// Registers all local notification\n+  /// - Parameter study: instance of Study\n+  /// - Parameter completionHandler: returns bool value\n+  class func registerForStudy(study: Study, completionHandler: @escaping (Bool) -> Void) {\n+\n+    DBHandler.loadActivityListFromDatabase(studyId: study.studyId) { (activities) in\n+      if activities.count > 0 {\n+\n+        LocalNotification.registerAllLocalNotificationFor(\n+          activities: activities,\n+          completionHandler: {\n+            (_, _) in\n+            completionHandler(true)\n+          })\n+      } else {\n+        completionHandler(true)\n+      }\n     }\n-    \n-    /**\n-     scheduleNotificationOn registers local notification\n-     */\n-    class func scheduleNotificationOn(date: Date,message: String,userInfo: Dictionary<String,Any> , id:String?){\n-\n-        if date > Date() {\n-            print(\"NotificationMessage\\(message) ** date \\(date.description(with: Locale.current))\" )\n-            let content = UNMutableNotificationContent()\n-            content.body = message\n-            content.userInfo = userInfo\n-            content.sound = UNNotificationSound.default\n-            content.badge = 1\n-            \n-            let timeInterval = date.timeIntervalSinceNow\n-            print(\"Time \\(timeInterval)\")\n-            let trigger = UNTimeIntervalNotificationTrigger(timeInterval: timeInterval, repeats: false)\n-            let id = id ?? Utilities.randomString(length: 10)\n-            let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)\n-            let center = UNUserNotificationCenter.current()\n-            center.add(request)\n+  }\n+\n+  /// Registesr local notification for activities based on the frequency type\n+  /// - Parameter activities: array of Activity\n+  /// - Parameter completionHandler: return status which is bool value and array of AppLocalNotifications\n+  class func registerAllLocalNotificationFor(\n+    activities: [Activity], completionHandler: @escaping (Bool, [AppLocalNotification]) -> Void\n+  ) {\n+\n+    LocalNotification.notificationList.removeAll()\n+\n+    let date = Date()\n+    for activity in activities {\n+\n+      var runsBeforeToday: [ActivityRun] = []\n+      if activity.frequencyType == Frequency.One_Time && activity.endDate == nil {\n+        runsBeforeToday = activity.activityRuns\n+      } else {\n+        runsBeforeToday = activity.activityRuns.filter({ $0.endDate >= date })\n+      }\n+\n+      for run in runsBeforeToday {\n+\n+        switch activity.frequencyType {\n \n+        case .One_Time:\n+          if run.endDate != nil {\n+            let date = run.endDate.addingTimeInterval(-24*3600)  // 24 hours before\n+            let message = \"The activity \" + activity.name!\n+              + \" will expire in 24 hours. Your participation is important. Please visit the study to complete it now.\"\n+            LocalNotification.composeRunNotification(\n+              startDate: date, endDate: run.endDate, message: message, run: run)\n+          }\n+\n+        case .Daily:\n+          if activity.frequencyRuns?.count == 1 {\n+            let date = run.startDate!  // 24 hours before\n+            let message = \"A new run of the daily activity \" + activity.name!\n+              + \", is now available. Your participation is important. Please visit the study to complete it now.\"\n+            LocalNotification.composeRunNotification(\n+              startDate: date, endDate: run.endDate, message: message, run: run)\n+          } else {\n+            let date = run.startDate!  // 24 hours before\n+            let message1 = \"A new run of the daily activity \" + activity.name!\n+            let message2 = \", is now available and is valid until \" + LocalNotification\n+              .timeFormatter.string(from: run.endDate!)\n+            let messgge3\n+              = \". Your participation is important. Please visit the study to complete it now.\"\n+            let message = message1 + message2 + messgge3\n+            LocalNotification.composeRunNotification(\n+              startDate: date, endDate: run.endDate, message: message, run: run)\n+          }\n+\n+        case .Weekly:\n+          // expiry notificaiton\n+          let date = run.endDate.addingTimeInterval(-24*3600)\n+          let message = \"The current run of the weekly activity \" + activity.name!\n+            + \" will expire in 24 hours. Your participation is important. Please visit the study to complete it now.\"\n+          LocalNotification.composeRunNotification(\n+            startDate: date, endDate: run.endDate, message: message, run: run)\n+          // start notification\n+          let startMessage = \"A new run of the weekly activity \" + activity.name!\n+            + \", is now available. Please visit the study to complete it now.\"\n+          LocalNotification.composeRunNotification(\n+            startDate: run.startDate!, endDate: run.endDate, message: startMessage,\n+            run: run)\n+\n+        case .Monthly:\n+          let date = run.endDate.addingTimeInterval(-72*3600)\n+          let message = \"The current run of the monthly activity \" + activity.name!\n+            + \" will expire in 3 days. Your participation is important. Please visit the study to complete it now.\"\n+          LocalNotification.composeRunNotification(\n+            startDate: date, endDate: run.endDate, message: message, run: run)\n+          // start notification\n+          let startMessage = \"A new run of the monthly activity \" + activity.name!\n+            + \", is now available. Please visit the study to complete it now.\"\n+          LocalNotification.composeRunNotification(\n+            startDate: run.startDate!, endDate: run.endDate, message: startMessage,\n+            run: run)\n+\n+        case .Scheduled:\n+          let date = run.startDate!  // 24 hours before\n+          let endDate = LocalNotification.oneTimeFormatter.string(from: run.endDate!)\n+          let message1 = \"A new run of the scheduled activity \" + activity.name!\n+          let message2 = \", is now available and is valid until \" + \"\\(endDate)\"\n+          let message3\n+            = \". Your participation is important. Please visit the study to complete it now.\"\n+          let message = message1 + message2 + message3\n+          LocalNotification.composeRunNotification(\n+            startDate: date, endDate: run.endDate, message: message, run: run)\n         }\n-        \n+      }\n     }\n-    \n-    /**\n-     removeLocalNotificationfor deletes the notification for studyId & activityId\n-     */\n-    class func removeLocalNotificationfor(studyId: String,activityid: String) {\n-        \n-        \n-        let notificationCenter = UNUserNotificationCenter.current()\n-        notificationCenter.getPendingNotificationRequests { (allNotificaiton) in\n-            \n-            var nIdentifers:[String] = []\n-            for notification in allNotificaiton {\n-                let userInfo = notification.content.userInfo\n-                if userInfo[kStudyId] != nil && userInfo[kActivityId] != nil {\n-                    if (userInfo[kStudyId] as! String == studyId && userInfo[kActivityId] as! String == activityid) {\n-                        nIdentifers.append(notification.identifier)\n-                    }\n-                }\n-            }\n-            notificationCenter.removePendingNotificationRequests(withIdentifiers: nIdentifers)\n-        }\n-        \n+    completionHandler(true, LocalNotification.notificationList)\n+  }\n+\n+  /// Creates a notification by using start date, end date, message and activityrun\n+  /// - Parameter startDate: instance of date\n+  /// - Parameter endDate: instance of date\n+  /// - Parameter message: message of type string\n+  /// - Parameter run: instance of ActivityRun\n+  class func composeRunNotification(\n+    startDate: Date, endDate: Date, message: String, run: ActivityRun\n+  ) {\n+\n+    _ = [\n+      kStudyId: run.studyId,\n+      kActivityId: run.activityId\n+    ] as [String: String]\n+\n+    // create App local notification object\n+    let notification = AppLocalNotification()\n+    notification.id = String(run.runId) + run.activityId + run.studyId\n+    notification.message = message\n+    notification.activityId = run.activityId\n+    notification.title = \"\"\n+    notification.startDate = startDate\n+    notification.endDate = endDate\n+    notification.type = AppNotification.NotificationType.Study\n+    notification.subType = AppNotification.NotificationSubType.Activity\n+    notification.audience = Audience.Limited\n+    notification.studyId = run.studyId  //(Study.currentStudy?.studyId)!\n+\n+    LocalNotification.notificationList.append(notification)\n+  }\n+\n+  /// Schedules a notification\n+  /// - Parameter date: instance of date\n+  /// - Parameter message: message of type string\n+  /// - Parameter userInfo: info of type Dictionary\n+  /// - Parameter id: id of type int\n+  class func scheduleNotificationOn(\n+    date: Date, message: String, userInfo: [String: Any], id: String?\n+  ) {\n+\n+    if date > Date() {\n+      let content = UNMutableNotificationContent()\n+      content.body = message\n+      content.userInfo = userInfo\n+      content.sound = UNNotificationSound.default\n+      content.badge = 1\n+\n+      let timeInterval = date.timeIntervalSinceNow\n+      let trigger = UNTimeIntervalNotificationTrigger(\n+        timeInterval: timeInterval, repeats: false)\n+      let id = id ?? Utilities.randomString(length: 10)\n+      let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)\n+      let center = UNUserNotificationCenter.current()\n+      center.add(request)\n+\n     }\n-    \n-    /**\n-     removeLocalNotificationfor deletes notification based on studyId\n-     */\n-    class func removeLocalNotificationfor(studyId: String) {\n-        \n-        let notificationCenter = UNUserNotificationCenter.current()\n-        notificationCenter.getPendingNotificationRequests { (allNotificaiton) in\n-            \n-            var nIdentifers:[String] = []\n-            for notification in allNotificaiton {\n-                let userInfo = notification.content.userInfo\n-                if userInfo[kStudyId] != nil {\n-                    if (userInfo[kStudyId] as! String == studyId) {\n-                        nIdentifers.append(notification.identifier)\n-                    }\n-                }\n-            }\n-            notificationCenter.removePendingNotificationRequests(withIdentifiers: nIdentifers)\n+\n+  }\n+\n+  /// Deletes a notification for a studyId and activityId\n+  /// - Parameter studyId: studyId of type string\n+  /// - Parameter activityid: activityId of type string\n+  class func removeLocalNotificationfor(studyId: String, activityid: String) {\n+\n+    let notificationCenter = UNUserNotificationCenter.current()\n+    notificationCenter.getPendingNotificationRequests { (allNotificaiton) in\n+\n+      var nIdentifers: [String] = []\n+      for notification in allNotificaiton {\n+        let userInfo = notification.content.userInfo\n+        if userInfo[kStudyId] != nil && userInfo[kActivityId] != nil {\n+          if\n+            userInfo[kStudyId] as! String == studyId && userInfo[kActivityId] as! String\n+              == activityid {\n+            nIdentifers.append(notification.identifier)\n+          }\n         }\n-        \n-    }\n-    \n-    /**\n-     cancelAllLocalNotification removes all local notification registered\n-     */\n-    class func cancelAllLocalNotification() {\n-        \n-        UNUserNotificationCenter.current().removeAllPendingNotificationRequests()\n-        //UIApplication.shared.cancelAllLocalNotifications()\n+      }\n+      notificationCenter.removePendingNotificationRequests(withIdentifiers: nIdentifers)\n     }\n-    \n-    \n-    class func registerReopenAppNotification() {\n-        \n-        let userInfo = [\"registerApp\": \"mystudies\",\n-                        ]\n-        //let date = Date().addingTimeInterval(60*60*24*14)\n-        let date = Date().addingTimeInterval(60)\n-        \n-        \n-        var infoDict: NSDictionary?\n-        if let path = Bundle.main.path(forResource: \"Info\", ofType: \"plist\") {\n-            infoDict = NSDictionary(contentsOfFile: path)\n+\n+  }\n+\n+  /// Removes local notification for a studyId\n+  /// - Parameter studyId: studyId of type string\n+  class func removeLocalNotificationfor(studyId: String) {\n+\n+    let notificationCenter = UNUserNotificationCenter.current()\n+    notificationCenter.getPendingNotificationRequests { (allNotificaiton) in\n+\n+      var nIdentifers: [String] = []\n+      for notification in allNotificaiton {\n+        let userInfo = notification.content.userInfo\n+        if userInfo[kStudyId] != nil {\n+          if userInfo[kStudyId] as! String == studyId {\n+            nIdentifers.append(notification.identifier)\n+          }\n         }\n-        let navTitle = infoDict![\"ProductTitleName\"] as! String\n-        \n-        let message = \"It\u2019s been a while since you visited the \\(navTitle) app. Please consider continuing your participation in any studies in which you\u2019re enrolled.\"\n-        \n-    \n-        \n-        let notification = UILocalNotification()\n-        notification.fireDate = date\n-        notification.alertBody = message\n-        notification.alertAction = \"Ok\"\n-        notification.soundName = UILocalNotificationDefaultSoundName\n-        notification.userInfo = userInfo\n-        notification.repeatInterval = NSCalendar.Unit.day\n-        UIApplication.shared.scheduleLocalNotification(notification)\n-        \n+      }\n+      notificationCenter.removePendingNotificationRequests(withIdentifiers: nIdentifers)\n     }\n-    \n-    class func removeReopenAppNotification() {\n-        \n-        let allNotificaiton = UIApplication.shared.scheduledLocalNotifications\n-        \n-        for notification in allNotificaiton! {\n-            let userInfo = notification.userInfo\n-            if userInfo?[\"registerApp\"] != nil {\n-                if (userInfo![\"registerApp\"] as! String == \"mystudies\") {\n-                    UIApplication.shared.cancelLocalNotification(notification)\n-                }\n-            }\n-        }\n+\n+  }\n+\n+  /// Cancels all local notifications\n+  class func cancelAllLocalNotification() {\n+    UNUserNotificationCenter.current().removeAllPendingNotificationRequests()\n+  }\n+\n+  /// Checked wheather notifications are anabled or not.\n+  /// - Parameter completion: A Boolean  value indication notification enable status.\n+  class func notificationsEnabled(completion: @escaping (_ status: Bool) -> Void) {\n+    let center = UNUserNotificationCenter.current()\n+    center.getNotificationSettings { (settings) in\n+      if settings.authorizationStatus == .authorized {\n+        completion(true)\n+        return\n+      }\n+      if #available(iOS 12.0, *), settings.authorizationStatus == .provisional {\n+        completion(true)\n+        return\n+      }\n+      completion(false)\n     }\n-    \n-    /**\n-     refreshAllLocalNotification cancels existing notifications and reschedules the top 50 notification from local notifications list\n-     */\n-    \n-    class func refreshAllLocalNotification() {\n-        \n-        //Fetch top 50 notifications\n-        DBHandler.getRecentLocalNotification {(localNotifications) in\n-            \n-            if localNotifications.count > 0 {\n-                //Cancel All Local Notifications\n-                LocalNotification.cancelAllLocalNotification()\n-                \n-                LocalNotification.scheduledNotificaiton()\n-                for notification in localNotifications {\n-                    \n-                    //Generate User Info\n-                    let userInfo = [kStudyId: notification.studyId!,\n-                                    kActivityId: notification.activityId!]\n-                    \n-                    //Reschedule top 50 Local Notifications\n-                    LocalNotification.scheduleNotificationOn(date: notification.startDate!, message: notification.message!, userInfo: userInfo,id: notification.id)\n-                    \n-                }\n-                LocalNotification.scheduledNotificaiton()\n-            }\n+  }\n+\n+  /// Cancels existing notifications and reschedules the top 50 notification from local notifications list\n+  class func refreshAllLocalNotification() {\n+\n+    //Fetch top 50 notifications", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 650}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI0Mjk2MQ==", "bodyText": "should this be warning or error?", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392242961", "createdAt": "2020-03-13T13:56:58Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/Helpers/StandaloneStudy.swift", "diffHunk": "@@ -1,178 +1,130 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import UIKit\n \n class StandaloneStudy: NSObject {\n-    \n-    \n-    \n-    func createStudyForStandalone() {\n-        \n-        WCPServices().getStudyBasicInfo(self)//.getStudyList(self)\n-        \n-//        let studyDetail = [\"category\":\"Drug Safety\",\n-//                           \"logo\":\"https://hphci-fdama-st-wcp-01.labkey.com/fdaResources/studylogo/STUDY_HT_06072017020809.jpeg?v=1513764405945\",\n-//                           \"settings\" :             [\n-//                            \"enrolling\" : true,\n-//                            \"platform\" : \"all\",\n-//                            \"rejoin\" : false\n-//            ],\n-//                           \"sponsorName\" : \" FDA\",\n-//                           \"status\" : \"Active\",\n-//                           \"studyId\" : \"TESTSTUDY01\",\n-//                           \"studyVersion\" : \"48.2\",\n-//                           \"tagline\" : \"A study on exposures exposures during Human Eye.\",\n-//                           \"title\" : \"Human Eye\"] as [String : Any]\n-//\n-//        let study = Study.init(studyDetail: studyDetail)\n-//        Study.updateCurrentStudy(study: study)\n-//\n-//        let studylist:Array<Study> = [study]\n-//        Gateway.instance.studies = studylist\n-//\n-//        Logger.sharedInstance.info(\"Studies Saving in DB\")\n-//        //save in database\n-//        DBHandler().saveStudies(studies: studylist)\n-//\n-//        self.fetchStudyDashboardInfo()\n-    }\n-    \n-    func setupStandaloneStudy() {\n-        if User.currentUser.authToken != nil && User.currentUser.authToken.count > 0{\n-            self.getStudyStates()\n-        }\n-        else {\n-            self.createStudyForStandalone()\n-        }\n-       \n-    }\n-    \n-    func getStudyStates() {\n-        UserServices().getStudyStates(self)\n-    }\n-    \n-    func getStudyDashboardInfo() {\n-        WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n-    }\n-    \n-    func fetchStudyDashboardInfo() {\n-        \n-    \n-        DBHandler.loadStudyOverview(studyId: (Study.currentStudy?.studyId)!) { (overview) in\n-            if overview != nil {\n-                Study.currentStudy?.overview = overview\n-                //NotificationCenter.default.post(name: NSNotification.Name(rawValue: \"StudySetupCompleted\"), object: nil)\n-                self.getStudyUpdates()\n-            }\n-            else {\n-                self.getStudyDashboardInfo()\n-            }\n-        }\n+\n+  /// Get Basic info of Study from Server.\n+  func createStudyForStandalone() {\n+    WCPServices().getStudyBasicInfo(self)\n+  }\n+\n+  ///\n+  func setupStandaloneStudy() {\n+    if User.currentUser.authToken != nil && User.currentUser.authToken.count > 0 {\n+      self.getStudyStates()\n+    } else {\n+      self.createStudyForStandalone()\n     }\n-    func getStudyUpdates(){\n-        \n-        let study = Study.currentStudy\n-        DBHandler.loadStudyDetailsToUpdate(studyId: (study?.studyId)!, completionHandler: { (success) in\n-          NotificationCenter.default.post(name: NSNotification.Name(rawValue: \"StudySetupCompleted\"), object: nil)\n-            //self.pushToStudyDashboard()\n-            //self.removeProgressIndicator()\n-            //self.checkDatabaseForStudyInfo(study: study!)\n-        })\n+\n+  }\n+\n+  func getStudyStates() {\n+    UserServices().getStudyStates(self)\n+  }\n+\n+  func getStudyDashboardInfo() {\n+    WCPServices().getStudyInformation(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+  }\n+\n+  func fetchStudyDashboardInfo() {\n+\n+    DBHandler.loadStudyOverview(studyId: (Study.currentStudy?.studyId)!) { (overview) in\n+      if overview != nil {\n+        Study.currentStudy?.overview = overview\n+        self.getStudyUpdates()\n+      } else {\n+        self.getStudyDashboardInfo()\n+      }\n     }\n-    func handleStudyListResponse(){\n-        \n-        Logger.sharedInstance.info(\"Study Response Handler\")\n-        \n-        if (Gateway.instance.studies?.count)! > 0{\n-            DBHandler.loadStudyListFromDatabase { (studies) in\n-                if studies.count > 0 {\n-                    \n-                    let standaloneStudyId = Utilities.standaloneStudyId()\n-                    let study = studies.filter({$0.studyId == standaloneStudyId})\n-                    Gateway.instance.studies = studies\n-                    Study.updateCurrentStudy(study:study.last!)\n-                    self.getStudyDashboardInfo()\n-                }\n-                else {\n-                    // no study found send controler back from here\n-                }\n-            }\n-          \n+  }\n+\n+  func getStudyUpdates() {\n+\n+    let study = Study.currentStudy\n+    DBHandler.loadStudyDetailsToUpdate(\n+      studyId: (study?.studyId)!,\n+      completionHandler: { (_) in\n+        NotificationCenter.default.post(\n+          name: NSNotification.Name(rawValue: \"StudySetupCompleted\"), object: nil)\n+      })\n+  }\n+\n+  func handleStudyListResponse() {\n+\n+    if (Gateway.instance.studies?.count)! > 0 {\n+      DBHandler.loadStudyListFromDatabase { (studies) in\n+        if studies.count > 0 {\n+\n+          let standaloneStudyId = Utilities.standaloneStudyId()\n+          let study = studies.filter({ $0.studyId == standaloneStudyId })\n+          Gateway.instance.studies = studies\n+          Study.updateCurrentStudy(study: study.last!)\n+          self.getStudyDashboardInfo()\n+        } else {\n+          // no study found send controler back from here\n         }\n-       \n+      }\n+\n     }\n+\n+  }\n }\n \n-//MARK:- Webservices Delegates\n-extension StandaloneStudy:NMWebServiceDelegate {\n-    \n-    func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n-        Logger.sharedInstance.info(\"requestname START : \\(requestName)\")\n-        \n-        //let appdelegate = UIApplication.shared.delegate as! AppDelegate\n-        //appdelegate.window?.addProgressIndicatorOnWindowFromTop()\n-        \n+// MARK: - Webservices Delegates\n+extension StandaloneStudy: NMWebServiceDelegate {\n+\n+  func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n+    Logger.sharedInstance.info(\"requestname START : \\(requestName)\")\n+  }\n+\n+  func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n+    Logger.sharedInstance.info(\n+      \"requestname FINISH: \\(requestName) : \\(String(describing: response))\")\n+\n+    if requestName as String == WCPMethods.study.rawValue {\n+      self.handleStudyListResponse()\n     }\n-    \n-    func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n-        Logger.sharedInstance.info(\"requestname FINISH: \\(requestName) : \\(String(describing:response))\")\n-        \n-        \n-        //let appdelegate = UIApplication.shared.delegate as! AppDelegate\n-        \n-        \n-        if(requestName as String == WCPMethods.study.rawValue){\n-            self.handleStudyListResponse()\n-        }\n-        \n-        if(requestName as String == WCPMethods.studyInfo.rawValue){\n-        \n-            self.fetchStudyDashboardInfo()\n-        }\n-        else if (requestName as String == RegistrationMethods.studyState.description){\n-        \n-            self.createStudyForStandalone()\n-        }\n-        \n-        \n-        \n+\n+    if requestName as String == WCPMethods.studyInfo.rawValue {\n+\n+      self.fetchStudyDashboardInfo()\n+    } else if requestName as String == RegistrationMethods.studyState.description {\n+\n+      self.createStudyForStandalone()\n     }\n-    \n-    func failedRequest(_ manager: NetworkManager, requestName: NSString, error: NSError) {\n-        Logger.sharedInstance.info(\"requestname Failed: \\(requestName)\")\n-        \n-        //--\n-        //self.removeProgressIndicator()\n-        //--\n-        let appdelegate = UIApplication.shared.delegate as! AppDelegate\n-        \n-        appdelegate.window?.removeProgressIndicatorFromWindow()\n-        \n-        if error.code == 403 { //unauthorized\n-           self.createStudyForStandalone()\n-        }\n-        else {\n-            \n-            UIUtilities.showAlertWithMessage(alertMessage: error.localizedDescription)\n-  \n-        }\n+\n+  }\n+\n+  func failedRequest(_ manager: NetworkManager, requestName: NSString, error: NSError) {\n+    Logger.sharedInstance.info(\"requestname Failed: \\(requestName)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI0MzQ1Nw==", "bodyText": "same here, should be warning or error", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392243457", "createdAt": "2020-03-13T13:57:51Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/UIUtilities.swift", "diffHunk": "@@ -1,290 +1,323 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n import UIKit\n \n-let alert = UIAlertView()\n-\n public typealias AlertAction = () -> Void\n \n class UIUtilities: NSObject {\n-    \n-    \n-    // MARK: UI changes for textField\n-    /* Initial Padding space before displaying the texts */\n-    class func paddingViewForTextField(textField: UITextField) ->Void {\n-        let paddingView =  UIView.init(frame: CGRect(x: 0, y: 0, width: 10, height: textField.frame.height))\n-        textField.leftView = paddingView\n-        textField.leftViewMode = UITextField.ViewMode.always\n-    }\n-    \n-    /* Add a border to Textfield\n-     @params:- textfield - the data which is used to show\n-     @return:- textfield - returns text field with padding space\n-     */\n-    class func addingBorderToTextField(textField:UITextField)->UITextField {\n-        //  textField.borderStyle =  UITextBorderStyle.RoundedRect\n-        textField.layer.borderWidth = 2\n-        textField.layer.borderColor = Utilities.hexStringToUIColor(\"556085\").cgColor\n-        textField.backgroundColor =  Utilities.hexStringToUIColor(\"414c6f\")\n-        \n-        return textField\n-    }\n-    \n-    /* Used to show invalid input for that particular textfield */\n-    class func getTextfieldWithInvalidInputBorder(textField: UITextField, layerBorderColor: String, backgroundColor: String) {\n-        \n-        //textField.borderStyle =  UITextBorderStyle.RoundedRect\n-        textField.layer.borderWidth = 2\n-        textField.layer.borderColor = Utilities.hexStringToUIColor(layerBorderColor).cgColor\n-        textField.backgroundColor =  Utilities.hexStringToUIColor(backgroundColor)\n-        //\"bf7266\"\n-        //\"414c6f\"\n-    }\n-    // MARK: UI effects & View Changes\n-    \n-    /* Used to remove border text field */\n-    class func removeTheBorderToTextField(textField: UITextField)->UITextField {\n-        \n-        textField.borderStyle =  UITextField.BorderStyle.none\n-        textField.layer.borderWidth = 0\n-        textField.layer.borderColor = UIColor.clear.cgColor\n-        textField.backgroundColor =  Utilities.hexStringToUIColor(\"556085\")\n-        \n-        return textField\n-        \n-    }\n-    \n-    class func segmentSeparatorColor(color: UIColor,segment: UISegmentedControl) -> UIImage {\n-        \n-        // let rect = CGRectMake(0.0, 0.0, 1.5, segment.frame.size.height)\n-        \n-        let rect =  CGRect(x: 0.0, y: 0.0, width: 1.5, height: segment.frame.size.height)\n-        UIGraphicsBeginImageContext(rect.size)\n-        let context = UIGraphicsGetCurrentContext()\n-        context!.setFillColor(color.cgColor);\n-        context!.fill(rect);\n-        let image = UIGraphicsGetImageFromCurrentImageContext();\n-        UIGraphicsEndImageContext();\n-        return image!\n-        \n-    }\n-    \n-    class func applyBlurrEffect() -> UIVisualEffectView\n-    {\n-        \n-        let blurEffect = UIBlurEffect.init(style: UIBlurEffect.Style.dark)\n-        let visualEffect = UIVisualEffectView.init(effect: blurEffect)\n-        visualEffect.tag = 100\n-        visualEffect.alpha = 1\n-        visualEffect.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n-        return visualEffect\n-    }\n-    \n-    class func applyBlurrEffectForFrequency() -> UIVisualEffectView\n-    {\n-        \n-        let blurEffect = UIBlurEffect.init(style: UIBlurEffect.Style.dark)\n-        let visualEffect = UIVisualEffectView.init(effect: blurEffect)\n-        visualEffect.tag = 500\n-        visualEffect.alpha = 1\n-        visualEffect.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n-        return visualEffect\n-    }\n-    \n-    \n-    class func removeBlurFromFrequency(fromView: UIView) {\n-        for subView in fromView.subviews{\n-            if subView.tag == 500{\n-                subView.removeFromSuperview()\n-            }\n-        }\n-    }\n-    \n-    class func removeBlur(fromView: UIView) {\n-        for subView in fromView.subviews{\n-            if subView.tag == 100{\n-                subView.removeFromSuperview()\n-            }\n-        }\n-    }\n-    \n-    /* Performs spinning action using CoreAnimation */\n-    class func addSpinAnimation(withDuration duration: CFTimeInterval)-> CABasicAnimation{\n-        let animation = CABasicAnimation(keyPath: \"transform.rotation.z\")\n-        animation.fromValue = 0\n-        animation.toValue = 360\n-        animation.duration = duration\n-        return animation\n-    }\n-    \n-    class  func getHexColors() -> NSArray {\n-        \n-        let hexColors = [\"ff9f30\",\"fdf22f\",\"b6ff14\",\"07f51c\"]\n-        return hexColors as NSArray\n-    }\n-    \n-    class  func addFadedGreenView(view: UIView) ->UIView{\n-        \n-        let greenView = UIView.init(frame: view.frame)\n-        greenView.backgroundColor = Utilities.hexStringToUIColor(\"1eebb4\")\n-        greenView.alpha = 0.5\n-        greenView.tag = 200\n-        view.addSubview(greenView)\n-        \n-        return greenView\n-    }\n-    \n-    class  func addFadedGreenViewForFrequencyAttributes(view: UIView) ->UIView{\n-        \n-        let greenView = UIView.init(frame:view.frame)\n-        greenView.backgroundColor = Utilities.hexStringToUIColor(\"1eebb4\")\n-        greenView.alpha = 0.8\n-        greenView.tag = 300\n-        view.addSubview(greenView)\n-        \n-        return greenView\n-    }\n-    \n-    class func setWhiteBorderOnView(view: UIView, borderWidth: CGFloat, cornerRadius: CGFloat){\n-        \n-        view.layer.borderWidth = borderWidth\n-        view.layer.cornerRadius = cornerRadius\n-        view.layer.borderColor = UIColor.white.cgColor\n-    }\n-    \n-    class func setRedBorderOnView(view: UIView, borderWidth: CGFloat, cornerRadius: CGFloat){\n-        \n-        view.layer.borderWidth = borderWidth\n-        view.layer.cornerRadius = cornerRadius\n-        view.layer.borderColor = Utilities.hexStringToUIColor(\"kInvalidBorderColor\").cgColor\n-    }\n-    \n-    // MARK: JSON serialization helper methods\n-    class func convertDictionaryIntoString(mutableDic: NSMutableDictionary) -> String{\n-        \n-        var jsonString: String!\n-        do{\n-            let jsonData: NSData = try JSONSerialization.data(withJSONObject: mutableDic, options: JSONSerialization.WritingOptions.prettyPrinted) as NSData\n-            jsonString = NSString(data: jsonData as Data, encoding: String.Encoding.utf8.rawValue)! as String\n-        }\n-        catch{\n-            \n-        }\n-        return jsonString\n+\n+  // MARK: UI changes for textField\n+  // Initial Padding space before displaying the texts\n+  class func paddingViewForTextField(textField: UITextField) {\n+    let paddingView = UIView.init(\n+      frame: CGRect(x: 0, y: 0, width: 10, height: textField.frame.height))\n+    textField.leftView = paddingView\n+    textField.leftViewMode = UITextField.ViewMode.always\n+  }\n+\n+  // Add a border to Textfield\n+  //     @params:- textfield - the data which is used to show\n+  //     @return:- textfield - returns text field with padding space\n+  class func addingBorderToTextField(textField: UITextField) -> UITextField {\n+    textField.layer.borderWidth = 2\n+    textField.layer.borderColor = Utilities.hexStringToUIColor(\"556085\").cgColor\n+    textField.backgroundColor = Utilities.hexStringToUIColor(\"414c6f\")\n+\n+    return textField\n+  }\n+\n+  /// Used to show invalid input for that particular textfield\n+  class func getTextfieldWithInvalidInputBorder(\n+    textField: UITextField, layerBorderColor: String, backgroundColor: String\n+  ) {\n+\n+    textField.layer.borderWidth = 2\n+    textField.layer.borderColor = Utilities.hexStringToUIColor(layerBorderColor).cgColor\n+    textField.backgroundColor = Utilities.hexStringToUIColor(backgroundColor)\n+\n+  }\n+\n+  // MARK: UI effects & View Changes\n+\n+  /// Used to remove border text field\n+  class func removeTheBorderToTextField(textField: UITextField) -> UITextField {\n+\n+    textField.borderStyle = UITextField.BorderStyle.none\n+    textField.layer.borderWidth = 0\n+    textField.layer.borderColor = UIColor.clear.cgColor\n+    textField.backgroundColor = Utilities.hexStringToUIColor(\"556085\")\n+\n+    return textField\n+\n+  }\n+\n+  class func segmentSeparatorColor(color: UIColor, segment: UISegmentedControl) -> UIImage {\n+\n+    let rect = CGRect(x: 0.0, y: 0.0, width: 1.5, height: segment.frame.size.height)\n+    UIGraphicsBeginImageContext(rect.size)\n+    let context = UIGraphicsGetCurrentContext()\n+    context!.setFillColor(color.cgColor)\n+    context!.fill(rect)\n+    let image = UIGraphicsGetImageFromCurrentImageContext()\n+    UIGraphicsEndImageContext()\n+    return image!\n+\n+  }\n+\n+  class func applyBlurrEffect() -> UIVisualEffectView {\n+\n+    let blurEffect = UIBlurEffect.init(style: UIBlurEffect.Style.dark)\n+    let visualEffect = UIVisualEffectView.init(effect: blurEffect)\n+    visualEffect.tag = 100\n+    visualEffect.alpha = 1\n+    visualEffect.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n+    return visualEffect\n+  }\n+\n+  class func applyBlurrEffectForFrequency() -> UIVisualEffectView {\n+\n+    let blurEffect = UIBlurEffect.init(style: UIBlurEffect.Style.dark)\n+    let visualEffect = UIVisualEffectView.init(effect: blurEffect)\n+    visualEffect.tag = 500\n+    visualEffect.alpha = 1\n+    visualEffect.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n+    return visualEffect\n+  }\n+\n+  class func removeBlurFromFrequency(fromView: UIView) {\n+    for subView in fromView.subviews {\n+      if subView.tag == 500 {\n+        subView.removeFromSuperview()\n+      }\n     }\n-    \n-    class func convertNSMutableArrayIntoString(mutableArray: NSMutableArray) -> String {\n-        \n-        var socialMediaNamesString: String!\n-        do{\n-            let jsonData: NSData = try JSONSerialization.data(withJSONObject: mutableArray, options: JSONSerialization.WritingOptions.prettyPrinted) as NSData\n-            socialMediaNamesString = NSString(data: jsonData as Data, encoding: String.Encoding.utf8.rawValue)! as String\n-        }\n-        catch{\n-        }\n-        return socialMediaNamesString\n+  }\n+\n+  class func removeBlur(fromView: UIView) {\n+    for subView in fromView.subviews {\n+      if subView.tag == 100 {\n+        subView.removeFromSuperview()\n+      }\n     }\n-    // MARK: Alert composers\n-    \n-    /* Presents alert message */\n-    class func showAlertWithTitleAndMessage(title: NSString, message : NSString) -> Void {\n-        \n-        let alert = UIAlertController(title: title as String,message: message as String,preferredStyle: UIAlertController.Style.alert)\n-        alert.addAction(UIAlertAction(title: NSLocalizedString(\"OK\", comment: \"\"), style: .default, handler: nil))\n-        var rootViewController = UIApplication.shared.keyWindow?.rootViewController\n-        if let navigationController = rootViewController as? UINavigationController {\n-            rootViewController = navigationController.viewControllers.first\n-        }\n-        if let tabBarController = rootViewController as? UITabBarController {\n-            rootViewController = tabBarController.selectedViewController\n-        }\n-        rootViewController?.present(alert, animated: true, completion: nil)\n-        \n+  }\n+\n+  /// Performs spinning action using CoreAnimation\n+  class func addSpinAnimation(withDuration duration: CFTimeInterval) -> CABasicAnimation {\n+    let animation = CABasicAnimation(keyPath: \"transform.rotation.z\")\n+    animation.fromValue = 0\n+    animation.toValue = 360\n+    animation.duration = duration\n+    return animation\n+  }\n+\n+  class func getHexColors() -> NSArray {\n+\n+    let hexColors = [\"ff9f30\", \"fdf22f\", \"b6ff14\", \"07f51c\"]\n+    return hexColors as NSArray\n+  }\n+\n+  class func addFadedGreenView(view: UIView) -> UIView {\n+\n+    let greenView = UIView.init(frame: view.frame)\n+    greenView.backgroundColor = Utilities.hexStringToUIColor(\"1eebb4\")\n+    greenView.alpha = 0.5\n+    greenView.tag = 200\n+    view.addSubview(greenView)\n+\n+    return greenView\n+  }\n+\n+  class func addFadedGreenViewForFrequencyAttributes(view: UIView) -> UIView {\n+\n+    let greenView = UIView.init(frame: view.frame)\n+    greenView.backgroundColor = Utilities.hexStringToUIColor(\"1eebb4\")\n+    greenView.alpha = 0.8\n+    greenView.tag = 300\n+    view.addSubview(greenView)\n+\n+    return greenView\n+  }\n+\n+  class func setWhiteBorderOnView(view: UIView, borderWidth: CGFloat, cornerRadius: CGFloat) {\n+\n+    view.layer.borderWidth = borderWidth\n+    view.layer.cornerRadius = cornerRadius\n+    view.layer.borderColor = UIColor.white.cgColor\n+  }\n+\n+  class func setRedBorderOnView(view: UIView, borderWidth: CGFloat, cornerRadius: CGFloat) {\n+\n+    view.layer.borderWidth = borderWidth\n+    view.layer.cornerRadius = cornerRadius\n+    view.layer.borderColor = Utilities.hexStringToUIColor(\"kInvalidBorderColor\").cgColor\n+  }\n+\n+  // MARK: - JSON serialization helper methods\n+\n+  class func convertDictionaryIntoString(mutableDic: NSMutableDictionary) -> String {\n+\n+    var jsonString: String!\n+    do {\n+      let jsonData: NSData = try JSONSerialization.data(\n+        withJSONObject: mutableDic, options: JSONSerialization.WritingOptions.prettyPrinted)\n+        as NSData\n+      jsonString = NSString(data: jsonData as Data, encoding: String.Encoding.utf8.rawValue)!\n+        as String\n+    } catch let error {\n+      Logger.sharedInstance.info(\"Error parsing data: \", error.localizedDescription)\n     }\n-    \n-    /* Dismiss alert message*/\n-    class func dismissAlert(){\n-        alert.dismiss(withClickedButtonIndex: 0, animated: false)\n+    return jsonString\n+  }\n+\n+  class func convertNSMutableArrayIntoString(mutableArray: NSMutableArray) -> String {\n+\n+    var socialMediaNamesString: String!\n+    do {\n+      let jsonData: NSData = try JSONSerialization.data(\n+        withJSONObject: mutableArray,\n+        options: JSONSerialization.WritingOptions.prettyPrinted)\n+        as NSData\n+      socialMediaNamesString = NSString(\n+        data: jsonData as Data, encoding: String.Encoding.utf8.rawValue)! as String\n+    } catch let error {\n+      Logger.sharedInstance.info(\"Error parsing data: \", error.localizedDescription)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 415}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI0MzY1Mw==", "bodyText": "error or warning instead of info", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392243653", "createdAt": "2020-03-13T13:58:12Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Utils/UIUtilities.swift", "diffHunk": "@@ -1,290 +1,323 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n import Foundation\n import UIKit\n \n-let alert = UIAlertView()\n-\n public typealias AlertAction = () -> Void\n \n class UIUtilities: NSObject {\n-    \n-    \n-    // MARK: UI changes for textField\n-    /* Initial Padding space before displaying the texts */\n-    class func paddingViewForTextField(textField: UITextField) ->Void {\n-        let paddingView =  UIView.init(frame: CGRect(x: 0, y: 0, width: 10, height: textField.frame.height))\n-        textField.leftView = paddingView\n-        textField.leftViewMode = UITextField.ViewMode.always\n-    }\n-    \n-    /* Add a border to Textfield\n-     @params:- textfield - the data which is used to show\n-     @return:- textfield - returns text field with padding space\n-     */\n-    class func addingBorderToTextField(textField:UITextField)->UITextField {\n-        //  textField.borderStyle =  UITextBorderStyle.RoundedRect\n-        textField.layer.borderWidth = 2\n-        textField.layer.borderColor = Utilities.hexStringToUIColor(\"556085\").cgColor\n-        textField.backgroundColor =  Utilities.hexStringToUIColor(\"414c6f\")\n-        \n-        return textField\n-    }\n-    \n-    /* Used to show invalid input for that particular textfield */\n-    class func getTextfieldWithInvalidInputBorder(textField: UITextField, layerBorderColor: String, backgroundColor: String) {\n-        \n-        //textField.borderStyle =  UITextBorderStyle.RoundedRect\n-        textField.layer.borderWidth = 2\n-        textField.layer.borderColor = Utilities.hexStringToUIColor(layerBorderColor).cgColor\n-        textField.backgroundColor =  Utilities.hexStringToUIColor(backgroundColor)\n-        //\"bf7266\"\n-        //\"414c6f\"\n-    }\n-    // MARK: UI effects & View Changes\n-    \n-    /* Used to remove border text field */\n-    class func removeTheBorderToTextField(textField: UITextField)->UITextField {\n-        \n-        textField.borderStyle =  UITextField.BorderStyle.none\n-        textField.layer.borderWidth = 0\n-        textField.layer.borderColor = UIColor.clear.cgColor\n-        textField.backgroundColor =  Utilities.hexStringToUIColor(\"556085\")\n-        \n-        return textField\n-        \n-    }\n-    \n-    class func segmentSeparatorColor(color: UIColor,segment: UISegmentedControl) -> UIImage {\n-        \n-        // let rect = CGRectMake(0.0, 0.0, 1.5, segment.frame.size.height)\n-        \n-        let rect =  CGRect(x: 0.0, y: 0.0, width: 1.5, height: segment.frame.size.height)\n-        UIGraphicsBeginImageContext(rect.size)\n-        let context = UIGraphicsGetCurrentContext()\n-        context!.setFillColor(color.cgColor);\n-        context!.fill(rect);\n-        let image = UIGraphicsGetImageFromCurrentImageContext();\n-        UIGraphicsEndImageContext();\n-        return image!\n-        \n-    }\n-    \n-    class func applyBlurrEffect() -> UIVisualEffectView\n-    {\n-        \n-        let blurEffect = UIBlurEffect.init(style: UIBlurEffect.Style.dark)\n-        let visualEffect = UIVisualEffectView.init(effect: blurEffect)\n-        visualEffect.tag = 100\n-        visualEffect.alpha = 1\n-        visualEffect.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n-        return visualEffect\n-    }\n-    \n-    class func applyBlurrEffectForFrequency() -> UIVisualEffectView\n-    {\n-        \n-        let blurEffect = UIBlurEffect.init(style: UIBlurEffect.Style.dark)\n-        let visualEffect = UIVisualEffectView.init(effect: blurEffect)\n-        visualEffect.tag = 500\n-        visualEffect.alpha = 1\n-        visualEffect.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n-        return visualEffect\n-    }\n-    \n-    \n-    class func removeBlurFromFrequency(fromView: UIView) {\n-        for subView in fromView.subviews{\n-            if subView.tag == 500{\n-                subView.removeFromSuperview()\n-            }\n-        }\n-    }\n-    \n-    class func removeBlur(fromView: UIView) {\n-        for subView in fromView.subviews{\n-            if subView.tag == 100{\n-                subView.removeFromSuperview()\n-            }\n-        }\n-    }\n-    \n-    /* Performs spinning action using CoreAnimation */\n-    class func addSpinAnimation(withDuration duration: CFTimeInterval)-> CABasicAnimation{\n-        let animation = CABasicAnimation(keyPath: \"transform.rotation.z\")\n-        animation.fromValue = 0\n-        animation.toValue = 360\n-        animation.duration = duration\n-        return animation\n-    }\n-    \n-    class  func getHexColors() -> NSArray {\n-        \n-        let hexColors = [\"ff9f30\",\"fdf22f\",\"b6ff14\",\"07f51c\"]\n-        return hexColors as NSArray\n-    }\n-    \n-    class  func addFadedGreenView(view: UIView) ->UIView{\n-        \n-        let greenView = UIView.init(frame: view.frame)\n-        greenView.backgroundColor = Utilities.hexStringToUIColor(\"1eebb4\")\n-        greenView.alpha = 0.5\n-        greenView.tag = 200\n-        view.addSubview(greenView)\n-        \n-        return greenView\n-    }\n-    \n-    class  func addFadedGreenViewForFrequencyAttributes(view: UIView) ->UIView{\n-        \n-        let greenView = UIView.init(frame:view.frame)\n-        greenView.backgroundColor = Utilities.hexStringToUIColor(\"1eebb4\")\n-        greenView.alpha = 0.8\n-        greenView.tag = 300\n-        view.addSubview(greenView)\n-        \n-        return greenView\n-    }\n-    \n-    class func setWhiteBorderOnView(view: UIView, borderWidth: CGFloat, cornerRadius: CGFloat){\n-        \n-        view.layer.borderWidth = borderWidth\n-        view.layer.cornerRadius = cornerRadius\n-        view.layer.borderColor = UIColor.white.cgColor\n-    }\n-    \n-    class func setRedBorderOnView(view: UIView, borderWidth: CGFloat, cornerRadius: CGFloat){\n-        \n-        view.layer.borderWidth = borderWidth\n-        view.layer.cornerRadius = cornerRadius\n-        view.layer.borderColor = Utilities.hexStringToUIColor(\"kInvalidBorderColor\").cgColor\n-    }\n-    \n-    // MARK: JSON serialization helper methods\n-    class func convertDictionaryIntoString(mutableDic: NSMutableDictionary) -> String{\n-        \n-        var jsonString: String!\n-        do{\n-            let jsonData: NSData = try JSONSerialization.data(withJSONObject: mutableDic, options: JSONSerialization.WritingOptions.prettyPrinted) as NSData\n-            jsonString = NSString(data: jsonData as Data, encoding: String.Encoding.utf8.rawValue)! as String\n-        }\n-        catch{\n-            \n-        }\n-        return jsonString\n+\n+  // MARK: UI changes for textField\n+  // Initial Padding space before displaying the texts\n+  class func paddingViewForTextField(textField: UITextField) {\n+    let paddingView = UIView.init(\n+      frame: CGRect(x: 0, y: 0, width: 10, height: textField.frame.height))\n+    textField.leftView = paddingView\n+    textField.leftViewMode = UITextField.ViewMode.always\n+  }\n+\n+  // Add a border to Textfield\n+  //     @params:- textfield - the data which is used to show\n+  //     @return:- textfield - returns text field with padding space\n+  class func addingBorderToTextField(textField: UITextField) -> UITextField {\n+    textField.layer.borderWidth = 2\n+    textField.layer.borderColor = Utilities.hexStringToUIColor(\"556085\").cgColor\n+    textField.backgroundColor = Utilities.hexStringToUIColor(\"414c6f\")\n+\n+    return textField\n+  }\n+\n+  /// Used to show invalid input for that particular textfield\n+  class func getTextfieldWithInvalidInputBorder(\n+    textField: UITextField, layerBorderColor: String, backgroundColor: String\n+  ) {\n+\n+    textField.layer.borderWidth = 2\n+    textField.layer.borderColor = Utilities.hexStringToUIColor(layerBorderColor).cgColor\n+    textField.backgroundColor = Utilities.hexStringToUIColor(backgroundColor)\n+\n+  }\n+\n+  // MARK: UI effects & View Changes\n+\n+  /// Used to remove border text field\n+  class func removeTheBorderToTextField(textField: UITextField) -> UITextField {\n+\n+    textField.borderStyle = UITextField.BorderStyle.none\n+    textField.layer.borderWidth = 0\n+    textField.layer.borderColor = UIColor.clear.cgColor\n+    textField.backgroundColor = Utilities.hexStringToUIColor(\"556085\")\n+\n+    return textField\n+\n+  }\n+\n+  class func segmentSeparatorColor(color: UIColor, segment: UISegmentedControl) -> UIImage {\n+\n+    let rect = CGRect(x: 0.0, y: 0.0, width: 1.5, height: segment.frame.size.height)\n+    UIGraphicsBeginImageContext(rect.size)\n+    let context = UIGraphicsGetCurrentContext()\n+    context!.setFillColor(color.cgColor)\n+    context!.fill(rect)\n+    let image = UIGraphicsGetImageFromCurrentImageContext()\n+    UIGraphicsEndImageContext()\n+    return image!\n+\n+  }\n+\n+  class func applyBlurrEffect() -> UIVisualEffectView {\n+\n+    let blurEffect = UIBlurEffect.init(style: UIBlurEffect.Style.dark)\n+    let visualEffect = UIVisualEffectView.init(effect: blurEffect)\n+    visualEffect.tag = 100\n+    visualEffect.alpha = 1\n+    visualEffect.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n+    return visualEffect\n+  }\n+\n+  class func applyBlurrEffectForFrequency() -> UIVisualEffectView {\n+\n+    let blurEffect = UIBlurEffect.init(style: UIBlurEffect.Style.dark)\n+    let visualEffect = UIVisualEffectView.init(effect: blurEffect)\n+    visualEffect.tag = 500\n+    visualEffect.alpha = 1\n+    visualEffect.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n+    return visualEffect\n+  }\n+\n+  class func removeBlurFromFrequency(fromView: UIView) {\n+    for subView in fromView.subviews {\n+      if subView.tag == 500 {\n+        subView.removeFromSuperview()\n+      }\n     }\n-    \n-    class func convertNSMutableArrayIntoString(mutableArray: NSMutableArray) -> String {\n-        \n-        var socialMediaNamesString: String!\n-        do{\n-            let jsonData: NSData = try JSONSerialization.data(withJSONObject: mutableArray, options: JSONSerialization.WritingOptions.prettyPrinted) as NSData\n-            socialMediaNamesString = NSString(data: jsonData as Data, encoding: String.Encoding.utf8.rawValue)! as String\n-        }\n-        catch{\n-        }\n-        return socialMediaNamesString\n+  }\n+\n+  class func removeBlur(fromView: UIView) {\n+    for subView in fromView.subviews {\n+      if subView.tag == 100 {\n+        subView.removeFromSuperview()\n+      }\n     }\n-    // MARK: Alert composers\n-    \n-    /* Presents alert message */\n-    class func showAlertWithTitleAndMessage(title: NSString, message : NSString) -> Void {\n-        \n-        let alert = UIAlertController(title: title as String,message: message as String,preferredStyle: UIAlertController.Style.alert)\n-        alert.addAction(UIAlertAction(title: NSLocalizedString(\"OK\", comment: \"\"), style: .default, handler: nil))\n-        var rootViewController = UIApplication.shared.keyWindow?.rootViewController\n-        if let navigationController = rootViewController as? UINavigationController {\n-            rootViewController = navigationController.viewControllers.first\n-        }\n-        if let tabBarController = rootViewController as? UITabBarController {\n-            rootViewController = tabBarController.selectedViewController\n-        }\n-        rootViewController?.present(alert, animated: true, completion: nil)\n-        \n+  }\n+\n+  /// Performs spinning action using CoreAnimation\n+  class func addSpinAnimation(withDuration duration: CFTimeInterval) -> CABasicAnimation {\n+    let animation = CABasicAnimation(keyPath: \"transform.rotation.z\")\n+    animation.fromValue = 0\n+    animation.toValue = 360\n+    animation.duration = duration\n+    return animation\n+  }\n+\n+  class func getHexColors() -> NSArray {\n+\n+    let hexColors = [\"ff9f30\", \"fdf22f\", \"b6ff14\", \"07f51c\"]\n+    return hexColors as NSArray\n+  }\n+\n+  class func addFadedGreenView(view: UIView) -> UIView {\n+\n+    let greenView = UIView.init(frame: view.frame)\n+    greenView.backgroundColor = Utilities.hexStringToUIColor(\"1eebb4\")\n+    greenView.alpha = 0.5\n+    greenView.tag = 200\n+    view.addSubview(greenView)\n+\n+    return greenView\n+  }\n+\n+  class func addFadedGreenViewForFrequencyAttributes(view: UIView) -> UIView {\n+\n+    let greenView = UIView.init(frame: view.frame)\n+    greenView.backgroundColor = Utilities.hexStringToUIColor(\"1eebb4\")\n+    greenView.alpha = 0.8\n+    greenView.tag = 300\n+    view.addSubview(greenView)\n+\n+    return greenView\n+  }\n+\n+  class func setWhiteBorderOnView(view: UIView, borderWidth: CGFloat, cornerRadius: CGFloat) {\n+\n+    view.layer.borderWidth = borderWidth\n+    view.layer.cornerRadius = cornerRadius\n+    view.layer.borderColor = UIColor.white.cgColor\n+  }\n+\n+  class func setRedBorderOnView(view: UIView, borderWidth: CGFloat, cornerRadius: CGFloat) {\n+\n+    view.layer.borderWidth = borderWidth\n+    view.layer.cornerRadius = cornerRadius\n+    view.layer.borderColor = Utilities.hexStringToUIColor(\"kInvalidBorderColor\").cgColor\n+  }\n+\n+  // MARK: - JSON serialization helper methods\n+\n+  class func convertDictionaryIntoString(mutableDic: NSMutableDictionary) -> String {\n+\n+    var jsonString: String!\n+    do {\n+      let jsonData: NSData = try JSONSerialization.data(\n+        withJSONObject: mutableDic, options: JSONSerialization.WritingOptions.prettyPrinted)\n+        as NSData\n+      jsonString = NSString(data: jsonData as Data, encoding: String.Encoding.utf8.rawValue)!\n+        as String\n+    } catch let error {\n+      Logger.sharedInstance.info(\"Error parsing data: \", error.localizedDescription)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 395}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1ODg4OQ==", "bodyText": "please remove this from top, copyright header should be on top", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392258889", "createdAt": "2020-03-13T14:23:36Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Views/Cells/TableView/Study/StudyListCell.swift", "diffHunk": "@@ -1,245 +1,209 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+//  HPHC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1OTQ3NA==", "bodyText": "why was this added? was there any other changes included here?", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392259474", "createdAt": "2020-03-13T14:24:39Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Views/Cells/TableView/Study/StudyListCell.swift", "diffHunk": "@@ -1,245 +1,209 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+//  HPHC\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NjU3OA==", "bodyText": "is this a brand new file?\nif yes, please only add the google copyright header", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392276578", "createdAt": "2020-03-13T14:52:11Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Views/UIViews+Additions/Activity/ActivitySchedule/ActivitySchedules.swift", "diffHunk": "@@ -0,0 +1,266 @@\n+// License Agreement for FDA My Studies", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3Njk4MA==", "bodyText": "please remove debug log", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392276980", "createdAt": "2020-03-13T14:52:50Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHC/Views/UIViews+Additions/Activity/ActivitySchedule/ActivitySchedules.swift", "diffHunk": "@@ -0,0 +1,266 @@\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n+// hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n+\n+import UIKit\n+\n+// MARK: - ActivitySchedules Class\n+class ActivitySchedules: UIView, UITableViewDelegate, UITableViewDataSource {\n+\n+  // MARK: - Outlets\n+  @IBOutlet var tableview: UITableView?\n+\n+  @IBOutlet var buttonCancel: UIButton!\n+  @IBOutlet var heightLayoutConstraint: NSLayoutConstraint!\n+\n+  var activity: Activity!\n+\n+  required init?(coder aDecoder: NSCoder) {\n+    super.init(coder: aDecoder)\n+  }\n+\n+  class func instanceFromNib(frame: CGRect, activity: Activity) -> ActivitySchedules {\n+    let view = (\n+      UINib(nibName: \"ActivitySchedules\", bundle: nil).instantiate(\n+        withOwner: nil, options: nil)[0]\n+        as? ActivitySchedules\n+    )!\n+    view.frame = frame\n+    view.activity = activity\n+    view.tableview?.register(UITableViewCell.self, forCellReuseIdentifier: \"Cell\")\n+    view.tableview?.delegate = view\n+    view.tableview?.dataSource = view\n+    let height = (activity.activityRuns.count*44) + 104\n+    let maxViewHeight = Int(UIScreen.main.bounds.size.height - 67)\n+    view.heightLayoutConstraint.constant = CGFloat(\n+      (height > maxViewHeight) ? maxViewHeight : height)\n+    view.layoutIfNeeded()\n+\n+    return view\n+  }\n+\n+  // MARK: - Button Action\n+  @IBAction func buttonCancelClicked(_: UIButton) {\n+    self.removeFromSuperview()\n+  }\n+\n+  // MARK: Tableview Delegates\n+  func numberOfSections(in tableView: UITableView) -> Int {\n+    return 1\n+  }\n+\n+  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n+    return self.activity.activityRuns.count\n+  }\n+\n+  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n+\n+    let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n+    cell.textLabel?.font = UIFont(name: \"HelveticaNeue-Light\", size: 13)\n+    let activityRun = self.activity.activityRuns[indexPath.row]\n+    cell.textLabel?.text = ActivitySchedules.formatter.string(from: activityRun.startDate)\n+      + \" - \"\n+      + ActivitySchedules.formatter.string(from: activityRun.endDate)\n+\n+    if activityRun.runId == self.activity.currentRunId {\n+      cell.textLabel?.textColor = kBlueColor\n+\n+    } else if activityRun.runId < self.activity.currentRunId {\n+      cell.textLabel?.textColor = UIColor.gray\n+    }\n+    cell.textLabel?.textAlignment = .center\n+    return cell\n+  }\n+\n+  private static let formatter: DateFormatter = {\n+    let formatter = DateFormatter()\n+    formatter.dateFormat = \"hh:mma, MMM dd YYYY\"\n+    return formatter\n+  }()\n+}\n+\n+class ResponseDataFetch: NMWebServiceDelegate {\n+\n+  var dataSourceKeysForLabkey: [[String: String]] = []\n+\n+  static let labkeyDateFormatter: DateFormatter = {\n+    let formatter = DateFormatter()\n+    formatter.timeZone = TimeZone.init(identifier: \"America/New_York\")\n+    formatter.dateFormat = \"YYYY-MM-dd HH:mm:ss.SSS\"\n+    return formatter\n+  }()\n+\n+  public static let localDateFormatter: DateFormatter = {\n+    let formatter = DateFormatter()\n+    formatter.timeZone = TimeZone.current\n+    formatter.dateFormat = \"YYYY/MM/dd HH:mm:ss\"\n+\n+    return formatter\n+  }()\n+\n+  init() {\n+\n+  }\n+\n+  // MARK: Helper Methods\n+  func checkUpdates() {\n+    if StudyUpdates.studyActivitiesUpdated {\n+      self.sendRequestToGetDashboardInfo()\n+\n+    } else {\n+\n+      // Load Stats List from DB\n+      DBHandler.loadStatisticsForStudy(studyId: (Study.currentStudy?.studyId)!) {\n+        (statiticsList) in\n+\n+        if statiticsList.count != 0 {\n+          StudyDashboard.instance.statistics = statiticsList\n+          self.getDataKeysForCurrentStudy()\n+          let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+          appDelegate.addAndRemoveProgress(add: true)\n+\n+        } else {\n+          // Fetch DashboardInfo\n+          self.sendRequestToGetDashboardInfo()\n+        }\n+      }\n+    }\n+  }\n+\n+  func sendRequestToGetDashboardInfo() {\n+    WCPServices().getStudyDashboardInfo(studyId: (Study.currentStudy?.studyId)!, delegate: self)\n+  }\n+\n+  func handleExecuteSQLResponse() {\n+\n+    if !self.dataSourceKeysForLabkey.isEmpty {\n+      self.dataSourceKeysForLabkey.removeFirst()\n+    }\n+    self.sendRequestToGetDashboardResponse()\n+  }\n+\n+  func getDataKeysForCurrentStudy() {\n+\n+    DBHandler.getDataSourceKeyForActivity(studyId: (Study.currentStudy?.studyId)!) {\n+      (activityKeys) in\n+      if activityKeys.count > 0 {\n+        self.dataSourceKeysForLabkey = activityKeys\n+        // GetDashboardResponse from server\n+        self.sendRequestToGetDashboardResponse()\n+      }\n+    }\n+\n+  }\n+\n+  func sendRequestToGetDashboardResponse() {\n+\n+    if self.dataSourceKeysForLabkey.count != 0 {\n+      let details = self.dataSourceKeysForLabkey.first\n+      let activityId = details?[\"activityId\"]\n+      var tableName = activityId\n+      let activity = Study.currentStudy?.activities.filter({ $0.actvityId == activityId })\n+        .first\n+      var keys = details?[\"keys\"]\n+      if activity?.type == ActivityType.activeTask {\n+        if activity?.taskSubType == \"fetalKickCounter\" {\n+          keys = \"\\\"count\\\",duration\"\n+          tableName = activityId!+activityId!\n+        } else if activity?.taskSubType == \"towerOfHanoi\" {\n+          keys = \"numberOfMoves\"\n+          tableName = activityId!+activityId!\n+        } else if activity?.taskSubType == \"spatialSpanMemory\" {\n+          keys = \"NumberofGames,Score,NumberofFailures\"\n+          tableName = activityId!+activityId!\n+        }\n+      }\n+      let participantId = Study.currentStudy?.userParticipateState.participantId\n+      // Get Survey Response from Server\n+      LabKeyServices().getParticipantResponse(\n+        tableName: tableName!, activityId: activityId!, keys: keys!,\n+        participantId: participantId!,\n+        delegate: self)\n+    } else {\n+      // save response in database\n+      let responses = StudyDashboard.instance.dashboardResponse\n+      for response in responses {\n+\n+        let activityId = response.activityId\n+        let activity = Study.currentStudy?.activities.filter({ $0.actvityId == activityId })\n+          .first\n+        var key = response.key\n+        if activity?.type == ActivityType.activeTask {\n+\n+          if activity?.taskSubType == \"fetalKickCounter\" || activity?.taskSubType\n+            == \"towerOfHanoi\" {\n+            key = activityId!\n+          }\n+        }\n+\n+        let values = response.values\n+        for value in values {\n+          let responseValue = (value[\"value\"] as? Float)!\n+          let count = (value[\"count\"] as? Float)!\n+          // SetData Format\n+          let date = ResponseDataFetch.labkeyDateFormatter.date(\n+            from: (value[\"date\"] as? String)!)\n+          let localDateAsString = ResponseDataFetch.localDateFormatter.string(from: date!)\n+\n+          let localDate = ResponseDataFetch.localDateFormatter.date(\n+            from: localDateAsString)\n+          // Save Stats to DB\n+          DBHandler.saveStatisticsDataFor(\n+            activityId: activityId!, key: key!, data: responseValue,\n+            fkDuration: Int(count),\n+            date: localDate!)\n+        }\n+\n+      }\n+      let key = \"LabKeyResponse\" + (Study.currentStudy?.studyId)!\n+      UserDefaults.standard.set(true, forKey: key)\n+\n+      let appDelegate = (UIApplication.shared.delegate as? AppDelegate)!\n+      appDelegate.addAndRemoveProgress(add: false)\n+\n+    }\n+  }\n+\n+  // MARK: Webservice Delegates\n+  func startedRequest(_ manager: NetworkManager, requestName: NSString) {\n+    Logger.sharedInstance.info(\" START requestname : \\(requestName)\")\n+  }\n+\n+  func finishedRequest(_ manager: NetworkManager, requestName: NSString, response: AnyObject?) {\n+    Logger.sharedInstance.info(\n+      \"requestname : \\(requestName) Response : \\(String(describing: response) )\")\n+\n+    if requestName as String == WCPMethods.studyDashboard.method.methodName {\n+      self.getDataKeysForCurrentStudy()\n+\n+    } else if requestName as String == ResponseMethods.executeSQL.description {\n+      self.handleExecuteSQLResponse()\n+    }\n+\n+  }\n+\n+  func failedRequest(_ manager: NetworkManager, requestName: NSString, error: NSError) {\n+    Logger.sharedInstance.info(\"requestname : \\(requestName)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MjE1MA==", "bodyText": "please remove all commented out code", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392282150", "createdAt": "2020-03-13T15:01:06Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHCTests/ResourceAnchorTest.swift", "diffHunk": "@@ -1,199 +1,200 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC\n+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import XCTest\n-@testable import HPHC\n import Mockingjay\n+import XCTest\n \n+@testable import HPHC\n \n class ResourceAnchorTest: XCTestCase {\n \n-    var delegate:WCPDelegate!\n-    override func setUp() {\n-        // Put setup code here. This method is called before the invocation of each test method in the class.\n-        delegate = WCPDelegate()\n-    }\n+  var delegate: WCPDelegate!\n \n-    override func tearDown() {\n-        // Put teardown code here. This method is called after the invocation of each test method in the class.\n-    }\n+  override func setUp() {\n+    // Put setup code here. This method is called before the invocation of each test method in the class.\n+    delegate = WCPDelegate()\n+  }\n+\n+  override func tearDown() {\n+    // Put teardown code here. This method is called after the invocation of each test method in the class.\n+  }\n+\n+  func testExample() {\n+    // This is an example of a functional test case.\n+    // Use XCTAssert and related functions to verify your tests produce the correct results.\n+  }\n+\n+  func testFetchingResourceList() {\n+    //        let rlist =  DBHandler.resourceListFor(nil, questionKey: nil)\n+    //        XCTAssertEqual(rlist.count, 1)\n+  }\n+\n+  func testResourcesLifeTimeWhenAnchorDateIsAvailable() {\n+    //        DBHandler.updateResourceLifeTime(nil, questionKey: nil, anchorDateValue: Date())\n+    //        let rlist =  DBHandler.resourceListFor(nil, questionKey: nil)\n+    //        XCTAssertEqual(rlist.count, 0)\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MjI5Ng==", "bodyText": "remove", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392282296", "createdAt": "2020-03-13T15:01:24Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/HPHCTests/ResourceAnchorTest.swift", "diffHunk": "@@ -1,199 +1,200 @@\n-/*\n- License Agreement for FDA My Studies\n-Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors. Permission is\n-hereby granted, free of charge, to any person obtaining a copy of this software and associated\n-documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n-limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n-Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n-conditions:\n-The above copyright notice and this permission notice shall be included in all copies or substantial\n-portions of the Software.\n-Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n-Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n-INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n-PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n- */\n+// License Agreement for FDA My Studies\n+// Copyright \u00a9 2017-2019 Harvard Pilgrim Health Care Institute (HPHCI) and its Contributors.\n+// Copyright 2020 Google LLC\n+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n+// documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n+// Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n+// conditions:\n+// The above copyright notice and this permission notice shall be included in all copies or substantial\n+// portions of the Software.\n+// Funding Source: Food and Drug Administration (\u201cFunding Agency\u201d) effective 18 September 2014 as\n+// Contract no. HHSF22320140030I/HHSF22301006T (the \u201cPrime Contract\u201d).\n+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n+// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+// OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+// OTHER DEALINGS IN THE SOFTWARE.\n \n-import XCTest\n-@testable import HPHC\n import Mockingjay\n+import XCTest\n \n+@testable import HPHC\n \n class ResourceAnchorTest: XCTestCase {\n \n-    var delegate:WCPDelegate!\n-    override func setUp() {\n-        // Put setup code here. This method is called before the invocation of each test method in the class.\n-        delegate = WCPDelegate()\n-    }\n+  var delegate: WCPDelegate!\n \n-    override func tearDown() {\n-        // Put teardown code here. This method is called after the invocation of each test method in the class.\n-    }\n+  override func setUp() {\n+    // Put setup code here. This method is called before the invocation of each test method in the class.\n+    delegate = WCPDelegate()\n+  }\n+\n+  override func tearDown() {\n+    // Put teardown code here. This method is called after the invocation of each test method in the class.\n+  }\n+\n+  func testExample() {\n+    // This is an example of a functional test case.\n+    // Use XCTAssert and related functions to verify your tests produce the correct results.\n+  }\n+\n+  func testFetchingResourceList() {\n+    //        let rlist =  DBHandler.resourceListFor(nil, questionKey: nil)\n+    //        XCTAssertEqual(rlist.count, 1)\n+  }\n+\n+  func testResourcesLifeTimeWhenAnchorDateIsAvailable() {\n+    //        DBHandler.updateResourceLifeTime(nil, questionKey: nil, anchorDateValue: Date())\n+    //        let rlist =  DBHandler.resourceListFor(nil, questionKey: nil)\n+    //        XCTAssertEqual(rlist.count, 0)\n+  }\n+\n+  func testResourceIsEmpty() {\n+    // let empty = DBHandler.isResourcesEmpty()\n+    //XCTAssert(empty)\n+  }\n+\n+  func testResourcesLifeTimeWhenAnchorDateIsNotAvailable() {\n+\n+  }\n+\n+  func testWCP_GetStudies_Failure() {\n+\n+    //let delegate = WCPDelegate()\n+\n+    let expection = expectation(description: \"StudyList api call\")\n+    delegate.asyncExpectation = expection\n+\n+    _ = [\"user\": \"Kyle\"]\n+    let url = API.wcpURL + \"studyList\"\n+\n+    let error = NSError.init(domain: \"mocking\", code: 500, userInfo: nil)\n+    stub(uri(url), failure(error))\n+\n+    let services = WCPServices()\n+    services.delegateSource = delegate\n+    services.getStudyList(delegate)\n+\n+    waitForExpectations(timeout: 3.0) { (error) in\n+\n+      if let error = error {\n+        XCTFail(\"waitForExpectationsWithTimeout errored: \\(error)\")\n+      }\n+\n+      guard let result = self.delegate.delegateAsyncResult else {\n+        XCTFail(\"Expected delegate to be called\")\n+        return\n+      }\n+      let data = self.delegate.apiResponse\n+      let error = self.delegate.apiError\n+\n+      XCTAssertEqual(error?.code, 500)\n+      XCTAssertNotEqual(WCPDelegate.State.none, result)\n+      //XCTAssertNotEqual(WCPDelegate.State.start, result)\n+      XCTAssertEqual(WCPDelegate.State.failed, result)\n+      XCTAssertNil(data)\n \n-    func testExample() {\n-        // This is an example of a functional test case.\n-        // Use XCTAssert and related functions to verify your tests produce the correct results.\n-    }\n-    func testFetchingResourceList() {\n-//        let rlist =  DBHandler.resourceListFor(nil, questionKey: nil)\n-//        XCTAssertEqual(rlist.count, 1)\n-    }\n-    \n-    func testResourcesLifeTimeWhenAnchorDateIsAvailable() {\n-//        DBHandler.updateResourceLifeTime(nil, questionKey: nil, anchorDateValue: Date())\n-//        let rlist =  DBHandler.resourceListFor(nil, questionKey: nil)\n-//        XCTAssertEqual(rlist.count, 0)\n-    }\n-    \n-    func testResourceIsEmpty() {\n-       // let empty = DBHandler.isResourcesEmpty()\n-        //XCTAssert(empty)\n-    }\n-    \n-    func testResourcesLifeTimeWhenAnchorDateIsNotAvailable() {\n-        \n-    }\n-    \n-    func testWCP_GetStudies_Failure() {\n-        \n-        //let delegate = WCPDelegate()\n-        \n-        let expection = expectation(description: \"StudyList api call\")\n-        delegate.asyncExpectation = expection\n-        \n-        _ = [ \"user\": \"Kyle\" ]\n-        let url = \"https://hpwcp-stage.lkcompliant.net/StudyMetaData/studyList\"\n-        \n-        let error = NSError.init(domain: \"mocking\", code: 500, userInfo: nil)\n-        stub(uri(url), failure(error))\n-        \n-        let services = WCPServices()\n-        services.delegateSource = delegate\n-        services.getStudyList(delegate)\n-        \n-        waitForExpectations(timeout: 3.0) { (error) in\n-           \n-            if let error = error {\n-                XCTFail(\"waitForExpectationsWithTimeout errored: \\(error)\")\n-            }\n-            \n-            guard let result = self.delegate.delegateAsyncResult else {\n-                XCTFail(\"Expected delegate to be called\")\n-                return\n-            }\n-            let data = self.delegate.apiResponse\n-            let error = self.delegate.apiError\n-            \n-            XCTAssertEqual(error?.code, 500)\n-            XCTAssertNotEqual(WCPDelegate.State.none, result)\n-            //XCTAssertNotEqual(WCPDelegate.State.start, result)\n-            XCTAssertEqual(WCPDelegate.State.failed, result)\n-            XCTAssertNil(data)\n-           \n-        }\n     }\n-    \n-    func testWCP_GetStudies_Sucess() {\n-        \n-        let expection = expectation(description: \"StudyList api call\")\n-        delegate.asyncExpectation = expection\n-        \n-        let path = Bundle(for: type(of: self)).url(forResource: \"StudyList\", withExtension: \"json\")!\n-        let data = try! Data(contentsOf: path)\n-        \n-        let url = \"https://hpwcp-stage.lkcompliant.net/StudyMetaData/studyList\"\n-        stub(http(.get,uri: url),jsonData(data))\n-        \n-        let services = WCPServices()\n-        services.delegateSource = delegate\n-        services.getStudyList(delegate)\n-        \n-        waitForExpectations(timeout: 2.0) { (error) in\n-            \n-            if let error = error {\n-                XCTFail(\"waitForExpectationsWithTimeout errored: \\(error)\")\n-            }\n-            \n-            guard let result = self.delegate.delegateAsyncResult else {\n-                XCTFail(\"Expected delegate to be called\")\n-                return\n-            }\n-            let data = self.delegate.apiResponse\n-            let error = self.delegate.apiError\n-            \n-            \n-            XCTAssertNotEqual(WCPDelegate.State.none, result)\n-            //XCTAssertNotEqual(WCPDelegate.State.start, result)\n-            XCTAssertEqual(WCPDelegate.State.finished, result)\n-            XCTAssertNotNil(data)\n-            XCTAssertEqual(Gateway.instance.studies?.count, 2)\n-            \n-        }\n+  }\n+\n+  func testWCP_GetStudies_Sucess() {\n+\n+    let expection = expectation(description: \"StudyList api call\")\n+    delegate.asyncExpectation = expection\n+\n+    let path = Bundle(for: type(of: self)).url(forResource: \"StudyList\", withExtension: \"json\")!\n+    let data = try! Data(contentsOf: path)\n+\n+    let url = API.wcpURL + \"studyList\"\n+    stub(http(.get, uri: url), jsonData(data))\n+\n+    let services = WCPServices()\n+    services.delegateSource = delegate\n+    services.getStudyList(delegate)\n+\n+    waitForExpectations(timeout: 2.0) { (error) in\n+\n+      if let error = error {\n+        XCTFail(\"waitForExpectationsWithTimeout errored: \\(error)\")\n+      }\n+\n+      guard let result = self.delegate.delegateAsyncResult else {\n+        XCTFail(\"Expected delegate to be called\")\n+        return\n+      }\n+      let data = self.delegate.apiResponse\n+      let error = self.delegate.apiError\n+\n+      XCTAssertNotEqual(WCPDelegate.State.none, result)\n+      //XCTAssertNotEqual(WCPDelegate.State.start, result)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMwMTg0Mg==", "bodyText": "please do not change pods codes; external dependencies do not need to follow Google style guide format, and in fact changing their code could cause conflicts going forward.", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/19#discussion_r392301842", "createdAt": "2020-03-13T15:32:34Z", "author": {"login": "zohrehj"}, "path": "iOS/HPHC/Pods/CryptoSwift/LICENSE", "diffHunk": "@@ -1,11 +1,11 @@\n Copyright (C) 2014-2017 Marcin Krzy\u017canowski <marcin.krzyzanowski@gmail.com>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e4edb100bdaa956ee53c385528168725e4ea085"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c36160e458ba3c6faf7556dab6abaa424a67e202", "author": {"user": {"login": "tushar-boston", "name": "Tushar Katyal"}}, "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/c36160e458ba3c6faf7556dab6abaa424a67e202", "committedDate": "2020-03-16T09:30:03Z", "message": "- Run swift-format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7de9123a736e523cab553737efa325117b5bf88", "author": {"user": {"login": "tushar-boston", "name": "Tushar Katyal"}}, "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/a7de9123a736e523cab553737efa325117b5bf88", "committedDate": "2020-03-16T09:30:44Z", "message": "Delete Performance.swift\n\nThis wasn't used anywhere."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b5c3e4b9b9f59084322b55e66da4466745b1e47", "author": {"user": {"login": "tushar-boston", "name": "Tushar Katyal"}}, "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/3b5c3e4b9b9f59084322b55e66da4466745b1e47", "committedDate": "2020-03-18T07:11:37Z", "message": "- Clean debug print logs.\n- Delete ViewController.swift unused class."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c1a0bb6e9c99155f1790e5ddb7e32bb7d760855", "author": {"user": {"login": "tushar-boston", "name": "Tushar Katyal"}}, "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/1c1a0bb6e9c99155f1790e5ddb7e32bb7d760855", "committedDate": "2020-03-18T11:13:34Z", "message": "formatting and commented out code cleanup."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1333, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}