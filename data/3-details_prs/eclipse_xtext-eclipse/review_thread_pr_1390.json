{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5MDAyNTc1", "number": 1390, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMDowMzo1NlrODu3Byg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxOTo1MlrODvBI4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNDYyNjY2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMDowMzo1NlrOGA-lWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwODo1OTowMFrOGB51wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY3ODU1Mg==", "bodyText": "I have removed the exception handling code as it was not required.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403678552", "createdAt": "2020-04-05T10:03:56Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxMzE3NQ==", "bodyText": "The runtime exception was most likely caught to avoid NPEs or IllegalArgumentException. Not sure if we have a tradeoff between robustness and clean code here.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403913175", "createdAt": "2020-04-06T08:26:55Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY3ODU1Mg=="}, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0OTQwOQ==", "bodyText": "Actually, after reading your comment, I chose to revert back the changes I made to this method.  I did keep Preconditions.checkNotNull(reference) just to be on the safer side.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r404649409", "createdAt": "2020-04-07T08:59:00Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY3ODU1Mg=="}, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNDYyODAyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMDowNTozOVrOGA-mFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMDowNTozOVrOGA-mFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY3ODc0MQ==", "bodyText": "Updated the error message to provide accurate contextual information in case of a failure.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403678741", "createdAt": "2020-04-05T10:05:39Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotation().getSimpleName()));\n+\n+\t\tList<JvmAnnotationValue> explicitValues = reference.getExplicitValues();\n+\t\tboolean needsExplicitProperties = explicitValues.size() > 1 //\n+\t\t\t\t|| (!explicitValues.isEmpty() && explicitValues.get(0).getOperation() != null //\n+\t\t\t\t\t\t&& !\"value\".equals(explicitValues.get(0).getOperation().getSimpleName()));\n+\n+\t\tif (!explicitValues.isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(explicitValues.stream().map(explicitValue -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\tif (needsExplicitProperties) {\n+\t\t\t\t\tIterable<JvmOperation> declaredOperations = reference.getAnnotation().getDeclaredOperations();\n+\t\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\t\tJvmOperation operation = explicitValue.getOperation() != null ? explicitValue.getOperation() : valueOperation;\n+\t\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(internalToString(explicitValue));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(XAnnotation reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotationType());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotationType().getSimpleName()));\n+\n+\t\tif (reference.getValue() != null) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getValue());\n+\t\t\tbuffer.append(\")\");\n+\t\t} else if (!reference.getElementValuePairs().isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getElementValuePairs().stream().map(evPair -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\n+\t\t\t\tIterable<JvmOperation> declaredOperations = ((JvmAnnotationType) reference.getAnnotationType()).getDeclaredOperations();\n+\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\tJvmOperation operation = evPair.getElement() != null ? evPair.getElement() : valueOperation;\n+\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\tbuilder.append(internalToString(evPair.getValue()));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationValue jvmAnnotationValue) {\n+\t\tEStructuralFeature ref = jvmAnnotationValue.eClass().getEStructuralFeature(\"values\");\n+\t\tif (ref == null) {\n+\t\t\tthrow new IllegalStateException(\"Cannot find feature with name 'values' in \" + jvmAnnotationValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNDYyOTY4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/validation/ProjectAwareUniqueClassNameValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMDowNzo0M1rOGA-m-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMDowNzo0M1rOGA-m-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY3ODk2OQ==", "bodyText": "Here, I have reduced the scope of the try block.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403678969", "createdAt": "2020-04-05T10:07:43Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/validation/ProjectAwareUniqueClassNameValidator.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.validation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.resources.ResourcesPlugin;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.core.runtime.Path;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragment;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.IType;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.core.search.IJavaSearchConstants;\n+import org.eclipse.jdt.core.search.IJavaSearchScope;\n+import org.eclipse.jdt.core.search.SearchParticipant;\n+import org.eclipse.jdt.core.search.SearchPattern;\n+import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;\n+import org.eclipse.jdt.internal.core.DefaultWorkingCopyOwner;\n+import org.eclipse.jdt.internal.core.JavaModelManager;\n+import org.eclipse.jdt.internal.core.search.BasicSearchEngine;\n+import org.eclipse.jdt.internal.core.search.IndexQueryRequestor;\n+import org.eclipse.jdt.internal.core.search.PatternSearchJob;\n+import org.eclipse.jdt.internal.core.search.indexing.IIndexConstants;\n+import org.eclipse.jdt.internal.core.search.indexing.IndexManager;\n+import org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern;\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.access.jdt.IJavaProjectProvider;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfiguration.SourceMapping;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ResourceSetContext;\n+import org.eclipse.xtext.ui.generator.IDerivedResourceMarkers;\n+import org.eclipse.xtext.xbase.validation.UniqueClassNameValidator;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+@SuppressWarnings(\"restriction\")\n+public class ProjectAwareUniqueClassNameValidator extends UniqueClassNameValidator {\n+\n+\tprivate enum SourceTraversal {\n+\t\tINTERRUPT,\n+\n+\t\tDUPLICATE,\n+\n+\t\tUNIQUE;\n+\t}\n+\n+\tprivate final static Logger LOG = Logger.getLogger(ProjectAwareUniqueClassNameValidator.class);\n+\n+\t/**\n+\t * Context key for output configurations.\n+\t */\n+\tprivate final static String OUTPUT_CONFIGS = \"ProjectAwareUniqueClassNameValidator.outputConfigs\";\n+\n+\t@Inject\n+\tprivate IJavaProjectProvider javaProjectProvider;\n+\n+\t@Inject\n+\tprivate IDerivedResourceMarkers derivedResourceMarkers;\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Override\n+\tpublic boolean doCheckUniqueName(QualifiedName name, JvmDeclaredType type) {\n+\t\tif (!super.doCheckUniqueName(name, type)) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\ttry {\n+\t\t\treturn doCheckUniqueInProject(name, type);\n+\t\t} catch (JavaModelException e) {\n+\t\t\tif (!e.isDoesNotExist()) {\n+\t\t\t\tLOG.error(e.getMessage(), e);\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\tprivate SourceTraversal doCheckUniqueInProjectSource(String packageName, String typeName, JvmDeclaredType type,\n+\t\t\tList<IPackageFragmentRoot> sourceFolders) throws JavaModelException {\n+\t\tIndexManager indexManager = JavaModelManager.getIndexManager();\n+\t\tfor (IPackageFragmentRoot sourceFolder : sourceFolders) {\n+\t\t\tif (indexManager.awaitingJobsCount() > 0) {\n+\t\t\t\tif (!isDerived(sourceFolder.getResource())) {\n+\t\t\t\t\tIPackageFragment packageFragment = sourceFolder.getPackageFragment(packageName);\n+\t\t\t\t\tif (packageFragment.exists()) {\n+\t\t\t\t\t\tfor (ICompilationUnit unit : packageFragment.getCompilationUnits()) {\n+\t\t\t\t\t\t\tif (!isDerived(unit.getResource())) {\n+\t\t\t\t\t\t\t\tIType javaType = unit.getType(typeName);\n+\t\t\t\t\t\t\t\tif (javaType.exists()) {\n+\t\t\t\t\t\t\t\t\taddIssue(type, unit.getElementName());\n+\t\t\t\t\t\t\t\t\treturn SourceTraversal.DUPLICATE;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\treturn SourceTraversal.INTERRUPT;\n+\t\t\t}\n+\t\t}\n+\t\treturn SourceTraversal.UNIQUE;\n+\t}\n+\n+\tpublic boolean doCheckUniqueInProject(QualifiedName name, JvmDeclaredType type) throws JavaModelException {\n+\t\tIJavaProject javaProject = javaProjectProvider.getJavaProject(type.eResource().getResourceSet());\n+\t\tgetContext().put(ProjectAwareUniqueClassNameValidator.OUTPUT_CONFIGS,\n+\t\t\t\toutputConfigurationProvider.getOutputConfigurations(type.eResource()));\n+\n+\t\tString packageName = type.getPackageName();\n+\t\tString typeName = type.getSimpleName();\n+\t\tIndexManager indexManager = JavaModelManager.getIndexManager();\n+\t\tList<IPackageFragmentRoot> sourceFolders = new ArrayList<>();\n+\t\tfor (IPackageFragmentRoot root : javaProject.getPackageFragmentRoots()) {\n+\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\tsourceFolders.add(root);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (sourceFolders.isEmpty() || indexManager.awaitingJobsCount() > 0) {\n+\t\t\t// still indexing - don't enter a busy wait loop but ask the source folders directly\n+\t\t\tSourceTraversal sourceTraversal = doCheckUniqueInProjectSource(packageName != null ? packageName : \"\", typeName, type,\n+\t\t\t\t\tsourceFolders);\n+\t\t\tif (sourceTraversal == SourceTraversal.DUPLICATE) {\n+\t\t\t\treturn false;\n+\t\t\t} else if (sourceTraversal == SourceTraversal.UNIQUE) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> workingCopyPaths = new HashSet<>();\n+\t\tICompilationUnit[] copies = getWorkingCopies(type);\n+\t\tif (copies != null) {\n+\t\t\tfor (ICompilationUnit workingCopy : copies) {\n+\t\t\t\tIPath path = workingCopy.getPath();\n+\t\t\t\tif (javaProject.getPath().isPrefixOf(path) && !isDerived(workingCopy.getResource())) {\n+\t\t\t\t\tif (workingCopy.getPackageDeclaration(packageName).exists()) {\n+\t\t\t\t\t\tIType result = workingCopy.getType(typeName);\n+\t\t\t\t\t\tif (result.exists()) {\n+\t\t\t\t\t\t\taddIssue(type, workingCopy.getElementName());\n+\t\t\t\t\t\t\treturn false;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tworkingCopyPaths.add(workingCopy.getPath().toString());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// The code below is adapted from BasicSearchEnginge.searchAllSecondaryTypes\n+\t\t// The Index is ready, query it for a secondary type \n+\t\tchar[] pkg = packageName == null ? CharOperation.NO_CHAR : packageName.toCharArray();\n+\t\tTypeDeclarationPattern pattern = new TypeDeclarationPattern(pkg, //\n+\t\t\t\tCharOperation.NO_CHAR_CHAR, // top level type - no enclosing type names\n+\t\t\t\ttypeName.toCharArray(), //\n+\t\t\t\tIIndexConstants.TYPE_SUFFIX, //\n+\t\t\t\tSearchPattern.R_EXACT_MATCH | SearchPattern.R_CASE_SENSITIVE);\n+\n+\t\tIndexQueryRequestor searchRequestor = new IndexQueryRequestor() {\n+\n+\t\t\t@Override\n+\t\t\tpublic boolean acceptIndexMatch(String documentPath, SearchPattern indexRecord, SearchParticipant participant,\n+\t\t\t\t\tAccessRuleSet access) {\n+\t\t\t\tif (workingCopyPaths.contains(documentPath)) {\n+\t\t\t\t\treturn true; // filter out working copies\n+\t\t\t\t}\n+\t\t\t\tIFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(documentPath));\n+\t\t\t\tif (!isDerived(file)) {\n+\t\t\t\t\taddIssue(type, file.getName());\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t};\n+\n+\t\ttry {\n+\t\t\tSearchParticipant searchParticipant = BasicSearchEngine.getDefaultSearchParticipant(); // Java search only\n+\t\t\tIJavaSearchScope javaSearchScope = BasicSearchEngine.createJavaSearchScope(sourceFolders.toArray(new IJavaElement[0]));\n+\t\t\tPatternSearchJob patternSearchJob = new PatternSearchJob(pattern, searchParticipant, javaSearchScope, searchRequestor);\n+\t\t\tindexManager.performConcurrentJob(patternSearchJob, IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, null);\n+\t\t\treturn true;\n+\t\t} catch (Throwable OperationCanceledException) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate ICompilationUnit[] getWorkingCopies(JvmDeclaredType type) {\n+\t\treturn ResourceSetContext.get(type).isBuilder() //\n+\t\t\t\t? new ICompilationUnit[] {} //\n+\t\t\t\t: JavaModelManager.getJavaModelManager().getWorkingCopies(DefaultWorkingCopyOwner.PRIMARY, false);\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected boolean isDerived(IResource resource) {\n+\t\ttry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNDYzMDE1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/validation/ProjectAwareUniqueClassNameValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMDowODoyNFrOGA-nPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQxMDowODoyNFrOGA-nPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY3OTAzOQ==", "bodyText": "Logging an error message before returning the value.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403679039", "createdAt": "2020-04-05T10:08:24Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/validation/ProjectAwareUniqueClassNameValidator.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.validation;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IResource;\n+import org.eclipse.core.resources.ResourcesPlugin;\n+import org.eclipse.core.runtime.CoreException;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.core.runtime.Path;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.jdt.core.ICompilationUnit;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragment;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.IType;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.core.search.IJavaSearchConstants;\n+import org.eclipse.jdt.core.search.IJavaSearchScope;\n+import org.eclipse.jdt.core.search.SearchParticipant;\n+import org.eclipse.jdt.core.search.SearchPattern;\n+import org.eclipse.jdt.internal.compiler.env.AccessRuleSet;\n+import org.eclipse.jdt.internal.core.DefaultWorkingCopyOwner;\n+import org.eclipse.jdt.internal.core.JavaModelManager;\n+import org.eclipse.jdt.internal.core.search.BasicSearchEngine;\n+import org.eclipse.jdt.internal.core.search.IndexQueryRequestor;\n+import org.eclipse.jdt.internal.core.search.PatternSearchJob;\n+import org.eclipse.jdt.internal.core.search.indexing.IIndexConstants;\n+import org.eclipse.jdt.internal.core.search.indexing.IndexManager;\n+import org.eclipse.jdt.internal.core.search.matching.TypeDeclarationPattern;\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.access.jdt.IJavaProjectProvider;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfiguration.SourceMapping;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ResourceSetContext;\n+import org.eclipse.xtext.ui.generator.IDerivedResourceMarkers;\n+import org.eclipse.xtext.xbase.validation.UniqueClassNameValidator;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+@SuppressWarnings(\"restriction\")\n+public class ProjectAwareUniqueClassNameValidator extends UniqueClassNameValidator {\n+\n+\tprivate enum SourceTraversal {\n+\t\tINTERRUPT,\n+\n+\t\tDUPLICATE,\n+\n+\t\tUNIQUE;\n+\t}\n+\n+\tprivate final static Logger LOG = Logger.getLogger(ProjectAwareUniqueClassNameValidator.class);\n+\n+\t/**\n+\t * Context key for output configurations.\n+\t */\n+\tprivate final static String OUTPUT_CONFIGS = \"ProjectAwareUniqueClassNameValidator.outputConfigs\";\n+\n+\t@Inject\n+\tprivate IJavaProjectProvider javaProjectProvider;\n+\n+\t@Inject\n+\tprivate IDerivedResourceMarkers derivedResourceMarkers;\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Override\n+\tpublic boolean doCheckUniqueName(QualifiedName name, JvmDeclaredType type) {\n+\t\tif (!super.doCheckUniqueName(name, type)) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\ttry {\n+\t\t\treturn doCheckUniqueInProject(name, type);\n+\t\t} catch (JavaModelException e) {\n+\t\t\tif (!e.isDoesNotExist()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE5NjI5OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo1NTo0MVrOGBL0ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOToxMDo0OVrOGB6SVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5NTM5Ng==", "bodyText": "Same logic as in lines 101f, 117f, 131f and probably others; maybe extract a method wie JvmIdentifiable as parameter?", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403895396", "createdAt": "2020-04-06T07:55:41Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NjcyNQ==", "bodyText": "I have added a private method #createLinkToOperation(...) which abstracts a bit of the common logic from the lines pointed above. The method has a minor optimization - the logic to filter out the first operation with simple-name value is only executed if the explicitOperation is null.\nSecondly, I removed the scheme parameter from the method createLinkWithLabel and hard-coded the scheme to XtextElementLinks.XTEXTDOC_SCHEME. This removes a bit of repetitive usage of the constant, secondly, since this is private code which is mostly controlled, I think it is ok to make such a change. @szarnekow What do you think? Is it ok?", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r404656725", "createdAt": "2020-04-07T09:10:49Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5NTM5Ng=="}, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjIwMTA5OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo1NzowMFrOGBL3Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo1NzowMFrOGBL3Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5NjE0Ng==", "bodyText": "Duplicates the logic in 128ff, please extract method", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403896146", "createdAt": "2020-04-06T07:57:00Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotation().getSimpleName()));\n+\n+\t\tList<JvmAnnotationValue> explicitValues = reference.getExplicitValues();\n+\t\tboolean needsExplicitProperties = explicitValues.size() > 1 //\n+\t\t\t\t|| (!explicitValues.isEmpty() && explicitValues.get(0).getOperation() != null //\n+\t\t\t\t\t\t&& !\"value\".equals(explicitValues.get(0).getOperation().getSimpleName()));\n+\n+\t\tif (!explicitValues.isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(explicitValues.stream().map(explicitValue -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\tif (needsExplicitProperties) {\n+\t\t\t\t\tIterable<JvmOperation> declaredOperations = reference.getAnnotation().getDeclaredOperations();\n+\t\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjIwNDQ1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo1Nzo1MVrOGBL5Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo1Nzo1MVrOGBL5Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5NjY1MQ==", "bodyText": "Collectors.joining as an overloaded version with prefix and suffix", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403896651", "createdAt": "2020-04-06T07:57:51Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotation().getSimpleName()));\n+\n+\t\tList<JvmAnnotationValue> explicitValues = reference.getExplicitValues();\n+\t\tboolean needsExplicitProperties = explicitValues.size() > 1 //\n+\t\t\t\t|| (!explicitValues.isEmpty() && explicitValues.get(0).getOperation() != null //\n+\t\t\t\t\t\t&& !\"value\".equals(explicitValues.get(0).getOperation().getSimpleName()));\n+\n+\t\tif (!explicitValues.isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(explicitValues.stream().map(explicitValue -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\tif (needsExplicitProperties) {\n+\t\t\t\t\tIterable<JvmOperation> declaredOperations = reference.getAnnotation().getDeclaredOperations();\n+\t\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\t\tJvmOperation operation = explicitValue.getOperation() != null ? explicitValue.getOperation() : valueOperation;\n+\t\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(internalToString(explicitValue));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(XAnnotation reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotationType());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotationType().getSimpleName()));\n+\n+\t\tif (reference.getValue() != null) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getValue());\n+\t\t\tbuffer.append(\")\");\n+\t\t} else if (!reference.getElementValuePairs().isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getElementValuePairs().stream().map(evPair -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\n+\t\t\t\tIterable<JvmOperation> declaredOperations = ((JvmAnnotationType) reference.getAnnotationType()).getDeclaredOperations();\n+\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\tJvmOperation operation = evPair.getElement() != null ? evPair.getElement() : valueOperation;\n+\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\tbuilder.append(internalToString(evPair.getValue()));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationValue jvmAnnotationValue) {\n+\t\tEStructuralFeature ref = jvmAnnotationValue.eClass().getEStructuralFeature(\"values\");\n+\t\tif (ref == null) {\n+\t\t\tthrow new IllegalStateException(\"Cannot find feature with name 'values' in \" + jvmAnnotationValue);\n+\t\t}\n+\n+\t\tEList<?> values = (EList<?>) jvmAnnotationValue.eGet(ref);\n+\t\tif (values.size() > 1) {\n+\t\t\treturn \"#[\" + values.stream().map((value) -> internalToString(value)).collect(Collectors.joining(\", \")) + \"]\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjIwOTk2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo1OToyNFrOGBL8jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo1OToyNFrOGBL8jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5NzQ4Nw==", "bodyText": "value should probably escape \"", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403897487", "createdAt": "2020-04-06T07:59:24Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotation().getSimpleName()));\n+\n+\t\tList<JvmAnnotationValue> explicitValues = reference.getExplicitValues();\n+\t\tboolean needsExplicitProperties = explicitValues.size() > 1 //\n+\t\t\t\t|| (!explicitValues.isEmpty() && explicitValues.get(0).getOperation() != null //\n+\t\t\t\t\t\t&& !\"value\".equals(explicitValues.get(0).getOperation().getSimpleName()));\n+\n+\t\tif (!explicitValues.isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(explicitValues.stream().map(explicitValue -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\tif (needsExplicitProperties) {\n+\t\t\t\t\tIterable<JvmOperation> declaredOperations = reference.getAnnotation().getDeclaredOperations();\n+\t\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\t\tJvmOperation operation = explicitValue.getOperation() != null ? explicitValue.getOperation() : valueOperation;\n+\t\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(internalToString(explicitValue));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(XAnnotation reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotationType());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotationType().getSimpleName()));\n+\n+\t\tif (reference.getValue() != null) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getValue());\n+\t\t\tbuffer.append(\")\");\n+\t\t} else if (!reference.getElementValuePairs().isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getElementValuePairs().stream().map(evPair -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\n+\t\t\t\tIterable<JvmOperation> declaredOperations = ((JvmAnnotationType) reference.getAnnotationType()).getDeclaredOperations();\n+\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\tJvmOperation operation = evPair.getElement() != null ? evPair.getElement() : valueOperation;\n+\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\tbuilder.append(internalToString(evPair.getValue()));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationValue jvmAnnotationValue) {\n+\t\tEStructuralFeature ref = jvmAnnotationValue.eClass().getEStructuralFeature(\"values\");\n+\t\tif (ref == null) {\n+\t\t\tthrow new IllegalStateException(\"Cannot find feature with name 'values' in \" + jvmAnnotationValue);\n+\t\t}\n+\n+\t\tEList<?> values = (EList<?>) jvmAnnotationValue.eGet(ref);\n+\t\tif (values.size() > 1) {\n+\t\t\treturn \"#[\" + values.stream().map((value) -> internalToString(value)).collect(Collectors.joining(\", \")) + \"]\";\n+\t\t} else {\n+\t\t\treturn internalToString(values.get(0));\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(Object obj) {\n+\t\treturn obj.toString();\n+\t}\n+\n+\tprotected String _internalToString(XTypeLiteral typeLiteral) {\n+\t\tURI uri = EcoreUtil.getURI(typeLiteral.getType());\n+\t\tString text = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, typeLiteral.getType().getSimpleName());\n+\t\treturn text + String.join(\"\", typeLiteral.getArrayDimensions());\n+\t}\n+\n+\tprotected String _internalToString(XListLiteral listLiteral) {\n+\t\treturn \"#[\" + listLiteral.getElements().stream().map(element -> internalToString(element)).collect(Collectors.joining(\", \")) + \"]\";\n+\t}\n+\n+\tprotected String _internalToString(XBinaryOperation binaryOperation) {\n+\t\treturn internalToString(binaryOperation.getLeftOperand()) + \" \" + binaryOperation.getConcreteSyntaxFeatureName() + \" \"\n+\t\t\t\t+ internalToString(binaryOperation.getRightOperand());\n+\t}\n+\n+\tprotected String _internalToString(XStringLiteral stringLiteral) {\n+\t\treturn \"\\\"\" + stringLiteral.getValue() + \"\\\"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjI2NjMyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxNToxNlrOGBMfQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxNToxNlrOGBMfQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwNjM3MA==", "bodyText": "Boolean.toString(booleanLiteral.isIsTrue())", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403906370", "createdAt": "2020-04-06T08:15:16Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotation().getSimpleName()));\n+\n+\t\tList<JvmAnnotationValue> explicitValues = reference.getExplicitValues();\n+\t\tboolean needsExplicitProperties = explicitValues.size() > 1 //\n+\t\t\t\t|| (!explicitValues.isEmpty() && explicitValues.get(0).getOperation() != null //\n+\t\t\t\t\t\t&& !\"value\".equals(explicitValues.get(0).getOperation().getSimpleName()));\n+\n+\t\tif (!explicitValues.isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(explicitValues.stream().map(explicitValue -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\tif (needsExplicitProperties) {\n+\t\t\t\t\tIterable<JvmOperation> declaredOperations = reference.getAnnotation().getDeclaredOperations();\n+\t\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\t\tJvmOperation operation = explicitValue.getOperation() != null ? explicitValue.getOperation() : valueOperation;\n+\t\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(internalToString(explicitValue));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(XAnnotation reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotationType());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotationType().getSimpleName()));\n+\n+\t\tif (reference.getValue() != null) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getValue());\n+\t\t\tbuffer.append(\")\");\n+\t\t} else if (!reference.getElementValuePairs().isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getElementValuePairs().stream().map(evPair -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\n+\t\t\t\tIterable<JvmOperation> declaredOperations = ((JvmAnnotationType) reference.getAnnotationType()).getDeclaredOperations();\n+\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\tJvmOperation operation = evPair.getElement() != null ? evPair.getElement() : valueOperation;\n+\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\tbuilder.append(internalToString(evPair.getValue()));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationValue jvmAnnotationValue) {\n+\t\tEStructuralFeature ref = jvmAnnotationValue.eClass().getEStructuralFeature(\"values\");\n+\t\tif (ref == null) {\n+\t\t\tthrow new IllegalStateException(\"Cannot find feature with name 'values' in \" + jvmAnnotationValue);\n+\t\t}\n+\n+\t\tEList<?> values = (EList<?>) jvmAnnotationValue.eGet(ref);\n+\t\tif (values.size() > 1) {\n+\t\t\treturn \"#[\" + values.stream().map((value) -> internalToString(value)).collect(Collectors.joining(\", \")) + \"]\";\n+\t\t} else {\n+\t\t\treturn internalToString(values.get(0));\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(Object obj) {\n+\t\treturn obj.toString();\n+\t}\n+\n+\tprotected String _internalToString(XTypeLiteral typeLiteral) {\n+\t\tURI uri = EcoreUtil.getURI(typeLiteral.getType());\n+\t\tString text = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, typeLiteral.getType().getSimpleName());\n+\t\treturn text + String.join(\"\", typeLiteral.getArrayDimensions());\n+\t}\n+\n+\tprotected String _internalToString(XListLiteral listLiteral) {\n+\t\treturn \"#[\" + listLiteral.getElements().stream().map(element -> internalToString(element)).collect(Collectors.joining(\", \")) + \"]\";\n+\t}\n+\n+\tprotected String _internalToString(XBinaryOperation binaryOperation) {\n+\t\treturn internalToString(binaryOperation.getLeftOperand()) + \" \" + binaryOperation.getConcreteSyntaxFeatureName() + \" \"\n+\t\t\t\t+ internalToString(binaryOperation.getRightOperand());\n+\t}\n+\n+\tprotected String _internalToString(XStringLiteral stringLiteral) {\n+\t\treturn \"\\\"\" + stringLiteral.getValue() + \"\\\"\";\n+\t}\n+\n+\tprotected String _internalToString(XNumberLiteral numberLiteral) {\n+\t\treturn numberLiteral.getValue();\n+\t}\n+\n+\tprotected String _internalToString(XBooleanLiteral booleanLiteral) {\n+\t\treturn Boolean.valueOf(booleanLiteral.isIsTrue()).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjI2OTQ3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxNjowOFrOGBMhTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwOTowMTowMFrOGDP7eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwNjg5Mg==", "bodyText": "This will look a little weird if the postfix is null since the link is broken.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403906892", "createdAt": "2020-04-06T08:16:08Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotation().getSimpleName()));\n+\n+\t\tList<JvmAnnotationValue> explicitValues = reference.getExplicitValues();\n+\t\tboolean needsExplicitProperties = explicitValues.size() > 1 //\n+\t\t\t\t|| (!explicitValues.isEmpty() && explicitValues.get(0).getOperation() != null //\n+\t\t\t\t\t\t&& !\"value\".equals(explicitValues.get(0).getOperation().getSimpleName()));\n+\n+\t\tif (!explicitValues.isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(explicitValues.stream().map(explicitValue -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\tif (needsExplicitProperties) {\n+\t\t\t\t\tIterable<JvmOperation> declaredOperations = reference.getAnnotation().getDeclaredOperations();\n+\t\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\t\tJvmOperation operation = explicitValue.getOperation() != null ? explicitValue.getOperation() : valueOperation;\n+\t\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(internalToString(explicitValue));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(XAnnotation reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotationType());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotationType().getSimpleName()));\n+\n+\t\tif (reference.getValue() != null) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getValue());\n+\t\t\tbuffer.append(\")\");\n+\t\t} else if (!reference.getElementValuePairs().isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getElementValuePairs().stream().map(evPair -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\n+\t\t\t\tIterable<JvmOperation> declaredOperations = ((JvmAnnotationType) reference.getAnnotationType()).getDeclaredOperations();\n+\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\tJvmOperation operation = evPair.getElement() != null ? evPair.getElement() : valueOperation;\n+\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\tbuilder.append(internalToString(evPair.getValue()));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationValue jvmAnnotationValue) {\n+\t\tEStructuralFeature ref = jvmAnnotationValue.eClass().getEStructuralFeature(\"values\");\n+\t\tif (ref == null) {\n+\t\t\tthrow new IllegalStateException(\"Cannot find feature with name 'values' in \" + jvmAnnotationValue);\n+\t\t}\n+\n+\t\tEList<?> values = (EList<?>) jvmAnnotationValue.eGet(ref);\n+\t\tif (values.size() > 1) {\n+\t\t\treturn \"#[\" + values.stream().map((value) -> internalToString(value)).collect(Collectors.joining(\", \")) + \"]\";\n+\t\t} else {\n+\t\t\treturn internalToString(values.get(0));\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(Object obj) {\n+\t\treturn obj.toString();\n+\t}\n+\n+\tprotected String _internalToString(XTypeLiteral typeLiteral) {\n+\t\tURI uri = EcoreUtil.getURI(typeLiteral.getType());\n+\t\tString text = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, typeLiteral.getType().getSimpleName());\n+\t\treturn text + String.join(\"\", typeLiteral.getArrayDimensions());\n+\t}\n+\n+\tprotected String _internalToString(XListLiteral listLiteral) {\n+\t\treturn \"#[\" + listLiteral.getElements().stream().map(element -> internalToString(element)).collect(Collectors.joining(\", \")) + \"]\";\n+\t}\n+\n+\tprotected String _internalToString(XBinaryOperation binaryOperation) {\n+\t\treturn internalToString(binaryOperation.getLeftOperand()) + \" \" + binaryOperation.getConcreteSyntaxFeatureName() + \" \"\n+\t\t\t\t+ internalToString(binaryOperation.getRightOperand());\n+\t}\n+\n+\tprotected String _internalToString(XStringLiteral stringLiteral) {\n+\t\treturn \"\\\"\" + stringLiteral.getValue() + \"\\\"\";\n+\t}\n+\n+\tprotected String _internalToString(XNumberLiteral numberLiteral) {\n+\t\treturn numberLiteral.getValue();\n+\t}\n+\n+\tprotected String _internalToString(XBooleanLiteral booleanLiteral) {\n+\t\treturn Boolean.valueOf(booleanLiteral.isIsTrue()).toString();\n+\t}\n+\n+\tprotected String _internalToString(XMemberFeatureCall memberFeatureCall) {\n+\t\tif (memberFeatureCall.isPackageFragment()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tString prefix = internalToString(memberFeatureCall.getMemberCallTarget());\n+\t\treturn internalHandleAbstractFeatureCall(prefix, memberFeatureCall);\n+\t}\n+\n+\tprotected String _internalToString(XFeatureCall featureCall) {\n+\t\treturn featureCall.isPackageFragment() ? null : internalHandleAbstractFeatureCall(null, featureCall);\n+\t}\n+\n+\tprotected String internalHandleAbstractFeatureCall(String prefix, XAbstractFeatureCall abstractFeatureCall) {\n+\t\tString postfix = null;\n+\t\tif (abstractFeatureCall.getFeature() != null && !abstractFeatureCall.getFeature().eIsProxy()) {\n+\t\t\tURI uri = EcoreUtil.getURI(abstractFeatureCall.getFeature());\n+\t\t\tpostfix = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, abstractFeatureCall.getConcreteSyntaxFeatureName());\n+\t\t} else {\n+\t\t\tpostfix = abstractFeatureCall.getConcreteSyntaxFeatureName();\n+\t\t}\n+\n+\t\tif (prefix == null) {\n+\t\t\treturn postfix;\n+\t\t} else {\n+\t\t\treturn prefix + \".\" + postfix;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYzNTMwNw==", "bodyText": "Would you recommend logging a error message if the postfix is null, before returning the value on lines 201 and 212?", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r404635307", "createdAt": "2020-04-07T08:37:08Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotation().getSimpleName()));\n+\n+\t\tList<JvmAnnotationValue> explicitValues = reference.getExplicitValues();\n+\t\tboolean needsExplicitProperties = explicitValues.size() > 1 //\n+\t\t\t\t|| (!explicitValues.isEmpty() && explicitValues.get(0).getOperation() != null //\n+\t\t\t\t\t\t&& !\"value\".equals(explicitValues.get(0).getOperation().getSimpleName()));\n+\n+\t\tif (!explicitValues.isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(explicitValues.stream().map(explicitValue -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\tif (needsExplicitProperties) {\n+\t\t\t\t\tIterable<JvmOperation> declaredOperations = reference.getAnnotation().getDeclaredOperations();\n+\t\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\t\tJvmOperation operation = explicitValue.getOperation() != null ? explicitValue.getOperation() : valueOperation;\n+\t\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(internalToString(explicitValue));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(XAnnotation reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotationType());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotationType().getSimpleName()));\n+\n+\t\tif (reference.getValue() != null) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getValue());\n+\t\t\tbuffer.append(\")\");\n+\t\t} else if (!reference.getElementValuePairs().isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getElementValuePairs().stream().map(evPair -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\n+\t\t\t\tIterable<JvmOperation> declaredOperations = ((JvmAnnotationType) reference.getAnnotationType()).getDeclaredOperations();\n+\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\tJvmOperation operation = evPair.getElement() != null ? evPair.getElement() : valueOperation;\n+\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\tbuilder.append(internalToString(evPair.getValue()));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationValue jvmAnnotationValue) {\n+\t\tEStructuralFeature ref = jvmAnnotationValue.eClass().getEStructuralFeature(\"values\");\n+\t\tif (ref == null) {\n+\t\t\tthrow new IllegalStateException(\"Cannot find feature with name 'values' in \" + jvmAnnotationValue);\n+\t\t}\n+\n+\t\tEList<?> values = (EList<?>) jvmAnnotationValue.eGet(ref);\n+\t\tif (values.size() > 1) {\n+\t\t\treturn \"#[\" + values.stream().map((value) -> internalToString(value)).collect(Collectors.joining(\", \")) + \"]\";\n+\t\t} else {\n+\t\t\treturn internalToString(values.get(0));\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(Object obj) {\n+\t\treturn obj.toString();\n+\t}\n+\n+\tprotected String _internalToString(XTypeLiteral typeLiteral) {\n+\t\tURI uri = EcoreUtil.getURI(typeLiteral.getType());\n+\t\tString text = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, typeLiteral.getType().getSimpleName());\n+\t\treturn text + String.join(\"\", typeLiteral.getArrayDimensions());\n+\t}\n+\n+\tprotected String _internalToString(XListLiteral listLiteral) {\n+\t\treturn \"#[\" + listLiteral.getElements().stream().map(element -> internalToString(element)).collect(Collectors.joining(\", \")) + \"]\";\n+\t}\n+\n+\tprotected String _internalToString(XBinaryOperation binaryOperation) {\n+\t\treturn internalToString(binaryOperation.getLeftOperand()) + \" \" + binaryOperation.getConcreteSyntaxFeatureName() + \" \"\n+\t\t\t\t+ internalToString(binaryOperation.getRightOperand());\n+\t}\n+\n+\tprotected String _internalToString(XStringLiteral stringLiteral) {\n+\t\treturn \"\\\"\" + stringLiteral.getValue() + \"\\\"\";\n+\t}\n+\n+\tprotected String _internalToString(XNumberLiteral numberLiteral) {\n+\t\treturn numberLiteral.getValue();\n+\t}\n+\n+\tprotected String _internalToString(XBooleanLiteral booleanLiteral) {\n+\t\treturn Boolean.valueOf(booleanLiteral.isIsTrue()).toString();\n+\t}\n+\n+\tprotected String _internalToString(XMemberFeatureCall memberFeatureCall) {\n+\t\tif (memberFeatureCall.isPackageFragment()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tString prefix = internalToString(memberFeatureCall.getMemberCallTarget());\n+\t\treturn internalHandleAbstractFeatureCall(prefix, memberFeatureCall);\n+\t}\n+\n+\tprotected String _internalToString(XFeatureCall featureCall) {\n+\t\treturn featureCall.isPackageFragment() ? null : internalHandleAbstractFeatureCall(null, featureCall);\n+\t}\n+\n+\tprotected String internalHandleAbstractFeatureCall(String prefix, XAbstractFeatureCall abstractFeatureCall) {\n+\t\tString postfix = null;\n+\t\tif (abstractFeatureCall.getFeature() != null && !abstractFeatureCall.getFeature().eIsProxy()) {\n+\t\t\tURI uri = EcoreUtil.getURI(abstractFeatureCall.getFeature());\n+\t\t\tpostfix = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, abstractFeatureCall.getConcreteSyntaxFeatureName());\n+\t\t} else {\n+\t\t\tpostfix = abstractFeatureCall.getConcreteSyntaxFeatureName();\n+\t\t}\n+\n+\t\tif (prefix == null) {\n+\t\t\treturn postfix;\n+\t\t} else {\n+\t\t\treturn prefix + \".\" + postfix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwNjg5Mg=="}, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY0MDM1Mg==", "bodyText": "No, I don't think an error is necessary. If there is an EMF proxy involved somewhere, this would be revealed to the user as a linking diagnostic or by means of a validation.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r404640352", "createdAt": "2020-04-07T08:45:10Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotation().getSimpleName()));\n+\n+\t\tList<JvmAnnotationValue> explicitValues = reference.getExplicitValues();\n+\t\tboolean needsExplicitProperties = explicitValues.size() > 1 //\n+\t\t\t\t|| (!explicitValues.isEmpty() && explicitValues.get(0).getOperation() != null //\n+\t\t\t\t\t\t&& !\"value\".equals(explicitValues.get(0).getOperation().getSimpleName()));\n+\n+\t\tif (!explicitValues.isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(explicitValues.stream().map(explicitValue -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\tif (needsExplicitProperties) {\n+\t\t\t\t\tIterable<JvmOperation> declaredOperations = reference.getAnnotation().getDeclaredOperations();\n+\t\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\t\tJvmOperation operation = explicitValue.getOperation() != null ? explicitValue.getOperation() : valueOperation;\n+\t\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(internalToString(explicitValue));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(XAnnotation reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotationType());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotationType().getSimpleName()));\n+\n+\t\tif (reference.getValue() != null) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getValue());\n+\t\t\tbuffer.append(\")\");\n+\t\t} else if (!reference.getElementValuePairs().isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getElementValuePairs().stream().map(evPair -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\n+\t\t\t\tIterable<JvmOperation> declaredOperations = ((JvmAnnotationType) reference.getAnnotationType()).getDeclaredOperations();\n+\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\tJvmOperation operation = evPair.getElement() != null ? evPair.getElement() : valueOperation;\n+\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\tbuilder.append(internalToString(evPair.getValue()));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationValue jvmAnnotationValue) {\n+\t\tEStructuralFeature ref = jvmAnnotationValue.eClass().getEStructuralFeature(\"values\");\n+\t\tif (ref == null) {\n+\t\t\tthrow new IllegalStateException(\"Cannot find feature with name 'values' in \" + jvmAnnotationValue);\n+\t\t}\n+\n+\t\tEList<?> values = (EList<?>) jvmAnnotationValue.eGet(ref);\n+\t\tif (values.size() > 1) {\n+\t\t\treturn \"#[\" + values.stream().map((value) -> internalToString(value)).collect(Collectors.joining(\", \")) + \"]\";\n+\t\t} else {\n+\t\t\treturn internalToString(values.get(0));\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(Object obj) {\n+\t\treturn obj.toString();\n+\t}\n+\n+\tprotected String _internalToString(XTypeLiteral typeLiteral) {\n+\t\tURI uri = EcoreUtil.getURI(typeLiteral.getType());\n+\t\tString text = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, typeLiteral.getType().getSimpleName());\n+\t\treturn text + String.join(\"\", typeLiteral.getArrayDimensions());\n+\t}\n+\n+\tprotected String _internalToString(XListLiteral listLiteral) {\n+\t\treturn \"#[\" + listLiteral.getElements().stream().map(element -> internalToString(element)).collect(Collectors.joining(\", \")) + \"]\";\n+\t}\n+\n+\tprotected String _internalToString(XBinaryOperation binaryOperation) {\n+\t\treturn internalToString(binaryOperation.getLeftOperand()) + \" \" + binaryOperation.getConcreteSyntaxFeatureName() + \" \"\n+\t\t\t\t+ internalToString(binaryOperation.getRightOperand());\n+\t}\n+\n+\tprotected String _internalToString(XStringLiteral stringLiteral) {\n+\t\treturn \"\\\"\" + stringLiteral.getValue() + \"\\\"\";\n+\t}\n+\n+\tprotected String _internalToString(XNumberLiteral numberLiteral) {\n+\t\treturn numberLiteral.getValue();\n+\t}\n+\n+\tprotected String _internalToString(XBooleanLiteral booleanLiteral) {\n+\t\treturn Boolean.valueOf(booleanLiteral.isIsTrue()).toString();\n+\t}\n+\n+\tprotected String _internalToString(XMemberFeatureCall memberFeatureCall) {\n+\t\tif (memberFeatureCall.isPackageFragment()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tString prefix = internalToString(memberFeatureCall.getMemberCallTarget());\n+\t\treturn internalHandleAbstractFeatureCall(prefix, memberFeatureCall);\n+\t}\n+\n+\tprotected String _internalToString(XFeatureCall featureCall) {\n+\t\treturn featureCall.isPackageFragment() ? null : internalHandleAbstractFeatureCall(null, featureCall);\n+\t}\n+\n+\tprotected String internalHandleAbstractFeatureCall(String prefix, XAbstractFeatureCall abstractFeatureCall) {\n+\t\tString postfix = null;\n+\t\tif (abstractFeatureCall.getFeature() != null && !abstractFeatureCall.getFeature().eIsProxy()) {\n+\t\t\tURI uri = EcoreUtil.getURI(abstractFeatureCall.getFeature());\n+\t\t\tpostfix = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, abstractFeatureCall.getConcreteSyntaxFeatureName());\n+\t\t} else {\n+\t\t\tpostfix = abstractFeatureCall.getConcreteSyntaxFeatureName();\n+\t\t}\n+\n+\t\tif (prefix == null) {\n+\t\t\treturn postfix;\n+\t\t} else {\n+\t\t\treturn prefix + \".\" + postfix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwNjg5Mg=="}, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY1NzY3OA==", "bodyText": "I understand. Do you want me to keep the code as it is?", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r404657678", "createdAt": "2020-04-07T09:12:25Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotation().getSimpleName()));\n+\n+\t\tList<JvmAnnotationValue> explicitValues = reference.getExplicitValues();\n+\t\tboolean needsExplicitProperties = explicitValues.size() > 1 //\n+\t\t\t\t|| (!explicitValues.isEmpty() && explicitValues.get(0).getOperation() != null //\n+\t\t\t\t\t\t&& !\"value\".equals(explicitValues.get(0).getOperation().getSimpleName()));\n+\n+\t\tif (!explicitValues.isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(explicitValues.stream().map(explicitValue -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\tif (needsExplicitProperties) {\n+\t\t\t\t\tIterable<JvmOperation> declaredOperations = reference.getAnnotation().getDeclaredOperations();\n+\t\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\t\tJvmOperation operation = explicitValue.getOperation() != null ? explicitValue.getOperation() : valueOperation;\n+\t\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(internalToString(explicitValue));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(XAnnotation reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotationType());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotationType().getSimpleName()));\n+\n+\t\tif (reference.getValue() != null) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getValue());\n+\t\t\tbuffer.append(\")\");\n+\t\t} else if (!reference.getElementValuePairs().isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getElementValuePairs().stream().map(evPair -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\n+\t\t\t\tIterable<JvmOperation> declaredOperations = ((JvmAnnotationType) reference.getAnnotationType()).getDeclaredOperations();\n+\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\tJvmOperation operation = evPair.getElement() != null ? evPair.getElement() : valueOperation;\n+\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\tbuilder.append(internalToString(evPair.getValue()));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationValue jvmAnnotationValue) {\n+\t\tEStructuralFeature ref = jvmAnnotationValue.eClass().getEStructuralFeature(\"values\");\n+\t\tif (ref == null) {\n+\t\t\tthrow new IllegalStateException(\"Cannot find feature with name 'values' in \" + jvmAnnotationValue);\n+\t\t}\n+\n+\t\tEList<?> values = (EList<?>) jvmAnnotationValue.eGet(ref);\n+\t\tif (values.size() > 1) {\n+\t\t\treturn \"#[\" + values.stream().map((value) -> internalToString(value)).collect(Collectors.joining(\", \")) + \"]\";\n+\t\t} else {\n+\t\t\treturn internalToString(values.get(0));\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(Object obj) {\n+\t\treturn obj.toString();\n+\t}\n+\n+\tprotected String _internalToString(XTypeLiteral typeLiteral) {\n+\t\tURI uri = EcoreUtil.getURI(typeLiteral.getType());\n+\t\tString text = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, typeLiteral.getType().getSimpleName());\n+\t\treturn text + String.join(\"\", typeLiteral.getArrayDimensions());\n+\t}\n+\n+\tprotected String _internalToString(XListLiteral listLiteral) {\n+\t\treturn \"#[\" + listLiteral.getElements().stream().map(element -> internalToString(element)).collect(Collectors.joining(\", \")) + \"]\";\n+\t}\n+\n+\tprotected String _internalToString(XBinaryOperation binaryOperation) {\n+\t\treturn internalToString(binaryOperation.getLeftOperand()) + \" \" + binaryOperation.getConcreteSyntaxFeatureName() + \" \"\n+\t\t\t\t+ internalToString(binaryOperation.getRightOperand());\n+\t}\n+\n+\tprotected String _internalToString(XStringLiteral stringLiteral) {\n+\t\treturn \"\\\"\" + stringLiteral.getValue() + \"\\\"\";\n+\t}\n+\n+\tprotected String _internalToString(XNumberLiteral numberLiteral) {\n+\t\treturn numberLiteral.getValue();\n+\t}\n+\n+\tprotected String _internalToString(XBooleanLiteral booleanLiteral) {\n+\t\treturn Boolean.valueOf(booleanLiteral.isIsTrue()).toString();\n+\t}\n+\n+\tprotected String _internalToString(XMemberFeatureCall memberFeatureCall) {\n+\t\tif (memberFeatureCall.isPackageFragment()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tString prefix = internalToString(memberFeatureCall.getMemberCallTarget());\n+\t\treturn internalHandleAbstractFeatureCall(prefix, memberFeatureCall);\n+\t}\n+\n+\tprotected String _internalToString(XFeatureCall featureCall) {\n+\t\treturn featureCall.isPackageFragment() ? null : internalHandleAbstractFeatureCall(null, featureCall);\n+\t}\n+\n+\tprotected String internalHandleAbstractFeatureCall(String prefix, XAbstractFeatureCall abstractFeatureCall) {\n+\t\tString postfix = null;\n+\t\tif (abstractFeatureCall.getFeature() != null && !abstractFeatureCall.getFeature().eIsProxy()) {\n+\t\t\tURI uri = EcoreUtil.getURI(abstractFeatureCall.getFeature());\n+\t\t\tpostfix = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, abstractFeatureCall.getConcreteSyntaxFeatureName());\n+\t\t} else {\n+\t\t\tpostfix = abstractFeatureCall.getConcreteSyntaxFeatureName();\n+\t\t}\n+\n+\t\tif (prefix == null) {\n+\t\t\treturn postfix;\n+\t\t} else {\n+\t\t\treturn prefix + \".\" + postfix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwNjg5Mg=="}, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1OTg5Ng==", "bodyText": "Ok", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r406059896", "createdAt": "2020-04-09T09:01:00Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/hover/JvmAnnotationReferencePrinter.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.hover;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmAnnotationValue;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.hover.html.XtextElementLinks;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XBinaryOperation;\n+import org.eclipse.xtext.xbase.XBooleanLiteral;\n+import org.eclipse.xtext.xbase.XFeatureCall;\n+import org.eclipse.xtext.xbase.XListLiteral;\n+import org.eclipse.xtext.xbase.XMemberFeatureCall;\n+import org.eclipse.xtext.xbase.XNumberLiteral;\n+import org.eclipse.xtext.xbase.XStringLiteral;\n+import org.eclipse.xtext.xbase.XTypeLiteral;\n+import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * Provides a HTML representation for {@code JvmAnnotationReference}s to be used in the hover.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class JvmAnnotationReferencePrinter {\n+\n+\t/**\n+\t * @return the HTML representation for the passed {@code reference}\n+\t * @throws NullPointerException\n+\t *             if the {@code reference} is {@code null}\n+\t */\n+\tpublic String toHtmlString(JvmAnnotationReference reference) {\n+\t\tPreconditions.checkNotNull(reference);\n+\t\treturn internalToString(reference);\n+\t}\n+\n+\tprotected String internalToString(Object obj) {\n+\t\tif (obj instanceof XBinaryOperation) {\n+\t\t\treturn _internalToString((XBinaryOperation) obj);\n+\t\t} else if (obj instanceof XFeatureCall) {\n+\t\t\treturn _internalToString((XFeatureCall) obj);\n+\t\t} else if (obj instanceof XListLiteral) {\n+\t\t\treturn _internalToString((XListLiteral) obj);\n+\t\t} else if (obj instanceof XMemberFeatureCall) {\n+\t\t\treturn _internalToString((XMemberFeatureCall) obj);\n+\t\t} else if (obj instanceof XBooleanLiteral) {\n+\t\t\treturn _internalToString((XBooleanLiteral) obj);\n+\t\t} else if (obj instanceof XNumberLiteral) {\n+\t\t\treturn _internalToString((XNumberLiteral) obj);\n+\t\t} else if (obj instanceof XStringLiteral) {\n+\t\t\treturn _internalToString((XStringLiteral) obj);\n+\t\t} else if (obj instanceof XTypeLiteral) {\n+\t\t\treturn _internalToString((XTypeLiteral) obj);\n+\t\t} else if (obj instanceof XAnnotation) {\n+\t\t\treturn _internalToString((XAnnotation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationReference) {\n+\t\t\treturn _internalToString((JvmAnnotationReference) obj);\n+\t\t} else if (obj instanceof JvmAnnotationValue) {\n+\t\t\treturn _internalToString((JvmAnnotationValue) obj);\n+\t\t} else {\n+\t\t\treturn _internalToString(obj);\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationReference reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotation());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotation().getSimpleName()));\n+\n+\t\tList<JvmAnnotationValue> explicitValues = reference.getExplicitValues();\n+\t\tboolean needsExplicitProperties = explicitValues.size() > 1 //\n+\t\t\t\t|| (!explicitValues.isEmpty() && explicitValues.get(0).getOperation() != null //\n+\t\t\t\t\t\t&& !\"value\".equals(explicitValues.get(0).getOperation().getSimpleName()));\n+\n+\t\tif (!explicitValues.isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(explicitValues.stream().map(explicitValue -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\t\tif (needsExplicitProperties) {\n+\t\t\t\t\tIterable<JvmOperation> declaredOperations = reference.getAnnotation().getDeclaredOperations();\n+\t\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\t\tJvmOperation operation = explicitValue.getOperation() != null ? explicitValue.getOperation() : valueOperation;\n+\t\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(internalToString(explicitValue));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(XAnnotation reference) {\n+\t\tStringBuilder buffer = new StringBuilder();\n+\t\tbuffer.append(\"@\");\n+\t\tURI uri = EcoreUtil.getURI(reference.getAnnotationType());\n+\t\tbuffer.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, reference.getAnnotationType().getSimpleName()));\n+\n+\t\tif (reference.getValue() != null) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getValue());\n+\t\t\tbuffer.append(\")\");\n+\t\t} else if (!reference.getElementValuePairs().isEmpty()) {\n+\t\t\tbuffer.append(\"(\");\n+\t\t\tbuffer.append(reference.getElementValuePairs().stream().map(evPair -> {\n+\t\t\t\tStringBuilder builder = new StringBuilder();\n+\n+\t\t\t\tIterable<JvmOperation> declaredOperations = ((JvmAnnotationType) reference.getAnnotationType()).getDeclaredOperations();\n+\t\t\t\tJvmOperation valueOperation = Iterables.tryFind(declaredOperations, o -> \"value\".equals(o.getSimpleName())).orNull();\n+\t\t\t\tJvmOperation operation = evPair.getElement() != null ? evPair.getElement() : valueOperation;\n+\t\t\t\tURI operationUri = EcoreUtil.getURI(operation);\n+\t\t\t\tbuilder.append(createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, operationUri, operation.getSimpleName()));\n+\t\t\t\tbuilder.append(\"=\");\n+\t\t\t\tbuilder.append(internalToString(evPair.getValue()));\n+\t\t\t\treturn builder.toString();\n+\t\t\t}).collect(Collectors.joining(\", \")));\n+\t\t\tbuffer.append(\")\");\n+\t\t}\n+\n+\t\treturn buffer.toString();\n+\t}\n+\n+\tprotected String _internalToString(JvmAnnotationValue jvmAnnotationValue) {\n+\t\tEStructuralFeature ref = jvmAnnotationValue.eClass().getEStructuralFeature(\"values\");\n+\t\tif (ref == null) {\n+\t\t\tthrow new IllegalStateException(\"Cannot find feature with name 'values' in \" + jvmAnnotationValue);\n+\t\t}\n+\n+\t\tEList<?> values = (EList<?>) jvmAnnotationValue.eGet(ref);\n+\t\tif (values.size() > 1) {\n+\t\t\treturn \"#[\" + values.stream().map((value) -> internalToString(value)).collect(Collectors.joining(\", \")) + \"]\";\n+\t\t} else {\n+\t\t\treturn internalToString(values.get(0));\n+\t\t}\n+\t}\n+\n+\tprotected String _internalToString(Object obj) {\n+\t\treturn obj.toString();\n+\t}\n+\n+\tprotected String _internalToString(XTypeLiteral typeLiteral) {\n+\t\tURI uri = EcoreUtil.getURI(typeLiteral.getType());\n+\t\tString text = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, typeLiteral.getType().getSimpleName());\n+\t\treturn text + String.join(\"\", typeLiteral.getArrayDimensions());\n+\t}\n+\n+\tprotected String _internalToString(XListLiteral listLiteral) {\n+\t\treturn \"#[\" + listLiteral.getElements().stream().map(element -> internalToString(element)).collect(Collectors.joining(\", \")) + \"]\";\n+\t}\n+\n+\tprotected String _internalToString(XBinaryOperation binaryOperation) {\n+\t\treturn internalToString(binaryOperation.getLeftOperand()) + \" \" + binaryOperation.getConcreteSyntaxFeatureName() + \" \"\n+\t\t\t\t+ internalToString(binaryOperation.getRightOperand());\n+\t}\n+\n+\tprotected String _internalToString(XStringLiteral stringLiteral) {\n+\t\treturn \"\\\"\" + stringLiteral.getValue() + \"\\\"\";\n+\t}\n+\n+\tprotected String _internalToString(XNumberLiteral numberLiteral) {\n+\t\treturn numberLiteral.getValue();\n+\t}\n+\n+\tprotected String _internalToString(XBooleanLiteral booleanLiteral) {\n+\t\treturn Boolean.valueOf(booleanLiteral.isIsTrue()).toString();\n+\t}\n+\n+\tprotected String _internalToString(XMemberFeatureCall memberFeatureCall) {\n+\t\tif (memberFeatureCall.isPackageFragment()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tString prefix = internalToString(memberFeatureCall.getMemberCallTarget());\n+\t\treturn internalHandleAbstractFeatureCall(prefix, memberFeatureCall);\n+\t}\n+\n+\tprotected String _internalToString(XFeatureCall featureCall) {\n+\t\treturn featureCall.isPackageFragment() ? null : internalHandleAbstractFeatureCall(null, featureCall);\n+\t}\n+\n+\tprotected String internalHandleAbstractFeatureCall(String prefix, XAbstractFeatureCall abstractFeatureCall) {\n+\t\tString postfix = null;\n+\t\tif (abstractFeatureCall.getFeature() != null && !abstractFeatureCall.getFeature().eIsProxy()) {\n+\t\t\tURI uri = EcoreUtil.getURI(abstractFeatureCall.getFeature());\n+\t\t\tpostfix = createLinkWithLabel(XtextElementLinks.XTEXTDOC_SCHEME, uri, abstractFeatureCall.getConcreteSyntaxFeatureName());\n+\t\t} else {\n+\t\t\tpostfix = abstractFeatureCall.getConcreteSyntaxFeatureName();\n+\t\t}\n+\n+\t\tif (prefix == null) {\n+\t\t\treturn postfix;\n+\t\t} else {\n+\t\t\treturn prefix + \".\" + postfix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwNjg5Mg=="}, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjI3Njg3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/labeling/XbaseImageAdornments.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxODoxM1rOGBMl4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxODoxM1rOGBMl4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwODA2NQ==", "bodyText": "Feels weird to have or in Java as a method, but I understand the reasoning behind it.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403908065", "createdAt": "2020-04-06T08:18:13Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/labeling/XbaseImageAdornments.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*******************************************************************************\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.xbase.ui.labeling;\n+\n+import static org.eclipse.jdt.ui.JavaElementImageDescriptor.*;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.util.DeprecationUtil;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * Used for calculating the Image adornments.\n+ */\n+public class XbaseImageAdornments {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t/**\n+\t * @return an {@code Integer} value representing the adornment to be rendered for a given {@code identifiableElement}\n+\t */\n+\tpublic int get(JvmIdentifiableElement identifiableElement) {\n+\t\tif (identifiableElement instanceof JvmConstructor) {\n+\t\t\treturn _get((JvmConstructor) identifiableElement);\n+\t\t} else if (identifiableElement instanceof JvmOperation) {\n+\t\t\treturn _get((JvmOperation) identifiableElement);\n+\t\t} else if (identifiableElement instanceof JvmField) {\n+\t\t\treturn _get((JvmField) identifiableElement);\n+\t\t} else if (identifiableElement instanceof JvmDeclaredType) {\n+\t\t\treturn _get((JvmDeclaredType) identifiableElement);\n+\t\t} else if (identifiableElement != null) {\n+\t\t\treturn _get(identifiableElement);\n+\t\t} else {\n+\t\t\treturn _get((Void) null);\n+\t\t}\n+\t}\n+\n+\tprotected int _get(JvmDeclaredType jvmDeclaredType) {\n+\t\tint abstract0 = or(0, jvmDeclaredType.isAbstract(), ABSTRACT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjI4MjQwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/labeling/XbaseLabelProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxOTo0MFrOGBMpGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxOTo0MFrOGBMpGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwODg5MA==", "bodyText": "Use Collectors.joining(delimiter, prefix, suffix)", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403908890", "createdAt": "2020-04-06T08:19:40Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/labeling/XbaseLabelProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.labeling;\n+\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider;\n+import org.eclipse.jface.resource.ImageDescriptor;\n+import org.eclipse.jface.viewers.StyledString;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmEnumerationType;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmTypeParameter;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider;\n+import org.eclipse.xtext.xbase.XVariableDeclaration;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedField;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+import org.eclipse.xtext.xbase.validation.UIStrings;\n+import org.eclipse.xtext.xtype.XImportDeclaration;\n+import org.eclipse.xtext.xtype.XImportSection;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Provides the text and image for the label of a a given element.\n+ */\n+public class XbaseLabelProvider extends DefaultEObjectLabelProvider {\n+\n+\t@Inject\n+\tprivate XbaseImages2 images;\n+\n+\t@Inject\n+\tprivate UIStrings uiStrings;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\t@Inject\n+\tprivate XbaseImageAdornments adornments;\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices services;\n+\n+\t@Inject\n+\tpublic XbaseLabelProvider(AdapterFactoryLabelProvider delegate) {\n+\t\tsuper(delegate);\n+\t}\n+\n+\t/**\n+\t * @return the {@code ImageDescriptor} for a given {@code obj}\n+\t * @throws NullPointerException\n+\t *             if the passed {@code obj} is null\n+\t */\n+\tprotected ImageDescriptor imageDescriptor(Object obj) {\n+\t\tPreconditions.checkNotNull(obj);\n+\n+\t\tif (obj instanceof JvmConstructor) {\n+\t\t\treturn _imageDescriptor((JvmConstructor) obj);\n+\t\t} else if (obj instanceof JvmOperation) {\n+\t\t\treturn _imageDescriptor((JvmOperation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationType) {\n+\t\t\treturn _imageDescriptor((JvmAnnotationType) obj);\n+\t\t} else if (obj instanceof JvmEnumerationType) {\n+\t\t\treturn _imageDescriptor((JvmEnumerationType) obj);\n+\t\t} else if (obj instanceof JvmField) {\n+\t\t\treturn _imageDescriptor((JvmField) obj);\n+\t\t} else if (obj instanceof JvmGenericType) {\n+\t\t\treturn _imageDescriptor((JvmGenericType) obj);\n+\t\t} else if (obj instanceof JvmTypeParameter) {\n+\t\t\treturn _imageDescriptor((JvmTypeParameter) obj);\n+\t\t} else if (obj instanceof JvmFormalParameter) {\n+\t\t\treturn _imageDescriptor((JvmFormalParameter) obj);\n+\t\t} else if (obj instanceof XVariableDeclaration) {\n+\t\t\treturn _imageDescriptor((XVariableDeclaration) obj);\n+\t\t} else if (obj instanceof IResolvedConstructor) {\n+\t\t\treturn _imageDescriptor((IResolvedConstructor) obj);\n+\t\t} else if (obj instanceof IResolvedOperation) {\n+\t\t\treturn _imageDescriptor((IResolvedOperation) obj);\n+\t\t} else if (obj instanceof XImportDeclaration) {\n+\t\t\treturn _imageDescriptor((XImportDeclaration) obj);\n+\t\t} else if (obj instanceof XImportSection) {\n+\t\t\treturn _imageDescriptor((XImportSection) obj);\n+\t\t} else if (obj instanceof IResolvedField) {\n+\t\t\treturn _imageDescriptor((IResolvedField) obj);\n+\t\t} else {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(XImportSection importSection) {\n+\t\treturn images.forImportContainer();\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(XImportDeclaration importDeclaration) {\n+\t\treturn images.forImport();\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmGenericType genericType) {\n+\t\treturn genericType.isInterface() // \n+\t\t\t\t? images.forInterface(genericType.getVisibility(), adornments.get(genericType)) //\n+\t\t\t\t: images.forClass(genericType.getVisibility(), adornments.get(genericType));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmEnumerationType enumerationType) {\n+\t\treturn images.forEnum(enumerationType.getVisibility(), adornments.get(enumerationType));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmAnnotationType annotationType) {\n+\t\treturn images.forAnnotation(annotationType.getVisibility(), adornments.get(annotationType));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmOperation operation) {\n+\t\treturn images.forOperation(operation.getVisibility(), adornments.get(operation));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(IResolvedOperation operation) {\n+\t\treturn imageDescriptor(operation.getDeclaration());\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmConstructor constructor) {\n+\t\treturn images.forConstructor(constructor.getVisibility(), adornments.get(constructor));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(IResolvedConstructor constructor) {\n+\t\treturn _imageDescriptor(constructor.getDeclaration());\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(IResolvedField field) {\n+\t\treturn _imageDescriptor(field.getDeclaration());\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmField field) {\n+\t\treturn images.forField(field.getVisibility(), adornments.get(field));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmFormalParameter parameter) {\n+\t\treturn images.forLocalVariable(adornments.get(parameter));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(XVariableDeclaration variableDeclaration) {\n+\t\treturn images.forLocalVariable(adornments.get(variableDeclaration));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmTypeParameter parameter) {\n+\t\treturn images.forTypeParameter(adornments.get(parameter));\n+\t}\n+\n+\tprotected String text(JvmConstructor constructor) {\n+\t\treturn \"new\" + uiStrings.parameters(constructor);\n+\t}\n+\n+\tprotected String text(JvmGenericType genericType) {\n+\t\treturn genericType.getSimpleName();\n+\t}\n+\n+\tprotected Object text(JvmOperation element) {\n+\t\treturn signature(element.getSimpleName(), element);\n+\t}\n+\n+\tprotected Object text(IResolvedOperation element) {\n+\t\tString returnTypeString = element.getResolvedReturnType().getSimpleName();\n+\t\tString decoratedPart = \" : \" + returnTypeString;\n+\t\tif (!element.getTypeParameters().isEmpty()) {\n+\t\t\tdecoratedPart = \" <\" + uiStrings.toString(element.getTypeParameters()) + \"> : \" + returnTypeString;\n+\t\t}\n+\n+\t\tString styledString = element.getDeclaration().getSimpleName() + \"(\"\n+\t\t\t\t+ element.getResolvedParameterTypes().stream().map(type -> type.getHumanReadableName()).collect(Collectors.joining(\", \"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjI4MzIzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/labeling/XbaseLabelProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxOTo1MlrOGBMpmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoxOTo1MlrOGBMpmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkwOTAxOQ==", "bodyText": "Same", "url": "https://github.com/eclipse/xtext-eclipse/pull/1390#discussion_r403909019", "createdAt": "2020-04-06T08:19:52Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/labeling/XbaseLabelProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.labeling;\n+\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider;\n+import org.eclipse.jface.resource.ImageDescriptor;\n+import org.eclipse.jface.viewers.StyledString;\n+import org.eclipse.xtext.common.types.JvmAnnotationType;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmEnumerationType;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmTypeParameter;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider;\n+import org.eclipse.xtext.xbase.XVariableDeclaration;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedField;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+import org.eclipse.xtext.xbase.validation.UIStrings;\n+import org.eclipse.xtext.xtype.XImportDeclaration;\n+import org.eclipse.xtext.xtype.XImportSection;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Provides the text and image for the label of a a given element.\n+ */\n+public class XbaseLabelProvider extends DefaultEObjectLabelProvider {\n+\n+\t@Inject\n+\tprivate XbaseImages2 images;\n+\n+\t@Inject\n+\tprivate UIStrings uiStrings;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\t@Inject\n+\tprivate XbaseImageAdornments adornments;\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices services;\n+\n+\t@Inject\n+\tpublic XbaseLabelProvider(AdapterFactoryLabelProvider delegate) {\n+\t\tsuper(delegate);\n+\t}\n+\n+\t/**\n+\t * @return the {@code ImageDescriptor} for a given {@code obj}\n+\t * @throws NullPointerException\n+\t *             if the passed {@code obj} is null\n+\t */\n+\tprotected ImageDescriptor imageDescriptor(Object obj) {\n+\t\tPreconditions.checkNotNull(obj);\n+\n+\t\tif (obj instanceof JvmConstructor) {\n+\t\t\treturn _imageDescriptor((JvmConstructor) obj);\n+\t\t} else if (obj instanceof JvmOperation) {\n+\t\t\treturn _imageDescriptor((JvmOperation) obj);\n+\t\t} else if (obj instanceof JvmAnnotationType) {\n+\t\t\treturn _imageDescriptor((JvmAnnotationType) obj);\n+\t\t} else if (obj instanceof JvmEnumerationType) {\n+\t\t\treturn _imageDescriptor((JvmEnumerationType) obj);\n+\t\t} else if (obj instanceof JvmField) {\n+\t\t\treturn _imageDescriptor((JvmField) obj);\n+\t\t} else if (obj instanceof JvmGenericType) {\n+\t\t\treturn _imageDescriptor((JvmGenericType) obj);\n+\t\t} else if (obj instanceof JvmTypeParameter) {\n+\t\t\treturn _imageDescriptor((JvmTypeParameter) obj);\n+\t\t} else if (obj instanceof JvmFormalParameter) {\n+\t\t\treturn _imageDescriptor((JvmFormalParameter) obj);\n+\t\t} else if (obj instanceof XVariableDeclaration) {\n+\t\t\treturn _imageDescriptor((XVariableDeclaration) obj);\n+\t\t} else if (obj instanceof IResolvedConstructor) {\n+\t\t\treturn _imageDescriptor((IResolvedConstructor) obj);\n+\t\t} else if (obj instanceof IResolvedOperation) {\n+\t\t\treturn _imageDescriptor((IResolvedOperation) obj);\n+\t\t} else if (obj instanceof XImportDeclaration) {\n+\t\t\treturn _imageDescriptor((XImportDeclaration) obj);\n+\t\t} else if (obj instanceof XImportSection) {\n+\t\t\treturn _imageDescriptor((XImportSection) obj);\n+\t\t} else if (obj instanceof IResolvedField) {\n+\t\t\treturn _imageDescriptor((IResolvedField) obj);\n+\t\t} else {\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(XImportSection importSection) {\n+\t\treturn images.forImportContainer();\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(XImportDeclaration importDeclaration) {\n+\t\treturn images.forImport();\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmGenericType genericType) {\n+\t\treturn genericType.isInterface() // \n+\t\t\t\t? images.forInterface(genericType.getVisibility(), adornments.get(genericType)) //\n+\t\t\t\t: images.forClass(genericType.getVisibility(), adornments.get(genericType));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmEnumerationType enumerationType) {\n+\t\treturn images.forEnum(enumerationType.getVisibility(), adornments.get(enumerationType));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmAnnotationType annotationType) {\n+\t\treturn images.forAnnotation(annotationType.getVisibility(), adornments.get(annotationType));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmOperation operation) {\n+\t\treturn images.forOperation(operation.getVisibility(), adornments.get(operation));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(IResolvedOperation operation) {\n+\t\treturn imageDescriptor(operation.getDeclaration());\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmConstructor constructor) {\n+\t\treturn images.forConstructor(constructor.getVisibility(), adornments.get(constructor));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(IResolvedConstructor constructor) {\n+\t\treturn _imageDescriptor(constructor.getDeclaration());\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(IResolvedField field) {\n+\t\treturn _imageDescriptor(field.getDeclaration());\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmField field) {\n+\t\treturn images.forField(field.getVisibility(), adornments.get(field));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmFormalParameter parameter) {\n+\t\treturn images.forLocalVariable(adornments.get(parameter));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(XVariableDeclaration variableDeclaration) {\n+\t\treturn images.forLocalVariable(adornments.get(variableDeclaration));\n+\t}\n+\n+\tprotected ImageDescriptor _imageDescriptor(JvmTypeParameter parameter) {\n+\t\treturn images.forTypeParameter(adornments.get(parameter));\n+\t}\n+\n+\tprotected String text(JvmConstructor constructor) {\n+\t\treturn \"new\" + uiStrings.parameters(constructor);\n+\t}\n+\n+\tprotected String text(JvmGenericType genericType) {\n+\t\treturn genericType.getSimpleName();\n+\t}\n+\n+\tprotected Object text(JvmOperation element) {\n+\t\treturn signature(element.getSimpleName(), element);\n+\t}\n+\n+\tprotected Object text(IResolvedOperation element) {\n+\t\tString returnTypeString = element.getResolvedReturnType().getSimpleName();\n+\t\tString decoratedPart = \" : \" + returnTypeString;\n+\t\tif (!element.getTypeParameters().isEmpty()) {\n+\t\t\tdecoratedPart = \" <\" + uiStrings.toString(element.getTypeParameters()) + \"> : \" + returnTypeString;\n+\t\t}\n+\n+\t\tString styledString = element.getDeclaration().getSimpleName() + \"(\"\n+\t\t\t\t+ element.getResolvedParameterTypes().stream().map(type -> type.getHumanReadableName()).collect(Collectors.joining(\", \"))\n+\t\t\t\t+ \")\";\n+\t\treturn new StyledString(styledString).append(new StyledString(decoratedPart, StyledString.DECORATIONS_STYLER));\n+\t}\n+\n+\tprotected Object text(IResolvedConstructor constructor) {\n+\t\tString styledString = \"new(\" + constructor.getResolvedParameterTypes().stream().map(type -> type.getHumanReadableName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d27c3d3d167800ba040cba435f5af0f4b3f1c8a"}, "originalPosition": 193}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 829, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}