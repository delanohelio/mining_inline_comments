{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2MjcyMDAy", "number": 1387, "title": "Migrating a subset of Xtend code from org.eclipse.xtext.xbase.ui project to Java", "bodyText": "Migrated subset of Xtend code to Java\n Ran the Maven/Gradle build locally\n\nSigned-off-by: nbhusare neerajbhusare@gmail.com", "createdAt": "2020-03-31T11:36:00Z", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387", "merged": true, "mergeCommit": {"oid": "f0a6f5c3eacdebdaf9167284e122be2305d21b21"}, "closed": true, "closedAt": "2020-04-03T14:55:57Z", "author": {"login": "nbhusare"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTBkAygFqTM4NDY0NzYwNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUCEUtAFqTM4NzMyNjAwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NjQ3NjA2", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-384647606", "createdAt": "2020-03-31T11:39:53Z", "commit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTozOTo1M1rOF-RmCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTozOTo1M1rOF-RmCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NDI5Ng==", "bodyText": "Added a safety-check which was not present in the original code. The code project.findPackageFragmentRoots(sourceFolder) may return an empty array.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400844296", "createdAt": "2020-03-31T11:39:53Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NjQ4OTE0", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-384648914", "createdAt": "2020-03-31T11:41:52Z", "commit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo0MTo1MlrOF-RqRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo0MTo1MlrOF-RqRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NTM4Mw==", "bodyText": "Logging an error message. I chose to do it after looking at other places in the source code where JavaModelException is caught. Please suggest if you would like me to replace with a RuntimeException.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400845383", "createdAt": "2020-03-31T11:41:52Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NjQ5Mzcx", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-384649371", "createdAt": "2020-03-31T11:42:35Z", "commit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo0MjozNVrOF-RrxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo0MjozNVrOF-RrxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NTc2NA==", "bodyText": "Simplified the logic. The original code made use of a while-loop to find the first element for which the \u201clanguageInfo.equals(candidate.getLanguage())\u201d is true. I do the same using the new code\nIterables.tryFind - Returns an Optional containing the first element in iterable that satisfies the given predicate, if such an element exists.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400845764", "createdAt": "2020-03-31T11:42:35Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource != null) {\n+\t\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\t\tif (original != input) {\n+\t\t\t\treturn original;\n+\t\t\t}\n+\n+\t\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\t\tif (trace == null) {\n+\t\t\t\treturn input;\n+\t\t\t}\n+\n+\t\t\tOptional<? extends ILocationInEclipseResource> sourceInformation = Iterables.tryFind(trace.getAllAssociatedLocations(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 137}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NjUwMTAw", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-384650100", "createdAt": "2020-03-31T11:43:39Z", "commit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo0MzozOVrOF-RuPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo0MzozOVrOF-RuPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NjM5OQ==", "bodyText": "Added a safety-check here.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400846399", "createdAt": "2020-03-31T11:43:39Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource != null) {\n+\t\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\t\tif (original != input) {\n+\t\t\t\treturn original;\n+\t\t\t}\n+\n+\t\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\t\tif (trace == null) {\n+\t\t\t\treturn input;\n+\t\t\t}\n+\n+\t\t\tOptional<? extends ILocationInEclipseResource> sourceInformation = Iterables.tryFind(trace.getAllAssociatedLocations(),\n+\t\t\t\t\t(candidate) -> languageInfo.equals(candidate.getLanguage()));\n+\n+\t\t\tif (!sourceInformation.isPresent()) {\n+\t\t\t\treturn input;\n+\t\t\t}\n+\n+\t\t\tIStorage originalStorage = sourceInformation.get().getPlatformResource();\n+\t\t\tif (originalStorage != null) {\n+\t\t\t\treturn EditorUtils.createEditorInput(originalStorage);\n+\t\t\t}\n+\t\t}\n+\t\treturn input;\n+\t}\n+\n+\t/**\n+\t * @return the {@code IPackageFragmentRoot} that contains the provided {@code element}\n+\t * @throws NullPointerException\n+\t *             if the provided {@code element} is null\n+\t */\n+\tpublic IPackageFragmentRoot getPackageFragmentRoot(IJavaElement element) {\n+\t\tPreconditions.checkNotNull(element, \"Couldn't find source package fragment root.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NjUxNjI4", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-384651628", "createdAt": "2020-03-31T11:46:04Z", "commit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo0NjowNVrOF-RzFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo0NjowNVrOF-RzFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NzYzNg==", "bodyText": "org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService is deprecated. We'll have to revisit this code and replace the deprecated API with the correct one. Corresponding change needs to be made in the XbaseUiModule#bindCopyQualifiedNameService() method.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400847636", "createdAt": "2020-03-31T11:46:05Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NjUyNjEy", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-384652612", "createdAt": "2020-03-31T11:47:29Z", "commit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo0NzoyOVrOF-R14g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo0NzoyOVrOF-R14g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA==", "bodyText": "FluentIterable - A bit of inspiration from @szarnekow code.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400848354", "createdAt": "2020-03-31T11:47:29Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else if (constructor == null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Unhandled parameter types: \" + Arrays.asList(constructor, constructorCall).toString());\n+\t\t}\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 148}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NzczNjM3", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-384773637", "createdAt": "2020-03-31T14:11:47Z", "commit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNDoxMTo0OFrOF-Xxdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNDoyNjozOVrOF-YfTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk0NTUyNg==", "bodyText": "Either add the ! before both equals, or do && -> ||", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400945526", "createdAt": "2020-03-31T14:11:48Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/contentassist/XbaseContentProposalPriorities.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.contentassist;\n+\n+import org.eclipse.jface.text.contentassist.ICompletionProposal;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal;\n+import org.eclipse.xtext.ui.editor.contentassist.ContentProposalPriorities;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.scoping.batch.SimpleIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.scoping.batch.StaticFeatureDescriptionWithTypeLiteralReceiver;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class XbaseContentProposalPriorities extends ContentProposalPriorities {\n+\n+\t@Override\n+\tpublic void adjustCrossReferencePriority(ICompletionProposal proposal, String prefix) {\n+\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n+\t\t\tConfigurableCompletionProposal configurableProposal = (ConfigurableCompletionProposal) proposal;\n+\t\t\tObject desc = configurableProposal.getAdditionalData(XbaseProposalProvider.DESCRIPTION_KEY);\n+\t\t\tif (desc instanceof SimpleIdentifiableElementDescription) {\n+\t\t\t\tif (!(\"this\".equals(configurableProposal.getReplacementString())\n+\t\t\t\t\t\t&& \"super\".equals(configurableProposal.getReplacementString()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk0OTM3Mw==", "bodyText": "Going to leave this one for @szarnekow", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400949373", "createdAt": "2020-03-31T14:16:47Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NTM4Mw=="}, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk0OTYzMQ==", "bodyText": "Seems fine to me especially with the extra log", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400949631", "createdAt": "2020-03-31T14:17:05Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NDI5Ng=="}, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1MDI3MA==", "bodyText": "Might be better to just write if (resource == null) return input;", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400950270", "createdAt": "2020-03-31T14:17:50Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1MTc5MA==", "bodyText": "LGTM", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400951790", "createdAt": "2020-03-31T14:19:45Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource != null) {\n+\t\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\t\tif (original != input) {\n+\t\t\t\treturn original;\n+\t\t\t}\n+\n+\t\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\t\tif (trace == null) {\n+\t\t\t\treturn input;\n+\t\t\t}\n+\n+\t\t\tOptional<? extends ILocationInEclipseResource> sourceInformation = Iterables.tryFind(trace.getAllAssociatedLocations(),\n+\t\t\t\t\t(candidate) -> languageInfo.equals(candidate.getLanguage()));\n+\n+\t\t\tif (!sourceInformation.isPresent()) {\n+\t\t\t\treturn input;\n+\t\t\t}\n+\n+\t\t\tIStorage originalStorage = sourceInformation.get().getPlatformResource();\n+\t\t\tif (originalStorage != null) {\n+\t\t\t\treturn EditorUtils.createEditorInput(originalStorage);\n+\t\t\t}\n+\t\t}\n+\t\treturn input;\n+\t}\n+\n+\t/**\n+\t * @return the {@code IPackageFragmentRoot} that contains the provided {@code element}\n+\t * @throws NullPointerException\n+\t *             if the provided {@code element} is null\n+\t */\n+\tpublic IPackageFragmentRoot getPackageFragmentRoot(IJavaElement element) {\n+\t\tPreconditions.checkNotNull(element, \"Couldn't find source package fragment root.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NjM5OQ=="}, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1MjkwNg==", "bodyText": "You can remove this, it's impossible to end up here, I don't if you leave it though", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400952906", "createdAt": "2020-03-31T14:21:05Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else if (constructor == null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Unhandled parameter types: \" + Arrays.asList(constructor, constructorCall).toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1NDQxOQ==", "bodyText": "constructor*", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400954419", "createdAt": "2020-03-31T14:23:05Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else if (constructor == null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Unhandled parameter types: \" + Arrays.asList(constructor, constructorCall).toString());\n+\t\t}\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)\n+\t\t\t\t.filter(constr -> constr.getDeclaration().equals(consturctor)) //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1NzI2MA==", "bodyText": "Does this work if declaredConstructors is null?", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r400957260", "createdAt": "2020-03-31T14:26:39Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else if (constructor == null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Unhandled parameter types: \" + Arrays.asList(constructor, constructorCall).toString());\n+\t\t}\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA=="}, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 148}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888", "author": {"user": {"login": "nbhusare", "name": "Neeraj Bhusare"}}, "url": "https://github.com/eclipse/xtext-eclipse/commit/3f972df3abd1c588fa29e30466c29b4c79693888", "committedDate": "2020-03-31T11:06:10Z", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>"}, "afterCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238", "author": {"user": {"login": "nbhusare", "name": "Neeraj Bhusare"}}, "url": "https://github.com/eclipse/xtext-eclipse/commit/996ded0b113e8053e5981ac3285d564f4fede238", "committedDate": "2020-03-31T20:39:49Z", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MTE2Nzgz", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-385116783", "createdAt": "2020-03-31T21:26:19Z", "commit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMToyNjoxOVrOF-o15w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTo1NToyM1rOF-prPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNTE5MQ==", "bodyText": "This will fall through to the super.adjust.. call. Not sure if that was the intention in the xtend code.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401225191", "createdAt": "2020-03-31T21:26:19Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/contentassist/XbaseContentProposalPriorities.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.contentassist;\n+\n+import org.eclipse.jface.text.contentassist.ICompletionProposal;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal;\n+import org.eclipse.xtext.ui.editor.contentassist.ContentProposalPriorities;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.scoping.batch.SimpleIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.scoping.batch.StaticFeatureDescriptionWithTypeLiteralReceiver;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class XbaseContentProposalPriorities extends ContentProposalPriorities {\n+\n+\t@Override\n+\tpublic void adjustCrossReferencePriority(ICompletionProposal proposal, String prefix) {\n+\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n+\t\t\tConfigurableCompletionProposal configurableProposal = (ConfigurableCompletionProposal) proposal;\n+\t\t\tObject desc = configurableProposal.getAdditionalData(XbaseProposalProvider.DESCRIPTION_KEY);\n+\t\t\tif (desc instanceof SimpleIdentifiableElementDescription) {\n+\t\t\t\tif (!\"this\".equals(configurableProposal.getReplacementString())\n+\t\t\t\t\t\t&& !\"super\".equals(configurableProposal.getReplacementString())) {\n+\t\t\t\t\tadjustPriority(proposal, prefix, 570);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t} else if (desc instanceof StaticFeatureDescriptionWithTypeLiteralReceiver) {\n+\t\t\t\tadjustPriority(proposal, prefix, 560);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNjk4MQ==", "bodyText": "Please only log on error level if the exception is not e.isDoesNotExist()", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401226981", "createdAt": "2020-03-31T21:30:04Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NTM4Mw=="}, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNzY5MQ==", "bodyText": "We probably want to use org.eclipse.jdt.core.IJavaElement.getAncestor(int) here", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401227691", "createdAt": "2020-03-31T21:31:40Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\tif (original != input) {\n+\t\t\treturn original;\n+\t\t}\n+\n+\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\tif (trace == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tOptional<? extends ILocationInEclipseResource> sourceInformation = Iterables.tryFind(trace.getAllAssociatedLocations(),\n+\t\t\t\t(candidate) -> languageInfo.equals(candidate.getLanguage()));\n+\n+\t\tif (!sourceInformation.isPresent()) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tIStorage originalStorage = sourceInformation.get().getPlatformResource();\n+\t\tif (originalStorage != null) {\n+\t\t\treturn EditorUtils.createEditorInput(originalStorage);\n+\t\t}\n+\t\t\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @return the {@code IPackageFragmentRoot} that contains the provided {@code element}\n+\t * @throws NullPointerException\n+\t *             if the provided {@code element} is null\n+\t */\n+\tpublic IPackageFragmentRoot getPackageFragmentRoot(IJavaElement element) {\n+\t\tPreconditions.checkNotNull(element, \"Couldn't find source package fragment root.\");\n+\t\treturn element instanceof IPackageFragmentRoot ? (IPackageFragmentRoot) element : getPackageFragmentRoot(element.getParent());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyOTMwNw==", "bodyText": "Iff we change this code, we could loop over all matching packageFragmentRoots until you find one that fulfills newFile.exists() below.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401229307", "createdAt": "2020-03-31T21:35:04Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyOTc2NA==", "bodyText": "Populating a list to loop over the list on step later appears to be unnecessary. Maybe extract a few smaller methods to improve the readability and avoid the intermediate list here?", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401229764", "createdAt": "2020-03-31T21:36:07Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzMDE2Ng==", "bodyText": "Same comment here as a few lines below: We create unnecessary lists and end up with a very long method. Maybe it's better to refactor this by extracting a few smaller methods.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401230166", "createdAt": "2020-03-31T21:36:58Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzMjUzMA==", "bodyText": "I'd prefer a more straight forward\nfor(PlatformResource candidate: trace.getAllAssociatedLocations()) {\n  if (languageInfo.equals(candidate.getLanguage()) {\n    IStorage storage = candidate.getPlatformResource();\n    if (storage != null) {\n      return ..\n    }\n  }\n}\nreturn input;", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401232530", "createdAt": "2020-03-31T21:42:05Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tList<IPackageFragmentRoot> packageFragmentRoots = new ArrayList<>();\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tpackageFragmentRoots.add(root);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot source : packageFragmentRoots) {\n+\t\t\t\t\t\t\t\tIPath fullPath = source.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tList<IClasspathEntry> classpathEntries = new ArrayList<>();\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tclasspathEntries.add(classpathEntry);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t\n+\t\t\t\t\t\tfor (IClasspathEntry sourceFolder : classpathEntries) {\n+\t\t\t\t\t\t\tif (sourceFolder.getOutputLocation() != null && sourceFolder.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(sourceFolder.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\tOptional<IPackageFragmentRoot> source = FluentIterable.from(project.findPackageFragmentRoots(sourceFolder))\n+\t\t\t\t\t\t\t\t\t\t.first();\n+\t\t\t\t\t\t\t\tif (source.isPresent()) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = source.get().getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\tif (original != input) {\n+\t\t\treturn original;\n+\t\t}\n+\n+\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\tif (trace == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tOptional<? extends ILocationInEclipseResource> sourceInformation = Iterables.tryFind(trace.getAllAssociatedLocations(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzMzQ0NA==", "bodyText": "Please take a look at the conversion that was applied to the org.eclipse.xtext.naming.DefaultCopyQualifiedNameService - there we use a PolymorphicDispatcher.\nI'm afraid we have to do the same here in order to remain backwards compatible.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401233444", "createdAt": "2020-03-31T21:43:54Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NzYzNg=="}, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNDQ3MA==", "bodyText": "declaredConstructors will still be null if resolvedFeatures is null.\nThese null checks look a little too xtendy to me. Many of the intermediate local vars will never be null if the actual receiver was present.\nPlease reverse the logic and exit early but otherwise keep a normal flow.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401234470", "createdAt": "2020-03-31T21:46:06Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else if (constructor == null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Unhandled parameter types: \" + Arrays.asList(constructor, constructorCall).toString());\n+\t\t}\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA=="}, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNDU4NQ==", "bodyText": "Typo in variable name", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401234585", "createdAt": "2020-03-31T21:46:23Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} \n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)\n+\t\t\t\t.filter(declaredConstructor -> declaredConstructor.getDeclaration().equals(consturctor)) //\n+\t\t\t\t.first();\n+\t\treturn resolvedConstructor.isPresent() ? resolvedConstructor.get() : null;\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor constructor, XConstructorCall constructorCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(constructorCall);\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstrutor = FluentIterable.from(declaredConstructors)\n+\t\t\t\t.filter(constr -> constr.getDeclaration().equals(constructor)) //\n+\t\t\t\t.first();\n+\t\treturn resolvedConstrutor.isPresent() ? resolvedConstrutor.get() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNjUyOA==", "bodyText": "Also my preference would always be something like\nfor(IResolvedConstructor candidate: declaredConstructors) {\n  if (constructor.equals(candidate.getDeclaration()) {\n    return candidate;\n }\n}\nreturn null", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401236528", "createdAt": "2020-03-31T21:50:20Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else if (constructor == null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Unhandled parameter types: \" + Arrays.asList(constructor, constructorCall).toString());\n+\t\t}\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0ODM1NA=="}, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNjYxMw==", "bodyText": "Typo in parameter name", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401236613", "createdAt": "2020-03-31T21:50:30Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} \n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNzEzNA==", "bodyText": "Not sure how often we do similar things in the code base, but I can imagine this logic to be moved to ResolvedFeatures, e.g. findResolvedOperation(JvmOperation declaration)", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401237134", "createdAt": "2020-03-31T21:51:44Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t} \n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor consturctor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstructor = FluentIterable.from(declaredConstructors)\n+\t\t\t\t.filter(declaredConstructor -> declaredConstructor.getDeclaration().equals(consturctor)) //\n+\t\t\t\t.first();\n+\t\treturn resolvedConstructor.isPresent() ? resolvedConstructor.get() : null;\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor constructor, XConstructorCall constructorCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(constructorCall);\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedConstructor> declaredConstructors = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tdeclaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t}\n+\n+\t\tOptional<IResolvedConstructor> resolvedConstrutor = FluentIterable.from(declaredConstructors)\n+\t\t\t\t.filter(constr -> constr.getDeclaration().equals(constructor)) //\n+\t\t\t\t.first();\n+\t\treturn resolvedConstrutor.isPresent() ? resolvedConstrutor.get() : null;\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmOperation operation, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tLightweightTypeReference actualType = null;\n+\t\tif (actualReceiver != null) {\n+\t\t\tactualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t}\n+\n+\t\tResolvedFeatures resolvedFeatures = null;\n+\t\tif (actualType != null) {\n+\t\t\tresolvedFeatures = overrideHelper.getResolvedFeatures(actualType);\n+\t\t}\n+\n+\t\tList<IResolvedOperation> allOperations = null;\n+\t\tif (resolvedFeatures != null) {\n+\t\t\tallOperations = resolvedFeatures.getAllOperations();\n+\t\t}\n+\n+\t\tOptional<IResolvedOperation> resolvedOperation = FluentIterable.from(allOperations)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzODc3Nw==", "bodyText": "Not a big fan of these usages of optionals. Checking for isPresent is usually not good style. You probably want to do something like Iterables.tryFind(..).transform(node->getOffset() + 1).or(compositeNode::getEndOffset)", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401238777", "createdAt": "2020-03-31T21:55:12Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/util/InsertionOffsets.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.util;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+public class InsertionOffsets {\n+\n+\tpublic int before(EObject element) {\n+\t\treturn NodeModelUtils.findActualNodeFor(element).getOffset();\n+\t}\n+\n+\tpublic int after(EObject element) {\n+\t\treturn NodeModelUtils.findActualNodeFor(element).getEndOffset();\n+\t}\n+\n+\tpublic int inEmpty(EObject element) {\n+\t\tICompositeNode compositeNode = NodeModelUtils.findActualNodeFor(element);\n+\t\tOptional<ILeafNode> openingBraceNode = Iterables.tryFind(compositeNode.getLeafNodes(), (node) -> \"{\".equals(node.getText()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzODg0NQ==", "bodyText": "Or preferably a plain for loop.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r401238845", "createdAt": "2020-03-31T21:55:23Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/util/InsertionOffsets.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.util;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.Iterables;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ */\n+public class InsertionOffsets {\n+\n+\tpublic int before(EObject element) {\n+\t\treturn NodeModelUtils.findActualNodeFor(element).getOffset();\n+\t}\n+\n+\tpublic int after(EObject element) {\n+\t\treturn NodeModelUtils.findActualNodeFor(element).getEndOffset();\n+\t}\n+\n+\tpublic int inEmpty(EObject element) {\n+\t\tICompositeNode compositeNode = NodeModelUtils.findActualNodeFor(element);\n+\t\tOptional<ILeafNode> openingBraceNode = Iterables.tryFind(compositeNode.getLeafNodes(), (node) -> \"{\".equals(node.getText()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzODc3Nw=="}, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238", "author": {"user": {"login": "nbhusare", "name": "Neeraj Bhusare"}}, "url": "https://github.com/eclipse/xtext-eclipse/commit/996ded0b113e8053e5981ac3285d564f4fede238", "committedDate": "2020-03-31T20:39:49Z", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>"}, "afterCommit": {"oid": "053a448c376f5a427bfd21bacb85c9e6a560abfd", "author": {"user": {"login": "nbhusare", "name": "Neeraj Bhusare"}}, "url": "https://github.com/eclipse/xtext-eclipse/commit/053a448c376f5a427bfd21bacb85c9e6a560abfd", "committedDate": "2020-04-01T20:33:39Z", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MTU2ODU0", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-386156854", "createdAt": "2020-04-02T07:08:30Z", "commit": {"oid": "053a448c376f5a427bfd21bacb85c9e6a560abfd"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNzowODozMVrOF_d94g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNzozOToxM1rOF_e4tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA5NTU4Ng==", "bodyText": "It's the opposite of what I tried to suggest: Only log, ig it is not e.isDoesNotExist()", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402095586", "createdAt": "2020-04-02T07:08:31Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = root.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tif (classpathEntry.getOutputLocation() != null\n+\t\t\t\t\t\t\t\t\t\t&& classpathEntry.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath()\n+\t\t\t\t\t\t\t\t\t\t\t.removeFirstSegments(classpathEntry.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.findPackageFragmentRoots(classpathEntry)) {\n+\t\t\t\t\t\t\t\t\t\tIPath fullPath = root.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tif (e.isDoesNotExist()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "053a448c376f5a427bfd21bacb85c9e6a560abfd"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA5NjE2MA==", "bodyText": "The semantics of getAncestor do already imply the check of the element itself. Can be implemented as return (IPackageFragmentRoot) element.getAncestor()", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402096160", "createdAt": "2020-04-02T07:09:43Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file\n+\t\t\t\tif (fileExtensionProvider.isValid(resource.getFullPath().getFileExtension())) {\n+\t\t\t\t\tIJavaProject project = JavaCore.create(resource.getProject());\n+\t\t\t\t\tif (project.exists()) {\n+\n+\t\t\t\t\t\t// Check if it's sitting in the output dir, look for original one\n+\t\t\t\t\t\tif (project.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\tIPath relative = resource.getFullPath().removeFirstSegments(project.getOutputLocation().segmentCount());\n+\n+\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.getPackageFragmentRoots()) {\n+\t\t\t\t\t\t\t\tif (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n+\t\t\t\t\t\t\t\t\tIPath fullPath = root.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t// Check if it's sitting in one of the output folders set on the source folders\n+\t\t\t\t\t\tfor (IClasspathEntry classpathEntry : project.getRawClasspath()) {\n+\t\t\t\t\t\t\tif (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n+\t\t\t\t\t\t\t\tif (classpathEntry.getOutputLocation() != null\n+\t\t\t\t\t\t\t\t\t\t&& classpathEntry.getOutputLocation().isPrefixOf(resource.getFullPath())) {\n+\t\t\t\t\t\t\t\t\tIPath relative = resource.getFullPath()\n+\t\t\t\t\t\t\t\t\t\t\t.removeFirstSegments(classpathEntry.getOutputLocation().segmentCount());\n+\t\t\t\t\t\t\t\t\tfor (IPackageFragmentRoot root : project.findPackageFragmentRoots(classpathEntry)) {\n+\t\t\t\t\t\t\t\t\t\tIPath fullPath = root.getCorrespondingResource().getProjectRelativePath().append(relative);\n+\t\t\t\t\t\t\t\t\t\tIFile newFile = resource.getProject().getFile(fullPath);\n+\t\t\t\t\t\t\t\t\t\tif (newFile.exists()) {\n+\t\t\t\t\t\t\t\t\t\t\treturn new FileEditorInput(newFile);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (JavaModelException e) {\n+\t\t\tif (e.isDoesNotExist()) {\n+\t\t\t\tLOG.error(\"Error finding the original source for the editor input\", e);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\tpublic IEditorInput findOriginalSource(IEditorInput input) {\n+\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\tif (resource == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tIEditorInput original = findOriginalSourceForOuputFolderCopy(input);\n+\t\tif (original != input) {\n+\t\t\treturn original;\n+\t\t}\n+\n+\t\tIEclipseTrace trace = traceInformation.getTraceToSource(resource);\n+\t\tif (trace == null) {\n+\t\t\treturn input;\n+\t\t}\n+\n+\t\tfor (ILocationInEclipseResource candidate : trace.getAllAssociatedLocations()) {\n+\t\t\tif (languageInfo.equals(candidate.getLanguage())) {\n+\t\t\t\tIStorage storage = candidate.getPlatformResource();\n+\t\t\t\tif (storage != null) {\n+\t\t\t\t\treturn EditorUtils.createEditorInput(storage);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn input;\n+\t}\n+\n+\t/**\n+\t * @return the {@code IPackageFragmentRoot} that contains the provided {@code element}\n+\t * @throws NullPointerException\n+\t *             if the provided {@code element} is null\n+\t */\n+\tpublic IPackageFragmentRoot getPackageFragmentRoot(IJavaElement element) {\n+\t\tPreconditions.checkNotNull(element, \"Couldn't find source package fragment root.\");\n+\t\treturn element instanceof IPackageFragmentRoot //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "053a448c376f5a427bfd21bacb85c9e6a560abfd"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA5NjcyMA==", "bodyText": "Code is duplicated in the method below.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402096720", "createdAt": "2020-04-02T07:11:02Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\tprotected String toQualifiedName(JvmExecutable jvmExecutable) {\n+\t\treturn toFullyQualifiedName(jvmExecutable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(jvmExecutable.getParameters(), (parameter) -> parameter.getParameterType().getSimpleName()) + \")\";\n+\t}\n+\n+\tprotected String toQualifiedName(XExpression expression, IResolvedExecutable resolvedExecutable, JvmExecutable executable,\n+\t\t\tIResolvedTypes resolvedTypes, List<XExpression> arguments) {\n+\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(expression);\n+\t\tif (actualType != null && !actualType.isAny() && !actualType.isUnknown()) {\n+\t\t\treturn actualType.getHumanReadableName();\n+\t\t}\n+\n+\t\tint index = arguments.indexOf(expression);\n+\t\tif (resolvedExecutable == null) {\n+\t\t\treturn executable.getParameters().get(index).getParameterType().getSimpleName();\n+\t\t}\n+\t\treturn resolvedExecutable.getResolvedParameterTypes().get(index).getSimpleName();\n+\t}\n+\n+\t@Override\n+\tpublic String getQualifiedName(EObject constructor, EObject constructorCall) {\n+\t\tif (constructor instanceof JvmConstructor && constructorCall instanceof XConstructorCall) {\n+\t\t\treturn _getQualifiedName((JvmConstructor) constructor, (XConstructorCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall instanceof XAbstractFeatureCall) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (XAbstractFeatureCall) constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, constructorCall);\n+\t\t} else if (constructor instanceof JvmExecutable && constructorCall == null) {\n+\t\t\treturn _getQualifiedName((JvmExecutable) constructor, (Void) null);\n+\t\t} else if (constructor != null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName(constructor, constructorCall);\n+\t\t} else if (constructor != null && constructorCall == null) {\n+\t\t\treturn _getQualifiedName(constructor, (Void) null);\n+\t\t} else if (constructor == null && constructorCall != null) {\n+\t\t\treturn _getQualifiedName((Void) null, constructorCall);\n+\t\t} else {\n+\t\t\treturn _getQualifiedName((Void) null, (Void) null);\n+\t\t}\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, EObject context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable jvmExecutable, Void context) {\n+\t\treturn toQualifiedName(jvmExecutable);\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmExecutable executable, XAbstractFeatureCall featureCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(featureCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(executable, featureCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(executable) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(featureCall.getActualArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, executable, resolvedTypes,\n+\t\t\t\t\t\t\t\tfeatureCall.getActualArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected String _getQualifiedName(JvmConstructor constructor, XConstructorCall constructorCall) {\n+\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(constructorCall);\n+\t\tIResolvedExecutable resolvedExecutable = resolveExecutable(constructor, constructorCall, resolvedTypes);\n+\t\treturn toFullyQualifiedName(constructor) //\n+\t\t\t\t+ \"(\" + toQualifiedNames(constructorCall.getArguments(), //\n+\t\t\t\t\t\t(argument) -> toQualifiedName(argument, resolvedExecutable, constructor, resolvedTypes,\n+\t\t\t\t\t\t\t\tconstructorCall.getArguments()))\n+\t\t\t\t+ \")\";\n+\t}\n+\n+\tprotected IResolvedExecutable resolveExecutable(JvmExecutable consturctor, XExpression expression, IResolvedTypes resolvedTypes) {\n+\t\tif (consturctor instanceof JvmConstructor && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmConstructor && expression instanceof XConstructorCall) {\n+\t\t\treturn _resolveExecutable((JvmConstructor) consturctor, (XConstructorCall) expression, resolvedTypes);\n+\t\t} else if (consturctor instanceof JvmOperation && expression instanceof XAbstractFeatureCall) {\n+\t\t\treturn _resolveExecutable((JvmOperation) consturctor, (XAbstractFeatureCall) expression, resolvedTypes);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Unhandled parameter types: \" + Arrays.asList(consturctor, expression, resolvedTypes).toString());\n+\t\t}\n+\t}\n+\n+\tprotected IResolvedExecutable _resolveExecutable(JvmConstructor constructor, XAbstractFeatureCall featureCall,\n+\t\t\tIResolvedTypes resolvedTypes) {\n+\t\tXExpression actualReceiver = featureCall.getActualReceiver();\n+\t\tif (actualReceiver != null) {\n+\t\t\tLightweightTypeReference actualType = resolvedTypes.getActualType(actualReceiver);\n+\t\t\tResolvedFeatures resolvedFeatures = overrideHelper.getResolvedFeatures(actualType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "053a448c376f5a427bfd21bacb85c9e6a560abfd"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEwODk4NA==", "bodyText": "eclipse/xtext-extras#581", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402108984", "createdAt": "2020-04-02T07:36:00Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/copyqualifiedname/XbaseCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor.copyqualifiedname;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.ui.editor.copyqualifiedname.DefaultCopyQualifiedNameService;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XConstructorCall;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.collect.FluentIterable;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @author Anton Kosyakov - Initial contribution and API\n+ * @since 2.4\n+ */\n+public class XbaseCopyQualifiedNameService extends DefaultCopyQualifiedNameService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NzYzNg=="}, "originalCommit": {"oid": "3f972df3abd1c588fa29e30466c29b4c79693888"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMDY0NQ==", "bodyText": "I think this was a bug in the old impl.", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402110645", "createdAt": "2020-04-02T07:39:13Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/contentassist/XbaseContentProposalPriorities.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.contentassist;\n+\n+import org.eclipse.jface.text.contentassist.ICompletionProposal;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal;\n+import org.eclipse.xtext.ui.editor.contentassist.ContentProposalPriorities;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.scoping.batch.SimpleIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.scoping.batch.StaticFeatureDescriptionWithTypeLiteralReceiver;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class XbaseContentProposalPriorities extends ContentProposalPriorities {\n+\n+\t@Override\n+\tpublic void adjustCrossReferencePriority(ICompletionProposal proposal, String prefix) {\n+\t\tif (proposal instanceof ConfigurableCompletionProposal) {\n+\t\t\tConfigurableCompletionProposal configurableProposal = (ConfigurableCompletionProposal) proposal;\n+\t\t\tObject desc = configurableProposal.getAdditionalData(XbaseProposalProvider.DESCRIPTION_KEY);\n+\t\t\tif (desc instanceof SimpleIdentifiableElementDescription) {\n+\t\t\t\tif (!\"this\".equals(configurableProposal.getReplacementString())\n+\t\t\t\t\t\t&& !\"super\".equals(configurableProposal.getReplacementString())) {\n+\t\t\t\t\tadjustPriority(proposal, prefix, 570);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t} else if (desc instanceof StaticFeatureDescriptionWithTypeLiteralReceiver) {\n+\t\t\t\tadjustPriority(proposal, prefix, 560);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNTE5MQ=="}, "originalCommit": {"oid": "996ded0b113e8053e5981ac3285d564f4fede238"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MTkyNDc1", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-386192475", "createdAt": "2020-04-02T08:05:06Z", "commit": {"oid": "053a448c376f5a427bfd21bacb85c9e6a560abfd"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODowNTowNlrOF_fx7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwODowNToyM1rOF_fydQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNTI5NA==", "bodyText": "I would early return here as well, also this doesn't need to be in try catch, try to keep it as small as possible", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402125294", "createdAt": "2020-04-02T08:05:06Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "053a448c376f5a427bfd21bacb85c9e6a560abfd"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNTQyOQ==", "bodyText": "s/if/If/", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#discussion_r402125429", "createdAt": "2020-04-02T08:05:23Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.xbase.ui/src/org/eclipse/xtext/xbase/ui/editor/XbaseEditorInputRedirector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ui.editor;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.core.resources.IFile;\n+import org.eclipse.core.resources.IStorage;\n+import org.eclipse.core.runtime.IPath;\n+import org.eclipse.jdt.core.IClasspathEntry;\n+import org.eclipse.jdt.core.IJavaElement;\n+import org.eclipse.jdt.core.IJavaProject;\n+import org.eclipse.jdt.core.IPackageFragmentRoot;\n+import org.eclipse.jdt.core.ITypeRoot;\n+import org.eclipse.jdt.core.JavaCore;\n+import org.eclipse.jdt.core.JavaModelException;\n+import org.eclipse.ui.IEditorInput;\n+import org.eclipse.ui.ide.ResourceUtil;\n+import org.eclipse.ui.part.FileEditorInput;\n+import org.eclipse.xtext.LanguageInfo;\n+import org.eclipse.xtext.resource.FileExtensionProvider;\n+import org.eclipse.xtext.ui.editor.utils.EditorUtils;\n+import org.eclipse.xtext.ui.generator.trace.IEclipseTrace;\n+import org.eclipse.xtext.ui.generator.trace.ILocationInEclipseResource;\n+import org.eclipse.xtext.ui.generator.trace.ITraceForStorageProvider;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.inject.Inject;\n+\n+public class XbaseEditorInputRedirector {\n+\n+\tprivate final static Logger LOG = Logger.getLogger(XbaseEditorInputRedirector.class);\n+\n+\t@Inject\n+\tprivate ITraceForStorageProvider traceInformation;\n+\n+\t@Inject\n+\tprivate LanguageInfo languageInfo;\n+\n+\t@Inject\n+\tprivate FileExtensionProvider fileExtensionProvider;\n+\n+\tpublic ITypeRoot getTypeRoot(IEditorInput editorInput) {\n+\t\tIJavaElement adapter = editorInput.getAdapter(IJavaElement.class);\n+\t\treturn adapter instanceof ITypeRoot ? (ITypeRoot) adapter : null;\n+\t}\n+\n+\t/**\n+\t * @return the original source for an editor input that points to an Xtext resource copied to the output folder, the given input\n+\t *         otherwise\n+\t */\n+\tpublic IEditorInput findOriginalSourceForOuputFolderCopy(IEditorInput input) {\n+\t\ttry {\n+\t\t\tIFile resource = ResourceUtil.getFile(input);\n+\t\t\tif (resource != null) {\n+\t\t\t\t// if the given resource is already pointing to a language file", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "053a448c376f5a427bfd21bacb85c9e6a560abfd"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b084a1a7d2d0f83a135237db245bc3f9d267a306", "author": {"user": {"login": "nbhusare", "name": "Neeraj Bhusare"}}, "url": "https://github.com/eclipse/xtext-eclipse/commit/b084a1a7d2d0f83a135237db245bc3f9d267a306", "committedDate": "2020-04-02T19:50:08Z", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "053a448c376f5a427bfd21bacb85c9e6a560abfd", "author": {"user": {"login": "nbhusare", "name": "Neeraj Bhusare"}}, "url": "https://github.com/eclipse/xtext-eclipse/commit/053a448c376f5a427bfd21bacb85c9e6a560abfd", "committedDate": "2020-04-01T20:33:39Z", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>"}, "afterCommit": {"oid": "b084a1a7d2d0f83a135237db245bc3f9d267a306", "author": {"user": {"login": "nbhusare", "name": "Neeraj Bhusare"}}, "url": "https://github.com/eclipse/xtext-eclipse/commit/b084a1a7d2d0f83a135237db245bc3f9d267a306", "committedDate": "2020-04-02T19:50:08Z", "message": "Migrating the Xtend code from org.eclipse.xtext.xbase.ui project to Java\n\nSigned-off-by: nbhusare <neerajbhusare@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3Mjk5MzA1", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-387299305", "createdAt": "2020-04-03T14:19:03Z", "commit": {"oid": "b084a1a7d2d0f83a135237db245bc3f9d267a306"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MzIzNTI4", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-387323528", "createdAt": "2020-04-03T14:46:19Z", "commit": {"oid": "b084a1a7d2d0f83a135237db245bc3f9d267a306"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MzI2MDAy", "url": "https://github.com/eclipse/xtext-eclipse/pull/1387#pullrequestreview-387326002", "createdAt": "2020-04-03T14:49:06Z", "commit": {"oid": "b084a1a7d2d0f83a135237db245bc3f9d267a306"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4500, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}