{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1NzM1MzUx", "number": 1592, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo0ODo0MFrOE9Fb4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1Mjo1M1rOE9FgWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDg3NjUwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo0ODo0MFrOH5lPMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo0ODo0MFrOH5lPMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MDk3Nw==", "bodyText": "change the local parameter name from it to event", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530140977", "createdAt": "2020-11-25T06:48:40Z", "author": {"login": "miklossy"}, "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDg3NzIyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo0OTowMlrOH5lPjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo0OTowMlrOH5lPjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MTA2OQ==", "bodyText": "change the local parameter name from it to command", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530141069", "createdAt": "2020-11-25T06:49:02Z", "author": {"login": "miklossy"}, "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDg3Nzk3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo0OToyNFrOH5lP_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo0OToyNFrOH5lP_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MTE4MQ==", "bodyText": "change the local parameter name from it to names", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530141181", "createdAt": "2020-11-25T06:49:24Z", "author": {"login": "miklossy"}, "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDg4MTg4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1MDo1NlrOH5lSMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1MDo1NlrOH5lSMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MTc0NA==", "bodyText": "set a space before - and +", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530141744", "createdAt": "2020-11-25T06:50:56Z", "author": {"login": "miklossy"}, "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDg4NDc4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1MjowMVrOH5lTvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1MjowMVrOH5lTvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MjE0Mg==", "bodyText": "change the local parameter name from it to names", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530142142", "createdAt": "2020-11-25T06:52:01Z", "author": {"login": "miklossy"}, "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);\n+\t}\n+\n+\tprivate String getLongestName(List<String> it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDg4NTYxOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1MjoxOFrOH5lUMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1MjoxOFrOH5lUMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MjI1OA==", "bodyText": "change the local parameter name from it to sm", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530142258", "createdAt": "2020-11-25T06:52:18Z", "author": {"login": "miklossy"}, "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);\n+\t}\n+\n+\tprivate String getLongestName(List<String> it) {\n+\t\treturn Iterables.getFirst(IterableExtensions.sortBy(it, s -> -s.length()), null);\n+\t}\n+\n+\tprivate boolean hasResetEvents(Statemachine it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDg4Njk0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1MjozN1rOH5lU1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1MjozN1rOH5lU1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MjQyMw==", "bodyText": "change the local parameter name from it to sm", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530142423", "createdAt": "2020-11-25T06:52:37Z", "author": {"login": "miklossy"}, "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);\n+\t}\n+\n+\tprivate String getLongestName(List<String> it) {\n+\t\treturn Iterables.getFirst(IterableExtensions.sortBy(it, s -> -s.length()), null);\n+\t}\n+\n+\tprivate boolean hasResetEvents(Statemachine it) {\n+\t\treturn !it.getResetEvents().isEmpty();\n+\t}\n+\n+\tprivate boolean hasCommands(Statemachine it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDg4NzMzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1Mjo0M1rOH5lVCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1Mjo0M1rOH5lVCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MjQ3Mw==", "bodyText": "change the local parameter name from it to sm", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530142473", "createdAt": "2020-11-25T06:52:43Z", "author": {"login": "miklossy"}, "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);\n+\t}\n+\n+\tprivate String getLongestName(List<String> it) {\n+\t\treturn Iterables.getFirst(IterableExtensions.sortBy(it, s -> -s.length()), null);\n+\t}\n+\n+\tprivate boolean hasResetEvents(Statemachine it) {\n+\t\treturn !it.getResetEvents().isEmpty();\n+\t}\n+\n+\tprivate boolean hasCommands(Statemachine it) {\n+\t\treturn !it.getCommands().isEmpty();\n+\t}\n+\n+\tprivate boolean hasStates(Statemachine it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDg4NzkzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1Mjo1M1rOH5lVXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo1Mjo1M1rOH5lVXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE0MjU1Ng==", "bodyText": "change the local parameter name from it to state", "url": "https://github.com/eclipse/xtext-eclipse/pull/1592#discussion_r530142556", "createdAt": "2020-11-25T06:52:53Z", "author": {"login": "miklossy"}, "path": "org.eclipse.xtext.xtext.ui.examples/projects/fowlerdsl/org.eclipse.xtext.example.fowlerdsl/src/org/eclipse/xtext/example/fowlerdsl/formatting2/StatemachineFormatter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.example.fowlerdsl.formatting2;\n+\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.COMMAND__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.EVENT__NAME;\n+import static org.eclipse.xtext.example.fowlerdsl.statemachine.StatemachinePackage.Literals.STATE__NAME;\n+\n+import java.util.List;\n+\n+import org.eclipse.xtext.example.fowlerdsl.services.StatemachineGrammarAccess;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Command;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Event;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.State;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Statemachine;\n+import org.eclipse.xtext.example.fowlerdsl.statemachine.Transition;\n+import org.eclipse.xtext.formatting2.AbstractJavaFormatter;\n+import org.eclipse.xtext.formatting2.IFormattableDocument;\n+import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class StatemachineFormatter extends AbstractJavaFormatter {\n+\n+\t@Inject\n+\tprivate StatemachineGrammarAccess ga;\n+\n+\tprotected void format(Statemachine sm, IFormattableDocument document) {\n+\t\tformatEvents(sm, document);\n+\t\tformatResetEvents(sm, document);\n+\t\tformatCommands(sm, document);\n+\t\tformatStates(sm, document);\n+\t}\n+\n+\tprotected void formatEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event definitions between the 'events' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"events\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_1_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Event event : sm.getEvents()) {\n+\t\t\tformat(event, doc);\n+\t\t}\n+\n+\t\tif (hasResetEvents(sm) || hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatResetEvents(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the event references between the 'resetEvents' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"resetEvents\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_2_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\t// format each event reference\n+\t\tdoc.append(regionFor(sm).assignment(ga.getStatemachineAccess().getResetEventsAssignment_2_1()),\n+\t\t\t\tit -> it.newLine());\n+\n+\t\tdoc.prepend(end, it -> it.newLine());\n+\n+\t\tif (hasCommands(sm) || hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatCommands(Statemachine sm, IFormattableDocument doc) {\n+\t\t// indent the command definitions between the 'commands' keyword and the 'end'\n+\t\t// keyword\n+\t\tISemanticRegion begin = regionFor(sm).keyword(\"commands\");\n+\t\tISemanticRegion end = regionFor(sm).keyword(ga.getStatemachineAccess().getEndKeyword_3_2());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tfor (Command command : sm.getCommands()) {\n+\t\t\tformat(command, doc);\n+\t\t}\n+\n+\t\tif (hasStates(sm)) {\n+\t\t\tdoc.append(end, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatStates(Statemachine sm, IFormattableDocument doc) {\n+\t\tfor (State state : sm.getStates()) {\n+\t\t\tformat(state, doc);\n+\t\t}\n+\t}\n+\n+\tprotected void format(Event event, IFormattableDocument doc) {\n+\t\t// align the event name and the event code in columns based on the longest event\n+\t\t// name\n+\t\tdoc.append(regionFor(event).feature(EVENT__NAME), it -> it.setSpace(additionalSpaces(event)));\n+\t\t// line break after each event definition\n+\t\tdoc.append(event, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Command command, IFormattableDocument doc) {\n+\t\t// align the command name and the command code in columns based on the longest\n+\t\t// command name\n+\t\tdoc.append(regionFor(command).feature(COMMAND__NAME), it -> it.setSpace(additionalSpaces(command)));\n+\t\t// line break after each command definition\n+\t\tdoc.append(command, it -> it.newLine());\n+\t}\n+\n+\tprotected void format(State s, IFormattableDocument doc) {\n+\t\t// indent the state elements between the name of the state and the 'end' keyword\n+\t\tISemanticRegion begin = regionFor(s).feature(STATE__NAME);\n+\t\tISemanticRegion end = regionFor(s).keyword(ga.getStateAccess().getEndKeyword_4());\n+\n+\t\tdoc.append(begin, it -> it.newLine());\n+\t\tdoc.interior(begin, end, it -> it.indent());\n+\n+\t\tformatActions(s, doc);\n+\n+\t\tfor (Transition transition : s.getTransitions()) {\n+\t\t\tformat(transition, doc);\n+\t\t}\n+\n+\t\tif (isLastState(s)) {\n+\t\t\tdoc.append(s, it -> it.newLine());\n+\t\t} else {\n+\t\t\tdoc.append(s, it -> it.setNewLines(2));\n+\t\t}\n+\t}\n+\n+\tprotected void formatActions(State s, IFormattableDocument doc) {\n+\t\t// line break after the action definitions\n+\t\tdoc.append(regionFor(s).keyword(\"}\"), it -> it.newLine());\n+\t}\n+\n+\tprotected void format(Transition transition, IFormattableDocument doc) {\n+\t\t// align the event name and the transition's state in columns based on the\n+\t\t// longest event name\n+\t\tdoc.append(regionFor(transition).assignment(ga.getTransitionAccess().getEventAssignment_0()),\n+\t\t\t\tit -> it.setSpace(additionalSpaces(transition)));\n+\t\t// line break after each transition\n+\t\tdoc.append(transition, it -> it.newLine());\n+\t}\n+\n+\tprivate String additionalSpaces(Event it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getEvents(), Event::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Command it) {\n+\t\tStatemachine statemachine = (Statemachine) it.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(statemachine.getCommands(), Command::getName), it.getName());\n+\t}\n+\n+\tprivate String additionalSpaces(Transition t) {\n+\t\tState state = (State) t.eContainer();\n+\t\treturn additionalSpaces(Lists.transform(state.getTransitions(), it -> it.getEvent().getName()),\n+\t\t\t\tt.getEvent().getName());\n+\t}\n+\n+\tprivate String additionalSpaces(List<String> it, String name) {\n+\t\treturn Strings.repeat(\" \", getLongestName(it).length()- name.length()+ 1);\n+\t}\n+\n+\tprivate String getLongestName(List<String> it) {\n+\t\treturn Iterables.getFirst(IterableExtensions.sortBy(it, s -> -s.length()), null);\n+\t}\n+\n+\tprivate boolean hasResetEvents(Statemachine it) {\n+\t\treturn !it.getResetEvents().isEmpty();\n+\t}\n+\n+\tprivate boolean hasCommands(Statemachine it) {\n+\t\treturn !it.getCommands().isEmpty();\n+\t}\n+\n+\tprivate boolean hasStates(Statemachine it) {\n+\t\treturn !it.getStates().isEmpty();\n+\t}\n+\n+\tprivate boolean isLastState(State it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fd0ee2bf1b0062b28e30de14e7a7df107f151a"}, "originalPosition": 195}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 791, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}