{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MzA5Nzc0", "number": 698, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMToxMjo0OFrOEawd5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDoyMjo0MVrOEbgMDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NDkyNTE5OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/compiler/canonical/ReflectionUtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMToxMjo0OFrOHEYPtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTozNzoxMlrOHEmNTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1MzU5MQ==", "bodyText": "maybe would be good to test some form o method overloading as well, making sure we get the correct one?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r474353591", "createdAt": "2020-08-21T01:12:48Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/compiler/canonical/ReflectionUtilsTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.jbpm.compiler.canonical;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ReflectionUtilsTest {\n+\n+    private static class ServiceExample {\n+\n+        @SuppressWarnings(\"unused\")\n+        public int primitiveType(String s, int a) {\n+            return a;\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        public Float wrapperType(String s, Float a) {\n+            return a;\n+        }\n+    }\n+\n+    @Test\n+    public void testGetMethod() throws ReflectiveOperationException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abb21a2d3ab6eb59edbb603360d48da8ea1c3a31"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU4MjM0OQ==", "bodyText": "Ok done", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r474582349", "createdAt": "2020-08-21T09:37:12Z", "author": {"login": "fjtirado"}, "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/compiler/canonical/ReflectionUtilsTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.jbpm.compiler.canonical;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ReflectionUtilsTest {\n+\n+    private static class ServiceExample {\n+\n+        @SuppressWarnings(\"unused\")\n+        public int primitiveType(String s, int a) {\n+            return a;\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        public Float wrapperType(String s, Float a) {\n+            return a;\n+        }\n+    }\n+\n+    @Test\n+    public void testGetMethod() throws ReflectiveOperationException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1MzU5MQ=="}, "originalCommit": {"oid": "abb21a2d3ab6eb59edbb603360d48da8ea1c3a31"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzg2MzYxOnYy", "diffSide": "RIGHT", "path": "integration-tests/integration-tests-quarkus/src/main/java/org/kie/kogito/integrationtests/HelloService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjo1MTozNFrOHE0UpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODo0MjoxM1rOHFaHNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMzYwNQ==", "bodyText": "Are there any of the integration-tests processes calling the hello, with the exception? I mean to test this exception use case.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r474813605", "createdAt": "2020-08-21T16:51:34Z", "author": {"login": "tiagodolphine"}, "path": "integration-tests/integration-tests-quarkus/src/main/java/org/kie/kogito/integrationtests/HelloService.java", "diffHunk": "@@ -28,21 +30,20 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(HelloService.class);\n \n-    public String hello(String name) {\n+    public String hello(String name) throws IOException {\n+        if (name.equals(\"exception\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3dc71b26e7f813ee2de8967b57d6175bf61547a6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQxODEwNA==", "bodyText": "No, but the scenario I wanted to test is not the exception being thrown, but the exception being properly handled by code generator (that the generated code compiles).\nRegarding exception handling itself, checked exception is wrapped inside a WorkITemHandlerError, which is tested in ErrorEventTest.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475418104", "createdAt": "2020-08-24T08:15:25Z", "author": {"login": "fjtirado"}, "path": "integration-tests/integration-tests-quarkus/src/main/java/org/kie/kogito/integrationtests/HelloService.java", "diffHunk": "@@ -28,21 +30,20 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(HelloService.class);\n \n-    public String hello(String name) {\n+    public String hello(String name) throws IOException {\n+        if (name.equals(\"exception\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMzYwNQ=="}, "originalCommit": {"oid": "3dc71b26e7f813ee2de8967b57d6175bf61547a6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzMjc1Nw==", "bodyText": "Anyway, Im going to add test case that throws Exception for integration purposes", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475432757", "createdAt": "2020-08-24T08:42:13Z", "author": {"login": "fjtirado"}, "path": "integration-tests/integration-tests-quarkus/src/main/java/org/kie/kogito/integrationtests/HelloService.java", "diffHunk": "@@ -28,21 +30,20 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(HelloService.class);\n \n-    public String hello(String name) {\n+    public String hello(String name) throws IOException {\n+        if (name.equals(\"exception\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMzYwNQ=="}, "originalCommit": {"oid": "3dc71b26e7f813ee2de8967b57d6175bf61547a6"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjY0MjYxOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ReflectionUtils.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTo1MzozNFrOHFdHXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMjoxNzoyOVrOHFhssA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4MTk0OQ==", "bodyText": "I would throw ex2 if the last caught exception was ex2. In case the exception messages are different, it can cause confusions.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475481949", "createdAt": "2020-08-24T09:53:34Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ReflectionUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.jbpm.compiler.canonical;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class ReflectionUtils {\n+\n+    private ReflectionUtils() {}\n+\n+    private static Map<Class<?>, Class<?>> wrappers2Primitive = new ConcurrentHashMap<>();\n+\n+    static {\n+        wrappers2Primitive.put(Boolean.class, boolean.class);\n+        wrappers2Primitive.put(Byte.class, byte.class);\n+        wrappers2Primitive.put(Character.class, char.class);\n+        wrappers2Primitive.put(Double.class, double.class);\n+        wrappers2Primitive.put(Float.class, float.class);\n+        wrappers2Primitive.put(Integer.class, int.class);\n+        wrappers2Primitive.put(Long.class, long.class);\n+        wrappers2Primitive.put(Short.class, short.class);\n+    }\n+\n+    public static boolean isWrapper(Class<?> clazz) {\n+        return wrappers2Primitive.containsKey(clazz);\n+    }\n+\n+    public static Class<?> getPrimitive(Class<?> clazz) {\n+        return wrappers2Primitive.get(clazz);\n+    }\n+    \n+    public static Method\n+        getMethod(ClassLoader cl,\n+                  Class<?> clazz,\n+                  String methodName,\n+                  Collection<String> parameterTypes) throws ReflectiveOperationException {\n+        \n+        boolean hasPrimitive = false;\n+        Class<?>[] methodParameters = new Class<?> [parameterTypes.size()];\n+        Class<?>[] primitiveParameters = new Class<?> [parameterTypes.size()];\n+        \n+        Iterator<String> iter = parameterTypes.iterator(); \n+        int i = 0;\n+        while (iter.hasNext()) {\n+            String parameter = iter.next();\n+            if (!parameter.contains(\".\")) {\n+                parameter = \"java.lang.\" + parameter;\n+            }\n+            Class<?> parameterClass = cl.loadClass(parameter);\n+            methodParameters[i] = parameterClass;\n+            Class<?> primitive = wrappers2Primitive.get(parameterClass);\n+            if (primitive != null) {\n+                primitiveParameters[i] = primitive;\n+                hasPrimitive = true;\n+            } else {\n+                primitiveParameters[i] = parameterClass;\n+            }\n+            i++;\n+        }\n+        try {\n+            return clazz.getMethod(methodName, methodParameters);\n+        }\n+        catch (NoSuchMethodException ex) {\n+            if (hasPrimitive) {\n+               try {\n+                   return clazz.getMethod(methodName,primitiveParameters);\n+               }\n+               catch (NoSuchMethodException ex2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "942582e686fa231a2cc546e1750960a258376455"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNjMxMA==", "bodyText": "Searching for method with primitive arguments  is a fallback mechanism in case the service is declared using primitive , the real issue is that the method with the wrapper cannot be found and thats the exception that has be thrown (the second exception can be safely ignored, as which will be ignoring a SQL exception in close method that hides the real SQL exception)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475526310", "createdAt": "2020-08-24T11:13:33Z", "author": {"login": "fjtirado"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ReflectionUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.jbpm.compiler.canonical;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class ReflectionUtils {\n+\n+    private ReflectionUtils() {}\n+\n+    private static Map<Class<?>, Class<?>> wrappers2Primitive = new ConcurrentHashMap<>();\n+\n+    static {\n+        wrappers2Primitive.put(Boolean.class, boolean.class);\n+        wrappers2Primitive.put(Byte.class, byte.class);\n+        wrappers2Primitive.put(Character.class, char.class);\n+        wrappers2Primitive.put(Double.class, double.class);\n+        wrappers2Primitive.put(Float.class, float.class);\n+        wrappers2Primitive.put(Integer.class, int.class);\n+        wrappers2Primitive.put(Long.class, long.class);\n+        wrappers2Primitive.put(Short.class, short.class);\n+    }\n+\n+    public static boolean isWrapper(Class<?> clazz) {\n+        return wrappers2Primitive.containsKey(clazz);\n+    }\n+\n+    public static Class<?> getPrimitive(Class<?> clazz) {\n+        return wrappers2Primitive.get(clazz);\n+    }\n+    \n+    public static Method\n+        getMethod(ClassLoader cl,\n+                  Class<?> clazz,\n+                  String methodName,\n+                  Collection<String> parameterTypes) throws ReflectiveOperationException {\n+        \n+        boolean hasPrimitive = false;\n+        Class<?>[] methodParameters = new Class<?> [parameterTypes.size()];\n+        Class<?>[] primitiveParameters = new Class<?> [parameterTypes.size()];\n+        \n+        Iterator<String> iter = parameterTypes.iterator(); \n+        int i = 0;\n+        while (iter.hasNext()) {\n+            String parameter = iter.next();\n+            if (!parameter.contains(\".\")) {\n+                parameter = \"java.lang.\" + parameter;\n+            }\n+            Class<?> parameterClass = cl.loadClass(parameter);\n+            methodParameters[i] = parameterClass;\n+            Class<?> primitive = wrappers2Primitive.get(parameterClass);\n+            if (primitive != null) {\n+                primitiveParameters[i] = primitive;\n+                hasPrimitive = true;\n+            } else {\n+                primitiveParameters[i] = parameterClass;\n+            }\n+            i++;\n+        }\n+        try {\n+            return clazz.getMethod(methodName, methodParameters);\n+        }\n+        catch (NoSuchMethodException ex) {\n+            if (hasPrimitive) {\n+               try {\n+                   return clazz.getMethod(methodName,primitiveParameters);\n+               }\n+               catch (NoSuchMethodException ex2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4MTk0OQ=="}, "originalCommit": {"oid": "942582e686fa231a2cc546e1750960a258376455"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU0MjU5Nw==", "bodyText": "In that case at least a log message would be helpful.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475542597", "createdAt": "2020-08-24T11:47:41Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ReflectionUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.jbpm.compiler.canonical;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class ReflectionUtils {\n+\n+    private ReflectionUtils() {}\n+\n+    private static Map<Class<?>, Class<?>> wrappers2Primitive = new ConcurrentHashMap<>();\n+\n+    static {\n+        wrappers2Primitive.put(Boolean.class, boolean.class);\n+        wrappers2Primitive.put(Byte.class, byte.class);\n+        wrappers2Primitive.put(Character.class, char.class);\n+        wrappers2Primitive.put(Double.class, double.class);\n+        wrappers2Primitive.put(Float.class, float.class);\n+        wrappers2Primitive.put(Integer.class, int.class);\n+        wrappers2Primitive.put(Long.class, long.class);\n+        wrappers2Primitive.put(Short.class, short.class);\n+    }\n+\n+    public static boolean isWrapper(Class<?> clazz) {\n+        return wrappers2Primitive.containsKey(clazz);\n+    }\n+\n+    public static Class<?> getPrimitive(Class<?> clazz) {\n+        return wrappers2Primitive.get(clazz);\n+    }\n+    \n+    public static Method\n+        getMethod(ClassLoader cl,\n+                  Class<?> clazz,\n+                  String methodName,\n+                  Collection<String> parameterTypes) throws ReflectiveOperationException {\n+        \n+        boolean hasPrimitive = false;\n+        Class<?>[] methodParameters = new Class<?> [parameterTypes.size()];\n+        Class<?>[] primitiveParameters = new Class<?> [parameterTypes.size()];\n+        \n+        Iterator<String> iter = parameterTypes.iterator(); \n+        int i = 0;\n+        while (iter.hasNext()) {\n+            String parameter = iter.next();\n+            if (!parameter.contains(\".\")) {\n+                parameter = \"java.lang.\" + parameter;\n+            }\n+            Class<?> parameterClass = cl.loadClass(parameter);\n+            methodParameters[i] = parameterClass;\n+            Class<?> primitive = wrappers2Primitive.get(parameterClass);\n+            if (primitive != null) {\n+                primitiveParameters[i] = primitive;\n+                hasPrimitive = true;\n+            } else {\n+                primitiveParameters[i] = parameterClass;\n+            }\n+            i++;\n+        }\n+        try {\n+            return clazz.getMethod(methodName, methodParameters);\n+        }\n+        catch (NoSuchMethodException ex) {\n+            if (hasPrimitive) {\n+               try {\n+                   return clazz.getMethod(methodName,primitiveParameters);\n+               }\n+               catch (NoSuchMethodException ex2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4MTk0OQ=="}, "originalCommit": {"oid": "942582e686fa231a2cc546e1750960a258376455"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU1NzA0MA==", "bodyText": "Sure", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475557040", "createdAt": "2020-08-24T12:17:29Z", "author": {"login": "fjtirado"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ReflectionUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.jbpm.compiler.canonical;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class ReflectionUtils {\n+\n+    private ReflectionUtils() {}\n+\n+    private static Map<Class<?>, Class<?>> wrappers2Primitive = new ConcurrentHashMap<>();\n+\n+    static {\n+        wrappers2Primitive.put(Boolean.class, boolean.class);\n+        wrappers2Primitive.put(Byte.class, byte.class);\n+        wrappers2Primitive.put(Character.class, char.class);\n+        wrappers2Primitive.put(Double.class, double.class);\n+        wrappers2Primitive.put(Float.class, float.class);\n+        wrappers2Primitive.put(Integer.class, int.class);\n+        wrappers2Primitive.put(Long.class, long.class);\n+        wrappers2Primitive.put(Short.class, short.class);\n+    }\n+\n+    public static boolean isWrapper(Class<?> clazz) {\n+        return wrappers2Primitive.containsKey(clazz);\n+    }\n+\n+    public static Class<?> getPrimitive(Class<?> clazz) {\n+        return wrappers2Primitive.get(clazz);\n+    }\n+    \n+    public static Method\n+        getMethod(ClassLoader cl,\n+                  Class<?> clazz,\n+                  String methodName,\n+                  Collection<String> parameterTypes) throws ReflectiveOperationException {\n+        \n+        boolean hasPrimitive = false;\n+        Class<?>[] methodParameters = new Class<?> [parameterTypes.size()];\n+        Class<?>[] primitiveParameters = new Class<?> [parameterTypes.size()];\n+        \n+        Iterator<String> iter = parameterTypes.iterator(); \n+        int i = 0;\n+        while (iter.hasNext()) {\n+            String parameter = iter.next();\n+            if (!parameter.contains(\".\")) {\n+                parameter = \"java.lang.\" + parameter;\n+            }\n+            Class<?> parameterClass = cl.loadClass(parameter);\n+            methodParameters[i] = parameterClass;\n+            Class<?> primitive = wrappers2Primitive.get(parameterClass);\n+            if (primitive != null) {\n+                primitiveParameters[i] = primitive;\n+                hasPrimitive = true;\n+            } else {\n+                primitiveParameters[i] = parameterClass;\n+            }\n+            i++;\n+        }\n+        try {\n+            return clazz.getMethod(methodName, methodParameters);\n+        }\n+        catch (NoSuchMethodException ex) {\n+            if (hasPrimitive) {\n+               try {\n+                   return clazz.getMethod(methodName,primitiveParameters);\n+               }\n+               catch (NoSuchMethodException ex2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4MTk0OQ=="}, "originalCommit": {"oid": "942582e686fa231a2cc546e1750960a258376455"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjY0OTUxOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ServiceTaskDescriptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTo1NToxMVrOHFdLUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMToxMTo0MFrOHFfxRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4Mjk2MA==", "bodyText": "Please use the full name in constants, i.e. EXCEPTION_NAME.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475482960", "createdAt": "2020-08-24T09:55:11Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ServiceTaskDescriptor.java", "diffHunk": "@@ -19,47 +19,61 @@\n import java.lang.reflect.Method;\n import java.text.MessageFormat;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.stream.Collectors;\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n import com.github.javaparser.ast.Modifier;\n+import com.github.javaparser.ast.NodeList;\n import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n import com.github.javaparser.ast.body.FieldDeclaration;\n import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n import com.github.javaparser.ast.expr.CastExpr;\n import com.github.javaparser.ast.expr.Expression;\n import com.github.javaparser.ast.expr.MethodCallExpr;\n import com.github.javaparser.ast.expr.NameExpr;\n import com.github.javaparser.ast.expr.NullLiteralExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n import com.github.javaparser.ast.expr.StringLiteralExpr;\n import com.github.javaparser.ast.expr.VariableDeclarationExpr;\n import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.UnionType;\n import org.jbpm.process.core.ParameterDefinition;\n import org.jbpm.workflow.core.node.DataAssociation;\n import org.jbpm.workflow.core.node.WorkItemNode;\n import org.kie.api.runtime.process.WorkItem;\n import org.kie.api.runtime.process.WorkItemHandler;\n import org.kie.api.runtime.process.WorkItemManager;\n-\n-import static java.util.stream.Collectors.joining;\n+import org.kie.kogito.process.workitem.WorkItemExecutionError;\n \n public class ServiceTaskDescriptor {\n \n+    private static final String RESULT_NAME = \"result\";\n+    private static final String EXC_NAME = \"ex\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "942582e686fa231a2cc546e1750960a258376455"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNTQ0Nw==", "bodyText": "Done", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475525447", "createdAt": "2020-08-24T11:11:40Z", "author": {"login": "fjtirado"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ServiceTaskDescriptor.java", "diffHunk": "@@ -19,47 +19,61 @@\n import java.lang.reflect.Method;\n import java.text.MessageFormat;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n-import java.util.stream.Collectors;\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n import com.github.javaparser.ast.Modifier;\n+import com.github.javaparser.ast.NodeList;\n import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n import com.github.javaparser.ast.body.FieldDeclaration;\n import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.AssignExpr;\n import com.github.javaparser.ast.expr.CastExpr;\n import com.github.javaparser.ast.expr.Expression;\n import com.github.javaparser.ast.expr.MethodCallExpr;\n import com.github.javaparser.ast.expr.NameExpr;\n import com.github.javaparser.ast.expr.NullLiteralExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n import com.github.javaparser.ast.expr.StringLiteralExpr;\n import com.github.javaparser.ast.expr.VariableDeclarationExpr;\n import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.UnionType;\n import org.jbpm.process.core.ParameterDefinition;\n import org.jbpm.workflow.core.node.DataAssociation;\n import org.jbpm.workflow.core.node.WorkItemNode;\n import org.kie.api.runtime.process.WorkItem;\n import org.kie.api.runtime.process.WorkItemHandler;\n import org.kie.api.runtime.process.WorkItemManager;\n-\n-import static java.util.stream.Collectors.joining;\n+import org.kie.kogito.process.workitem.WorkItemExecutionError;\n \n public class ServiceTaskDescriptor {\n \n+    private static final String RESULT_NAME = \"result\";\n+    private static final String EXC_NAME = \"ex\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ4Mjk2MA=="}, "originalCommit": {"oid": "942582e686fa231a2cc546e1750960a258376455"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Mjc0MzgzOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ReflectionUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMDoyMjo0MVrOHFeD3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMTo0ODo1N1rOHFg2Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ5NzQzNg==", "bodyText": "So this functionality is here to support either:\nmethod(String a, Float b, Integer c)\nor\nmethod(String a, float a, int b)\nso nothing in between.\nI think that the current BPMN modeller knows only wrapper types, so if somebody calls a method with arguments String, Float and Integer and a service will have only String, float and Integer parameters, it will fail to find the method.\nI don't mean we should support all combinations, just asking if I understand it correctly.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475497436", "createdAt": "2020-08-24T10:22:41Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ReflectionUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.jbpm.compiler.canonical;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class ReflectionUtils {\n+\n+    private ReflectionUtils() {}\n+\n+    private static Map<Class<?>, Class<?>> wrappers2Primitive = new ConcurrentHashMap<>();\n+\n+    static {\n+        wrappers2Primitive.put(Boolean.class, boolean.class);\n+        wrappers2Primitive.put(Byte.class, byte.class);\n+        wrappers2Primitive.put(Character.class, char.class);\n+        wrappers2Primitive.put(Double.class, double.class);\n+        wrappers2Primitive.put(Float.class, float.class);\n+        wrappers2Primitive.put(Integer.class, int.class);\n+        wrappers2Primitive.put(Long.class, long.class);\n+        wrappers2Primitive.put(Short.class, short.class);\n+    }\n+\n+    public static boolean isWrapper(Class<?> clazz) {\n+        return wrappers2Primitive.containsKey(clazz);\n+    }\n+\n+    public static Class<?> getPrimitive(Class<?> clazz) {\n+        return wrappers2Primitive.get(clazz);\n+    }\n+    \n+    public static Method\n+        getMethod(ClassLoader cl,\n+                  Class<?> clazz,\n+                  String methodName,\n+                  Collection<String> parameterTypes) throws ReflectiveOperationException {\n+        \n+        boolean hasPrimitive = false;\n+        Class<?>[] methodParameters = new Class<?> [parameterTypes.size()];\n+        Class<?>[] primitiveParameters = new Class<?> [parameterTypes.size()];\n+        \n+        Iterator<String> iter = parameterTypes.iterator(); \n+        int i = 0;\n+        while (iter.hasNext()) {\n+            String parameter = iter.next();\n+            if (!parameter.contains(\".\")) {\n+                parameter = \"java.lang.\" + parameter;\n+            }\n+            Class<?> parameterClass = cl.loadClass(parameter);\n+            methodParameters[i] = parameterClass;\n+            Class<?> primitive = wrappers2Primitive.get(parameterClass);\n+            if (primitive != null) {\n+                primitiveParameters[i] = primitive;\n+                hasPrimitive = true;\n+            } else {\n+                primitiveParameters[i] = parameterClass;\n+            }\n+            i++;\n+        }\n+        try {\n+            return clazz.getMethod(methodName, methodParameters);\n+        }\n+        catch (NoSuchMethodException ex) {\n+            if (hasPrimitive) {\n+               try {\n+                   return clazz.getMethod(methodName,primitiveParameters);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "942582e686fa231a2cc546e1750960a258376455"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNzcyNw==", "bodyText": "Initially implementation of this PR was not supporting primitive version of the method, but one of the service classes in our test is using primitive and was failing, so I think, rather than changing the test (which I did for HotReloadTest, because the approach used to load the classes was not recommended by Quarkus guys), why not supporting both?\nSupport is partial though, because the service method should either user all wrapper or all primitive (I prefer to use getMethod rather thatn getMethods and search), but I think this is a safer assumption for now.\nIf it turns out to not be a right assumption in the future, we will just have to change the implementation in ReflectionUtils (and use getMEthods and a type name comparator that considers primitive and wrapper types to be the same class)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475527727", "createdAt": "2020-08-24T11:16:26Z", "author": {"login": "fjtirado"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ReflectionUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.jbpm.compiler.canonical;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class ReflectionUtils {\n+\n+    private ReflectionUtils() {}\n+\n+    private static Map<Class<?>, Class<?>> wrappers2Primitive = new ConcurrentHashMap<>();\n+\n+    static {\n+        wrappers2Primitive.put(Boolean.class, boolean.class);\n+        wrappers2Primitive.put(Byte.class, byte.class);\n+        wrappers2Primitive.put(Character.class, char.class);\n+        wrappers2Primitive.put(Double.class, double.class);\n+        wrappers2Primitive.put(Float.class, float.class);\n+        wrappers2Primitive.put(Integer.class, int.class);\n+        wrappers2Primitive.put(Long.class, long.class);\n+        wrappers2Primitive.put(Short.class, short.class);\n+    }\n+\n+    public static boolean isWrapper(Class<?> clazz) {\n+        return wrappers2Primitive.containsKey(clazz);\n+    }\n+\n+    public static Class<?> getPrimitive(Class<?> clazz) {\n+        return wrappers2Primitive.get(clazz);\n+    }\n+    \n+    public static Method\n+        getMethod(ClassLoader cl,\n+                  Class<?> clazz,\n+                  String methodName,\n+                  Collection<String> parameterTypes) throws ReflectiveOperationException {\n+        \n+        boolean hasPrimitive = false;\n+        Class<?>[] methodParameters = new Class<?> [parameterTypes.size()];\n+        Class<?>[] primitiveParameters = new Class<?> [parameterTypes.size()];\n+        \n+        Iterator<String> iter = parameterTypes.iterator(); \n+        int i = 0;\n+        while (iter.hasNext()) {\n+            String parameter = iter.next();\n+            if (!parameter.contains(\".\")) {\n+                parameter = \"java.lang.\" + parameter;\n+            }\n+            Class<?> parameterClass = cl.loadClass(parameter);\n+            methodParameters[i] = parameterClass;\n+            Class<?> primitive = wrappers2Primitive.get(parameterClass);\n+            if (primitive != null) {\n+                primitiveParameters[i] = primitive;\n+                hasPrimitive = true;\n+            } else {\n+                primitiveParameters[i] = parameterClass;\n+            }\n+            i++;\n+        }\n+        try {\n+            return clazz.getMethod(methodName, methodParameters);\n+        }\n+        catch (NoSuchMethodException ex) {\n+            if (hasPrimitive) {\n+               try {\n+                   return clazz.getMethod(methodName,primitiveParameters);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ5NzQzNg=="}, "originalCommit": {"oid": "942582e686fa231a2cc546e1750960a258376455"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU0MzE0Mg==", "bodyText": "OK, makes sense.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/698#discussion_r475543142", "createdAt": "2020-08-24T11:48:57Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ReflectionUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.jbpm.compiler.canonical;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class ReflectionUtils {\n+\n+    private ReflectionUtils() {}\n+\n+    private static Map<Class<?>, Class<?>> wrappers2Primitive = new ConcurrentHashMap<>();\n+\n+    static {\n+        wrappers2Primitive.put(Boolean.class, boolean.class);\n+        wrappers2Primitive.put(Byte.class, byte.class);\n+        wrappers2Primitive.put(Character.class, char.class);\n+        wrappers2Primitive.put(Double.class, double.class);\n+        wrappers2Primitive.put(Float.class, float.class);\n+        wrappers2Primitive.put(Integer.class, int.class);\n+        wrappers2Primitive.put(Long.class, long.class);\n+        wrappers2Primitive.put(Short.class, short.class);\n+    }\n+\n+    public static boolean isWrapper(Class<?> clazz) {\n+        return wrappers2Primitive.containsKey(clazz);\n+    }\n+\n+    public static Class<?> getPrimitive(Class<?> clazz) {\n+        return wrappers2Primitive.get(clazz);\n+    }\n+    \n+    public static Method\n+        getMethod(ClassLoader cl,\n+                  Class<?> clazz,\n+                  String methodName,\n+                  Collection<String> parameterTypes) throws ReflectiveOperationException {\n+        \n+        boolean hasPrimitive = false;\n+        Class<?>[] methodParameters = new Class<?> [parameterTypes.size()];\n+        Class<?>[] primitiveParameters = new Class<?> [parameterTypes.size()];\n+        \n+        Iterator<String> iter = parameterTypes.iterator(); \n+        int i = 0;\n+        while (iter.hasNext()) {\n+            String parameter = iter.next();\n+            if (!parameter.contains(\".\")) {\n+                parameter = \"java.lang.\" + parameter;\n+            }\n+            Class<?> parameterClass = cl.loadClass(parameter);\n+            methodParameters[i] = parameterClass;\n+            Class<?> primitive = wrappers2Primitive.get(parameterClass);\n+            if (primitive != null) {\n+                primitiveParameters[i] = primitive;\n+                hasPrimitive = true;\n+            } else {\n+                primitiveParameters[i] = parameterClass;\n+            }\n+            i++;\n+        }\n+        try {\n+            return clazz.getMethod(methodName, methodParameters);\n+        }\n+        catch (NoSuchMethodException ex) {\n+            if (hasPrimitive) {\n+               try {\n+                   return clazz.getMethod(methodName,primitiveParameters);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ5NzQzNg=="}, "originalCommit": {"oid": "942582e686fa231a2cc546e1750960a258376455"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4932, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}