{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0OTc2MTY2", "number": 452, "title": "KOGITO-1631 - File System based persistence addon", "bodyText": "", "createdAt": "2020-04-17T07:46:15Z", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452", "merged": true, "mergeCommit": {"oid": "47a5f9377497785b5efd8a6e2c02689b0bd595e9"}, "closed": true, "closedAt": "2020-04-21T08:00:10Z", "author": {"login": "mswiderski"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYgKD8gFqTM5NTM4NjU4OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZkM1BgBqjMyNTMyMzI2NTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Mzg2NTg4", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#pullrequestreview-395386588", "createdAt": "2020-04-17T11:49:48Z", "commit": {"oid": "b9a38a9efbd7f25024509b206c81b556a3370c89"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMTo0OTo0OFrOGHK4OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjowMTo0M1rOGHLM7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MTQ0OA==", "bodyText": "@mswiderski can you include the copywrite headers :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r410171448", "createdAt": "2020-04-17T11:49:48Z", "author": {"login": "cristianonicolai"}, "path": "addons/persistence/filesystem-persistence-addon/src/main/java/org/kie/kogito/persistence/filesystem/FileSystemProcessInstances.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.kie.kogito.persistence.filesystem;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9a38a9efbd7f25024509b206c81b556a3370c89"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MTY0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n          \n          \n            \n             * Copyright 2020 Red Hat, Inc. and/or its affiliates.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r410171641", "createdAt": "2020-04-17T11:50:20Z", "author": {"login": "cristianonicolai"}, "path": "addons/persistence/filesystem-persistence-addon/src/test/java/org/kie/persistence/filesystem/FileSystemProcessInstancesTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9a38a9efbd7f25024509b206c81b556a3370c89"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3NTU0OQ==", "bodyText": "any specific reason for doing a list and not using it? perhaps just do a size assert?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r410175549", "createdAt": "2020-04-17T11:59:03Z", "author": {"login": "cristianonicolai"}, "path": "addons/persistence/filesystem-persistence-addon/src/test/java/org/kie/persistence/filesystem/FileSystemProcessInstancesTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.persistence.filesystem;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_COMPLETED;\n+\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.services.identity.StaticIdentityProvider;\n+\n+public class FileSystemProcessInstancesTest {\n+\n+\t\n+\tprivate SecurityPolicy securityPolicy = SecurityPolicy.of(new StaticIdentityProvider(\"john\"));\n+\t\n+    @Test\n+    public void testBasicFlow() {\n+\n+        BpmnProcess process = (BpmnProcess) BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask.bpmn2\")).get(0);\n+        process.setProcessInstancesFactory(new FileSystemProcessInstancesFactory());\n+        process.configure();\n+                                     \n+        ProcessInstance<BpmnVariables> processInstance = process.createInstance(BpmnVariables.create(Collections.singletonMap(\"test\", \"test\")));\n+\n+        processInstance.start();\n+        assertEquals(STATE_ACTIVE, processInstance.status());\n+        assertEquals(\"User Task\", processInstance.description());\n+        \n+        process.instances().values();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9a38a9efbd7f25024509b206c81b556a3370c89"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3Njc0OA==", "bodyText": "this file should not be needed, the .gitignore in the root should be enough", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r410176748", "createdAt": "2020-04-17T12:01:43Z", "author": {"login": "cristianonicolai"}, "path": "addons/persistence/filesystem-persistence-addon/.gitignore", "diffHunk": "@@ -0,0 +1,10 @@\n+target/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9a38a9efbd7f25024509b206c81b556a3370c89"}, "originalPosition": 1}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b9a38a9efbd7f25024509b206c81b556a3370c89", "author": {"user": {"login": "mswiderski", "name": "Maciej Swiderski"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b9a38a9efbd7f25024509b206c81b556a3370c89", "committedDate": "2020-04-17T05:47:47Z", "message": "KOGITO-1631 - File System based persistence addon"}, "afterCommit": {"oid": "0ead05b67b71ae1c42b88e86ea5d03d561b62e0b", "author": {"user": {"login": "mswiderski", "name": "Maciej Swiderski"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/0ead05b67b71ae1c42b88e86ea5d03d561b62e0b", "committedDate": "2020-04-17T12:17:08Z", "message": "KOGITO-1631 - File System based persistence addon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MTg3MTg2", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#pullrequestreview-396187186", "createdAt": "2020-04-20T07:02:01Z", "commit": {"oid": "0ead05b67b71ae1c42b88e86ea5d03d561b62e0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MjIzNDYx", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#pullrequestreview-396223461", "createdAt": "2020-04-20T08:01:06Z", "commit": {"oid": "0ead05b67b71ae1c42b88e86ea5d03d561b62e0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDA1ODg0", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#pullrequestreview-396405884", "createdAt": "2020-04-20T12:28:17Z", "commit": {"oid": "0ead05b67b71ae1c42b88e86ea5d03d561b62e0b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjoyODoxOFrOGIR_OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjoyOTo0OVrOGISC0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNjUwNA==", "bodyText": "It seems this method read all files on the target path, in case we have N files this can be dangerous loading all into memory, wouldn't be better to have at least a limit/pagination?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411336504", "createdAt": "2020-04-20T12:28:18Z", "author": {"login": "tiagodolphine"}, "path": "addons/persistence/filesystem-persistence-addon/src/main/java/org/kie/kogito/persistence/filesystem/FileSystemProcessInstances.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.filesystem;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.UserDefinedFileAttributeView;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@SuppressWarnings({\"rawtypes\"})\n+public class FileSystemProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FileSystemProcessInstances.class);\n+\n+    private static final String PI_DESCRIPTION = \"ProcessInstanceDescription\";\n+    private Process<?> process;\n+    private Path storage;\n+\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage) {\n+        this(process, storage, new ProcessInstanceMarshaller());\n+    }\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage, ProcessInstanceMarshaller marshaller) {\n+        this.process = process;\n+        this.storage = Paths.get(storage.toString(), process.id());\n+        this.marshaller = marshaller;\n+\n+        try {\n+            Files.createDirectories(this.storage);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to create directories for file based storage of process instances\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional findById(String id) {\n+        String resolvedId = resolveId(id);\n+        Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+        if (Files.notExists(processInstanceStorage)) {\n+            return Optional.empty();\n+        }\n+        return (Optional<? extends ProcessInstance>) Optional.of(marshaller.unmarshallProcessInstance(readBytesFromFile(processInstanceStorage), process));\n+\n+    }\n+\n+    @Override\n+    public Collection values() {\n+        try {\n+            return Files.walk(storage)\n+                        .filter(file -> !Files.isDirectory(file))\n+                        .map(f -> marshaller.unmarshallProcessInstance(readBytesFromFile(f), process))\n+                        .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ead05b67b71ae1c42b88e86ea5d03d561b62e0b"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNzQyNw==", "bodyText": "formatting", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411337427", "createdAt": "2020-04-20T12:29:49Z", "author": {"login": "tiagodolphine"}, "path": "addons/persistence/filesystem-persistence-addon/src/test/java/org/kie/persistence/filesystem/FileSystemProcessInstancesTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.persistence.filesystem;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_COMPLETED;\n+\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.services.identity.StaticIdentityProvider;\n+\n+public class FileSystemProcessInstancesTest {\n+\n+\t\n+\tprivate SecurityPolicy securityPolicy = SecurityPolicy.of(new StaticIdentityProvider(\"john\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ead05b67b71ae1c42b88e86ea5d03d561b62e0b"}, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0ead05b67b71ae1c42b88e86ea5d03d561b62e0b", "author": {"user": {"login": "mswiderski", "name": "Maciej Swiderski"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/0ead05b67b71ae1c42b88e86ea5d03d561b62e0b", "committedDate": "2020-04-17T12:17:08Z", "message": "KOGITO-1631 - File System based persistence addon"}, "afterCommit": {"oid": "b748af707ac34620f05f7dd91a2f98ae54ac9ab9", "author": {"user": {"login": "mswiderski", "name": "Maciej Swiderski"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b748af707ac34620f05f7dd91a2f98ae54ac9ab9", "committedDate": "2020-04-20T13:10:23Z", "message": "KOGITO-1631 - File System based persistence addon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTIxMjI1", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#pullrequestreview-396521225", "createdAt": "2020-04-20T14:43:17Z", "commit": {"oid": "b748af707ac34620f05f7dd91a2f98ae54ac9ab9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b748af707ac34620f05f7dd91a2f98ae54ac9ab9", "author": {"user": {"login": "mswiderski", "name": "Maciej Swiderski"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b748af707ac34620f05f7dd91a2f98ae54ac9ab9", "committedDate": "2020-04-20T13:10:23Z", "message": "KOGITO-1631 - File System based persistence addon"}, "afterCommit": {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842", "author": {"user": {"login": "mswiderski", "name": "Maciej Swiderski"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/88fb8db9e595c086fd6bf0925c66214ece19b842", "committedDate": "2020-04-20T15:50:57Z", "message": "KOGITO-1631 - File System based persistence addon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NjQwMzA1", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#pullrequestreview-396640305", "createdAt": "2020-04-20T16:57:33Z", "commit": {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTY0MDQx", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#pullrequestreview-396564041", "createdAt": "2020-04-20T15:28:52Z", "commit": {"oid": "b748af707ac34620f05f7dd91a2f98ae54ac9ab9"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNToyODo1MlrOGIaSFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzo0MDoyNlrOGIgD4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3MjQwNg==", "bodyText": "Don't we want to inform a user in case a process instance we are trying to update does not exist?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411472406", "createdAt": "2020-04-20T15:28:52Z", "author": {"login": "MarianMacik"}, "path": "addons/persistence/filesystem-persistence-addon/src/main/java/org/kie/kogito/persistence/filesystem/FileSystemProcessInstances.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.filesystem;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.UserDefinedFileAttributeView;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@SuppressWarnings({\"rawtypes\"})\n+public class FileSystemProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FileSystemProcessInstances.class);\n+\n+    private static final String PI_DESCRIPTION = \"ProcessInstanceDescription\";\n+    private Process<?> process;\n+    private Path storage;\n+\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage) {\n+        this(process, storage, new ProcessInstanceMarshaller());\n+    }\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage, ProcessInstanceMarshaller marshaller) {\n+        this.process = process;\n+        this.storage = Paths.get(storage.toString(), process.id());\n+        this.marshaller = marshaller;\n+\n+        try {\n+            Files.createDirectories(this.storage);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to create directories for file based storage of process instances\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional findById(String id) {\n+        String resolvedId = resolveId(id);\n+        Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+        if (Files.notExists(processInstanceStorage)) {\n+            return Optional.empty();\n+        }\n+        return (Optional<? extends ProcessInstance>) Optional.of(marshaller.unmarshallProcessInstance(readBytesFromFile(processInstanceStorage), process));\n+\n+    }\n+\n+    @Override\n+    public Collection values() {\n+        try {\n+            return Files.walk(storage)\n+                        .filter(file -> !Files.isDirectory(file))\n+                        .map(f -> marshaller.unmarshallProcessInstance(readBytesFromFile(f), process))\n+                        .collect(Collectors.toList());\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return Files.exists(Paths.get(storage.toString(), resolveId(id)));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            String resolvedId = resolveId(id);\n+            Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+            if (Files.exists(processInstanceStorage)) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            storeProcessInstance(processInstanceStorage, instance);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            String resolvedId = resolveId(id);\n+            Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+            if (Files.exists(processInstanceStorage)) {\n+                storeProcessInstance(processInstanceStorage, instance);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b748af707ac34620f05f7dd91a2f98ae54ac9ab9"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3MzMyNg==", "bodyText": "Shouldn't we inform a user if the process instance we are trying to delete does not exist? This can really help avoid potential issues in the future in case there is a bug in the code.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411473326", "createdAt": "2020-04-20T15:29:58Z", "author": {"login": "MarianMacik"}, "path": "addons/persistence/filesystem-persistence-addon/src/main/java/org/kie/kogito/persistence/filesystem/FileSystemProcessInstances.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.filesystem;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.UserDefinedFileAttributeView;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@SuppressWarnings({\"rawtypes\"})\n+public class FileSystemProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FileSystemProcessInstances.class);\n+\n+    private static final String PI_DESCRIPTION = \"ProcessInstanceDescription\";\n+    private Process<?> process;\n+    private Path storage;\n+\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage) {\n+        this(process, storage, new ProcessInstanceMarshaller());\n+    }\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage, ProcessInstanceMarshaller marshaller) {\n+        this.process = process;\n+        this.storage = Paths.get(storage.toString(), process.id());\n+        this.marshaller = marshaller;\n+\n+        try {\n+            Files.createDirectories(this.storage);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to create directories for file based storage of process instances\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional findById(String id) {\n+        String resolvedId = resolveId(id);\n+        Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+        if (Files.notExists(processInstanceStorage)) {\n+            return Optional.empty();\n+        }\n+        return (Optional<? extends ProcessInstance>) Optional.of(marshaller.unmarshallProcessInstance(readBytesFromFile(processInstanceStorage), process));\n+\n+    }\n+\n+    @Override\n+    public Collection values() {\n+        try {\n+            return Files.walk(storage)\n+                        .filter(file -> !Files.isDirectory(file))\n+                        .map(f -> marshaller.unmarshallProcessInstance(readBytesFromFile(f), process))\n+                        .collect(Collectors.toList());\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return Files.exists(Paths.get(storage.toString(), resolveId(id)));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            String resolvedId = resolveId(id);\n+            Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+            if (Files.exists(processInstanceStorage)) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            storeProcessInstance(processInstanceStorage, instance);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            String resolvedId = resolveId(id);\n+            Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+            if (Files.exists(processInstanceStorage)) {\n+                storeProcessInstance(processInstanceStorage, instance);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        Path processInstanceStorage = Paths.get(storage.toString(), resolveId(id));\n+\n+        try {\n+            Files.deleteIfExists(processInstanceStorage);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to remove process instance with id \" + id, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b748af707ac34620f05f7dd91a2f98ae54ac9ab9"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MDU0MA==", "bodyText": "mutually", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411490540", "createdAt": "2020-04-20T15:51:50Z", "author": {"login": "MarianMacik"}, "path": "pom.xml", "diffHunk": "@@ -842,6 +842,8 @@\n                               <include name=\"**/target/classes/**/*.class\"/>\n                               <!-- To avoid a complaint about duplicate classes from archetypes. -->\n                               <exclude name=\"**/target/test-classes/**/*.class\"/>\n+                              <!-- To avoid a complaint about duplicate classes as KogitoProcessInstancesFactory.class is required in every persistence addon that is mutally exclusive. -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwODA2MQ==", "bodyText": "Would be good to have this at the top as a constant as well.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411508061", "createdAt": "2020-04-20T16:14:00Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -273,4 +147,199 @@ public void setDependencyInjection(DependencyInjectionAnnotator annotator) {\n     protected boolean useInjection() {\n         return this.annotator != null;\n     }\n+    \n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    protected void inifinispanBasedPersistence(List<GeneratedFile> generatedFiles) {\n+        Collection dataModelClasses = protoGenerator.extractDataClasses((Collection) modelClasses, targetDirectory.toString());\n+        Path protoFilePath = Paths.get(targetDirectory.getParent(), \"src/main/resources\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+        File persistencePath = Paths.get(targetDirectory.getAbsolutePath(), \"/classes/persistence\").toFile();\n+        \n+        if (persistencePath != null && persistencePath.isDirectory()) {\n+            // only process proto files generated by the inner generator\n+            for (final File protoFile : Objects.requireNonNull(persistencePath.listFiles((dir, name) ->\n+                    !KOGITO_APPLICATION_PROTO.equalsIgnoreCase(name) && name.toLowerCase().endsWith(PersistenceProtoFilesLabeler.PROTO_FILE_EXT))))\n+                this.persistenceProtoLabeler.processProto(protoFile);\n+        }\n+        \n+        if (!protoFilePath.toFile().exists()) {\n+            try {\n+                // generate proto file based on known data model\n+                Proto proto = protoGenerator.generate(packageName, dataModelClasses, \"import \\\"kogito-types.proto\\\";\");\n+                protoFilePath = Paths.get(targetDirectory.toString(), \"classes\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+            \n+                Files.createDirectories(protoFilePath.getParent());\n+                Files.write(protoFilePath, proto.toString().getBytes(StandardCharsets.UTF_8));\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error during proto file generation/store\", e);\n+            }\n+            \n+        }\n+    \n+    \n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n+        \n+        ConstructorDeclaration constructor = persistenceProviderClazz.addConstructor(Keyword.PUBLIC);\n+        \n+        List<Expression> paramNames = new ArrayList<>();\n+        for (String parameter : parameters) {\n+            String name = \"param\" + paramNames.size();\n+            constructor.addParameter(parameter, name);\n+            paramNames.add(new NameExpr(name));\n+        }\n+        BlockStmt body = new BlockStmt();\n+        ExplicitConstructorInvocationStmt superExp = new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(paramNames));\n+        body.addStatement(superExp);\n+        \n+        constructor.setBody(body);\n+        \n+        if (useInjection()) {\n+            annotator.withApplicationComponent(persistenceProviderClazz);\n+            annotator.withInjection(constructor);\n+            \n+            FieldDeclaration templateNameField = new FieldDeclaration().addVariable(new VariableDeclarator()\n+                                                                                     .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n+                                                                                     .setName(TEMPLATE_NAME));\n+            annotator.withConfigInjection(templateNameField, \"kogito.persistence.infinispan.template\");\n+            // allow to inject template name for the cache\n+            BlockStmt templateMethodBody = new BlockStmt();                \n+            templateMethodBody.addStatement(new ReturnStmt(new MethodCallExpr(new NameExpr(TEMPLATE_NAME), \"orElse\").addArgument(new StringLiteralExpr(\"\"))));\n+            \n+            MethodDeclaration templateNameMethod = new MethodDeclaration()\n+                    .addModifier(Keyword.PUBLIC)\n+                    .setName(\"template\")\n+                    .setType(String.class)                                \n+                    .setBody(templateMethodBody);\n+            \n+            persistenceProviderClazz.addMember(templateNameField);\n+            persistenceProviderClazz.addMember(templateNameMethod);\n+        }\n+        List<String> variableMarshallers = new ArrayList<>();  \n+        // handler process variable marshallers\n+        if (protoFilePath.toFile().exists()) {\n+            MarshallerGenerator marshallerGenerator = new MarshallerGenerator(this.classLoader);\n+            try {\n+                String protoContent = new String(Files.readAllBytes(protoFilePath));\n+                \n+                List<CompilationUnit> marshallers = marshallerGenerator.generate(protoContent);\n+                \n+                if (!marshallers.isEmpty()) {\n+                    \n+                    for (CompilationUnit marshallerClazz : marshallers) {\n+                        String packageName = marshallerClazz.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                        String clazzName = packageName + \".\" + marshallerClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+                     \n+                        variableMarshallers.add(clazzName);\n+                        \n+                        generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                          clazzName.replace('.', '/') + \".java\",\n+                                          marshallerClazz.toString().getBytes(StandardCharsets.UTF_8)));                        \n+                    }                    \n+                }\n+        \n+                // handler process variable marshallers                                     \n+                if (!variableMarshallers.isEmpty()) {\n+                    \n+                    MethodDeclaration protoMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"proto\")\n+                            .setType(String.class)                                \n+                            .setBody(new BlockStmt()\n+                                     .addStatement(new ReturnStmt(new StringLiteralExpr().setString(protoContent))));\n+                    \n+                    persistenceProviderClazz.addMember(protoMethod);\n+                    \n+                    ClassOrInterfaceType listType = new ClassOrInterfaceType(null, List.class.getCanonicalName());\n+                    BlockStmt marshallersMethodBody = new BlockStmt();\n+                    VariableDeclarationExpr marshallerList = new VariableDeclarationExpr(new VariableDeclarator(listType, \"list\", new ObjectCreationExpr(null, new ClassOrInterfaceType(null, ArrayList.class.getCanonicalName()), NodeList.nodeList())));\n+                    marshallersMethodBody.addStatement(marshallerList);\n+                    \n+                    for (String marshallerClazz : variableMarshallers) {\n+                        \n+                        MethodCallExpr addMarshallerMethod = new MethodCallExpr(new NameExpr(\"list\"), \"add\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, marshallerClazz), NodeList.nodeList()));\n+                        marshallersMethodBody.addStatement(addMarshallerMethod);\n+                        \n+                    }\n+                    \n+                    marshallersMethodBody.addStatement(new ReturnStmt(new NameExpr(\"list\")));\n+                    \n+                    MethodDeclaration marshallersMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"marshallers\")\n+                            .setType(listType)                                \n+                            .setBody(marshallersMethodBody);\n+                    \n+                    persistenceProviderClazz.addMember(marshallersMethod);\n+                }\n+                    \n+                \n+                String packageName = compilationUnit.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                String clazzName = packageName + \".\" + persistenceProviderClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+             \n+                generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                                     clazzName.replace('.', '/') + \".java\",\n+                                                     compilationUnit.toString().getBytes(StandardCharsets.UTF_8))); \n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error when generating marshallers for defined variables\", e);\n+            }\n+            persistenceProviderClazz.getMembers().sort(new BodyDeclarationComparator());\n+        }\n+    }\n+    \n+    protected void fileSystemBasedPersistence(List<GeneratedFile> generatedFiles) {\n+    \tClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n+        \n+        ConstructorDeclaration constructor = persistenceProviderClazz.addConstructor(Keyword.PUBLIC);\n+        constructor.addParameter(new ClassOrInterfaceType(null, String.class.getName()), \"storagePath\");\n+        BlockStmt body = new BlockStmt();\n+        ExplicitConstructorInvocationStmt superExp = new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new MethodCallExpr(new NameExpr(Paths.class.getCanonicalName()), \"get\").addArgument(new NameExpr(\"storagePath\"))));\n+        body.addStatement(superExp);\n+        \n+        constructor.setBody(body);\n+        \n+        if (useInjection()) {\n+            annotator.withApplicationComponent(persistenceProviderClazz);            \n+            \n+            FieldDeclaration pathField = new FieldDeclaration().addVariable(new VariableDeclarator()\n+                                                                                     .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n+                                                                                     .setName(PATH_NAME));\n+            annotator.withConfigInjection(pathField, \"kogito.persistence.filesystem.path\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842"}, "originalPosition": 386}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTA3Nw==", "bodyText": "PATH_NAME can be used here as well.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411519077", "createdAt": "2020-04-20T16:28:58Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -273,4 +147,199 @@ public void setDependencyInjection(DependencyInjectionAnnotator annotator) {\n     protected boolean useInjection() {\n         return this.annotator != null;\n     }\n+    \n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    protected void inifinispanBasedPersistence(List<GeneratedFile> generatedFiles) {\n+        Collection dataModelClasses = protoGenerator.extractDataClasses((Collection) modelClasses, targetDirectory.toString());\n+        Path protoFilePath = Paths.get(targetDirectory.getParent(), \"src/main/resources\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+        File persistencePath = Paths.get(targetDirectory.getAbsolutePath(), \"/classes/persistence\").toFile();\n+        \n+        if (persistencePath != null && persistencePath.isDirectory()) {\n+            // only process proto files generated by the inner generator\n+            for (final File protoFile : Objects.requireNonNull(persistencePath.listFiles((dir, name) ->\n+                    !KOGITO_APPLICATION_PROTO.equalsIgnoreCase(name) && name.toLowerCase().endsWith(PersistenceProtoFilesLabeler.PROTO_FILE_EXT))))\n+                this.persistenceProtoLabeler.processProto(protoFile);\n+        }\n+        \n+        if (!protoFilePath.toFile().exists()) {\n+            try {\n+                // generate proto file based on known data model\n+                Proto proto = protoGenerator.generate(packageName, dataModelClasses, \"import \\\"kogito-types.proto\\\";\");\n+                protoFilePath = Paths.get(targetDirectory.toString(), \"classes\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+            \n+                Files.createDirectories(protoFilePath.getParent());\n+                Files.write(protoFilePath, proto.toString().getBytes(StandardCharsets.UTF_8));\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error during proto file generation/store\", e);\n+            }\n+            \n+        }\n+    \n+    \n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n+        \n+        ConstructorDeclaration constructor = persistenceProviderClazz.addConstructor(Keyword.PUBLIC);\n+        \n+        List<Expression> paramNames = new ArrayList<>();\n+        for (String parameter : parameters) {\n+            String name = \"param\" + paramNames.size();\n+            constructor.addParameter(parameter, name);\n+            paramNames.add(new NameExpr(name));\n+        }\n+        BlockStmt body = new BlockStmt();\n+        ExplicitConstructorInvocationStmt superExp = new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(paramNames));\n+        body.addStatement(superExp);\n+        \n+        constructor.setBody(body);\n+        \n+        if (useInjection()) {\n+            annotator.withApplicationComponent(persistenceProviderClazz);\n+            annotator.withInjection(constructor);\n+            \n+            FieldDeclaration templateNameField = new FieldDeclaration().addVariable(new VariableDeclarator()\n+                                                                                     .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n+                                                                                     .setName(TEMPLATE_NAME));\n+            annotator.withConfigInjection(templateNameField, \"kogito.persistence.infinispan.template\");\n+            // allow to inject template name for the cache\n+            BlockStmt templateMethodBody = new BlockStmt();                \n+            templateMethodBody.addStatement(new ReturnStmt(new MethodCallExpr(new NameExpr(TEMPLATE_NAME), \"orElse\").addArgument(new StringLiteralExpr(\"\"))));\n+            \n+            MethodDeclaration templateNameMethod = new MethodDeclaration()\n+                    .addModifier(Keyword.PUBLIC)\n+                    .setName(\"template\")\n+                    .setType(String.class)                                \n+                    .setBody(templateMethodBody);\n+            \n+            persistenceProviderClazz.addMember(templateNameField);\n+            persistenceProviderClazz.addMember(templateNameMethod);\n+        }\n+        List<String> variableMarshallers = new ArrayList<>();  \n+        // handler process variable marshallers\n+        if (protoFilePath.toFile().exists()) {\n+            MarshallerGenerator marshallerGenerator = new MarshallerGenerator(this.classLoader);\n+            try {\n+                String protoContent = new String(Files.readAllBytes(protoFilePath));\n+                \n+                List<CompilationUnit> marshallers = marshallerGenerator.generate(protoContent);\n+                \n+                if (!marshallers.isEmpty()) {\n+                    \n+                    for (CompilationUnit marshallerClazz : marshallers) {\n+                        String packageName = marshallerClazz.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                        String clazzName = packageName + \".\" + marshallerClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+                     \n+                        variableMarshallers.add(clazzName);\n+                        \n+                        generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                          clazzName.replace('.', '/') + \".java\",\n+                                          marshallerClazz.toString().getBytes(StandardCharsets.UTF_8)));                        \n+                    }                    \n+                }\n+        \n+                // handler process variable marshallers                                     \n+                if (!variableMarshallers.isEmpty()) {\n+                    \n+                    MethodDeclaration protoMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"proto\")\n+                            .setType(String.class)                                \n+                            .setBody(new BlockStmt()\n+                                     .addStatement(new ReturnStmt(new StringLiteralExpr().setString(protoContent))));\n+                    \n+                    persistenceProviderClazz.addMember(protoMethod);\n+                    \n+                    ClassOrInterfaceType listType = new ClassOrInterfaceType(null, List.class.getCanonicalName());\n+                    BlockStmt marshallersMethodBody = new BlockStmt();\n+                    VariableDeclarationExpr marshallerList = new VariableDeclarationExpr(new VariableDeclarator(listType, \"list\", new ObjectCreationExpr(null, new ClassOrInterfaceType(null, ArrayList.class.getCanonicalName()), NodeList.nodeList())));\n+                    marshallersMethodBody.addStatement(marshallerList);\n+                    \n+                    for (String marshallerClazz : variableMarshallers) {\n+                        \n+                        MethodCallExpr addMarshallerMethod = new MethodCallExpr(new NameExpr(\"list\"), \"add\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, marshallerClazz), NodeList.nodeList()));\n+                        marshallersMethodBody.addStatement(addMarshallerMethod);\n+                        \n+                    }\n+                    \n+                    marshallersMethodBody.addStatement(new ReturnStmt(new NameExpr(\"list\")));\n+                    \n+                    MethodDeclaration marshallersMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"marshallers\")\n+                            .setType(listType)                                \n+                            .setBody(marshallersMethodBody);\n+                    \n+                    persistenceProviderClazz.addMember(marshallersMethod);\n+                }\n+                    \n+                \n+                String packageName = compilationUnit.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                String clazzName = packageName + \".\" + persistenceProviderClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+             \n+                generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                                     clazzName.replace('.', '/') + \".java\",\n+                                                     compilationUnit.toString().getBytes(StandardCharsets.UTF_8))); \n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error when generating marshallers for defined variables\", e);\n+            }\n+            persistenceProviderClazz.getMembers().sort(new BodyDeclarationComparator());\n+        }\n+    }\n+    \n+    protected void fileSystemBasedPersistence(List<GeneratedFile> generatedFiles) {\n+    \tClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n+        \n+        ConstructorDeclaration constructor = persistenceProviderClazz.addConstructor(Keyword.PUBLIC);\n+        constructor.addParameter(new ClassOrInterfaceType(null, String.class.getName()), \"storagePath\");\n+        BlockStmt body = new BlockStmt();\n+        ExplicitConstructorInvocationStmt superExp = new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new MethodCallExpr(new NameExpr(Paths.class.getCanonicalName()), \"get\").addArgument(new NameExpr(\"storagePath\"))));\n+        body.addStatement(superExp);\n+        \n+        constructor.setBody(body);\n+        \n+        if (useInjection()) {\n+            annotator.withApplicationComponent(persistenceProviderClazz);            \n+            \n+            FieldDeclaration pathField = new FieldDeclaration().addVariable(new VariableDeclarator()\n+                                                                                     .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n+                                                                                     .setName(PATH_NAME));\n+            annotator.withConfigInjection(pathField, \"kogito.persistence.filesystem.path\");\n+            // allow to inject path for the file system storage\n+            BlockStmt pathMethodBody = new BlockStmt();                \n+            pathMethodBody.addStatement(new ReturnStmt(new MethodCallExpr(new NameExpr(PATH_NAME), \"orElse\").addArgument(new StringLiteralExpr(\"/tmp\"))));\n+            \n+            MethodDeclaration pathMethod = new MethodDeclaration()\n+                    .addModifier(Keyword.PUBLIC)\n+                    .setName(\"path\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842"}, "originalPosition": 393}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MjA2Nw==", "bodyText": "We can call just super() here and the effect will be the same.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411562067", "createdAt": "2020-04-20T17:32:42Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -273,4 +147,199 @@ public void setDependencyInjection(DependencyInjectionAnnotator annotator) {\n     protected boolean useInjection() {\n         return this.annotator != null;\n     }\n+    \n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    protected void inifinispanBasedPersistence(List<GeneratedFile> generatedFiles) {\n+        Collection dataModelClasses = protoGenerator.extractDataClasses((Collection) modelClasses, targetDirectory.toString());\n+        Path protoFilePath = Paths.get(targetDirectory.getParent(), \"src/main/resources\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+        File persistencePath = Paths.get(targetDirectory.getAbsolutePath(), \"/classes/persistence\").toFile();\n+        \n+        if (persistencePath != null && persistencePath.isDirectory()) {\n+            // only process proto files generated by the inner generator\n+            for (final File protoFile : Objects.requireNonNull(persistencePath.listFiles((dir, name) ->\n+                    !KOGITO_APPLICATION_PROTO.equalsIgnoreCase(name) && name.toLowerCase().endsWith(PersistenceProtoFilesLabeler.PROTO_FILE_EXT))))\n+                this.persistenceProtoLabeler.processProto(protoFile);\n+        }\n+        \n+        if (!protoFilePath.toFile().exists()) {\n+            try {\n+                // generate proto file based on known data model\n+                Proto proto = protoGenerator.generate(packageName, dataModelClasses, \"import \\\"kogito-types.proto\\\";\");\n+                protoFilePath = Paths.get(targetDirectory.toString(), \"classes\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+            \n+                Files.createDirectories(protoFilePath.getParent());\n+                Files.write(protoFilePath, proto.toString().getBytes(StandardCharsets.UTF_8));\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error during proto file generation/store\", e);\n+            }\n+            \n+        }\n+    \n+    \n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n+        \n+        ConstructorDeclaration constructor = persistenceProviderClazz.addConstructor(Keyword.PUBLIC);\n+        \n+        List<Expression> paramNames = new ArrayList<>();\n+        for (String parameter : parameters) {\n+            String name = \"param\" + paramNames.size();\n+            constructor.addParameter(parameter, name);\n+            paramNames.add(new NameExpr(name));\n+        }\n+        BlockStmt body = new BlockStmt();\n+        ExplicitConstructorInvocationStmt superExp = new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(paramNames));\n+        body.addStatement(superExp);\n+        \n+        constructor.setBody(body);\n+        \n+        if (useInjection()) {\n+            annotator.withApplicationComponent(persistenceProviderClazz);\n+            annotator.withInjection(constructor);\n+            \n+            FieldDeclaration templateNameField = new FieldDeclaration().addVariable(new VariableDeclarator()\n+                                                                                     .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n+                                                                                     .setName(TEMPLATE_NAME));\n+            annotator.withConfigInjection(templateNameField, \"kogito.persistence.infinispan.template\");\n+            // allow to inject template name for the cache\n+            BlockStmt templateMethodBody = new BlockStmt();                \n+            templateMethodBody.addStatement(new ReturnStmt(new MethodCallExpr(new NameExpr(TEMPLATE_NAME), \"orElse\").addArgument(new StringLiteralExpr(\"\"))));\n+            \n+            MethodDeclaration templateNameMethod = new MethodDeclaration()\n+                    .addModifier(Keyword.PUBLIC)\n+                    .setName(\"template\")\n+                    .setType(String.class)                                \n+                    .setBody(templateMethodBody);\n+            \n+            persistenceProviderClazz.addMember(templateNameField);\n+            persistenceProviderClazz.addMember(templateNameMethod);\n+        }\n+        List<String> variableMarshallers = new ArrayList<>();  \n+        // handler process variable marshallers\n+        if (protoFilePath.toFile().exists()) {\n+            MarshallerGenerator marshallerGenerator = new MarshallerGenerator(this.classLoader);\n+            try {\n+                String protoContent = new String(Files.readAllBytes(protoFilePath));\n+                \n+                List<CompilationUnit> marshallers = marshallerGenerator.generate(protoContent);\n+                \n+                if (!marshallers.isEmpty()) {\n+                    \n+                    for (CompilationUnit marshallerClazz : marshallers) {\n+                        String packageName = marshallerClazz.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                        String clazzName = packageName + \".\" + marshallerClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+                     \n+                        variableMarshallers.add(clazzName);\n+                        \n+                        generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                          clazzName.replace('.', '/') + \".java\",\n+                                          marshallerClazz.toString().getBytes(StandardCharsets.UTF_8)));                        \n+                    }                    \n+                }\n+        \n+                // handler process variable marshallers                                     \n+                if (!variableMarshallers.isEmpty()) {\n+                    \n+                    MethodDeclaration protoMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"proto\")\n+                            .setType(String.class)                                \n+                            .setBody(new BlockStmt()\n+                                     .addStatement(new ReturnStmt(new StringLiteralExpr().setString(protoContent))));\n+                    \n+                    persistenceProviderClazz.addMember(protoMethod);\n+                    \n+                    ClassOrInterfaceType listType = new ClassOrInterfaceType(null, List.class.getCanonicalName());\n+                    BlockStmt marshallersMethodBody = new BlockStmt();\n+                    VariableDeclarationExpr marshallerList = new VariableDeclarationExpr(new VariableDeclarator(listType, \"list\", new ObjectCreationExpr(null, new ClassOrInterfaceType(null, ArrayList.class.getCanonicalName()), NodeList.nodeList())));\n+                    marshallersMethodBody.addStatement(marshallerList);\n+                    \n+                    for (String marshallerClazz : variableMarshallers) {\n+                        \n+                        MethodCallExpr addMarshallerMethod = new MethodCallExpr(new NameExpr(\"list\"), \"add\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, marshallerClazz), NodeList.nodeList()));\n+                        marshallersMethodBody.addStatement(addMarshallerMethod);\n+                        \n+                    }\n+                    \n+                    marshallersMethodBody.addStatement(new ReturnStmt(new NameExpr(\"list\")));\n+                    \n+                    MethodDeclaration marshallersMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"marshallers\")\n+                            .setType(listType)                                \n+                            .setBody(marshallersMethodBody);\n+                    \n+                    persistenceProviderClazz.addMember(marshallersMethod);\n+                }\n+                    \n+                \n+                String packageName = compilationUnit.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                String clazzName = packageName + \".\" + persistenceProviderClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+             \n+                generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                                     clazzName.replace('.', '/') + \".java\",\n+                                                     compilationUnit.toString().getBytes(StandardCharsets.UTF_8))); \n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error when generating marshallers for defined variables\", e);\n+            }\n+            persistenceProviderClazz.getMembers().sort(new BodyDeclarationComparator());\n+        }\n+    }\n+    \n+    protected void fileSystemBasedPersistence(List<GeneratedFile> generatedFiles) {\n+    \tClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842"}, "originalPosition": 370}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MjEzMQ==", "bodyText": "Why not unify it with generated KogitoProcessInstancesFactoryImpl? storage is not actually used as only its String representation is. We can make String from storage and then just override a setter in the generated class with injection. By doing this we won't need any path method and also we won't need additional path field in the generated class, wdyt?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411562131", "createdAt": "2020-04-20T17:32:48Z", "author": {"login": "MarianMacik"}, "path": "addons/persistence/filesystem-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.kie.kogito.persistence.filesystem.FileSystemProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ *\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+   \n+\tprivate Path storage; ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2Mjc4NQ==", "bodyText": "What was the reason for adding this?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411562785", "createdAt": "2020-04-20T17:33:52Z", "author": {"login": "MarianMacik"}, "path": "kogito-maven-plugin/src/main/java/org/kie/kogito/maven/plugin/ProcessClassesMojo.java", "diffHunk": "@@ -107,10 +111,14 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n                         parameters.add(t.getTypeName());\n                     }\n                 }\n+                \n+                GeneratorContext context = GeneratorContext.ofResourcePath(kieSourcesDirectory);\n+                context.withBuildContext(discoverKogitoRuntimeContext(project));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2NzA3Mg==", "bodyText": "Can't we do this based on kogito.addon files?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411567072", "createdAt": "2020-04-20T17:40:26Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -102,152 +109,19 @@ public ApplicationSection section() {\n         return null;\n     }\n \n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    \n     @Override\n     public Collection<GeneratedFile> generate() {\n+    \tString persistenceType = context.getApplicationProperty(\"kogito.persistence.type\").orElse(DEFAULT_PERSISTENCE_TYPE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a65f9fbe92e6902c20d72caa98e8017e327da135", "author": {"user": {"login": "mswiderski", "name": "Maciej Swiderski"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a65f9fbe92e6902c20d72caa98e8017e327da135", "committedDate": "2020-04-20T19:24:24Z", "message": "KOGITO-1631 - File System based persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842", "author": {"user": {"login": "mswiderski", "name": "Maciej Swiderski"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/88fb8db9e595c086fd6bf0925c66214ece19b842", "committedDate": "2020-04-20T15:50:57Z", "message": "KOGITO-1631 - File System based persistence addon"}, "afterCommit": {"oid": "a65f9fbe92e6902c20d72caa98e8017e327da135", "author": {"user": {"login": "mswiderski", "name": "Maciej Swiderski"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a65f9fbe92e6902c20d72caa98e8017e327da135", "committedDate": "2020-04-20T19:24:24Z", "message": "KOGITO-1631 - File System based persistence addon"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3651, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}