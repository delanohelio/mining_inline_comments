{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0OTc1NzA0", "number": 451, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjoxNzoxOVrODy4OMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo1Njo1MFrODz3_oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Njc2NTMxOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjoxNzoxOVrOGHLoHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjoyMTozNFrOGHLwFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE4MzcxMA==", "bodyText": "@mswiderski could you use a logger or remove these?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r410183710", "createdAt": "2020-04-17T12:17:19Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "diffHunk": "@@ -1006,6 +1176,10 @@ public void testTimerBoundaryEventDuration() throws Exception {\n         ksession.addEventListener(countDownListener);\n         ProcessInstance processInstance = ksession.startProcess(\"TimerBoundaryEvent\");\n         assertProcessInstanceActive(processInstance);\n+        \n+        System.out.println(\"Events  \" + ((WorkflowProcessInstanceImpl) processInstance).getEventDescriptions());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2646f4c79d8fdd642dcc57a8a578875dd537789b"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE4NTc0OQ==", "bodyText": "leftover will remove", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r410185749", "createdAt": "2020-04-17T12:21:34Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "diffHunk": "@@ -1006,6 +1176,10 @@ public void testTimerBoundaryEventDuration() throws Exception {\n         ksession.addEventListener(countDownListener);\n         ProcessInstance processInstance = ksession.startProcess(\"TimerBoundaryEvent\");\n         assertProcessInstanceActive(processInstance);\n+        \n+        System.out.println(\"Events  \" + ((WorkflowProcessInstanceImpl) processInstance).getEventDescriptions());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE4MzcxMA=="}, "originalCommit": {"oid": "2646f4c79d8fdd642dcc57a8a578875dd537789b"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjgyNDIwOnYy", "diffSide": "RIGHT", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/GroupedNamedDataType.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjozNjo0OFrOGHMM4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMzoxNDoxOFrOGHNb3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5MzEyMA==", "bodyText": "this is not really used, so not sure if you want to keep it.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r410193120", "createdAt": "2020-04-17T12:36:48Z", "author": {"login": "cristianonicolai"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/GroupedNamedDataType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class GroupedNamedDataType {\n+\n+    private final Map<String, Set<NamedDataType>> groupedDataTypes = new HashMap<>();\n+\n+    public void add(String name, NamedDataType dataType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2646f4c79d8fdd642dcc57a8a578875dd537789b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIxMzM0Mg==", "bodyText": "removed", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r410213342", "createdAt": "2020-04-17T13:14:18Z", "author": {"login": "mswiderski"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/GroupedNamedDataType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class GroupedNamedDataType {\n+\n+    private final Map<String, Set<NamedDataType>> groupedDataTypes = new HashMap<>();\n+\n+    public void add(String name, NamedDataType dataType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5MzEyMA=="}, "originalCommit": {"oid": "2646f4c79d8fdd642dcc57a8a578875dd537789b"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjgyODczOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/EventNodeInstance.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjozODoxMFrOGHMPkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMzoxODo1N1rOGHNmnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5MzgwOQ==", "bodyText": "could you add some test to cover these two methods?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r410193809", "createdAt": "2020-04-17T12:38:10Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/EventNodeInstance.java", "diffHunk": "@@ -285,4 +291,20 @@ private String resolveVariable(String s) {\n \tprivate void callSignal(String type, Object event) {\n \t    signalEvent(type, event);\n \t}\n+\n+    @Override\n+    public String[] getEventTypes() {\n+        return new String[] {getEventType()};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2646f4c79d8fdd642dcc57a8a578875dd537789b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIxNjA5Mw==", "bodyText": "not sure what you want to test.. this was just exposing already defined method to fit the interface.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r410216093", "createdAt": "2020-04-17T13:18:57Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/EventNodeInstance.java", "diffHunk": "@@ -285,4 +291,20 @@ private String resolveVariable(String s) {\n \tprivate void callSignal(String type, Object event) {\n \t    signalEvent(type, event);\n \t}\n+\n+    @Override\n+    public String[] getEventTypes() {\n+        return new String[] {getEventType()};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5MzgwOQ=="}, "originalCommit": {"oid": "2646f4c79d8fdd642dcc57a8a578875dd537789b"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Njg1ODkxOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjo0NzowOVrOGHMiBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjo1MDoxMFrOGHMoZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5ODUzNQ==", "bodyText": "Im wondering here in case we dont actually have a long on ids[1], should i fail completely or handle it and continue to look into the next nodes?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r410198535", "createdAt": "2020-04-17T12:47:09Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java", "diffHunk": "@@ -483,4 +483,28 @@ protected void mapDynamicOutputData(Map<String, Object> results) {\n             }\n         }\n     }\n+    \n+    public Map<String, String> extractTimerEventInformation() {\n+        if (getTimerInstances() != null) {\n+            for (String id : getTimerInstances()) {\n+                String[] ids = id.split(\"_\");\n+                \n+                for (Map.Entry<Timer, DroolsAction> entry : getEventBasedNode().getTimers().entrySet()) {\n+                    if (entry.getKey().getId() == Long.valueOf(ids[1])) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ffcf440e0e258d489fd49799669468a80accaa6"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIwMDE2Ng==", "bodyText": "it should fail completely as this means the id of the timer is not valid", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r410200166", "createdAt": "2020-04-17T12:50:10Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java", "diffHunk": "@@ -483,4 +483,28 @@ protected void mapDynamicOutputData(Map<String, Object> results) {\n             }\n         }\n     }\n+    \n+    public Map<String, String> extractTimerEventInformation() {\n+        if (getTimerInstances() != null) {\n+            for (String id : getTimerInstances()) {\n+                String[] ids = id.split(\"_\");\n+                \n+                for (Map.Entry<Timer, DroolsAction> entry : getEventBasedNode().getTimers().entrySet()) {\n+                    if (entry.getKey().getId() == Long.valueOf(ids[1])) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5ODUzNQ=="}, "originalCommit": {"oid": "7ffcf440e0e258d489fd49799669468a80accaa6"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Njk1MTE2OnYy", "diffSide": "RIGHT", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/NamedDataType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzo1MjozNVrOGIgjhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDowMjo1MFrOGIlYag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3NTE3Mg==", "bodyText": "Unnecessary.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411575172", "createdAt": "2020-04-20T17:52:35Z", "author": {"login": "MarianMacik"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/NamedDataType.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process;\n+\n+\n+public class NamedDataType {\n+\n+    private final String name;\n+\n+    private final Object dataType;\n+\n+    public NamedDataType(String name, Object dataType) {\n+        super();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NDI1MA==", "bodyText": "removed", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411654250", "createdAt": "2020-04-20T20:02:50Z", "author": {"login": "mswiderski"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/NamedDataType.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process;\n+\n+\n+public class NamedDataType {\n+\n+    private final String name;\n+\n+    private final Object dataType;\n+\n+    public NamedDataType(String name, Object dataType) {\n+        super();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3NTE3Mg=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Njk3MzY4OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzo1Nzo0NlrOGIgxBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDowMjo1NVrOGIlYng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3ODYyOA==", "bodyText": "Unnecessary blank line.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411578628", "createdAt": "2020-04-20T17:57:46Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -351,6 +353,14 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n         this.rt.getWorkItemManager().transitionWorkItem(id, transition);\n         removeOnFinish();\n     }\n+    \n+    \n+    @Override\n+    public Set<EventDescription<?>> events() {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NDMwMg==", "bodyText": "removed", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411654302", "createdAt": "2020-04-20T20:02:55Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -351,6 +353,14 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n         this.rt.getWorkItemManager().transitionWorkItem(id, transition);\n         removeOnFinish();\n     }\n+    \n+    \n+    @Override\n+    public Set<EventDescription<?>> events() {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3ODYyOA=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Njk5ODA3OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/EventNodeInterface.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODowMzozNFrOGIg_hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNzo1MDowNVrOGI3t4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4MjM0MQ==", "bodyText": "Probably would be good to add what kind of variable is queried.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411582341", "createdAt": "2020-04-20T18:03:34Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/EventNodeInterface.java", "diffHunk": "@@ -25,5 +25,7 @@\n \tdefault\tboolean acceptsEvent(String type, Object event, Function<String, String> resolver) {\n \t    return acceptsEvent(type, event);\n \t}\n+\t\n+\tString getVariableName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NDcxMQ==", "bodyText": "not sure what you mean...", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411654711", "createdAt": "2020-04-20T20:03:33Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/EventNodeInterface.java", "diffHunk": "@@ -25,5 +25,7 @@\n \tdefault\tboolean acceptsEvent(String type, Object event, Function<String, String> resolver) {\n \t    return acceptsEvent(type, event);\n \t}\n+\t\n+\tString getVariableName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4MjM0MQ=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk1MzY2Nw==", "bodyText": "I didn't get what variableName means basically :) But then found out that it is a kind of the variable used to store the event in?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411953667", "createdAt": "2020-04-21T07:48:34Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/EventNodeInterface.java", "diffHunk": "@@ -25,5 +25,7 @@\n \tdefault\tboolean acceptsEvent(String type, Object event, Function<String, String> resolver) {\n \t    return acceptsEvent(type, event);\n \t}\n+\t\n+\tString getVariableName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4MjM0MQ=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk1NDY1Ng==", "bodyText": "yes, this is the name of the variable that the event payload received will be mapped to on process instance", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411954656", "createdAt": "2020-04-21T07:50:05Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/EventNodeInterface.java", "diffHunk": "@@ -25,5 +25,7 @@\n \tdefault\tboolean acceptsEvent(String type, Object event, Function<String, String> resolver) {\n \t    return acceptsEvent(type, event);\n \t}\n+\t\n+\tString getVariableName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4MjM0MQ=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzAwNDI0OnYy", "diffSide": "RIGHT", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/Process.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODowNToxMFrOGIhDSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDowMzoyOVrOGIlaCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4MzMwNw==", "bodyText": "Unnecessary.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411583307", "createdAt": "2020-04-20T18:05:10Z", "author": {"login": "MarianMacik"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/Process.java", "diffHunk": "@@ -38,4 +38,5 @@\n     void activate();\n \n     void deactivate();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NDY2Nw==", "bodyText": "removed", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411654667", "createdAt": "2020-04-20T20:03:29Z", "author": {"login": "mswiderski"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/Process.java", "diffHunk": "@@ -38,4 +38,5 @@\n     void activate();\n \n     void deactivate();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4MzMwNw=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzA4MjE0OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODoyNDozN1rOGIhxUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDowMzozNlrOGIlaVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5NTA4OQ==", "bodyText": "Probably eventVar?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411595089", "createdAt": "2020-04-20T18:24:37Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "diffHunk": "@@ -765,6 +774,97 @@ private void removeEventListeners() {\n     public String[] getEventTypes() {\n         return externalEventListeners.keySet().stream().map(this::resolveVariable).collect(Collectors.toList()).toArray(new String[externalEventListeners.size()]);\n     }\n+    \n+    @Override\n+    public Set<EventDescription<?>> getEventDescriptions() {\n+        if (getState() == ProcessInstance.STATE_COMPLETED || getState() == ProcessInstance.STATE_ABORTED) {\n+            return Collections.emptySet();\n+        }\n+        VariableScope variableScope = (VariableScope) ((ContextContainer) getProcess()).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+        Set<EventDescription<?>> eventDesciptions = new LinkedHashSet<>();\n+        \n+        List<EventListener> activeListeners = eventListeners.values().stream()\n+                .flatMap(List::stream)\n+                .collect(Collectors.toList());\n+        \n+        activeListeners.addAll(externalEventListeners.values().stream()\n+                    .flatMap(List::stream)\n+                    .collect(Collectors.toList()));\n+        \n+        activeListeners.forEach(el -> eventDesciptions.addAll(el.getEventDescriptions()));\n+        \n+ \n+        ((org.jbpm.workflow.core.WorkflowProcess)getProcess()).getNodesRecursively().stream().filter(n -> n instanceof EventNodeInterface).forEach(n -> {\n+            \n+            NamedDataType dataType = null;\n+            if (((EventNodeInterface)n).getVariableName() != null) {\n+                Variable evantVar = variableScope.findVariable(((EventNodeInterface)n).getVariableName());\n+                if (evantVar != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NDc0Mg==", "bodyText": "fixed", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411654742", "createdAt": "2020-04-20T20:03:36Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "diffHunk": "@@ -765,6 +774,97 @@ private void removeEventListeners() {\n     public String[] getEventTypes() {\n         return externalEventListeners.keySet().stream().map(this::resolveVariable).collect(Collectors.toList()).toArray(new String[externalEventListeners.size()]);\n     }\n+    \n+    @Override\n+    public Set<EventDescription<?>> getEventDescriptions() {\n+        if (getState() == ProcessInstance.STATE_COMPLETED || getState() == ProcessInstance.STATE_ABORTED) {\n+            return Collections.emptySet();\n+        }\n+        VariableScope variableScope = (VariableScope) ((ContextContainer) getProcess()).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+        Set<EventDescription<?>> eventDesciptions = new LinkedHashSet<>();\n+        \n+        List<EventListener> activeListeners = eventListeners.values().stream()\n+                .flatMap(List::stream)\n+                .collect(Collectors.toList());\n+        \n+        activeListeners.addAll(externalEventListeners.values().stream()\n+                    .flatMap(List::stream)\n+                    .collect(Collectors.toList()));\n+        \n+        activeListeners.forEach(el -> eventDesciptions.addAll(el.getEventDescriptions()));\n+        \n+ \n+        ((org.jbpm.workflow.core.WorkflowProcess)getProcess()).getNodesRecursively().stream().filter(n -> n instanceof EventNodeInterface).forEach(n -> {\n+            \n+            NamedDataType dataType = null;\n+            if (((EventNodeInterface)n).getVariableName() != null) {\n+                Variable evantVar = variableScope.findVariable(((EventNodeInterface)n).getVariableName());\n+                if (evantVar != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5NTA4OQ=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzEwOTk1OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODozMTozM1rOGIiCTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDowMzo0N1rOGIla6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5OTQzOA==", "bodyText": "This can be put on less than 3 lines I guess :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411599438", "createdAt": "2020-04-20T18:31:33Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "diffHunk": "@@ -765,6 +774,97 @@ private void removeEventListeners() {\n     public String[] getEventTypes() {\n         return externalEventListeners.keySet().stream().map(this::resolveVariable).collect(Collectors.toList()).toArray(new String[externalEventListeners.size()]);\n     }\n+    \n+    @Override\n+    public Set<EventDescription<?>> getEventDescriptions() {\n+        if (getState() == ProcessInstance.STATE_COMPLETED || getState() == ProcessInstance.STATE_ABORTED) {\n+            return Collections.emptySet();\n+        }\n+        VariableScope variableScope = (VariableScope) ((ContextContainer) getProcess()).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+        Set<EventDescription<?>> eventDesciptions = new LinkedHashSet<>();\n+        \n+        List<EventListener> activeListeners = eventListeners.values().stream()\n+                .flatMap(List::stream)\n+                .collect(Collectors.toList());\n+        \n+        activeListeners.addAll(externalEventListeners.values().stream()\n+                    .flatMap(List::stream)\n+                    .collect(Collectors.toList()));\n+        \n+        activeListeners.forEach(el -> eventDesciptions.addAll(el.getEventDescriptions()));\n+        \n+ \n+        ((org.jbpm.workflow.core.WorkflowProcess)getProcess()).getNodesRecursively().stream().filter(n -> n instanceof EventNodeInterface).forEach(n -> {\n+            \n+            NamedDataType dataType = null;\n+            if (((EventNodeInterface)n).getVariableName() != null) {\n+                Variable evantVar = variableScope.findVariable(((EventNodeInterface)n).getVariableName());\n+                if (evantVar != null) {\n+                    dataType = new NamedDataType(evantVar.getName(), evantVar.getType());\n+                }\n+            }\n+            if (n instanceof BoundaryEventNode) {\n+                BoundaryEventNode boundaryEventNode = (BoundaryEventNode) n;\n+                StateBasedNodeInstance attachedToNodeInstance = (StateBasedNodeInstance) getNodeInstances(true).stream().filter( ni -> ni.getNode().getMetaData().get(\"UniqueId\").equals(boundaryEventNode.getAttachedToNodeId())).findFirst().orElse(null);\n+                if (attachedToNodeInstance != null) {\n+                    Map<String, String> properties = new HashMap<>();\n+                    properties.put(\"AttachedToID\", attachedToNodeInstance.getNodeDefinitionId());\n+                    properties.put(\"AttachedToName\", attachedToNodeInstance.getNodeName());\n+                    String eventType = \"signal\";\n+                    String eventName = boundaryEventNode.getType();\n+                    Map<String, String> timerProperties = attachedToNodeInstance.extractTimerEventInformation();\n+                    if (timerProperties != null) {\n+                        properties.putAll(timerProperties);\n+                        eventType = \"timer\";\n+                        eventName = \"timerTriggered\";\n+                    } \n+                \n+                    eventDesciptions.add(new BaseEventDescription(eventName, (String)n.getMetaData().get(\"UniqueId\"), n.getName(), eventType, null, getId(), dataType, properties));\n+                    \n+                }\n+                \n+            } else if (n instanceof EventSubProcessNode) {\n+                EventSubProcessNode eventSubProcessNode = (EventSubProcessNode) n;\n+                Node startNode = eventSubProcessNode.findStartNode();\n+                Map<Timer, DroolsAction> timers = eventSubProcessNode.getTimers();\n+                if (timers != null && !timers.isEmpty()) {\n+                    getNodeInstances(eventSubProcessNode.getId()).forEach(ni -> {\n+                        \n+                        Map<String, String> timerProperties = ((StateBasedNodeInstance) ni).extractTimerEventInformation();\n+                        if (timerProperties != null) {\n+                         \n+                            eventDesciptions.add(new BaseEventDescription(\"timerTriggered\", (String)startNode.getMetaData().get(\"UniqueId\"), startNode.getName(), \"timer\", ni.getId(), getId(), null, timerProperties));\n+                          \n+                        }\n+                    });\n+                } else {\n+                \n+                    for (String eventName : eventSubProcessNode.getEvents()) {\n+                        \n+                        eventDesciptions.add(new BaseEventDescription(eventName, (String)startNode.getMetaData().get(\"UniqueId\"), startNode.getName(), \"signal\", null, getId(), dataType));\n+                    }\n+                \n+                }\n+            } else if (n instanceof EventNode) {\n+                NamedDataType finalDataType = dataType;\n+                getNodeInstances(n.getId()).forEach(ni -> {\n+                    eventDesciptions.add(new BaseEventDescription(((EventNode) n).getType(), (String) n.getMetaData().get(\"UniqueId\"), n.getName(), (String) n.getMetaData().getOrDefault(\"EventType\", \"signal\"), ni.getId(),\n+                                                              getId(), finalDataType));\n+                });\n+            } else if (n instanceof StateNode) {\n+                \n+                getNodeInstances(n.getId()).forEach(ni -> {\n+                    eventDesciptions.add(new BaseEventDescription((String) n.getMetaData().get(\"Condition\"), (String) n.getMetaData().get(\"UniqueId\"), n.getName(), (String) n.getMetaData().getOrDefault(\"EventType\",\n+                                                                                                                                                                                                      \"signal\"), ni.getId(),\n+                                                              getId(), null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NDg4OQ==", "bodyText": "reformatted", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411654889", "createdAt": "2020-04-20T20:03:47Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "diffHunk": "@@ -765,6 +774,97 @@ private void removeEventListeners() {\n     public String[] getEventTypes() {\n         return externalEventListeners.keySet().stream().map(this::resolveVariable).collect(Collectors.toList()).toArray(new String[externalEventListeners.size()]);\n     }\n+    \n+    @Override\n+    public Set<EventDescription<?>> getEventDescriptions() {\n+        if (getState() == ProcessInstance.STATE_COMPLETED || getState() == ProcessInstance.STATE_ABORTED) {\n+            return Collections.emptySet();\n+        }\n+        VariableScope variableScope = (VariableScope) ((ContextContainer) getProcess()).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+        Set<EventDescription<?>> eventDesciptions = new LinkedHashSet<>();\n+        \n+        List<EventListener> activeListeners = eventListeners.values().stream()\n+                .flatMap(List::stream)\n+                .collect(Collectors.toList());\n+        \n+        activeListeners.addAll(externalEventListeners.values().stream()\n+                    .flatMap(List::stream)\n+                    .collect(Collectors.toList()));\n+        \n+        activeListeners.forEach(el -> eventDesciptions.addAll(el.getEventDescriptions()));\n+        \n+ \n+        ((org.jbpm.workflow.core.WorkflowProcess)getProcess()).getNodesRecursively().stream().filter(n -> n instanceof EventNodeInterface).forEach(n -> {\n+            \n+            NamedDataType dataType = null;\n+            if (((EventNodeInterface)n).getVariableName() != null) {\n+                Variable evantVar = variableScope.findVariable(((EventNodeInterface)n).getVariableName());\n+                if (evantVar != null) {\n+                    dataType = new NamedDataType(evantVar.getName(), evantVar.getType());\n+                }\n+            }\n+            if (n instanceof BoundaryEventNode) {\n+                BoundaryEventNode boundaryEventNode = (BoundaryEventNode) n;\n+                StateBasedNodeInstance attachedToNodeInstance = (StateBasedNodeInstance) getNodeInstances(true).stream().filter( ni -> ni.getNode().getMetaData().get(\"UniqueId\").equals(boundaryEventNode.getAttachedToNodeId())).findFirst().orElse(null);\n+                if (attachedToNodeInstance != null) {\n+                    Map<String, String> properties = new HashMap<>();\n+                    properties.put(\"AttachedToID\", attachedToNodeInstance.getNodeDefinitionId());\n+                    properties.put(\"AttachedToName\", attachedToNodeInstance.getNodeName());\n+                    String eventType = \"signal\";\n+                    String eventName = boundaryEventNode.getType();\n+                    Map<String, String> timerProperties = attachedToNodeInstance.extractTimerEventInformation();\n+                    if (timerProperties != null) {\n+                        properties.putAll(timerProperties);\n+                        eventType = \"timer\";\n+                        eventName = \"timerTriggered\";\n+                    } \n+                \n+                    eventDesciptions.add(new BaseEventDescription(eventName, (String)n.getMetaData().get(\"UniqueId\"), n.getName(), eventType, null, getId(), dataType, properties));\n+                    \n+                }\n+                \n+            } else if (n instanceof EventSubProcessNode) {\n+                EventSubProcessNode eventSubProcessNode = (EventSubProcessNode) n;\n+                Node startNode = eventSubProcessNode.findStartNode();\n+                Map<Timer, DroolsAction> timers = eventSubProcessNode.getTimers();\n+                if (timers != null && !timers.isEmpty()) {\n+                    getNodeInstances(eventSubProcessNode.getId()).forEach(ni -> {\n+                        \n+                        Map<String, String> timerProperties = ((StateBasedNodeInstance) ni).extractTimerEventInformation();\n+                        if (timerProperties != null) {\n+                         \n+                            eventDesciptions.add(new BaseEventDescription(\"timerTriggered\", (String)startNode.getMetaData().get(\"UniqueId\"), startNode.getName(), \"timer\", ni.getId(), getId(), null, timerProperties));\n+                          \n+                        }\n+                    });\n+                } else {\n+                \n+                    for (String eventName : eventSubProcessNode.getEvents()) {\n+                        \n+                        eventDesciptions.add(new BaseEventDescription(eventName, (String)startNode.getMetaData().get(\"UniqueId\"), startNode.getName(), \"signal\", null, getId(), dataType));\n+                    }\n+                \n+                }\n+            } else if (n instanceof EventNode) {\n+                NamedDataType finalDataType = dataType;\n+                getNodeInstances(n.getId()).forEach(ni -> {\n+                    eventDesciptions.add(new BaseEventDescription(((EventNode) n).getType(), (String) n.getMetaData().get(\"UniqueId\"), n.getName(), (String) n.getMetaData().getOrDefault(\"EventType\", \"signal\"), ni.getId(),\n+                                                              getId(), finalDataType));\n+                });\n+            } else if (n instanceof StateNode) {\n+                \n+                getNodeInstances(n.getId()).forEach(ni -> {\n+                    eventDesciptions.add(new BaseEventDescription((String) n.getMetaData().get(\"Condition\"), (String) n.getMetaData().get(\"UniqueId\"), n.getName(), (String) n.getMetaData().getOrDefault(\"EventType\",\n+                                                                                                                                                                                                      \"signal\"), ni.getId(),\n+                                                              getId(), null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5OTQzOA=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzE3MzA3OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0NzoxMlrOGIioFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNzo0OTozMlrOGI3sdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwOTExMA==", "bodyText": "Maybe a stupid question but why do we iterate here over BoundaryEventNode and not over instance of it? Is the attachedTo property accessible only via nodes and not node instances?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411609110", "createdAt": "2020-04-20T18:47:12Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "diffHunk": "@@ -765,6 +774,97 @@ private void removeEventListeners() {\n     public String[] getEventTypes() {\n         return externalEventListeners.keySet().stream().map(this::resolveVariable).collect(Collectors.toList()).toArray(new String[externalEventListeners.size()]);\n     }\n+    \n+    @Override\n+    public Set<EventDescription<?>> getEventDescriptions() {\n+        if (getState() == ProcessInstance.STATE_COMPLETED || getState() == ProcessInstance.STATE_ABORTED) {\n+            return Collections.emptySet();\n+        }\n+        VariableScope variableScope = (VariableScope) ((ContextContainer) getProcess()).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+        Set<EventDescription<?>> eventDesciptions = new LinkedHashSet<>();\n+        \n+        List<EventListener> activeListeners = eventListeners.values().stream()\n+                .flatMap(List::stream)\n+                .collect(Collectors.toList());\n+        \n+        activeListeners.addAll(externalEventListeners.values().stream()\n+                    .flatMap(List::stream)\n+                    .collect(Collectors.toList()));\n+        \n+        activeListeners.forEach(el -> eventDesciptions.addAll(el.getEventDescriptions()));\n+        \n+ \n+        ((org.jbpm.workflow.core.WorkflowProcess)getProcess()).getNodesRecursively().stream().filter(n -> n instanceof EventNodeInterface).forEach(n -> {\n+            \n+            NamedDataType dataType = null;\n+            if (((EventNodeInterface)n).getVariableName() != null) {\n+                Variable evantVar = variableScope.findVariable(((EventNodeInterface)n).getVariableName());\n+                if (evantVar != null) {\n+                    dataType = new NamedDataType(evantVar.getName(), evantVar.getType());\n+                }\n+            }\n+            if (n instanceof BoundaryEventNode) {\n+                BoundaryEventNode boundaryEventNode = (BoundaryEventNode) n;\n+                StateBasedNodeInstance attachedToNodeInstance = (StateBasedNodeInstance) getNodeInstances(true).stream().filter( ni -> ni.getNode().getMetaData().get(\"UniqueId\").equals(boundaryEventNode.getAttachedToNodeId())).findFirst().orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NTk3Ng==", "bodyText": "boundary event node instances are created on demand and thus do not exist as node instances so it needs to find if there is a node instance of that this boundary is attached to as active node instance", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411655976", "createdAt": "2020-04-20T20:05:32Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "diffHunk": "@@ -765,6 +774,97 @@ private void removeEventListeners() {\n     public String[] getEventTypes() {\n         return externalEventListeners.keySet().stream().map(this::resolveVariable).collect(Collectors.toList()).toArray(new String[externalEventListeners.size()]);\n     }\n+    \n+    @Override\n+    public Set<EventDescription<?>> getEventDescriptions() {\n+        if (getState() == ProcessInstance.STATE_COMPLETED || getState() == ProcessInstance.STATE_ABORTED) {\n+            return Collections.emptySet();\n+        }\n+        VariableScope variableScope = (VariableScope) ((ContextContainer) getProcess()).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+        Set<EventDescription<?>> eventDesciptions = new LinkedHashSet<>();\n+        \n+        List<EventListener> activeListeners = eventListeners.values().stream()\n+                .flatMap(List::stream)\n+                .collect(Collectors.toList());\n+        \n+        activeListeners.addAll(externalEventListeners.values().stream()\n+                    .flatMap(List::stream)\n+                    .collect(Collectors.toList()));\n+        \n+        activeListeners.forEach(el -> eventDesciptions.addAll(el.getEventDescriptions()));\n+        \n+ \n+        ((org.jbpm.workflow.core.WorkflowProcess)getProcess()).getNodesRecursively().stream().filter(n -> n instanceof EventNodeInterface).forEach(n -> {\n+            \n+            NamedDataType dataType = null;\n+            if (((EventNodeInterface)n).getVariableName() != null) {\n+                Variable evantVar = variableScope.findVariable(((EventNodeInterface)n).getVariableName());\n+                if (evantVar != null) {\n+                    dataType = new NamedDataType(evantVar.getName(), evantVar.getType());\n+                }\n+            }\n+            if (n instanceof BoundaryEventNode) {\n+                BoundaryEventNode boundaryEventNode = (BoundaryEventNode) n;\n+                StateBasedNodeInstance attachedToNodeInstance = (StateBasedNodeInstance) getNodeInstances(true).stream().filter( ni -> ni.getNode().getMetaData().get(\"UniqueId\").equals(boundaryEventNode.getAttachedToNodeId())).findFirst().orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwOTExMA=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk1NDI5NQ==", "bodyText": "Thanks,", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411954295", "createdAt": "2020-04-21T07:49:32Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "diffHunk": "@@ -765,6 +774,97 @@ private void removeEventListeners() {\n     public String[] getEventTypes() {\n         return externalEventListeners.keySet().stream().map(this::resolveVariable).collect(Collectors.toList()).toArray(new String[externalEventListeners.size()]);\n     }\n+    \n+    @Override\n+    public Set<EventDescription<?>> getEventDescriptions() {\n+        if (getState() == ProcessInstance.STATE_COMPLETED || getState() == ProcessInstance.STATE_ABORTED) {\n+            return Collections.emptySet();\n+        }\n+        VariableScope variableScope = (VariableScope) ((ContextContainer) getProcess()).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+        Set<EventDescription<?>> eventDesciptions = new LinkedHashSet<>();\n+        \n+        List<EventListener> activeListeners = eventListeners.values().stream()\n+                .flatMap(List::stream)\n+                .collect(Collectors.toList());\n+        \n+        activeListeners.addAll(externalEventListeners.values().stream()\n+                    .flatMap(List::stream)\n+                    .collect(Collectors.toList()));\n+        \n+        activeListeners.forEach(el -> eventDesciptions.addAll(el.getEventDescriptions()));\n+        \n+ \n+        ((org.jbpm.workflow.core.WorkflowProcess)getProcess()).getNodesRecursively().stream().filter(n -> n instanceof EventNodeInterface).forEach(n -> {\n+            \n+            NamedDataType dataType = null;\n+            if (((EventNodeInterface)n).getVariableName() != null) {\n+                Variable evantVar = variableScope.findVariable(((EventNodeInterface)n).getVariableName());\n+                if (evantVar != null) {\n+                    dataType = new NamedDataType(evantVar.getName(), evantVar.getType());\n+                }\n+            }\n+            if (n instanceof BoundaryEventNode) {\n+                BoundaryEventNode boundaryEventNode = (BoundaryEventNode) n;\n+                StateBasedNodeInstance attachedToNodeInstance = (StateBasedNodeInstance) getNodeInstances(true).stream().filter( ni -> ni.getNode().getMetaData().get(\"UniqueId\").equals(boundaryEventNode.getAttachedToNodeId())).findFirst().orElse(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwOTExMA=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzE3NDM5OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0NzozOVrOGIipAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDowMzo1N1rOGIlbSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwOTM0Nw==", "bodyText": "What about just get keySet here and filter in lambda? Would be more readable I think.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411609347", "createdAt": "2020-04-20T18:47:39Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java", "diffHunk": "@@ -483,4 +483,28 @@ protected void mapDynamicOutputData(Map<String, Object> results) {\n             }\n         }\n     }\n+    \n+    public Map<String, String> extractTimerEventInformation() {\n+        if (getTimerInstances() != null) {\n+            for (String id : getTimerInstances()) {\n+                String[] ids = id.split(\"_\");\n+                \n+                for (Map.Entry<Timer, DroolsAction> entry : getEventBasedNode().getTimers().entrySet()) {\n+                    if (entry.getKey().getId() == Long.valueOf(ids[1])) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NDk4Nw==", "bodyText": "used keySet instead", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411654987", "createdAt": "2020-04-20T20:03:57Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/StateBasedNodeInstance.java", "diffHunk": "@@ -483,4 +483,28 @@ protected void mapDynamicOutputData(Map<String, Object> results) {\n             }\n         }\n     }\n+    \n+    public Map<String, String> extractTimerEventInformation() {\n+        if (getTimerInstances() != null) {\n+            for (String id : getTimerInstances()) {\n+                String[] ids = id.split(\"_\");\n+                \n+                for (Map.Entry<Timer, DroolsAction> entry : getEventBasedNode().getTimers().entrySet()) {\n+                    if (entry.getKey().getId() == Long.valueOf(ids[1])) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwOTM0Nw=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzIxMjIxOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo1NjozNlrOGIi_dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDowNDowNlrOGIlbqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxNTA5NQ==", "bodyText": "Can we rather log these or delete them?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411615095", "createdAt": "2020-04-20T18:56:36Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "diffHunk": "@@ -1172,6 +1357,9 @@ public void testIntermediateCatchEventSignal() throws Exception {\n         ProcessInstance processInstance = ksession\n                 .startProcess(\"IntermediateCatchEvent\");\n         assertProcessInstanceActive(processInstance);\n+        \n+        System.out.println(\"Boundary  \" + ((WorkflowProcessInstanceImpl) processInstance).getEventDescriptions());\n+        ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NTA4Mg==", "bodyText": "removed", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411655082", "createdAt": "2020-04-20T20:04:06Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "diffHunk": "@@ -1172,6 +1357,9 @@ public void testIntermediateCatchEventSignal() throws Exception {\n         ProcessInstance processInstance = ksession\n                 .startProcess(\"IntermediateCatchEvent\");\n         assertProcessInstanceActive(processInstance);\n+        \n+        System.out.println(\"Boundary  \" + ((WorkflowProcessInstanceImpl) processInstance).getEventDescriptions());\n+        ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxNTA5NQ=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 309}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzIxMzAwOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo1Njo0M1rOGIi_-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDowNDoxNVrOGIlcBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxNTIyNg==", "bodyText": "Same here.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411615226", "createdAt": "2020-04-20T18:56:43Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "diffHunk": "@@ -1189,6 +1377,8 @@ public void testIntermediateCatchEventMessage() throws Exception {\n         ProcessInstance processInstance = ksession\n                 .startProcess(\"IntermediateCatchEvent\");\n         assertProcessInstanceActive(processInstance);\n+        \n+        System.out.println(Arrays.toString(processInstance.getEventTypes()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NTE3Mw==", "bodyText": "removed", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411655173", "createdAt": "2020-04-20T20:04:15Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "diffHunk": "@@ -1189,6 +1377,8 @@ public void testIntermediateCatchEventMessage() throws Exception {\n         ProcessInstance processInstance = ksession\n                 .startProcess(\"IntermediateCatchEvent\");\n         assertProcessInstanceActive(processInstance);\n+        \n+        System.out.println(Arrays.toString(processInstance.getEventTypes()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxNTIyNg=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 318}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzIxMzc2OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo1Njo1MFrOGIjAVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDowNDoxOFrOGIlcLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxNTMxNw==", "bodyText": "Same here.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411615317", "createdAt": "2020-04-20T18:56:50Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "diffHunk": "@@ -1226,6 +1416,8 @@ public void testIntermediateCatchEventTimerDuration() throws Exception {\n         ProcessInstance processInstance = ksession\n                 .startProcess(\"IntermediateCatchEvent\");\n         assertProcessInstanceActive(processInstance);\n+        \n+        System.out.println(\"Events  \" + ((WorkflowProcessInstanceImpl) processInstance).getEventDescriptions());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NTIxNQ==", "bodyText": "removed", "url": "https://github.com/kiegroup/kogito-runtimes/pull/451#discussion_r411655215", "createdAt": "2020-04-20T20:04:18Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/IntermediateEventTest.java", "diffHunk": "@@ -1226,6 +1416,8 @@ public void testIntermediateCatchEventTimerDuration() throws Exception {\n         ProcessInstance processInstance = ksession\n                 .startProcess(\"IntermediateCatchEvent\");\n         assertProcessInstanceActive(processInstance);\n+        \n+        System.out.println(\"Events  \" + ((WorkflowProcessInstanceImpl) processInstance).getEventDescriptions());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxNTMxNw=="}, "originalCommit": {"oid": "48bd3ddf9b375c88e9d42b86ab96fdf35c131017"}, "originalPosition": 327}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 236, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}