{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMTQ0MTk2", "number": 825, "title": "KOGITO-3073 Kafka persistence addon", "bodyText": "Assembly:\n\n#825\nkiegroup/kogito-examples#393\nkiegroup/kie-docs#3178", "createdAt": "2020-10-14T06:32:00Z", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825", "merged": true, "mergeCommit": {"oid": "8b29d15280535b78eafebbd5f760da085177a666"}, "closed": true, "closedAt": "2021-02-15T04:39:23Z", "author": {"login": "cristianonicolai"}, "timelineItems": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSXYutABqjM4NzQ5NTg0NTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd6OJnagBqjQzMjk0OTg1NTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "80d41b856dc3da9d8b7cd0f61cacab20d4111c0f", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/80d41b856dc3da9d8b7cd0f61cacab20d4111c0f", "committedDate": "2020-10-14T05:20:16Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "9a2fc4aedbe8ca5a65d1c1f76e10c675ac9aa167", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9a2fc4aedbe8ca5a65d1c1f76e10c675ac9aa167", "committedDate": "2020-10-14T06:42:31Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a2fc4aedbe8ca5a65d1c1f76e10c675ac9aa167", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9a2fc4aedbe8ca5a65d1c1f76e10c675ac9aa167", "committedDate": "2020-10-14T06:42:31Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "6d9939fc38d86843a5f4b78d3ad3926766b36c99", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/6d9939fc38d86843a5f4b78d3ad3926766b36c99", "committedDate": "2020-11-26T14:43:39Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d9939fc38d86843a5f4b78d3ad3926766b36c99", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/6d9939fc38d86843a5f4b78d3ad3926766b36c99", "committedDate": "2020-11-26T14:43:39Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "8affe25c07610759435303d251cfb993f73c0483", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/8affe25c07610759435303d251cfb993f73c0483", "committedDate": "2021-01-21T02:48:25Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8affe25c07610759435303d251cfb993f73c0483", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/8affe25c07610759435303d251cfb993f73c0483", "committedDate": "2021-01-21T02:48:25Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "9e90fbc5bac886986406040e8b072a83c808e486", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9e90fbc5bac886986406040e8b072a83c808e486", "committedDate": "2021-01-21T05:33:13Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNzA2MjUx", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#pullrequestreview-573706251", "createdAt": "2021-01-21T20:23:51Z", "commit": {"oid": "9e90fbc5bac886986406040e8b072a83c808e486"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQyMDoyMzo1MVrOIYIW6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQyMDo0Mjo1NlrOIYJAKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3MzY3Mg==", "bodyText": "This method returns all the protos (+ list JSON) used by the operator to export them to data index so I think we should move this code outside single persistence types and bind it to the add-on that produce data index events.\nWdyt?\nSide note this change is in conflict with #967\n/cc @r00ta", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562173672", "createdAt": "2021-01-21T20:23:51Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -147,6 +144,46 @@ public String persistenceType() {\n             persistenceProviderClazz.addMember(templateNameField);\n             persistenceProviderClazz.addMember(templateNameMethod);\n         }\n+        \n+        return protobufBasedPersistence(persistenceProviderClazz);\n+    }\n+\n+    protected Collection<GeneratedFile> kafkaBasedPersistence() {\n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(KOGITO_PROCESS_INSTANCE_FACTORY_IMPL)\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(KOGITO_PROCESS_INSTANCE_FACTORY_PACKAGE);\n+\n+        if (context().hasDI()) {\n+            context().getDependencyInjectionAnnotator().withApplicationComponent(persistenceProviderClazz);\n+        }\n+\n+        Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n+\n+        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerTemplate.java\"));\n+\n+        ClassOrInterfaceDeclaration producer = parsedClazzFile.getClassByName(\"KafkaStreamsTopologyProducer\").get();\n+        \n+        MethodCallExpr asListOfProcesses = new MethodCallExpr(new NameExpr(\"java.util.Arrays\"), \"asList\");\n+\n+        protoGenerator.getProcessIds().forEach(p -> asListOfProcesses.addArgument(new StringLiteralExpr(p)));\n+        producer.getFieldByName(\"processes\").get().getVariable(0).setInitializer(asListOfProcesses);\n+\n+        String clazzName = KOGITO_PROCESS_INSTANCE_PACKAGE + \".\" + producer.getName().asString();\n+        generatedFiles.add(new GeneratedFile(GeneratedFileType.SOURCE,\n+                                             clazzName.replace('.', '/') + \".java\",\n+                                             parsedClazzFile.toString()));\n+        return generatedFiles;\n+    }\n+    \n+    private Collection<GeneratedFile> protobufBasedPersistence(ClassOrInterfaceDeclaration persistenceProviderClazz){\n+        CompilationUnit compilationUnit = new CompilationUnit(KOGITO_PROCESS_INSTANCE_PACKAGE);\n+        compilationUnit.getTypes().add(persistenceProviderClazz);\n+\n+        Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e90fbc5bac886986406040e8b072a83c808e486"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4MzMzNg==", "bodyText": "I think you can use existing generatedAnnotation field", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562183336", "createdAt": "2021-01-21T20:41:10Z", "author": {"login": "danielezonca"}, "path": "kogito-quarkus-extension/deployment/src/main/java/org/kie/kogito/quarkus/deployment/JandexProtoGenerator.java", "diffHunk": "@@ -102,6 +106,18 @@ public Proto generate(String messageComment, String fieldComment, String package\n         return parameters;\n     }\n \n+    @Override\n+    public Set<String> getProcessIds() {\n+        return modelClasses.stream().map(c -> {\n+            AnnotationInstance instance = c.classAnnotation(DotName.createSimple(Generated.class.getCanonicalName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e90fbc5bac886986406040e8b072a83c808e486"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NDIzNQ==", "bodyText": "Can you please describe in the ticket what a kafka topology is and the relation with ktable?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r562184235", "createdAt": "2021-01-21T20:42:56Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/resources/class-templates/persistence/KafkaStreamsTopologyProducerTemplate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import org.apache.kafka.streams.Topology;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+\n+@ApplicationScoped\n+public class KafkaStreamsTopologyProducer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsTopologyProducer.class);\n+\n+    private List<String> processes = Arrays.asList();\n+\n+    @Produces\n+    public Topology buildTopology() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e90fbc5bac886986406040e8b072a83c808e486"}, "originalPosition": 39}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e90fbc5bac886986406040e8b072a83c808e486", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9e90fbc5bac886986406040e8b072a83c808e486", "committedDate": "2021-01-21T05:33:13Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "970d8591278df327a508211eea0fcdd42b826144", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/970d8591278df327a508211eea0fcdd42b826144", "committedDate": "2021-01-22T02:16:12Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "970d8591278df327a508211eea0fcdd42b826144", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/970d8591278df327a508211eea0fcdd42b826144", "committedDate": "2021-01-22T02:16:12Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "committedDate": "2021-01-22T08:40:27Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c4479ba8815eaa3ae202c0e66f7bdc53bfbb8f24", "committedDate": "2021-01-22T08:40:27Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "cfa5bdc0f3e20e0ce2334b5a9100652ffabda740", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/cfa5bdc0f3e20e0ce2334b5a9100652ffabda740", "committedDate": "2021-01-22T10:47:49Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cfa5bdc0f3e20e0ce2334b5a9100652ffabda740", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/cfa5bdc0f3e20e0ce2334b5a9100652ffabda740", "committedDate": "2021-01-22T10:47:49Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/68c1854e5ed94fa96ad8296153f08f8f08da011e", "committedDate": "2021-01-22T11:58:59Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "68c1854e5ed94fa96ad8296153f08f8f08da011e", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/68c1854e5ed94fa96ad8296153f08f8f08da011e", "committedDate": "2021-01-22T11:58:59Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "7cb3890af384c1abbb28fafa5622c7c794af5765", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7cb3890af384c1abbb28fafa5622c7c794af5765", "committedDate": "2021-02-01T06:07:44Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7cb3890af384c1abbb28fafa5622c7c794af5765", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7cb3890af384c1abbb28fafa5622c7c794af5765", "committedDate": "2021-02-01T06:07:44Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "1f3cb4a037745998c7d3e05c24500971e812526a", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1f3cb4a037745998c7d3e05c24500971e812526a", "committedDate": "2021-02-02T02:05:02Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f3cb4a037745998c7d3e05c24500971e812526a", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1f3cb4a037745998c7d3e05c24500971e812526a", "committedDate": "2021-02-02T02:05:02Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "committedDate": "2021-02-02T04:30:44Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/0db2eff4fa7e3d22e0b148825bf995ffeeef8dd2", "committedDate": "2021-02-02T04:30:44Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "72c4b39fec40aa5d1882ee3c89c59a613e434474", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/72c4b39fec40aa5d1882ee3c89c59a613e434474", "committedDate": "2021-02-02T11:34:12Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72c4b39fec40aa5d1882ee3c89c59a613e434474", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/72c4b39fec40aa5d1882ee3c89c59a613e434474", "committedDate": "2021-02-02T11:34:12Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "committedDate": "2021-02-02T11:39:04Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5Mjg1MTM4", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#pullrequestreview-579285138", "createdAt": "2021-01-29T14:05:59Z", "commit": {"oid": "68c1854e5ed94fa96ad8296153f08f8f08da011e"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxNDowNTo1OVrOIclagQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxMzoxNDo1MlrOIeQDXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDAzMw==", "bodyText": "If new KafkaProcessInstancesFactory() fails this could be null", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r566844033", "createdAt": "2021-01-29T14:05:59Z", "author": {"login": "danielezonca"}, "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.jbpm.process.instance.impl.Action;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Node;\n+import org.kie.api.definition.process.WorkflowProcess;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        factory.stop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68c1854e5ed94fa96ad8296153f08f8f08da011e"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg0NDg2MQ==", "bodyText": "Can you please clarify why this workaround? What about (in another PR of course) convert scripts to lambdas?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r566844861", "createdAt": "2021-01-29T14:07:18Z", "author": {"login": "danielezonca"}, "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.jbpm.process.instance.impl.Action;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Node;\n+import org.kie.api.definition.process.WorkflowProcess;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        factory.stop();\n+        if (factory.getKafkaStreams() != null) {\n+            factory.getKafkaStreams().close();\n+        }\n+    }\n+\n+    @Test\n+    void testFindByIdReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n+        // workaround as BpmnProcess does not compile the scripts but just reads the xml\n+        for (Node node : ((WorkflowProcess) process.process()).getNodes()) {\n+            if (node instanceof ActionNode) {\n+                DroolsAction a = ((ActionNode) node).getAction();\n+                a.setMetaData(\"Action\", (Action) kcontext -> {\n+                    System.out.println(\"The variable value is \" + kcontext.getVariable(\"s\") + \" about to call toString on it\");\n+                    kcontext.getVariable(\"s\").toString();\n+                });\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68c1854e5ed94fa96ad8296153f08f8f08da011e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4Njg2NQ==", "bodyText": "Please use TemplatedGenerator\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));\n          \n          \n            \n                    TemplatedGenerator generator = TemplatedGenerator.builder()\n          \n          \n            \n                                .withTemplateBasePath(\"/class-templates/persistence/\")\n          \n          \n            \n                                .withFallbackContext(JavaKogitoBuildContext.CONTEXT_NAME)\n          \n          \n            \n                                .build(context(), \"KafkaStreamsTopologyProducer\");\n          \n          \n            \n                    CompilationUnit parsedClazzFile = generator.compilationUnitOrThrow();", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568586865", "createdAt": "2021-02-02T13:07:44Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -147,6 +155,44 @@ public String persistenceType() {\n             persistenceProviderClazz.addMember(templateNameField);\n             persistenceProviderClazz.addMember(templateNameMethod);\n         }\n+        \n+        return protobufBasedPersistence(persistenceProviderClazz);\n+    }\n+\n+    protected Collection<GeneratedFile> kafkaBasedPersistence() {\n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(KOGITO_PROCESS_INSTANCE_FACTORY_IMPL)\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(KOGITO_PROCESS_INSTANCE_FACTORY_PACKAGE);\n+\n+        if (context().hasDI()) {\n+            context().getDependencyInjectionAnnotator().withApplicationComponent(persistenceProviderClazz);\n+        }\n+\n+        Collection<GeneratedFile> generatedFiles = protobufBasedPersistence(persistenceProviderClazz);\n+\n+        CompilationUnit parsedClazzFile = parse(this.getClass().getResourceAsStream(\"/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ==", "bodyText": "This class is a *JavaTemplate but it seems to be a Quarkus one (it uses CDI). I think we need also a *SpringTemplate", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568589969", "createdAt": "2021-02-02T13:12:48Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/resources/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import org.apache.kafka.streams.Topology;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+\n+@ApplicationScoped\n+public class KafkaStreamsTopologyProducer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU5MTE5Ng==", "bodyText": "What about add checks on proto in this test too (like this)?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(generatedFiles).hasSize(3);\n          \n          \n            \n                    assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE)).count()).isEqualTo(2);\n          \n          \n            \n                    assertThat(generatedFiles.stream().filter(gf -> gf.type().equals(ProtoGenerator.PROTO_TYPE) && gf.relativePath().endsWith(\".json\")).count()).isEqualTo(1);\n          \n          \n            \n            \n          \n          \n            \n                    assertThat(generatedFiles).hasSize(3);", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568591196", "createdAt": "2021-02-02T13:14:52Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/persistence/FileSystemPersistenceGeneratorTest.java", "diffHunk": "@@ -57,7 +57,7 @@ void test() {\n                 protoGenerator);\n         Collection<GeneratedFile> generatedFiles = persistenceGenerator.generate();\n \n-        assertThat(generatedFiles).hasSize(1);\n+        assertThat(generatedFiles).hasSize(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxNzA1MzA3", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#pullrequestreview-581705307", "createdAt": "2021-02-02T19:38:02Z", "commit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxOTozODowMlrOIehkXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQyMDowNzowNFrOIeinWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg3ODE3Mw==", "bodyText": "remove commented code?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568878173", "createdAt": "2021-02-02T19:38:02Z", "author": {"login": "tiagodolphine"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    //Store can only be accessed after the Kafka Streams has started \n+    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n+//        ReadOnlyKeyValueStore<String, byte[]> store = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDU0MQ==", "bodyText": "what about using a listerner for the state? for example streams.setStateListener(....) in this way we can get rid of the Thread.sleep", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568880541", "createdAt": "2021-02-02T19:42:00Z", "author": {"login": "tiagodolphine"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    //Store can only be accessed after the Kafka Streams has started \n+    protected Supplier<ReadOnlyKeyValueStore<String, byte[]>> supplyStore(Process<?> process) {\n+//        ReadOnlyKeyValueStore<String, byte[]> store = null;\n+        return () -> {\n+//            if (store != null) {\n+//                return store;\n+//            }\n+            while (streams.state() == KafkaStreams.State.CREATED || streams.state() == KafkaStreams.State.REBALANCING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4MDk1NQ==", "bodyText": "log instead of printStackTrace would be bettter", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568880955", "createdAt": "2021-02-02T19:42:43Z", "author": {"login": "tiagodolphine"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(p -> p.close());\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = new KafkaProducer<>(kafkaConfig, new StringSerializer(), new ByteArraySerializer());\n+            producers.add(producer);\n+            return new KafkaProcessInstances(process, topicName(process.id()), supplyStore(process), producer, proto(), marshallers().toArray(new BaseMarshaller<?>[0]));\n+        } catch (Exception ex) {\n+            ex.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4OTgzNA==", "bodyText": "maybe using store.approximateNumEntries() would be better in this way it is not necessary to fetch all entries to sum, wdyt?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568889834", "createdAt": "2021-02-02T19:57:43Z", "author": {"login": "tiagodolphine"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public KafkaProcessInstances(Process<?> process, String topic, Supplier<ReadOnlyKeyValueStore<String, byte[]>> storeSupplier, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topic;\n+        this.producer = producer;\n+        this.marshaller = new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers));\n+        this.store = storeSupplier.get();\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return store.get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (store.get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = store.get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {\n+            while (iterator.hasNext()) {\n+                instances.add(mode == MUTABLE ?\n+                                      marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n+                                      marshaller.unmarshallReadOnlyProcessInstance(iterator.next().value, process)\n+                );\n+            }\n+            return instances;\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public Integer size() {\n+        int size = 0;\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5MjQzNg==", "bodyText": "I already said that but every time I see all() it hurts me :P  at some point we need to revisit this values() method in runtimes, anyway just saying.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568892436", "createdAt": "2021-02-02T20:02:00Z", "author": {"login": "tiagodolphine"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public KafkaProcessInstances(Process<?> process, String topic, Supplier<ReadOnlyKeyValueStore<String, byte[]>> storeSupplier, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topic;\n+        this.producer = producer;\n+        this.marshaller = new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers));\n+        this.store = storeSupplier.get();\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return store.get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (store.get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = store.get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = store.all()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg5NTMyMA==", "bodyText": "and do we really need a template? or this could be a static class? I mean what is injected during codegen?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r568895320", "createdAt": "2021-02-02T20:07:04Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/resources/class-templates/persistence/KafkaStreamsTopologyProducerJavaTemplate.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import org.apache.kafka.streams.Topology;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+\n+@ApplicationScoped\n+public class KafkaStreamsTopologyProducer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU4OTk2OQ=="}, "originalCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49"}, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1134facfa7f7dd76ea8fd2e2e58fe8e28e425b49", "committedDate": "2021-02-02T11:39:04Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "633430c163438bed2b8989df88c4fcbc93e82871", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/633430c163438bed2b8989df88c4fcbc93e82871", "committedDate": "2021-02-03T03:58:22Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "633430c163438bed2b8989df88c4fcbc93e82871", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/633430c163438bed2b8989df88c4fcbc93e82871", "committedDate": "2021-02-03T03:58:22Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "committedDate": "2021-02-04T01:01:28Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/6f22b0b4c948ecb83ec85f1f6ba8daa1b84b52cf", "committedDate": "2021-02-04T01:01:28Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "ede1cb4064c89d1b2f4fc8577b0602d3e81348af", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/ede1cb4064c89d1b2f4fc8577b0602d3e81348af", "committedDate": "2021-02-04T08:33:25Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ede1cb4064c89d1b2f4fc8577b0602d3e81348af", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/ede1cb4064c89d1b2f4fc8577b0602d3e81348af", "committedDate": "2021-02-04T08:33:25Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "9cecb263d0ebb610ae1d54509cb9561437d3e33e", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9cecb263d0ebb610ae1d54509cb9561437d3e33e", "committedDate": "2021-02-04T09:18:08Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9cecb263d0ebb610ae1d54509cb9561437d3e33e", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9cecb263d0ebb610ae1d54509cb9561437d3e33e", "committedDate": "2021-02-04T09:18:08Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "27327e054b73b72e065a160fe42059ba4776df71", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/27327e054b73b72e065a160fe42059ba4776df71", "committedDate": "2021-02-05T06:09:56Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "27327e054b73b72e065a160fe42059ba4776df71", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/27327e054b73b72e065a160fe42059ba4776df71", "committedDate": "2021-02-05T06:09:56Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "committedDate": "2021-02-05T07:35:25Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/eba1a010fed2d94fef88bef28ce3c3d498eb2d02", "committedDate": "2021-02-05T07:35:25Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "494bee99defc436f1c88fb00356bb81095ac1865", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/494bee99defc436f1c88fb00356bb81095ac1865", "committedDate": "2021-02-08T03:47:19Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "494bee99defc436f1c88fb00356bb81095ac1865", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/494bee99defc436f1c88fb00356bb81095ac1865", "committedDate": "2021-02-08T03:47:19Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "29159a9f025be375f7d1dde948732c6b8951f6ff", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/29159a9f025be375f7d1dde948732c6b8951f6ff", "committedDate": "2021-02-08T07:40:32Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "29159a9f025be375f7d1dde948732c6b8951f6ff", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/29159a9f025be375f7d1dde948732c6b8951f6ff", "committedDate": "2021-02-08T07:40:32Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "8291208a7fdbc2b9e2c5c89702060eccd1181a82", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/8291208a7fdbc2b9e2c5c89702060eccd1181a82", "committedDate": "2021-02-08T11:55:10Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8291208a7fdbc2b9e2c5c89702060eccd1181a82", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/8291208a7fdbc2b9e2c5c89702060eccd1181a82", "committedDate": "2021-02-08T11:55:10Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "95ffd75ab52b23dcfd4fc83df24f356547c3b9cf", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/95ffd75ab52b23dcfd4fc83df24f356547c3b9cf", "committedDate": "2021-02-08T11:56:08Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95ffd75ab52b23dcfd4fc83df24f356547c3b9cf", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/95ffd75ab52b23dcfd4fc83df24f356547c3b9cf", "committedDate": "2021-02-08T11:56:08Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "c1b58ae3e223447875d6dde4127472a981e15fb0", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c1b58ae3e223447875d6dde4127472a981e15fb0", "committedDate": "2021-02-08T15:17:25Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c1b58ae3e223447875d6dde4127472a981e15fb0", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c1b58ae3e223447875d6dde4127472a981e15fb0", "committedDate": "2021-02-08T15:17:25Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "04f611739e7cf099fd05e3b4aa3ecfd485e93318", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/04f611739e7cf099fd05e3b4aa3ecfd485e93318", "committedDate": "2021-02-08T15:24:58Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "04f611739e7cf099fd05e3b4aa3ecfd485e93318", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/04f611739e7cf099fd05e3b4aa3ecfd485e93318", "committedDate": "2021-02-08T15:24:58Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "0190a1a1283fb5ca6da0625d00ce0ed868dc1bf9", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/0190a1a1283fb5ca6da0625d00ce0ed868dc1bf9", "committedDate": "2021-02-09T05:37:29Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0190a1a1283fb5ca6da0625d00ce0ed868dc1bf9", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/0190a1a1283fb5ca6da0625d00ce0ed868dc1bf9", "committedDate": "2021-02-09T05:37:29Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "committedDate": "2021-02-09T06:40:45Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2NDExMzQ5", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#pullrequestreview-586411349", "createdAt": "2021-02-09T10:46:56Z", "commit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxMDo0Njo1NlrOIiPuDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxMzoyMTowN1rOIiVrcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc4MDA0Ng==", "bodyText": "Can't this be called in parallel during injection and initialization of the process endpoints?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572780046", "createdAt": "2021-02-09T10:46:56Z", "author": {"login": "MarianMacik"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.kafka.KafkaProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KogitoProcessInstancesFactory.class);\n+\n+    Map<String, Object> kafkaConfig;\n+    KafkaStreams streams;\n+    List<KafkaProducer<String, byte[]>> producers = new ArrayList<>();\n+\n+    @Inject\n+    @Named(\"default-kafka-broker\")\n+    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n+        this.kafkaConfig = kafkaConfig;\n+    }\n+\n+    public KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+    }\n+\n+    @PreDestroy\n+    public void stop() {\n+        producers.forEach(KafkaProducer::close);\n+    }\n+\n+    public KafkaProcessInstances createProcessInstances(Process<?> process) {\n+        try {\n+            LOGGER.info(\"Creating KafkaProcessInstances for process: {}\", process.id());\n+            KafkaProducer<String, byte[]> producer = getProducer();\n+            producers.add(producer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc5NDI4Ng==", "bodyText": "This means that KafkaStreams can already be injected, but not started? So we have to wait in all store manipulation methods until it is running?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572794286", "createdAt": "2021-02-09T11:06:25Z", "author": {"login": "MarianMacik"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private KafkaStreams streams;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        this.streams = streams;\n+        this.streams.setStateListener((newState, oldState) -> {\n+            if (store == null && newState == KafkaStreams.State.RUNNING) {\n+                setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(process.id()), QueryableStoreTypes.keyValueStore())));\n+                latch.countDown();\n+            }\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwOTY1Mw==", "bodyText": "Daniele said that this can happen, but I don't see how would new KafkaProcessInstancesFactory(); fail. Maybe in older code it could happen?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572809653", "createdAt": "2021-02-09T11:30:33Z", "author": {"login": "MarianMacik"}, "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (factory != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxMjkwMA==", "bodyText": "Just curious, I have always thought that Kafka Streams also support producers and consumers, meaning it is the \"superset\" of the traditional Consumer/Producer API. Or this is just in case we receive something from Kafka and then want to push it again to Kafka (\"streams\")? Not sure about the clear distinction between Kafka Streams and Kafka here.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572812900", "createdAt": "2021-02-09T11:35:57Z", "author": {"login": "MarianMacik"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private KafkaStreams streams;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaStreams streams, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        this.streams = streams;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxNTgyMw==", "bodyText": "Do all of these methods have to be package-private?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572815823", "createdAt": "2021-02-09T11:40:46Z", "author": {"login": "MarianMacik"}, "path": "addons/persistence/kafka-persistence-addon/src/test/java/org/kie/kogito/persistence/kafka/KafkaProcessInstancesIT.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.Topology;\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.IdentityProviders;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.ProcessInstances;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.testcontainers.KogitoKafkaContainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.createTopologyForProcesses;\n+import static org.kie.kogito.process.ProcessInstance.STATE_COMPLETED;\n+import static org.kie.kogito.process.ProcessInstance.STATE_ERROR;\n+\n+@Testcontainers\n+public class KafkaProcessInstancesIT {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstancesIT.class);\n+\n+    @Container\n+    KogitoKafkaContainer kafka = new KogitoKafkaContainer();\n+\n+    KafkaProcessInstancesFactory factory;\n+\n+    @BeforeEach\n+    void start() {\n+        factory = new KafkaProcessInstancesFactory();\n+        factory.setKafkaConfig(singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafka.getBootstrapServers()));\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (factory != null) {\n+            factory.stop();\n+            if (factory.getKafkaStreams() != null) {\n+                factory.getKafkaStreams().close();\n+                factory.getKafkaStreams().cleanUp();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testFindByIdReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask-Script.bpmn2\")).get(0);\n+\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+\n+        ProcessInstance<BpmnVariables> mutablePi = process.createInstance(BpmnVariables.create(singletonMap(\"var\", \"value\")));\n+\n+        mutablePi.start();\n+        assertThat(mutablePi.status()).isEqualTo(STATE_ERROR);\n+        assertThat(mutablePi.error()).hasValueSatisfying(error -> {\n+            assertThat(error.errorMessage()).endsWith(\"java.lang.NullPointerException - null\");\n+            assertThat(error.failedNodeId()).isEqualTo(\"ScriptTask_1\");\n+        });\n+        assertThat(mutablePi.variables().toMap()).containsExactly(entry(\"var\", \"value\"));\n+\n+        await().until(() -> instances.values().size() == 1);\n+        \n+        ProcessInstance<BpmnVariables> pi = instances.findById(mutablePi.id(), ProcessInstanceReadMode.READ_ONLY).get();\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> pi.abort());\n+\n+        ProcessInstance<BpmnVariables> readOnlyPi = instances.findById(mutablePi.id(), ProcessInstanceReadMode.READ_ONLY).get();\n+        assertThat(readOnlyPi.status()).isEqualTo(STATE_ERROR);\n+        assertThat(readOnlyPi.error()).hasValueSatisfying(error -> {\n+            assertThat(error.errorMessage()).endsWith(\"java.lang.NullPointerException - null\");\n+            assertThat(error.failedNodeId()).isEqualTo(\"ScriptTask_1\");\n+        });\n+        assertThat(readOnlyPi.variables().toMap()).containsExactly(entry(\"var\", \"value\"));\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> readOnlyPi.abort());\n+\n+        instances.findById(mutablePi.id()).get().abort();\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    @Test\n+    void testValuesReadMode() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask.bpmn2\")).get(0);\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+\n+        ProcessInstance<BpmnVariables> processInstance = process.createInstance(BpmnVariables.create(singletonMap(\"test\", \"test\")));\n+\n+        processInstance.start();\n+\n+        await().until(() -> instances.values().size() == 1);\n+\n+        ProcessInstance<BpmnVariables> pi = instances.values().stream().findFirst().get();\n+        assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> pi.abort());\n+        instances.values(ProcessInstanceReadMode.MUTABLE).stream().findFirst().get().abort();\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    @Test\n+    void testBasicFlow() {\n+        BpmnProcess process = BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask.bpmn2\")).get(0);\n+        factory.setKafkaStreams(createStreams(process));\n+        process.setProcessInstancesFactory(factory);\n+        process.configure();\n+        factory.getKafkaStreams().start();\n+\n+        ProcessInstances<BpmnVariables> instances = process.instances();\n+        assertThat(instances.size()).isZero();\n+        \n+        ProcessInstance<BpmnVariables> processInstance = process.createInstance(BpmnVariables.create(singletonMap(\"test\", \"test\")));\n+\n+        processInstance.start();\n+        assertEquals(STATE_ACTIVE, processInstance.status());\n+\n+        await().until(() -> instances.values().size() == 1);\n+\n+        SecurityPolicy asJohn = SecurityPolicy.of(IdentityProviders.of(\"john\"));\n+\n+        assertThat(instances.values().iterator().next().workItems(asJohn)).hasSize(1);\n+\n+        List<WorkItem> workItems = processInstance.workItems(asJohn);\n+        assertThat(workItems).hasSize(1);\n+        WorkItem workItem = workItems.get(0);\n+        assertEquals(\"john\", workItem.getParameters().get(\"ActorId\"));\n+        processInstance.completeWorkItem(workItem.getId(), null, asJohn);\n+        assertEquals(STATE_COMPLETED, processInstance.status());\n+        assertThat(instances.size()).isZero();\n+    }\n+\n+    KafkaStreams createStreams(Process process) {\n+        Topology topology = createTopologyForProcesses(Arrays.asList(process.id()));\n+        KafkaStreams streams = new KafkaStreams(topology, getStreamsConfig());\n+        streams.setUncaughtExceptionHandler((Thread thread, Throwable throwable) ->\n+                                                    LOGGER.error(\"Kafka persistence error: \" + throwable.getMessage(), throwable)\n+        );\n+        streams.cleanUp();\n+        return streams;\n+    }\n+\n+    Properties getStreamsConfig() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgxOTkzMw==", "bodyText": "Reason for changing this?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572819933", "createdAt": "2021-02-09T11:47:58Z", "author": {"login": "MarianMacik"}, "path": "integration-tests/integration-tests-springboot/src/it/integration-tests-springboot-kafka-it/pom.xml", "diffHunk": "@@ -71,8 +71,9 @@\n         </dependency>\n \n         <dependency>\n-            <groupId>org.springframework.kafka</groupId>\n-            <artifactId>spring-kafka</artifactId>\n+            <groupId>org.apache.kafka</groupId>\n+            <artifactId>kafka-clients</artifactId>\n+            <version>@version.kafka@</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg3NjY2OQ==", "bodyText": "Is this used anywhere?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572876669", "createdAt": "2021-02-09T13:19:36Z", "author": {"login": "MarianMacik"}, "path": "kogito-build-parent/pom.xml", "diffHunk": "@@ -880,6 +882,23 @@\n         <version>${version.io.serverlessworkflow}</version>\n       </dependency>\n \n+      <!-- Kafka -->\n+      <dependency>\n+        <groupId>org.apache.kafka</groupId>\n+        <artifactId>kafka-streams</artifactId>\n+        <version>${version.kafka}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.kafka</groupId>\n+        <artifactId>kafka-clients</artifactId>\n+        <version>${version.kafka}</version>\n+      </dependency>\n+      <dependency>\n+        <groupId>org.apache.kafka</groupId>\n+        <artifactId>kafka-streams-test-utils</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjg3NzY4MA==", "bodyText": "Isn't this already true because of the check at the beginning of the method?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r572877680", "createdAt": "2021-02-09T13:21:07Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen-modules/kogito-codegen-processes/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -94,34 +99,39 @@ public PersistenceGenerator(KogitoBuildContext context, ProtoGenerator protoGene\n             return Collections.emptyList();\n         }\n \n-        switch (persistenceType()) {\n-            case INFINISPAN_PERSISTENCE_TYPE:\n-                return infinispanBasedPersistence();\n-            case FILESYSTEM_PERSISTENCE_TYPE:\n-                return fileSystemBasedPersistence();\n-            case MONGODB_PERSISTENCE_TYPE:\n-                return mongodbBasedPersistence();\n-            default:\n-                throw new IllegalArgumentException(\"Unknown persistenceType \" + persistenceType());\n+        Collection<GeneratedFile> generatedFiles = new ArrayList<>(protoGenerator.generateProtoFiles());\n+        \n+        if (context().getAddonsConfig().usePersistence()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615"}, "originalPosition": 58}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/8135a7c3c111e463f7c0c0ec93bdc08e450b8615", "committedDate": "2021-02-09T06:40:45Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "730a8254ba0855f4a904091a1306a0599df22613", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/730a8254ba0855f4a904091a1306a0599df22613", "committedDate": "2021-02-10T06:34:15Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "730a8254ba0855f4a904091a1306a0599df22613", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/730a8254ba0855f4a904091a1306a0599df22613", "committedDate": "2021-02-10T06:34:15Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "committedDate": "2021-02-10T07:02:46Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a", "committedDate": "2021-02-10T07:02:46Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "committedDate": "2021-02-10T10:20:35Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg3NjA3NjY3", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#pullrequestreview-587607667", "createdAt": "2021-02-10T13:33:05Z", "commit": {"oid": "c4f2bcaed6f24d990d04abfe1908d1b98ae9ec1a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxMzozMzozMlrOIjJoFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxMzo0MzowM1rOIjKB4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzcyODc4OQ==", "bodyText": "As I asked before, cannot this be called by multiple threads at the same time? Imagine having more processes and injecting them when the app starts. This calls this method then:\n\n  \n    \n      kogito-runtimes/jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcess.java\n    \n    \n        Lines 131 to 139\n      in\n      17154e1\n    \n    \n    \n    \n\n        \n          \n           public Process<T> configure() { \n        \n\n        \n          \n            \n        \n\n        \n          \n               registerListeners(); \n        \n\n        \n          \n               if (isProcessFactorySet()) { \n        \n\n        \n          \n                   this.instances = (MutableProcessInstances<T>) processInstancesFactory.createProcessInstances(this); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               return this; \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nwhen the process is activated.\nNot sure if injection can happen in more threads, but if it can then we need to use concurrent collection here I think. Otherwise in case more than one process is activated at the same time, it won't work properly.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573728789", "createdAt": "2021-02-10T13:33:32Z", "author": {"login": "MarianMacik"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+\n+@ApplicationScoped\n+public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n+\n+    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+\n+    private KafkaStreams streams;\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+        this.streams.setStateListener(this);\n+    }\n+\n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        instances.clear();\n+    }\n+\n+    protected List<KafkaProcessInstances> getInstances() {\n+        return instances;\n+    }\n+\n+    @Override\n+    public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n+        LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n+        if (newState == KafkaStreams.State.RUNNING) {\n+            instances.forEach(pi -> {\n+                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n+                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            });\n+        }\n+    }\n+\n+    public void addProcessInstances(KafkaProcessInstances pi) {\n+        LOGGER.debug(\"Adding process instance into listener for process: {}\", pi.getProcess().id());\n+        instances.add(pi);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzczNTM5Mg==", "bodyText": "What if KafkaStreams component is started earlier then all the KafkaProcessInstances are set up? Will it react also then? If not, we may permanently set state to running in the listener when we get that information and then set stores directly if the state is already running. That would mean, however, to sync it properly.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r573735392", "createdAt": "2021-02-10T13:43:03Z", "author": {"login": "MarianMacik"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaStreamsStateListener.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.storeName;\n+\n+@ApplicationScoped\n+public class KafkaStreamsStateListener implements KafkaStreams.StateListener {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaStreamsStateListener.class);\n+\n+    private List<KafkaProcessInstances> instances = new ArrayList<>();\n+\n+    private KafkaStreams streams;\n+\n+    @Inject\n+    public void setKafkaStreams(KafkaStreams streams) {\n+        this.streams = streams;\n+        this.streams.setStateListener(this);\n+    }\n+\n+    protected KafkaStreams getKafkaStreams() {\n+        return streams;\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        instances.clear();\n+    }\n+\n+    protected List<KafkaProcessInstances> getInstances() {\n+        return instances;\n+    }\n+\n+    @Override\n+    public void onChange(KafkaStreams.State newState, KafkaStreams.State oldState) {\n+        LOGGER.debug(\"Received change from KafkaStreams to new state: {}\", newState);\n+        if (newState == KafkaStreams.State.RUNNING) {\n+            instances.forEach(pi -> {\n+                LOGGER.info(\"Creating store for process: {}\", pi.getProcess().id());\n+                pi.setStore(streams.store(StoreQueryParameters.fromNameAndType(storeName(pi.getProcess().id()), QueryableStoreTypes.keyValueStore())));\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f"}, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/02cae2666d99b5e05a73e2c7b7feb001ed11f28f", "committedDate": "2021-02-10T10:20:35Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "c3aae5132acc313a6460afbfa28a8bb09057cc62", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c3aae5132acc313a6460afbfa28a8bb09057cc62", "committedDate": "2021-02-11T04:54:42Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3aae5132acc313a6460afbfa28a8bb09057cc62", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c3aae5132acc313a6460afbfa28a8bb09057cc62", "committedDate": "2021-02-11T04:54:42Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "1cb72ee9575ad444bba155bc7610f9eaf168bce7", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1cb72ee9575ad444bba155bc7610f9eaf168bce7", "committedDate": "2021-02-11T04:59:49Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1cb72ee9575ad444bba155bc7610f9eaf168bce7", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1cb72ee9575ad444bba155bc7610f9eaf168bce7", "committedDate": "2021-02-11T04:59:49Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "committedDate": "2021-02-11T05:43:11Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg4NDI4NDk3", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#pullrequestreview-588428497", "createdAt": "2021-02-11T10:45:32Z", "commit": {"oid": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg4OTg5OTg5", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#pullrequestreview-588989989", "createdAt": "2021-02-11T21:13:18Z", "commit": {"oid": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQyMToxMzoxOFrOIkM2sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMVQyMToxNTo1MFrOIkM8Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgzMDI1Nw==", "bodyText": "Are you sure it is enough to override this property?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574830257", "createdAt": "2021-02-11T21:13:18Z", "author": {"login": "danielezonca"}, "path": "integration-tests/integration-tests-springboot/pom.xml", "diffHunk": "@@ -8,6 +8,11 @@\n   <artifactId>integration-tests-springboot</artifactId>\n   <name>Kogito :: Integration Tests :: SpringBoot</name>\n \n+  <properties>\n+    <!-- Override version to match the one used by spring-kafka -->\n+    <version.org.apache.kafka>2.5.0</version.org.apache.kafka>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDgzMTY1MQ==", "bodyText": "This is just an approximation, do we use this value anywhere? We should make sure an approximation works", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#discussion_r574831651", "createdAt": "2021-02-11T21:15:50Z", "author": {"login": "danielezonca"}, "path": "addons/persistence/kafka-persistence-addon/src/main/java/org/kie/kogito/persistence/kafka/KafkaProcessInstances.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.kafka;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.infinispan.protostream.BaseMarshaller;\n+import org.kie.kogito.persistence.protobuf.ProtoStreamObjectMarshallingStrategy;\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.ProcessInstanceReadMode;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.kogito.persistence.kafka.KafkaPersistenceUtils.topicName;\n+import static org.kie.kogito.process.ProcessInstanceReadMode.MUTABLE;\n+\n+public class KafkaProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProcessInstances.class);\n+\n+    private Process<?> process;\n+    private KafkaProducer<String, byte[]> producer;\n+    private String topic;\n+    private ReadOnlyKeyValueStore<String, byte[]> store;\n+    private ProcessInstanceMarshaller marshaller;\n+    private CountDownLatch latch = new CountDownLatch(1);\n+\n+    public KafkaProcessInstances(Process<?> process, KafkaProducer<String, byte[]> producer, String proto, BaseMarshaller<?>... marshallers) {\n+        this.process = process;\n+        this.topic = topicName(process.id());\n+        this.producer = producer;\n+        setMarshaller(new ProcessInstanceMarshaller(new ProtoStreamObjectMarshallingStrategy(proto, marshallers)));\n+    }\n+\n+    protected Process<?> getProcess() {\n+        return process;\n+    }\n+\n+    protected ReadOnlyKeyValueStore<String, byte[]> getStore() {\n+        if (store != null) {\n+            return store;\n+        }\n+\n+        return getStoreAwait();\n+    }\n+\n+    protected void setStore(ReadOnlyKeyValueStore<String, byte[]> store) {\n+        this.store = store;\n+        this.latch.countDown();\n+    }\n+\n+    private ReadOnlyKeyValueStore<String, byte[]> getStoreAwait() {\n+        try {\n+            if (latch.await(1, TimeUnit.MINUTES)) {\n+                if (store == null) {\n+                    throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id());\n+                } else {\n+                    return store;\n+                }\n+            } else {\n+                throw new RuntimeException(\"Timeout waiting to obtain Kafka Store for process: \" + process.id());\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to obtain Kafka Store for process: \" + process.id(), e);\n+        }\n+    }\n+\n+    protected void setMarshaller(ProcessInstanceMarshaller marshaller) {\n+        this.marshaller = marshaller;\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return getStore().get(id) != null;\n+    }\n+\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            if (getStore().get(id) != null) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to persist process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            byte[] data = marshaller.marshallProcessInstance(instance);\n+            try {\n+                producer.send(new ProducerRecord<>(topic, id, data)).get();\n+                disconnect(instance);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Unable to update process instance id: \" + id, e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        try {\n+            producer.send(new ProducerRecord<>(topic, id, null)).get();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to remove process instance id: \" + id, e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional<ProcessInstance> findById(String id, ProcessInstanceReadMode mode) {\n+        byte[] data = getStore().get(id);\n+        if (data == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(mode == MUTABLE ?\n+                                   marshaller.unmarshallProcessInstance(data, process) :\n+                                   marshaller.unmarshallReadOnlyProcessInstance(data, process)\n+        );\n+    }\n+\n+    @Override\n+    public Collection<ProcessInstance> values(ProcessInstanceReadMode mode) {\n+        final List<ProcessInstance> instances = new ArrayList<>();\n+        try (final KeyValueIterator<String, byte[]> iterator = getStore().all()) {\n+            while (iterator.hasNext()) {\n+                instances.add(mode == MUTABLE ?\n+                                      marshaller.unmarshallProcessInstance(iterator.next().value, process) :\n+                                      marshaller.unmarshallReadOnlyProcessInstance(iterator.next().value, process)\n+                );\n+            }\n+            return instances;\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public Integer size() {\n+        return (int) getStore().approximateNumEntries();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c"}, "originalPosition": 174}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a4d5d4e49b5c167ede9e18de4a4384acd8d2455c", "committedDate": "2021-02-11T05:43:11Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "b9353cbdb6843b3584630fd4e77028e6c819a4bf", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b9353cbdb6843b3584630fd4e77028e6c819a4bf", "committedDate": "2021-02-12T13:03:01Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b9353cbdb6843b3584630fd4e77028e6c819a4bf", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b9353cbdb6843b3584630fd4e77028e6c819a4bf", "committedDate": "2021-02-12T13:03:01Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "d5a0ac73bf080723dfd265f9b0862f1d0509e7a0", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/d5a0ac73bf080723dfd265f9b0862f1d0509e7a0", "committedDate": "2021-02-12T13:50:00Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg5NTUzMTE5", "url": "https://github.com/kiegroup/kogito-runtimes/pull/825#pullrequestreview-589553119", "createdAt": "2021-02-12T15:10:38Z", "commit": {"oid": "d5a0ac73bf080723dfd265f9b0862f1d0509e7a0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03463ae050215ce3761dae5e78eb8150c216d72e", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/03463ae050215ce3761dae5e78eb8150c216d72e", "committedDate": "2021-02-15T02:33:44Z", "message": "KOGITO-3073 Kafka persistence addon"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d5a0ac73bf080723dfd265f9b0862f1d0509e7a0", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/d5a0ac73bf080723dfd265f9b0862f1d0509e7a0", "committedDate": "2021-02-12T13:50:00Z", "message": "KOGITO-3073 Kafka persistence addon"}, "afterCommit": {"oid": "03463ae050215ce3761dae5e78eb8150c216d72e", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/03463ae050215ce3761dae5e78eb8150c216d72e", "committedDate": "2021-02-15T02:33:44Z", "message": "KOGITO-3073 Kafka persistence addon"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4029, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}