{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3ODQ4NTA2", "number": 544, "title": "[KOGITO-2126] Implement decision tracing addon with TraceEvent", "bodyText": "Related JIRA ticket\nWith this PR, decision tracing addon exports data formatted as TraceEvent (wrapped in a CloudEvent). This JIRA ticket refers to the discussion that led to the choice of this specific format.", "createdAt": "2020-06-04T13:41:57Z", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544", "merged": true, "mergeCommit": {"oid": "6badb08b30ac8160f3ba081e4a3324c8b5050408"}, "closed": true, "closedAt": "2020-06-22T19:38:04Z", "author": {"login": "kostola"}, "timelineItems": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoN9YmAFqTQyNTA1MjU1Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABct0qN5gFqTQzNTE1MDU1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDUyNTUz", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-425052553", "createdAt": "2020-06-05T07:20:09Z", "commit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzoyMDowOVrOGfjHBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo1Nzo0NVrOGfkPMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNDI3OQ==", "bodyText": "Is this Counter class used just for this check?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435734279", "createdAt": "2020-06-05T07:20:09Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/DecisionTracingCollector.java", "diffHunk": "@@ -35,49 +38,84 @@\n     private static final Logger LOG = LoggerFactory.getLogger(DecisionTracingCollector.class);\n \n     private final Map<String, List<EvaluateEvent>> cacheMap;\n+    private final Map<String, Counter> openEventsCounterMap;\n     private final Aggregator<?> aggregator;\n     private final Consumer<String> payloadConsumer;\n+    private final ModelSupplier modelSupplier;\n \n-    public DecisionTracingCollector(Consumer<String> payloadConsumer) {\n-        this(new DefaultAggregator(), payloadConsumer);\n+    public DecisionTracingCollector(Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n+        this(new DefaultAggregator(), payloadConsumer, modelSupplier);\n     }\n \n-    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer) {\n-        this.payloadConsumer = payloadConsumer;\n+    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n         this.cacheMap = new HashMap<>();\n+        this.openEventsCounterMap = new HashMap<>();\n         this.aggregator = aggregator;\n+        this.payloadConsumer = payloadConsumer;\n+        this.modelSupplier = modelSupplier;\n     }\n \n     public void addEvent(EvaluateEvent event) {\n-        LOG.trace(\n-                \"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\",\n-                event.getClass().getSimpleName(),\n-                event.getExecutionId(),\n-                event.getModelName(),\n-                event.getModelNamespace()\n-        );\n+        LOG.trace(\"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\", event.getType(), event.getExecutionId(), event.getModelName(), event.getModelNamespace());\n \n         String evaluationId = event.getExecutionId();\n         if (cacheMap.containsKey(evaluationId)) {\n             cacheMap.get(evaluationId).add(event);\n+            if (event.getType().isBefore()) {\n+                openEventsCounterMap.get(evaluationId).increment();\n+            } else {\n+                openEventsCounterMap.get(evaluationId).decrement();\n+            }\n         } else {\n             List<EvaluateEvent> list = new LinkedList<>();\n             list.add(event);\n             cacheMap.put(evaluationId, list);\n+            openEventsCounterMap.put(evaluationId, new Counter(1));\n             LOG.trace(\"Added evaluation {} to cache (current size: {})\", evaluationId, cacheMap.size());\n         }\n \n-        if (event instanceof AfterEvaluateAllEvent) {\n-            String payload = aggregate(evaluationId, cacheMap.get(evaluationId));\n-            payloadConsumer.accept(payload);\n-            LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+        if (openEventsCounterMap.get(evaluationId).getValue() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTc0NQ==", "bodyText": "Record execution timestamp?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435735745", "createdAt": "2020-06-05T07:23:29Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceHeader.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+\n+public class TraceHeader {\n+\n+    private final TraceEvent.Type type;\n+    private final String executionId;\n+    private final long duration;\n+    private final TraceModel resourceId;\n+    @JsonInclude(NON_EMPTY)\n+    private final List<Message> messages;\n+\n+    public TraceHeader(TraceEvent.Type type, String executionId, long duration, TraceModel resourceId, List<Message> messages) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczOTcwMg==", "bodyText": "Duplicated code", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435739702", "createdAt": "2020-06-05T07:31:39Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));\n+                }\n+                DefaultAggregatorStackEntry stackEntry = stack.pop();\n+                TraceExecutionStep step = buildTraceExecutionStep(model, stackEntry, event);\n+                if (stack.isEmpty()) {\n+                    executionSteps.add(step);\n+                } else {\n+                    stack.peek().addChild(step);\n+                }\n+            }\n+            LOG.trace(\"Finished aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+        }\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionSteps);\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n                 .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+                .withSource(URI.create(URLEncoder.encode(lastEvent.getModelName(), StandardCharsets.UTF_8)))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static TraceExecutionStep buildTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        switch (stackEntry.getType()) {\n+            case DMN_BKM_EVALUATION:\n+                return buildDmnBkmEvaluationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_BKM_INVOCATION:\n+                return buildDmnBkmInvocationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_CONTEXT_ENTRY:\n+                return buildDmnContextEntryTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION:\n+                return buildDmnDecisionTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_SERVICE:\n+                return buildDmnDecisionServiceTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_TABLE:\n+                return buildDmnDecisionTableTraceExecutionStep(model, stackEntry, afterEvent);\n+        }\n+        // this should never happen\n+        throw new AggregatorException(\"Can't build trace execution step\");\n+    }\n+\n+    private static TraceExecutionStep buildDmnBkmEvaluationTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), null, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }\n+\n+    private static TraceExecutionStep buildDmnBkmInvocationTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), null, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MDEzNg==", "bodyText": "Duplicated code as above?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435740136", "createdAt": "2020-06-05T07:32:34Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));\n+                }\n+                DefaultAggregatorStackEntry stackEntry = stack.pop();\n+                TraceExecutionStep step = buildTraceExecutionStep(model, stackEntry, event);\n+                if (stack.isEmpty()) {\n+                    executionSteps.add(step);\n+                } else {\n+                    stack.peek().addChild(step);\n+                }\n+            }\n+            LOG.trace(\"Finished aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+        }\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionSteps);\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n                 .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+                .withSource(URI.create(URLEncoder.encode(lastEvent.getModelName(), StandardCharsets.UTF_8)))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static TraceExecutionStep buildTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        switch (stackEntry.getType()) {\n+            case DMN_BKM_EVALUATION:\n+                return buildDmnBkmEvaluationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_BKM_INVOCATION:\n+                return buildDmnBkmInvocationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_CONTEXT_ENTRY:\n+                return buildDmnContextEntryTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION:\n+                return buildDmnDecisionTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_SERVICE:\n+                return buildDmnDecisionServiceTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_TABLE:\n+                return buildDmnDecisionTableTraceExecutionStep(model, stackEntry, afterEvent);\n+        }\n+        // this should never happen\n+        throw new AggregatorException(\"Can't build trace execution step\");\n+    }\n+\n+    private static TraceExecutionStep buildDmnBkmEvaluationTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), null, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }\n+\n+    private static TraceExecutionStep buildDmnBkmInvocationTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), null, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }\n+\n+    private static TraceExecutionStep buildDmnContextEntryTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Object result = afterEvent.getContextEntryResult().getExpressionResult();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"expressionId\", afterEvent.getContextEntryResult().getExpressionId());\n+        additionalData.put(\"nodeId\", model.getDecisionByName(afterEvent.getNodeName()).getId());\n+        additionalData.put(\"variableId\", afterEvent.getContextEntryResult().getVariableId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getContextEntryResult().getVariableName(), result, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }\n+\n+    private static TraceExecutionStep buildDmnDecisionTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        List<Message> messages = afterEvent.getResult().getMessages().stream()\n+                .filter(m -> afterEvent.getNodeId().equals(m.getSourceId()))\n+                .collect(Collectors.toList());\n+\n+        Object result = afterEvent.getResult().getDecisionResults().stream()\n+                .filter(dr -> dr.getDecisionId().equals(afterEvent.getNodeId()))\n+                .findFirst()\n+                .map(EvaluateDecisionResult::getResult)\n+                .orElse(null);\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), result, messages, additionalData, stackEntry.getChildren());\n+    }\n+\n+    private static TraceExecutionStep buildDmnDecisionServiceTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), null, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MzcyNg==", "bodyText": "Move to separated file", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435743726", "createdAt": "2020-06-05T07:40:04Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/evaluate/EvaluateEvent.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.evaluate;\n+\n+import java.util.Map;\n+\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.ast.DMNNode;\n+import org.kie.dmn.api.core.event.AfterEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.AfterInvokeBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.BeforeInvokeBKMEvent;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+\n+public class EvaluateEvent {\n+\n+    public enum Type {\n+        BEFORE_EVALUATE_ALL(true),\n+        AFTER_EVALUATE_ALL(false),\n+        BEFORE_EVALUATE_BKM(true),\n+        AFTER_EVALUATE_BKM(false),\n+        BEFORE_EVALUATE_CONTEXT_ENTRY(true),\n+        AFTER_EVALUATE_CONTEXT_ENTRY(false),\n+        BEFORE_EVALUATE_DECISION(true),\n+        AFTER_EVALUATE_DECISION(false),\n+        BEFORE_EVALUATE_DECISION_SERVICE(true),\n+        AFTER_EVALUATE_DECISION_SERVICE(false),\n+        BEFORE_EVALUATE_DECISION_TABLE(true),\n+        AFTER_EVALUATE_DECISION_TABLE(false),\n+        BEFORE_INVOKE_BKM(true),\n+        AFTER_INVOKE_BKM(false);\n+\n+        private final boolean before;\n+\n+        Type(boolean before) {\n+            this.before = before;\n+        }\n+\n+        public boolean isBefore() {\n+            return before;\n+        }\n+\n+        public boolean isAfter() {\n+            return !before;\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NDE4Mw==", "bodyText": "Move to separated file", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435744183", "createdAt": "2020-06-05T07:41:00Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceExecutionStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+\n+public class TraceExecutionStep {\n+\n+    public enum Type {\n+        DMN_BKM_EVALUATION,\n+        DMN_BKM_INVOCATION,\n+        DMN_CONTEXT_ENTRY,\n+        DMN_DECISION,\n+        DMN_DECISION_SERVICE,\n+        DMN_DECISION_TABLE\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0OTI3Mg==", "bodyText": "I think these two properties are not enough to identify a model of a particular version. We should include the GAV and the other properties we talked about some time ago @danielezonca wdyt?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435749272", "createdAt": "2020-06-05T07:50:49Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceModel.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import org.kie.dmn.api.core.DMNModel;\n+\n+public class TraceModel {\n+    private final String modelNamespace;\n+    private final String modelName;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTY2NA==", "bodyText": "Just a consideration: with this structure, the consumer of this data will have to load the DMN model and then do some magic to properly deserialize the value. For example of the type is composite, then the consumer will have to figure it out looking at the model and then use the information to deserialize the JsonNode value to a properly typed structure. Just saying that the complexity is then delegated to the consumer that will have to use the dmn model for sure", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435751664", "createdAt": "2020-06-05T07:55:38Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceInputValue.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+\n+public class TraceInputValue {\n+\n+    private final String id;\n+    private final String name;\n+    private final TraceType type;\n+    private final JsonNode value;\n+    @JsonInclude(NON_EMPTY)\n+    private final List<Message> messages;\n+\n+    public TraceInputValue(String id, String name, TraceType type, JsonNode value, List<Message> messages) {\n+        this.id = id;\n+        this.name = name;\n+        this.type = type;\n+        this.value = value;\n+        this.messages = messages;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTgzNw==", "bodyText": "Same considerations for the InputValue", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435751837", "createdAt": "2020-06-05T07:55:57Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceOutputValue.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+\n+public class TraceOutputValue {\n+\n+    private final String id;\n+    private final String name;\n+    private final String status;\n+    private final TraceType type;\n+    private final JsonNode value;\n+    @JsonInclude(NON_EMPTY)\n+    private final List<Message> messages;\n+\n+    public TraceOutputValue(String id, String name, String status, TraceType type, JsonNode value, List<Message> messages) {\n+        this.id = id;\n+        this.name = name;\n+        this.status = status;\n+        this.type = type;\n+        this.value = value;\n+        this.messages = messages;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1Mjc1Mw==", "bodyText": "I'm not sure we should be a little bit more specific here since the DMNType has a kind of implicit contract documented here https://github.com/kiegroup/drools/blob/00811849ad79a98c562adc188862f705c71859a0/kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNType.java#L30 . Basically when you call dmnType.getName() you get data with different semantic if the node is usin FEEL or not", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435752753", "createdAt": "2020-06-05T07:57:45Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceType.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.dmn.api.core.DMNType;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+\n+@JsonInclude(NON_NULL)\n+public class TraceType {\n+    private final String id;\n+    private final String namespace;\n+    private final String name;\n+\n+    public TraceType(String id, String namespace, String name) {\n+        this.id = id;\n+        this.namespace = namespace;\n+        this.name = name;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "committedDate": "2020-06-04T13:31:38Z", "message": "[KOGITO-2126] Implement decision tracing addon with TraceEvent"}, "afterCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f533801625f51cfd343d8a6e19b0de00c764ab87", "committedDate": "2020-06-05T12:23:40Z", "message": "[KOGITO-2126] Fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MjEzNzM0", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-425213734", "createdAt": "2020-06-05T11:22:39Z", "commit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyMjozOVrOGfqnhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzozNjowNFrOGf3WHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NzI4Nw==", "bodyText": "Please use AtomicInteger instead of this custom class", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435857287", "createdAt": "2020-06-05T11:22:39Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/DecisionTracingCollector.java", "diffHunk": "@@ -35,49 +38,84 @@\n     private static final Logger LOG = LoggerFactory.getLogger(DecisionTracingCollector.class);\n \n     private final Map<String, List<EvaluateEvent>> cacheMap;\n+    private final Map<String, Counter> openEventsCounterMap;\n     private final Aggregator<?> aggregator;\n     private final Consumer<String> payloadConsumer;\n+    private final ModelSupplier modelSupplier;\n \n-    public DecisionTracingCollector(Consumer<String> payloadConsumer) {\n-        this(new DefaultAggregator(), payloadConsumer);\n+    public DecisionTracingCollector(Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n+        this(new DefaultAggregator(), payloadConsumer, modelSupplier);\n     }\n \n-    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer) {\n-        this.payloadConsumer = payloadConsumer;\n+    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n         this.cacheMap = new HashMap<>();\n+        this.openEventsCounterMap = new HashMap<>();\n         this.aggregator = aggregator;\n+        this.payloadConsumer = payloadConsumer;\n+        this.modelSupplier = modelSupplier;\n     }\n \n     public void addEvent(EvaluateEvent event) {\n-        LOG.trace(\n-                \"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\",\n-                event.getClass().getSimpleName(),\n-                event.getExecutionId(),\n-                event.getModelName(),\n-                event.getModelNamespace()\n-        );\n+        LOG.trace(\"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\", event.getType(), event.getExecutionId(), event.getModelName(), event.getModelNamespace());\n \n         String evaluationId = event.getExecutionId();\n         if (cacheMap.containsKey(evaluationId)) {\n             cacheMap.get(evaluationId).add(event);\n+            if (event.getType().isBefore()) {\n+                openEventsCounterMap.get(evaluationId).increment();\n+            } else {\n+                openEventsCounterMap.get(evaluationId).decrement();\n+            }\n         } else {\n             List<EvaluateEvent> list = new LinkedList<>();\n             list.add(event);\n             cacheMap.put(evaluationId, list);\n+            openEventsCounterMap.put(evaluationId, new Counter(1));\n             LOG.trace(\"Added evaluation {} to cache (current size: {})\", evaluationId, cacheMap.size());\n         }\n \n-        if (event instanceof AfterEvaluateAllEvent) {\n-            String payload = aggregate(evaluationId, cacheMap.get(evaluationId));\n-            payloadConsumer.accept(payload);\n-            LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+        if (openEventsCounterMap.get(evaluationId).getValue() == 0) {\n+            Optional<DMNModel> optModel = modelSupplier.get(event.getModelNamespace(), event.getModelName());\n+\n+            if (optModel.isPresent()) {\n+                try {\n+                    String payload = aggregate(optModel.get(), evaluationId, cacheMap.get(evaluationId));\n+                    payloadConsumer.accept(payload);\n+                    LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+                } catch (AggregatorException e) {\n+                    LOG.error(\"Aggregator exception. Evaluation with id \" + evaluationId + \" will be discarded.\", e);\n+                }\n+            } else {\n+                LOG.error(\"Can't find model (namespace={}, name={}). Evaluation with id {} will be discarded.\", event.getModelNamespace(), event.getModelName(), evaluationId);\n+            }\n+\n             cacheMap.remove(evaluationId);\n             LOG.trace(\"Removed evaluation {} from cache (current size: {})\", evaluationId, cacheMap.size());\n         }\n     }\n \n-    private String aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        return Json.encode(aggregator.aggregate(evaluationId, events));\n+    private String aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        return Json.encode(aggregator.aggregate(model, evaluationId, events));\n     }\n \n+    private static class Counter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3Mzk4OA==", "bodyText": "This object is quite generic, I think we can move it to tracing.decision.event.common", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435873988", "createdAt": "2020-06-05T11:59:58Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/common/Message.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.common;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NDE5NQ==", "bodyText": "This object is quite generic, I think we can move it to tracing.decision.event.common", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435874195", "createdAt": "2020-06-05T12:00:25Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/common/MessageException.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.common;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NDYzNA==", "bodyText": "Can you please better explain this?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435874634", "createdAt": "2020-06-05T12:01:19Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/common/MessageFEELEvent.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.common;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.dmn.api.feel.runtime.events.FEELEvent;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+\n+public class MessageFEELEvent {\n+    private final FEELEvent.Severity severity;\n+    private final String message;\n+    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = PositiveIntegerFilter.class)\n+    private final int line;\n+    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = PositiveIntegerFilter.class)\n+    private final int column;\n+    @JsonInclude(NON_NULL)\n+    private final MessageException sourceException;\n+\n+    public MessageFEELEvent(FEELEvent.Severity severity, String message, int line, int column, MessageException sourceException) {\n+        this.severity = severity;\n+        this.message = message;\n+        this.line = line;\n+        this.column = column;\n+        this.sourceException = sourceException;\n+    }\n+\n+    public FEELEvent.Severity getSeverity() {\n+        return severity;\n+    }\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public int getLine() {\n+        return line;\n+    }\n+\n+    public int getColumn() {\n+        return column;\n+    }\n+\n+    public MessageException getSourceException() {\n+        return sourceException;\n+    }\n+\n+    public static MessageFEELEvent from(FEELEvent feelEvent) {\n+        if (feelEvent == null) {\n+            return null;\n+        }\n+        return new MessageFEELEvent(\n+                feelEvent.getSeverity(),\n+                feelEvent.getMessage(),\n+                feelEvent.getLine(),\n+                feelEvent.getColumn(),\n+                MessageException.from(feelEvent.getSourceException())\n+        );\n+    }\n+\n+    public static class PositiveIntegerFilter {\n+        @Override\n+        public boolean equals(Object other) {\n+            // Trick required to be compliant with the Jackson Custom attribute processing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3ODI0NA==", "bodyText": "This class is intended to be generic so please move it to tracing.event.trace and same for the related classes", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435878244", "createdAt": "2020-06-05T12:08:59Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceEvent.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+\n+public class TraceEvent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyNDcwMQ==", "bodyText": "Have you verified if it is possible to receive events in a wrong order? If not a check on AfterEvaluateAllEvent should be enough (you can still check the counter for consistency)\nEDIT: ok here there is the implicit assumption that events are ordered so probably AfterEvaluateAllEvent should be enough", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436024701", "createdAt": "2020-06-05T16:15:36Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/DecisionTracingCollector.java", "diffHunk": "@@ -35,49 +38,84 @@\n     private static final Logger LOG = LoggerFactory.getLogger(DecisionTracingCollector.class);\n \n     private final Map<String, List<EvaluateEvent>> cacheMap;\n+    private final Map<String, Counter> openEventsCounterMap;\n     private final Aggregator<?> aggregator;\n     private final Consumer<String> payloadConsumer;\n+    private final ModelSupplier modelSupplier;\n \n-    public DecisionTracingCollector(Consumer<String> payloadConsumer) {\n-        this(new DefaultAggregator(), payloadConsumer);\n+    public DecisionTracingCollector(Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n+        this(new DefaultAggregator(), payloadConsumer, modelSupplier);\n     }\n \n-    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer) {\n-        this.payloadConsumer = payloadConsumer;\n+    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n         this.cacheMap = new HashMap<>();\n+        this.openEventsCounterMap = new HashMap<>();\n         this.aggregator = aggregator;\n+        this.payloadConsumer = payloadConsumer;\n+        this.modelSupplier = modelSupplier;\n     }\n \n     public void addEvent(EvaluateEvent event) {\n-        LOG.trace(\n-                \"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\",\n-                event.getClass().getSimpleName(),\n-                event.getExecutionId(),\n-                event.getModelName(),\n-                event.getModelNamespace()\n-        );\n+        LOG.trace(\"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\", event.getType(), event.getExecutionId(), event.getModelName(), event.getModelNamespace());\n \n         String evaluationId = event.getExecutionId();\n         if (cacheMap.containsKey(evaluationId)) {\n             cacheMap.get(evaluationId).add(event);\n+            if (event.getType().isBefore()) {\n+                openEventsCounterMap.get(evaluationId).increment();\n+            } else {\n+                openEventsCounterMap.get(evaluationId).decrement();\n+            }\n         } else {\n             List<EvaluateEvent> list = new LinkedList<>();\n             list.add(event);\n             cacheMap.put(evaluationId, list);\n+            openEventsCounterMap.put(evaluationId, new Counter(1));\n             LOG.trace(\"Added evaluation {} to cache (current size: {})\", evaluationId, cacheMap.size());\n         }\n \n-        if (event instanceof AfterEvaluateAllEvent) {\n-            String payload = aggregate(evaluationId, cacheMap.get(evaluationId));\n-            payloadConsumer.accept(payload);\n-            LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+        if (openEventsCounterMap.get(evaluationId).getValue() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNDI3OQ=="}, "originalCommit": {"oid": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzMzYyOQ==", "bodyText": "This should never happen and I would consider this as a fatal error \ud83e\udd14\nIt is a completely broken state", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436033629", "createdAt": "2020-06-05T16:32:39Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/DecisionTracingCollector.java", "diffHunk": "@@ -35,49 +38,84 @@\n     private static final Logger LOG = LoggerFactory.getLogger(DecisionTracingCollector.class);\n \n     private final Map<String, List<EvaluateEvent>> cacheMap;\n+    private final Map<String, Counter> openEventsCounterMap;\n     private final Aggregator<?> aggregator;\n     private final Consumer<String> payloadConsumer;\n+    private final ModelSupplier modelSupplier;\n \n-    public DecisionTracingCollector(Consumer<String> payloadConsumer) {\n-        this(new DefaultAggregator(), payloadConsumer);\n+    public DecisionTracingCollector(Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n+        this(new DefaultAggregator(), payloadConsumer, modelSupplier);\n     }\n \n-    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer) {\n-        this.payloadConsumer = payloadConsumer;\n+    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n         this.cacheMap = new HashMap<>();\n+        this.openEventsCounterMap = new HashMap<>();\n         this.aggregator = aggregator;\n+        this.payloadConsumer = payloadConsumer;\n+        this.modelSupplier = modelSupplier;\n     }\n \n     public void addEvent(EvaluateEvent event) {\n-        LOG.trace(\n-                \"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\",\n-                event.getClass().getSimpleName(),\n-                event.getExecutionId(),\n-                event.getModelName(),\n-                event.getModelNamespace()\n-        );\n+        LOG.trace(\"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\", event.getType(), event.getExecutionId(), event.getModelName(), event.getModelNamespace());\n \n         String evaluationId = event.getExecutionId();\n         if (cacheMap.containsKey(evaluationId)) {\n             cacheMap.get(evaluationId).add(event);\n+            if (event.getType().isBefore()) {\n+                openEventsCounterMap.get(evaluationId).increment();\n+            } else {\n+                openEventsCounterMap.get(evaluationId).decrement();\n+            }\n         } else {\n             List<EvaluateEvent> list = new LinkedList<>();\n             list.add(event);\n             cacheMap.put(evaluationId, list);\n+            openEventsCounterMap.put(evaluationId, new Counter(1));\n             LOG.trace(\"Added evaluation {} to cache (current size: {})\", evaluationId, cacheMap.size());\n         }\n \n-        if (event instanceof AfterEvaluateAllEvent) {\n-            String payload = aggregate(evaluationId, cacheMap.get(evaluationId));\n-            payloadConsumer.accept(payload);\n-            LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+        if (openEventsCounterMap.get(evaluationId).getValue() == 0) {\n+            Optional<DMNModel> optModel = modelSupplier.get(event.getModelNamespace(), event.getModelName());\n+\n+            if (optModel.isPresent()) {\n+                try {\n+                    String payload = aggregate(optModel.get(), evaluationId, cacheMap.get(evaluationId));\n+                    payloadConsumer.accept(payload);\n+                    LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+                } catch (AggregatorException e) {\n+                    LOG.error(\"Aggregator exception. Evaluation with id \" + evaluationId + \" will be discarded.\", e);\n+                }\n+            } else {\n+                LOG.error(\"Can't find model (namespace={}, name={}). Evaluation with id {} will be discarded.\", event.getModelNamespace(), event.getModelName(), evaluationId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNjk1NQ==", "bodyText": "I think this class should be removed as concept itself: aggregation happens in parallel and we should never generate an expected error but define a default strategy to preserve data and proceed.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436036955", "createdAt": "2020-06-05T16:39:14Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/AggregatorException.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.aggregator;\n+\n+public class AggregatorException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0MjM2MA==", "bodyText": "This is not possible because here last event is added to the list.\nI don't think we can be too defensive in this code because we cannot really \"expect\" or manage an unexpected situation: model could be null too, same for evaluationId, you cannot neither trust of events.get(0) to be not null (accept or not null elements is an implementation detail of the List itself).", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436042360", "createdAt": "2020-06-05T16:49:59Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0OTQ0NA==", "bodyText": "Can this really happen? The only reason I see for this is when the engine is broken so I got an AfterEvaluateAllEvent alone. If this is the case it is already too late so it is useless to \"manage\" this :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436049444", "createdAt": "2020-06-05T17:04:10Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MjkyNg==", "bodyText": "Again, this can only happen if the engine is broken :)\nBtw I think we can consider TraceExecutionStep as some sort of optional so if it is not possible to create all of them we should return partial steps (if possible) or none of them but not skip the whole execution", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436052926", "createdAt": "2020-06-05T17:11:28Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MzQ1OA==", "bodyText": "Same comment as above, it is better to loose some TraceExecutionStep instead of skip the whole execution", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436053458", "createdAt": "2020-06-05T17:12:35Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));\n+                }\n+                DefaultAggregatorStackEntry stackEntry = stack.pop();\n+                TraceExecutionStep step = buildTraceExecutionStep(model, stackEntry, event);\n+                if (stack.isEmpty()) {\n+                    executionSteps.add(step);\n+                } else {\n+                    stack.peek().addChild(step);\n+                }\n+            }\n+            LOG.trace(\"Finished aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+        }\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionSteps);\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n                 .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+                .withSource(URI.create(URLEncoder.encode(lastEvent.getModelName(), StandardCharsets.UTF_8)))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static TraceExecutionStep buildTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        switch (stackEntry.getType()) {\n+            case DMN_BKM_EVALUATION:\n+                return buildDmnBkmEvaluationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_BKM_INVOCATION:\n+                return buildDmnBkmInvocationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_CONTEXT_ENTRY:\n+                return buildDmnContextEntryTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION:\n+                return buildDmnDecisionTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_SERVICE:\n+                return buildDmnDecisionServiceTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_TABLE:\n+                return buildDmnDecisionTableTraceExecutionStep(model, stackEntry, afterEvent);\n+        }\n+        // this should never happen\n+        throw new AggregatorException(\"Can't build trace execution step\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1Mzg2Mg==", "bodyText": "Please create ticket (or tickets) with the missing logic (same for all the others TODOs)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436053862", "createdAt": "2020-06-05T17:13:28Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));\n+                }\n+                DefaultAggregatorStackEntry stackEntry = stack.pop();\n+                TraceExecutionStep step = buildTraceExecutionStep(model, stackEntry, event);\n+                if (stack.isEmpty()) {\n+                    executionSteps.add(step);\n+                } else {\n+                    stack.peek().addChild(step);\n+                }\n+            }\n+            LOG.trace(\"Finished aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+        }\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionSteps);\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n                 .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+                .withSource(URI.create(URLEncoder.encode(lastEvent.getModelName(), StandardCharsets.UTF_8)))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static TraceExecutionStep buildTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        switch (stackEntry.getType()) {\n+            case DMN_BKM_EVALUATION:\n+                return buildDmnBkmEvaluationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_BKM_INVOCATION:\n+                return buildDmnBkmInvocationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_CONTEXT_ENTRY:\n+                return buildDmnContextEntryTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION:\n+                return buildDmnDecisionTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_SERVICE:\n+                return buildDmnDecisionServiceTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_TABLE:\n+                return buildDmnDecisionTableTraceExecutionStep(model, stackEntry, afterEvent);\n+        }\n+        // this should never happen\n+        throw new AggregatorException(\"Can't build trace execution step\");\n+    }\n+\n+    private static TraceExecutionStep buildDmnBkmEvaluationTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NzQ3MA==", "bodyText": "I think the whole isBefore/isAfter logic could (should?) be moved directly to DMN events.\nSame for event Type enum (or equivalent mechanims). Wdyt?\n@tarilabs FYI, wdyt?\nDMNEvent is a generic interface but the list of events that the engine can fire is hardcoded so we can probably add an abstraction in the middle like DMNRuntimeEvent with Type, isBefore and isAfter that extends DMNEvent and that all runtime events has to use", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436057470", "createdAt": "2020-06-05T17:20:46Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/evaluate/EvaluateEvent.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.evaluate;\n+\n+import java.util.Map;\n+\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.ast.DMNNode;\n+import org.kie.dmn.api.core.event.AfterEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.AfterInvokeBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.BeforeInvokeBKMEvent;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+\n+public class EvaluateEvent {\n+\n+    public enum Type {\n+        BEFORE_EVALUATE_ALL(true),\n+        AFTER_EVALUATE_ALL(false),\n+        BEFORE_EVALUATE_BKM(true),\n+        AFTER_EVALUATE_BKM(false),\n+        BEFORE_EVALUATE_CONTEXT_ENTRY(true),\n+        AFTER_EVALUATE_CONTEXT_ENTRY(false),\n+        BEFORE_EVALUATE_DECISION(true),\n+        AFTER_EVALUATE_DECISION(false),\n+        BEFORE_EVALUATE_DECISION_SERVICE(true),\n+        AFTER_EVALUATE_DECISION_SERVICE(false),\n+        BEFORE_EVALUATE_DECISION_TABLE(true),\n+        AFTER_EVALUATE_DECISION_TABLE(false),\n+        BEFORE_INVOKE_BKM(true),\n+        AFTER_INVOKE_BKM(false);\n+\n+        private final boolean before;\n+\n+        Type(boolean before) {\n+            this.before = before;\n+        }\n+\n+        public boolean isBefore() {\n+            return before;\n+        }\n+\n+        public boolean isAfter() {\n+            return !before;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2MjA1Mw==", "bodyText": "I would like not to have a so strict relation with DMN internals, what about a simple String? Do we use this Type to obtain some specific logic?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436062053", "createdAt": "2020-06-05T17:29:51Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceExecutionStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+\n+public class TraceExecutionStep {\n+\n+    public enum Type {\n+        DMN_BKM_EVALUATION,\n+        DMN_BKM_INVOCATION,\n+        DMN_CONTEXT_ENTRY,\n+        DMN_DECISION,\n+        DMN_DECISION_SERVICE,\n+        DMN_DECISION_TABLE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2Mzc0Mw==", "bodyText": "Again too defensive both for the initial if and then with the Optional result :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436063743", "createdAt": "2020-06-05T17:32:53Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/modelsupplier/ApplicationModelSupplier.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.modelsupplier;\n+\n+import java.util.Optional;\n+\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.decision.DecisionModel;\n+\n+public class ApplicationModelSupplier implements ModelSupplier {\n+\n+    private final Application application;\n+\n+    public ApplicationModelSupplier(Application application) {\n+        this.application = application;\n+    }\n+\n+    @Override\n+    public Optional<DMNModel> get(String namespace, String name) {\n+        if (namespace == null || name == null) {\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(application)\n+                .map(Application::decisionModels)\n+                .map(dm -> dm.getDecisionModel(namespace, name))\n+                .map(DecisionModel::getDMNModel);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2NDcyMw==", "bodyText": "What do you have against BiFunction? :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436064723", "createdAt": "2020-06-05T17:33:56Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/modelsupplier/ModelSupplier.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.modelsupplier;\n+\n+import java.util.Optional;\n+\n+import org.kie.dmn.api.core.DMNModel;\n+\n+@FunctionalInterface\n+public interface ModelSupplier {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2NTgyMA==", "bodyText": "What's the reason of this change? And why a SingleThreadExecutor?\nIf it is needed what about Quakus?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436065820", "createdAt": "2020-06-05T17:36:04Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-springboot-addon/src/main/java/org/kie/kogito/tracing/decision/SpringBootDecisionTracingConfiguration.java", "diffHunk": "@@ -91,4 +93,8 @@ public NewTopic newTopic() {\n         return new KafkaTemplate<>(producerFactory());\n     }\n \n+    @Bean(name = \"kogitoTracingDecisionAddonTaskExecutor\")\n+    public Executor threadPoolTaskExecutor() {\n+        return Executors.newSingleThreadExecutor(r -> new Thread(r, \"kogito-tracing\"));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2OTE0NjA5", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-426914609", "createdAt": "2020-06-09T08:41:21Z", "commit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODo0MToyMlrOGg-y7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODo0MzoyNFrOGg-4Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzNjQ2MA==", "bodyText": "What is the purpose of empty public constructor? Can we remove it?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437236460", "createdAt": "2020-06-09T08:41:22Z", "author": {"login": "jiripetrlik"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/AggregatorException.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.aggregator;\n+\n+public class AggregatorException extends RuntimeException {\n+\n+    public AggregatorException() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzNzc2Mw==", "bodyText": "Can you be more specific in description? For example \"Unknown stack entry type: type\". Or if you plan to not throw exception as @danielezonca suggested, please log proper warning message.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437237763", "createdAt": "2020-06-09T08:43:24Z", "author": {"login": "jiripetrlik"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));\n+                }\n+                DefaultAggregatorStackEntry stackEntry = stack.pop();\n+                TraceExecutionStep step = buildTraceExecutionStep(model, stackEntry, event);\n+                if (stack.isEmpty()) {\n+                    executionSteps.add(step);\n+                } else {\n+                    stack.peek().addChild(step);\n+                }\n+            }\n+            LOG.trace(\"Finished aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+        }\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionSteps);\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n                 .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+                .withSource(URI.create(URLEncoder.encode(lastEvent.getModelName(), StandardCharsets.UTF_8)))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static TraceExecutionStep buildTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        switch (stackEntry.getType()) {\n+            case DMN_BKM_EVALUATION:\n+                return buildDmnBkmEvaluationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_BKM_INVOCATION:\n+                return buildDmnBkmInvocationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_CONTEXT_ENTRY:\n+                return buildDmnContextEntryTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION:\n+                return buildDmnDecisionTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_SERVICE:\n+                return buildDmnDecisionServiceTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_TABLE:\n+                return buildDmnDecisionTableTraceExecutionStep(model, stackEntry, afterEvent);\n+        }\n+        // this should never happen\n+        throw new AggregatorException(\"Can't build trace execution step\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87"}, "originalPosition": 134}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f533801625f51cfd343d8a6e19b0de00c764ab87", "committedDate": "2020-06-05T12:23:40Z", "message": "[KOGITO-2126] Fix tests"}, "afterCommit": {"oid": "6c1a9cede43df9c3546115491f8a511e43ed563b", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/6c1a9cede43df9c3546115491f8a511e43ed563b", "committedDate": "2020-06-09T16:01:55Z", "message": "[KOGITO-2126] Best effort aggregation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6c1a9cede43df9c3546115491f8a511e43ed563b", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/6c1a9cede43df9c3546115491f8a511e43ed563b", "committedDate": "2020-06-09T16:01:55Z", "message": "[KOGITO-2126] Best effort aggregation"}, "afterCommit": {"oid": "c7a6c1e525995db11b6fcac731ef26a034c49176", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c7a6c1e525995db11b6fcac731ef26a034c49176", "committedDate": "2020-06-10T10:14:42Z", "message": "[KOGITO-2126] Expand tracing-decision-common tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ddfb9005abb7a9915eb7c11a40305e75a7344e7", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9ddfb9005abb7a9915eb7c11a40305e75a7344e7", "committedDate": "2020-06-10T14:22:29Z", "message": "[KOGITO-2126] Expand testing of evaluateDecisionService"}, "afterCommit": {"oid": "f9f5150751cba0494bdca859f6f488c657f2fa71", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f9f5150751cba0494bdca859f6f488c657f2fa71", "committedDate": "2020-06-11T09:17:31Z", "message": "[KOGITO-2126] Add TerminationDetector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f9f5150751cba0494bdca859f6f488c657f2fa71", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f9f5150751cba0494bdca859f6f488c657f2fa71", "committedDate": "2020-06-11T09:17:31Z", "message": "[KOGITO-2126] Add TerminationDetector"}, "afterCommit": {"oid": "296fa692b36eb3b7ad3dfdd27e16b1ad99884454", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/296fa692b36eb3b7ad3dfdd27e16b1ad99884454", "committedDate": "2020-06-11T12:08:00Z", "message": "[KOGITO-2126] Add EvaluateEventTypeTest"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7aa8b6c806d7d86b976668301ec63648e7e098a1", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7aa8b6c806d7d86b976668301ec63648e7e098a1", "committedDate": "2020-06-11T14:03:13Z", "message": "[KOGITO-2126] Update json test resources with timestamps"}, "afterCommit": {"oid": "3e6e2063a341c625137f1ce4c2bb0d25fc68ef47", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/3e6e2063a341c625137f1ce4c2bb0d25fc68ef47", "committedDate": "2020-06-11T16:03:36Z", "message": "[KOGITO-2126] Improve resourceId and source in decision service evaluations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMzc3Nzcx", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-430377771", "createdAt": "2020-06-15T07:17:45Z", "commit": {"oid": "c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzoxNzo0NVrOGjl44A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzoxNzo0NVrOGjl44A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NDExMg==", "bodyText": "null is better?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r439974112", "createdAt": "2020-06-15T07:17:45Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,339 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.dmn.core.ast.DecisionServiceNodeImpl;\n+import org.kie.dmn.feel.util.Pair;\n+import org.kie.kogito.tracing.decision.event.common.InternalMessageType;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStepType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceResourceId;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.AFTER_EVALUATE_DECISION_SERVICE;\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.BEFORE_EVALUATE_DECISION_SERVICE;\n+\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n-                .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        return events == null || events.isEmpty()\n+                ? buildNotEnoughDataCloudEvent(model, executionId)\n+                : buildDefaultCloudEvent(model, executionId, events);\n+    }\n+\n+    private static CloudEventImpl<TraceEvent> buildNotEnoughDataCloudEvent(DMNModel model, String executionId) {\n+        TraceHeader header = new TraceHeader(\n+                TraceEventType.DMN,\n+                executionId,\n+                0L,\n+                0L,\n+                0L,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMzgwMTk2", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-430380196", "createdAt": "2020-06-15T07:21:50Z", "commit": {"oid": "c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzoyMTo1MFrOGjmAbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzoyMTo1MFrOGjmAbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjA0NQ==", "bodyText": "firstEvent.getTimestamp() and lastEvent.getTimestamp() return the timestamp in milliseconds, but the duration is stored as nanoseconds. I think the three properties should have the same unit of measurement", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r439976045", "createdAt": "2020-06-15T07:21:50Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,339 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.dmn.core.ast.DecisionServiceNodeImpl;\n+import org.kie.dmn.feel.util.Pair;\n+import org.kie.kogito.tracing.decision.event.common.InternalMessageType;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStepType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceResourceId;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.AFTER_EVALUATE_DECISION_SERVICE;\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.BEFORE_EVALUATE_DECISION_SERVICE;\n+\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n-                .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        return events == null || events.isEmpty()\n+                ? buildNotEnoughDataCloudEvent(model, executionId)\n+                : buildDefaultCloudEvent(model, executionId, events);\n+    }\n+\n+    private static CloudEventImpl<TraceEvent> buildNotEnoughDataCloudEvent(DMNModel model, String executionId) {\n+        TraceHeader header = new TraceHeader(\n+                TraceEventType.DMN,\n+                executionId,\n+                0L,\n+                0L,\n+                0L,\n+                TraceResourceId.from(model),\n+                Stream.of(\n+                        Message.from(InternalMessageType.NOT_ENOUGH_DATA),\n+                        model == null ? Message.from(InternalMessageType.DMN_MODEL_NOT_FOUND) : null\n+                ).filter(Objects::nonNull).collect(Collectors.toList())\n+        );\n+\n+        TraceEvent event = new TraceEvent(header, Collections.emptyList(), Collections.emptyList(), Collections.emptyList());\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n+                .withId(executionId)\n+                .withSource(URI.create(URLEncoder.encode(\"__UNKNOWN_SOURCE__\", StandardCharsets.UTF_8)))\n+                .withData(event)\n+                .build();\n+    }\n+\n+    private static CloudEventImpl<TraceEvent> buildDefaultCloudEvent(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        List<TraceInputValue> inputs = buildTraceInputValues(model, firstEvent);\n+\n+        List<TraceOutputValue> outputs = buildTraceOutputValues(model, lastEvent);\n+\n+        Pair<List<TraceExecutionStep>, List<Message>> executionStepsPair = buildTraceExecutionSteps(model, executionId, events);\n+\n+        TraceHeader header = new TraceHeader(\n+                TraceEventType.DMN,\n+                executionId,\n+                firstEvent.getTimestamp(),\n+                lastEvent.getTimestamp(),\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMzgyMjU4", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-430382258", "createdAt": "2020-06-15T07:25:10Z", "commit": {"oid": "c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzoyNToxMVrOGjmGvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzoyNToxMVrOGjmGvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NzY2MQ==", "bodyText": "Why does it start from 1?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r439977661", "createdAt": "2020-06-15T07:25:11Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,339 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.dmn.core.ast.DecisionServiceNodeImpl;\n+import org.kie.dmn.feel.util.Pair;\n+import org.kie.kogito.tracing.decision.event.common.InternalMessageType;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStepType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceResourceId;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.AFTER_EVALUATE_DECISION_SERVICE;\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.BEFORE_EVALUATE_DECISION_SERVICE;\n+\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n-                .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        return events == null || events.isEmpty()\n+                ? buildNotEnoughDataCloudEvent(model, executionId)\n+                : buildDefaultCloudEvent(model, executionId, events);\n+    }\n+\n+    private static CloudEventImpl<TraceEvent> buildNotEnoughDataCloudEvent(DMNModel model, String executionId) {\n+        TraceHeader header = new TraceHeader(\n+                TraceEventType.DMN,\n+                executionId,\n+                0L,\n+                0L,\n+                0L,\n+                TraceResourceId.from(model),\n+                Stream.of(\n+                        Message.from(InternalMessageType.NOT_ENOUGH_DATA),\n+                        model == null ? Message.from(InternalMessageType.DMN_MODEL_NOT_FOUND) : null\n+                ).filter(Objects::nonNull).collect(Collectors.toList())\n+        );\n+\n+        TraceEvent event = new TraceEvent(header, Collections.emptyList(), Collections.emptyList(), Collections.emptyList());\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n+                .withId(executionId)\n+                .withSource(URI.create(URLEncoder.encode(\"__UNKNOWN_SOURCE__\", StandardCharsets.UTF_8)))\n+                .withData(event)\n+                .build();\n+    }\n+\n+    private static CloudEventImpl<TraceEvent> buildDefaultCloudEvent(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        List<TraceInputValue> inputs = buildTraceInputValues(model, firstEvent);\n+\n+        List<TraceOutputValue> outputs = buildTraceOutputValues(model, lastEvent);\n+\n+        Pair<List<TraceExecutionStep>, List<Message>> executionStepsPair = buildTraceExecutionSteps(model, executionId, events);\n+\n+        TraceHeader header = new TraceHeader(\n+                TraceEventType.DMN,\n+                executionId,\n+                firstEvent.getTimestamp(),\n+                lastEvent.getTimestamp(),\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceResourceId.from(firstEvent),\n+                Stream.of(\n+                        model == null ? Stream.of(Message.from(InternalMessageType.DMN_MODEL_NOT_FOUND)) : Stream.<Message>empty(),\n+                        executionStepsPair.getRight().stream(),\n+                        lastEvent.getResult().getMessages().stream()\n+                                .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                ).flatMap(Function.identity()).collect(Collectors.toList())\n+        );\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionStepsPair.getLeft());\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n+                .withId(executionId)\n+                .withSource(buildSource(firstEvent))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static URI buildSource(EvaluateEvent event) {\n+        return event.getType() == BEFORE_EVALUATE_DECISION_SERVICE || event.getType() == AFTER_EVALUATE_DECISION_SERVICE\n+               ? URI.create(String.format(\"%s/%s\", urlEncode(event.getModelName()), urlEncode(event.getNodeName())))\n+               : URI.create(urlEncode(event.getModelName()));\n+    }\n+\n+    private static List<TraceInputValue> buildTraceInputValues(DMNModel model, EvaluateEvent firstEvent) {\n+        if (model == null) {\n+            return firstEvent.getContext().entrySet().stream()\n+                    .map(DefaultAggregator::traceInputFrom)\n+                    .collect(Collectors.toList());\n+        }\n+        if (firstEvent.getType() == EvaluateEventType.BEFORE_EVALUATE_DECISION_SERVICE) {\n+            // cast to DecisionServiceNodeImpl here is required to have access to getInputParameters method\n+            Optional<DecisionServiceNodeImpl> optNode = model.getDecisionServices().stream()\n+                    .filter(ds -> ds.getId().equals(firstEvent.getNodeId()))\n+                    .findFirst()\n+                    .filter(DecisionServiceNodeImpl.class::isInstance)\n+                    .map(DecisionServiceNodeImpl.class::cast);\n+\n+            if (optNode.isPresent()) {\n+                return optNode.get().getInputParameters().values().stream()\n+                        .filter(InputDataNode.class::isInstance)\n+                        .map(InputDataNode.class::cast)\n+                        .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                        .collect(Collectors.toList());\n+            }\n+        }\n+        return model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static List<TraceOutputValue> buildTraceOutputValues(DMNModel model, EvaluateEvent lastEvent) {\n+        return lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static Pair<List<TraceExecutionStep>, List<Message>> buildTraceExecutionSteps(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        try {\n+            return new Pair<>(buildTraceExecutionStepsHierarchy(model, events), Collections.emptyList());\n+        } catch (IllegalStateException e) {\n+            LOG.error(String.format(\"IllegalStateException during aggregation of evaluation %s\", executionId), e);\n+            return new Pair<>(buildTraceExecutionStepsList(model, events), List.of(Message.from(InternalMessageType.NO_EXECUTION_STEP_HIERARCHY, e)));\n+        }\n+    }\n+\n+    private static List<TraceExecutionStep> buildTraceExecutionStepsHierarchy(DMNModel model, List<EvaluateEvent> events) {\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Deque<DefaultAggregatorStackEntry> stack = new ArrayDeque<>(events.size() / 2);\n+        for (int i = 1; i < events.size() - 1; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e"}, "originalPosition": 183}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e", "committedDate": "2020-06-11T16:06:28Z", "message": "[KOGITO-2126] Add missing getters to TraceResourceId"}, "afterCommit": {"oid": "b68b61c1da8b3f6b1b84f942378d31b0a126c5b9", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b68b61c1da8b3f6b1b84f942378d31b0a126c5b9", "committedDate": "2020-06-15T12:24:26Z", "message": "[KOGITO-2126] Remove PositiveIntegerFilter in MessageFEELEvent"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d37d7eb04c03fbeb05ef575721922f5a21ebf72", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/6d37d7eb04c03fbeb05ef575721922f5a21ebf72", "committedDate": "2020-06-15T17:50:22Z", "message": "[KOGITO-2126] Reduce code smells"}, "afterCommit": {"oid": "51f48178e1f3947fb5aac7d8d585c9123b85d0f3", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/51f48178e1f3947fb5aac7d8d585c9123b85d0f3", "committedDate": "2020-06-16T09:46:18Z", "message": "[KOGITO-2126] duration is now in milliseconds instead of nanoseconds"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMTMwMjYw", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-432130260", "createdAt": "2020-06-17T07:30:35Z", "commit": {"oid": "51f48178e1f3947fb5aac7d8d585c9123b85d0f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzozMDozNVrOGk5JuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzozMDozNVrOGk5JuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzODI5Ng==", "bodyText": "Can you please add a check to verify that DMNRuntimeEventListener doesn't contain other/additional methods?\nSame for EvaluateEventType.\nThe goal of this test is to understand if something is changing so we should cover:\n\nexisting event changes -> already covered\nadditional event not managed -> to cover\nadditional type EvaluateEventType to match -> to cover", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r441338296", "createdAt": "2020-06-17T07:30:35Z", "author": {"login": "danielezonca"}, "path": "addons/tracing/tracing-decision-common/src/test/java/org/kie/kogito/tracing/decision/event/evaluate/EvaluateEventTypeTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.evaluate;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.event.AfterEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.AfterInvokeBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.BeforeInvokeBKMEvent;\n+import org.kie.dmn.api.core.event.DMNEvent;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventListener;\n+import org.kie.dmn.feel.util.Pair;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The purpose of this test is ensure that the structure of {@link DMNRuntimeEventListener} remains\n+ * aligned with our {@link EvaluateEventType} enum that maps {@link DMNEvent} to {@link EvaluateEvent}.\n+ */\n+class EvaluateEventTypeTest {\n+\n+    private static final Map<EvaluateEventType, Pair<String, Class<?>>> CHECK_MAP = new HashMap<>() {{\n+        put(EvaluateEventType.BEFORE_EVALUATE_ALL, new Pair<>(\"beforeEvaluateAll\", BeforeEvaluateAllEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_ALL, new Pair<>(\"afterEvaluateAll\", AfterEvaluateAllEvent.class));\n+        put(EvaluateEventType.BEFORE_EVALUATE_BKM, new Pair<>(\"beforeEvaluateBKM\", BeforeEvaluateBKMEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_BKM, new Pair<>(\"afterEvaluateBKM\", AfterEvaluateBKMEvent.class));\n+        put(EvaluateEventType.BEFORE_EVALUATE_CONTEXT_ENTRY, new Pair<>(\"beforeEvaluateContextEntry\", BeforeEvaluateContextEntryEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_CONTEXT_ENTRY, new Pair<>(\"afterEvaluateContextEntry\", AfterEvaluateContextEntryEvent.class));\n+        put(EvaluateEventType.BEFORE_EVALUATE_DECISION, new Pair<>(\"beforeEvaluateDecision\", BeforeEvaluateDecisionEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_DECISION, new Pair<>(\"afterEvaluateDecision\", AfterEvaluateDecisionEvent.class));\n+        put(EvaluateEventType.BEFORE_EVALUATE_DECISION_SERVICE, new Pair<>(\"beforeEvaluateDecisionService\", BeforeEvaluateDecisionServiceEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_DECISION_SERVICE, new Pair<>(\"afterEvaluateDecisionService\", AfterEvaluateDecisionServiceEvent.class));\n+        put(EvaluateEventType.BEFORE_EVALUATE_DECISION_TABLE, new Pair<>(\"beforeEvaluateDecisionTable\", BeforeEvaluateDecisionTableEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_DECISION_TABLE, new Pair<>(\"afterEvaluateDecisionTable\", AfterEvaluateDecisionTableEvent.class));\n+        put(EvaluateEventType.BEFORE_INVOKE_BKM, new Pair<>(\"beforeInvokeBKM\", BeforeInvokeBKMEvent.class));\n+        put(EvaluateEventType.AFTER_INVOKE_BKM, new Pair<>(\"afterInvokeBKM\", AfterInvokeBKMEvent.class));\n+    }};\n+\n+    @Test\n+    void test() {\n+        for (EvaluateEventType t : EvaluateEventType.values()) {\n+            assertTrue(CHECK_MAP.containsKey(t), () -> String.format(\"Missing test entry for %s\", t));\n+        }\n+\n+        Class<DMNRuntimeEventListener> listenerClass = DMNRuntimeEventListener.class;\n+        CHECK_MAP.forEach((type, checkPair) ->\n+                assertDoesNotThrow(\n+                        () -> listenerClass.getDeclaredMethod(checkPair.getLeft(), checkPair.getRight()),\n+                        () -> String.format(\"Method %s(%s) not found for EvaluateEventType.%s\", checkPair.getLeft(), checkPair.getRight().getSimpleName(), type)\n+                )\n+        );\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51f48178e1f3947fb5aac7d8d585c9123b85d0f3"}, "originalPosition": 81}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51f48178e1f3947fb5aac7d8d585c9123b85d0f3", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/51f48178e1f3947fb5aac7d8d585c9123b85d0f3", "committedDate": "2020-06-16T09:46:18Z", "message": "[KOGITO-2126] duration is now in milliseconds instead of nanoseconds"}, "afterCommit": {"oid": "0d2c2661fe5855170388ae16842540233ec5a8ba", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/0d2c2661fe5855170388ae16842540233ec5a8ba", "committedDate": "2020-06-17T09:30:52Z", "message": "[KOGITO-2126] Expand EvaluateEventTypeTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMDYyMjEw", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-433062210", "createdAt": "2020-06-18T08:37:10Z", "commit": {"oid": "0d2c2661fe5855170388ae16842540233ec5a8ba"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0d2c2661fe5855170388ae16842540233ec5a8ba", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/0d2c2661fe5855170388ae16842540233ec5a8ba", "committedDate": "2020-06-17T09:30:52Z", "message": "[KOGITO-2126] Expand EvaluateEventTypeTest"}, "afterCommit": {"oid": "900ecd22a22b154b35d4600f304285eb6b06b245", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/900ecd22a22b154b35d4600f304285eb6b06b245", "committedDate": "2020-06-18T08:53:17Z", "message": "[KOGITO-2126] Expand EvaluateEventTypeTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16527d1da3d70c2850e3333324bee2021b0c9d58", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/16527d1da3d70c2850e3333324bee2021b0c9d58", "committedDate": "2020-06-19T09:24:14Z", "message": "[KOGITO-2126] Implement decision tracing addon with TraceEvent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1234816f179aa6570ece266eefa62c4d3e6fcb64", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1234816f179aa6570ece266eefa62c4d3e6fcb64", "committedDate": "2020-06-19T09:24:14Z", "message": "[KOGITO-2126] Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f057659dba296802ad6002bf428484e920af7391", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f057659dba296802ad6002bf428484e920af7391", "committedDate": "2020-06-19T09:24:14Z", "message": "[KOGITO-2126] Improvements and fixes for code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1265e48e3d42ed53a08bc10bb62567a497dc5619", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1265e48e3d42ed53a08bc10bb62567a497dc5619", "committedDate": "2020-06-19T09:24:14Z", "message": "[KOGITO-2126] Best effort aggregation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ad1687febebb609140f2319d9059dbef9ce4c0a", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/8ad1687febebb609140f2319d9059dbef9ce4c0a", "committedDate": "2020-06-19T09:24:14Z", "message": "[KOGITO-2126] Expand tracing-decision-common tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17f8dc2ee24f8e32acdf3a29150559a9c528bcac", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/17f8dc2ee24f8e32acdf3a29150559a9c528bcac", "committedDate": "2020-06-19T09:24:14Z", "message": "[KOGITO-2126] Expand testing of evaluateDecisionService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fee37c872d26bb3212122c908ce8abf3a3785bca", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/fee37c872d26bb3212122c908ce8abf3a3785bca", "committedDate": "2020-06-19T09:24:14Z", "message": "[KOGITO-2126] Add TerminationDetector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "831d420c311702c86f4f1d7ae0636993046fb3aa", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/831d420c311702c86f4f1d7ae0636993046fb3aa", "committedDate": "2020-06-19T09:24:14Z", "message": "[KOGITO-2126] Add EvaluateEventTypeTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b73caea635feb998ac31ee3053e67eb18bf6d1dc", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b73caea635feb998ac31ee3053e67eb18bf6d1dc", "committedDate": "2020-06-19T09:24:14Z", "message": "[KOGITO-2126] Add start and end timestamps to TraceHeader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4523b2f1400555dd92b3d9f6c6ca97d0be2b8d85", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/4523b2f1400555dd92b3d9f6c6ca97d0be2b8d85", "committedDate": "2020-06-19T09:24:14Z", "message": "[KOGITO-2126] Update json test resources with timestamps"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2bcd5fa6077722b632dab0dd70b75bc7cfae509", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b2bcd5fa6077722b632dab0dd70b75bc7cfae509", "committedDate": "2020-06-19T09:24:15Z", "message": "[KOGITO-2126] Improve resourceId and source in decision service evaluations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "556c2b5c02b14bedba1636ed17eb123f4be8ddcc", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/556c2b5c02b14bedba1636ed17eb123f4be8ddcc", "committedDate": "2020-06-19T09:24:15Z", "message": "[KOGITO-2126] Add missing getters to TraceResourceId"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "404f536bf43d04c876b25e81afd8baa7d4ccde68", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/404f536bf43d04c876b25e81afd8baa7d4ccde68", "committedDate": "2020-06-19T09:24:15Z", "message": "[KOGITO-2126] Remove PositiveIntegerFilter in MessageFEELEvent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cbe74196d10840902d48182a59e8cf9b83b86ce", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/4cbe74196d10840902d48182a59e8cf9b83b86ce", "committedDate": "2020-06-19T09:24:15Z", "message": "[KOGITO-2126] Use null to indicate missing values for startTs, endTs and duration in TraceHeader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6aff6964b6f22180d183d36362221aba8f4bf032", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/6aff6964b6f22180d183d36362221aba8f4bf032", "committedDate": "2020-06-19T09:24:15Z", "message": "[KOGITO-2126] Reduce code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f75501d3bb5c4ce13d668a276304cd115998b1a0", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f75501d3bb5c4ce13d668a276304cd115998b1a0", "committedDate": "2020-06-19T09:24:15Z", "message": "[KOGITO-2126] duration is now in milliseconds instead of nanoseconds"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63f32e37647a7cf9ec942ba794821c1976a0a30d", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/63f32e37647a7cf9ec942ba794821c1976a0a30d", "committedDate": "2020-06-19T09:24:15Z", "message": "[KOGITO-2126] Expand EvaluateEventTypeTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MDIwMjc1", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-434020275", "createdAt": "2020-06-19T11:59:26Z", "commit": {"oid": "900ecd22a22b154b35d4600f304285eb6b06b245"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MDQ0ODU4", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-434044858", "createdAt": "2020-06-19T12:41:15Z", "commit": {"oid": "900ecd22a22b154b35d4600f304285eb6b06b245"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMjo0MToxNVrOGmTaLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMjo0MToxNVrOGmTaLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNzA3MQ==", "bodyText": "Could you review a bit this logic? If an execution is really fast, it might be that the duration is 0. I mean, if the consumer sets it to 0 then it should remain 0 and not null", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r442817071", "createdAt": "2020-06-19T12:41:15Z", "author": {"login": "r00ta"}, "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceHeader.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+\n+public class TraceHeader {\n+\n+    private final TraceEventType type;\n+    private final String executionId;\n+    @JsonInclude(NON_NULL)\n+    private final Long startTimestamp;\n+    @JsonInclude(NON_NULL)\n+    private final Long endTimestamp;\n+    @JsonInclude(NON_NULL)\n+    private final Long duration;\n+    private final TraceResourceId resourceId;\n+    @JsonInclude(NON_EMPTY)\n+    private final List<Message> messages;\n+\n+    public TraceHeader(TraceEventType type, String executionId, Long startTs, Long endTs, Long duration, TraceResourceId resourceId, List<Message> messages) {\n+        this.type = type;\n+        this.executionId = executionId;\n+        this.startTimestamp = startTs == null || startTs <= 0 ? null : startTs;\n+        this.endTimestamp = endTs == null || endTs <= 0 ? null : endTs;\n+        this.duration = duration == null || duration <= 0 ? null : duration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "900ecd22a22b154b35d4600f304285eb6b06b245"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c32561c6681dd9edca576f1943e1517876ba247d", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c32561c6681dd9edca576f1943e1517876ba247d", "committedDate": "2020-06-19T13:12:49Z", "message": "[KOGITO-2126] Allow zero duration in TraceHeader"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "900ecd22a22b154b35d4600f304285eb6b06b245", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/900ecd22a22b154b35d4600f304285eb6b06b245", "committedDate": "2020-06-18T08:53:17Z", "message": "[KOGITO-2126] Expand EvaluateEventTypeTest"}, "afterCommit": {"oid": "c32561c6681dd9edca576f1943e1517876ba247d", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c32561c6681dd9edca576f1943e1517876ba247d", "committedDate": "2020-06-19T13:12:49Z", "message": "[KOGITO-2126] Allow zero duration in TraceHeader"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MTUwNTU0", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#pullrequestreview-435150554", "createdAt": "2020-06-22T17:53:51Z", "commit": {"oid": "c32561c6681dd9edca576f1943e1517876ba247d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3540, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}