{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4MDc0MDQ0", "number": 507, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo0NDo1OVrOD_dafQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMjoxMToyNlrOEBOnUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODY4Nzk3OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ActionNodeVisitor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo0NDo1OVrOGaIp3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDowMzo0OFrOGauYBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1Nzk1MA==", "bodyText": "I'm wondering whether the .toString() it the best option to check, can't any attribute be checked instead?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r430057950", "createdAt": "2020-05-25T19:44:59Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ActionNodeVisitor.java", "diffHunk": "@@ -48,22 +51,31 @@ public void visitNode(String factoryField, ActionNode node, BlockStmt body, Vari\n             body.addStatement(getFactoryMethod(getNodeId(node), METHOD_ACTION, lambda));\n         } else {\n             if (node.getAction().toString() == null || node.getAction().toString().trim().isEmpty()) {\n-                throw new IllegalStateException(\"Action node \" + node.getId() + \" name \" + node.getName() + \" has not action defined\");\n+                throw new IllegalStateException(\"Action node \" + node.getId() + \" name \" + node.getName() + \" has no action defined\");\n             }\n             BlockStmt actionBody = new BlockStmt();\n+            List<Variable> variables = variableScope.getVariables();\n+            variables.stream()\n+                    .filter(v -> isVarPresent(v, node.getAction()))\n+                    .map(ActionNodeVisitor::makeAssignment)\n+                    .forEach(actionBody::addStatement);\n+\n+            actionBody.addStatement(new NameExpr(node.getAction().toString()));\n+\n             LambdaExpr lambda = new LambdaExpr(\n                     new Parameter(new UnknownType(), KCONTEXT_VAR), // (kcontext) ->\n                     actionBody\n             );\n-\n-            for (Variable v : variableScope.getVariables()) {\n-                actionBody.addStatement(makeAssignment(v));\n-            }\n-            actionBody.addStatement(new NameExpr(node.getAction().toString()));\n-\n             body.addStatement(getFactoryMethod(getNodeId(node), METHOD_ACTION, lambda));\n         }\n         visitMetaData(node.getMetaData(), body, getNodeId(node));\n         body.addStatement(getDoneMethod(getNodeId(node)));\n     }\n+\n+    private boolean isVarPresent(Variable v, DroolsAction action) {\n+        if(action == null) {\n+            return false;\n+        }\n+        return action.toString().contains(v.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "511715d448c97a2b1fb987965f4521b1238d93cc"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY3NTk3NA==", "bodyText": "As the droolsConsequenceAction is the only one implementing the toString I check the consequence instead.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r430675974", "createdAt": "2020-05-26T20:03:48Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ActionNodeVisitor.java", "diffHunk": "@@ -48,22 +51,31 @@ public void visitNode(String factoryField, ActionNode node, BlockStmt body, Vari\n             body.addStatement(getFactoryMethod(getNodeId(node), METHOD_ACTION, lambda));\n         } else {\n             if (node.getAction().toString() == null || node.getAction().toString().trim().isEmpty()) {\n-                throw new IllegalStateException(\"Action node \" + node.getId() + \" name \" + node.getName() + \" has not action defined\");\n+                throw new IllegalStateException(\"Action node \" + node.getId() + \" name \" + node.getName() + \" has no action defined\");\n             }\n             BlockStmt actionBody = new BlockStmt();\n+            List<Variable> variables = variableScope.getVariables();\n+            variables.stream()\n+                    .filter(v -> isVarPresent(v, node.getAction()))\n+                    .map(ActionNodeVisitor::makeAssignment)\n+                    .forEach(actionBody::addStatement);\n+\n+            actionBody.addStatement(new NameExpr(node.getAction().toString()));\n+\n             LambdaExpr lambda = new LambdaExpr(\n                     new Parameter(new UnknownType(), KCONTEXT_VAR), // (kcontext) ->\n                     actionBody\n             );\n-\n-            for (Variable v : variableScope.getVariables()) {\n-                actionBody.addStatement(makeAssignment(v));\n-            }\n-            actionBody.addStatement(new NameExpr(node.getAction().toString()));\n-\n             body.addStatement(getFactoryMethod(getNodeId(node), METHOD_ACTION, lambda));\n         }\n         visitMetaData(node.getMetaData(), body, getNodeId(node));\n         body.addStatement(getDoneMethod(getNodeId(node)));\n     }\n+\n+    private boolean isVarPresent(Variable v, DroolsAction action) {\n+        if(action == null) {\n+            return false;\n+        }\n+        return action.toString().contains(v.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1Nzk1MA=="}, "originalCommit": {"oid": "511715d448c97a2b1fb987965f4521b1238d93cc"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODcwMTEzOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxOTo1NDowMFrOGaIxtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDozNjo1OFrOGahVqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTk1Ng==", "bodyText": "the getProcessInstance().getKnowledgeRuntime().getAgenda() != null condition is used in more places, it could be extracted to a method.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r430059956", "createdAt": "2020-05-25T19:54:00Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java", "diffHunk": "@@ -63,43 +64,43 @@ public String getNodeName() {\n     @Override\n     public void internalTrigger(NodeInstance from, String type) {\n         triggerTime = new Date();\n-        triggerEvent(ExtendedNodeImpl.EVENT_NODE_ENTER);\n+        triggerEvent(EVENT_NODE_ENTER);\n \n     \t// if node instance was cancelled, abort\n \t\tif (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n \t\t\treturn;\n \t\t}\n-    \tInternalAgenda agenda =  (InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda();\n-    \tString ruleFlowGroup = getRuleFlowGroupName();\n-    \tif (ruleFlowGroup != null && !agenda.getRuleFlowGroup(ruleFlowGroup).isActive()) {\n-        \tagenda.getRuleFlowGroup(ruleFlowGroup).setAutoDeactivate(false);\n-        \tagenda.activateRuleFlowGroup(ruleFlowGroup, getProcessInstance().getId(), getUniqueId());\n-    \t}\n-//    \tif (getDynamicNode().isAutoComplete() && getNodeInstances(false).isEmpty()) {\n-//    \t\ttriggerCompleted(NodeImpl.CONNECTION_DEFAULT_TYPE);\n-//    \t}\n-\n-        \n-        String rule = \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId() + \"-\" + getDynamicNode().getUniqueId();\n-        boolean isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-            .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), rule, getProcessInstance().getId());\n+        boolean isActive = false;\n+        // KOGITO-2168 Conditions not supported\n+        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "511715d448c97a2b1fb987965f4521b1238d93cc"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2MjM3Nw==", "bodyText": "Well, it is used 3 times and is something that will change or at least be revisited when supporting conditions. As discussed with @evacchi in the previous PR the agenda is something that should be dropped completely. So adding functions specific to the agenda is not worth it.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r430462377", "createdAt": "2020-05-26T14:36:58Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/DynamicNodeInstance.java", "diffHunk": "@@ -63,43 +64,43 @@ public String getNodeName() {\n     @Override\n     public void internalTrigger(NodeInstance from, String type) {\n         triggerTime = new Date();\n-        triggerEvent(ExtendedNodeImpl.EVENT_NODE_ENTER);\n+        triggerEvent(EVENT_NODE_ENTER);\n \n     \t// if node instance was cancelled, abort\n \t\tif (getNodeInstanceContainer().getNodeInstance(getId()) == null) {\n \t\t\treturn;\n \t\t}\n-    \tInternalAgenda agenda =  (InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda();\n-    \tString ruleFlowGroup = getRuleFlowGroupName();\n-    \tif (ruleFlowGroup != null && !agenda.getRuleFlowGroup(ruleFlowGroup).isActive()) {\n-        \tagenda.getRuleFlowGroup(ruleFlowGroup).setAutoDeactivate(false);\n-        \tagenda.activateRuleFlowGroup(ruleFlowGroup, getProcessInstance().getId(), getUniqueId());\n-    \t}\n-//    \tif (getDynamicNode().isAutoComplete() && getNodeInstances(false).isEmpty()) {\n-//    \t\ttriggerCompleted(NodeImpl.CONNECTION_DEFAULT_TYPE);\n-//    \t}\n-\n-        \n-        String rule = \"RuleFlow-AdHocComplete-\" + getProcessInstance().getProcessId() + \"-\" + getDynamicNode().getUniqueId();\n-        boolean isActive = ((InternalAgenda) getProcessInstance().getKnowledgeRuntime().getAgenda())\n-            .isRuleActiveInRuleFlowGroup(getRuleFlowGroupName(), rule, getProcessInstance().getId());\n+        boolean isActive = false;\n+        // KOGITO-2168 Conditions not supported\n+        if(getProcessInstance().getKnowledgeRuntime().getAgenda() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTk1Ng=="}, "originalCommit": {"oid": "511715d448c97a2b1fb987965f4521b1238d93cc"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MDkwNTg0OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxMzoyMzoxNlrOGaeBTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDozMzowOFrOGahKow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQwODAxMw==", "bodyText": "What about moving the StageBuilder from test to src and use here as well?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r430408013", "createdAt": "2020-05-26T13:23:16Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -381,13 +387,33 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n     @Override\n     public Collection<Milestone> milestones() {\n         return getNodes(MilestoneNode.class)\n+                .map(MilestoneNode.class::cast)\n                 .map(n -> {\n                     String uid = (String) n.getMetaData().get(UNIQUE_ID);\n-                    return new Milestone(uid, n.getName(), getStatus(uid));\n+                    return new Milestone(uid, n.getName(), getStatus(uid), n.getConstraint());\n                 })\n                 .collect(Collectors.toList());\n     }\n \n+    @Override\n+    public Collection<Stage> stages() {\n+        return getNodes(DynamicNode.class)\n+                .map(DynamicNode.class::cast)\n+                .map(n -> {\n+                    String uid = (String) n.getMetaData().get(UNIQUE_ID);\n+                    return new Stage(uid, n.getName(), getStatus(uid), n.getActivationExpression(), n.getCompletionExpression(), n.isAutoComplete(), collectAdHocFragments(n));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "511715d448c97a2b1fb987965f4521b1238d93cc"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ1OTU1NQ==", "bodyText": "Yes, I'll do it", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r430459555", "createdAt": "2020-05-26T14:33:08Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -381,13 +387,33 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n     @Override\n     public Collection<Milestone> milestones() {\n         return getNodes(MilestoneNode.class)\n+                .map(MilestoneNode.class::cast)\n                 .map(n -> {\n                     String uid = (String) n.getMetaData().get(UNIQUE_ID);\n-                    return new Milestone(uid, n.getName(), getStatus(uid));\n+                    return new Milestone(uid, n.getName(), getStatus(uid), n.getConstraint());\n                 })\n                 .collect(Collectors.toList());\n     }\n \n+    @Override\n+    public Collection<Stage> stages() {\n+        return getNodes(DynamicNode.class)\n+                .map(DynamicNode.class::cast)\n+                .map(n -> {\n+                    String uid = (String) n.getMetaData().get(UNIQUE_ID);\n+                    return new Stage(uid, n.getName(), getStatus(uid), n.getActivationExpression(), n.getCompletionExpression(), n.isAutoComplete(), collectAdHocFragments(n));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQwODAxMw=="}, "originalCommit": {"oid": "511715d448c97a2b1fb987965f4521b1238d93cc"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTYwODYzOnYy", "diffSide": "LEFT", "path": "drools/drools-core/src/main/java/org/drools/core/process/instance/impl/DefaultWorkItemManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDoyODoxMFrOGbM4WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNTo1MTozNVrOGbRZ6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3NTc2OA==", "bodyText": "@ruromero Im not sure whats the actual need for this change", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431175768", "createdAt": "2020-05-27T14:28:10Z", "author": {"login": "cristianonicolai"}, "path": "drools/drools-core/src/main/java/org/drools/core/process/instance/impl/DefaultWorkItemManager.java", "diffHunk": "@@ -73,8 +76,7 @@ public void internalExecuteWorkItem(WorkItem workItem) {\n         WorkItemHandler handler = this.workItemHandlers.get(workItem.getName());\n         if (handler != null) {\n             handler.executeWorkItem(workItem, this);\n-        } else throw new WorkItemHandlerNotFoundException( \"Could not find work item handler for \" + workItem.getName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI0OTg5OA==", "bodyText": "There's no need. It's just an improvement.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431249898", "createdAt": "2020-05-27T15:51:35Z", "author": {"login": "ruromero"}, "path": "drools/drools-core/src/main/java/org/drools/core/process/instance/impl/DefaultWorkItemManager.java", "diffHunk": "@@ -73,8 +76,7 @@ public void internalExecuteWorkItem(WorkItem workItem) {\n         WorkItemHandler handler = this.workItemHandlers.get(workItem.getName());\n         if (handler != null) {\n             handler.executeWorkItem(workItem, this);\n-        } else throw new WorkItemHandlerNotFoundException( \"Could not find work item handler for \" + workItem.getName(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3NTc2OA=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTYyNDM0OnYy", "diffSide": "RIGHT", "path": "drools/drools-core/src/main/java/org/drools/core/process/instance/impl/WorkItemImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDozMDoyMVrOGbNCpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNjoxMjoyMFrOGbSeHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3ODQwNw==", "bodyText": "I think it actualy makes more sense to keep the Impl class as Serializable. not the interface.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431178407", "createdAt": "2020-05-27T14:30:21Z", "author": {"login": "cristianonicolai"}, "path": "drools/drools-core/src/main/java/org/drools/core/process/instance/impl/WorkItemImpl.java", "diffHunk": "@@ -26,15 +25,15 @@\n import org.kie.api.runtime.process.NodeInstance;\n import org.kie.api.runtime.process.ProcessInstance;\n \n-public class WorkItemImpl implements WorkItem, Serializable {\n+public class WorkItemImpl implements WorkItem {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI1MDU0Mg==", "bodyText": "All WorkItem implementations must be Serializable so why not just moving it to the interface? Why do you think it makes more sense to have it in the Class?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431250542", "createdAt": "2020-05-27T15:52:25Z", "author": {"login": "ruromero"}, "path": "drools/drools-core/src/main/java/org/drools/core/process/instance/impl/WorkItemImpl.java", "diffHunk": "@@ -26,15 +25,15 @@\n import org.kie.api.runtime.process.NodeInstance;\n import org.kie.api.runtime.process.ProcessInstance;\n \n-public class WorkItemImpl implements WorkItem, Serializable {\n+public class WorkItemImpl implements WorkItem {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3ODQwNw=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI2NzM1OA==", "bodyText": "why does every work item must be serializable?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431267358", "createdAt": "2020-05-27T16:12:20Z", "author": {"login": "mswiderski"}, "path": "drools/drools-core/src/main/java/org/drools/core/process/instance/impl/WorkItemImpl.java", "diffHunk": "@@ -26,15 +25,15 @@\n import org.kie.api.runtime.process.NodeInstance;\n import org.kie.api.runtime.process.ProcessInstance;\n \n-public class WorkItemImpl implements WorkItem, Serializable {\n+public class WorkItemImpl implements WorkItem {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3ODQwNw=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTY1NjQwOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDozMzo1N1rOGbNW2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzoyNTo1MlrOGcRp4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4MzU3Ng==", "bodyText": "Formatting is really strange is this class, if you can review that in the PR I think would be a nice improvement.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431183576", "createdAt": "2020-05-27T14:33:57Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -20,13 +20,10 @@\n import java.util.Collections;\n import java.util.List;\n \n-import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n import org.jbpm.process.core.Context;\n import org.jbpm.process.core.context.AbstractContext;\n+import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n \n-/**\n- * \n- */\n public class VariableScope extends AbstractContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI1MTk3Ng==", "bodyText": "Sure, I usually try to avoid too many formatting changes to reduce the \"noise\". I will re-format this file.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431251976", "createdAt": "2020-05-27T15:54:21Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -20,13 +20,10 @@\n import java.util.Collections;\n import java.util.List;\n \n-import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n import org.jbpm.process.core.Context;\n import org.jbpm.process.core.context.AbstractContext;\n+import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n \n-/**\n- * \n- */\n public class VariableScope extends AbstractContext {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4MzU3Ng=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5NzI4NA==", "bodyText": "yeah, I agree to that, but it was little strange to review actually.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431597284", "createdAt": "2020-05-28T05:55:31Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -20,13 +20,10 @@\n import java.util.Collections;\n import java.util.List;\n \n-import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n import org.jbpm.process.core.Context;\n import org.jbpm.process.core.context.AbstractContext;\n+import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n \n-/**\n- * \n- */\n public class VariableScope extends AbstractContext {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4MzU3Ng=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMjU2MQ==", "bodyText": "done", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r432302561", "createdAt": "2020-05-29T07:25:52Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -20,13 +20,10 @@\n import java.util.Collections;\n import java.util.List;\n \n-import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n import org.jbpm.process.core.Context;\n import org.jbpm.process.core.context.AbstractContext;\n+import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n \n-/**\n- * \n- */\n public class VariableScope extends AbstractContext {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4MzU3Ng=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTY4MTgzOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDozNzo0NlrOGbNnCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDozNzo0NlrOGbNnCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4NzcyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String[] result = new String[this.variables.size()];\n          \n          \n            \n                    return variables.stream().map(v -> v.getName()).toArray(String[]::new);", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431187723", "createdAt": "2020-05-27T14:37:46Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -60,10 +57,8 @@ public void setVariables(final List<Variable> variables) {\n \n     public String[] getVariableNames() {\n         final String[] result = new String[this.variables.size()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTY4OTIxOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDozOToxMVrOGbNruQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNjo0OTowNlrOGbnxlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4ODkyMQ==", "bodyText": "isnt the opposite logic? if does not contains a . ?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431188921", "createdAt": "2020-05-27T14:39:11Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -74,7 +69,7 @@ public Variable findVariable(String variableName) {\n                 return variable;\n             }\n         }\n-        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.indexOf(\".\") == -1) {\n+        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.contains(\".\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI2ODEwNQ==", "bodyText": "what is the reason to introduce case file prefix in Kogito?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431268105", "createdAt": "2020-05-27T16:13:18Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -74,7 +69,7 @@ public Variable findVariable(String variableName) {\n                 return variable;\n             }\n         }\n-        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.indexOf(\".\") == -1) {\n+        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.contains(\".\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4ODkyMQ=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI2ODkxMQ==", "bodyText": "Yes", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431268911", "createdAt": "2020-05-27T16:14:35Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -74,7 +69,7 @@ public Variable findVariable(String variableName) {\n                 return variable;\n             }\n         }\n-        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.indexOf(\".\") == -1) {\n+        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.contains(\".\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4ODkyMQ=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxMTMxOQ==", "bodyText": "what is the reason to introduce case file prefix in Kogito?\n\nThis is not new, it was already there. Maybe the question is should this be removed?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431411319", "createdAt": "2020-05-27T20:05:42Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -74,7 +69,7 @@ public Variable findVariable(String variableName) {\n                 return variable;\n             }\n         }\n-        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.indexOf(\".\") == -1) {\n+        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.contains(\".\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4ODkyMQ=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5ODAzNg==", "bodyText": "yeah case file prefix inst something that we would be using in Kogito", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431598036", "createdAt": "2020-05-28T05:57:54Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -74,7 +69,7 @@ public Variable findVariable(String variableName) {\n                 return variable;\n             }\n         }\n-        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.indexOf(\".\") == -1) {\n+        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.contains(\".\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4ODkyMQ=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNjQwNw==", "bodyText": "Removing, then", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431616407", "createdAt": "2020-05-28T06:49:06Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -74,7 +69,7 @@ public Variable findVariable(String variableName) {\n                 return variable;\n             }\n         }\n-        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.indexOf(\".\") == -1) {\n+        if (variableName.startsWith(CASE_FILE_PREFIX) && variableName.contains(\".\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4ODkyMQ=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTY5MjI3OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/ContextInstance.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDozOTo1MlrOGbNtwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDozOTo1MlrOGbNtwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE4OTQ0Mg==", "bodyText": "again, not sure an interface is a right place for Serializable", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431189442", "createdAt": "2020-05-27T14:39:52Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/ContextInstance.java", "diffHunk": "@@ -16,21 +16,20 @@\n \n package org.jbpm.process.instance;\n \n+import java.io.Serializable;\n+\n import org.jbpm.process.core.Context;\n \n-/**\n- * \n- */\n-public interface ContextInstance {\n-    \n+public interface ContextInstance extends Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTcwOTk0OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/LightWorkItemManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNDo0Mzo1NFrOGbN5cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNjoyMjowNVrOGbS3gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE5MjQzMg==", "bodyText": "any specific need to change these inner classes into static?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431192432", "createdAt": "2020-05-27T14:43:54Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/LightWorkItemManager.java", "diffHunk": "@@ -253,7 +251,7 @@ public void retryWorkItem( String workItemID, Map<String, Object> params ) {\n         \n     }\n     \n-    private class TransitionToActive implements Transition<Void> {\n+    private static class TransitionToActive implements Transition<Void> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3Mzg1OA==", "bodyText": "non-static nested classes keep the reference to the parent object which is not needed in this case", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431273858", "createdAt": "2020-05-27T16:22:05Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/LightWorkItemManager.java", "diffHunk": "@@ -253,7 +251,7 @@ public void retryWorkItem( String workItemID, Map<String, Object> params ) {\n         \n     }\n     \n-    private class TransitionToActive implements Transition<Void> {\n+    private static class TransitionToActive implements Transition<Void> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE5MjQzMg=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTgzMDAzOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNTowNDoxM1rOGbPHEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzo0NDozNlrOGb__pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxMjMwNw==", "bodyText": "if you change the getNodes method to return a types version, then this map is unnecessay:\nprivate <T extends Node> Stream<T> getNodes(Class<T> nodeClass) {\n        if (!(legacyProcessInstance instanceof RuleFlowProcessInstance)) {\n            return Stream.empty();\n        }\n        RuleFlowProcessInstance processInstance = ((RuleFlowProcessInstance) legacyProcessInstance);\n        return Arrays.stream(processInstance.getNodeContainer().getNodes()).filter(nodeClass::isInstance).map(n -> (T)n);\n    }", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431212307", "createdAt": "2020-05-27T15:04:13Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -381,13 +385,37 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n     @Override\n     public Collection<Milestone> milestones() {\n         return getNodes(MilestoneNode.class)\n+                .map(MilestoneNode.class::cast)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTcwNg==", "bodyText": "nice suggestion", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431611706", "createdAt": "2020-05-28T06:37:14Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -381,13 +385,37 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n     @Override\n     public Collection<Milestone> milestones() {\n         return getNodes(MilestoneNode.class)\n+                .map(MilestoneNode.class::cast)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxMjMwNw=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcwMjE4Nw==", "bodyText": "Wouldn't it be enough to cast to WorkflowProcessInstance instead of RuleFlowProcessInstance?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431702187", "createdAt": "2020-05-28T09:27:03Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -381,13 +385,37 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n     @Override\n     public Collection<Milestone> milestones() {\n         return getNodes(MilestoneNode.class)\n+                .map(MilestoneNode.class::cast)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxMjMwNw=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxMzIyMw==", "bodyText": "in fact, it could be NodeInstanceContainer", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r432013223", "createdAt": "2020-05-28T17:44:36Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -381,13 +385,37 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n     @Override\n     public Collection<Milestone> milestones() {\n         return getNodes(MilestoneNode.class)\n+                .map(MilestoneNode.class::cast)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxMjMwNw=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTg0MDM2OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNTowNjozNFrOGbPN7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMjo1OTowOFrOGbz5XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxNDA2Mg==", "bodyText": "how about adhoc nodes that are not inside of stages, should we also expose it here?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431214062", "createdAt": "2020-05-27T15:06:34Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -381,13 +385,37 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n     @Override\n     public Collection<Milestone> milestones() {\n         return getNodes(MilestoneNode.class)\n+                .map(MilestoneNode.class::cast)\n                 .map(n -> {\n                     String uid = (String) n.getMetaData().get(UNIQUE_ID);\n-                    return new Milestone(uid, n.getName(), getStatus(uid));\n+                    return new Milestone(uid, n.getName(), getStatus(uid), n.getConstraint());\n                 })\n                 .collect(Collectors.toList());\n     }\n \n+    @Override\n+    public Collection<Stage> stages() {\n+        return getNodes(DynamicNode.class)\n+                .map(DynamicNode.class::cast)\n+                .map(n -> {\n+                    String uid = (String) n.getMetaData().get(UNIQUE_ID);\n+                    Stage.Builder builder = new Stage.Builder(uid)\n+                            .withName(n.getName())\n+                            .withStatus(getStatus(uid))\n+                            .withActivationExpression(n.getActivationExpression())\n+                    .withCompletionExpression(n.getCompletionExpression()).withAutoComplete(n.isAutoComplete());\n+                    getAdHocNodes(n).forEach(builder::withFragment);\n+                    return builder.build();\n+                })\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Stream<Node> getAdHocNodes(DynamicNode node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgxNTAwNQ==", "bodyText": "Yes", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431815005", "createdAt": "2020-05-28T12:59:08Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/kie/kogito/process/impl/AbstractProcessInstance.java", "diffHunk": "@@ -381,13 +385,37 @@ public void transitionWorkItem(String id, Transition<?> transition) {\n     @Override\n     public Collection<Milestone> milestones() {\n         return getNodes(MilestoneNode.class)\n+                .map(MilestoneNode.class::cast)\n                 .map(n -> {\n                     String uid = (String) n.getMetaData().get(UNIQUE_ID);\n-                    return new Milestone(uid, n.getName(), getStatus(uid));\n+                    return new Milestone(uid, n.getName(), getStatus(uid), n.getConstraint());\n                 })\n                 .collect(Collectors.toList());\n     }\n \n+    @Override\n+    public Collection<Stage> stages() {\n+        return getNodes(DynamicNode.class)\n+                .map(DynamicNode.class::cast)\n+                .map(n -> {\n+                    String uid = (String) n.getMetaData().get(UNIQUE_ID);\n+                    Stage.Builder builder = new Stage.Builder(uid)\n+                            .withName(n.getName())\n+                            .withStatus(getStatus(uid))\n+                            .withActivationExpression(n.getActivationExpression())\n+                    .withCompletionExpression(n.getCompletionExpression()).withAutoComplete(n.isAutoComplete());\n+                    getAdHocNodes(n).forEach(builder::withFragment);\n+                    return builder.build();\n+                })\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Stream<Node> getAdHocNodes(DynamicNode node) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxNDA2Mg=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTg0NDI5OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/StageTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNTowNzoyOFrOGbPQmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNTowNzoyOFrOGbPQmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxNDc0Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ProcessInstance<?> processInstance = p.createInstance(m);\n          \n          \n            \n                    ProcessInstance<?> processInstance = p.createInstance(p.createModel());", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431214746", "createdAt": "2020-05-27T15:07:28Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/StageTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.casemgmt.AdHocFragment;\n+import org.kie.kogito.process.casemgmt.Stage;\n+import org.kie.kogito.process.workitem.Policy;\n+import org.kie.kogito.services.identity.StaticIdentityProvider;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.kie.kogito.process.casemgmt.ItemDescription.Status.AVAILABLE;\n+import static org.kie.kogito.process.casemgmt.ItemDescription.Status.COMPLETED;\n+import static org.kie.kogito.process.impl.ProcessTestUtils.assertState;\n+\n+class StageTest extends AbstractCodegenTest {\n+\n+    private Policy<?> securityPolicy = SecurityPolicy.of(new StaticIdentityProvider(\"role\"));\n+\n+    @Test\n+    void testSimpleAdHoc() throws Exception {\n+        Application app = generateCodeProcessesOnly(\"cases/SimpleAdHoc.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleAdHoc\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        m.fromMap(parameters);\n+\n+        ProcessInstance<?> processInstance = p.createInstance(m);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTg2ODQ5OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/StageTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNToxMjo0N1rOGbPfwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDowNDozNVrOGbbOVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxODYyNA==", "bodyText": "can we avoid hard coding the node id, I guess that will need update as soon as the file is changed in the editor, it is probably not relevant for the test anyway.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431218624", "createdAt": "2020-05-27T15:12:47Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/StageTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.casemgmt.AdHocFragment;\n+import org.kie.kogito.process.casemgmt.Stage;\n+import org.kie.kogito.process.workitem.Policy;\n+import org.kie.kogito.services.identity.StaticIdentityProvider;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.kie.kogito.process.casemgmt.ItemDescription.Status.AVAILABLE;\n+import static org.kie.kogito.process.casemgmt.ItemDescription.Status.COMPLETED;\n+import static org.kie.kogito.process.impl.ProcessTestUtils.assertState;\n+\n+class StageTest extends AbstractCodegenTest {\n+\n+    private Policy<?> securityPolicy = SecurityPolicy.of(new StaticIdentityProvider(\"role\"));\n+\n+    @Test\n+    void testSimpleAdHoc() throws Exception {\n+        Application app = generateCodeProcessesOnly(\"cases/SimpleAdHoc.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleAdHoc\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        m.fromMap(parameters);\n+\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+\n+        HumanTaskNode task = new HumanTaskNode();\n+        task.setName(\"Update driver name\");\n+        Stage expected = new Stage.Builder(\"_866F4F98-8810-42FE-8398-6E7E272523D9\")\n+                .withName(\"Sub-process\")\n+                .withStatus(AVAILABLE)\n+                .withAutoComplete(true)\n+                .withFragment(new HumanTaskNode(), \"Update driver name\")\n+                .build();\n+        Collection<Stage> stages = processInstance.stages();\n+        assertThat(stages.size()).isEqualTo(1);\n+        assertContainsStage(expected, stages);\n+\n+        processInstance.start();\n+        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n+        assertThat(processInstance.workItems().size()).isEqualTo(1);\n+        WorkItem workItem = processInstance.workItems(securityPolicy).get(0);\n+\n+        Map<String, Object> variables = new HashMap<>();\n+        variables.put(\"updatedName\", \"Paul\");\n+        processInstance.completeWorkItem(workItem.getId(), variables, securityPolicy);\n+\n+        assertThat(((Model) processInstance.variables()).toMap().get(\"driver\")).isEqualTo(\"Paul\");\n+        assertThat(processInstance.workItems().size()).isEqualTo(0);\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+        expected = new Stage.Builder(expected).withStatus(COMPLETED).build();\n+        assertContainsStage(expected, processInstance.stages());\n+    }\n+\n+    @Test\n+    void testMultipleAdHoc() throws Exception {\n+        Application app = generateCodeProcessesOnly(\"cases/MultipleAdHoc.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.MultipleAdHoc\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        parameters.put(\"caseFile_currentStage\", 0);\n+        m.fromMap(parameters);\n+\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+        Collection<Stage> stages = processInstance.stages();\n+        assertThat(stages.size()).isEqualTo(3);\n+        ActionNode task = new ActionNode();\n+        task.setName(\"Task1\");\n+        Collection<Stage> expected = buildExpectedMultipleAdHoc();\n+        expected.forEach(eStage -> assertContainsStage(eStage, processInstance.stages()));\n+        processInstance.start();\n+\n+        assertThat(((Model) processInstance.variables()).toMap().get(\"caseFile_currentStage\")).isEqualTo(3);\n+        assertThat(processInstance.workItems().size()).isEqualTo(0);\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+        expected = expected.stream().map(s -> new Stage.Builder(s).withStatus(COMPLETED).build()).collect(Collectors.toList());\n+        expected.forEach(eStage -> assertContainsStage(eStage, processInstance.stages()));\n+    }\n+\n+    private Collection<Stage> buildExpectedMultipleAdHoc() {\n+        Collection<Stage> expected = new ArrayList<>();\n+        expected.add(new Stage.Builder(\"_4A154E74-F085-4ECA-93F1-DE452E624FB1\").withName(\"Stage 1\").withStatus(AVAILABLE).withAutoComplete(true).withFragment(new ActionNode(), \"Task1\").build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxMDc3Mw==", "bodyText": "I'll look into it. Makes sense", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431410773", "createdAt": "2020-05-27T20:04:35Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/StageTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.casemgmt.AdHocFragment;\n+import org.kie.kogito.process.casemgmt.Stage;\n+import org.kie.kogito.process.workitem.Policy;\n+import org.kie.kogito.services.identity.StaticIdentityProvider;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.kie.kogito.process.casemgmt.ItemDescription.Status.AVAILABLE;\n+import static org.kie.kogito.process.casemgmt.ItemDescription.Status.COMPLETED;\n+import static org.kie.kogito.process.impl.ProcessTestUtils.assertState;\n+\n+class StageTest extends AbstractCodegenTest {\n+\n+    private Policy<?> securityPolicy = SecurityPolicy.of(new StaticIdentityProvider(\"role\"));\n+\n+    @Test\n+    void testSimpleAdHoc() throws Exception {\n+        Application app = generateCodeProcessesOnly(\"cases/SimpleAdHoc.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleAdHoc\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        m.fromMap(parameters);\n+\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+\n+        HumanTaskNode task = new HumanTaskNode();\n+        task.setName(\"Update driver name\");\n+        Stage expected = new Stage.Builder(\"_866F4F98-8810-42FE-8398-6E7E272523D9\")\n+                .withName(\"Sub-process\")\n+                .withStatus(AVAILABLE)\n+                .withAutoComplete(true)\n+                .withFragment(new HumanTaskNode(), \"Update driver name\")\n+                .build();\n+        Collection<Stage> stages = processInstance.stages();\n+        assertThat(stages.size()).isEqualTo(1);\n+        assertContainsStage(expected, stages);\n+\n+        processInstance.start();\n+        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n+        assertThat(processInstance.workItems().size()).isEqualTo(1);\n+        WorkItem workItem = processInstance.workItems(securityPolicy).get(0);\n+\n+        Map<String, Object> variables = new HashMap<>();\n+        variables.put(\"updatedName\", \"Paul\");\n+        processInstance.completeWorkItem(workItem.getId(), variables, securityPolicy);\n+\n+        assertThat(((Model) processInstance.variables()).toMap().get(\"driver\")).isEqualTo(\"Paul\");\n+        assertThat(processInstance.workItems().size()).isEqualTo(0);\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+        expected = new Stage.Builder(expected).withStatus(COMPLETED).build();\n+        assertContainsStage(expected, processInstance.stages());\n+    }\n+\n+    @Test\n+    void testMultipleAdHoc() throws Exception {\n+        Application app = generateCodeProcessesOnly(\"cases/MultipleAdHoc.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.MultipleAdHoc\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        parameters.put(\"caseFile_currentStage\", 0);\n+        m.fromMap(parameters);\n+\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+        Collection<Stage> stages = processInstance.stages();\n+        assertThat(stages.size()).isEqualTo(3);\n+        ActionNode task = new ActionNode();\n+        task.setName(\"Task1\");\n+        Collection<Stage> expected = buildExpectedMultipleAdHoc();\n+        expected.forEach(eStage -> assertContainsStage(eStage, processInstance.stages()));\n+        processInstance.start();\n+\n+        assertThat(((Model) processInstance.variables()).toMap().get(\"caseFile_currentStage\")).isEqualTo(3);\n+        assertThat(processInstance.workItems().size()).isEqualTo(0);\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+        expected = expected.stream().map(s -> new Stage.Builder(s).withStatus(COMPLETED).build()).collect(Collectors.toList());\n+        expected.forEach(eStage -> assertContainsStage(eStage, processInstance.stages()));\n+    }\n+\n+    private Collection<Stage> buildExpectedMultipleAdHoc() {\n+        Collection<Stage> expected = new ArrayList<>();\n+        expected.add(new Stage.Builder(\"_4A154E74-F085-4ECA-93F1-DE452E624FB1\").withName(\"Stage 1\").withStatus(AVAILABLE).withAutoComplete(true).withFragment(new ActionNode(), \"Task1\").build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxODYyNA=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NTg3ODAwOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/StageTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNToxNDo0MlrOGbPl0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOTo0OTo1M1rOGcWOog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIyMDE3Nw==", "bodyText": "based on what we discussed, shouldnt this handling of case file be avoided, so we can look into that shared scope approach?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431220177", "createdAt": "2020-05-27T15:14:42Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/StageTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.casemgmt.AdHocFragment;\n+import org.kie.kogito.process.casemgmt.Stage;\n+import org.kie.kogito.process.workitem.Policy;\n+import org.kie.kogito.services.identity.StaticIdentityProvider;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.kie.kogito.process.casemgmt.ItemDescription.Status.AVAILABLE;\n+import static org.kie.kogito.process.casemgmt.ItemDescription.Status.COMPLETED;\n+import static org.kie.kogito.process.impl.ProcessTestUtils.assertState;\n+\n+class StageTest extends AbstractCodegenTest {\n+\n+    private Policy<?> securityPolicy = SecurityPolicy.of(new StaticIdentityProvider(\"role\"));\n+\n+    @Test\n+    void testSimpleAdHoc() throws Exception {\n+        Application app = generateCodeProcessesOnly(\"cases/SimpleAdHoc.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleAdHoc\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        m.fromMap(parameters);\n+\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+\n+        HumanTaskNode task = new HumanTaskNode();\n+        task.setName(\"Update driver name\");\n+        Stage expected = new Stage.Builder(\"_866F4F98-8810-42FE-8398-6E7E272523D9\")\n+                .withName(\"Sub-process\")\n+                .withStatus(AVAILABLE)\n+                .withAutoComplete(true)\n+                .withFragment(new HumanTaskNode(), \"Update driver name\")\n+                .build();\n+        Collection<Stage> stages = processInstance.stages();\n+        assertThat(stages.size()).isEqualTo(1);\n+        assertContainsStage(expected, stages);\n+\n+        processInstance.start();\n+        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n+        assertThat(processInstance.workItems().size()).isEqualTo(1);\n+        WorkItem workItem = processInstance.workItems(securityPolicy).get(0);\n+\n+        Map<String, Object> variables = new HashMap<>();\n+        variables.put(\"updatedName\", \"Paul\");\n+        processInstance.completeWorkItem(workItem.getId(), variables, securityPolicy);\n+\n+        assertThat(((Model) processInstance.variables()).toMap().get(\"driver\")).isEqualTo(\"Paul\");\n+        assertThat(processInstance.workItems().size()).isEqualTo(0);\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+        expected = new Stage.Builder(expected).withStatus(COMPLETED).build();\n+        assertContainsStage(expected, processInstance.stages());\n+    }\n+\n+    @Test\n+    void testMultipleAdHoc() throws Exception {\n+        Application app = generateCodeProcessesOnly(\"cases/MultipleAdHoc.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.MultipleAdHoc\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        parameters.put(\"caseFile_currentStage\", 0);\n+        m.fromMap(parameters);\n+\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+        Collection<Stage> stages = processInstance.stages();\n+        assertThat(stages.size()).isEqualTo(3);\n+        ActionNode task = new ActionNode();\n+        task.setName(\"Task1\");\n+        Collection<Stage> expected = buildExpectedMultipleAdHoc();\n+        expected.forEach(eStage -> assertContainsStage(eStage, processInstance.stages()));\n+        processInstance.start();\n+\n+        assertThat(((Model) processInstance.variables()).toMap().get(\"caseFile_currentStage\")).isEqualTo(3);\n+        assertThat(processInstance.workItems().size()).isEqualTo(0);\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+        expected = expected.stream().map(s -> new Stage.Builder(s).withStatus(COMPLETED).build()).collect(Collectors.toList());\n+        expected.forEach(eStage -> assertContainsStage(eStage, processInstance.stages()));\n+    }\n+\n+    private Collection<Stage> buildExpectedMultipleAdHoc() {\n+        Collection<Stage> expected = new ArrayList<>();\n+        expected.add(new Stage.Builder(\"_4A154E74-F085-4ECA-93F1-DE452E624FB1\").withName(\"Stage 1\").withStatus(AVAILABLE).withAutoComplete(true).withFragment(new ActionNode(), \"Task1\").build());\n+        expected.add(new Stage.Builder(\"_168F4098-8ACA-4E81-9F97-5EAAC0782574\").withName(\"Stage 2\").withStatus(AVAILABLE).withAutoComplete(true).withFragment(new ActionNode(), \"Task2\").build());\n+        expected.add(new Stage.Builder(\"_E2F977AC-205A-4314-A406-00CEA619CDF9\").withName(\"Stage 3\").withStatus(AVAILABLE).withAutoComplete(true).withFragment(new ActionNode(), \"Task3\").build());\n+        return expected;\n+    }\n+\n+    @Test\n+    void testCaseFile() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3NzUwNg==", "bodyText": "I will remove it for now until we implement the shared variables", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r432377506", "createdAt": "2020-05-29T09:49:53Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/process/impl/StageTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.casemgmt.AdHocFragment;\n+import org.kie.kogito.process.casemgmt.Stage;\n+import org.kie.kogito.process.workitem.Policy;\n+import org.kie.kogito.services.identity.StaticIdentityProvider;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.kie.kogito.process.casemgmt.ItemDescription.Status.AVAILABLE;\n+import static org.kie.kogito.process.casemgmt.ItemDescription.Status.COMPLETED;\n+import static org.kie.kogito.process.impl.ProcessTestUtils.assertState;\n+\n+class StageTest extends AbstractCodegenTest {\n+\n+    private Policy<?> securityPolicy = SecurityPolicy.of(new StaticIdentityProvider(\"role\"));\n+\n+    @Test\n+    void testSimpleAdHoc() throws Exception {\n+        Application app = generateCodeProcessesOnly(\"cases/SimpleAdHoc.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.SimpleAdHoc\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        m.fromMap(parameters);\n+\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+\n+        HumanTaskNode task = new HumanTaskNode();\n+        task.setName(\"Update driver name\");\n+        Stage expected = new Stage.Builder(\"_866F4F98-8810-42FE-8398-6E7E272523D9\")\n+                .withName(\"Sub-process\")\n+                .withStatus(AVAILABLE)\n+                .withAutoComplete(true)\n+                .withFragment(new HumanTaskNode(), \"Update driver name\")\n+                .build();\n+        Collection<Stage> stages = processInstance.stages();\n+        assertThat(stages.size()).isEqualTo(1);\n+        assertContainsStage(expected, stages);\n+\n+        processInstance.start();\n+        assertState(processInstance, ProcessInstance.STATE_ACTIVE);\n+        assertThat(processInstance.workItems().size()).isEqualTo(1);\n+        WorkItem workItem = processInstance.workItems(securityPolicy).get(0);\n+\n+        Map<String, Object> variables = new HashMap<>();\n+        variables.put(\"updatedName\", \"Paul\");\n+        processInstance.completeWorkItem(workItem.getId(), variables, securityPolicy);\n+\n+        assertThat(((Model) processInstance.variables()).toMap().get(\"driver\")).isEqualTo(\"Paul\");\n+        assertThat(processInstance.workItems().size()).isEqualTo(0);\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+        expected = new Stage.Builder(expected).withStatus(COMPLETED).build();\n+        assertContainsStage(expected, processInstance.stages());\n+    }\n+\n+    @Test\n+    void testMultipleAdHoc() throws Exception {\n+        Application app = generateCodeProcessesOnly(\"cases/MultipleAdHoc.bpmn\");\n+        assertThat(app).isNotNull();\n+\n+        Process<? extends Model> p = app.processes().processById(\"TestCase.MultipleAdHoc\");\n+\n+        Model m = p.createModel();\n+        Map<String, Object> parameters = new HashMap<>();\n+        parameters.put(\"caseFile_currentStage\", 0);\n+        m.fromMap(parameters);\n+\n+        ProcessInstance<?> processInstance = p.createInstance(m);\n+        Collection<Stage> stages = processInstance.stages();\n+        assertThat(stages.size()).isEqualTo(3);\n+        ActionNode task = new ActionNode();\n+        task.setName(\"Task1\");\n+        Collection<Stage> expected = buildExpectedMultipleAdHoc();\n+        expected.forEach(eStage -> assertContainsStage(eStage, processInstance.stages()));\n+        processInstance.start();\n+\n+        assertThat(((Model) processInstance.variables()).toMap().get(\"caseFile_currentStage\")).isEqualTo(3);\n+        assertThat(processInstance.workItems().size()).isEqualTo(0);\n+        assertState(processInstance, ProcessInstance.STATE_COMPLETED);\n+        expected = expected.stream().map(s -> new Stage.Builder(s).withStatus(COMPLETED).build()).collect(Collectors.toList());\n+        expected.forEach(eStage -> assertContainsStage(eStage, processInstance.stages()));\n+    }\n+\n+    private Collection<Stage> buildExpectedMultipleAdHoc() {\n+        Collection<Stage> expected = new ArrayList<>();\n+        expected.add(new Stage.Builder(\"_4A154E74-F085-4ECA-93F1-DE452E624FB1\").withName(\"Stage 1\").withStatus(AVAILABLE).withAutoComplete(true).withFragment(new ActionNode(), \"Task1\").build());\n+        expected.add(new Stage.Builder(\"_168F4098-8ACA-4E81-9F97-5EAAC0782574\").withName(\"Stage 2\").withStatus(AVAILABLE).withAutoComplete(true).withFragment(new ActionNode(), \"Task2\").build());\n+        expected.add(new Stage.Builder(\"_E2F977AC-205A-4314-A406-00CEA619CDF9\").withName(\"Stage 3\").withStatus(AVAILABLE).withAutoComplete(true).withFragment(new ActionNode(), \"Task3\").build());\n+        return expected;\n+    }\n+\n+    @Test\n+    void testCaseFile() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIyMDE3Nw=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjE5NzE2OnYy", "diffSide": "RIGHT", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNjoxODo0M1rOGbSu2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwOToyODoxMlrOGbtDXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3MTY0Mw==", "bodyText": "wouldn't it make more sense to either\n\nuse new sub class for case related methods\nuse more process related names instead\n\nmixing these two concepts can become really confusing...", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431271643", "createdAt": "2020-05-27T16:18:43Z", "author": {"login": "mswiderski"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "diffHunk": "@@ -172,4 +173,10 @@\n      * @return All the process milestones with their current status\n      */\n     Collection<Milestone> milestones();\n+\n+    /**\n+     * Returns the process stages\n+     * @return All the process stages with their current status\n+     */\n+    Collection<Stage> stages();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxMDQ0NA==", "bodyText": "This is a behaviour that is already implicit in a process so sub-classing wouldn't make much sense to me. I am in favour of renaming stages for something else. Any suggestion?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431410444", "createdAt": "2020-05-27T20:03:57Z", "author": {"login": "ruromero"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "diffHunk": "@@ -172,4 +173,10 @@\n      * @return All the process milestones with their current status\n      */\n     Collection<Milestone> milestones();\n+\n+    /**\n+     * Returns the process stages\n+     * @return All the process stages with their current status\n+     */\n+    Collection<Stage> stages();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3MTY0Mw=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcwMjg3Nw==", "bodyText": "stage is actually a subprocess, why not having this as such? If needed you can narrow it down to only ad hoc subprocesses all all...", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r431702877", "createdAt": "2020-05-28T09:28:12Z", "author": {"login": "mswiderski"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "diffHunk": "@@ -172,4 +173,10 @@\n      * @return All the process milestones with their current status\n      */\n     Collection<Milestone> milestones();\n+\n+    /**\n+     * Returns the process stages\n+     * @return All the process stages with their current status\n+     */\n+    Collection<Stage> stages();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3MTY0Mw=="}, "originalCommit": {"oid": "7e6d6a7e6914f10b39cb04f07df2051633ef2126"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MzMzMTA3OnYy", "diffSide": "RIGHT", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMTozNTowM1rOGcZJlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMjoxMzoyM1rOGcaKLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyNTM2NA==", "bodyText": "Does it return only Adhoc subprocesses or any subprocesses?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r432425364", "createdAt": "2020-05-29T11:35:03Z", "author": {"login": "tiagodolphine"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "diffHunk": "@@ -169,7 +187,22 @@\n \n     /**\n      * Returns the process milestones\n+     *\n      * @return All the process milestones with their current status\n      */\n     Collection<Milestone> milestones();\n+\n+    /**\n+     * Returns the AdHocSubProcesses in the proces", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599ed8478376f8b49d545708045bacbd4d6371d5"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0MTkwMw==", "bodyText": "Refactoring leftover, thanks", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r432441903", "createdAt": "2020-05-29T12:13:23Z", "author": {"login": "ruromero"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "diffHunk": "@@ -169,7 +187,22 @@\n \n     /**\n      * Returns the process milestones\n+     *\n      * @return All the process milestones with their current status\n      */\n     Collection<Milestone> milestones();\n+\n+    /**\n+     * Returns the AdHocSubProcesses in the proces", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyNTM2NA=="}, "originalCommit": {"oid": "599ed8478376f8b49d545708045bacbd4d6371d5"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MzM0MDgzOnYy", "diffSide": "RIGHT", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/casemgmt/SubProcess.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMTozODozMVrOGcZPmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMjoxMzo0M1rOGcaKvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyNjkwNg==", "bodyText": "Should we name it Subprocess or AdhocSubprocess?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r432426906", "createdAt": "2020-05-29T11:38:31Z", "author": {"login": "tiagodolphine"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/casemgmt/SubProcess.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.casemgmt;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+public class SubProcess extends ItemDescription {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599ed8478376f8b49d545708045bacbd4d6371d5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0MjA0Nw==", "bodyText": "AdHocSubProcesses are a specific type of SubProcesses", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r432442047", "createdAt": "2020-05-29T12:13:43Z", "author": {"login": "ruromero"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/casemgmt/SubProcess.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.process.casemgmt;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+public class SubProcess extends ItemDescription {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyNjkwNg=="}, "originalCommit": {"oid": "599ed8478376f8b49d545708045bacbd4d6371d5"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MzM0OTQ4OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMTo0MjowM1rOGcZVRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDoyODowNVrOGdF0qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyODM1OA==", "bodyText": "why not just setting the system property on the tests?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r432428358", "createdAt": "2020-05-29T11:42:03Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -89,36 +72,36 @@ public Context resolveContext(Object param) {\n             return findVariable((String) param) == null ? null : this;\n         }\n         throw new IllegalArgumentException(\n-            \"VariableScopes can only resolve variable names: \" + param);\n+                \"VariableScopes can only resolve variable names: \" + param);\n+    }\n+\n+    public void validateVariable(String processName, String name, Object value) {\n+        if (!variableStrictEnabled) {\n+            return;\n+        }\n+        Variable var = findVariable(name);\n+        if (var == null) {\n+            throw new IllegalArgumentException(\"Variable '\" + name + \"' is not defined in process \" + processName);\n+        }\n+        if (var.getType() != null && value != null) {\n+            boolean isValidType = var.getType().verifyDataType(value);\n+            if (!isValidType) {\n+                throw new IllegalArgumentException(\"Variable '\" + name + \"' has incorrect data type expected:\"\n+                        + var.getType().getStringType() + \" actual:\" + value.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /*\n+     * mainly for test coverage to easily switch between settings\n+     */\n+    public static void setVariableStrictOption(boolean turnedOn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "599ed8478376f8b49d545708045bacbd4d6371d5"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNTYxOQ==", "bodyText": "@ruromero why not simply use the system property instead?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r433015619", "createdAt": "2020-06-01T02:15:51Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -89,36 +72,36 @@ public Context resolveContext(Object param) {\n             return findVariable((String) param) == null ? null : this;\n         }\n         throw new IllegalArgumentException(\n-            \"VariableScopes can only resolve variable names: \" + param);\n+                \"VariableScopes can only resolve variable names: \" + param);\n+    }\n+\n+    public void validateVariable(String processName, String name, Object value) {\n+        if (!variableStrictEnabled) {\n+            return;\n+        }\n+        Variable var = findVariable(name);\n+        if (var == null) {\n+            throw new IllegalArgumentException(\"Variable '\" + name + \"' is not defined in process \" + processName);\n+        }\n+        if (var.getType() != null && value != null) {\n+            boolean isValidType = var.getType().verifyDataType(value);\n+            if (!isValidType) {\n+                throw new IllegalArgumentException(\"Variable '\" + name + \"' has incorrect data type expected:\"\n+                        + var.getType().getStringType() + \" actual:\" + value.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /*\n+     * mainly for test coverage to easily switch between settings\n+     */\n+    public static void setVariableStrictOption(boolean turnedOn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyODM1OA=="}, "originalCommit": {"oid": "599ed8478376f8b49d545708045bacbd4d6371d5"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExOTQ4NA==", "bodyText": "just formatting old code, nevermind @ruromero", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r433119484", "createdAt": "2020-06-01T08:58:08Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -89,36 +72,36 @@ public Context resolveContext(Object param) {\n             return findVariable((String) param) == null ? null : this;\n         }\n         throw new IllegalArgumentException(\n-            \"VariableScopes can only resolve variable names: \" + param);\n+                \"VariableScopes can only resolve variable names: \" + param);\n+    }\n+\n+    public void validateVariable(String processName, String name, Object value) {\n+        if (!variableStrictEnabled) {\n+            return;\n+        }\n+        Variable var = findVariable(name);\n+        if (var == null) {\n+            throw new IllegalArgumentException(\"Variable '\" + name + \"' is not defined in process \" + processName);\n+        }\n+        if (var.getType() != null && value != null) {\n+            boolean isValidType = var.getType().verifyDataType(value);\n+            if (!isValidType) {\n+                throw new IllegalArgumentException(\"Variable '\" + name + \"' has incorrect data type expected:\"\n+                        + var.getType().getStringType() + \" actual:\" + value.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /*\n+     * mainly for test coverage to easily switch between settings\n+     */\n+    public static void setVariableStrictOption(boolean turnedOn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyODM1OA=="}, "originalCommit": {"oid": "599ed8478376f8b49d545708045bacbd4d6371d5"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NzI4OA==", "bodyText": "I couldn't just disappoint you but I didn't change everything or else tests would go crazy", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r433157288", "createdAt": "2020-06-01T10:28:05Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/core/context/variable/VariableScope.java", "diffHunk": "@@ -89,36 +72,36 @@ public Context resolveContext(Object param) {\n             return findVariable((String) param) == null ? null : this;\n         }\n         throw new IllegalArgumentException(\n-            \"VariableScopes can only resolve variable names: \" + param);\n+                \"VariableScopes can only resolve variable names: \" + param);\n+    }\n+\n+    public void validateVariable(String processName, String name, Object value) {\n+        if (!variableStrictEnabled) {\n+            return;\n+        }\n+        Variable var = findVariable(name);\n+        if (var == null) {\n+            throw new IllegalArgumentException(\"Variable '\" + name + \"' is not defined in process \" + processName);\n+        }\n+        if (var.getType() != null && value != null) {\n+            boolean isValidType = var.getType().verifyDataType(value);\n+            if (!isValidType) {\n+                throw new IllegalArgumentException(\"Variable '\" + name + \"' has incorrect data type expected:\"\n+                        + var.getType().getStringType() + \" actual:\" + value.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /*\n+     * mainly for test coverage to easily switch between settings\n+     */\n+    public static void setVariableStrictOption(boolean turnedOn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyODM1OA=="}, "originalCommit": {"oid": "599ed8478376f8b49d545708045bacbd4d6371d5"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzIzNDczOnYy", "diffSide": "RIGHT", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMjoxMToyNlrOGc9Itw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwMjoxMToyNlrOGc9Itw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNDk2Nw==", "bodyText": "I think to align with the other methods naming we would call this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Collection<AdHocFragment> getAdHocFragments();\n          \n          \n            \n                Collection<AdHocFragment> adHocFragments();", "url": "https://github.com/kiegroup/kogito-runtimes/pull/507#discussion_r433014967", "createdAt": "2020-06-01T02:11:26Z", "author": {"login": "cristianonicolai"}, "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "diffHunk": "@@ -169,7 +187,22 @@\n \n     /**\n      * Returns the process milestones\n+     *\n      * @return All the process milestones with their current status\n      */\n     Collection<Milestone> milestones();\n+\n+    /**\n+     * Returns the SubProcesses in the process\n+     *\n+     * @return All the process {@link SubProcess} with their current status\n+     */\n+    Collection<SubProcess> subProcesses();\n+\n+    /**\n+     * Returns the process adHocFragments\n+     *\n+     * @return All the {@link AdHocFragment} in the process\n+     */\n+    Collection<AdHocFragment> getAdHocFragments();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e4882e8a48e719e77fe67594df51b94a2cbef3a"}, "originalPosition": 178}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 111, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}