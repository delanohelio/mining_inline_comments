{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwMTk3NjM1", "number": 423, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxODo1OVrODx9vXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjo1MDowOVrODy42vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE4MzY2OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/compiler/canonical/ProcessToExecModelGeneratorTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxODo1OVrOGFu29A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOToxMTozNlrOGFwzOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2Mzc5Ng==", "bodyText": "any reason for using the generic interface instead of the implementation?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r408663796", "createdAt": "2020-04-15T08:18:59Z", "author": {"login": "evacchi"}, "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/compiler/canonical/ProcessToExecModelGeneratorTest.java", "diffHunk": "@@ -61,9 +61,9 @@ public void testScriptAndWorkItemGeneration() {\n         .connection(4, 2)\n         .connection(1, 3);\n         \n-        Process process = factory.validate().getProcess();\n+        WorkflowProcess process = factory.validate().getProcess();\n         \n-        ProcessMetaData processMetadata = ProcessToExecModelGenerator.INSTANCE.generate((WorkflowProcess) process);\n+        ProcessMetaData processMetadata = ProcessToExecModelGenerator.INSTANCE.generate(process);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1922aba0f5f1b9a959dd0a6be4907bc5d3c07737"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2ODcyMQ==", "bodyText": "It is redundant. Any reason not to do it? \ud83d\ude04", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r408668721", "createdAt": "2020-04-15T08:27:11Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/compiler/canonical/ProcessToExecModelGeneratorTest.java", "diffHunk": "@@ -61,9 +61,9 @@ public void testScriptAndWorkItemGeneration() {\n         .connection(4, 2)\n         .connection(1, 3);\n         \n-        Process process = factory.validate().getProcess();\n+        WorkflowProcess process = factory.validate().getProcess();\n         \n-        ProcessMetaData processMetadata = ProcessToExecModelGenerator.INSTANCE.generate((WorkflowProcess) process);\n+        ProcessMetaData processMetadata = ProcessToExecModelGenerator.INSTANCE.generate(process);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2Mzc5Ng=="}, "originalCommit": {"oid": "1922aba0f5f1b9a959dd0a6be4907bc5d3c07737"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4MDkzOQ==", "bodyText": "Just asking :) sometimes we may want to use the implementation directly and/or we may want to drop some useless interfaces in Kogito (at some point in time :P) so using the implementation (if no cast is involved) could be even safer. Anyway, that's ok here.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r408680939", "createdAt": "2020-04-15T08:47:18Z", "author": {"login": "evacchi"}, "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/compiler/canonical/ProcessToExecModelGeneratorTest.java", "diffHunk": "@@ -61,9 +61,9 @@ public void testScriptAndWorkItemGeneration() {\n         .connection(4, 2)\n         .connection(1, 3);\n         \n-        Process process = factory.validate().getProcess();\n+        WorkflowProcess process = factory.validate().getProcess();\n         \n-        ProcessMetaData processMetadata = ProcessToExecModelGenerator.INSTANCE.generate((WorkflowProcess) process);\n+        ProcessMetaData processMetadata = ProcessToExecModelGenerator.INSTANCE.generate(process);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2Mzc5Ng=="}, "originalCommit": {"oid": "1922aba0f5f1b9a959dd0a6be4907bc5d3c07737"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5NTYxMA==", "bodyText": "I always prefer to use the interface when possible. If we want to drop useless interfaces this is a good point to think it they're really useless. As you said, if a casting is involved, the interface should not be used.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r408695610", "createdAt": "2020-04-15T09:11:36Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/compiler/canonical/ProcessToExecModelGeneratorTest.java", "diffHunk": "@@ -61,9 +61,9 @@ public void testScriptAndWorkItemGeneration() {\n         .connection(4, 2)\n         .connection(1, 3);\n         \n-        Process process = factory.validate().getProcess();\n+        WorkflowProcess process = factory.validate().getProcess();\n         \n-        ProcessMetaData processMetadata = ProcessToExecModelGenerator.INSTANCE.generate((WorkflowProcess) process);\n+        ProcessMetaData processMetadata = ProcessToExecModelGenerator.INSTANCE.generate(process);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2Mzc5Ng=="}, "originalCommit": {"oid": "1922aba0f5f1b9a959dd0a6be4907bc5d3c07737"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTI1OTIxOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ProcessVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoxNzoyMFrOGGWG4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMTowNToyOFrOGGgJTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwNjg1MA==", "bodyText": "maybe a JIRA for this?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409306850", "createdAt": "2020-04-16T06:17:20Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ProcessVisitor.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.compiler.canonical;\n+\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.LongLiteralExpr;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NullLiteralExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.VariableDeclarationExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.jbpm.process.core.ContextContainer;\n+import org.jbpm.process.core.Work;\n+import org.jbpm.process.core.context.variable.Variable;\n+import org.jbpm.process.core.context.variable.VariableScope;\n+import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n+import org.jbpm.ruleflow.core.RuleFlowProcessFactory;\n+import org.jbpm.workflow.core.Node;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.ConnectionImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.CompositeContextNode;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.EventSubProcessNode;\n+import org.jbpm.workflow.core.node.FaultNode;\n+import org.jbpm.workflow.core.node.ForEachNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.RuleSetNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.SubProcessNode;\n+import org.jbpm.workflow.core.node.TimerNode;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.WorkflowProcess;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory.METHOD_CONNECTION;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_DYNAMIC;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_GLOBAL;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_IMPORTS;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_NAME;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_PACKAGE_NAME;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VALIDATE;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VARIABLE;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VERSION;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VISIBILITY;\n+\n+public class ProcessVisitor extends AbstractVisitor {\n+\n+    public static final String DEFAULT_VERSION = \"1.0\";\n+\n+    private static final String METADATA_HIDDEN = \"hidden\";\n+    private static final String METADATA_UNIQUE_ID = \"UniqueId\";\n+    private static final String METADATA_LINK_NODE_HIDDEN = \"linkNodeHidden\";\n+\n+    private Map<Class<?>, AbstractNodeVisitor> nodesVisitors = new HashMap<>();\n+\n+    public ProcessVisitor(ClassLoader contextClassLoader) {\n+        this.nodesVisitors.put(StartNode.class, new StartNodeVisitor());\n+        this.nodesVisitors.put(ActionNode.class, new ActionNodeVisitor());\n+        this.nodesVisitors.put(EndNode.class, new EndNodeVisitor());\n+        this.nodesVisitors.put(HumanTaskNode.class, new HumanTaskNodeVisitor());\n+        this.nodesVisitors.put(WorkItemNode.class, new WorkItemNodeVisitor(contextClassLoader));\n+        this.nodesVisitors.put(SubProcessNode.class, new LambdaSubProcessNodeVisitor());\n+        this.nodesVisitors.put(Split.class, new SplitNodeVisitor());\n+        this.nodesVisitors.put(Join.class, new JoinNodeVisitor());\n+        this.nodesVisitors.put(FaultNode.class, new FaultNodeVisitor());\n+        this.nodesVisitors.put(RuleSetNode.class, new RuleSetNodeVisitor(contextClassLoader));\n+        this.nodesVisitors.put(BoundaryEventNode.class, new BoundaryEventNodeVisitor());\n+        this.nodesVisitors.put(EventNode.class, new EventNodeVisitor());\n+        this.nodesVisitors.put(ForEachNode.class, new ForEachNodeVisitor(nodesVisitors));\n+        this.nodesVisitors.put(CompositeContextNode.class, new CompositeContextNodeVisitor(nodesVisitors));\n+        this.nodesVisitors.put(EventSubProcessNode.class, new EventSubprocessNodeVisitor(nodesVisitors));\n+        this.nodesVisitors.put(TimerNode.class, new TimerNodeVisitor());\n+    }\n+\n+    public void visitProcess(WorkflowProcess process, MethodDeclaration processMethod, ProcessMetaData metadata) {\n+        BlockStmt body = new BlockStmt();\n+\n+        ClassOrInterfaceType processFactoryType = new ClassOrInterfaceType(null, RuleFlowProcessFactory.class.getSimpleName());\n+\n+        // create local variable factory and assign new fluent process to it\n+        VariableDeclarationExpr factoryField = new VariableDeclarationExpr(processFactoryType, FACTORY_FIELD_NAME);\n+        MethodCallExpr assignFactoryMethod = new MethodCallExpr(new NameExpr(processFactoryType.getName().asString()), \"createProcess\");\n+        assignFactoryMethod.addArgument(new StringLiteralExpr(process.getId()));\n+        body.addStatement(new AssignExpr(factoryField, assignFactoryMethod, AssignExpr.Operator.ASSIGN));\n+\n+        // item definitions\n+        Set<String> visitedVariables = new HashSet<>();\n+        VariableScope variableScope = (VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+\n+        visitVariableScope(variableScope, body, visitedVariables);\n+        visitSubVariableScopes(process.getNodes(), body, visitedVariables);\n+\n+        visitInterfaces(process.getNodes(), body);\n+\n+        // the process itself\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_NAME, new StringLiteralExpr(process.getName()));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_PACKAGE_NAME, new StringLiteralExpr(process.getPackageName()));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_DYNAMIC, new BooleanLiteralExpr(((org.jbpm.workflow.core.WorkflowProcess) process).isDynamic()));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VERSION, new StringLiteralExpr(getOrDefault(process.getVersion(), DEFAULT_VERSION)));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VISIBILITY, new StringLiteralExpr(getOrDefault(process.getVisibility(), WorkflowProcess.PUBLIC_VISIBILITY)));\n+\n+        visitMetaData(process.getMetaData(), body, FACTORY_FIELD_NAME);\n+\n+        visitHeader(process, body);\n+\n+        List<Node> processNodes = new ArrayList<>();\n+        for (org.kie.api.definition.process.Node procNode : process.getNodes()) {\n+            processNodes.add((org.jbpm.workflow.core.Node) procNode);\n+        }\n+        visitNodes(processNodes, body, variableScope, metadata);\n+        visitConnections(process.getNodes(), body);\n+\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VALIDATE);\n+\n+        MethodCallExpr getProcessMethod = new MethodCallExpr(new NameExpr(FACTORY_FIELD_NAME), \"getProcess\");\n+        body.addStatement(new ReturnStmt(getProcessMethod));\n+        processMethod.setBody(body);\n+    }\n+\n+    private void visitVariableScope(VariableScope variableScope, BlockStmt body, Set<String> visitedVariables) {\n+        if (variableScope != null && !variableScope.getVariables().isEmpty()) {\n+            for (Variable variable : variableScope.getVariables()) {\n+\n+                if (!visitedVariables.add(variable.getName())) {\n+                    continue;\n+                }\n+                String tags = (String) variable.getMetaData(Variable.VARIABLE_TAGS);\n+                ClassOrInterfaceType variableType = new ClassOrInterfaceType(null, ObjectDataType.class.getSimpleName());\n+                ObjectCreationExpr variableValue = new ObjectCreationExpr(null, variableType, new NodeList<>(new StringLiteralExpr(variable.getType().getStringType())));\n+                addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VARIABLE, new StringLiteralExpr(variable.getName()), variableValue, new StringLiteralExpr(Variable.VARIABLE_TAGS), tags != null ? new StringLiteralExpr(tags) : new NullLiteralExpr());\n+            }\n+        }\n+    }\n+\n+    private void visitSubVariableScopes(org.kie.api.definition.process.Node[] nodes, BlockStmt body, Set<String> visitedVariables) {\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            if (node instanceof ContextContainer) {\n+                VariableScope variableScope = (VariableScope)\n+                        ((ContextContainer) node).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+                if (variableScope != null) {\n+                    visitVariableScope(variableScope, body, visitedVariables);\n+                }\n+            }\n+            if (node instanceof NodeContainer) {\n+                visitSubVariableScopes(((NodeContainer) node).getNodes(), body, visitedVariables);\n+            }\n+        }\n+    }\n+\n+    private void visitHeader(WorkflowProcess process, BlockStmt body) {\n+        Map<String, Object> metaData = getMetaData(process.getMetaData());\n+        Set<String> imports = ((org.jbpm.process.core.Process) process).getImports();\n+        Map<String, String> globals = ((org.jbpm.process.core.Process) process).getGlobals();\n+        if ((imports != null && !imports.isEmpty()) || (globals != null && globals.size() > 0) || !metaData.isEmpty()) {\n+            if (imports != null) {\n+                for (String s : imports) {\n+                    addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_IMPORTS, new StringLiteralExpr(s));\n+                }\n+            }\n+            if (globals != null) {\n+                for (Map.Entry<String, String> global : globals.entrySet()) {\n+                    addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_GLOBAL, new StringLiteralExpr(global.getKey()), new StringLiteralExpr(global.getValue()));\n+                }\n+            }\n+        }\n+    }\n+\n+    private Map<String, Object> getMetaData(Map<String, Object> input) {\n+        Map<String, Object> metaData = new HashMap<>();\n+        for (Map.Entry<String, Object> entry : input.entrySet()) {\n+            String name = entry.getKey();\n+            if (entry.getKey().startsWith(\"custom\")\n+                    && entry.getValue() instanceof String) {\n+                metaData.put(name, entry.getValue());\n+            }\n+        }\n+        return metaData;\n+    }\n+\n+    private void visitNodes(List<org.jbpm.workflow.core.Node> nodes, BlockStmt body, VariableScope variableScope, ProcessMetaData metadata) {\n+\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            AbstractNodeVisitor visitor = nodesVisitors.get(node.getClass());\n+\n+            if (visitor == null) {\n+                throw new IllegalStateException(\"No visitor found for node \" + node.getClass().getName());\n+            }\n+\n+            visitor.visitNode(node, body, variableScope, metadata);\n+        }\n+    }\n+\n+    private void visitConnections(org.kie.api.definition.process.Node[] nodes, BlockStmt body) {\n+\n+        List<Connection> connections = new ArrayList<>();\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            for (List<Connection> connectionList : node.getIncomingConnections().values()) {\n+                connections.addAll(connectionList);\n+            }\n+        }\n+        for (Connection connection : connections) {\n+            visitConnection(connection, body);\n+        }\n+    }\n+\n+    private void visitInterfaces(org.kie.api.definition.process.Node[] nodes, BlockStmt body) {\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            if (node instanceof WorkItemNode) {\n+                Work work = ((WorkItemNode) node).getWork();\n+                if (work != null) {\n+                    // TODO - finish this method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3MTMxMA==", "bodyText": "Created Jira KOGITO-1882 and added as a comment", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409471310", "createdAt": "2020-04-16T11:05:28Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ProcessVisitor.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.compiler.canonical;\n+\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.LongLiteralExpr;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NullLiteralExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.VariableDeclarationExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.jbpm.process.core.ContextContainer;\n+import org.jbpm.process.core.Work;\n+import org.jbpm.process.core.context.variable.Variable;\n+import org.jbpm.process.core.context.variable.VariableScope;\n+import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n+import org.jbpm.ruleflow.core.RuleFlowProcessFactory;\n+import org.jbpm.workflow.core.Node;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.ConnectionImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.CompositeContextNode;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.EventSubProcessNode;\n+import org.jbpm.workflow.core.node.FaultNode;\n+import org.jbpm.workflow.core.node.ForEachNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.RuleSetNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.SubProcessNode;\n+import org.jbpm.workflow.core.node.TimerNode;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.WorkflowProcess;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory.METHOD_CONNECTION;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_DYNAMIC;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_GLOBAL;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_IMPORTS;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_NAME;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_PACKAGE_NAME;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VALIDATE;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VARIABLE;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VERSION;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VISIBILITY;\n+\n+public class ProcessVisitor extends AbstractVisitor {\n+\n+    public static final String DEFAULT_VERSION = \"1.0\";\n+\n+    private static final String METADATA_HIDDEN = \"hidden\";\n+    private static final String METADATA_UNIQUE_ID = \"UniqueId\";\n+    private static final String METADATA_LINK_NODE_HIDDEN = \"linkNodeHidden\";\n+\n+    private Map<Class<?>, AbstractNodeVisitor> nodesVisitors = new HashMap<>();\n+\n+    public ProcessVisitor(ClassLoader contextClassLoader) {\n+        this.nodesVisitors.put(StartNode.class, new StartNodeVisitor());\n+        this.nodesVisitors.put(ActionNode.class, new ActionNodeVisitor());\n+        this.nodesVisitors.put(EndNode.class, new EndNodeVisitor());\n+        this.nodesVisitors.put(HumanTaskNode.class, new HumanTaskNodeVisitor());\n+        this.nodesVisitors.put(WorkItemNode.class, new WorkItemNodeVisitor(contextClassLoader));\n+        this.nodesVisitors.put(SubProcessNode.class, new LambdaSubProcessNodeVisitor());\n+        this.nodesVisitors.put(Split.class, new SplitNodeVisitor());\n+        this.nodesVisitors.put(Join.class, new JoinNodeVisitor());\n+        this.nodesVisitors.put(FaultNode.class, new FaultNodeVisitor());\n+        this.nodesVisitors.put(RuleSetNode.class, new RuleSetNodeVisitor(contextClassLoader));\n+        this.nodesVisitors.put(BoundaryEventNode.class, new BoundaryEventNodeVisitor());\n+        this.nodesVisitors.put(EventNode.class, new EventNodeVisitor());\n+        this.nodesVisitors.put(ForEachNode.class, new ForEachNodeVisitor(nodesVisitors));\n+        this.nodesVisitors.put(CompositeContextNode.class, new CompositeContextNodeVisitor(nodesVisitors));\n+        this.nodesVisitors.put(EventSubProcessNode.class, new EventSubprocessNodeVisitor(nodesVisitors));\n+        this.nodesVisitors.put(TimerNode.class, new TimerNodeVisitor());\n+    }\n+\n+    public void visitProcess(WorkflowProcess process, MethodDeclaration processMethod, ProcessMetaData metadata) {\n+        BlockStmt body = new BlockStmt();\n+\n+        ClassOrInterfaceType processFactoryType = new ClassOrInterfaceType(null, RuleFlowProcessFactory.class.getSimpleName());\n+\n+        // create local variable factory and assign new fluent process to it\n+        VariableDeclarationExpr factoryField = new VariableDeclarationExpr(processFactoryType, FACTORY_FIELD_NAME);\n+        MethodCallExpr assignFactoryMethod = new MethodCallExpr(new NameExpr(processFactoryType.getName().asString()), \"createProcess\");\n+        assignFactoryMethod.addArgument(new StringLiteralExpr(process.getId()));\n+        body.addStatement(new AssignExpr(factoryField, assignFactoryMethod, AssignExpr.Operator.ASSIGN));\n+\n+        // item definitions\n+        Set<String> visitedVariables = new HashSet<>();\n+        VariableScope variableScope = (VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+\n+        visitVariableScope(variableScope, body, visitedVariables);\n+        visitSubVariableScopes(process.getNodes(), body, visitedVariables);\n+\n+        visitInterfaces(process.getNodes(), body);\n+\n+        // the process itself\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_NAME, new StringLiteralExpr(process.getName()));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_PACKAGE_NAME, new StringLiteralExpr(process.getPackageName()));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_DYNAMIC, new BooleanLiteralExpr(((org.jbpm.workflow.core.WorkflowProcess) process).isDynamic()));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VERSION, new StringLiteralExpr(getOrDefault(process.getVersion(), DEFAULT_VERSION)));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VISIBILITY, new StringLiteralExpr(getOrDefault(process.getVisibility(), WorkflowProcess.PUBLIC_VISIBILITY)));\n+\n+        visitMetaData(process.getMetaData(), body, FACTORY_FIELD_NAME);\n+\n+        visitHeader(process, body);\n+\n+        List<Node> processNodes = new ArrayList<>();\n+        for (org.kie.api.definition.process.Node procNode : process.getNodes()) {\n+            processNodes.add((org.jbpm.workflow.core.Node) procNode);\n+        }\n+        visitNodes(processNodes, body, variableScope, metadata);\n+        visitConnections(process.getNodes(), body);\n+\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VALIDATE);\n+\n+        MethodCallExpr getProcessMethod = new MethodCallExpr(new NameExpr(FACTORY_FIELD_NAME), \"getProcess\");\n+        body.addStatement(new ReturnStmt(getProcessMethod));\n+        processMethod.setBody(body);\n+    }\n+\n+    private void visitVariableScope(VariableScope variableScope, BlockStmt body, Set<String> visitedVariables) {\n+        if (variableScope != null && !variableScope.getVariables().isEmpty()) {\n+            for (Variable variable : variableScope.getVariables()) {\n+\n+                if (!visitedVariables.add(variable.getName())) {\n+                    continue;\n+                }\n+                String tags = (String) variable.getMetaData(Variable.VARIABLE_TAGS);\n+                ClassOrInterfaceType variableType = new ClassOrInterfaceType(null, ObjectDataType.class.getSimpleName());\n+                ObjectCreationExpr variableValue = new ObjectCreationExpr(null, variableType, new NodeList<>(new StringLiteralExpr(variable.getType().getStringType())));\n+                addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VARIABLE, new StringLiteralExpr(variable.getName()), variableValue, new StringLiteralExpr(Variable.VARIABLE_TAGS), tags != null ? new StringLiteralExpr(tags) : new NullLiteralExpr());\n+            }\n+        }\n+    }\n+\n+    private void visitSubVariableScopes(org.kie.api.definition.process.Node[] nodes, BlockStmt body, Set<String> visitedVariables) {\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            if (node instanceof ContextContainer) {\n+                VariableScope variableScope = (VariableScope)\n+                        ((ContextContainer) node).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+                if (variableScope != null) {\n+                    visitVariableScope(variableScope, body, visitedVariables);\n+                }\n+            }\n+            if (node instanceof NodeContainer) {\n+                visitSubVariableScopes(((NodeContainer) node).getNodes(), body, visitedVariables);\n+            }\n+        }\n+    }\n+\n+    private void visitHeader(WorkflowProcess process, BlockStmt body) {\n+        Map<String, Object> metaData = getMetaData(process.getMetaData());\n+        Set<String> imports = ((org.jbpm.process.core.Process) process).getImports();\n+        Map<String, String> globals = ((org.jbpm.process.core.Process) process).getGlobals();\n+        if ((imports != null && !imports.isEmpty()) || (globals != null && globals.size() > 0) || !metaData.isEmpty()) {\n+            if (imports != null) {\n+                for (String s : imports) {\n+                    addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_IMPORTS, new StringLiteralExpr(s));\n+                }\n+            }\n+            if (globals != null) {\n+                for (Map.Entry<String, String> global : globals.entrySet()) {\n+                    addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_GLOBAL, new StringLiteralExpr(global.getKey()), new StringLiteralExpr(global.getValue()));\n+                }\n+            }\n+        }\n+    }\n+\n+    private Map<String, Object> getMetaData(Map<String, Object> input) {\n+        Map<String, Object> metaData = new HashMap<>();\n+        for (Map.Entry<String, Object> entry : input.entrySet()) {\n+            String name = entry.getKey();\n+            if (entry.getKey().startsWith(\"custom\")\n+                    && entry.getValue() instanceof String) {\n+                metaData.put(name, entry.getValue());\n+            }\n+        }\n+        return metaData;\n+    }\n+\n+    private void visitNodes(List<org.jbpm.workflow.core.Node> nodes, BlockStmt body, VariableScope variableScope, ProcessMetaData metadata) {\n+\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            AbstractNodeVisitor visitor = nodesVisitors.get(node.getClass());\n+\n+            if (visitor == null) {\n+                throw new IllegalStateException(\"No visitor found for node \" + node.getClass().getName());\n+            }\n+\n+            visitor.visitNode(node, body, variableScope, metadata);\n+        }\n+    }\n+\n+    private void visitConnections(org.kie.api.definition.process.Node[] nodes, BlockStmt body) {\n+\n+        List<Connection> connections = new ArrayList<>();\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            for (List<Connection> connectionList : node.getIncomingConnections().values()) {\n+                connections.addAll(connectionList);\n+            }\n+        }\n+        for (Connection connection : connections) {\n+            visitConnection(connection, body);\n+        }\n+    }\n+\n+    private void visitInterfaces(org.kie.api.definition.process.Node[] nodes, BlockStmt body) {\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            if (node instanceof WorkItemNode) {\n+                Work work = ((WorkItemNode) node).getWork();\n+                if (work != null) {\n+                    // TODO - finish this method", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwNjg1MA=="}, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTI3Mjk0OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/DynamicNodeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyMjo0NFrOGGWPDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyMjo0NFrOGGWPDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwODk0Mw==", "bodyText": "formatting seems a bit off from here", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409308943", "createdAt": "2020-04-16T06:22:44Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/DynamicNodeFactory.java", "diffHunk": "@@ -16,111 +16,90 @@\n \n package org.jbpm.ruleflow.core.factory;\n \n-import org.jbpm.process.core.datatype.DataType;\n-import org.jbpm.process.core.context.exception.ActionExceptionHandler;\n import org.jbpm.process.core.context.exception.ExceptionHandler;\n-import org.jbpm.process.core.context.exception.ExceptionScope;\n-import org.jbpm.process.core.context.variable.Variable;\n-import org.jbpm.process.core.context.variable.VariableScope;\n+import org.jbpm.process.core.datatype.DataType;\n import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n-import org.jbpm.workflow.core.Node;\n import org.jbpm.workflow.core.NodeContainer;\n-import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n import org.jbpm.workflow.core.node.CompositeContextNode;\n import org.jbpm.workflow.core.node.DynamicNode;\n \n /**\n  *\n  */\n-public class DynamicNodeFactory extends RuleFlowNodeContainerFactory {\n+public class DynamicNodeFactory extends CompositeContextNodeFactory {\n \n-\tprivate RuleFlowNodeContainerFactory nodeContainerFactory;\n-\tprivate NodeContainer nodeContainer;\n-\tprivate long linkedIncomingNodeId = -1;\n-\tprivate long linkedOutgoingNodeId = -1;\n-\t\n     public DynamicNodeFactory(RuleFlowNodeContainerFactory nodeContainerFactory, NodeContainer nodeContainer, long id) {\n-    \tthis.nodeContainerFactory = nodeContainerFactory;\n-    \tthis.nodeContainer = nodeContainer;\n-    \tDynamicNode compositeNode = new DynamicNode();\n-        compositeNode.setId(id);\n-        setNodeContainer(compositeNode);\n-    }\n-    \n-    protected CompositeContextNode getCompositeNode() {\n-    \treturn (CompositeContextNode) getNodeContainer();\n+    \tsuper(nodeContainerFactory, nodeContainer, id);\n     }\n-    \n+\n+    @Override\n+    protected CompositeContextNode createNode() {\n+    \treturn new DynamicNode();\n+\t}\n+\n     protected DynamicNode getDynamicNode() {\n     \treturn (DynamicNode) getNodeContainer();\n     }\n \n+\t@Override\n+\tprotected CompositeContextNode getCompositeNode() {\n+\t\treturn (CompositeContextNode) getNodeContainer();\n+\t}\n+\n+    @Override\n     public DynamicNodeFactory variable(String name, DataType type) {\n-    \treturn variable(name, type, null);\n+    \tsuper.variable(name, type);\n+    \treturn this;\n     }\n-    \n+\n+    @Override\n     public DynamicNodeFactory variable(String name, DataType type, Object value) {\n-    \tVariable variable = new Variable();\n-    \tvariable.setName(name);\n-    \tvariable.setType(type);\n-    \tvariable.setValue(value);\n-    \tVariableScope variableScope = (VariableScope)\n-\t\t\tgetCompositeNode().getDefaultContext(VariableScope.VARIABLE_SCOPE);\n-\t\tif (variableScope == null) {\n-\t\t\tvariableScope = new VariableScope();\n-\t\t\tgetCompositeNode().addContext(variableScope);\n-\t\t\tgetCompositeNode().setDefaultContext(variableScope);\n-\t\t}\n-\t\tvariableScope.getVariables().add(variable);\n-        return this;\n+    \tsuper.variable(name, type, value);\n+    \treturn this;\n     }\n-    \n+\n+    @Override\n     public DynamicNodeFactory exceptionHandler(String exception, ExceptionHandler exceptionHandler) {\n-    \tExceptionScope exceptionScope = (ExceptionScope)\n-\t\t\tgetCompositeNode().getDefaultContext(ExceptionScope.EXCEPTION_SCOPE);\n-\t\tif (exceptionScope == null) {\n-\t\t\texceptionScope = new ExceptionScope();\n-\t\t\tgetCompositeNode().addContext(exceptionScope);\n-\t\t\tgetCompositeNode().setDefaultContext(exceptionScope);\n-\t\t}\n-\t\texceptionScope.setExceptionHandler(exception, exceptionHandler);\n+    \tsuper.exceptionHandler(exception, exceptionHandler);\n     \treturn this;\n     }\n-    \n+\n+    @Override\n     public DynamicNodeFactory exceptionHandler(String exception, String dialect, String action) {\n-    \tActionExceptionHandler exceptionHandler = new ActionExceptionHandler();\n-    \texceptionHandler.setAction(new DroolsConsequenceAction(dialect, action));\n-    \treturn exceptionHandler(exception, exceptionHandler);\n+    \tsuper.exceptionHandler(exception, dialect, action);\n+    \treturn this;\n     }\n-    \n+\n+    @Override\n     public DynamicNodeFactory autoComplete(boolean autoComplete) {\n-    \tgetDynamicNode().setAutoComplete(autoComplete);\n+    \tsuper.autoComplete(autoComplete);\n     \treturn this;\n     }\n-    \n+\n+    @Override\n     public DynamicNodeFactory linkIncomingConnections(long nodeId) {\n-    \tthis.linkedIncomingNodeId = nodeId;\n+    \tsuper.linkIncomingConnections(nodeId);\n         return this;\n     }\n \n+\t@Override\n     public DynamicNodeFactory linkOutgoingConnections(long nodeId) {\n-    \tthis.linkedOutgoingNodeId = nodeId;\n+    \tsuper.linkOutgoingConnections(nodeId);\n     \treturn this;\n     }\n \n-    public RuleFlowNodeContainerFactory done() {\n-    \tif (linkedIncomingNodeId != -1) {\n-    \t\tgetCompositeNode().linkIncomingConnections(\n-\t\t\t\tNode.CONNECTION_DEFAULT_TYPE,\n-\t\t        linkedIncomingNodeId, Node.CONNECTION_DEFAULT_TYPE);\n-    \t}\n-    \tif (linkedOutgoingNodeId != -1) {\n-    \t\tgetCompositeNode().linkOutgoingConnections(\n-\t\t\t\tlinkedOutgoingNodeId, Node.CONNECTION_DEFAULT_TYPE,\n-\t            Node.CONNECTION_DEFAULT_TYPE);\n-    \t}\n-        nodeContainer.addNode(getCompositeNode());\n-        return nodeContainerFactory;\n-    }\n+    public DynamicNodeFactory language(String language) {\n+    \tgetDynamicNode().setLanguage(language);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTI3NjczOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/ExtendedNodeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyNDowMVrOGGWRNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyNDowMVrOGGWRNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwOTQ5Mg==", "bodyText": "could be removed or documented? :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409309492", "createdAt": "2020-04-16T06:24:01Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/ExtendedNodeFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.ruleflow.core.factory;\n+\n+import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTI3NzQwOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/ExtendedNodeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyNDoxOVrOGGWRng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyNDoxOVrOGGWRng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwOTU5OA==", "bodyText": "can we remove these extra lines?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409309598", "createdAt": "2020-04-16T06:24:19Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/ExtendedNodeFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.ruleflow.core.factory;\n+\n+import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ *\n+ */\n+public abstract class ExtendedNodeFactory extends NodeFactory {\n+\n+    protected static final String METADATA_ACTION = \"Action\";\n+\n+    protected ExtendedNodeFactory(RuleFlowNodeContainerFactory nodeContainerFactory, NodeContainer nodeContainer, long id) {\n+        super(nodeContainerFactory, nodeContainer, id);\n+    }\n+\n+    protected ExtendedNodeImpl getExtendedNode() {\n+        return (ExtendedNodeImpl) getNode();\n+    }\n+\n+    public ExtendedNodeFactory onEntryAction(String dialect, String action) {\n+        if (getExtendedNode().getActions(dialect) != null) {\n+            getExtendedNode().getActions(dialect).add(new DroolsConsequenceAction(dialect, action));\n+        } else {\n+            List<DroolsAction> actions = new ArrayList<>();\n+            actions.add(new DroolsConsequenceAction(dialect, action));\n+            getExtendedNode().setActions(ExtendedNodeImpl.EVENT_NODE_ENTER, actions);\n+        }\n+        return this;\n+    }\n+\n+    public ExtendedNodeFactory onExitAction(String dialect, String action) {\n+        if (getExtendedNode().getActions(dialect) != null) {\n+            getExtendedNode().getActions(dialect).add(new DroolsConsequenceAction(dialect, action));\n+        } else {\n+            List<DroolsAction> actions = new ArrayList<>();\n+            actions.add(new DroolsConsequenceAction(dialect, action));\n+            getExtendedNode().setActions(ExtendedNodeImpl.EVENT_NODE_EXIT, actions);\n+        }\n+        return this;\n+    }\n+}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTI4MDg3OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/MappableNodeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyNTo0OVrOGGWTyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyNTo0OVrOGGWTyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMDE1Mg==", "bodyText": "no need for public static final", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409310152", "createdAt": "2020-04-16T06:25:49Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/MappableNodeFactory.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.ruleflow.core.factory;\n+\n+import org.jbpm.process.core.context.variable.Mappable;\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+\n+/**\n+ *\n+ */\n+public interface MappableNodeFactory {\n+\n+    String METHOD_IN_MAPPING = \"inMapping\";\n+    public static final String METHOD_OUT_MAPPING = \"outMapping\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTI4MTcyOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/MappableNodeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyNjowNlrOGGWUSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyNjowNlrOGGWUSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMDI4MQ==", "bodyText": "same here to remove.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409310281", "createdAt": "2020-04-16T06:26:06Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/MappableNodeFactory.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.ruleflow.core.factory;\n+\n+import org.jbpm.process.core.context.variable.Mappable;\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTI4MjExOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/MappableNodeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyNjoxM1rOGGWUfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyNjoxM1rOGGWUfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMDMzMw==", "bodyText": "and here :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409310333", "createdAt": "2020-04-16T06:26:13Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/MappableNodeFactory.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.ruleflow.core.factory;\n+\n+import org.jbpm.process.core.context.variable.Mappable;\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+\n+/**\n+ *\n+ */\n+public interface MappableNodeFactory {\n+\n+    String METHOD_IN_MAPPING = \"inMapping\";\n+    public static final String METHOD_OUT_MAPPING = \"outMapping\";\n+\n+    Mappable getMappableNode();\n+\n+    default MappableNodeFactory inMapping(String parameterName, String variableName) {\n+        getMappableNode().addInMapping(parameterName, variableName);\n+        return this;\n+    }\n+\n+    default MappableNodeFactory outMapping(String parameterName, String variableName) {\n+        getMappableNode().addOutMapping(parameterName, variableName);\n+        return this;\n+    }\n+}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTI4NzQyOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessCodegen.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyODoxOFrOGGWXqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyODoxOFrOGGWXqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMTE0NQ==", "bodyText": "perhaps rename to SUPPORTED_SW_EXTENSIONS ?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409311145", "createdAt": "2020-04-16T06:28:18Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessCodegen.java", "diffHunk": "@@ -81,6 +82,10 @@\n     private static final Logger LOGGER = LoggerFactory.getLogger(ProcessCodegen.class);\n \n     private static final SemanticModules BPMN_SEMANTIC_MODULES = new SemanticModules();\n+    private static final Set<String> SUPPORTED_BPMN_EXTENSIONS = Collections.unmodifiableSet(Set.of(\".bpmn\", \".bpmn2\"));\n+    private static final String YAML_PARSER = \"yml\";\n+    private static final String JSON_PARSER = \"json\";\n+    private static final Map<String, String> SUPPORTED_WORKFLOW_EXTENSIONS = Map.of(\".sw.yml\", YAML_PARSER, \".sw.yaml\", YAML_PARSER, \".sw.json\", JSON_PARSER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTI4ODQ3OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoyODo0MVrOGGWYSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMDo0NzoxNVrOGGfi1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMTMwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n          \n          \n            \n             * Copyright 2020 Red Hat, Inc. and/or its affiliates.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409311307", "createdAt": "2020-04-16T06:28:41Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MTQ2MA==", "bodyText": "Already in the parent PR", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409461460", "createdAt": "2020-04-16T10:47:15Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMTMwNw=="}, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTI5MzY0OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjozMDo0MVrOGGWbbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMDo0Njo1OFrOGGfiMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMjEwOQ==", "bodyText": "same comment as in the other PR, to make each file the parametrized test, and findining the files dinamically so every new resource is included by default.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409312109", "createdAt": "2020-04-16T06:30:41Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.CompositeNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed processes in process-generation folder files\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final String TEST_FILE_PATH = \"src/test/resources/org/kie/kogito/codegen/process-generation/%s.txt\";\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"businessruleunit\", \"decision\", \"event-subprocess\",\n+            \"gateway\", \"messageevent\", \"messagestartevent\", \"ruletask\", \"servicetask\",\n+            \"signalevent\", \"subprocess\", \"timer\", \"usertask\", \"serverless\"})\n+    public void testProcessesGeneration(String fileName) throws IOException {\n+        Files.lines(Paths.get(String.format(TEST_FILE_PATH, fileName)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MTI5Nw==", "bodyText": "Yes, this will be there once rebased", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409461297", "createdAt": "2020-04-16T10:46:58Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.CompositeNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed processes in process-generation folder files\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final String TEST_FILE_PATH = \"src/test/resources/org/kie/kogito/codegen/process-generation/%s.txt\";\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"businessruleunit\", \"decision\", \"event-subprocess\",\n+            \"gateway\", \"messageevent\", \"messagestartevent\", \"ruletask\", \"servicetask\",\n+            \"signalevent\", \"subprocess\", \"timer\", \"usertask\", \"serverless\"})\n+    public void testProcessesGeneration(String fileName) throws IOException {\n+        Files.lines(Paths.get(String.format(TEST_FILE_PATH, fileName)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMjEwOQ=="}, "originalCommit": {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Njg2OTEwOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/CompositeContextNodeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjo1MDowOVrOGHMoYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjo1MDowOVrOGHMoYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIwMDE2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n          \n          \n            \n             * Copyright 2020 Red Hat, Inc. and/or its affiliates.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r410200163", "createdAt": "2020-04-17T12:50:09Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/CompositeContextNodeFactory.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18827b763810b049fe848b629ee4ae5c1922a869"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 218, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}