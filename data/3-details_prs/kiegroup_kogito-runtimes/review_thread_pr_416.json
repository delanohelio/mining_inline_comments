{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MjUwODIz", "number": 416, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoxODoxNlrODvuaYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjozODo1M1rODye35g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzcwMDgwOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoxODoxNlrOGCUfag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzo1ODozN1rOGCwlfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NjA1OA==", "bodyText": "I think you can use the already defined method on AbstractVisitor, \n  \n    \n      kogito-runtimes/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/AbstractVisitor.java\n    \n    \n         Line 163\n      in\n      e785096\n    \n    \n    \n    \n\n        \n          \n           protected void addNodeMappings(Mappable node, BlockStmt body, String variableName) { \n        \n    \n  \n\n\nBut it is at least strange the things are working without this mapping... and probably it would be necessary on other visitors like EventNode, EndNode, etc... WDYT?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405086058", "createdAt": "2020-04-07T20:18:16Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -51,7 +51,7 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n-        \n+        startNode.getOutMappings().forEach((k, v) -> addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"addOutMapping\", new StringLiteralExpr(k), new StringLiteralExpr(v)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM2ODE4Nw==", "bodyText": "Actually I had to rollback the change because the getInMappings method for StartNode throws an IllegalArgumentException", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405368187", "createdAt": "2020-04-08T09:00:26Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -51,7 +51,7 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n-        \n+        startNode.getOutMappings().forEach((k, v) -> addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"addOutMapping\", new StringLiteralExpr(k), new StringLiteralExpr(v)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NjA1OA=="}, "originalCommit": {"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0NjM2Nw==", "bodyText": "After our discussion I changed it back again and the StartNode don't throw exceptions for getters only for setters.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405546367", "createdAt": "2020-04-08T13:58:37Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -51,7 +51,7 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n-        \n+        startNode.getOutMappings().forEach((k, v) -> addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"addOutMapping\", new StringLiteralExpr(k), new StringLiteralExpr(v)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NjA1OA=="}, "originalCommit": {"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzc0MTI4OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/StartNodeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoyOTozNVrOGCU4VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoyOTozNVrOGCU4VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MjQzNw==", "bodyText": "you can follow the same name pattern for other NodeFactories, like HumanTaskNodeFactory.outMapping.. but as I said on the other comment why this call was not necessary for other nodes, like EventNode, EndNode, etc...", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405092437", "createdAt": "2020-04-07T20:29:35Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/StartNodeFactory.java", "diffHunk": "@@ -50,6 +50,11 @@ public StartNodeFactory interrupting(boolean interrupting) {\n         getStartNode().setInterrupting(interrupting);\n         return this;\n     }\n+\n+    public StartNodeFactory addOutMapping(String parameterName, String variableName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzc0NDkyOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDozMDo0NFrOGCU6uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDozMDo0NFrOGCU6uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MzA1MQ==", "bodyText": "maybe a simple javadoc comment to explain the purpose of the class...", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405093051", "createdAt": "2020-04-07T20:30:44Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.assertj.core.api.ThrowableAssert;\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.*;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ProcessGenerationTest extends AbstractCodegenTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMjM4NzY0OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzowMjo0MVrOGFAzhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODozNzoxN1rOGFviBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwOTI1NA==", "bodyText": "we had to revert to JDK 8 compatibility on 0.9.x branch. We will merge this back on master too. This is therefore not a valid method call.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r407909254", "createdAt": "2020-04-14T07:02:41Z", "author": {"login": "evacchi"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -97,12 +97,12 @@ public RuleFlowProcessFactory packageName(String packageName) {\n     }\n \n     public RuleFlowProcessFactory imports(String... imports) {\n-    \tgetRuleFlowProcess().setImports(new HashSet<String>(Arrays.asList(imports)));\n+        getRuleFlowProcess().getImports().addAll(Set.of(imports));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a2e041f43c979b5952acc8a4a274e5292206ac4"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3NDgyMQ==", "bodyText": "Done, thanks", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408674821", "createdAt": "2020-04-15T08:37:17Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -97,12 +97,12 @@ public RuleFlowProcessFactory packageName(String packageName) {\n     }\n \n     public RuleFlowProcessFactory imports(String... imports) {\n-    \tgetRuleFlowProcess().setImports(new HashSet<String>(Arrays.asList(imports)));\n+        getRuleFlowProcess().getImports().addAll(Set.of(imports));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwOTI1NA=="}, "originalCommit": {"oid": "9a2e041f43c979b5952acc8a4a274e5292206ac4"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzQ5OTQzOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo0MjoxM1rOGFx6yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMToxMDo0MVrOGF03lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMzkzMA==", "bodyText": "Probably would be nicer to have a dedicated addAll() method for this as adding something using getters may be considered as bad practice. But if we cannot/don't want to change the interfaces, I'm fine with that.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408713930", "createdAt": "2020-04-15T09:42:13Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -97,12 +97,12 @@ public RuleFlowProcessFactory packageName(String packageName) {\n     }\n \n     public RuleFlowProcessFactory imports(String... imports) {\n-    \tgetRuleFlowProcess().setImports(new HashSet<String>(Arrays.asList(imports)));\n+        getRuleFlowProcess().getImports().addAll(Arrays.asList(imports));\n         return this;\n     }\n     \n     public RuleFlowProcessFactory functionImports(String... functionImports) {\n-    \tgetRuleFlowProcess().setFunctionImports(Arrays.asList(functionImports));\n+        getRuleFlowProcess().getFunctionImports().addAll(Arrays.asList(functionImports));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MjI2MQ==", "bodyText": "Added", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408762261", "createdAt": "2020-04-15T11:10:41Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -97,12 +97,12 @@ public RuleFlowProcessFactory packageName(String packageName) {\n     }\n \n     public RuleFlowProcessFactory imports(String... imports) {\n-    \tgetRuleFlowProcess().setImports(new HashSet<String>(Arrays.asList(imports)));\n+        getRuleFlowProcess().getImports().addAll(Arrays.asList(imports));\n         return this;\n     }\n     \n     public RuleFlowProcessFactory functionImports(String... functionImports) {\n-    \tgetRuleFlowProcess().setFunctionImports(Arrays.asList(functionImports));\n+        getRuleFlowProcess().getFunctionImports().addAll(Arrays.asList(functionImports));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMzkzMA=="}, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzU3MTYyOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowMDo1M1rOGFynIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowMDo1M1rOGFynIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTI4Mw==", "bodyText": "Gereration -> Generation :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408725283", "createdAt": "2020-04-15T10:00:53Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzU3MzQ5OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowMToyM1rOGFyoMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMTowNzoyMVrOGF0xAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTU1NA==", "bodyText": "This will be implemented in the future? If so, we can link a JIRA here so we won't forget.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408725554", "createdAt": "2020-04-15T10:01:23Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MDU3Ng==", "bodyText": "I'll add a different assertion", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408760576", "createdAt": "2020-04-15T11:07:21Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTU1NA=="}, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzU3NDAwOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowMTozM1rOGFyoig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo1MDoyMVrOGGAQ8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTY0Mg==", "bodyText": "Same for these.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408725642", "createdAt": "2020-04-15T10:01:33Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODk3Nw==", "bodyText": "implemented assertion", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408948977", "createdAt": "2020-04-15T15:50:21Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTY0Mg=="}, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzU4NTI3OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowNDozNlrOGFyvgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo1MDozMFrOGGARaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNzQyNA==", "bodyText": "Maybe an improvement - assert also the size of the maps? This way it will be sure that there is nothing redundant on the current side.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408727424", "createdAt": "2020-04-15T10:04:36Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0OTA5Nw==", "bodyText": "done!", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408949097", "createdAt": "2020-04-15T15:50:30Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNzQyNA=="}, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzU5NzYyOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowNzo1OVrOGFy3Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowNzo1OVrOGFy3Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyOTM4Ng==", "bodyText": "Same here.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408729386", "createdAt": "2020-04-15T10:07:59Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzU5OTgyOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowODozNFrOGFy4dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowODozNFrOGFy4dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyOTcxNg==", "bodyText": "Formatting here.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408729716", "createdAt": "2020-04-15T10:08:34Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) ignoredKeys = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 316}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzYwMzA3OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDowOToyMlrOGFy6VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo1MTozNFrOGGAUVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMDE5Ng==", "bodyText": "Again probably asserting on the size would be beneficial?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408730196", "createdAt": "2020-04-15T10:09:22Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0OTg0NQ==", "bodyText": "done too", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408949845", "createdAt": "2020-04-15T15:51:34Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMDE5Ng=="}, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 310}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzYwODczOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDoxMTowMVrOGFy9yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0MjoxNVrOGHDVeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMTA4Mw==", "bodyText": "@evacchi probably?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408731083", "createdAt": "2020-04-15T10:11:01Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) ignoredKeys = new HashSet<>();\n+        expected.keySet()\n+                .stream()\n+                .filter(Predicate.not(ignoredKeys::contains))\n+                .forEach(k -> assertEquals(expected.get(k), current.get(k), \"Metadata \"+ k));\n+    }\n+\n+    private static void assertConnections(Map<String, List<Connection>> expectedConnections, Map<String, List<Connection>> currentConnections) {\n+        assertEquals(expectedConnections.size(), currentConnections.size());\n+        expectedConnections.forEach((type, expectedByType) -> {\n+            assertTrue(currentConnections.containsKey(type), \"Node does not have connections of type: \" + type);\n+            List<Connection> currentByType = currentConnections.get(type);\n+            expectedByType.forEach(expected -> {\n+                Optional<Connection> current = currentByType\n+                        .stream()\n+                        .filter(c -> expected.getMetaData().isEmpty() || expected.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\")))\n+                        .findFirst();\n+                assertTrue(current.isPresent(), \"Connection is present for \" + expected.getMetaData().get(\"UniqueId\"));\n+                assertEquals(expected.getFromType(), current.get().getFromType(), \"FromType\");\n+                assertEquals(expected.getFrom().getId(), current.get().getFrom().getId(), \"From.Id\");\n+                assertEquals(expected.getToType(), current.get().getToType(), \"ToType\");\n+                assertEquals(expected.getTo().getId(), current.get().getTo().getId(), \"To.Id\");\n+            });\n+        });\n+    }\n+\n+    private static void assertTriggers(List<Trigger> expected, List<Trigger> current) {\n+        try {\n+            if (expected == null) {\n+                assertNull(current);\n+                return;\n+            }\n+            assertNotNull(current);\n+            assertEquals(expected.size(), current.size());\n+            for (int i = 0; i < expected.size(); i++) {\n+                Trigger e = expected.get(i);\n+                Trigger c = current.get(i);\n+                e.getInMappings().forEach((k, v) -> assertEquals(v, c.getInMapping(k), \"InMapping for \" + k));\n+                assertDataAssociations(e.getInAssociations(), c.getInAssociations());\n+            }\n+        } catch (Throwable e) {\n+            fail(\"Triggers are not equal\", e);\n+        }\n+    }\n+\n+    private static void assertDataAssociations(List<DataAssociation> expected, List<DataAssociation> current) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        if (expected.isEmpty()) {\n+            assertEquals(1, current.size());\n+            assertEquals(1, current.get(0).getSources().size());\n+            assertEquals(\"\", current.get(0).getSources().get(0));\n+        } else {\n+            assertEquals(expected.size(), current.size());\n+            for (int i = 0; i < expected.size(); i++) {\n+                assertEquals(expected.get(i).getSources(), current.get(i).getSources(), \"Sources\");\n+                assertEquals(expected.get(i).getTarget(), current.get(i).getTarget(), \"Target\");\n+                assertEquals(expected.get(i).getTransformation(), current.get(i).getTransformation(), \"Transformation\");\n+                assertAssignments(expected.get(i).getAssignments(), current.get(i).getAssignments());\n+            }\n+        }\n+    }\n+\n+    private static void assertActions(List<DroolsAction> expected, List<DroolsAction> current) {\n+        assertEquals(expected.size(), current.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            assertEquals(((DroolsConsequenceAction) expected.get(i)).getDialect(), ((DroolsConsequenceAction) current.get(i)).getDialect(), \"Dialect\");\n+            assertEquals(((DroolsConsequenceAction) expected.get(i)).getConsequence(), ((DroolsConsequenceAction) current.get(i)).getConsequence(), \"Consequence\");\n+        }\n+    }\n+\n+    private static void assertAssignments(List<Assignment> expected, List<Assignment> current) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertEquals(expected.size(), current.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            assertEquals(expected.get(i).getFrom(), current.get(i).getFrom(), \"From\");\n+            assertEquals(expected.get(i).getDialect(), current.get(i).getDialect(), \"Dialect\");\n+            assertEquals(expected.get(i).getTo(), current.get(i).getTo(), \"To\");\n+        }\n+    }\n+\n+    private static void assertTimers(Map<Timer, DroolsAction> expected, Map<Timer, DroolsAction> current) {\n+        if(expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        assertEquals(expected.size(), current.size(), \"Size\");\n+        expected.forEach((expectedTimer, expectedAction) -> {\n+            Optional<Timer> currentTimer = current.keySet().stream().filter(c -> c.getId() == expectedTimer.getId()).findFirst();\n+            assertTrue(currentTimer.isPresent());\n+            assertEquals(expectedTimer.getPeriod(), currentTimer.get().getPeriod(), \"Period\");\n+            assertEquals(expectedTimer.getDate(), currentTimer.get().getDate(), \"Date\");\n+            assertEquals(expectedTimer.getDelay(), currentTimer.get().getDelay(), \"Delay\");\n+            assertEquals(expectedTimer.getTimeType(), currentTimer.get().getTimeType(), \"TimeType\");\n+            DroolsAction currentAction = current.get(currentTimer.get());\n+            if(expectedAction == null) {\n+                assertNull(currentAction);\n+                return;\n+            }\n+            assertNotNull(currentAction);\n+            assertEquals(expectedAction.getName(), currentAction.getName(), \"DroolsAction name\");\n+            //TODO: Is this expected? They are totally different objects. Expected DroolsConsequenceAction, Got lambda\n+            // assertEquals(expectedAction.getMetaData(DroolsAction.METADATA_ACTION), currentAction.getMetaData(DroolsAction.METADATA_ACTION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzNDExOQ==", "bodyText": "IIRC it used to be a lambda of type DroolsAction", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r410034119", "createdAt": "2020-04-17T07:12:27Z", "author": {"login": "evacchi"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) ignoredKeys = new HashSet<>();\n+        expected.keySet()\n+                .stream()\n+                .filter(Predicate.not(ignoredKeys::contains))\n+                .forEach(k -> assertEquals(expected.get(k), current.get(k), \"Metadata \"+ k));\n+    }\n+\n+    private static void assertConnections(Map<String, List<Connection>> expectedConnections, Map<String, List<Connection>> currentConnections) {\n+        assertEquals(expectedConnections.size(), currentConnections.size());\n+        expectedConnections.forEach((type, expectedByType) -> {\n+            assertTrue(currentConnections.containsKey(type), \"Node does not have connections of type: \" + type);\n+            List<Connection> currentByType = currentConnections.get(type);\n+            expectedByType.forEach(expected -> {\n+                Optional<Connection> current = currentByType\n+                        .stream()\n+                        .filter(c -> expected.getMetaData().isEmpty() || expected.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\")))\n+                        .findFirst();\n+                assertTrue(current.isPresent(), \"Connection is present for \" + expected.getMetaData().get(\"UniqueId\"));\n+                assertEquals(expected.getFromType(), current.get().getFromType(), \"FromType\");\n+                assertEquals(expected.getFrom().getId(), current.get().getFrom().getId(), \"From.Id\");\n+                assertEquals(expected.getToType(), current.get().getToType(), \"ToType\");\n+                assertEquals(expected.getTo().getId(), current.get().getTo().getId(), \"To.Id\");\n+            });\n+        });\n+    }\n+\n+    private static void assertTriggers(List<Trigger> expected, List<Trigger> current) {\n+        try {\n+            if (expected == null) {\n+                assertNull(current);\n+                return;\n+            }\n+            assertNotNull(current);\n+            assertEquals(expected.size(), current.size());\n+            for (int i = 0; i < expected.size(); i++) {\n+                Trigger e = expected.get(i);\n+                Trigger c = current.get(i);\n+                e.getInMappings().forEach((k, v) -> assertEquals(v, c.getInMapping(k), \"InMapping for \" + k));\n+                assertDataAssociations(e.getInAssociations(), c.getInAssociations());\n+            }\n+        } catch (Throwable e) {\n+            fail(\"Triggers are not equal\", e);\n+        }\n+    }\n+\n+    private static void assertDataAssociations(List<DataAssociation> expected, List<DataAssociation> current) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        if (expected.isEmpty()) {\n+            assertEquals(1, current.size());\n+            assertEquals(1, current.get(0).getSources().size());\n+            assertEquals(\"\", current.get(0).getSources().get(0));\n+        } else {\n+            assertEquals(expected.size(), current.size());\n+            for (int i = 0; i < expected.size(); i++) {\n+                assertEquals(expected.get(i).getSources(), current.get(i).getSources(), \"Sources\");\n+                assertEquals(expected.get(i).getTarget(), current.get(i).getTarget(), \"Target\");\n+                assertEquals(expected.get(i).getTransformation(), current.get(i).getTransformation(), \"Transformation\");\n+                assertAssignments(expected.get(i).getAssignments(), current.get(i).getAssignments());\n+            }\n+        }\n+    }\n+\n+    private static void assertActions(List<DroolsAction> expected, List<DroolsAction> current) {\n+        assertEquals(expected.size(), current.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            assertEquals(((DroolsConsequenceAction) expected.get(i)).getDialect(), ((DroolsConsequenceAction) current.get(i)).getDialect(), \"Dialect\");\n+            assertEquals(((DroolsConsequenceAction) expected.get(i)).getConsequence(), ((DroolsConsequenceAction) current.get(i)).getConsequence(), \"Consequence\");\n+        }\n+    }\n+\n+    private static void assertAssignments(List<Assignment> expected, List<Assignment> current) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertEquals(expected.size(), current.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            assertEquals(expected.get(i).getFrom(), current.get(i).getFrom(), \"From\");\n+            assertEquals(expected.get(i).getDialect(), current.get(i).getDialect(), \"Dialect\");\n+            assertEquals(expected.get(i).getTo(), current.get(i).getTo(), \"To\");\n+        }\n+    }\n+\n+    private static void assertTimers(Map<Timer, DroolsAction> expected, Map<Timer, DroolsAction> current) {\n+        if(expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        assertEquals(expected.size(), current.size(), \"Size\");\n+        expected.forEach((expectedTimer, expectedAction) -> {\n+            Optional<Timer> currentTimer = current.keySet().stream().filter(c -> c.getId() == expectedTimer.getId()).findFirst();\n+            assertTrue(currentTimer.isPresent());\n+            assertEquals(expectedTimer.getPeriod(), currentTimer.get().getPeriod(), \"Period\");\n+            assertEquals(expectedTimer.getDate(), currentTimer.get().getDate(), \"Date\");\n+            assertEquals(expectedTimer.getDelay(), currentTimer.get().getDelay(), \"Delay\");\n+            assertEquals(expectedTimer.getTimeType(), currentTimer.get().getTimeType(), \"TimeType\");\n+            DroolsAction currentAction = current.get(currentTimer.get());\n+            if(expectedAction == null) {\n+                assertNull(currentAction);\n+                return;\n+            }\n+            assertNotNull(currentAction);\n+            assertEquals(expectedAction.getName(), currentAction.getName(), \"DroolsAction name\");\n+            //TODO: Is this expected? They are totally different objects. Expected DroolsConsequenceAction, Got lambda\n+            // assertEquals(expectedAction.getMetaData(DroolsAction.METADATA_ACTION), currentAction.getMetaData(DroolsAction.METADATA_ACTION));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMTA4Mw=="}, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0Nzg2Ng==", "bodyText": "It is actually of type Action. I decided to validate just that the content is not empty. We can improve the action assertions later on, if needed.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r410047866", "createdAt": "2020-04-17T07:42:15Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) ignoredKeys = new HashSet<>();\n+        expected.keySet()\n+                .stream()\n+                .filter(Predicate.not(ignoredKeys::contains))\n+                .forEach(k -> assertEquals(expected.get(k), current.get(k), \"Metadata \"+ k));\n+    }\n+\n+    private static void assertConnections(Map<String, List<Connection>> expectedConnections, Map<String, List<Connection>> currentConnections) {\n+        assertEquals(expectedConnections.size(), currentConnections.size());\n+        expectedConnections.forEach((type, expectedByType) -> {\n+            assertTrue(currentConnections.containsKey(type), \"Node does not have connections of type: \" + type);\n+            List<Connection> currentByType = currentConnections.get(type);\n+            expectedByType.forEach(expected -> {\n+                Optional<Connection> current = currentByType\n+                        .stream()\n+                        .filter(c -> expected.getMetaData().isEmpty() || expected.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\")))\n+                        .findFirst();\n+                assertTrue(current.isPresent(), \"Connection is present for \" + expected.getMetaData().get(\"UniqueId\"));\n+                assertEquals(expected.getFromType(), current.get().getFromType(), \"FromType\");\n+                assertEquals(expected.getFrom().getId(), current.get().getFrom().getId(), \"From.Id\");\n+                assertEquals(expected.getToType(), current.get().getToType(), \"ToType\");\n+                assertEquals(expected.getTo().getId(), current.get().getTo().getId(), \"To.Id\");\n+            });\n+        });\n+    }\n+\n+    private static void assertTriggers(List<Trigger> expected, List<Trigger> current) {\n+        try {\n+            if (expected == null) {\n+                assertNull(current);\n+                return;\n+            }\n+            assertNotNull(current);\n+            assertEquals(expected.size(), current.size());\n+            for (int i = 0; i < expected.size(); i++) {\n+                Trigger e = expected.get(i);\n+                Trigger c = current.get(i);\n+                e.getInMappings().forEach((k, v) -> assertEquals(v, c.getInMapping(k), \"InMapping for \" + k));\n+                assertDataAssociations(e.getInAssociations(), c.getInAssociations());\n+            }\n+        } catch (Throwable e) {\n+            fail(\"Triggers are not equal\", e);\n+        }\n+    }\n+\n+    private static void assertDataAssociations(List<DataAssociation> expected, List<DataAssociation> current) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        if (expected.isEmpty()) {\n+            assertEquals(1, current.size());\n+            assertEquals(1, current.get(0).getSources().size());\n+            assertEquals(\"\", current.get(0).getSources().get(0));\n+        } else {\n+            assertEquals(expected.size(), current.size());\n+            for (int i = 0; i < expected.size(); i++) {\n+                assertEquals(expected.get(i).getSources(), current.get(i).getSources(), \"Sources\");\n+                assertEquals(expected.get(i).getTarget(), current.get(i).getTarget(), \"Target\");\n+                assertEquals(expected.get(i).getTransformation(), current.get(i).getTransformation(), \"Transformation\");\n+                assertAssignments(expected.get(i).getAssignments(), current.get(i).getAssignments());\n+            }\n+        }\n+    }\n+\n+    private static void assertActions(List<DroolsAction> expected, List<DroolsAction> current) {\n+        assertEquals(expected.size(), current.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            assertEquals(((DroolsConsequenceAction) expected.get(i)).getDialect(), ((DroolsConsequenceAction) current.get(i)).getDialect(), \"Dialect\");\n+            assertEquals(((DroolsConsequenceAction) expected.get(i)).getConsequence(), ((DroolsConsequenceAction) current.get(i)).getConsequence(), \"Consequence\");\n+        }\n+    }\n+\n+    private static void assertAssignments(List<Assignment> expected, List<Assignment> current) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertEquals(expected.size(), current.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            assertEquals(expected.get(i).getFrom(), current.get(i).getFrom(), \"From\");\n+            assertEquals(expected.get(i).getDialect(), current.get(i).getDialect(), \"Dialect\");\n+            assertEquals(expected.get(i).getTo(), current.get(i).getTo(), \"To\");\n+        }\n+    }\n+\n+    private static void assertTimers(Map<Timer, DroolsAction> expected, Map<Timer, DroolsAction> current) {\n+        if(expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        assertEquals(expected.size(), current.size(), \"Size\");\n+        expected.forEach((expectedTimer, expectedAction) -> {\n+            Optional<Timer> currentTimer = current.keySet().stream().filter(c -> c.getId() == expectedTimer.getId()).findFirst();\n+            assertTrue(currentTimer.isPresent());\n+            assertEquals(expectedTimer.getPeriod(), currentTimer.get().getPeriod(), \"Period\");\n+            assertEquals(expectedTimer.getDate(), currentTimer.get().getDate(), \"Date\");\n+            assertEquals(expectedTimer.getDelay(), currentTimer.get().getDelay(), \"Delay\");\n+            assertEquals(expectedTimer.getTimeType(), currentTimer.get().getTimeType(), \"TimeType\");\n+            DroolsAction currentAction = current.get(currentTimer.get());\n+            if(expectedAction == null) {\n+                assertNull(currentAction);\n+                return;\n+            }\n+            assertNotNull(currentAction);\n+            assertEquals(expectedAction.getName(), currentAction.getName(), \"DroolsAction name\");\n+            //TODO: Is this expected? They are totally different objects. Expected DroolsConsequenceAction, Got lambda\n+            // assertEquals(expectedAction.getMetaData(DroolsAction.METADATA_ACTION), currentAction.getMetaData(DroolsAction.METADATA_ACTION));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMTA4Mw=="}, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 424}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTAzMTIyOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjowNDo1NlrOGGA5bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOTozNzo1NVrOGGItaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1OTM0MA==", "bodyText": "Come on, formatting again? You can do better \ud83e\udd23", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408959340", "createdAt": "2020-04-15T16:04:56Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.process.instance.impl.ReturnValueConstraintEvaluator;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ConstraintImpl;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGeneration);\n+    }\n+\n+    private void testProcessGeneration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+            if(expected.getVersion() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NzMzNg==", "bodyText": "I just not get used to the IDE (random excuse)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409087336", "createdAt": "2020-04-15T19:37:55Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.process.instance.impl.ReturnValueConstraintEvaluator;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ConstraintImpl;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGeneration);\n+    }\n+\n+    private void testProcessGeneration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+            if(expected.getVersion() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1OTM0MA=="}, "originalCommit": {"oid": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTAzNDk1OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjowNjowMVrOGGA78A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjowNjowMVrOGGA78A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1OTk4NA==", "bodyText": "Formatting.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408959984", "createdAt": "2020-04-15T16:06:01Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.process.instance.impl.ReturnValueConstraintEvaluator;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ConstraintImpl;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGeneration);\n+    }\n+\n+    private void testProcessGeneration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+            if(expected.getVersion() != null) {\n+                assertEquals(expected.getVersion(), current.getVersion());\n+            } else {\n+                assertEquals(\"1.0\", current.getVersion());\n+            }\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+        if(expected.getName() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTA0MjA4OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjowNzo0NFrOGGBAdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjowNzo0NFrOGGBAdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2MTE0Mw==", "bodyText": "Still formatting.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408961143", "createdAt": "2020-04-15T16:07:44Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.process.instance.impl.ReturnValueConstraintEvaluator;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ConstraintImpl;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGeneration);\n+    }\n+\n+    private void testProcessGeneration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+            if(expected.getVersion() != null) {\n+                assertEquals(expected.getVersion(), current.getVersion());\n+            } else {\n+                assertEquals(\"1.0\", current.getVersion());\n+            }\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+        if(expected.getName() != null) {\n+            assertEquals(expected.getName(), current.getName());\n+        } else {\n+            assertNotNull(current.getName());\n+        }\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+        assertConstraints((NodeImpl) expected, (NodeImpl) current);\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported - KOGITO-1709\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        assertEquals(expected.getInMappings().size(), current.getInMappings().size(), \"inMappings\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        assertEquals(expected.getOutMappings().size(), current.getOutMappings().size(), \"outMappings\");\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", expected.getClass().getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb"}, "originalPosition": 331}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTE2NjE0OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTozNTozM1rOGGVPlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTozNTozM1rOGGVPlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5MjY5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n          \n          \n            \n             * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n          \n      \n    \n    \n  \n\n:D", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409292692", "createdAt": "2020-04-16T05:35:33Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTE5MjgyOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo0ODoyNVrOGGVfag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMDo1MzozNlrOGGfwow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Njc0Ng==", "bodyText": "@ruromero could you turn this test into a parametrized test, so each file is a different instance. That also helps to clearly distinguish which file fails.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409296746", "createdAt": "2020-04-16T05:48:25Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMzE2Mw==", "bodyText": "In the follow up PR I already did that, by folder so I prefer to keep it like this for this one if you don't mind", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409303163", "createdAt": "2020-04-16T06:07:18Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Njc0Ng=="}, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2NDk5NQ==", "bodyText": "Done", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409464995", "createdAt": "2020-04-16T10:53:36Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Njc0Ng=="}, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTE5OTM4OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo1MTozMlrOGGVjWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjoxMDo1MlrOGGV9oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Nzc1NA==", "bodyText": "would also suggest here that instead of having to keep a list in a file, we do a find and include all .bpmn2 with some exclusions based on limitations. That way any new .bpmn would be automatically pickup by the test, wdyt?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409297754", "createdAt": "2020-04-16T05:51:32Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwNDQ4MQ==", "bodyText": "As there are some processes that are meant to fail or that include functionalities not covered by this process generation like multi-processes or model dependencies I'll do the other way around. I'll create files with the processes to ignore.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409304481", "createdAt": "2020-04-16T06:10:52Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Nzc1NA=="}, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTIxMTEzOnYy", "diffSide": "LEFT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/StartNode.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo1NjoyMFrOGGVp-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwOToyMDoxMFrOGHGhDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5OTQ0OA==", "bodyText": "@ruromero so what is the main reason for the changes here? for instance, we now would have the setInMappings and  addInMapping that would throw exception but these method wouldnt.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409299448", "createdAt": "2020-04-16T05:56:20Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/StartNode.java", "diffHunk": "@@ -118,12 +118,12 @@ public void setInMappings(Map<String, String> inMapping) {\n \n     @Override\n     public String getInMapping(String parameterName) {\n-        throw new IllegalArgumentException(\"A start event [\" + this.getMetaData(\"UniqueId\") + \", \" + this.getName() + \"] does not support input mappings\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2NDY5OA==", "bodyText": "Because this allows writing generic methods for any Mappable node.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409464698", "createdAt": "2020-04-16T10:53:05Z", "author": {"login": "ruromero"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/StartNode.java", "diffHunk": "@@ -118,12 +118,12 @@ public void setInMappings(Map<String, String> inMapping) {\n \n     @Override\n     public String getInMapping(String parameterName) {\n-        throw new IllegalArgumentException(\"A start event [\" + this.getMetaData(\"UniqueId\") + \", \" + this.getName() + \"] does not support input mappings\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5OTQ0OA=="}, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5ODc5Ng==", "bodyText": "Not sure I understood that. Can you elaborate @ruromero ?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r410098796", "createdAt": "2020-04-17T09:17:53Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/StartNode.java", "diffHunk": "@@ -118,12 +118,12 @@ public void setInMappings(Map<String, String> inMapping) {\n \n     @Override\n     public String getInMapping(String parameterName) {\n-        throw new IllegalArgumentException(\"A start event [\" + this.getMetaData(\"UniqueId\") + \", \" + this.getName() + \"] does not support input mappings\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5OTQ0OA=="}, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5OTk4Mw==", "bodyText": "Ah, I see now, so we can call it without worrying about the exceptions.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r410099983", "createdAt": "2020-04-17T09:20:10Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/StartNode.java", "diffHunk": "@@ -118,12 +118,12 @@ public void setInMappings(Map<String, String> inMapping) {\n \n     @Override\n     public String getInMapping(String parameterName) {\n-        throw new IllegalArgumentException(\"A start event [\" + this.getMetaData(\"UniqueId\") + \", \" + this.getName() + \"] does not support input mappings\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5OTQ0OA=="}, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MjYxMDA3OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjozODoxOFrOGGjN3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoxOTo1N1rOGGnsQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMTYyOQ==", "bodyText": "@ruromero I think the best approach here would be to use this https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-sources-MethodSource, a method source, so each file name is a parameter to testProcessGeneration.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409521629", "createdAt": "2020-04-16T12:38:18Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -91,18 +96,28 @@\n public class ProcessGenerationTest extends AbstractCodegenTest {\n \n     private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n-\n-    @Test\n-    public void testProcessesGeneration() throws IOException {\n-        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n-                .filter(f -> !f.startsWith(\"#\"))\n+    private static final Path BASE_PATH = Path.of(\"src/test/resources\");\n+    private static final Collection<String> PROCESS_EXTENSIONS = Arrays.asList(\".bpmn2\", \".bpmn\");\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"decision\", \"event-subprocess\", \"gateway\", \"messageevent\", \"messagestartevent\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c42b301e037b30d34a7e7eab711ce2064a62db9a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5NDk0Ng==", "bodyText": "I didn't know about MethodSource. Thanks I have updated it.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409594946", "createdAt": "2020-04-16T14:19:57Z", "author": {"login": "ruromero"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -91,18 +96,28 @@\n public class ProcessGenerationTest extends AbstractCodegenTest {\n \n     private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n-\n-    @Test\n-    public void testProcessesGeneration() throws IOException {\n-        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n-                .filter(f -> !f.startsWith(\"#\"))\n+    private static final Path BASE_PATH = Path.of(\"src/test/resources\");\n+    private static final Collection<String> PROCESS_EXTENSIONS = Arrays.asList(\".bpmn2\", \".bpmn\");\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"decision\", \"event-subprocess\", \"gateway\", \"messageevent\", \"messagestartevent\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMTYyOQ=="}, "originalCommit": {"oid": "c42b301e037b30d34a7e7eab711ce2064a62db9a"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MjYxMjIyOnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjozODo1M1rOGGjPPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjozODo1M1rOGGjPPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMTk4MA==", "bodyText": "@ruromero cool, best of both approaches :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409521980", "createdAt": "2020-04-16T12:38:53Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -91,18 +96,28 @@\n public class ProcessGenerationTest extends AbstractCodegenTest {\n \n     private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n-\n-    @Test\n-    public void testProcessesGeneration() throws IOException {\n-        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n-                .filter(f -> !f.startsWith(\"#\"))\n+    private static final Path BASE_PATH = Path.of(\"src/test/resources\");\n+    private static final Collection<String> PROCESS_EXTENSIONS = Arrays.asList(\".bpmn2\", \".bpmn\");\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"decision\", \"event-subprocess\", \"gateway\", \"messageevent\", \"messagestartevent\",\n+            \"org/kie/kogito/codegen/tests\", \"ruletask\", \"servicetask\", \"signalevent\", \"subprocess\",\n+            \"timer\", \"usertask\"})\n+    public void testProcessesGeneration(String folderName) throws IOException {\n+        Set<String> ignoredFiles = Files.lines(BASE_PATH.resolve(\"org/kie/kogito/codegen/process/process-generation-test.skip.txt\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c42b301e037b30d34a7e7eab711ce2064a62db9a"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 212, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}