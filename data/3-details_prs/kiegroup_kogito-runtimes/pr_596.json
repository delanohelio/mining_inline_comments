{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMDgzODU4", "number": 596, "title": "[KOGITO-2444] Generating REST endpoints for AdHocFragments", "bodyText": "Signed-off-by: ruromero rromerom@redhat.com\nFix https://issues.redhat.com/browse/KOGITO-2444\n\nAllow dynamic processes without startNode to be started\nGenerate signal-based endpoints for AdHocFragments (including HumanTasks)", "createdAt": "2020-06-30T14:48:47Z", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596", "merged": true, "mergeCommit": {"oid": "5095e3045abe68dd98aaa5f39bc7053c789a4572"}, "closed": true, "closedAt": "2020-07-06T17:32:02Z", "author": {"login": "ruromero"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwW4tZABqjM0OTgxODg1NDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyRAXigBqjM1MTU4NTE4NzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "28ef04de3f1469b9979ecd6992ad1dc2b37d7d49", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/28ef04de3f1469b9979ecd6992ad1dc2b37d7d49", "committedDate": "2020-06-30T14:46:51Z", "message": "[KOGITO-2444] Generating REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}, "afterCommit": {"oid": "e7b51a1c02119496402b1a5be376e8971d052881", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/e7b51a1c02119496402b1a5be376e8971d052881", "committedDate": "2020-06-30T14:54:10Z", "message": "[KOGITO-2444] Generating REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e7b51a1c02119496402b1a5be376e8971d052881", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/e7b51a1c02119496402b1a5be376e8971d052881", "committedDate": "2020-06-30T14:54:10Z", "message": "[KOGITO-2444] Generating REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}, "afterCommit": {"oid": "2e7ef5d1dea442b9d04975be3362a8453e098d93", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/2e7ef5d1dea442b9d04975be3362a8453e098d93", "committedDate": "2020-07-01T10:35:03Z", "message": "[KOGITO-2444] Generating REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2e7ef5d1dea442b9d04975be3362a8453e098d93", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/2e7ef5d1dea442b9d04975be3362a8453e098d93", "committedDate": "2020-07-01T10:35:03Z", "message": "[KOGITO-2444] Generating REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}, "afterCommit": {"oid": "48b8efe7dc5971f69df856cac0206cf80f490f7f", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/48b8efe7dc5971f69df856cac0206cf80f490f7f", "committedDate": "2020-07-01T15:35:18Z", "message": "[KOGITO-2444] Generating REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "48b8efe7dc5971f69df856cac0206cf80f490f7f", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/48b8efe7dc5971f69df856cac0206cf80f490f7f", "committedDate": "2020-07-01T15:35:18Z", "message": "[KOGITO-2444] Generating REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}, "afterCommit": {"oid": "a0c219481f33e89749fdd21cb5f0aa1323c0e370", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a0c219481f33e89749fdd21cb5f0aa1323c0e370", "committedDate": "2020-07-01T17:20:42Z", "message": "[KOGITO-2444] Generating REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0c219481f33e89749fdd21cb5f0aa1323c0e370", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a0c219481f33e89749fdd21cb5f0aa1323c0e370", "committedDate": "2020-07-01T17:20:42Z", "message": "[KOGITO-2444] Generating REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}, "afterCommit": {"oid": "1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8", "committedDate": "2020-07-01T17:22:22Z", "message": "[KOGITO-2444] Generating REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMDYzMzQ5", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#pullrequestreview-441063349", "createdAt": "2020-07-01T17:24:54Z", "commit": {"oid": "48b8efe7dc5971f69df856cac0206cf80f490f7f"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNzoyNTo1N1rOGru-HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODowODo1NFrOGrwVJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUxMTUxNg==", "bodyText": "signalId name is quite confusing IMO, what about signalNamePath or sanitizedSignalName... just some suggestions", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r448511516", "createdAt": "2020-07-01T17:25:57Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/resources/class-templates/RestResourceSignalTemplate.java", "diffHunk": "@@ -28,18 +28,18 @@\n     Process<$Type$> process;\n \n     @POST\n-    @Path(\"/{id}/$signalName$\")\n+    @Path(\"/{id}/$signalId$\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUxOTcyOQ==", "bodyText": "suggestion to extract the signalName.replaceAll(\"\\\\s\", \"_\")) to a class/method, this logic could be used to sanitize and generate the path for endpoints when needed, not only in this place, wdyt?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r448519729", "createdAt": "2020-07-01T17:41:43Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/AbstractResourceGenerator.java", "diffHunk": "@@ -178,6 +179,7 @@ public String generate() {\n                                 template.findAll(StringLiteralExpr.class).forEach(vv -> {\n                                     String s = vv.getValue();\n                                     String interpolated = s.replace(\"$signalName$\", signalName);\n+                                    interpolated = interpolated.replace(\"$signalId$\", signalName.replaceAll(\"\\\\s\", \"_\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUyMjUxOQ==", "bodyText": "the same logic used to sanitize used here...", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r448522519", "createdAt": "2020-07-01T17:47:02Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/AbstractResourceGenerator.java", "diffHunk": "@@ -311,19 +317,18 @@ private void interpolateStrings(StringLiteralExpr vv) {\n \n     private void interpolateUserTaskStrings(StringLiteralExpr vv, UserTaskModelMetaData userTask) {\n         String s = vv.getValue();\n-\n-        String interpolated =\n-                s.replace(\"$taskname$\", userTask.getName().replaceAll(\"\\\\s\", \"_\"));\n+        String interpolated = s.replace(\"$taskname$\", userTask.getName().replaceAll(\"\\\\s\", \"_\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMDk2Ng==", "bodyText": "isn't better to interpolate the method name signal based on the $taskname$? if you check \n  \n    \n      kogito-runtimes/kogito-codegen/src/main/java/org/kie/kogito/codegen/process/AbstractResourceGenerator.java\n    \n    \n         Line 151\n      in\n      e5994ce\n    \n    \n    \n    \n\n        \n          \n           String methodName = \"signal_\" + index.getAndIncrement(); \n        \n    \n  \n\n when the other methods for signals where generated it was used a \"counter\" but basically to avoid name conflicts probably.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r448530966", "createdAt": "2020-07-01T18:03:07Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/resources/class-templates/RestResourceUserTaskTemplate.java", "diffHunk": "@@ -3,11 +3,32 @@\n import java.util.List;\n \n import org.drools.core.WorkItemNotFoundException;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.impl.Sig;\n \n \n public class $Type$Resource {\n \n-    \n+    @POST\n+    @Path(\"/{id}/$taskname$\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public javax.ws.rs.core.Response signal(@PathParam(\"id\") final String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMzI4Mg==", "bodyText": "minor, but why not use camelCase for tasknodename", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r448533282", "createdAt": "2020-07-01T18:07:53Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/AbstractResourceGenerator.java", "diffHunk": "@@ -311,19 +317,18 @@ private void interpolateStrings(StringLiteralExpr vv) {\n \n     private void interpolateUserTaskStrings(StringLiteralExpr vv, UserTaskModelMetaData userTask) {\n         String s = vv.getValue();\n-\n-        String interpolated =\n-                s.replace(\"$taskname$\", userTask.getName().replaceAll(\"\\\\s\", \"_\"));\n+        String interpolated = s.replace(\"$taskname$\", userTask.getName().replaceAll(\"\\\\s\", \"_\"));\n+        interpolated = interpolated.replace(\"$tasknodename$\", userTask.getNodeName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMzc5OA==", "bodyText": "so If I understood correctly method is always added by the template and it is being removed here in case of ad-hoc, right?\nWhere the method name is generated based on the \"signal_\" + userTask.getId() ? on the template the method is just called signal, I missed this point", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r448533798", "createdAt": "2020-07-01T18:08:54Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/AbstractResourceGenerator.java", "diffHunk": "@@ -208,9 +210,15 @@ public String generate() {\n                 });\n \n                 template.findAll(StringLiteralExpr.class).forEach(s -> interpolateUserTaskStrings(s, userTask));\n-\n-                template.findAll(ClassOrInterfaceType.class).forEach(c -> interpolateUserTaskTypes(c, userTask.getInputMoodelClassSimpleName(), userTask.getOutputMoodelClassSimpleName()));\n+                template.findAll(ClassOrInterfaceType.class).forEach(c -> interpolateUserTaskTypes(c, userTask.getInputModelClassSimpleName(), userTask.getOutputModelClassSimpleName()));\n                 template.findAll(NameExpr.class).forEach(c -> interpolateUserTaskNameExp(c, userTask));\n+                if(!userTask.isAdHoc()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzUwODMz", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#pullrequestreview-441350833", "createdAt": "2020-07-02T04:58:59Z", "commit": {"oid": "1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNDo1OTowMFrOGr9fQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNDo1OTowMFrOGr9fQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc0OTM3Nw==", "bodyText": "perhaps the method should not be added in the first place?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r448749377", "createdAt": "2020-07-02T04:59:00Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/AbstractResourceGenerator.java", "diffHunk": "@@ -208,9 +210,15 @@ public String generate() {\n                 });\n \n                 template.findAll(StringLiteralExpr.class).forEach(s -> interpolateUserTaskStrings(s, userTask));\n-\n-                template.findAll(ClassOrInterfaceType.class).forEach(c -> interpolateUserTaskTypes(c, userTask.getInputMoodelClassSimpleName(), userTask.getOutputMoodelClassSimpleName()));\n+                template.findAll(ClassOrInterfaceType.class).forEach(c -> interpolateUserTaskTypes(c, userTask.getInputModelClassSimpleName(), userTask.getOutputModelClassSimpleName()));\n                 template.findAll(NameExpr.class).forEach(c -> interpolateUserTaskNameExp(c, userTask));\n+                if(!userTask.isAdHoc()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMzc5OA=="}, "originalCommit": {"oid": "1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTM3NTI3", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#pullrequestreview-441937527", "createdAt": "2020-07-02T18:38:49Z", "commit": {"oid": "1d6fd495b42af36d038756024a41f411b942ed56"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODozODo0OVrOGsZJ0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo0MDo0NFrOGsZNiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMjY0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .post(\"/AdHocFragments\" + taskPath)\n          \n          \n            \n                            .post(\"/AdHocFragments/{path}\", taskPath)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449202640", "createdAt": "2020-07-02T18:38:49Z", "author": {"login": "cristianonicolai"}, "path": "integration-tests/integration-tests-quarkus/src/test/java/org/kie/kogito/integrationtests/quarkus/AdHocFragmentsTest.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.integrationtests.quarkus;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import io.restassured.RestAssured;\n+import io.restassured.http.ContentType;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.emptyOrNullString;\n+\n+@QuarkusTest\n+public class AdHocFragmentsTest {\n+\n+    static {\n+        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();\n+    }\n+\n+    @Test\n+    public void testUserTaskProcess() {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"var1\", \"Kermit\");\n+\n+        String pid = given()\n+                .contentType(ContentType.JSON)\n+                .when()\n+                .body(params)\n+                .post(\"/AdHocFragments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"id\", not(emptyOrNullString()))\n+                .body(\"var1\", equalTo(\"Kermit\"))\n+                .extract().path(\"id\");\n+\n+        String link = given()\n+                .contentType(ContentType.JSON)\n+                .when()\n+                .post(\"/AdHocFragments/{pid}/AdHocTask1\", pid)\n+                .then()\n+                .statusCode(200)\n+                .header(\"Link\", notNullValue())\n+                .extract().header(\"Link\");\n+\n+        String taskPath = link.substring(link.indexOf(\"<\") + 1, link.indexOf(\">\"));\n+\n+        params = new HashMap<>();\n+        params.put(\"newVar1\", \"Gonzo\");\n+        given()\n+                .contentType(ContentType.JSON)\n+                .when()\n+                .body(params)\n+                .post(\"/AdHocFragments\" + taskPath)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6fd495b42af36d038756024a41f411b942ed56"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMzE4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    given()\n          \n          \n            \n                            .contentType(ContentType.JSON)\n          \n          \n            \n                            .when()\n          \n          \n            \n                            .body(params)\n          \n          \n            \n                            .post(\"/AdHocProcess\")\n          \n          \n            \n                            .then()\n          \n          \n            \n                            .statusCode(200)\n          \n          \n            \n                            .body(\"id\", not(emptyOrNullString()))\n          \n          \n            \n                            .body(\"var1\", equalTo(\"Hello first! Script\"))\n          \n          \n            \n                            .body(\"var2\", equalTo(\"second Script 2\"));\n          \n          \n            \n                    given()\n          \n          \n            \n                            .contentType(ContentType.JSON)\n          \n          \n            \n                    .when()\n          \n          \n            \n                            .body(params)\n          \n          \n            \n                            .post(\"/AdHocProcess\")\n          \n          \n            \n                    .then()\n          \n          \n            \n                            .statusCode(200)\n          \n          \n            \n                            .body(\"id\", not(emptyOrNullString()))\n          \n          \n            \n                            .body(\"var1\", equalTo(\"Hello first! Script\"))\n          \n          \n            \n                            .body(\"var2\", equalTo(\"second Script 2\"));", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449203189", "createdAt": "2020-07-02T18:39:52Z", "author": {"login": "cristianonicolai"}, "path": "integration-tests/integration-tests-quarkus/src/test/java/org/kie/kogito/integrationtests/quarkus/FlexibleProcessTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.integrationtests.quarkus;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+import io.restassured.RestAssured;\n+import io.restassured.http.ContentType;\n+import org.junit.jupiter.api.Test;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.Matchers.emptyOrNullString;\n+\n+@QuarkusTest\n+public class FlexibleProcessTest {\n+\n+    static {\n+        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();\n+    }\n+\n+    @Test\n+    public void testInstantiateProcess() {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"var1\", \"first\");\n+        params.put(\"var2\", \"second\");\n+\n+        given()\n+                .contentType(ContentType.JSON)\n+                .when()\n+                .body(params)\n+                .post(\"/AdHocProcess\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"id\", not(emptyOrNullString()))\n+                .body(\"var1\", equalTo(\"Hello first! Script\"))\n+                .body(\"var2\", equalTo(\"second Script 2\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6fd495b42af36d038756024a41f411b942ed56"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMzU5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .post(\"/AdHocFragments\" + taskPath)\n          \n          \n            \n                            .post(\"/AdHocFragments/{path}\", taskPath)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449203593", "createdAt": "2020-07-02T18:40:44Z", "author": {"login": "cristianonicolai"}, "path": "integration-tests/integration-tests-springboot/src/it/integration-tests-springboot-it/src/test/java/org/kie/kogito/integrationtests/springboot/AdHocFragmentsTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.integrationtests.springboot;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import io.restassured.RestAssured;\n+import io.restassured.http.ContentType;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.boot.test.context.SpringBootTest;\n+import org.springframework.test.annotation.DirtiesContext;\n+\n+import static io.restassured.RestAssured.given;\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.Matchers.emptyOrNullString;\n+\n+@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT, classes = KogitoSpringbootApplication.class)\n+@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)\n+public class AdHocFragmentsTest {\n+\n+    static {\n+        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();\n+    }\n+\n+    @Test\n+    public void testUserTaskProcess() {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"var1\", \"Kermit\");\n+\n+        String pid = given()\n+                .contentType(ContentType.JSON)\n+                .when()\n+                .body(params)\n+                .post(\"/AdHocFragments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"id\", not(emptyOrNullString()))\n+                .body(\"var1\", equalTo(\"Kermit\"))\n+                .extract().path(\"id\");\n+\n+        String link = given()\n+                .contentType(ContentType.JSON)\n+                .when()\n+                .post(\"/AdHocFragments/{pid}/AdHocTask1\", pid)\n+                .then()\n+                .statusCode(200)\n+                .header(\"Link\", notNullValue())\n+                .extract().header(\"Link\");\n+\n+        String taskPath = link.substring(link.indexOf(\"<\") + 1, link.indexOf(\">\"));\n+\n+        params = new HashMap<>();\n+        params.put(\"newVar1\", \"Gonzo\");\n+        given()\n+                .contentType(ContentType.JSON)\n+                .when()\n+                .body(params)\n+                .post(\"/AdHocFragments\" + taskPath)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6fd495b42af36d038756024a41f411b942ed56"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMDAwMzg4", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#pullrequestreview-442000388", "createdAt": "2020-07-02T20:30:50Z", "commit": {"oid": "551d4da02dd5d1712580e3a7ff897fc09218c6f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMDozMDo1MVrOGscJIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMDozMDo1MVrOGscJIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI1MTYxOQ==", "bodyText": "I still didn't get where is the place the method name was set with \"signal_\" + index.getAndIncrement(), because to filter here, to be removed from the template, you should have set this before, right? I didn't found where it is being set.\nBy the way is there a specific test to check if the method was removed from the generated code?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449251619", "createdAt": "2020-07-02T20:30:51Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/AbstractResourceGenerator.java", "diffHunk": "@@ -208,9 +209,12 @@ public String generate() {\n                 });\n \n                 template.findAll(StringLiteralExpr.class).forEach(s -> interpolateUserTaskStrings(s, userTask));\n-\n-                template.findAll(ClassOrInterfaceType.class).forEach(c -> interpolateUserTaskTypes(c, userTask.getInputMoodelClassSimpleName(), userTask.getOutputMoodelClassSimpleName()));\n+                template.findAll(ClassOrInterfaceType.class).forEach(c -> interpolateUserTaskTypes(c, userTask.getInputModelClassSimpleName(), userTask.getOutputModelClassSimpleName()));\n                 template.findAll(NameExpr.class).forEach(c -> interpolateUserTaskNameExp(c, userTask));\n+                template.findAll(MethodDeclaration.class)\n+                        .stream()\n+                        .filter(md -> md.getNameAsString().equals(\"signal_\" + index.getAndIncrement()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "551d4da02dd5d1712580e3a7ff897fc09218c6f5"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzQ5OTk4", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#pullrequestreview-442349998", "createdAt": "2020-07-03T11:30:40Z", "commit": {"oid": "02f2efe887e0529909feb27ea357ebc3971dc6b4"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTozMDo0MFrOGstb_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMTozMDo0MFrOGstb_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUzNDk3NQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449534975", "createdAt": "2020-07-03T11:30:40Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/AbstractResourceGenerator.java", "diffHunk": "@@ -208,9 +210,15 @@ public String generate() {\n                 });\n \n                 template.findAll(StringLiteralExpr.class).forEach(s -> interpolateUserTaskStrings(s, userTask));\n-\n-                template.findAll(ClassOrInterfaceType.class).forEach(c -> interpolateUserTaskTypes(c, userTask.getInputMoodelClassSimpleName(), userTask.getOutputMoodelClassSimpleName()));\n+                template.findAll(ClassOrInterfaceType.class).forEach(c -> interpolateUserTaskTypes(c, userTask.getInputModelClassSimpleName(), userTask.getOutputModelClassSimpleName()));\n                 template.findAll(NameExpr.class).forEach(c -> interpolateUserTaskNameExp(c, userTask));\n+                if(!userTask.isAdHoc()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMzc5OA=="}, "originalCommit": {"oid": "1f3b52cef3ff9b55979d354c1ac7721a5f97dcc8"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzk5NjEy", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#pullrequestreview-442399612", "createdAt": "2020-07-03T13:04:32Z", "commit": {"oid": "02f2efe887e0529909feb27ea357ebc3971dc6b4"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMzowNDozMlrOGsvxyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMzo0OTozN1rOGsw_Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MzMyMA==", "bodyText": "So in the end this Map can be put back inside the if statement, right? As dynamicParams is not used outside of the if.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449573320", "createdAt": "2020-07-03T13:04:32Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/WorkflowProcessInstanceImpl.java", "diffHunk": "@@ -636,17 +638,19 @@ public void signalEvent(String type, Object event) {\n                     for (Node node : getWorkflowProcess().getNodes()) {\n                         if (type.equals(node.getName()) && node.getIncomingConnections().isEmpty()) {\n                             NodeInstance nodeInstance = getNodeInstance(node);\n+                            Map<String, Object> dynamicParams = new HashMap<>(getVariables());\n                             if (event != null) {\n-                                Map<String, Object> dynamicParams = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02f2efe887e0529909feb27ea357ebc3971dc6b4"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3Mzk5MA==", "bodyText": "Maybe an additional formatting here would help when reading.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449573990", "createdAt": "2020-07-03T13:06:03Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/CompositeNodeInstance.java", "diffHunk": "@@ -272,22 +272,33 @@ public void signalEvent(String type, Object event) {\n \t\tList<NodeInstance> currentView = new ArrayList<>(this.nodeInstances);\n \t\tsuper.signalEvent(type, event);\n \t\tfor (Node node: getCompositeNode().internalGetNodes()) {\n-\t\t\tif (node instanceof EventNodeInterface) {\n-\t\t\t\tif (((EventNodeInterface) node).acceptsEvent(type, event)) {\n-\t\t\t\t\tif (node instanceof EventNode && ((EventNode) node).getFrom() == null || node instanceof EventSubProcessNode) {\n-\t\t\t\t\t\tEventNodeInstanceInterface eventNodeInstance = (EventNodeInstanceInterface) getNodeInstance(node);\n-\t\t\t\t\t\teventNodeInstance.signalEvent(type, event);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tList<NodeInstance> nodeInstances = getNodeInstances(node.getId(), currentView);\n-\t\t\t\t\t\tif (nodeInstances != null && !nodeInstances.isEmpty()) {\n-\t\t\t\t\t\t\tfor (NodeInstance nodeInstance : nodeInstances) {\n-\t\t\t\t\t\t\t\t((EventNodeInstanceInterface) nodeInstance)\n-\t\t\t\t\t\t\t\t\t\t.signalEvent(type, event);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\tif (node instanceof EventNodeInterface && ((EventNodeInterface) node).acceptsEvent(type, event)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02f2efe887e0529909feb27ea357ebc3971dc6b4"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NDU2Mw==", "bodyText": "Same here.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449574563", "createdAt": "2020-07-03T13:07:21Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/CompositeNodeInstance.java", "diffHunk": "@@ -272,22 +272,33 @@ public void signalEvent(String type, Object event) {\n \t\tList<NodeInstance> currentView = new ArrayList<>(this.nodeInstances);\n \t\tsuper.signalEvent(type, event);\n \t\tfor (Node node: getCompositeNode().internalGetNodes()) {\n-\t\t\tif (node instanceof EventNodeInterface) {\n-\t\t\t\tif (((EventNodeInterface) node).acceptsEvent(type, event)) {\n-\t\t\t\t\tif (node instanceof EventNode && ((EventNode) node).getFrom() == null || node instanceof EventSubProcessNode) {\n-\t\t\t\t\t\tEventNodeInstanceInterface eventNodeInstance = (EventNodeInstanceInterface) getNodeInstance(node);\n-\t\t\t\t\t\teventNodeInstance.signalEvent(type, event);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tList<NodeInstance> nodeInstances = getNodeInstances(node.getId(), currentView);\n-\t\t\t\t\t\tif (nodeInstances != null && !nodeInstances.isEmpty()) {\n-\t\t\t\t\t\t\tfor (NodeInstance nodeInstance : nodeInstances) {\n-\t\t\t\t\t\t\t\t((EventNodeInstanceInterface) nodeInstance)\n-\t\t\t\t\t\t\t\t\t\t.signalEvent(type, event);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\tif (node instanceof EventNodeInterface && ((EventNodeInterface) node).acceptsEvent(type, event)) {\n+                if (node instanceof EventNode && ((EventNode) node).getFrom() == null || node instanceof EventSubProcessNode) {\n+                    EventNodeInstanceInterface eventNodeInstance = (EventNodeInstanceInterface) getNodeInstance(node);\n+                    eventNodeInstance.signalEvent(type, event);\n+                } else {\n+                    List<NodeInstance> nodeInstances = getNodeInstances(node.getId(), currentView);\n+                    if (nodeInstances != null && !nodeInstances.isEmpty()) {\n+                        for (NodeInstance nodeInstance : nodeInstances) {\n+                            ((EventNodeInstanceInterface) nodeInstance)\n+                                    .signalEvent(type, event);\n+                        }\n+                    }\n+                }\n \t\t\t}\n+            if (type.equals(node.getName()) && node.getIncomingConnections().isEmpty()) {\n+                NodeInstance nodeInstance = getNodeInstance(node);\n+                Map<String, Object> dynamicParams = new HashMap<>(getProcessInstance().getVariables());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02f2efe887e0529909feb27ea357ebc3971dc6b4"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3ODI2MQ==", "bodyText": "Is there any reason to introduce a new parameter? By looking at the AbstractResourceGenerator, signalPath and signalName are replaced with the same signalName value. So having here the same parameter might be less misleading.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449578261", "createdAt": "2020-07-03T13:15:47Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/main/resources/class-templates/RestResourceSignalTemplate.java", "diffHunk": "@@ -28,18 +28,18 @@\n     Process<$Type$> process;\n \n     @POST\n-    @Path(\"/{id}/$signalName$\")\n+    @Path(\"/{id}/$signalPath$\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02f2efe887e0529909feb27ea357ebc3971dc6b4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MTcwMg==", "bodyText": "Just a question from the performance point of view. Now I think in Business Central on 7.x, when we trigger a fragment we just send a signal and don't check if it has been triggered I think. We just return as soon as the signal has been sent successfully. This additional check may be not needed/wanted by some users maybe.\nI am not saying it's bad, maybe we should just think also about the quicker option.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449591702", "createdAt": "2020-07-03T13:46:05Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/main/resources/class-templates/RestResourceUserTaskTemplate.java", "diffHunk": "@@ -3,13 +3,36 @@\n import java.util.List;\n \n import org.drools.core.WorkItemNotFoundException;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.impl.Sig;\n \n \n public class $Type$Resource {\n \n-    \n+    @POST\n+    @Path(\"/{id}/$taskName$\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public javax.ws.rs.core.Response signal(@PathParam(\"id\") final String id) {\n+        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+            ProcessInstance<$Type$> pi = process.instances().findById(id).orElse(null);\n+            if (pi == null) {\n+                return null;\n+            }\n+            pi.send(Sig.of(\"$taskNodeName$\", java.util.Collections.emptyMap()));\n+            java.util.Optional<WorkItem> task = pi.workItems().stream().filter(wi -> wi.getName().equals(\"$taskName$\")).findFirst();\n+            if(task.isPresent()) {\n+                return javax.ws.rs.core.Response.ok(pi.variables())\n+                        .header(\"Link\", \"</\" + id + \"/$taskName$/\" + task.get().getId() + \">; rel='instance'\")\n+                        .build();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02f2efe887e0529909feb27ea357ebc3971dc6b4"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MzE3OA==", "bodyText": "Here the additional check is missing. Is it OK?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449593178", "createdAt": "2020-07-03T13:49:37Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/main/resources/class-templates/spring/SpringRestResourceUserTaskTemplate.java", "diffHunk": "@@ -13,7 +16,22 @@\n \n public class $Type$Resource {\n \n-    @PostMapping(value = \"/{id}/$taskname$/{workItemId}\", produces = MediaType.APPLICATION_JSON_VALUE,\n+    @PostMapping(value = \"/{id}/$taskName$\", produces = MediaType.APPLICATION_JSON_VALUE,\n+            consumes = MediaType.APPLICATION_JSON_VALUE)\n+    public org.springframework.http.ResponseEntity<$Type$> signal(@PathVariable(\"id\") final String id) {\n+        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+            ProcessInstance<$Type$> pi = process.instances().findById(id).orElse(null);\n+            if (pi == null) {\n+                return null;\n+            }\n+            pi.send(Sig.of(\"$taskNodeName$\", java.util.Collections.emptyMap()));\n+            return org.springframework.http.ResponseEntity.ok()\n+                    .header(\"Link\", \"</\" + id + \"/$taskName$/\" + task.get().getId() + \">; rel='instance'\")\n+                    .body(pi.variables());\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02f2efe887e0529909feb27ea357ebc3971dc6b4"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNTA3ODAz", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#pullrequestreview-442507803", "createdAt": "2020-07-03T16:50:52Z", "commit": {"oid": "b57e4ea68f625741442ec5f39aedc7d607a1c9d9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNTI0Mjg1", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#pullrequestreview-442524285", "createdAt": "2020-07-03T17:59:10Z", "commit": {"oid": "b57e4ea68f625741442ec5f39aedc7d607a1c9d9"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNzo1OToxMFrOGs10-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxODowMTo0NVrOGs12zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3MjQ0MA==", "bodyText": "I think the call to pi.variables() should be wrapped in getModel To filter out inputs, internals etc\nSame as done here https://github.com/kiegroup/kogito-runtimes/pull/596/files#diff-6350da7d2030cb169a6592ea0de9c8bdR98", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449672440", "createdAt": "2020-07-03T17:59:10Z", "author": {"login": "mswiderski"}, "path": "kogito-codegen/src/main/resources/class-templates/RestResourceUserTaskTemplate.java", "diffHunk": "@@ -3,13 +3,36 @@\n import java.util.List;\n \n import org.drools.core.WorkItemNotFoundException;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.impl.Sig;\n \n \n public class $Type$Resource {\n \n-    \n+    @POST\n+    @Path(\"/{id}/$taskName$\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public javax.ws.rs.core.Response signal(@PathParam(\"id\") final String id) {\n+        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+            ProcessInstance<$Type$> pi = process.instances().findById(id).orElse(null);\n+            if (pi == null) {\n+                return null;\n+            }\n+            pi.send(Sig.of(\"$taskNodeName$\", java.util.Collections.emptyMap()));\n+            java.util.Optional<WorkItem> task = pi.workItems().stream().filter(wi -> wi.getName().equals(\"$taskName$\")).findFirst();\n+            if(task.isPresent()) {\n+                return javax.ws.rs.core.Response.ok(pi.variables())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b57e4ea68f625741442ec5f39aedc7d607a1c9d9"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3MjU0Mg==", "bodyText": "Same here about wrapping in getModel", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449672542", "createdAt": "2020-07-03T17:59:41Z", "author": {"login": "mswiderski"}, "path": "kogito-codegen/src/main/resources/class-templates/RestResourceSignalTemplate.java", "diffHunk": "@@ -28,18 +28,18 @@\n     Process<$Type$> process;\n \n     @POST\n-    @Path(\"/{id}/$signalName$\")\n+    @Path(\"/{id}/$signalPath$\")\n     @Consumes(MediaType.APPLICATION_JSON)\n     @Produces(MediaType.APPLICATION_JSON)\n     public $Type$ signal(@PathParam(\"id\") final String id, final $signalType$ data) {\n-\n-        ProcessInstance<$Type$> pi = process.instances().findById(id).orElse(null);\n-        if(pi == null){\n-            return null;\n-        }\n-\n-        pi.send(Sig.of(\"$signalName$\", data));\n-\n-        return pi.variables();\n+        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+            ProcessInstance<$Type$> pi = process.instances().findById(id).orElse(null);\n+            if (pi == null) {\n+                return null;\n+            }\n+            pi.send(Sig.of(\"$signalName$\", data));\n+            return pi.variables();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b57e4ea68f625741442ec5f39aedc7d607a1c9d9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3MjkxMA==", "bodyText": "And one more wrap with getModel", "url": "https://github.com/kiegroup/kogito-runtimes/pull/596#discussion_r449672910", "createdAt": "2020-07-03T18:01:45Z", "author": {"login": "mswiderski"}, "path": "kogito-codegen/src/main/resources/class-templates/spring/SpringRestResourceSignalTemplate.java", "diffHunk": "@@ -30,16 +30,15 @@\n \n     Process<$Type$> process;\n \n-    @PostMapping(value = \"/{id}/$signalName$\", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)\n+    @PostMapping(value = \"/{id}/$signalPath$\", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)\n     public $Type$ signal(@PathVariable(\"id\") final String id, final @RequestBody $signalType$ data) {\n-\n-        ProcessInstance<$Type$> pi = process.instances().findById(id).orElse(null);\n-        if (pi == null) {\n-            return null;\n-        }\n-\n-        pi.send(Sig.of(\"$signalName$\", data));\n-\n-        return pi.variables();\n+        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+            ProcessInstance<$Type$> pi = process.instances().findById(id).orElse(null);\n+            if (pi == null) {\n+                return null;\n+            }\n+            pi.send(Sig.of(\"$signalName$\", data));\n+            return pi.variables();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b57e4ea68f625741442ec5f39aedc7d607a1c9d9"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c9753d297e38e3b78c44b5246d7c318b94444ba", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/5c9753d297e38e3b78c44b5246d7c318b94444ba", "committedDate": "2020-07-06T13:10:53Z", "message": "[KOGITO-2444] Generate REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9988c97c2702fd540e4c13863af8aceadd369c2c", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9988c97c2702fd540e4c13863af8aceadd369c2c", "committedDate": "2020-07-06T09:14:30Z", "message": "[KOGITO-2444] getModel\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}, "afterCommit": {"oid": "5c9753d297e38e3b78c44b5246d7c318b94444ba", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/5c9753d297e38e3b78c44b5246d7c318b94444ba", "committedDate": "2020-07-06T13:10:53Z", "message": "[KOGITO-2444] Generate REST endpoints for AdHocFragments\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4203, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}