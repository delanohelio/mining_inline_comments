{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNTA4NTk2", "number": 308, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNzoxNTozMFrODeF5Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwOTo0ODowMVrODfHDlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODgwNDE5OnYy", "diffSide": "RIGHT", "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNzoxNTozMFrOFnENXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNDowNToyMFrOFnnNyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUwNzc0MA==", "bodyText": "Shouldn't we add these properties on the README?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r376507740", "createdAt": "2020-02-07T17:15:30Z", "author": {"login": "spolti"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -52,13 +55,19 @@\n     @ConfigProperty(name = \"kogito.jobs-service.maxIntervalLimitToRetryMillis\", defaultValue = \"60000\")\n     long maxIntervalLimitToRetryMillis;\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkxMzcwOA==", "bodyText": "+1 and to update wiki page about jobs service", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r376913708", "createdAt": "2020-02-10T08:14:15Z", "author": {"login": "mswiderski"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -52,13 +55,19 @@\n     @ConfigProperty(name = \"kogito.jobs-service.maxIntervalLimitToRetryMillis\", defaultValue = \"60000\")\n     long maxIntervalLimitToRetryMillis;\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUwNzc0MA=="}, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAwODIwMw==", "bodyText": "+1, I'll update the wiki and insert some javadoc as well...", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r377008203", "createdAt": "2020-02-10T11:31:08Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -52,13 +55,19 @@\n     @ConfigProperty(name = \"kogito.jobs-service.maxIntervalLimitToRetryMillis\", defaultValue = \"60000\")\n     long maxIntervalLimitToRetryMillis;\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUwNzc0MA=="}, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MTI4OA==", "bodyText": "done, missing the wiki.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r377081288", "createdAt": "2020-02-10T14:05:20Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -52,13 +55,19 @@\n     @ConfigProperty(name = \"kogito.jobs-service.maxIntervalLimitToRetryMillis\", defaultValue = \"60000\")\n     long maxIntervalLimitToRetryMillis;\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUwNzc0MA=="}, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODgwODk3OnYy", "diffSide": "RIGHT", "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNzoxNzoyM1rOFnEQhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNDowNjoyNFrOFnnQAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUwODU0OQ==", "bodyText": "just an opinion, wouldn't be better break this step in smaller pieces for a better code maintainability?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r376508549", "createdAt": "2020-02-07T17:17:23Z", "author": {"login": "spolti"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -79,30 +89,45 @@ public BaseTimerJobScheduler(JobExecutor jobExecutor,\n                 .fromCompletionStage(jobRepository.exists(job.getId()))\n                 .flatMap(exists -> Boolean.TRUE.equals(exists)\n                         ? handleExistingJob(job)\n-                        : ReactiveStreams.of(Boolean.TRUE))\n-                .filter(Boolean.TRUE::equals)\n-                //2- calculate the delay (when the job should be executed)\n-                .map(checked -> job.getExpirationTime())\n-                .map(this::calculateDelay)\n-                .peek(delay -> Optional\n-                        .of(delay.isNegative())\n-                        .filter(Boolean.FALSE::equals)\n-                        .orElseThrow(() -> new RuntimeException(\"Delay should be positive\")))\n-                //3- schedule the job\n-                .map(delay -> doSchedule(delay, job))\n-                .flatMap(p -> p)\n-                .map(scheduleId -> ScheduledJob\n-                        .builder()\n-                        .job(job)\n-                        .scheduledId(scheduleId)\n-                        .status(JobStatus.SCHEDULED)\n-                        .build())\n-                .map(scheduledJob -> jobRepository.save(scheduledJob))\n-                .flatMapCompletionStage(p -> p)\n+                        : ReactiveStreams.of(job))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MTg1Ng==", "bodyText": "done, I split into one more method to execute the scheduling process.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r377081856", "createdAt": "2020-02-10T14:06:24Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -79,30 +89,45 @@ public BaseTimerJobScheduler(JobExecutor jobExecutor,\n                 .fromCompletionStage(jobRepository.exists(job.getId()))\n                 .flatMap(exists -> Boolean.TRUE.equals(exists)\n                         ? handleExistingJob(job)\n-                        : ReactiveStreams.of(Boolean.TRUE))\n-                .filter(Boolean.TRUE::equals)\n-                //2- calculate the delay (when the job should be executed)\n-                .map(checked -> job.getExpirationTime())\n-                .map(this::calculateDelay)\n-                .peek(delay -> Optional\n-                        .of(delay.isNegative())\n-                        .filter(Boolean.FALSE::equals)\n-                        .orElseThrow(() -> new RuntimeException(\"Delay should be positive\")))\n-                //3- schedule the job\n-                .map(delay -> doSchedule(delay, job))\n-                .flatMap(p -> p)\n-                .map(scheduleId -> ScheduledJob\n-                        .builder()\n-                        .job(job)\n-                        .scheduledId(scheduleId)\n-                        .status(JobStatus.SCHEDULED)\n-                        .build())\n-                .map(scheduledJob -> jobRepository.save(scheduledJob))\n-                .flatMapCompletionStage(p -> p)\n+                        : ReactiveStreams.of(job))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUwODU0OQ=="}, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTYxNDg0OnYy", "diffSide": "RIGHT", "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwODowOToxOFrOFnc4rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNDoxMTo0OFrOFnnb-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkxMjA0NQ==", "bodyText": "why to keep these two properties in different time units? one in minutes and the other in millis?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r376912045", "createdAt": "2020-02-10T08:09:18Z", "author": {"login": "mswiderski"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "diffHunk": "@@ -35,22 +40,49 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(JobSchedulerManager.class);\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")\n+    long schedulerChunkInMinutes;\n+\n+    @ConfigProperty(name = \"kogito.jobs-service.loadJobIntervalInMillis\", defaultValue = \"60000\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAwODg1NQ==", "bodyText": "np, let's unify... I used milliseconds just because vertx scheduler is based on it, but this is an easy conversion, better to keep the same units.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r377008855", "createdAt": "2020-02-10T11:32:42Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "diffHunk": "@@ -35,22 +40,49 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(JobSchedulerManager.class);\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")\n+    long schedulerChunkInMinutes;\n+\n+    @ConfigProperty(name = \"kogito.jobs-service.loadJobIntervalInMillis\", defaultValue = \"60000\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkxMjA0NQ=="}, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4NDkyMQ==", "bodyText": "done", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r377084921", "createdAt": "2020-02-10T14:11:48Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "diffHunk": "@@ -35,22 +40,49 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(JobSchedulerManager.class);\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")\n+    long schedulerChunkInMinutes;\n+\n+    @ConfigProperty(name = \"kogito.jobs-service.loadJobIntervalInMillis\", defaultValue = \"60000\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkxMjA0NQ=="}, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMTYyNDc0OnYy", "diffSide": "RIGHT", "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwODoxMzozOFrOFnc-bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNDoxMTo1OFrOFnncRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkxMzUxOQ==", "bodyText": "so the load of jobs will run every minute by default and the jobs to be loaded are for 10 min from current time. so that means every minute we load next 10 min of jobs. Isn't that we will get lot of duplicates to filter out?\nwouldn't it be better to run less frequently ... close to the chunk size/time and just to load next chunk and thus no need to filter out duplicates? This would make a real difference in case there are lot of jobs in given chunk.\nI don't think we need to worry about scheduled jobs in between (like the chunk that was already loaded) as this is already checked upon scheduling.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r376913519", "createdAt": "2020-02-10T08:13:38Z", "author": {"login": "mswiderski"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "diffHunk": "@@ -35,22 +40,49 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(JobSchedulerManager.class);\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")\n+    long schedulerChunkInMinutes;\n+\n+    @ConfigProperty(name = \"kogito.jobs-service.loadJobIntervalInMillis\", defaultValue = \"60000\")\n+    long loadJobIntervalInMillis;\n+\n     @Inject\n     VertxJobScheduler scheduler;\n \n     @Inject\n     ReactiveJobRepository repository;\n \n-    CompletionStage<Void> loadScheduledJobs(@Observes StartupEvent startupEvent) {\n-        LOGGER.info(\"Loading scheduled jobs\");\n-        return repository.findByStatus(JobStatus.SCHEDULED, JobStatus.RETRY)\n-                //is is necessary to skip error on the publisher to continue processing, otherwise the subscribe\n-                // terminated\n+    @Inject\n+    Vertx vertx;\n+\n+    void onStartup(@Observes StartupEvent startupEvent) {\n+        //first execution\n+        vertx.runOnContext(v -> loadScheduledJobs());\n+        //periodic execution\n+        vertx.setPeriodic(loadJobIntervalInMillis, id -> loadScheduledJobs());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAxMTQwNg==", "bodyText": "yeah, this is the point of getting the configuration property, it is easy to change, I think we can keep both intervals equals or very close to the chunk size, this is more efficient, I was testing with this more frequently load to see it the scheduling was running properly and avoiding duplication.\nSo I'll change the default values to be equals, 10min is ok in your point of view?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r377011406", "createdAt": "2020-02-10T11:39:06Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "diffHunk": "@@ -35,22 +40,49 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(JobSchedulerManager.class);\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")\n+    long schedulerChunkInMinutes;\n+\n+    @ConfigProperty(name = \"kogito.jobs-service.loadJobIntervalInMillis\", defaultValue = \"60000\")\n+    long loadJobIntervalInMillis;\n+\n     @Inject\n     VertxJobScheduler scheduler;\n \n     @Inject\n     ReactiveJobRepository repository;\n \n-    CompletionStage<Void> loadScheduledJobs(@Observes StartupEvent startupEvent) {\n-        LOGGER.info(\"Loading scheduled jobs\");\n-        return repository.findByStatus(JobStatus.SCHEDULED, JobStatus.RETRY)\n-                //is is necessary to skip error on the publisher to continue processing, otherwise the subscribe\n-                // terminated\n+    @Inject\n+    Vertx vertx;\n+\n+    void onStartup(@Observes StartupEvent startupEvent) {\n+        //first execution\n+        vertx.runOnContext(v -> loadScheduledJobs());\n+        //periodic execution\n+        vertx.setPeriodic(loadJobIntervalInMillis, id -> loadScheduledJobs());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkxMzUxOQ=="}, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAyMTc1MQ==", "bodyText": "yes, let's go with defaults to be the same value. in the end it is all configurable so can be adjusted as needed", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r377021751", "createdAt": "2020-02-10T12:02:27Z", "author": {"login": "mswiderski"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "diffHunk": "@@ -35,22 +40,49 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(JobSchedulerManager.class);\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")\n+    long schedulerChunkInMinutes;\n+\n+    @ConfigProperty(name = \"kogito.jobs-service.loadJobIntervalInMillis\", defaultValue = \"60000\")\n+    long loadJobIntervalInMillis;\n+\n     @Inject\n     VertxJobScheduler scheduler;\n \n     @Inject\n     ReactiveJobRepository repository;\n \n-    CompletionStage<Void> loadScheduledJobs(@Observes StartupEvent startupEvent) {\n-        LOGGER.info(\"Loading scheduled jobs\");\n-        return repository.findByStatus(JobStatus.SCHEDULED, JobStatus.RETRY)\n-                //is is necessary to skip error on the publisher to continue processing, otherwise the subscribe\n-                // terminated\n+    @Inject\n+    Vertx vertx;\n+\n+    void onStartup(@Observes StartupEvent startupEvent) {\n+        //first execution\n+        vertx.runOnContext(v -> loadScheduledJobs());\n+        //periodic execution\n+        vertx.setPeriodic(loadJobIntervalInMillis, id -> loadScheduledJobs());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkxMzUxOQ=="}, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4NDk5OQ==", "bodyText": "done", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r377084999", "createdAt": "2020-02-10T14:11:58Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "diffHunk": "@@ -35,22 +40,49 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(JobSchedulerManager.class);\n \n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\", defaultValue = \"10\")\n+    long schedulerChunkInMinutes;\n+\n+    @ConfigProperty(name = \"kogito.jobs-service.loadJobIntervalInMillis\", defaultValue = \"60000\")\n+    long loadJobIntervalInMillis;\n+\n     @Inject\n     VertxJobScheduler scheduler;\n \n     @Inject\n     ReactiveJobRepository repository;\n \n-    CompletionStage<Void> loadScheduledJobs(@Observes StartupEvent startupEvent) {\n-        LOGGER.info(\"Loading scheduled jobs\");\n-        return repository.findByStatus(JobStatus.SCHEDULED, JobStatus.RETRY)\n-                //is is necessary to skip error on the publisher to continue processing, otherwise the subscribe\n-                // terminated\n+    @Inject\n+    Vertx vertx;\n+\n+    void onStartup(@Observes StartupEvent startupEvent) {\n+        //first execution\n+        vertx.runOnContext(v -> loadScheduledJobs());\n+        //periodic execution\n+        vertx.setPeriodic(loadJobIntervalInMillis, id -> loadScheduledJobs());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkxMzUxOQ=="}, "originalCommit": {"oid": "fbd875fd8953210ee7010a7e631d53c0e6f94bdf"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTM4NTgyOnYy", "diffSide": "RIGHT", "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwOToyMTo0MlrOFom-Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNjozNTo0OVrOFo123g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEyNTgzMA==", "bodyText": "Can you please just quickly explain these 3 config parameters?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r378125830", "createdAt": "2020-02-12T09:21:42Z", "author": {"login": "MarianMacik"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -46,19 +49,29 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(BaseTimerJobScheduler.class);\n \n-    @ConfigProperty(name = \"kogito.jobs-service.backoffRetryMillis\", defaultValue = \"1000\")\n+    @ConfigProperty(name = \"kogito.jobs-service.backoffRetryMillis\")\n     long backoffRetryMillis;\n \n-    @ConfigProperty(name = \"kogito.jobs-service.maxIntervalLimitToRetryMillis\", defaultValue = \"60000\")\n+    @ConfigProperty(name = \"kogito.jobs-service.maxIntervalLimitToRetryMillis\")\n     long maxIntervalLimitToRetryMillis;\n \n+    /**\n+     * The current chunk size  in minutes the scheduler handles, it is used to keep a limit number of jobs scheduled\n+     * in the in-memory scheduler.\n+     */\n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\")\n+    long schedulerChunkInMinutes;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2860a9ef2e48a44a58368c91688fff2bb20aed73"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2Mjk0Ng==", "bodyText": "schedulerChunkInMinutes is the chunk size, represented in minutes, the chunk is an interval of time. This config will be on the wiki, the other two parameters are on the wiki already and represent the Retry configurations for backoff and the limit that is supposed to be retried.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r378362946", "createdAt": "2020-02-12T16:25:26Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -46,19 +49,29 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(BaseTimerJobScheduler.class);\n \n-    @ConfigProperty(name = \"kogito.jobs-service.backoffRetryMillis\", defaultValue = \"1000\")\n+    @ConfigProperty(name = \"kogito.jobs-service.backoffRetryMillis\")\n     long backoffRetryMillis;\n \n-    @ConfigProperty(name = \"kogito.jobs-service.maxIntervalLimitToRetryMillis\", defaultValue = \"60000\")\n+    @ConfigProperty(name = \"kogito.jobs-service.maxIntervalLimitToRetryMillis\")\n     long maxIntervalLimitToRetryMillis;\n \n+    /**\n+     * The current chunk size  in minutes the scheduler handles, it is used to keep a limit number of jobs scheduled\n+     * in the in-memory scheduler.\n+     */\n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\")\n+    long schedulerChunkInMinutes;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEyNTgzMA=="}, "originalCommit": {"oid": "2860a9ef2e48a44a58368c91688fff2bb20aed73"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2OTc1OA==", "bodyText": "@spolti  could you please open a jira to handle this property on operator side?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r378369758", "createdAt": "2020-02-12T16:35:49Z", "author": {"login": "ricardozanini"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -46,19 +49,29 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(BaseTimerJobScheduler.class);\n \n-    @ConfigProperty(name = \"kogito.jobs-service.backoffRetryMillis\", defaultValue = \"1000\")\n+    @ConfigProperty(name = \"kogito.jobs-service.backoffRetryMillis\")\n     long backoffRetryMillis;\n \n-    @ConfigProperty(name = \"kogito.jobs-service.maxIntervalLimitToRetryMillis\", defaultValue = \"60000\")\n+    @ConfigProperty(name = \"kogito.jobs-service.maxIntervalLimitToRetryMillis\")\n     long maxIntervalLimitToRetryMillis;\n \n+    /**\n+     * The current chunk size  in minutes the scheduler handles, it is used to keep a limit number of jobs scheduled\n+     * in the in-memory scheduler.\n+     */\n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\")\n+    long schedulerChunkInMinutes;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEyNTgzMA=="}, "originalCommit": {"oid": "2860a9ef2e48a44a58368c91688fff2bb20aed73"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTM5Njk0OnYy", "diffSide": "RIGHT", "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwOToyNDo1MlrOFonEww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNjoxOToyNFrOFo1Mpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEyNzU1NQ==", "bodyText": "Does this mean that the chunk is constantly moving?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r378127555", "createdAt": "2020-02-12T09:24:52Z", "author": {"login": "MarianMacik"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -98,11 +129,18 @@ public BaseTimerJobScheduler(JobExecutor jobExecutor,\n                         .status(JobStatus.SCHEDULED)\n                         .build())\n                 .map(scheduledJob -> jobRepository.save(scheduledJob))\n-                .flatMapCompletionStage(p -> p)\n-                .buildRs();\n+                .flatMapCompletionStage(p -> p);\n+    }\n+\n+    /**\n+     * Check if it should be scheduled (on the current chunk) or saved to be scheduled later.\n+     * @return\n+     */\n+    private boolean isOnCurrentSchedulerChunk(Job job) {\n+        return job.getExpirationTime().isBefore(DateUtil.now().plusMinutes(schedulerChunkInMinutes));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2860a9ef2e48a44a58368c91688fff2bb20aed73"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM1ODk1MQ==", "bodyText": "Yes, the chunk is based on time, so basically the chunk is the interval from now until the defined interval, for instance, 10 minutes. In this way, the scheduler keeps in memory only the next X jobs on the current chunk.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r378358951", "createdAt": "2020-02-12T16:19:24Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/BaseTimerJobScheduler.java", "diffHunk": "@@ -98,11 +129,18 @@ public BaseTimerJobScheduler(JobExecutor jobExecutor,\n                         .status(JobStatus.SCHEDULED)\n                         .build())\n                 .map(scheduledJob -> jobRepository.save(scheduledJob))\n-                .flatMapCompletionStage(p -> p)\n-                .buildRs();\n+                .flatMapCompletionStage(p -> p);\n+    }\n+\n+    /**\n+     * Check if it should be scheduled (on the current chunk) or saved to be scheduled later.\n+     * @return\n+     */\n+    private boolean isOnCurrentSchedulerChunk(Job job) {\n+        return job.getExpirationTime().isBefore(DateUtil.now().plusMinutes(schedulerChunkInMinutes));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEyNzU1NQ=="}, "originalCommit": {"oid": "2860a9ef2e48a44a58368c91688fff2bb20aed73"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTQ4MDUyOnYy", "diffSide": "RIGHT", "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwOTo0ODowMVrOFon3bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNjoyNzowOFrOFo1gcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0MDUyNQ==", "bodyText": "I guess this will run periodically so maybe changing log level to debug instead of info to not spam logs too much, wdyt?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r378140525", "createdAt": "2020-02-12T09:48:01Z", "author": {"login": "mswiderski"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "diffHunk": "@@ -35,22 +41,65 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(JobSchedulerManager.class);\n \n+    /**\n+     * The current chunk size  in minutes the scheduler handles, it is used to keep a limit number of jobs scheduled\n+     * in the in-memory scheduler.\n+     */\n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\")\n+    long schedulerChunkInMinutes;\n+\n+    /**\n+     * The interval the job loading method runs to fetch the persisted jobs from the repository.\n+     */\n+    @ConfigProperty(name = \"kogito.jobs-service.loadJobIntervalInMinutes\")\n+    long loadJobIntervalInMinutes;\n+\n     @Inject\n     VertxJobScheduler scheduler;\n \n     @Inject\n     ReactiveJobRepository repository;\n \n-    CompletionStage<Void> loadScheduledJobs(@Observes StartupEvent startupEvent) {\n-        LOGGER.info(\"Loading scheduled jobs\");\n-        return repository.findByStatus(JobStatus.SCHEDULED, JobStatus.RETRY)\n-                //is is necessary to skip error on the publisher to continue processing, otherwise the subscribe\n-                // terminated\n+    @Inject\n+    Vertx vertx;\n+\n+    void onStartup(@Observes StartupEvent startupEvent) {\n+        if (loadJobIntervalInMinutes > schedulerChunkInMinutes) {\n+            LOGGER.warn(\"The loadJobIntervalInMinutes ({}) cannot be greater than schedulerChunkInMinutes ({}), \" +\n+                                \"setting value {} for both\",\n+                        loadJobIntervalInMinutes,\n+                        schedulerChunkInMinutes,\n+                        schedulerChunkInMinutes);\n+            loadJobIntervalInMinutes = schedulerChunkInMinutes;\n+        }\n+\n+        //first execution\n+        vertx.runOnContext(v -> loadScheduledJobs());\n+        //periodic execution\n+        vertx.setPeriodic(TimeUnit.MINUTES.toMillis(loadJobIntervalInMinutes), id -> loadScheduledJobs());\n+    }\n+\n+    //Runs periodically loading the jobs from the repository in chunks\n+    void loadScheduledJobs() {\n+        loadJobsInCurrentChunk()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2860a9ef2e48a44a58368c91688fff2bb20aed73"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM1NzM0NA==", "bodyText": "I'll change to debug the log for each job and keep the completed job load with info, this is important to check it the loading jobs is running properly from time to time.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r378357344", "createdAt": "2020-02-12T16:17:00Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "diffHunk": "@@ -35,22 +41,65 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(JobSchedulerManager.class);\n \n+    /**\n+     * The current chunk size  in minutes the scheduler handles, it is used to keep a limit number of jobs scheduled\n+     * in the in-memory scheduler.\n+     */\n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\")\n+    long schedulerChunkInMinutes;\n+\n+    /**\n+     * The interval the job loading method runs to fetch the persisted jobs from the repository.\n+     */\n+    @ConfigProperty(name = \"kogito.jobs-service.loadJobIntervalInMinutes\")\n+    long loadJobIntervalInMinutes;\n+\n     @Inject\n     VertxJobScheduler scheduler;\n \n     @Inject\n     ReactiveJobRepository repository;\n \n-    CompletionStage<Void> loadScheduledJobs(@Observes StartupEvent startupEvent) {\n-        LOGGER.info(\"Loading scheduled jobs\");\n-        return repository.findByStatus(JobStatus.SCHEDULED, JobStatus.RETRY)\n-                //is is necessary to skip error on the publisher to continue processing, otherwise the subscribe\n-                // terminated\n+    @Inject\n+    Vertx vertx;\n+\n+    void onStartup(@Observes StartupEvent startupEvent) {\n+        if (loadJobIntervalInMinutes > schedulerChunkInMinutes) {\n+            LOGGER.warn(\"The loadJobIntervalInMinutes ({}) cannot be greater than schedulerChunkInMinutes ({}), \" +\n+                                \"setting value {} for both\",\n+                        loadJobIntervalInMinutes,\n+                        schedulerChunkInMinutes,\n+                        schedulerChunkInMinutes);\n+            loadJobIntervalInMinutes = schedulerChunkInMinutes;\n+        }\n+\n+        //first execution\n+        vertx.runOnContext(v -> loadScheduledJobs());\n+        //periodic execution\n+        vertx.setPeriodic(TimeUnit.MINUTES.toMillis(loadJobIntervalInMinutes), id -> loadScheduledJobs());\n+    }\n+\n+    //Runs periodically loading the jobs from the repository in chunks\n+    void loadScheduledJobs() {\n+        loadJobsInCurrentChunk()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0MDUyNQ=="}, "originalCommit": {"oid": "2860a9ef2e48a44a58368c91688fff2bb20aed73"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2NDAxNw==", "bodyText": "done", "url": "https://github.com/kiegroup/kogito-runtimes/pull/308#discussion_r378364017", "createdAt": "2020-02-12T16:27:08Z", "author": {"login": "tiagodolphine"}, "path": "addons/jobs/jobs-service/src/main/java/org/kie/kogito/jobs/service/scheduler/JobSchedulerManager.java", "diffHunk": "@@ -35,22 +41,65 @@\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(JobSchedulerManager.class);\n \n+    /**\n+     * The current chunk size  in minutes the scheduler handles, it is used to keep a limit number of jobs scheduled\n+     * in the in-memory scheduler.\n+     */\n+    @ConfigProperty(name = \"kogito.jobs-service.schedulerChunkInMinutes\")\n+    long schedulerChunkInMinutes;\n+\n+    /**\n+     * The interval the job loading method runs to fetch the persisted jobs from the repository.\n+     */\n+    @ConfigProperty(name = \"kogito.jobs-service.loadJobIntervalInMinutes\")\n+    long loadJobIntervalInMinutes;\n+\n     @Inject\n     VertxJobScheduler scheduler;\n \n     @Inject\n     ReactiveJobRepository repository;\n \n-    CompletionStage<Void> loadScheduledJobs(@Observes StartupEvent startupEvent) {\n-        LOGGER.info(\"Loading scheduled jobs\");\n-        return repository.findByStatus(JobStatus.SCHEDULED, JobStatus.RETRY)\n-                //is is necessary to skip error on the publisher to continue processing, otherwise the subscribe\n-                // terminated\n+    @Inject\n+    Vertx vertx;\n+\n+    void onStartup(@Observes StartupEvent startupEvent) {\n+        if (loadJobIntervalInMinutes > schedulerChunkInMinutes) {\n+            LOGGER.warn(\"The loadJobIntervalInMinutes ({}) cannot be greater than schedulerChunkInMinutes ({}), \" +\n+                                \"setting value {} for both\",\n+                        loadJobIntervalInMinutes,\n+                        schedulerChunkInMinutes,\n+                        schedulerChunkInMinutes);\n+            loadJobIntervalInMinutes = schedulerChunkInMinutes;\n+        }\n+\n+        //first execution\n+        vertx.runOnContext(v -> loadScheduledJobs());\n+        //periodic execution\n+        vertx.setPeriodic(TimeUnit.MINUTES.toMillis(loadJobIntervalInMinutes), id -> loadScheduledJobs());\n+    }\n+\n+    //Runs periodically loading the jobs from the repository in chunks\n+    void loadScheduledJobs() {\n+        loadJobsInCurrentChunk()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0MDUyNQ=="}, "originalCommit": {"oid": "2860a9ef2e48a44a58368c91688fff2bb20aed73"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 296, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}