{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MjUwODIz", "number": 416, "title": "[KOGITO-1248] Add process generation tests and some fixes", "bodyText": "Signed-off-by: ruromero rromerom@redhat.com\nAdded a ProcessGenerationTest class that uses all the existing bpmn files in the kogito-codegen project and validates that the parsed process is equivalent to the one code-generated.\nThe following issues were found and addressed during the execution of the tests:\n\nProcess imports were being overwritten, now they are appended\nScope was not being set for the BoundaryEventNodeVisitor\nThe outMappings were not being added to the startNode\nTriggers were not properly added to the startNode. There was always an empty trigger. Now it is only added when is not event driven.", "createdAt": "2020-04-03T15:49:46Z", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416", "merged": true, "mergeCommit": {"oid": "3ee2e738170f7a0e5ab3ebfd6a521c821440cee8"}, "closed": true, "closedAt": "2020-04-17T09:26:50Z", "author": {"login": "ruromero"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcUC9TMABqjMxOTY5ODk0MDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYcqrEgH2gAyMzk4MjUwODIzOjNkYjI5ZDY5OTkyNTc3ZGE2M2FmMjQzMjM1Y2FkOTMxYzk5OWFkZTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7ca4ba1769ed6a3ba3cecc6a868fe27ca6c8db8e", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7ca4ba1769ed6a3ba3cecc6a868fe27ca6c8db8e", "committedDate": "2020-04-03T15:46:16Z", "message": "[KOGITO-1248] Add process generation tests and some fixes\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}, "afterCommit": {"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/92a68ace794f9dec3b20b08c3bf7499f440fccf5", "committedDate": "2020-04-03T15:51:09Z", "message": "[KOGITO-1248] Add process generation tests and some fixes\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NDU4NDk2", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#pullrequestreview-389458496", "createdAt": "2020-04-07T20:18:16Z", "commit": {"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoxODoxNlrOGCUfag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDozMDo0NFrOGCU6uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NjA1OA==", "bodyText": "I think you can use the already defined method on AbstractVisitor, \n  \n    \n      kogito-runtimes/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/AbstractVisitor.java\n    \n    \n         Line 163\n      in\n      e785096\n    \n    \n    \n    \n\n        \n          \n           protected void addNodeMappings(Mappable node, BlockStmt body, String variableName) { \n        \n    \n  \n\n\nBut it is at least strange the things are working without this mapping... and probably it would be necessary on other visitors like EventNode, EndNode, etc... WDYT?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405086058", "createdAt": "2020-04-07T20:18:16Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -51,7 +51,7 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n-        \n+        startNode.getOutMappings().forEach((k, v) -> addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"addOutMapping\", new StringLiteralExpr(k), new StringLiteralExpr(v)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MjQzNw==", "bodyText": "you can follow the same name pattern for other NodeFactories, like HumanTaskNodeFactory.outMapping.. but as I said on the other comment why this call was not necessary for other nodes, like EventNode, EndNode, etc...", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405092437", "createdAt": "2020-04-07T20:29:35Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/StartNodeFactory.java", "diffHunk": "@@ -50,6 +50,11 @@ public StartNodeFactory interrupting(boolean interrupting) {\n         getStartNode().setInterrupting(interrupting);\n         return this;\n     }\n+\n+    public StartNodeFactory addOutMapping(String parameterName, String variableName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MzA1MQ==", "bodyText": "maybe a simple javadoc comment to explain the purpose of the class...", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405093051", "createdAt": "2020-04-07T20:30:44Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.assertj.core.api.ThrowableAssert;\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.*;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ProcessGenerationTest extends AbstractCodegenTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjUxODUw", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#pullrequestreview-392651850", "createdAt": "2020-04-14T07:02:41Z", "commit": {"oid": "9a2e041f43c979b5952acc8a4a274e5292206ac4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzowMjo0MVrOGFAzhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzowMjo0MVrOGFAzhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwOTI1NA==", "bodyText": "we had to revert to JDK 8 compatibility on 0.9.x branch. We will merge this back on master too. This is therefore not a valid method call.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r407909254", "createdAt": "2020-04-14T07:02:41Z", "author": {"login": "evacchi"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -97,12 +97,12 @@ public RuleFlowProcessFactory packageName(String packageName) {\n     }\n \n     public RuleFlowProcessFactory imports(String... imports) {\n-    \tgetRuleFlowProcess().setImports(new HashSet<String>(Arrays.asList(imports)));\n+        getRuleFlowProcess().getImports().addAll(Set.of(imports));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a2e041f43c979b5952acc8a4a274e5292206ac4"}, "originalPosition": 16}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43c8c64ae895582b77357818a807320aa59ccc2a", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/43c8c64ae895582b77357818a807320aa59ccc2a", "committedDate": "2020-04-15T08:36:56Z", "message": "[KOGITO-1248] Stick to jdk8\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}, "afterCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/eac934e923ddfa7417d6a47493e8c86e59176f34", "committedDate": "2020-04-15T08:52:57Z", "message": "[KOGITO-1248] Stick to jdk8\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNjE2NDEy", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#pullrequestreview-393616412", "createdAt": "2020-04-15T09:42:13Z", "commit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo0MjoxM1rOGFx6yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxMDoxMTowMVrOGFy9yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMzkzMA==", "bodyText": "Probably would be nicer to have a dedicated addAll() method for this as adding something using getters may be considered as bad practice. But if we cannot/don't want to change the interfaces, I'm fine with that.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408713930", "createdAt": "2020-04-15T09:42:13Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -97,12 +97,12 @@ public RuleFlowProcessFactory packageName(String packageName) {\n     }\n \n     public RuleFlowProcessFactory imports(String... imports) {\n-    \tgetRuleFlowProcess().setImports(new HashSet<String>(Arrays.asList(imports)));\n+        getRuleFlowProcess().getImports().addAll(Arrays.asList(imports));\n         return this;\n     }\n     \n     public RuleFlowProcessFactory functionImports(String... functionImports) {\n-    \tgetRuleFlowProcess().setFunctionImports(Arrays.asList(functionImports));\n+        getRuleFlowProcess().getFunctionImports().addAll(Arrays.asList(functionImports));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTI4Mw==", "bodyText": "Gereration -> Generation :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408725283", "createdAt": "2020-04-15T10:00:53Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTU1NA==", "bodyText": "This will be implemented in the future? If so, we can link a JIRA here so we won't forget.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408725554", "createdAt": "2020-04-15T10:01:23Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTY0Mg==", "bodyText": "Same for these.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408725642", "createdAt": "2020-04-15T10:01:33Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNzQyNA==", "bodyText": "Maybe an improvement - assert also the size of the maps? This way it will be sure that there is nothing redundant on the current side.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408727424", "createdAt": "2020-04-15T10:04:36Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyOTM4Ng==", "bodyText": "Same here.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408729386", "createdAt": "2020-04-15T10:07:59Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyOTcxNg==", "bodyText": "Formatting here.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408729716", "createdAt": "2020-04-15T10:08:34Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) ignoredKeys = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMDE5Ng==", "bodyText": "Again probably asserting on the size would be beneficial?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408730196", "createdAt": "2020-04-15T10:09:22Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMTA4Mw==", "bodyText": "@evacchi probably?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408731083", "createdAt": "2020-04-15T10:11:01Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) ignoredKeys = new HashSet<>();\n+        expected.keySet()\n+                .stream()\n+                .filter(Predicate.not(ignoredKeys::contains))\n+                .forEach(k -> assertEquals(expected.get(k), current.get(k), \"Metadata \"+ k));\n+    }\n+\n+    private static void assertConnections(Map<String, List<Connection>> expectedConnections, Map<String, List<Connection>> currentConnections) {\n+        assertEquals(expectedConnections.size(), currentConnections.size());\n+        expectedConnections.forEach((type, expectedByType) -> {\n+            assertTrue(currentConnections.containsKey(type), \"Node does not have connections of type: \" + type);\n+            List<Connection> currentByType = currentConnections.get(type);\n+            expectedByType.forEach(expected -> {\n+                Optional<Connection> current = currentByType\n+                        .stream()\n+                        .filter(c -> expected.getMetaData().isEmpty() || expected.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\")))\n+                        .findFirst();\n+                assertTrue(current.isPresent(), \"Connection is present for \" + expected.getMetaData().get(\"UniqueId\"));\n+                assertEquals(expected.getFromType(), current.get().getFromType(), \"FromType\");\n+                assertEquals(expected.getFrom().getId(), current.get().getFrom().getId(), \"From.Id\");\n+                assertEquals(expected.getToType(), current.get().getToType(), \"ToType\");\n+                assertEquals(expected.getTo().getId(), current.get().getTo().getId(), \"To.Id\");\n+            });\n+        });\n+    }\n+\n+    private static void assertTriggers(List<Trigger> expected, List<Trigger> current) {\n+        try {\n+            if (expected == null) {\n+                assertNull(current);\n+                return;\n+            }\n+            assertNotNull(current);\n+            assertEquals(expected.size(), current.size());\n+            for (int i = 0; i < expected.size(); i++) {\n+                Trigger e = expected.get(i);\n+                Trigger c = current.get(i);\n+                e.getInMappings().forEach((k, v) -> assertEquals(v, c.getInMapping(k), \"InMapping for \" + k));\n+                assertDataAssociations(e.getInAssociations(), c.getInAssociations());\n+            }\n+        } catch (Throwable e) {\n+            fail(\"Triggers are not equal\", e);\n+        }\n+    }\n+\n+    private static void assertDataAssociations(List<DataAssociation> expected, List<DataAssociation> current) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        if (expected.isEmpty()) {\n+            assertEquals(1, current.size());\n+            assertEquals(1, current.get(0).getSources().size());\n+            assertEquals(\"\", current.get(0).getSources().get(0));\n+        } else {\n+            assertEquals(expected.size(), current.size());\n+            for (int i = 0; i < expected.size(); i++) {\n+                assertEquals(expected.get(i).getSources(), current.get(i).getSources(), \"Sources\");\n+                assertEquals(expected.get(i).getTarget(), current.get(i).getTarget(), \"Target\");\n+                assertEquals(expected.get(i).getTransformation(), current.get(i).getTransformation(), \"Transformation\");\n+                assertAssignments(expected.get(i).getAssignments(), current.get(i).getAssignments());\n+            }\n+        }\n+    }\n+\n+    private static void assertActions(List<DroolsAction> expected, List<DroolsAction> current) {\n+        assertEquals(expected.size(), current.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            assertEquals(((DroolsConsequenceAction) expected.get(i)).getDialect(), ((DroolsConsequenceAction) current.get(i)).getDialect(), \"Dialect\");\n+            assertEquals(((DroolsConsequenceAction) expected.get(i)).getConsequence(), ((DroolsConsequenceAction) current.get(i)).getConsequence(), \"Consequence\");\n+        }\n+    }\n+\n+    private static void assertAssignments(List<Assignment> expected, List<Assignment> current) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertEquals(expected.size(), current.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            assertEquals(expected.get(i).getFrom(), current.get(i).getFrom(), \"From\");\n+            assertEquals(expected.get(i).getDialect(), current.get(i).getDialect(), \"Dialect\");\n+            assertEquals(expected.get(i).getTo(), current.get(i).getTo(), \"To\");\n+        }\n+    }\n+\n+    private static void assertTimers(Map<Timer, DroolsAction> expected, Map<Timer, DroolsAction> current) {\n+        if(expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        assertEquals(expected.size(), current.size(), \"Size\");\n+        expected.forEach((expectedTimer, expectedAction) -> {\n+            Optional<Timer> currentTimer = current.keySet().stream().filter(c -> c.getId() == expectedTimer.getId()).findFirst();\n+            assertTrue(currentTimer.isPresent());\n+            assertEquals(expectedTimer.getPeriod(), currentTimer.get().getPeriod(), \"Period\");\n+            assertEquals(expectedTimer.getDate(), currentTimer.get().getDate(), \"Date\");\n+            assertEquals(expectedTimer.getDelay(), currentTimer.get().getDelay(), \"Delay\");\n+            assertEquals(expectedTimer.getTimeType(), currentTimer.get().getTimeType(), \"TimeType\");\n+            DroolsAction currentAction = current.get(currentTimer.get());\n+            if(expectedAction == null) {\n+                assertNull(currentAction);\n+                return;\n+            }\n+            assertNotNull(currentAction);\n+            assertEquals(expectedAction.getName(), currentAction.getName(), \"DroolsAction name\");\n+            //TODO: Is this expected? They are totally different objects. Expected DroolsConsequenceAction, Got lambda\n+            // assertEquals(expectedAction.getMetaData(DroolsAction.METADATA_ACTION), currentAction.getMetaData(DroolsAction.METADATA_ACTION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34"}, "originalPosition": 424}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzOTIwNDA2", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#pullrequestreview-393920406", "createdAt": "2020-04-15T16:04:56Z", "commit": {"oid": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjowNDo1NlrOGGA5bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNjowNzo0NFrOGGBAdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1OTM0MA==", "bodyText": "Come on, formatting again? You can do better \ud83e\udd23", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408959340", "createdAt": "2020-04-15T16:04:56Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.process.instance.impl.ReturnValueConstraintEvaluator;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ConstraintImpl;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGeneration);\n+    }\n+\n+    private void testProcessGeneration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+            if(expected.getVersion() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1OTk4NA==", "bodyText": "Formatting.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408959984", "createdAt": "2020-04-15T16:06:01Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.process.instance.impl.ReturnValueConstraintEvaluator;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ConstraintImpl;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGeneration);\n+    }\n+\n+    private void testProcessGeneration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+            if(expected.getVersion() != null) {\n+                assertEquals(expected.getVersion(), current.getVersion());\n+            } else {\n+                assertEquals(\"1.0\", current.getVersion());\n+            }\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+        if(expected.getName() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2MTE0Mw==", "bodyText": "Still formatting.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408961143", "createdAt": "2020-04-15T16:07:44Z", "author": {"login": "MarianMacik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.process.instance.impl.ReturnValueConstraintEvaluator;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ConstraintImpl;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGeneration);\n+    }\n+\n+    private void testProcessGeneration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+            if(expected.getVersion() != null) {\n+                assertEquals(expected.getVersion(), current.getVersion());\n+            } else {\n+                assertEquals(\"1.0\", current.getVersion());\n+            }\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+        if(expected.getName() != null) {\n+            assertEquals(expected.getName(), current.getName());\n+        } else {\n+            assertNotNull(current.getName());\n+        }\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+        assertConstraints((NodeImpl) expected, (NodeImpl) current);\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported - KOGITO-1709\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        assertEquals(expected.getInMappings().size(), current.getInMappings().size(), \"inMappings\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        assertEquals(expected.getOutMappings().size(), current.getOutMappings().size(), \"outMappings\");\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", expected.getClass().getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb"}, "originalPosition": 331}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDg4OTIw", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#pullrequestreview-394088920", "createdAt": "2020-04-15T19:55:22Z", "commit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDkwODYw", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#pullrequestreview-394090860", "createdAt": "2020-04-15T19:58:15Z", "commit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzEwNDcy", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#pullrequestreview-394310472", "createdAt": "2020-04-16T05:35:33Z", "commit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTozNTozM1rOGGVPlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo1NjoyMFrOGGVp-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5MjY5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n          \n          \n            \n             * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n          \n      \n    \n    \n  \n\n:D", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409292692", "createdAt": "2020-04-16T05:35:33Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Njc0Ng==", "bodyText": "@ruromero could you turn this test into a parametrized test, so each file is a different instance. That also helps to clearly distinguish which file fails.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409296746", "createdAt": "2020-04-16T05:48:25Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Nzc1NA==", "bodyText": "would also suggest here that instead of having to keep a list in a file, we do a find and include all .bpmn2 with some exclusions based on limitations. That way any new .bpmn would be automatically pickup by the test, wdyt?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409297754", "createdAt": "2020-04-16T05:51:32Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5OTQ0OA==", "bodyText": "@ruromero so what is the main reason for the changes here? for instance, we now would have the setInMappings and  addInMapping that would throw exception but these method wouldnt.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409299448", "createdAt": "2020-04-16T05:56:20Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/StartNode.java", "diffHunk": "@@ -118,12 +118,12 @@ public void setInMappings(Map<String, String> inMapping) {\n \n     @Override\n     public String getInMapping(String parameterName) {\n-        throw new IllegalArgumentException(\"A start event [\" + this.getMetaData(\"UniqueId\") + \", \" + this.getName() + \"] does not support input mappings\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NTg4OTY2", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#pullrequestreview-394588966", "createdAt": "2020-04-16T12:38:18Z", "commit": {"oid": "c42b301e037b30d34a7e7eab711ce2064a62db9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjozODoxOFrOGGjN3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjozODoxOFrOGGjN3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMTYyOQ==", "bodyText": "@ruromero I think the best approach here would be to use this https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-sources-MethodSource, a method source, so each file name is a parameter to testProcessGeneration.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409521629", "createdAt": "2020-04-16T12:38:18Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -91,18 +96,28 @@\n public class ProcessGenerationTest extends AbstractCodegenTest {\n \n     private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n-\n-    @Test\n-    public void testProcessesGeneration() throws IOException {\n-        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n-                .filter(f -> !f.startsWith(\"#\"))\n+    private static final Path BASE_PATH = Path.of(\"src/test/resources\");\n+    private static final Collection<String> PROCESS_EXTENSIONS = Arrays.asList(\".bpmn2\", \".bpmn\");\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"decision\", \"event-subprocess\", \"gateway\", \"messageevent\", \"messagestartevent\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c42b301e037b30d34a7e7eab711ce2064a62db9a"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NTg5NDIz", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#pullrequestreview-394589423", "createdAt": "2020-04-16T12:38:53Z", "commit": {"oid": "c42b301e037b30d34a7e7eab711ce2064a62db9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjozODo1M1rOGGjPPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjozODo1M1rOGGjPPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMTk4MA==", "bodyText": "@ruromero cool, best of both approaches :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409521980", "createdAt": "2020-04-16T12:38:53Z", "author": {"login": "cristianonicolai"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -91,18 +96,28 @@\n public class ProcessGenerationTest extends AbstractCodegenTest {\n \n     private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n-\n-    @Test\n-    public void testProcessesGeneration() throws IOException {\n-        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n-                .filter(f -> !f.startsWith(\"#\"))\n+    private static final Path BASE_PATH = Path.of(\"src/test/resources\");\n+    private static final Collection<String> PROCESS_EXTENSIONS = Arrays.asList(\".bpmn2\", \".bpmn\");\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"decision\", \"event-subprocess\", \"gateway\", \"messageevent\", \"messagestartevent\",\n+            \"org/kie/kogito/codegen/tests\", \"ruletask\", \"servicetask\", \"signalevent\", \"subprocess\",\n+            \"timer\", \"usertask\"})\n+    public void testProcessesGeneration(String folderName) throws IOException {\n+        Set<String> ignoredFiles = Files.lines(BASE_PATH.resolve(\"org/kie/kogito/codegen/process/process-generation-test.skip.txt\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c42b301e037b30d34a7e7eab711ce2064a62db9a"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c54b88844035232a1faca3ca6d562e0295a480a", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/3c54b88844035232a1faca3ca6d562e0295a480a", "committedDate": "2020-04-16T14:29:46Z", "message": "[KOGITO-1248] Add process generation tests and some fixes\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7172316848c4296cd911a192be1a18f596707f18", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7172316848c4296cd911a192be1a18f596707f18", "committedDate": "2020-04-16T14:29:46Z", "message": "[KOGITO-1248] Add javadoc and reuse mappings method\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37fcf7d6970207ce7117934d1285d39e1dc1b9af", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/37fcf7d6970207ce7117934d1285d39e1dc1b9af", "committedDate": "2020-04-16T14:29:46Z", "message": "[KOGITO-1248] Revert addMappings. StartEvent does not support it\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dab8574c6600ea0607d549c2c836c858ace176e5", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/dab8574c6600ea0607d549c2c836c858ace176e5", "committedDate": "2020-04-16T14:29:46Z", "message": "[KOGITO-1248] Add mappings and don't throw exception\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb9416634405e5b5cedd06df985365d479b4c055", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/fb9416634405e5b5cedd06df985365d479b4c055", "committedDate": "2020-04-16T14:29:46Z", "message": "[KOGITO-1248] Avoid using outMappings in the factory\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "551bd496e6c6d5a6fa4d5a67967b9ad0c759f131", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/551bd496e6c6d5a6fa4d5a67967b9ad0c759f131", "committedDate": "2020-04-16T14:29:46Z", "message": "[KOGITO-1248] use emptyMap/emptyList\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d02a131bbf72fa04275a2a7a2f49fffe6e4b94aa", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/d02a131bbf72fa04275a2a7a2f49fffe6e4b94aa", "committedDate": "2020-04-16T14:29:46Z", "message": "[KOGITO-1248] Stick to jdk8\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2b197e10e5837883e35ecb0e4fdd865c0cd1f05", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f2b197e10e5837883e35ecb0e4fdd865c0cd1f05", "committedDate": "2020-04-16T14:29:46Z", "message": "[KOGITO-1248] Apply review changes\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a46ba0553bb276ed4312073f1df8cb7dabcc0b62", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a46ba0553bb276ed4312073f1df8cb7dabcc0b62", "committedDate": "2020-04-16T14:29:46Z", "message": "[KOGITO-1248] Fix formatting and remove TODO\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "730b571222cb1434b7e8b85a92612f288810dc76", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/730b571222cb1434b7e8b85a92612f288810dc76", "committedDate": "2020-04-16T14:29:46Z", "message": "Update kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java\n\nCo-Authored-By: Cristiano Nicolai <cristiano.nicolai@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de6ed7fcd19e801f5f52de6fbee33db916b4d8df", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/de6ed7fcd19e801f5f52de6fbee33db916b4d8df", "committedDate": "2020-04-16T14:29:46Z", "message": "[KOGITO-1248] Find processes in parameterized folder\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9df5347ce905c7069cc5fbd48185a1ef2c2b5c8", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a9df5347ce905c7069cc5fbd48185a1ef2c2b5c8", "committedDate": "2020-04-16T14:30:28Z", "message": "[KOGITO-1248] Use MethodSource\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00102b8f4006663c417ff67341eae2423ebc5d67", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/00102b8f4006663c417ff67341eae2423ebc5d67", "committedDate": "2020-04-16T13:04:18Z", "message": "[KOGITO-1248] Use MethodSource\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}, "afterCommit": {"oid": "a9df5347ce905c7069cc5fbd48185a1ef2c2b5c8", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a9df5347ce905c7069cc5fbd48185a1ef2c2b5c8", "committedDate": "2020-04-16T14:30:28Z", "message": "[KOGITO-1248] Use MethodSource\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0ODUwMDU0", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#pullrequestreview-394850054", "createdAt": "2020-04-16T17:28:46Z", "commit": {"oid": "a9df5347ce905c7069cc5fbd48185a1ef2c2b5c8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3db29d69992577da63af243235cad931c999ade4", "author": {"user": {"login": "ruromero", "name": "Ruben Romero Montes"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/3db29d69992577da63af243235cad931c999ade4", "committedDate": "2020-04-17T08:04:13Z", "message": "[KOGITO-1248] Avoid java11 methods\n\nSigned-off-by: ruromero <rromerom@redhat.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3620, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}