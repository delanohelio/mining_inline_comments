{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMDE2MTkx", "number": 749, "title": "[KOGITO-3221] Fix kogito-runtimes for MiningModel", "bodyText": "@danielezonca @mariofusco @jiripetrlik\nSee https://issues.redhat.com/browse/KOGITO-3221\nThis PR\n\nUses KiePMMLMiningModelWithSources.nestedModels list for nested model generation/compilation\nCode-generate  org.kie.kogito.prediction.PredictionRuleMappers to map \"nested\" org.kie.kogito.prediction.PredictionRuleMapper  used to instantiate \"Rules\" network\n\nThis PR depends on kiegroup/drools#3084", "createdAt": "2020-09-08T12:46:09Z", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749", "merged": true, "mergeCommit": {"oid": "21026e962a37cfbe257f64c2c48d5dcc4d06ff57"}, "closed": true, "closedAt": "2020-09-15T11:30:14Z", "author": {"login": "gitgabrio"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdGyu2AAH2gAyNDgyMDE2MTkxOjQzNWYyZGIyYWMzMjJiYjZiZjFlYTExMmE2MDcwYjdjODY2ZjAxMzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJGHYngFqTQ4ODU4NjU5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "435f2db2ac322bb6bf1ea112a6070b7c866f0134", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/435f2db2ac322bb6bf1ea112a6070b7c866f0134", "committedDate": "2020-09-08T07:47:12Z", "message": "[KOGITO-3221] Ignoring directory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc01a1b03768c95a3115a8dd8223805dac60d343", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/cc01a1b03768c95a3115a8dd8223805dac60d343", "committedDate": "2020-09-08T08:30:00Z", "message": "[KOGITO-3221] Managing nested models of PMML MiningModel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b65bf508b5f2f690ea6dff274077888a811522e", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9b65bf508b5f2f690ea6dff274077888a811522e", "committedDate": "2020-09-08T08:30:13Z", "message": "Merge remote-tracking branch 'origin/master' into KOGITO-3221"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "123e02121f82e11f2bcf2e97d53bb62e127cd7fd", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/123e02121f82e11f2bcf2e97d53bb62e127cd7fd", "committedDate": "2020-09-09T14:30:53Z", "message": "Merge remote-tracking branch 'origin/master' into KOGITO-3221\n\n# Conflicts:\n#\tdrools/drools-core-static/src/main/java/org/drools/statics/StaticServiceRegistry.java\n#\tkogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionCodegen.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60cc81b6af98b9cde4e11f9fb12d80008b8d8d38", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/60cc81b6af98b9cde4e11f9fb12d80008b8d8d38", "committedDate": "2020-09-09T14:32:34Z", "message": "[KOGITO-3221] Merged master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NzQxMzk5", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#pullrequestreview-485741399", "createdAt": "2020-09-10T09:17:04Z", "commit": {"oid": "60cc81b6af98b9cde4e11f9fb12d80008b8d8d38"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOToxNzowNVrOHPqsZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOToxNzo1N1rOHPqudg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MDE4MA==", "bodyText": "Please remove comment.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486190180", "createdAt": "2020-09-10T09:17:05Z", "author": {"login": "jiripetrlik"}, "path": "kogito-build-parent/pom.xml", "diffHunk": "@@ -129,7 +129,8 @@\n     <version.org.keycloak>11.0.0</version.org.keycloak>\n     <version.org.mockito>3.3.3</version.org.mockito>\n     <version.org.mvel>2.4.7.Final</version.org.mvel>\n-    <version.org.kie7>7.43.0.t20200824</version.org.kie7>\n+<!--    <version.org.kie7>7.43.0.t20200824</version.org.kie7>-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60cc81b6af98b9cde4e11f9fb12d80008b8d8d38"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MDcxMA==", "bodyText": "I would suggest to use some logger instead.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486190710", "createdAt": "2020-09-10T09:17:57Z", "author": {"login": "jiripetrlik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/prediction/PredictionRuleMappersGeneratorTest.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.kie.kogito.codegen.prediction;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class PredictionRuleMappersGeneratorTest {\n+\n+    @Test\n+    void getPredictionRuleMapperSource() {\n+        final String predictionRuleMapper = \"PredictionRuleMapperImpl\";\n+        final String packageName = \"PACKAGE\";\n+        final List<String> generatedRuleMappers = IntStream.range(0, 4).mapToObj(index -> packageName + \".\" +\n+                \"subPack\" + index + \".\" + predictionRuleMapper).collect(Collectors.toList());\n+        String retrieved = PredictionRuleMappersGenerator.getPredictionRuleMappersSource(packageName,\n+                                                                                        generatedRuleMappers);\n+        assertNotNull(retrieved);\n+        String expected = String.format(\"package %s;\", packageName);\n+        assertTrue(retrieved.contains(expected));\n+        List<String> mod = generatedRuleMappers.stream().map(gen -> \"new \" + gen + \"()\").collect(Collectors.toList());\n+        expected = \"Arrays.asList(\" + String.join(\", \", mod) + \");\";\n+        assertTrue(retrieved.contains(expected));\n+        System.out.println(retrieved);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60cc81b6af98b9cde4e11f9fb12d80008b8d8d38"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1532ae6a0a71cacb790dd6fcb8aa9194cfe2d155", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1532ae6a0a71cacb790dd6fcb8aa9194cfe2d155", "committedDate": "2020-09-10T09:30:24Z", "message": "[KOGITO-3221] Fixed as per PR suggestion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "028b118d8ee2502486a0b689606e609c4c641205", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/028b118d8ee2502486a0b689606e609c4c641205", "committedDate": "2020-09-10T09:32:00Z", "message": "[KOGITO-3221] Fixed as per PR suggestion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/89cb14decb20502abd76fa08fb1a680f551d3b48", "committedDate": "2020-09-10T09:35:24Z", "message": "Merge remote-tracking branch 'origin/master' into KOGITO-3221\n\n# Conflicts:\n#\tdrools/kogito-pmml/src/test/java/org/kie/kogito/pmml/PmmlPredictionModelTest.java\n#\tkogito-build-parent/pom.xml"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2Mjk3MzA2", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#pullrequestreview-486297306", "createdAt": "2020-09-10T20:45:55Z", "commit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo0NTo1NVrOHQFIPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo1MzozMFrOHQFXEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzI5NQ==", "bodyText": "What about catch ReflectiveOperationException so that we can simplify and cover all reflection related exceptions just with one?  Only ClassCastExpection will probably remain in addition", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486623295", "createdAt": "2020-09-10T20:45:55Z", "author": {"login": "danielezonca"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/KieRuntimeFactoryBuilder.java", "diffHunk": "@@ -70,63 +73,65 @@ private KieRuntimeFactoryBuilder() {\n             final BiFunction<KnowledgeBuilderImpl, Resource, List<KiePMMLModel>> modelProducer) {\n         final Map<KieBase, KieRuntimeFactory> toReturn = new HashMap<>();\n         resources.forEach(resource -> {\n-            final String[] factoryClassNamePackageName = getFactoryClassNamePackageName(resource);\n             final KnowledgeBuilderImpl kbuilderImpl = createKnowledgeBuilderImpl(resource);\n             List<KiePMMLModel> toAdd = modelProducer.apply(kbuilderImpl, resource);\n             if (toAdd.isEmpty()) {\n                 throw new KiePMMLException(\"Failed to retrieve compiled models\");\n             }\n-            for (KiePMMLModel kiePMMLModel : toAdd) {\n-                InternalKnowledgePackage internalKnowledgePackage =\n-                        kbuilderImpl.getKnowledgeBase().getPackage(factoryClassNamePackageName[1]);\n-                if (internalKnowledgePackage == null) {\n-                    PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n-                    PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n-                    internalKnowledgePackage = pkgReg.getPackage();\n-                }\n-                PMMLPackage pmmlPkg =\n-                        internalKnowledgePackage.getResourceTypePackages().computeIfAbsent(\n-                                ResourceType.PMML,\n-                                rtp -> new PMMLPackageImpl());\n-                pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n-            }\n+            addModels(kbuilderImpl, toAdd);\n             KieBase kieBase = kbuilderImpl.getKnowledgeBase();\n             toReturn.put(kieBase, KieRuntimeFactory.of(kieBase));\n         });\n         return toReturn;\n     }\n \n+    private static void addModels(final KnowledgeBuilderImpl kbuilderImpl, final List<KiePMMLModel> toAdd) {\n+        for (KiePMMLModel kiePMMLModel : toAdd) {\n+            PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n+            PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n+            InternalKnowledgePackage kpkgs = pkgReg.getPackage();\n+            PMMLPackage pmmlPkg =\n+                    kpkgs.getResourceTypePackages().computeIfAbsent(\n+                            ResourceType.PMML,\n+                            rtp -> new PMMLPackageImpl());\n+            pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n+            if (kiePMMLModel instanceof HasNestedModels) {\n+                addModels(kbuilderImpl, ((HasNestedModels) kiePMMLModel).getNestedModels());\n+            }\n+        }\n+    }\n+\n     private static KnowledgeBuilderImpl createKnowledgeBuilderImpl(final Resource resource) {\n         KnowledgeBaseImpl defaultKnowledgeBase = new KnowledgeBaseImpl(\"PMML\", null);\n         KnowledgeBuilderImpl toReturn = new KnowledgeBuilderImpl(defaultKnowledgeBase);\n-        PredictionRuleMapper pmmlRuleMapper = loadPMMLRuleMapper(toReturn.getRootClassLoader(), resource);\n-        if (pmmlRuleMapper != null) {\n-            String ruleName = pmmlRuleMapper.getRuleName();\n-            Model model = loadModel(toReturn.getRootClassLoader(), ruleName);\n-            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(model));\n+        List<PredictionRuleMapper> pmmlRuleMappers = loadPMMLRuleMappers(toReturn.getRootClassLoader(), resource);\n+        if (!pmmlRuleMappers.isEmpty()) {\n+            List<Model> models =\n+                    pmmlRuleMappers.stream()\n+                            .map(PredictionRuleMapper::getModel)\n+                            .collect(Collectors.toList());\n+            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(models));\n         }\n         return toReturn;\n     }\n \n-    private static PredictionRuleMapper loadPMMLRuleMapper(final ClassLoader classLoader,\n-                                                           final Resource resource) {\n+    private static List<PredictionRuleMapper> loadPMMLRuleMappers(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n+        PredictionRuleMappers predictionRuleMappers = loadPMMLRuleMappersClass(classLoader, resource);\n+        return predictionRuleMappers.getPredictionRuleMappers();\n+    }\n+\n+    private static PredictionRuleMappers loadPMMLRuleMappersClass(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n         String[] classNamePackageName = getFactoryClassNamePackageName(resource);\n         String packageName = classNamePackageName[1];\n-        String fullPMMLRuleMapperClassName = packageName + \".PredictionRuleMapperImpl\";\n+        String fullPMMLRuleMappersClassName = packageName + \".PredictionRuleMappersImpl\";\n         try {\n-            return (PredictionRuleMapper) classLoader.loadClass(fullPMMLRuleMapperClassName).getDeclaredConstructor().newInstance();\n+            return (PredictionRuleMappers) classLoader.loadClass(fullPMMLRuleMappersClassName).getDeclaredConstructor().newInstance();\n         } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | ClassCastException | NoSuchMethodException | InvocationTargetException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzkyNQ==", "bodyText": "Please add e to RuntimeException so that it will be possible to get the original clause", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486623925", "createdAt": "2020-09-10T20:47:10Z", "author": {"login": "danielezonca"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/KieRuntimeFactoryBuilder.java", "diffHunk": "@@ -70,63 +73,65 @@ private KieRuntimeFactoryBuilder() {\n             final BiFunction<KnowledgeBuilderImpl, Resource, List<KiePMMLModel>> modelProducer) {\n         final Map<KieBase, KieRuntimeFactory> toReturn = new HashMap<>();\n         resources.forEach(resource -> {\n-            final String[] factoryClassNamePackageName = getFactoryClassNamePackageName(resource);\n             final KnowledgeBuilderImpl kbuilderImpl = createKnowledgeBuilderImpl(resource);\n             List<KiePMMLModel> toAdd = modelProducer.apply(kbuilderImpl, resource);\n             if (toAdd.isEmpty()) {\n                 throw new KiePMMLException(\"Failed to retrieve compiled models\");\n             }\n-            for (KiePMMLModel kiePMMLModel : toAdd) {\n-                InternalKnowledgePackage internalKnowledgePackage =\n-                        kbuilderImpl.getKnowledgeBase().getPackage(factoryClassNamePackageName[1]);\n-                if (internalKnowledgePackage == null) {\n-                    PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n-                    PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n-                    internalKnowledgePackage = pkgReg.getPackage();\n-                }\n-                PMMLPackage pmmlPkg =\n-                        internalKnowledgePackage.getResourceTypePackages().computeIfAbsent(\n-                                ResourceType.PMML,\n-                                rtp -> new PMMLPackageImpl());\n-                pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n-            }\n+            addModels(kbuilderImpl, toAdd);\n             KieBase kieBase = kbuilderImpl.getKnowledgeBase();\n             toReturn.put(kieBase, KieRuntimeFactory.of(kieBase));\n         });\n         return toReturn;\n     }\n \n+    private static void addModels(final KnowledgeBuilderImpl kbuilderImpl, final List<KiePMMLModel> toAdd) {\n+        for (KiePMMLModel kiePMMLModel : toAdd) {\n+            PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n+            PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n+            InternalKnowledgePackage kpkgs = pkgReg.getPackage();\n+            PMMLPackage pmmlPkg =\n+                    kpkgs.getResourceTypePackages().computeIfAbsent(\n+                            ResourceType.PMML,\n+                            rtp -> new PMMLPackageImpl());\n+            pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n+            if (kiePMMLModel instanceof HasNestedModels) {\n+                addModels(kbuilderImpl, ((HasNestedModels) kiePMMLModel).getNestedModels());\n+            }\n+        }\n+    }\n+\n     private static KnowledgeBuilderImpl createKnowledgeBuilderImpl(final Resource resource) {\n         KnowledgeBaseImpl defaultKnowledgeBase = new KnowledgeBaseImpl(\"PMML\", null);\n         KnowledgeBuilderImpl toReturn = new KnowledgeBuilderImpl(defaultKnowledgeBase);\n-        PredictionRuleMapper pmmlRuleMapper = loadPMMLRuleMapper(toReturn.getRootClassLoader(), resource);\n-        if (pmmlRuleMapper != null) {\n-            String ruleName = pmmlRuleMapper.getRuleName();\n-            Model model = loadModel(toReturn.getRootClassLoader(), ruleName);\n-            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(model));\n+        List<PredictionRuleMapper> pmmlRuleMappers = loadPMMLRuleMappers(toReturn.getRootClassLoader(), resource);\n+        if (!pmmlRuleMappers.isEmpty()) {\n+            List<Model> models =\n+                    pmmlRuleMappers.stream()\n+                            .map(PredictionRuleMapper::getModel)\n+                            .collect(Collectors.toList());\n+            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(models));\n         }\n         return toReturn;\n     }\n \n-    private static PredictionRuleMapper loadPMMLRuleMapper(final ClassLoader classLoader,\n-                                                           final Resource resource) {\n+    private static List<PredictionRuleMapper> loadPMMLRuleMappers(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n+        PredictionRuleMappers predictionRuleMappers = loadPMMLRuleMappersClass(classLoader, resource);\n+        return predictionRuleMappers.getPredictionRuleMappers();\n+    }\n+\n+    private static PredictionRuleMappers loadPMMLRuleMappersClass(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n         String[] classNamePackageName = getFactoryClassNamePackageName(resource);\n         String packageName = classNamePackageName[1];\n-        String fullPMMLRuleMapperClassName = packageName + \".PredictionRuleMapperImpl\";\n+        String fullPMMLRuleMappersClassName = packageName + \".PredictionRuleMappersImpl\";\n         try {\n-            return (PredictionRuleMapper) classLoader.loadClass(fullPMMLRuleMapperClassName).getDeclaredConstructor().newInstance();\n+            return (PredictionRuleMappers) classLoader.loadClass(fullPMMLRuleMappersClassName).getDeclaredConstructor().newInstance();\n         } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | ClassCastException | NoSuchMethodException | InvocationTargetException e) {\n-            logger.info(String.format(\"%s class not found in rootClassLoader\", fullPMMLRuleMapperClassName));\n-            return null;\n+            throw new RuntimeException(String.format(\"%s class not found in rootClassLoader\",\n+                                                     fullPMMLRuleMappersClassName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNDU4Mw==", "bodyText": "Can you please review this change? The new predictionRuleMappers seems unused", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486624583", "createdAt": "2020-09-10T20:48:36Z", "author": {"login": "danielezonca"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/PMMLKogito.java", "diffHunk": "@@ -52,7 +53,7 @@ private PMMLKogito() {\n      * Use {@link Application#predictionModels()} of Kogito API to programmatically access PMML assets and evaluate\n      * PMML decisions.\n      */\n-    public static Map<KieBase, KieRuntimeFactory> createKieRuntimeFactories(String... pmmlPaths) {\n+    public static Map<KieBase, KieRuntimeFactory> createKieRuntimeFactories(List<PredictionRuleMappers> predictionRuleMappers, String... pmmlPaths) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNDc3Mw==", "bodyText": "Javadoc?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486624773", "createdAt": "2020-09-10T20:49:00Z", "author": {"login": "danielezonca"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/prediction/PredictionRuleMappers.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.prediction;\n+\n+import java.util.List;\n+\n+public interface PredictionRuleMappers {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNTI1MQ==", "bodyText": "To be replaced with fixed version before merging", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486625251", "createdAt": "2020-09-10T20:49:57Z", "author": {"login": "danielezonca"}, "path": "kogito-build-parent/pom.xml", "diffHunk": "@@ -129,7 +129,7 @@\n     <version.org.keycloak>11.0.0</version.org.keycloak>\n     <version.org.mockito>3.3.3</version.org.mockito>\n     <version.org.mvel>2.4.7.Final</version.org.mvel>\n-    <version.org.kie7>7.43.0.Final</version.org.kie7>\n+    <version.org.kie7>7.44.0-SNAPSHOT</version.org.kie7>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNzA4OQ==", "bodyText": "2020", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486627089", "createdAt": "2020-09-10T20:53:30Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionRuleMappersGenerator.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 2}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dce353b6ce514a46396c57d31cf3dc0dfbf14e7", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/6dce353b6ce514a46396c57d31cf3dc0dfbf14e7", "committedDate": "2020-09-11T09:02:18Z", "message": "[KOGITO-3221] Fixed as per PR suggestion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8039ecd36cafc2c211749a50d9cc8b66341ca04", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a8039ecd36cafc2c211749a50d9cc8b66341ca04", "committedDate": "2020-09-11T10:04:28Z", "message": "[KOGITO-3221] Fixing tests. Fixing PMMLRuleMappers retrieval management"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c0caad94943959b654d64dd53a89a8f20b1683b", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/3c0caad94943959b654d64dd53a89a8f20b1683b", "committedDate": "2020-09-14T06:51:03Z", "message": "Merge remote-tracking branch 'origin/master' into KOGITO-3221"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c99c63347479cfb487ecf51d27c561c3f55be711", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/c99c63347479cfb487ecf51d27c561c3f55be711", "committedDate": "2020-09-15T07:04:29Z", "message": "Merge remote-tracking branch 'origin/master' into KOGITO-3221"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52ed49979dccd2b5be2002610a9ec21938722e3c", "author": {"user": {"login": "gitgabrio", "name": "Gabriele Cardosi"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/52ed49979dccd2b5be2002610a9ec21938722e3c", "committedDate": "2020-09-15T07:07:03Z", "message": "[KOGITO-3221] Merged with master. Updated DROOLS version to tag release"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NTM0MzA3", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#pullrequestreview-488534307", "createdAt": "2020-09-15T10:15:55Z", "commit": {"oid": "52ed49979dccd2b5be2002610a9ec21938722e3c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NTg2NTkw", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#pullrequestreview-488586590", "createdAt": "2020-09-15T11:30:03Z", "commit": {"oid": "52ed49979dccd2b5be2002610a9ec21938722e3c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3928, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}