{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NDM3NDE4", "number": 475, "title": "Code formatting and debug logs", "bodyText": "Many thanks for submitting your Pull Request \u2764\ufe0f!\nPlease make sure that your PR meets the following requirements:\n\n You have read the contributors guide\n Pull Request title is properly formatted: [KOGITO-XYZ] Subject\n Pull Request title contains the target branch if not targeting master: [0.9.x] [KOGITO-XYZ] Subject\n Pull Request contains link to the JIRA issue\n Pull Request contains link to any dependent or related Pull Request\n Pull Request contains description of the issue\n Pull Request does not include fixes for issues other than the main ticket", "createdAt": "2020-04-24T09:27:58Z", "url": "https://github.com/kiegroup/kogito-runtimes/pull/475", "merged": true, "mergeCommit": {"oid": "dddd37925eb8e9526a3917af2f40254ee6a8f652"}, "closed": true, "closedAt": "2020-04-28T16:11:48Z", "author": {"login": "cristianonicolai"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcauCebgH2gAyNDA4NDM3NDE4OjNmMzY0Yjk4NzY1YzA1YjhjOGI1ZWQxYjNjYWEwNmE0MmU1ZjkxODg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccGK2zgFqTQwMTk4NzkwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3f364b98765c05b8c8b5ed1b3caa06a42e5f9188", "author": {"user": {"login": "cristianonicolai", "name": "Cristiano Nicolai"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/3f364b98765c05b8c8b5ed1b3caa06a42e5f9188", "committedDate": "2020-04-24T09:26:27Z", "message": "Code formatting and debug logs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNDk5Njc5", "url": "https://github.com/kiegroup/kogito-runtimes/pull/475#pullrequestreview-400499679", "createdAt": "2020-04-26T12:37:58Z", "commit": {"oid": "3f364b98765c05b8c8b5ed1b3caa06a42e5f9188"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNjMwNjE2", "url": "https://github.com/kiegroup/kogito-runtimes/pull/475#pullrequestreview-401630616", "createdAt": "2020-04-28T08:53:19Z", "commit": {"oid": "3f364b98765c05b8c8b5ed1b3caa06a42e5f9188"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxOTg3OTAy", "url": "https://github.com/kiegroup/kogito-runtimes/pull/475#pullrequestreview-401987902", "createdAt": "2020-04-28T16:03:56Z", "commit": {"oid": "3f364b98765c05b8c8b5ed1b3caa06a42e5f9188"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjowMzo1NlrOGNbj5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjowMzo1NlrOGNbj5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjczNjIyOA==", "bodyText": "What is our current code style? Somewhere it is one param per line, somewhere it is all on one line.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/475#discussion_r416736228", "createdAt": "2020-04-28T16:03:56Z", "author": {"login": "MarianMacik"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/ProcessRuntimeImpl.java", "diffHunk": "@@ -77,219 +77,211 @@\n import org.kie.services.time.impl.CommandServiceTimerJobFactoryManager;\n \n public class ProcessRuntimeImpl implements InternalProcessRuntime {\n-\t\n-\tprivate InternalKnowledgeRuntime kruntime;\n-\t\n-\tprivate ProcessInstanceManager processInstanceManager;\n-\tprivate SignalManager signalManager;\n-\tprivate JobsService jobService;\n-\tprivate ProcessEventSupport processEventSupport;\n-\tprivate UnitOfWorkManager unitOfWorkManager;\n-\n-\tpublic ProcessRuntimeImpl(InternalKnowledgeRuntime kruntime) {\n-\t\tthis.kruntime = kruntime;\n+\n+    private InternalKnowledgeRuntime kruntime;\n+    private ProcessInstanceManager processInstanceManager;\n+    private SignalManager signalManager;\n+    private JobsService jobService;\n+    private ProcessEventSupport processEventSupport;\n+    private UnitOfWorkManager unitOfWorkManager;\n+\n+    public ProcessRuntimeImpl(InternalKnowledgeRuntime kruntime) {\n+        this.kruntime = kruntime;\n         TimerService timerService = kruntime.getTimerService();\n-        if ( !(timerService.getTimerJobFactoryManager() instanceof CommandServiceTimerJobFactoryManager) ) {\n-            timerService.setTimerJobFactoryManager( new ThreadSafeTrackableTimeJobFactoryManager() );\n+        if (!(timerService.getTimerJobFactoryManager() instanceof CommandServiceTimerJobFactoryManager)) {\n+            timerService.setTimerJobFactoryManager(new ThreadSafeTrackableTimeJobFactoryManager());\n         }\n \n-\t\t((CompositeClassLoader) getRootClassLoader()).addClassLoader( getClass().getClassLoader() );\n-\t\tinitProcessInstanceManager();\n-\t\tinitSignalManager();\t\t\n-\t\tunitOfWorkManager = new DefaultUnitOfWorkManager(new CollectingUnitOfWorkFactory());\n-\t\tjobService = new InMemoryJobService(this, unitOfWorkManager);\n+        ((CompositeClassLoader) getRootClassLoader()).addClassLoader(getClass().getClassLoader());\n+        initProcessInstanceManager();\n+        initSignalManager();\n+        unitOfWorkManager = new DefaultUnitOfWorkManager(new CollectingUnitOfWorkFactory());\n+        jobService = new InMemoryJobService(this, unitOfWorkManager);\n         processEventSupport = new ProcessEventSupport(unitOfWorkManager);\n         if (isActive()) {\n-            initProcessEventListeners();                   \n+            initProcessEventListeners();\n             initStartTimers();\n         }\n-        initProcessActivationListener(); \n-\t}\n-\t\n-\tpublic void initStartTimers() {\n-\t    KieBase kbase = kruntime.getKieBase();\n+        initProcessActivationListener();\n+    }\n+\n+    public ProcessRuntimeImpl(InternalWorkingMemory workingMemory) {\n+        TimerService timerService = workingMemory.getTimerService();\n+        if (!(timerService.getTimerJobFactoryManager() instanceof CommandServiceTimerJobFactoryManager)) {\n+            timerService.setTimerJobFactoryManager(new ThreadSafeTrackableTimeJobFactoryManager());\n+        }\n+\n+        this.kruntime = (InternalKnowledgeRuntime) workingMemory.getKnowledgeRuntime();\n+        initProcessInstanceManager();\n+        initSignalManager();\n+        unitOfWorkManager = new DefaultUnitOfWorkManager(new CollectingUnitOfWorkFactory());\n+        jobService = new InMemoryJobService(this, unitOfWorkManager);\n+        processEventSupport = new ProcessEventSupport(unitOfWorkManager);\n+        if (isActive()) {\n+            initProcessEventListeners();\n+            initStartTimers();\n+        }\n+        initProcessActivationListener();\n+    }\n+\n+    public void initStartTimers() {\n+        KieBase kbase = kruntime.getKieBase();\n         Collection<Process> processes = kbase.getProcesses();\n         for (Process process : processes) {\n             RuleFlowProcess p = (RuleFlowProcess) process;\n             List<StartNode> startNodes = p.getTimerStart();\n             if (startNodes != null && !startNodes.isEmpty()) {\n-                \n+\n                 for (StartNode startNode : startNodes) {\n                     if (startNode != null && startNode.getTimer() != null) {\n-                                               \n-                        jobService.scheduleProcessJob(ProcessJobDescription.of(createTimerInstance(startNode.getTimer(), kruntime), p.getId()));                       \n+                        jobService.scheduleProcessJob(ProcessJobDescription.of(createTimerInstance(startNode.getTimer(), kruntime), p.getId()));\n                     }\n                 }\n             }\n         }\n     }\n \n-\tpublic ProcessRuntimeImpl(InternalWorkingMemory workingMemory) {\n-        TimerService timerService = workingMemory.getTimerService();\n-        if ( !(timerService.getTimerJobFactoryManager() instanceof CommandServiceTimerJobFactoryManager) ) {\n-            timerService.setTimerJobFactoryManager( new ThreadSafeTrackableTimeJobFactoryManager() );\n-        }\n-\t\t\n-\t\tthis.kruntime = (InternalKnowledgeRuntime) workingMemory.getKnowledgeRuntime();\n-\t\tinitProcessInstanceManager();\n-\t\tinitSignalManager();\t\t\n-\t\tunitOfWorkManager = new DefaultUnitOfWorkManager(new CollectingUnitOfWorkFactory());\n-\t\tjobService = new InMemoryJobService(this, unitOfWorkManager);\n-        processEventSupport = new ProcessEventSupport(unitOfWorkManager);\n-        if (isActive()) {\n-            initProcessEventListeners();                   \n-            initStartTimers();\n+    private void initProcessInstanceManager() {\n+        processInstanceManager = new DefaultProcessInstanceManagerFactory().createProcessInstanceManager(kruntime);\n+    }\n+\n+    private void initSignalManager() {\n+        signalManager = new DefaultSignalManagerFactory().createSignalManager(kruntime);\n+    }\n+\n+    private ClassLoader getRootClassLoader() {\n+        KieBase kbase = ((InternalKnowledgeBase) kruntime.getKieBase());\n+        if (kbase != null) {\n+            return ((InternalKnowledgeBase) kbase).getRootClassLoader();\n         }\n-        initProcessActivationListener();\n-\t}\n-\t\n-\tprivate void initProcessInstanceManager() {\n-\t\tprocessInstanceManager = new DefaultProcessInstanceManagerFactory().createProcessInstanceManager(kruntime);\n-\t\t\n-\t}\n-\t\n-\tprivate void initSignalManager() {\t\n-\t\tsignalManager = new DefaultSignalManagerFactory().createSignalManager(kruntime);\n-\t\t\n-\t}\n-\t\n-\tprivate ClassLoader getRootClassLoader() {\n-\t\tKieBase kbase = ((InternalKnowledgeBase) kruntime.getKieBase());\n-\t\tif (kbase != null) {\n-\t\t\treturn ((InternalKnowledgeBase) kbase).getRootClassLoader();\n-\t\t}\n-\t\tCompositeClassLoader result = new CompositeClassLoader();\n-\t\tresult.addClassLoader(Thread.currentThread().getContextClassLoader());\n-\t\treturn result;\n-\t}\n-\t\n+        CompositeClassLoader result = new CompositeClassLoader();\n+        result.addClassLoader(Thread.currentThread().getContextClassLoader());\n+        return result;\n+    }\n+\n     public ProcessInstance startProcess(final String processId) {\n         return startProcess(processId, null);\n     }\n \n     public ProcessInstance startProcess(String processId,\n                                         Map<String, Object> parameters) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f364b98765c05b8c8b5ed1b3caa06a42e5f9188"}, "originalPosition": 156}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3425, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}