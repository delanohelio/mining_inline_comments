{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3MjQxMTQ0", "number": 322, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzoxOTozMVrODh8_Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoxNzozMlrODit98Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTI4NzcwOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzoxOTozMVrOFs-gGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjowMDowMlrOFuo31A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNTY5MQ==", "bodyText": "Probably these constants could be unified with the ones used on StartEventHandler, wdyt?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r382705691", "createdAt": "2020-02-21T17:19:31Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -17,17 +17,25 @@\n package org.jbpm.compiler.canonical;\n \n import java.util.Map;\n+import java.util.Map.Entry;\n \n+import org.jbpm.process.core.context.variable.Variable;\n import org.jbpm.process.core.context.variable.VariableScope;\n import org.jbpm.ruleflow.core.factory.StartNodeFactory;\n import org.jbpm.workflow.core.node.StartNode;\n import org.kie.api.definition.process.Node;\n \n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n import com.github.javaparser.ast.expr.LongLiteralExpr;\n import com.github.javaparser.ast.expr.StringLiteralExpr;\n import com.github.javaparser.ast.stmt.BlockStmt;\n \n public class StartNodeVisitor extends AbstractVisitor {\n+    \n+    private static final String TRIGGER_REF = \"TriggerRef\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwNjU1Mg==", "bodyText": "I kept them separate as they are across different modules so didn't want to make too much dependencies between them", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r382906552", "createdAt": "2020-02-22T11:35:24Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -17,17 +17,25 @@\n package org.jbpm.compiler.canonical;\n \n import java.util.Map;\n+import java.util.Map.Entry;\n \n+import org.jbpm.process.core.context.variable.Variable;\n import org.jbpm.process.core.context.variable.VariableScope;\n import org.jbpm.ruleflow.core.factory.StartNodeFactory;\n import org.jbpm.workflow.core.node.StartNode;\n import org.kie.api.definition.process.Node;\n \n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n import com.github.javaparser.ast.expr.LongLiteralExpr;\n import com.github.javaparser.ast.expr.StringLiteralExpr;\n import com.github.javaparser.ast.stmt.BlockStmt;\n \n public class StartNodeVisitor extends AbstractVisitor {\n+    \n+    private static final String TRIGGER_REF = \"TriggerRef\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNTY5MQ=="}, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0ODQ2OA==", "bodyText": "Ok \ud83d\udc4d", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r384448468", "createdAt": "2020-02-26T12:00:02Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -17,17 +17,25 @@\n package org.jbpm.compiler.canonical;\n \n import java.util.Map;\n+import java.util.Map.Entry;\n \n+import org.jbpm.process.core.context.variable.Variable;\n import org.jbpm.process.core.context.variable.VariableScope;\n import org.jbpm.ruleflow.core.factory.StartNodeFactory;\n import org.jbpm.workflow.core.node.StartNode;\n import org.kie.api.definition.process.Node;\n \n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n import com.github.javaparser.ast.expr.LongLiteralExpr;\n import com.github.javaparser.ast.expr.StringLiteralExpr;\n import com.github.javaparser.ast.stmt.BlockStmt;\n \n public class StartNodeVisitor extends AbstractVisitor {\n+    \n+    private static final String TRIGGER_REF = \"TriggerRef\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNTY5MQ=="}, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTM0NjM3OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessCodegen.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzo0MDowOFrOFs_FCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjowMDoyNVrOFuo4ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNTE0NA==", "bodyText": "this block is being repeated, maybe it is better to unify on a method.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r382715144", "createdAt": "2020-02-21T17:40:08Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessCodegen.java", "diffHunk": "@@ -315,13 +315,15 @@ public ProcessCodegen withClassLoader(ClassLoader projectClassLoader) {\n \n                 for (TriggerMetaData trigger : metaData.getTriggers()) {\n \n-                    MessageDataEventGenerator msgDataEventGenerator = new MessageDataEventGenerator(workFlowProcess,\n-                                                            trigger)\n-                                                                  .withDependencyInjection(annotator);\n-                    mdegs.add(msgDataEventGenerator);\n+                    \n                     // generate message consumers for processes with message start events\n                     if (trigger.getType().equals(TriggerMetaData.TriggerType.ConsumeMessage)) {\n \n+                        MessageDataEventGenerator msgDataEventGenerator = new MessageDataEventGenerator(workFlowProcess,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwNjUyMA==", "bodyText": "it is only two lines that are repeated so having this as method will not be of that big value in my opinion especially that the MessageDataEventGenerator  is referenced few lines below", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r382906520", "createdAt": "2020-02-22T11:34:46Z", "author": {"login": "mswiderski"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessCodegen.java", "diffHunk": "@@ -315,13 +315,15 @@ public ProcessCodegen withClassLoader(ClassLoader projectClassLoader) {\n \n                 for (TriggerMetaData trigger : metaData.getTriggers()) {\n \n-                    MessageDataEventGenerator msgDataEventGenerator = new MessageDataEventGenerator(workFlowProcess,\n-                                                            trigger)\n-                                                                  .withDependencyInjection(annotator);\n-                    mdegs.add(msgDataEventGenerator);\n+                    \n                     // generate message consumers for processes with message start events\n                     if (trigger.getType().equals(TriggerMetaData.TriggerType.ConsumeMessage)) {\n \n+                        MessageDataEventGenerator msgDataEventGenerator = new MessageDataEventGenerator(workFlowProcess,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNTE0NA=="}, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0ODYzNQ==", "bodyText": "Ok \ud83d\udc4d", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r384448635", "createdAt": "2020-02-26T12:00:25Z", "author": {"login": "tiagodolphine"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessCodegen.java", "diffHunk": "@@ -315,13 +315,15 @@ public ProcessCodegen withClassLoader(ClassLoader projectClassLoader) {\n \n                 for (TriggerMetaData trigger : metaData.getTriggers()) {\n \n-                    MessageDataEventGenerator msgDataEventGenerator = new MessageDataEventGenerator(workFlowProcess,\n-                                                            trigger)\n-                                                                  .withDependencyInjection(annotator);\n-                    mdegs.add(msgDataEventGenerator);\n+                    \n                     // generate message consumers for processes with message start events\n                     if (trigger.getType().equals(TriggerMetaData.TriggerType.ConsumeMessage)) {\n \n+                        MessageDataEventGenerator msgDataEventGenerator = new MessageDataEventGenerator(workFlowProcess,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNTE0NA=="}, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTM1Mzg2OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzo0Mjo0MlrOFs_J3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjowMDo0MVrOFuo46g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNjM4MA==", "bodyText": "if filters can be null, maybe it is worth to check.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r382716380", "createdAt": "2020-02-21T17:42:42Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -286,5 +292,43 @@ protected Node findNodeByIdOrUniqueIdInMetadata(NodeContainer nodeContainer, fin\n         }\n         return node;\n     }\n+    \n+    private void postProcessNodes(RuleFlowProcess process, NodeContainer container) {\n+        \n+        for (Node node: container.getNodes()) {\n+            if (node instanceof NodeContainer) {\n+                // prepare event sub process\n+                if (node instanceof EventSubProcessNode) {\n+                    EventSubProcessNode eventSubProcessNode = (EventSubProcessNode) node;\n+\n+                    Node[] nodes = eventSubProcessNode.getNodes();\n+                    for (Node subNode : nodes) {\n+                        // avoids cyclomatic complexity\n+                        if (subNode instanceof StartNode) {\n+                         \n+                            processEventSubprocessStartNode(((StartNode) subNode), eventSubProcessNode);\n+                        }\n+                    }\n+                }\n+                postProcessNodes(process, (NodeContainer) node);\n+            } \n+        }     \n+    }\n+    \n+    private void processEventSubprocessStartNode(StartNode subNode, EventSubProcessNode eventSubProcessNode) {\n+        List<Trigger> triggers = subNode.getTriggers();\n+        if ( triggers != null ) {\n+                                   \n+            for ( Trigger trigger : triggers ) {\n+                if ( trigger instanceof EventTrigger ) {\n+                    final List<EventFilter> filters = ((EventTrigger) trigger).getEventFilters();\n+    \n+                    for ( EventFilter filter : filters ) {                        ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwNjIyMw==", "bodyText": "I'd say it should not be null but an empty list in worse case, see that it is set to empty list in EventTrigger class", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r382906223", "createdAt": "2020-02-22T11:28:48Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -286,5 +292,43 @@ protected Node findNodeByIdOrUniqueIdInMetadata(NodeContainer nodeContainer, fin\n         }\n         return node;\n     }\n+    \n+    private void postProcessNodes(RuleFlowProcess process, NodeContainer container) {\n+        \n+        for (Node node: container.getNodes()) {\n+            if (node instanceof NodeContainer) {\n+                // prepare event sub process\n+                if (node instanceof EventSubProcessNode) {\n+                    EventSubProcessNode eventSubProcessNode = (EventSubProcessNode) node;\n+\n+                    Node[] nodes = eventSubProcessNode.getNodes();\n+                    for (Node subNode : nodes) {\n+                        // avoids cyclomatic complexity\n+                        if (subNode instanceof StartNode) {\n+                         \n+                            processEventSubprocessStartNode(((StartNode) subNode), eventSubProcessNode);\n+                        }\n+                    }\n+                }\n+                postProcessNodes(process, (NodeContainer) node);\n+            } \n+        }     \n+    }\n+    \n+    private void processEventSubprocessStartNode(StartNode subNode, EventSubProcessNode eventSubProcessNode) {\n+        List<Trigger> triggers = subNode.getTriggers();\n+        if ( triggers != null ) {\n+                                   \n+            for ( Trigger trigger : triggers ) {\n+                if ( trigger instanceof EventTrigger ) {\n+                    final List<EventFilter> filters = ((EventTrigger) trigger).getEventFilters();\n+    \n+                    for ( EventFilter filter : filters ) {                        ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNjM4MA=="}, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0ODc0Ng==", "bodyText": "Ok \ud83d\udc4d", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r384448746", "createdAt": "2020-02-26T12:00:41Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -286,5 +292,43 @@ protected Node findNodeByIdOrUniqueIdInMetadata(NodeContainer nodeContainer, fin\n         }\n         return node;\n     }\n+    \n+    private void postProcessNodes(RuleFlowProcess process, NodeContainer container) {\n+        \n+        for (Node node: container.getNodes()) {\n+            if (node instanceof NodeContainer) {\n+                // prepare event sub process\n+                if (node instanceof EventSubProcessNode) {\n+                    EventSubProcessNode eventSubProcessNode = (EventSubProcessNode) node;\n+\n+                    Node[] nodes = eventSubProcessNode.getNodes();\n+                    for (Node subNode : nodes) {\n+                        // avoids cyclomatic complexity\n+                        if (subNode instanceof StartNode) {\n+                         \n+                            processEventSubprocessStartNode(((StartNode) subNode), eventSubProcessNode);\n+                        }\n+                    }\n+                }\n+                postProcessNodes(process, (NodeContainer) node);\n+            } \n+        }     \n+    }\n+    \n+    private void processEventSubprocessStartNode(StartNode subNode, EventSubProcessNode eventSubProcessNode) {\n+        List<Trigger> triggers = subNode.getTriggers();\n+        if ( triggers != null ) {\n+                                   \n+            for ( Trigger trigger : triggers ) {\n+                if ( trigger instanceof EventTrigger ) {\n+                    final List<EventFilter> filters = ((EventTrigger) trigger).getEventFilters();\n+    \n+                    for ( EventFilter filter : filters ) {                        ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNjM4MA=="}, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTM1ODc4OnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzo0NDoxOFrOFs_M5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjowNDo0MFrOFuo_lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzE1Ng==", "bodyText": "there is always a TRIGGER_TYPE on metaData? otherwise, this can lead to a NPE... maybe using String.valueOf() instead of casting is an option.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r382717156", "createdAt": "2020-02-21T17:44:18Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -36,24 +44,51 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         addFactoryMethodWithArgsWithAssignment(factoryField, body, StartNodeFactory.class, \"startNode\" + node.getId(), \"startNode\", new LongLiteralExpr(startNode.getId()));\n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"name\", new StringLiteralExpr(getOrDefault(startNode.getName(), \"Start\")));\n         \n+        addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"interrupting\", new BooleanLiteralExpr(startNode.isInterrupting()));\n+        \n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n         \n         if (startNode.getTriggers() != null && !startNode.getTriggers().isEmpty()) {\n             Map<String, Object> nodeMetaData = startNode.getMetaData();\n-            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(\"TriggerRef\"), \n-                                                           (String)nodeMetaData.get(\"TriggerType\"), \n-                                                           (String)nodeMetaData.get(\"MessageType\"), \n-                                                           (String)nodeMetaData.get(\"TriggerMapping\"),\n+            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(TRIGGER_REF), \n+                                                           (String)nodeMetaData.get(TRIGGER_TYPE), \n+                                                           (String)nodeMetaData.get(MESSAGE_TYPE), \n+                                                           (String)nodeMetaData.get(TRIGGER_MAPPING),\n                                                            String.valueOf(node.getId())).validate());\n             \n-            addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"trigger\", new StringLiteralExpr((String)nodeMetaData.get(\"TriggerRef\")),\n-                                                                                  new StringLiteralExpr(getOrDefault((String)nodeMetaData.get(\"TriggerMapping\"), \"\")));\n+            handleSignal(startNode, nodeMetaData, body, variableScope, metadata);\n+            \n+            addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"trigger\", new StringLiteralExpr((String)nodeMetaData.get(TRIGGER_REF)),\n+                                                                                  new StringLiteralExpr(getOrDefault((String)nodeMetaData.get(TRIGGER_MAPPING), \"\")));\n         } else {\n             // since there is start node without trigger then make sure it is startable\n             metadata.setStartable(true);\n         }\n         \n     }\n+    \n+    protected void handleSignal(StartNode startNode, Map<String, Object> nodeMetaData, BlockStmt body, VariableScope variableScope, ProcessMetaData metadata) {\n+        if (\"signal\".equalsIgnoreCase((String)startNode.getMetaData(TRIGGER_TYPE))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwNjE3NQ==", "bodyText": "not sure what you mean as this\nObject test = null;\n \"\".equalsIgnoreCase((String) test);\n\ndoes not cause NP, so did you had something else in mind?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r382906175", "createdAt": "2020-02-22T11:27:41Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -36,24 +44,51 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         addFactoryMethodWithArgsWithAssignment(factoryField, body, StartNodeFactory.class, \"startNode\" + node.getId(), \"startNode\", new LongLiteralExpr(startNode.getId()));\n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"name\", new StringLiteralExpr(getOrDefault(startNode.getName(), \"Start\")));\n         \n+        addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"interrupting\", new BooleanLiteralExpr(startNode.isInterrupting()));\n+        \n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n         \n         if (startNode.getTriggers() != null && !startNode.getTriggers().isEmpty()) {\n             Map<String, Object> nodeMetaData = startNode.getMetaData();\n-            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(\"TriggerRef\"), \n-                                                           (String)nodeMetaData.get(\"TriggerType\"), \n-                                                           (String)nodeMetaData.get(\"MessageType\"), \n-                                                           (String)nodeMetaData.get(\"TriggerMapping\"),\n+            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(TRIGGER_REF), \n+                                                           (String)nodeMetaData.get(TRIGGER_TYPE), \n+                                                           (String)nodeMetaData.get(MESSAGE_TYPE), \n+                                                           (String)nodeMetaData.get(TRIGGER_MAPPING),\n                                                            String.valueOf(node.getId())).validate());\n             \n-            addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"trigger\", new StringLiteralExpr((String)nodeMetaData.get(\"TriggerRef\")),\n-                                                                                  new StringLiteralExpr(getOrDefault((String)nodeMetaData.get(\"TriggerMapping\"), \"\")));\n+            handleSignal(startNode, nodeMetaData, body, variableScope, metadata);\n+            \n+            addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"trigger\", new StringLiteralExpr((String)nodeMetaData.get(TRIGGER_REF)),\n+                                                                                  new StringLiteralExpr(getOrDefault((String)nodeMetaData.get(TRIGGER_MAPPING), \"\")));\n         } else {\n             // since there is start node without trigger then make sure it is startable\n             metadata.setStartable(true);\n         }\n         \n     }\n+    \n+    protected void handleSignal(StartNode startNode, Map<String, Object> nodeMetaData, BlockStmt body, VariableScope variableScope, ProcessMetaData metadata) {\n+        if (\"signal\".equalsIgnoreCase((String)startNode.getMetaData(TRIGGER_TYPE))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzE1Ng=="}, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ1MDQ1NA==", "bodyText": "\ud83d\udc4d yeah, you are right I was thinking about the (String) test to be changed to String.valueOf() but indeed the cast does not throw NPE.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r384450454", "createdAt": "2020-02-26T12:04:40Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -36,24 +44,51 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         addFactoryMethodWithArgsWithAssignment(factoryField, body, StartNodeFactory.class, \"startNode\" + node.getId(), \"startNode\", new LongLiteralExpr(startNode.getId()));\n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"name\", new StringLiteralExpr(getOrDefault(startNode.getName(), \"Start\")));\n         \n+        addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"interrupting\", new BooleanLiteralExpr(startNode.isInterrupting()));\n+        \n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n         \n         if (startNode.getTriggers() != null && !startNode.getTriggers().isEmpty()) {\n             Map<String, Object> nodeMetaData = startNode.getMetaData();\n-            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(\"TriggerRef\"), \n-                                                           (String)nodeMetaData.get(\"TriggerType\"), \n-                                                           (String)nodeMetaData.get(\"MessageType\"), \n-                                                           (String)nodeMetaData.get(\"TriggerMapping\"),\n+            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(TRIGGER_REF), \n+                                                           (String)nodeMetaData.get(TRIGGER_TYPE), \n+                                                           (String)nodeMetaData.get(MESSAGE_TYPE), \n+                                                           (String)nodeMetaData.get(TRIGGER_MAPPING),\n                                                            String.valueOf(node.getId())).validate());\n             \n-            addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"trigger\", new StringLiteralExpr((String)nodeMetaData.get(\"TriggerRef\")),\n-                                                                                  new StringLiteralExpr(getOrDefault((String)nodeMetaData.get(\"TriggerMapping\"), \"\")));\n+            handleSignal(startNode, nodeMetaData, body, variableScope, metadata);\n+            \n+            addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"trigger\", new StringLiteralExpr((String)nodeMetaData.get(TRIGGER_REF)),\n+                                                                                  new StringLiteralExpr(getOrDefault((String)nodeMetaData.get(TRIGGER_MAPPING), \"\")));\n         } else {\n             // since there is start node without trigger then make sure it is startable\n             metadata.setStartable(true);\n         }\n         \n     }\n+    \n+    protected void handleSignal(StartNode startNode, Map<String, Object> nodeMetaData, BlockStmt body, VariableScope variableScope, ProcessMetaData metadata) {\n+        if (\"signal\".equalsIgnoreCase((String)startNode.getMetaData(TRIGGER_TYPE))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzE1Ng=="}, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTM2MzgxOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzo0NjowM1rOFs_QAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjowNDo1OFrOFuo_-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzk1NA==", "bodyText": "there is always a TRIGGER_TYPE,...,  on metaData? otherwise, this can lead to a NPE... maybe using String.valueOf() instead of casting is an option.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r382717954", "createdAt": "2020-02-21T17:46:03Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -36,24 +44,51 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         addFactoryMethodWithArgsWithAssignment(factoryField, body, StartNodeFactory.class, \"startNode\" + node.getId(), \"startNode\", new LongLiteralExpr(startNode.getId()));\n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"name\", new StringLiteralExpr(getOrDefault(startNode.getName(), \"Start\")));\n         \n+        addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"interrupting\", new BooleanLiteralExpr(startNode.isInterrupting()));\n+        \n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n         \n         if (startNode.getTriggers() != null && !startNode.getTriggers().isEmpty()) {\n             Map<String, Object> nodeMetaData = startNode.getMetaData();\n-            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(\"TriggerRef\"), \n-                                                           (String)nodeMetaData.get(\"TriggerType\"), \n-                                                           (String)nodeMetaData.get(\"MessageType\"), \n-                                                           (String)nodeMetaData.get(\"TriggerMapping\"),\n+            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(TRIGGER_REF), ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwNjE4NQ==", "bodyText": "same as above...", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r382906185", "createdAt": "2020-02-22T11:27:50Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -36,24 +44,51 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         addFactoryMethodWithArgsWithAssignment(factoryField, body, StartNodeFactory.class, \"startNode\" + node.getId(), \"startNode\", new LongLiteralExpr(startNode.getId()));\n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"name\", new StringLiteralExpr(getOrDefault(startNode.getName(), \"Start\")));\n         \n+        addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"interrupting\", new BooleanLiteralExpr(startNode.isInterrupting()));\n+        \n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n         \n         if (startNode.getTriggers() != null && !startNode.getTriggers().isEmpty()) {\n             Map<String, Object> nodeMetaData = startNode.getMetaData();\n-            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(\"TriggerRef\"), \n-                                                           (String)nodeMetaData.get(\"TriggerType\"), \n-                                                           (String)nodeMetaData.get(\"MessageType\"), \n-                                                           (String)nodeMetaData.get(\"TriggerMapping\"),\n+            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(TRIGGER_REF), ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzk1NA=="}, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ1MDU1Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r384450552", "createdAt": "2020-02-26T12:04:58Z", "author": {"login": "tiagodolphine"}, "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -36,24 +44,51 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         addFactoryMethodWithArgsWithAssignment(factoryField, body, StartNodeFactory.class, \"startNode\" + node.getId(), \"startNode\", new LongLiteralExpr(startNode.getId()));\n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"name\", new StringLiteralExpr(getOrDefault(startNode.getName(), \"Start\")));\n         \n+        addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"interrupting\", new BooleanLiteralExpr(startNode.isInterrupting()));\n+        \n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n         \n         if (startNode.getTriggers() != null && !startNode.getTriggers().isEmpty()) {\n             Map<String, Object> nodeMetaData = startNode.getMetaData();\n-            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(\"TriggerRef\"), \n-                                                           (String)nodeMetaData.get(\"TriggerType\"), \n-                                                           (String)nodeMetaData.get(\"MessageType\"), \n-                                                           (String)nodeMetaData.get(\"TriggerMapping\"),\n+            metadata.getTriggers().add(new TriggerMetaData((String)nodeMetaData.get(TRIGGER_REF), ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzk1NA=="}, "originalCommit": {"oid": "b605e08a53abab03eca9b6d4d1783037d22aa677"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzMxMzEzOnYy", "diffSide": "RIGHT", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/EventSubProcessNodeFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoxNzozMlrOFuHuGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyNTozMlrOFuIBZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwNTMwNQ==", "bodyText": "back to the future? :D", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r383905305", "createdAt": "2020-02-25T14:17:32Z", "author": {"login": "cristianonicolai"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/EventSubProcessNodeFactory.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2c74bd0248d3842c63a0ad8e1307b22099d679b"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMDI0Nw==", "bodyText": "yes, indeed at least the header is there :)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/322#discussion_r383910247", "createdAt": "2020-02-25T14:25:32Z", "author": {"login": "mswiderski"}, "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/EventSubProcessNodeFactory.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwNTMwNQ=="}, "originalCommit": {"oid": "e2c74bd0248d3842c63a0ad8e1307b22099d679b"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 308, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}