{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2NTI4Nzgz", "number": 763, "title": "[KOGITO-2766] Refactoring Process<T> initialization code", "bodyText": "Summary of changes (please read JIRA initial description for more information):\nGenerated handlers are now passed to constructor explicitly (handlers\nfield has been removed), which registers them, both for injection and non injection\npaths\nAdditionally,  when there is any handler present, additional non injected constructor that only accepts Application reference is provided, Itautomatically creates and registers the handlers (user can still pass handler instances using the other constructor in non injection)\nConfigure and registerListeners methods are only generated if they have\ncontent (which happen when there are listeners)\nActivate method will be invoked from generated constructors.\nGenerated code example\n    public TravellersProcess(org.kie.kogito.app.Application app) {\n        this(\n            app,\n            new org.kie.kogito.handlers.GreetingTravellerService_greetTraveller_3_Handler(),\n            new org.kie.kogito.handlers.TravellerAuditService_auditTraveller_7_Handler(),\n            new org.kie.kogito.handlers.StoreTravellerService_storeTraveller_2_Handler());\n    }\n\n    @javax.inject.Inject()\n    public TravellersProcess(org.kie.kogito.app.Application app,\n                             org.kie.kogito.handlers.GreetingTravellerService_greetTraveller_3_Handler greetingTravellerService_greetTraveller_3_Handler,\n                             org.kie.kogito.handlers.TravellerAuditService_auditTraveller_7_Handler travellerAuditService_auditTraveller_7_Handler,\n                             org.kie.kogito.handlers.StoreTravellerService_storeTraveller_2_Handler storeTravellerService_storeTraveller_2_Handler) {\n        super(\n            app,\n            java.util.Arrays\n                .asList(\n                        greetingTravellerService_greetTraveller_3_Handler,\n                        travellerAuditService_auditTraveller_7_Handler,\n                        storeTravellerService_storeTraveller_2_Handler));\n        activate();\n    }\n\n\nHandler classes now have two constructors\npublic GreetingTravellerService_greetTraveller_3_Handler() {\n       this.service = new org.acme.travels.services.GreetingTravellerService();\n   }\n\n   @javax.inject.Inject()\n   public GreetingTravellerService_greetTraveller_3_Handler(org.acme.travels.services.GreetingTravellerService service) {\n       this.service = service;\n   }", "createdAt": "2020-09-14T11:06:16Z", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763", "merged": true, "mergeCommit": {"oid": "673b2d0943660293b77cab24ca6c2c352db5ce02"}, "closed": true, "closedAt": "2020-09-17T03:01:57Z", "author": {"login": "fjtirado"}, "timelineItems": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdIxT6wABqjM3NjI3OTA0MDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJoCqiAFqTQ5MDIxMDE0OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6db18fbcb978431b7a28faf0def3c0f48782cfbd", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/6db18fbcb978431b7a28faf0def3c0f48782cfbd", "committedDate": "2020-09-14T11:05:02Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "fb808a607fbc780dfa4679a0a250717851dc64c3", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/fb808a607fbc780dfa4679a0a250717851dc64c3", "committedDate": "2020-09-14T11:15:34Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb808a607fbc780dfa4679a0a250717851dc64c3", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/fb808a607fbc780dfa4679a0a250717851dc64c3", "committedDate": "2020-09-14T11:15:34Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "1f8b3bf542941adaf3de966dca1d752eaf5dce45", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1f8b3bf542941adaf3de966dca1d752eaf5dce45", "committedDate": "2020-09-14T11:17:32Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f8b3bf542941adaf3de966dca1d752eaf5dce45", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1f8b3bf542941adaf3de966dca1d752eaf5dce45", "committedDate": "2020-09-14T11:17:32Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "a5175befccf7a33673c5baab196ebe2aa2a6e696", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a5175befccf7a33673c5baab196ebe2aa2a6e696", "committedDate": "2020-09-14T11:47:57Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a5175befccf7a33673c5baab196ebe2aa2a6e696", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/a5175befccf7a33673c5baab196ebe2aa2a6e696", "committedDate": "2020-09-14T11:47:57Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "866ee4e20c474e0cdb55be74683f54b358c773f8", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/866ee4e20c474e0cdb55be74683f54b358c773f8", "committedDate": "2020-09-14T12:22:40Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "866ee4e20c474e0cdb55be74683f54b358c773f8", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/866ee4e20c474e0cdb55be74683f54b358c773f8", "committedDate": "2020-09-14T12:22:40Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "bcb30db9395f271aa667680e9b5df1eb9447a771", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/bcb30db9395f271aa667680e9b5df1eb9447a771", "committedDate": "2020-09-14T12:41:13Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bcb30db9395f271aa667680e9b5df1eb9447a771", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/bcb30db9395f271aa667680e9b5df1eb9447a771", "committedDate": "2020-09-14T12:41:13Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "9fc818079c0bda913f7a4857a5550b6b24534b85", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9fc818079c0bda913f7a4857a5550b6b24534b85", "committedDate": "2020-09-14T13:15:55Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9fc818079c0bda913f7a4857a5550b6b24534b85", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9fc818079c0bda913f7a4857a5550b6b24534b85", "committedDate": "2020-09-14T13:15:55Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "60f97f1087be8cd205adf4fe3844d9513b527970", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/60f97f1087be8cd205adf4fe3844d9513b527970", "committedDate": "2020-09-14T13:17:43Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "60f97f1087be8cd205adf4fe3844d9513b527970", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/60f97f1087be8cd205adf4fe3844d9513b527970", "committedDate": "2020-09-14T13:17:43Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "2b60b5f00a45533cc66d981dec1308ad127b6340", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/2b60b5f00a45533cc66d981dec1308ad127b6340", "committedDate": "2020-09-14T13:31:40Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2b60b5f00a45533cc66d981dec1308ad127b6340", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/2b60b5f00a45533cc66d981dec1308ad127b6340", "committedDate": "2020-09-14T13:31:40Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths (which means that when injection is not used, caller of the\nconstructor will explicitly have to pass it)\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "7596887205c0e994f43243f4a9ef566b0c8d62b4", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7596887205c0e994f43243f4a9ef566b0c8d62b4", "committedDate": "2020-09-14T14:25:29Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7596887205c0e994f43243f4a9ef566b0c8d62b4", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7596887205c0e994f43243f4a9ef566b0c8d62b4", "committedDate": "2020-09-14T14:25:29Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "72050ad08dc80df641630c701fb5178284cbd229", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/72050ad08dc80df641630c701fb5178284cbd229", "committedDate": "2020-09-14T15:39:12Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72050ad08dc80df641630c701fb5178284cbd229", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/72050ad08dc80df641630c701fb5178284cbd229", "committedDate": "2020-09-14T15:39:12Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "b2a0b0a28d433d5674613902a5643dc128b19736", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b2a0b0a28d433d5674613902a5643dc128b19736", "committedDate": "2020-09-14T15:51:21Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b2a0b0a28d433d5674613902a5643dc128b19736", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b2a0b0a28d433d5674613902a5643dc128b19736", "committedDate": "2020-09-14T15:51:21Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "2c3c3bcf32d56e01b2ba9a9cfa75966284e6f279", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/2c3c3bcf32d56e01b2ba9a9cfa75966284e6f279", "committedDate": "2020-09-14T15:57:45Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c3c3bcf32d56e01b2ba9a9cfa75966284e6f279", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/2c3c3bcf32d56e01b2ba9a9cfa75966284e6f279", "committedDate": "2020-09-14T15:57:45Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "f4efd316adbc5b7014c42644490e4a424a9e2f78", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f4efd316adbc5b7014c42644490e4a424a9e2f78", "committedDate": "2020-09-14T15:59:33Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f4efd316adbc5b7014c42644490e4a424a9e2f78", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f4efd316adbc5b7014c42644490e4a424a9e2f78", "committedDate": "2020-09-14T15:59:33Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "7c0a5aad9aad51fd046e1058758d9144896bb74e", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7c0a5aad9aad51fd046e1058758d9144896bb74e", "committedDate": "2020-09-15T09:26:42Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c0a5aad9aad51fd046e1058758d9144896bb74e", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7c0a5aad9aad51fd046e1058758d9144896bb74e", "committedDate": "2020-09-15T09:26:42Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "39008da486570df4eac7e69291072f20b730b843", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/39008da486570df4eac7e69291072f20b730b843", "committedDate": "2020-09-15T12:07:56Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NjY0MzY0", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#pullrequestreview-488664364", "createdAt": "2020-09-15T13:10:22Z", "commit": {"oid": "39008da486570df4eac7e69291072f20b730b843"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMzoxMDoyMlrOHSBCXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMzoxMjowNFrOHSBHMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY1MzQwNg==", "bodyText": "with", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488653406", "createdAt": "2020-09-15T13:10:22Z", "author": {"login": "evacchi"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java", "diffHunk": "@@ -137,6 +137,8 @@\n      * @param defaultValue value to be used in case there is no config parameter defined\n      */\n     <T extends NodeWithAnnotations<?>> T withConfigInjection(T node, String configKey, String defaultValue);\n+ \n+    default <T extends NodeWithAnnotations<?>> T witLazyInit(T node) { return node; }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39008da486570df4eac7e69291072f20b730b843"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY1NDY0Mg==", "bodyText": "remove comment", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488654642", "createdAt": "2020-09-15T13:12:04Z", "author": {"login": "evacchi"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -382,76 +343,118 @@ public ClassOrInterfaceDeclaration classDeclaration() {\n         ClassOrInterfaceDeclaration cls = new ClassOrInterfaceDeclaration()\n                 .setName(targetTypeName)\n                 .setModifiers(Modifier.Keyword.PUBLIC);\n-\n-        if (useInjection()) {\n-            annotator.withNamedApplicationComponent(cls, process.getId());\n-            \n-            FieldDeclaration handlersInjectFieldDeclaration = new FieldDeclaration()\n-                    .addVariable(new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(annotator.multiInstanceInjectionType()), NodeList.nodeList(new ClassOrInterfaceType(null, WorkItemHandler.class.getCanonicalName()))), \"handlers\"));\n-            annotator.withOptionalInjection(handlersInjectFieldDeclaration);\n-            \n-            cls.addMember(handlersInjectFieldDeclaration);\n-        }\n-\n+        ProcessMetaData processMetaData = processGenerator.generate();\n         String processInstanceFQCN = ProcessInstanceGenerator.qualifiedName(packageName, typeName);\n-\n-        FieldDeclaration fieldDeclaration = new FieldDeclaration()\n-                .addVariable(new VariableDeclarator(new ClassOrInterfaceType(null, appCanonicalName), \"app\"));\n-\n-        ConstructorDeclaration constructorDeclaration = new ConstructorDeclaration()\n-                .setName(targetTypeName)\n-                .addModifier(Modifier.Keyword.PUBLIC)\n-                .addParameter(appCanonicalName, \"app\")\n-                .setBody(new BlockStmt()\n-                                 // super(module.config().process())\n-                                 .addStatement(new MethodCallExpr(null, \"super\")\n-                                              .addArgument(\n-                                                      new MethodCallExpr(\n-                                                              new MethodCallExpr(new NameExpr(\"app\"), \"config\"),\n-                                                              \"process\")))\n-                                 .addStatement(\n-                                         new AssignExpr(new FieldAccessExpr(new ThisExpr(), \"app\"), new NameExpr(\"app\"), AssignExpr.Operator.ASSIGN)));\n-        \n-        ConstructorDeclaration emptyConstructorDeclaration = new ConstructorDeclaration()\n-                .setName(targetTypeName)\n-                .addModifier(Modifier.Keyword.PUBLIC);\n-        \n+        ConstructorDeclaration constructorDeclaration = getConstructorDeclaration().addParameter(appCanonicalName, APPLICATION);\n+        BlockStmt constructorBody = new BlockStmt()\n+                // super(module.config().process())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39008da486570df4eac7e69291072f20b730b843"}, "originalPosition": 255}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "39008da486570df4eac7e69291072f20b730b843", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/39008da486570df4eac7e69291072f20b730b843", "committedDate": "2020-09-15T12:07:56Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "d8e66648b60819464920316cf674e10a667a8d1d", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/d8e66648b60819464920316cf674e10a667a8d1d", "committedDate": "2020-09-15T13:33:42Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd58590ffcc630ad4e7780f185618151e311cd0a", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/dd58590ffcc630ad4e7780f185618151e311cd0a", "committedDate": "2020-09-15T14:16:00Z", "message": "[KOGITO-2766] Calling activate from constructor"}, "afterCommit": {"oid": "7323bdc7aaef7dd21c27920047572a6d02c4437b", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7323bdc7aaef7dd21c27920047572a6d02c4437b", "committedDate": "2020-09-15T14:19:25Z", "message": "[KOGITO-2766] Calling activate from constructor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7323bdc7aaef7dd21c27920047572a6d02c4437b", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/7323bdc7aaef7dd21c27920047572a6d02c4437b", "committedDate": "2020-09-15T14:19:25Z", "message": "[KOGITO-2766] Calling activate from constructor"}, "afterCommit": {"oid": "f4a7419d6f6c290514b84794ebb10760db8f4f2c", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f4a7419d6f6c290514b84794ebb10760db8f4f2c", "committedDate": "2020-09-15T14:26:10Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4Nzg5NDc2", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#pullrequestreview-488789476", "createdAt": "2020-09-15T15:11:49Z", "commit": {"oid": "f4a7419d6f6c290514b84794ebb10760db8f4f2c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNToxMTo0OVrOHSGxYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNTozODoyNFrOHSH-lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc0NzM2MQ==", "bodyText": "As far as I can see this concept only exists in Spring and not in CDI (even if quarkus impl should be lazy by default).\nWhy do you need it?\nMinor note, can you add a javadoc?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488747361", "createdAt": "2020-09-15T15:11:49Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java", "diffHunk": "@@ -137,6 +136,8 @@\n      * @param defaultValue value to be used in case there is no config parameter defined\n      */\n     <T extends NodeWithAnnotations<?>> T withConfigInjection(T node, String configKey, String defaultValue);\n+ \n+    default <T extends NodeWithAnnotations<?>> T withLazyInit(T node) { return node; }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a7419d6f6c290514b84794ebb10760db8f4f2c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MzQxMw==", "bodyText": "What about return Optional<MethodDeclaration>?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488753413", "createdAt": "2020-09-15T15:19:42Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -268,105 +276,58 @@ private MethodCallExpr createProcessRuntime() {\n     }\n     \n     private MethodDeclaration internalConfigure(ProcessMetaData processMetaData) {\n-        BlockStmt body = new BlockStmt();\n-        MethodDeclaration internalConfigure = new MethodDeclaration()\n-                .setModifiers(Modifier.Keyword.PUBLIC)\n-                .setType(targetTypeName)\n-                .setName(\"configure\")\n-                .setBody(body);   \n-        \n-        // always call super.configure\n-        body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n-\n-        if (!processMetaData.getGeneratedHandlers().isEmpty()) {\n-            \n-            processMetaData.getGeneratedHandlers().forEach((name, handler) -> {\n-                ClassOrInterfaceDeclaration clazz = handler.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                if (useInjection()) {\n-                                       \n-                    annotator.withApplicationComponent(clazz);\n-                    BlockStmt actionBody = new BlockStmt();\n-                    LambdaExpr forachBody = new LambdaExpr(new Parameter(new UnknownType(), \"h\"), actionBody);\n-                    MethodCallExpr forachHandler = new MethodCallExpr(new NameExpr(\"handlers\"), \"forEach\");                    \n-                    forachHandler.addArgument(forachBody);\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new MethodCallExpr(new NameExpr(\"h\"), \"getName\")).addArgument(new NameExpr(\"h\"));\n-                    \n-                    actionBody.addStatement(registerHandler);\n-                    \n-                    body.addStatement(forachHandler);\n-                } else {\n-                \n-                    String packageName = handler.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                    String clazzName = clazz.getName().toString();\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new StringLiteralExpr(name)).addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n-                    \n-                    body.addStatement(registerHandler);\n-                }\n-                // annotate for injection or add constructor for initialization\n-                handler.findAll(FieldDeclaration.class).forEach(fd -> {\n-                    if (useInjection()) {\n-                        annotator.withInjection(fd);\n-                    } else {\n-                        BlockStmt constructorBody = new BlockStmt();\n-                        AssignExpr assignExpr = new AssignExpr(\n-                                                               new FieldAccessExpr(new ThisExpr(), fd.getVariable(0).getNameAsString()),\n-                                                               new ObjectCreationExpr().setType(fd.getVariable(0).getType().toString()),\n-                                                               AssignExpr.Operator.ASSIGN);\n-                        \n-                        constructorBody.addStatement(assignExpr);\n-                        clazz.addConstructor(Keyword.PUBLIC).setBody(constructorBody);\n-                    }\n-                });\n-                \n-                \n-                additionalClasses.add(handler);\n-            });\n-        }\n+       \n         if (!processMetaData.getGeneratedListeners().isEmpty()) {\n+            BlockStmt body = new BlockStmt();\n+            MethodDeclaration internalConfigure = new MethodDeclaration()\n+                    .setModifiers(Modifier.Keyword.PUBLIC)\n+                    .setType(targetTypeName)\n+                    .setName(\"configure\")\n+                    .setBody(body);   \n             \n+            // always call super.configure\n+            body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n             processMetaData.getGeneratedListeners().forEach(listener -> {\n-                \n                 ClassOrInterfaceDeclaration clazz = listener.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                String packageName = listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                String clazzName = clazz.getName().toString();\n-                \n-                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");            \n-                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n+                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");\n+                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\")\n+                    .addArgument(\n+                        new ObjectCreationExpr(\n+                            null,\n+                            new ClassOrInterfaceType(\n+                                null,\n+                                listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\") + \".\" +clazz.getName()),\n+                            NodeList.nodeList()));\n                 \n                 body.addStatement(registerListener);\n                 \n                 additionalClasses.add(listener);\n             });\n+            body.addStatement(new ReturnStmt(new ThisExpr()));\n+            return internalConfigure;\n         }\n+        return null;\n         \n-        body.addStatement(new ReturnStmt(new ThisExpr()));\n-        \n-        return internalConfigure;\n+       \n     }\n     \n     private MethodDeclaration internalRegisterListeners(ProcessMetaData processMetaData) {\n-        BlockStmt body = new BlockStmt();\n-        MethodDeclaration internalRegisterListeners = new MethodDeclaration()\n-                .setModifiers(Modifier.Keyword.PROTECTED)\n-                .setType(void.class)\n-                .setName(\"registerListeners\")\n-                .setBody(body);   \n-                \n         if (!processMetaData.getSubProcesses().isEmpty()) {\n+            BlockStmt body = new BlockStmt();\n+            MethodDeclaration internalRegisterListeners = new MethodDeclaration()\n+                    .setModifiers(Modifier.Keyword.PROTECTED)\n+                    .setType(void.class)\n+                    .setName(\"registerListeners\")\n+                    .setBody(body);   \n             \n             for (Entry<String, String> subProcess : processMetaData.getSubProcesses().entrySet()) {\n                 MethodCallExpr signalManager = new MethodCallExpr(new NameExpr(\"services\"), \"getSignalManager\");\n                 MethodCallExpr registerListener = new MethodCallExpr(signalManager, \"addEventListener\").addArgument(new StringLiteralExpr(subProcess.getValue())).addArgument(new NameExpr(\"completionEventListener\"));\n-                \n                 body.addStatement(registerListener);\n             }\n+            return internalRegisterListeners;\n         }\n-        \n-        return internalRegisterListeners;\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a7419d6f6c290514b84794ebb10760db8f4f2c"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1NTI5OQ==", "bodyText": "What about return Optional<MethodDeclaration>?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488755299", "createdAt": "2020-09-15T15:22:17Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -268,105 +276,58 @@ private MethodCallExpr createProcessRuntime() {\n     }\n     \n     private MethodDeclaration internalConfigure(ProcessMetaData processMetaData) {\n-        BlockStmt body = new BlockStmt();\n-        MethodDeclaration internalConfigure = new MethodDeclaration()\n-                .setModifiers(Modifier.Keyword.PUBLIC)\n-                .setType(targetTypeName)\n-                .setName(\"configure\")\n-                .setBody(body);   \n-        \n-        // always call super.configure\n-        body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n-\n-        if (!processMetaData.getGeneratedHandlers().isEmpty()) {\n-            \n-            processMetaData.getGeneratedHandlers().forEach((name, handler) -> {\n-                ClassOrInterfaceDeclaration clazz = handler.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                if (useInjection()) {\n-                                       \n-                    annotator.withApplicationComponent(clazz);\n-                    BlockStmt actionBody = new BlockStmt();\n-                    LambdaExpr forachBody = new LambdaExpr(new Parameter(new UnknownType(), \"h\"), actionBody);\n-                    MethodCallExpr forachHandler = new MethodCallExpr(new NameExpr(\"handlers\"), \"forEach\");                    \n-                    forachHandler.addArgument(forachBody);\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new MethodCallExpr(new NameExpr(\"h\"), \"getName\")).addArgument(new NameExpr(\"h\"));\n-                    \n-                    actionBody.addStatement(registerHandler);\n-                    \n-                    body.addStatement(forachHandler);\n-                } else {\n-                \n-                    String packageName = handler.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                    String clazzName = clazz.getName().toString();\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new StringLiteralExpr(name)).addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n-                    \n-                    body.addStatement(registerHandler);\n-                }\n-                // annotate for injection or add constructor for initialization\n-                handler.findAll(FieldDeclaration.class).forEach(fd -> {\n-                    if (useInjection()) {\n-                        annotator.withInjection(fd);\n-                    } else {\n-                        BlockStmt constructorBody = new BlockStmt();\n-                        AssignExpr assignExpr = new AssignExpr(\n-                                                               new FieldAccessExpr(new ThisExpr(), fd.getVariable(0).getNameAsString()),\n-                                                               new ObjectCreationExpr().setType(fd.getVariable(0).getType().toString()),\n-                                                               AssignExpr.Operator.ASSIGN);\n-                        \n-                        constructorBody.addStatement(assignExpr);\n-                        clazz.addConstructor(Keyword.PUBLIC).setBody(constructorBody);\n-                    }\n-                });\n-                \n-                \n-                additionalClasses.add(handler);\n-            });\n-        }\n+       \n         if (!processMetaData.getGeneratedListeners().isEmpty()) {\n+            BlockStmt body = new BlockStmt();\n+            MethodDeclaration internalConfigure = new MethodDeclaration()\n+                    .setModifiers(Modifier.Keyword.PUBLIC)\n+                    .setType(targetTypeName)\n+                    .setName(\"configure\")\n+                    .setBody(body);   \n             \n+            // always call super.configure\n+            body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n             processMetaData.getGeneratedListeners().forEach(listener -> {\n-                \n                 ClassOrInterfaceDeclaration clazz = listener.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                String packageName = listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                String clazzName = clazz.getName().toString();\n-                \n-                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");            \n-                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n+                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");\n+                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\")\n+                    .addArgument(\n+                        new ObjectCreationExpr(\n+                            null,\n+                            new ClassOrInterfaceType(\n+                                null,\n+                                listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\") + \".\" +clazz.getName()),\n+                            NodeList.nodeList()));\n                 \n                 body.addStatement(registerListener);\n                 \n                 additionalClasses.add(listener);\n             });\n+            body.addStatement(new ReturnStmt(new ThisExpr()));\n+            return internalConfigure;\n         }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a7419d6f6c290514b84794ebb10760db8f4f2c"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1Nzk5Nw==", "bodyText": "Can you please rename the method to better explain its scope? Something like initializeField or similar", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488757997", "createdAt": "2020-09-15T15:25:54Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -548,6 +535,30 @@ public ClassOrInterfaceDeclaration classDeclaration() {\n         return cls;\n     }\n \n+    \n+    private ConstructorDeclaration getConstructorDeclaration() {\n+        return new ConstructorDeclaration()\n+            .setName(targetTypeName)\n+            .addModifier(Modifier.Keyword.PUBLIC);\n+    }\n+\n+    \n+    private void forEachField (ClassOrInterfaceDeclaration clazz, FieldDeclaration fd) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a7419d6f6c290514b84794ebb10760db8f4f2c"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2MjMyMg==", "bodyText": "If you make them return Optional<MethodDeclaration> you can replace with something like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    MethodDeclaration configure = internalConfigure(processMetaData);\n          \n          \n            \n                    if (configure != null) {\n          \n          \n            \n                        cls.addMember(configure);\n          \n          \n            \n                    }\n          \n          \n            \n                    MethodDeclaration registerListener = internalRegisterListeners(processMetaData);\n          \n          \n            \n                    if (registerListener != null) {\n          \n          \n            \n                        cls.addMember(registerListener);\n          \n          \n            \n                    }\n          \n          \n            \n                    internalConfigure(processMetaData).ifPresent(cls::addMember);\n          \n          \n            \n                    internalRegisterListeners(processMetaData).ifPresent(cls::addMember);", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488762322", "createdAt": "2020-09-15T15:31:38Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -382,76 +343,113 @@ public ClassOrInterfaceDeclaration classDeclaration() {\n         ClassOrInterfaceDeclaration cls = new ClassOrInterfaceDeclaration()\n                 .setName(targetTypeName)\n                 .setModifiers(Modifier.Keyword.PUBLIC);\n-\n-        if (useInjection()) {\n-            annotator.withNamedApplicationComponent(cls, process.getId());\n-            \n-            FieldDeclaration handlersInjectFieldDeclaration = new FieldDeclaration()\n-                    .addVariable(new VariableDeclarator(new ClassOrInterfaceType(null, new SimpleName(annotator.multiInstanceInjectionType()), NodeList.nodeList(new ClassOrInterfaceType(null, WorkItemHandler.class.getCanonicalName()))), \"handlers\"));\n-            annotator.withOptionalInjection(handlersInjectFieldDeclaration);\n-            \n-            cls.addMember(handlersInjectFieldDeclaration);\n-        }\n-\n+        ProcessMetaData processMetaData = processGenerator.generate();\n         String processInstanceFQCN = ProcessInstanceGenerator.qualifiedName(packageName, typeName);\n-\n-        FieldDeclaration fieldDeclaration = new FieldDeclaration()\n-                .addVariable(new VariableDeclarator(new ClassOrInterfaceType(null, appCanonicalName), \"app\"));\n-\n-        ConstructorDeclaration constructorDeclaration = new ConstructorDeclaration()\n-                .setName(targetTypeName)\n-                .addModifier(Modifier.Keyword.PUBLIC)\n-                .addParameter(appCanonicalName, \"app\")\n-                .setBody(new BlockStmt()\n-                                 // super(module.config().process())\n-                                 .addStatement(new MethodCallExpr(null, \"super\")\n-                                              .addArgument(\n-                                                      new MethodCallExpr(\n-                                                              new MethodCallExpr(new NameExpr(\"app\"), \"config\"),\n-                                                              \"process\")))\n-                                 .addStatement(\n-                                         new AssignExpr(new FieldAccessExpr(new ThisExpr(), \"app\"), new NameExpr(\"app\"), AssignExpr.Operator.ASSIGN)));\n-        \n-        ConstructorDeclaration emptyConstructorDeclaration = new ConstructorDeclaration()\n-                .setName(targetTypeName)\n-                .addModifier(Modifier.Keyword.PUBLIC);\n-        \n+        ConstructorDeclaration constructorDeclaration = getConstructorDeclaration().addParameter(appCanonicalName, APPLICATION);\n+        BlockStmt constructorBody = new BlockStmt()\n+                // super(module.config().process())\n+                .addStatement(\n+                              new MethodCallExpr(null, \"super\")\n+                                  .addArgument(\n+                                               new MethodCallExpr(\n+                                                   new MethodCallExpr(new NameExpr(APPLICATION), \"config\"),\n+                                                   \"process\")))\n+                .addStatement(\n+                              new AssignExpr(\n+                                  new FieldAccessExpr(new ThisExpr(), APPLICATION),\n+                                  new NameExpr(APPLICATION),\n+                                  AssignExpr.Operator.ASSIGN));\n+        constructorDeclaration.setBody(constructorBody);\n         if (useInjection()) {\n+            annotator.withNamedApplicationComponent(cls, process.getId());\n             annotator.withInjection(constructorDeclaration);\n-        } else {\n-        \n-            emptyConstructorDeclaration\n-                .setBody(new BlockStmt()\n-                                 .addStatement(\n-                                         new MethodCallExpr(null, \"this\").addArgument(new ObjectCreationExpr().setType(appCanonicalName))));\n         }\n         \n-        MethodDeclaration createModelMethod = new MethodDeclaration()\n-                .addModifier(Keyword.PUBLIC)\n-                .setName(CREATE_MODEL)\n-                .setType(modelTypeName)\n-                .setBody(new BlockStmt()\n-                         .addStatement(new ReturnStmt(new ObjectCreationExpr(null, \n-                                                                             new ClassOrInterfaceType(null, modelTypeName), \n-                                                                             NodeList.nodeList()))));               \n+        Map<String, CompilationUnit> handlers = processMetaData.getGeneratedHandlers();\n+        if (!handlers.isEmpty()) {\n+            constructorBody.addStatement(\n+                          new VariableDeclarationExpr(\n+                              new VariableDeclarator(\n+                                  parseClassOrInterfaceType(WorkItemManager.class.getCanonicalName()),\n+                                  WORK_ITEM_MANAGER,\n+                                  new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\"))));\n+            \n+            MethodCallExpr initMethodCall = new MethodCallExpr(null, \"this\").addArgument(new NameExpr(APPLICATION));\n+            cls\n+                .addMember(\n+                           getConstructorDeclaration()\n+                               .addParameter(appCanonicalName, APPLICATION)\n+                               .setBody(new BlockStmt().addStatement(initMethodCall)));\n+\n+            for (Entry<String, CompilationUnit> handler : handlers.entrySet()) {\n+                String varName = handler.getKey().substring(handler.getKey().lastIndexOf('.') + 1);\n+                varName = Character.toLowerCase(varName.charAt(0)) + varName.substring(1);\n+                ClassOrInterfaceDeclaration clazz =\n+                        handler\n+                            .getValue()\n+                            .findFirst(ClassOrInterfaceDeclaration.class)\n+                            .orElseThrow(() -> new NoSuchElementException(\"Compilation unit doesn't contain a method declaration!\"));\n+                String clazzName =\n+                        handler.getValue().getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\") +\n+                                   '.' + clazz.getName();\n+\n+                Parameter parameter = new Parameter(parseClassOrInterfaceType(clazzName), varName);\n+                if (useInjection()) {\n+                    annotator.withApplicationComponent(clazz);\n+                    annotator.withLazyInit(parameter);\n+                } \n+                initMethodCall\n+                    .addArgument(\n+                                 new ObjectCreationExpr(\n+                                     null,\n+                                     new ClassOrInterfaceType(null, clazzName),\n+                                     NodeList.nodeList()));\n+\n+                constructorDeclaration.addParameter(parameter);\n+                constructorBody\n+                    .addStatement(\n+                                  new MethodCallExpr(new NameExpr(WORK_ITEM_MANAGER), \"registerWorkItemHandler\")\n+                                      .addArgument(new StringLiteralExpr(handler.getKey()))\n+                                      .addArgument(new NameExpr(varName)));\n+                handler.getValue().findAll(FieldDeclaration.class).forEach(fd -> forEachField(clazz, fd));\n+                additionalClasses.add(handler.getValue());\n+            }\n+        }\n         \n-        ProcessMetaData processMetaData = processGenerator.generate();\n+        constructorBody.addStatement(new MethodCallExpr(new ThisExpr(), \"activate\"));\n \n         cls.addExtendedType(abstractProcessType(modelTypeName))\n-                .addMember(fieldDeclaration)\n-                .addMember(emptyConstructorDeclaration)\n+                .addMember(new FieldDeclaration()\n+                           .addVariable(new VariableDeclarator(new ClassOrInterfaceType(null, appCanonicalName), APPLICATION)))\n                 .addMember(constructorDeclaration)\n+                .addMember(getConstructorDeclaration())\n                 .addMember(createInstanceMethod(processInstanceFQCN))\n                 .addMember(createInstanceWithBusinessKeyMethod(processInstanceFQCN))\n-                .addMember(createModelMethod)\n+                .addMember(new MethodDeclaration()\n+                           .addModifier(Keyword.PUBLIC)\n+                           .setName(CREATE_MODEL)\n+                           .setType(modelTypeName)\n+                           .addAnnotation(Override.class)\n+                           .setBody(new BlockStmt()\n+                                    .addStatement(new ReturnStmt(new ObjectCreationExpr(null, \n+                                                                                        new ClassOrInterfaceType(null, modelTypeName), \n+                                                                                        NodeList.nodeList())))))\n                 .addMember(createInstanceGenericMethod(processInstanceFQCN))\n                 .addMember(createInstanceGenericWithBusinessKeyMethod(processInstanceFQCN))\n                 .addMember(createInstanceGenericWithWorkflowInstanceMethod(processInstanceFQCN))\n                 .addMember(createReadOnlyInstanceGenericWithWorkflowInstanceMethod(processInstanceFQCN))\n-                .addMember(internalConfigure(processMetaData))\n-                .addMember(internalRegisterListeners(processMetaData))\n                 .addMember(process(processMetaData));\n+\n         \n+        MethodDeclaration configure = internalConfigure(processMetaData);\n+        if (configure != null) {\n+            cls.addMember(configure);\n+        }\n+        MethodDeclaration registerListener = internalRegisterListeners(processMetaData);\n+        if (registerListener != null) {\n+            cls.addMember(registerListener);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a7419d6f6c290514b84794ebb10760db8f4f2c"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2NzEyNg==", "bodyText": "If getPackageDeclaration() returns an empty Optional this will produce an invalid string: .ClassName\nCan you please verify if getPackageDeclaration() can be empty (i.e. default package)?\nIf not I think it is better to throw an exception like \"This should never happen\" instead of a empty string.\nIn general we can probably replace the code with this alternative\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\") + \".\" +clazz.getName()),\n          \n          \n            \n                                            listener.getPackageDeclaration().map(pd -> pd.getName().toString() + \".\" + clazz.getName()).orElse(clazz.getName()),\n          \n      \n    \n    \n  \n\nWdyt?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r488767126", "createdAt": "2020-09-15T15:38:24Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessGenerator.java", "diffHunk": "@@ -268,105 +276,58 @@ private MethodCallExpr createProcessRuntime() {\n     }\n     \n     private MethodDeclaration internalConfigure(ProcessMetaData processMetaData) {\n-        BlockStmt body = new BlockStmt();\n-        MethodDeclaration internalConfigure = new MethodDeclaration()\n-                .setModifiers(Modifier.Keyword.PUBLIC)\n-                .setType(targetTypeName)\n-                .setName(\"configure\")\n-                .setBody(body);   \n-        \n-        // always call super.configure\n-        body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n-\n-        if (!processMetaData.getGeneratedHandlers().isEmpty()) {\n-            \n-            processMetaData.getGeneratedHandlers().forEach((name, handler) -> {\n-                ClassOrInterfaceDeclaration clazz = handler.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                if (useInjection()) {\n-                                       \n-                    annotator.withApplicationComponent(clazz);\n-                    BlockStmt actionBody = new BlockStmt();\n-                    LambdaExpr forachBody = new LambdaExpr(new Parameter(new UnknownType(), \"h\"), actionBody);\n-                    MethodCallExpr forachHandler = new MethodCallExpr(new NameExpr(\"handlers\"), \"forEach\");                    \n-                    forachHandler.addArgument(forachBody);\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new MethodCallExpr(new NameExpr(\"h\"), \"getName\")).addArgument(new NameExpr(\"h\"));\n-                    \n-                    actionBody.addStatement(registerHandler);\n-                    \n-                    body.addStatement(forachHandler);\n-                } else {\n-                \n-                    String packageName = handler.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                    String clazzName = clazz.getName().toString();\n-                    \n-                    MethodCallExpr workItemManager = new MethodCallExpr(new NameExpr(\"services\"), \"getWorkItemManager\");            \n-                    MethodCallExpr registerHandler = new MethodCallExpr(workItemManager, \"registerWorkItemHandler\").addArgument(new StringLiteralExpr(name)).addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n-                    \n-                    body.addStatement(registerHandler);\n-                }\n-                // annotate for injection or add constructor for initialization\n-                handler.findAll(FieldDeclaration.class).forEach(fd -> {\n-                    if (useInjection()) {\n-                        annotator.withInjection(fd);\n-                    } else {\n-                        BlockStmt constructorBody = new BlockStmt();\n-                        AssignExpr assignExpr = new AssignExpr(\n-                                                               new FieldAccessExpr(new ThisExpr(), fd.getVariable(0).getNameAsString()),\n-                                                               new ObjectCreationExpr().setType(fd.getVariable(0).getType().toString()),\n-                                                               AssignExpr.Operator.ASSIGN);\n-                        \n-                        constructorBody.addStatement(assignExpr);\n-                        clazz.addConstructor(Keyword.PUBLIC).setBody(constructorBody);\n-                    }\n-                });\n-                \n-                \n-                additionalClasses.add(handler);\n-            });\n-        }\n+       \n         if (!processMetaData.getGeneratedListeners().isEmpty()) {\n+            BlockStmt body = new BlockStmt();\n+            MethodDeclaration internalConfigure = new MethodDeclaration()\n+                    .setModifiers(Modifier.Keyword.PUBLIC)\n+                    .setType(targetTypeName)\n+                    .setName(\"configure\")\n+                    .setBody(body);   \n             \n+            // always call super.configure\n+            body.addStatement(new MethodCallExpr(new SuperExpr(), \"configure\"));\n             processMetaData.getGeneratedListeners().forEach(listener -> {\n-                \n                 ClassOrInterfaceDeclaration clazz = listener.findFirst(ClassOrInterfaceDeclaration.class).get();\n-                String packageName = listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n-                String clazzName = clazz.getName().toString();\n-                \n-                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");            \n-                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, packageName + \".\" + clazzName), NodeList.nodeList()));\n+                MethodCallExpr eventSupport = new MethodCallExpr(new NameExpr(\"services\"), \"getEventSupport\");\n+                MethodCallExpr registerListener = new MethodCallExpr(eventSupport, \"addEventListener\")\n+                    .addArgument(\n+                        new ObjectCreationExpr(\n+                            null,\n+                            new ClassOrInterfaceType(\n+                                null,\n+                                listener.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\") + \".\" +clazz.getName()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a7419d6f6c290514b84794ebb10760db8f4f2c"}, "originalPosition": 166}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f4a7419d6f6c290514b84794ebb10760db8f4f2c", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/f4a7419d6f6c290514b84794ebb10760db8f4f2c", "committedDate": "2020-09-15T14:26:10Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}, "afterCommit": {"oid": "b3679780366a503252dd72447f32d79ccecd0a91", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b3679780366a503252dd72447f32d79ccecd0a91", "committedDate": "2020-09-15T16:01:34Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b3679780366a503252dd72447f32d79ccecd0a91", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b3679780366a503252dd72447f32d79ccecd0a91", "committedDate": "2020-09-15T16:01:34Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}, "afterCommit": {"oid": "5b06fe0f50ce60a7fcab5194995d45518360f0f0", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/5b06fe0f50ce60a7fcab5194995d45518360f0f0", "committedDate": "2020-09-15T16:23:33Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5b06fe0f50ce60a7fcab5194995d45518360f0f0", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/5b06fe0f50ce60a7fcab5194995d45518360f0f0", "committedDate": "2020-09-15T16:23:33Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}, "afterCommit": {"oid": "64c760c6733ab705a3f46d3a0240c0c2eec88926", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/64c760c6733ab705a3f46d3a0240c0c2eec88926", "committedDate": "2020-09-15T16:29:21Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64c760c6733ab705a3f46d3a0240c0c2eec88926", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/64c760c6733ab705a3f46d3a0240c0c2eec88926", "committedDate": "2020-09-15T16:29:21Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}, "afterCommit": {"oid": "8a6d8cf8f0bb7d3c08affb6d16138ad98b5deb56", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/8a6d8cf8f0bb7d3c08affb6d16138ad98b5deb56", "committedDate": "2020-09-15T16:35:05Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NDcwNjcy", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#pullrequestreview-489470672", "createdAt": "2020-09-16T10:04:22Z", "commit": {"oid": "8a6d8cf8f0bb7d3c08affb6d16138ad98b5deb56"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8a6d8cf8f0bb7d3c08affb6d16138ad98b5deb56", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/8a6d8cf8f0bb7d3c08affb6d16138ad98b5deb56", "committedDate": "2020-09-15T16:35:05Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}, "afterCommit": {"oid": "668b8e79abdda43f950a77e32491698567ea5e7f", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/668b8e79abdda43f950a77e32491698567ea5e7f", "committedDate": "2020-09-16T11:35:04Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "668b8e79abdda43f950a77e32491698567ea5e7f", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/668b8e79abdda43f950a77e32491698567ea5e7f", "committedDate": "2020-09-16T11:35:04Z", "message": "[KOGITO-2766] Calling activate from constructor\n\nAnd removing not any longer withInitMethod"}, "afterCommit": {"oid": "3d2ad936d693997dbfbc15bfe60ead62fe128ed0", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/3d2ad936d693997dbfbc15bfe60ead62fe128ed0", "committedDate": "2020-09-16T11:42:56Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d2ad936d693997dbfbc15bfe60ead62fe128ed0", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/3d2ad936d693997dbfbc15bfe60ead62fe128ed0", "committedDate": "2020-09-16T11:42:56Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "2d7d170ffc68fe262f7348ff7f06f3e2e85a7c6f", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/2d7d170ffc68fe262f7348ff7f06f3e2e85a7c6f", "committedDate": "2020-09-16T12:18:16Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d7d170ffc68fe262f7348ff7f06f3e2e85a7c6f", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/2d7d170ffc68fe262f7348ff7f06f3e2e85a7c6f", "committedDate": "2020-09-16T12:18:16Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "621cf3fb7cd161c75ffccb2582f07e54510e0f45", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/621cf3fb7cd161c75ffccb2582f07e54510e0f45", "committedDate": "2020-09-16T12:21:49Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "621cf3fb7cd161c75ffccb2582f07e54510e0f45", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/621cf3fb7cd161c75ffccb2582f07e54510e0f45", "committedDate": "2020-09-16T12:21:49Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "cc5bec2f30055b626143312e7df259fffb856d9e", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/cc5bec2f30055b626143312e7df259fffb856d9e", "committedDate": "2020-09-16T12:31:11Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cc5bec2f30055b626143312e7df259fffb856d9e", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/cc5bec2f30055b626143312e7df259fffb856d9e", "committedDate": "2020-09-16T12:31:11Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "1a4e7812c48f489300dfbe6621c4c4c51a7a723b", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1a4e7812c48f489300dfbe6621c4c4c51a7a723b", "committedDate": "2020-09-16T12:53:18Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a4e7812c48f489300dfbe6621c4c4c51a7a723b", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/1a4e7812c48f489300dfbe6621c4c4c51a7a723b", "committedDate": "2020-09-16T12:53:18Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "ce2470fec8eb328521d6acec77e0852de84b500f", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/ce2470fec8eb328521d6acec77e0852de84b500f", "committedDate": "2020-09-16T13:07:28Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NjMzMTcy", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#pullrequestreview-489633172", "createdAt": "2020-09-16T13:37:12Z", "commit": {"oid": "ce2470fec8eb328521d6acec77e0852de84b500f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce2470fec8eb328521d6acec77e0852de84b500f", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/ce2470fec8eb328521d6acec77e0852de84b500f", "committedDate": "2020-09-16T13:07:28Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "fb526db31592ec6f425ebda7d6dc712967f99898", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/fb526db31592ec6f425ebda7d6dc712967f99898", "committedDate": "2020-09-16T13:41:46Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb526db31592ec6f425ebda7d6dc712967f99898", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/fb526db31592ec6f425ebda7d6dc712967f99898", "committedDate": "2020-09-16T13:41:46Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "eb8ba60cd15d8df5774f11cfc4eaac7b1c0b6a60", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/eb8ba60cd15d8df5774f11cfc4eaac7b1c0b6a60", "committedDate": "2020-09-16T13:42:16Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5ODA3NDI1", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#pullrequestreview-489807425", "createdAt": "2020-09-16T16:39:15Z", "commit": {"oid": "eb8ba60cd15d8df5774f11cfc4eaac7b1c0b6a60"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNjozOToxNVrOHS5TTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNjozOToxNVrOHS5TTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3NTI0Nw==", "bodyText": "What about rename lazy to something like forceLazyInit or similar? Mainly because lazy=false doesn't mean eager but means \"use framework default\"", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#discussion_r489575247", "createdAt": "2020-09-16T16:39:15Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/di/DependencyInjectionAnnotator.java", "diffHunk": "@@ -86,8 +85,19 @@\n      * Annotates given node with injection annotations e.g. Inject, Autowire\n      *\n      * @param node node to be annotated\n+     * @boolean lazy use lazy initialization\n      */\n-    <T extends NodeWithAnnotations<?>> T withInjection(T node);\n+    <T extends NodeWithAnnotations<?>> T withInjection(T node, boolean lazy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb8ba60cd15d8df5774f11cfc4eaac7b1c0b6a60"}, "originalPosition": 15}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb8ba60cd15d8df5774f11cfc4eaac7b1c0b6a60", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/eb8ba60cd15d8df5774f11cfc4eaac7b1c0b6a60", "committedDate": "2020-09-16T13:42:16Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "9df588b31e9c9cac222fb124e25d9aa0f4aacdf7", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9df588b31e9c9cac222fb124e25d9aa0f4aacdf7", "committedDate": "2020-09-16T16:46:59Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b58330fba2f3e7d9c2da3d994470c40dbd0b8f66", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b58330fba2f3e7d9c2da3d994470c40dbd0b8f66", "committedDate": "2020-09-16T16:47:27Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9df588b31e9c9cac222fb124e25d9aa0f4aacdf7", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/9df588b31e9c9cac222fb124e25d9aa0f4aacdf7", "committedDate": "2020-09-16T16:46:59Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}, "afterCommit": {"oid": "b58330fba2f3e7d9c2da3d994470c40dbd0b8f66", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/kogito-runtimes/commit/b58330fba2f3e7d9c2da3d994470c40dbd0b8f66", "committedDate": "2020-09-16T16:47:27Z", "message": "[KOGITO-2766] Refactoring initialization code\n\nGenerated handlers are now passed to constructor explicitly (handlers\nfields is\nremoved), which registers them, both for injection and non injection\npaths\n\nConfigure and registerListeners methods are only generated if they have\ncontent (if there are listeners)\n\nIf injection is not used, activate method will be invoked from\nconstructor. If it is active, then it is invoked using quarkus start\nevent or springboot post construct as it is now."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMjEwMTQ4", "url": "https://github.com/kiegroup/kogito-runtimes/pull/763#pullrequestreview-490210148", "createdAt": "2020-09-17T03:01:40Z", "commit": {"oid": "b58330fba2f3e7d9c2da3d994470c40dbd0b8f66"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3947, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}