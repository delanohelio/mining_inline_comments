{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMDE2MTkx", "number": 749, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOToxNzowNVrOEiBuiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo1MzozMFrOEiSc6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTE1MzM5OnYy", "diffSide": "RIGHT", "path": "kogito-build-parent/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOToxNzowNVrOHPqsZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTozMjoyNVrOHPrR0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MDE4MA==", "bodyText": "Please remove comment.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486190180", "createdAt": "2020-09-10T09:17:05Z", "author": {"login": "jiripetrlik"}, "path": "kogito-build-parent/pom.xml", "diffHunk": "@@ -129,7 +129,8 @@\n     <version.org.keycloak>11.0.0</version.org.keycloak>\n     <version.org.mockito>3.3.3</version.org.mockito>\n     <version.org.mvel>2.4.7.Final</version.org.mvel>\n-    <version.org.kie7>7.43.0.t20200824</version.org.kie7>\n+<!--    <version.org.kie7>7.43.0.t20200824</version.org.kie7>-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60cc81b6af98b9cde4e11f9fb12d80008b8d8d38"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5OTc2MA==", "bodyText": "@jiripetrlik\nRemoved (leftover)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486199760", "createdAt": "2020-09-10T09:32:25Z", "author": {"login": "gitgabrio"}, "path": "kogito-build-parent/pom.xml", "diffHunk": "@@ -129,7 +129,8 @@\n     <version.org.keycloak>11.0.0</version.org.keycloak>\n     <version.org.mockito>3.3.3</version.org.mockito>\n     <version.org.mvel>2.4.7.Final</version.org.mvel>\n-    <version.org.kie7>7.43.0.t20200824</version.org.kie7>\n+<!--    <version.org.kie7>7.43.0.t20200824</version.org.kie7>-->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MDE4MA=="}, "originalCommit": {"oid": "60cc81b6af98b9cde4e11f9fb12d80008b8d8d38"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MTE1Njc5OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/prediction/PredictionRuleMappersGeneratorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOToxNzo1N1rOHPqudg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTozMjoxNlrOHPrRhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MDcxMA==", "bodyText": "I would suggest to use some logger instead.", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486190710", "createdAt": "2020-09-10T09:17:57Z", "author": {"login": "jiripetrlik"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/prediction/PredictionRuleMappersGeneratorTest.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.kie.kogito.codegen.prediction;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class PredictionRuleMappersGeneratorTest {\n+\n+    @Test\n+    void getPredictionRuleMapperSource() {\n+        final String predictionRuleMapper = \"PredictionRuleMapperImpl\";\n+        final String packageName = \"PACKAGE\";\n+        final List<String> generatedRuleMappers = IntStream.range(0, 4).mapToObj(index -> packageName + \".\" +\n+                \"subPack\" + index + \".\" + predictionRuleMapper).collect(Collectors.toList());\n+        String retrieved = PredictionRuleMappersGenerator.getPredictionRuleMappersSource(packageName,\n+                                                                                        generatedRuleMappers);\n+        assertNotNull(retrieved);\n+        String expected = String.format(\"package %s;\", packageName);\n+        assertTrue(retrieved.contains(expected));\n+        List<String> mod = generatedRuleMappers.stream().map(gen -> \"new \" + gen + \"()\").collect(Collectors.toList());\n+        expected = \"Arrays.asList(\" + String.join(\", \", mod) + \");\";\n+        assertTrue(retrieved.contains(expected));\n+        System.out.println(retrieved);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60cc81b6af98b9cde4e11f9fb12d80008b8d8d38"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5OTY4Ng==", "bodyText": "@jiripetrlik\nRemoved (leftover)", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486199686", "createdAt": "2020-09-10T09:32:16Z", "author": {"login": "gitgabrio"}, "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/prediction/PredictionRuleMappersGeneratorTest.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.kie.kogito.codegen.prediction;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class PredictionRuleMappersGeneratorTest {\n+\n+    @Test\n+    void getPredictionRuleMapperSource() {\n+        final String predictionRuleMapper = \"PredictionRuleMapperImpl\";\n+        final String packageName = \"PACKAGE\";\n+        final List<String> generatedRuleMappers = IntStream.range(0, 4).mapToObj(index -> packageName + \".\" +\n+                \"subPack\" + index + \".\" + predictionRuleMapper).collect(Collectors.toList());\n+        String retrieved = PredictionRuleMappersGenerator.getPredictionRuleMappersSource(packageName,\n+                                                                                        generatedRuleMappers);\n+        assertNotNull(retrieved);\n+        String expected = String.format(\"package %s;\", packageName);\n+        assertTrue(retrieved.contains(expected));\n+        List<String> mod = generatedRuleMappers.stream().map(gen -> \"new \" + gen + \"()\").collect(Collectors.toList());\n+        expected = \"Arrays.asList(\" + String.join(\", \", mod) + \");\";\n+        assertTrue(retrieved.contains(expected));\n+        System.out.println(retrieved);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MDcxMA=="}, "originalCommit": {"oid": "60cc81b6af98b9cde4e11f9fb12d80008b8d8d38"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg2OTMxOnYy", "diffSide": "RIGHT", "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/KieRuntimeFactoryBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo0NTo1NVrOHQFIPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzoyNzowM1rOHQRfww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzI5NQ==", "bodyText": "What about catch ReflectiveOperationException so that we can simplify and cover all reflection related exceptions just with one?  Only ClassCastExpection will probably remain in addition", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486623295", "createdAt": "2020-09-10T20:45:55Z", "author": {"login": "danielezonca"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/KieRuntimeFactoryBuilder.java", "diffHunk": "@@ -70,63 +73,65 @@ private KieRuntimeFactoryBuilder() {\n             final BiFunction<KnowledgeBuilderImpl, Resource, List<KiePMMLModel>> modelProducer) {\n         final Map<KieBase, KieRuntimeFactory> toReturn = new HashMap<>();\n         resources.forEach(resource -> {\n-            final String[] factoryClassNamePackageName = getFactoryClassNamePackageName(resource);\n             final KnowledgeBuilderImpl kbuilderImpl = createKnowledgeBuilderImpl(resource);\n             List<KiePMMLModel> toAdd = modelProducer.apply(kbuilderImpl, resource);\n             if (toAdd.isEmpty()) {\n                 throw new KiePMMLException(\"Failed to retrieve compiled models\");\n             }\n-            for (KiePMMLModel kiePMMLModel : toAdd) {\n-                InternalKnowledgePackage internalKnowledgePackage =\n-                        kbuilderImpl.getKnowledgeBase().getPackage(factoryClassNamePackageName[1]);\n-                if (internalKnowledgePackage == null) {\n-                    PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n-                    PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n-                    internalKnowledgePackage = pkgReg.getPackage();\n-                }\n-                PMMLPackage pmmlPkg =\n-                        internalKnowledgePackage.getResourceTypePackages().computeIfAbsent(\n-                                ResourceType.PMML,\n-                                rtp -> new PMMLPackageImpl());\n-                pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n-            }\n+            addModels(kbuilderImpl, toAdd);\n             KieBase kieBase = kbuilderImpl.getKnowledgeBase();\n             toReturn.put(kieBase, KieRuntimeFactory.of(kieBase));\n         });\n         return toReturn;\n     }\n \n+    private static void addModels(final KnowledgeBuilderImpl kbuilderImpl, final List<KiePMMLModel> toAdd) {\n+        for (KiePMMLModel kiePMMLModel : toAdd) {\n+            PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n+            PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n+            InternalKnowledgePackage kpkgs = pkgReg.getPackage();\n+            PMMLPackage pmmlPkg =\n+                    kpkgs.getResourceTypePackages().computeIfAbsent(\n+                            ResourceType.PMML,\n+                            rtp -> new PMMLPackageImpl());\n+            pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n+            if (kiePMMLModel instanceof HasNestedModels) {\n+                addModels(kbuilderImpl, ((HasNestedModels) kiePMMLModel).getNestedModels());\n+            }\n+        }\n+    }\n+\n     private static KnowledgeBuilderImpl createKnowledgeBuilderImpl(final Resource resource) {\n         KnowledgeBaseImpl defaultKnowledgeBase = new KnowledgeBaseImpl(\"PMML\", null);\n         KnowledgeBuilderImpl toReturn = new KnowledgeBuilderImpl(defaultKnowledgeBase);\n-        PredictionRuleMapper pmmlRuleMapper = loadPMMLRuleMapper(toReturn.getRootClassLoader(), resource);\n-        if (pmmlRuleMapper != null) {\n-            String ruleName = pmmlRuleMapper.getRuleName();\n-            Model model = loadModel(toReturn.getRootClassLoader(), ruleName);\n-            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(model));\n+        List<PredictionRuleMapper> pmmlRuleMappers = loadPMMLRuleMappers(toReturn.getRootClassLoader(), resource);\n+        if (!pmmlRuleMappers.isEmpty()) {\n+            List<Model> models =\n+                    pmmlRuleMappers.stream()\n+                            .map(PredictionRuleMapper::getModel)\n+                            .collect(Collectors.toList());\n+            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(models));\n         }\n         return toReturn;\n     }\n \n-    private static PredictionRuleMapper loadPMMLRuleMapper(final ClassLoader classLoader,\n-                                                           final Resource resource) {\n+    private static List<PredictionRuleMapper> loadPMMLRuleMappers(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n+        PredictionRuleMappers predictionRuleMappers = loadPMMLRuleMappersClass(classLoader, resource);\n+        return predictionRuleMappers.getPredictionRuleMappers();\n+    }\n+\n+    private static PredictionRuleMappers loadPMMLRuleMappersClass(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n         String[] classNamePackageName = getFactoryClassNamePackageName(resource);\n         String packageName = classNamePackageName[1];\n-        String fullPMMLRuleMapperClassName = packageName + \".PredictionRuleMapperImpl\";\n+        String fullPMMLRuleMappersClassName = packageName + \".PredictionRuleMappersImpl\";\n         try {\n-            return (PredictionRuleMapper) classLoader.loadClass(fullPMMLRuleMapperClassName).getDeclaredConstructor().newInstance();\n+            return (PredictionRuleMappers) classLoader.loadClass(fullPMMLRuleMappersClassName).getDeclaredConstructor().newInstance();\n         } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | ClassCastException | NoSuchMethodException | InvocationTargetException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyNTkyMw==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486825923", "createdAt": "2020-09-11T07:27:03Z", "author": {"login": "gitgabrio"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/KieRuntimeFactoryBuilder.java", "diffHunk": "@@ -70,63 +73,65 @@ private KieRuntimeFactoryBuilder() {\n             final BiFunction<KnowledgeBuilderImpl, Resource, List<KiePMMLModel>> modelProducer) {\n         final Map<KieBase, KieRuntimeFactory> toReturn = new HashMap<>();\n         resources.forEach(resource -> {\n-            final String[] factoryClassNamePackageName = getFactoryClassNamePackageName(resource);\n             final KnowledgeBuilderImpl kbuilderImpl = createKnowledgeBuilderImpl(resource);\n             List<KiePMMLModel> toAdd = modelProducer.apply(kbuilderImpl, resource);\n             if (toAdd.isEmpty()) {\n                 throw new KiePMMLException(\"Failed to retrieve compiled models\");\n             }\n-            for (KiePMMLModel kiePMMLModel : toAdd) {\n-                InternalKnowledgePackage internalKnowledgePackage =\n-                        kbuilderImpl.getKnowledgeBase().getPackage(factoryClassNamePackageName[1]);\n-                if (internalKnowledgePackage == null) {\n-                    PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n-                    PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n-                    internalKnowledgePackage = pkgReg.getPackage();\n-                }\n-                PMMLPackage pmmlPkg =\n-                        internalKnowledgePackage.getResourceTypePackages().computeIfAbsent(\n-                                ResourceType.PMML,\n-                                rtp -> new PMMLPackageImpl());\n-                pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n-            }\n+            addModels(kbuilderImpl, toAdd);\n             KieBase kieBase = kbuilderImpl.getKnowledgeBase();\n             toReturn.put(kieBase, KieRuntimeFactory.of(kieBase));\n         });\n         return toReturn;\n     }\n \n+    private static void addModels(final KnowledgeBuilderImpl kbuilderImpl, final List<KiePMMLModel> toAdd) {\n+        for (KiePMMLModel kiePMMLModel : toAdd) {\n+            PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n+            PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n+            InternalKnowledgePackage kpkgs = pkgReg.getPackage();\n+            PMMLPackage pmmlPkg =\n+                    kpkgs.getResourceTypePackages().computeIfAbsent(\n+                            ResourceType.PMML,\n+                            rtp -> new PMMLPackageImpl());\n+            pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n+            if (kiePMMLModel instanceof HasNestedModels) {\n+                addModels(kbuilderImpl, ((HasNestedModels) kiePMMLModel).getNestedModels());\n+            }\n+        }\n+    }\n+\n     private static KnowledgeBuilderImpl createKnowledgeBuilderImpl(final Resource resource) {\n         KnowledgeBaseImpl defaultKnowledgeBase = new KnowledgeBaseImpl(\"PMML\", null);\n         KnowledgeBuilderImpl toReturn = new KnowledgeBuilderImpl(defaultKnowledgeBase);\n-        PredictionRuleMapper pmmlRuleMapper = loadPMMLRuleMapper(toReturn.getRootClassLoader(), resource);\n-        if (pmmlRuleMapper != null) {\n-            String ruleName = pmmlRuleMapper.getRuleName();\n-            Model model = loadModel(toReturn.getRootClassLoader(), ruleName);\n-            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(model));\n+        List<PredictionRuleMapper> pmmlRuleMappers = loadPMMLRuleMappers(toReturn.getRootClassLoader(), resource);\n+        if (!pmmlRuleMappers.isEmpty()) {\n+            List<Model> models =\n+                    pmmlRuleMappers.stream()\n+                            .map(PredictionRuleMapper::getModel)\n+                            .collect(Collectors.toList());\n+            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(models));\n         }\n         return toReturn;\n     }\n \n-    private static PredictionRuleMapper loadPMMLRuleMapper(final ClassLoader classLoader,\n-                                                           final Resource resource) {\n+    private static List<PredictionRuleMapper> loadPMMLRuleMappers(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n+        PredictionRuleMappers predictionRuleMappers = loadPMMLRuleMappersClass(classLoader, resource);\n+        return predictionRuleMappers.getPredictionRuleMappers();\n+    }\n+\n+    private static PredictionRuleMappers loadPMMLRuleMappersClass(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n         String[] classNamePackageName = getFactoryClassNamePackageName(resource);\n         String packageName = classNamePackageName[1];\n-        String fullPMMLRuleMapperClassName = packageName + \".PredictionRuleMapperImpl\";\n+        String fullPMMLRuleMappersClassName = packageName + \".PredictionRuleMappersImpl\";\n         try {\n-            return (PredictionRuleMapper) classLoader.loadClass(fullPMMLRuleMapperClassName).getDeclaredConstructor().newInstance();\n+            return (PredictionRuleMappers) classLoader.loadClass(fullPMMLRuleMappersClassName).getDeclaredConstructor().newInstance();\n         } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | ClassCastException | NoSuchMethodException | InvocationTargetException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzI5NQ=="}, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg3MzI5OnYy", "diffSide": "RIGHT", "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/KieRuntimeFactoryBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo0NzoxMFrOHQFKtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzoyNzoxOFrOHQRgRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzkyNQ==", "bodyText": "Please add e to RuntimeException so that it will be possible to get the original clause", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486623925", "createdAt": "2020-09-10T20:47:10Z", "author": {"login": "danielezonca"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/KieRuntimeFactoryBuilder.java", "diffHunk": "@@ -70,63 +73,65 @@ private KieRuntimeFactoryBuilder() {\n             final BiFunction<KnowledgeBuilderImpl, Resource, List<KiePMMLModel>> modelProducer) {\n         final Map<KieBase, KieRuntimeFactory> toReturn = new HashMap<>();\n         resources.forEach(resource -> {\n-            final String[] factoryClassNamePackageName = getFactoryClassNamePackageName(resource);\n             final KnowledgeBuilderImpl kbuilderImpl = createKnowledgeBuilderImpl(resource);\n             List<KiePMMLModel> toAdd = modelProducer.apply(kbuilderImpl, resource);\n             if (toAdd.isEmpty()) {\n                 throw new KiePMMLException(\"Failed to retrieve compiled models\");\n             }\n-            for (KiePMMLModel kiePMMLModel : toAdd) {\n-                InternalKnowledgePackage internalKnowledgePackage =\n-                        kbuilderImpl.getKnowledgeBase().getPackage(factoryClassNamePackageName[1]);\n-                if (internalKnowledgePackage == null) {\n-                    PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n-                    PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n-                    internalKnowledgePackage = pkgReg.getPackage();\n-                }\n-                PMMLPackage pmmlPkg =\n-                        internalKnowledgePackage.getResourceTypePackages().computeIfAbsent(\n-                                ResourceType.PMML,\n-                                rtp -> new PMMLPackageImpl());\n-                pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n-            }\n+            addModels(kbuilderImpl, toAdd);\n             KieBase kieBase = kbuilderImpl.getKnowledgeBase();\n             toReturn.put(kieBase, KieRuntimeFactory.of(kieBase));\n         });\n         return toReturn;\n     }\n \n+    private static void addModels(final KnowledgeBuilderImpl kbuilderImpl, final List<KiePMMLModel> toAdd) {\n+        for (KiePMMLModel kiePMMLModel : toAdd) {\n+            PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n+            PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n+            InternalKnowledgePackage kpkgs = pkgReg.getPackage();\n+            PMMLPackage pmmlPkg =\n+                    kpkgs.getResourceTypePackages().computeIfAbsent(\n+                            ResourceType.PMML,\n+                            rtp -> new PMMLPackageImpl());\n+            pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n+            if (kiePMMLModel instanceof HasNestedModels) {\n+                addModels(kbuilderImpl, ((HasNestedModels) kiePMMLModel).getNestedModels());\n+            }\n+        }\n+    }\n+\n     private static KnowledgeBuilderImpl createKnowledgeBuilderImpl(final Resource resource) {\n         KnowledgeBaseImpl defaultKnowledgeBase = new KnowledgeBaseImpl(\"PMML\", null);\n         KnowledgeBuilderImpl toReturn = new KnowledgeBuilderImpl(defaultKnowledgeBase);\n-        PredictionRuleMapper pmmlRuleMapper = loadPMMLRuleMapper(toReturn.getRootClassLoader(), resource);\n-        if (pmmlRuleMapper != null) {\n-            String ruleName = pmmlRuleMapper.getRuleName();\n-            Model model = loadModel(toReturn.getRootClassLoader(), ruleName);\n-            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(model));\n+        List<PredictionRuleMapper> pmmlRuleMappers = loadPMMLRuleMappers(toReturn.getRootClassLoader(), resource);\n+        if (!pmmlRuleMappers.isEmpty()) {\n+            List<Model> models =\n+                    pmmlRuleMappers.stream()\n+                            .map(PredictionRuleMapper::getModel)\n+                            .collect(Collectors.toList());\n+            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(models));\n         }\n         return toReturn;\n     }\n \n-    private static PredictionRuleMapper loadPMMLRuleMapper(final ClassLoader classLoader,\n-                                                           final Resource resource) {\n+    private static List<PredictionRuleMapper> loadPMMLRuleMappers(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n+        PredictionRuleMappers predictionRuleMappers = loadPMMLRuleMappersClass(classLoader, resource);\n+        return predictionRuleMappers.getPredictionRuleMappers();\n+    }\n+\n+    private static PredictionRuleMappers loadPMMLRuleMappersClass(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n         String[] classNamePackageName = getFactoryClassNamePackageName(resource);\n         String packageName = classNamePackageName[1];\n-        String fullPMMLRuleMapperClassName = packageName + \".PredictionRuleMapperImpl\";\n+        String fullPMMLRuleMappersClassName = packageName + \".PredictionRuleMappersImpl\";\n         try {\n-            return (PredictionRuleMapper) classLoader.loadClass(fullPMMLRuleMapperClassName).getDeclaredConstructor().newInstance();\n+            return (PredictionRuleMappers) classLoader.loadClass(fullPMMLRuleMappersClassName).getDeclaredConstructor().newInstance();\n         } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | ClassCastException | NoSuchMethodException | InvocationTargetException e) {\n-            logger.info(String.format(\"%s class not found in rootClassLoader\", fullPMMLRuleMapperClassName));\n-            return null;\n+            throw new RuntimeException(String.format(\"%s class not found in rootClassLoader\",\n+                                                     fullPMMLRuleMappersClassName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyNjA1Mg==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486826052", "createdAt": "2020-09-11T07:27:18Z", "author": {"login": "gitgabrio"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/KieRuntimeFactoryBuilder.java", "diffHunk": "@@ -70,63 +73,65 @@ private KieRuntimeFactoryBuilder() {\n             final BiFunction<KnowledgeBuilderImpl, Resource, List<KiePMMLModel>> modelProducer) {\n         final Map<KieBase, KieRuntimeFactory> toReturn = new HashMap<>();\n         resources.forEach(resource -> {\n-            final String[] factoryClassNamePackageName = getFactoryClassNamePackageName(resource);\n             final KnowledgeBuilderImpl kbuilderImpl = createKnowledgeBuilderImpl(resource);\n             List<KiePMMLModel> toAdd = modelProducer.apply(kbuilderImpl, resource);\n             if (toAdd.isEmpty()) {\n                 throw new KiePMMLException(\"Failed to retrieve compiled models\");\n             }\n-            for (KiePMMLModel kiePMMLModel : toAdd) {\n-                InternalKnowledgePackage internalKnowledgePackage =\n-                        kbuilderImpl.getKnowledgeBase().getPackage(factoryClassNamePackageName[1]);\n-                if (internalKnowledgePackage == null) {\n-                    PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n-                    PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n-                    internalKnowledgePackage = pkgReg.getPackage();\n-                }\n-                PMMLPackage pmmlPkg =\n-                        internalKnowledgePackage.getResourceTypePackages().computeIfAbsent(\n-                                ResourceType.PMML,\n-                                rtp -> new PMMLPackageImpl());\n-                pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n-            }\n+            addModels(kbuilderImpl, toAdd);\n             KieBase kieBase = kbuilderImpl.getKnowledgeBase();\n             toReturn.put(kieBase, KieRuntimeFactory.of(kieBase));\n         });\n         return toReturn;\n     }\n \n+    private static void addModels(final KnowledgeBuilderImpl kbuilderImpl, final List<KiePMMLModel> toAdd) {\n+        for (KiePMMLModel kiePMMLModel : toAdd) {\n+            PackageDescr pkgDescr = new PackageDescr(kiePMMLModel.getKModulePackageName());\n+            PackageRegistry pkgReg = kbuilderImpl.getOrCreatePackageRegistry(pkgDescr);\n+            InternalKnowledgePackage kpkgs = pkgReg.getPackage();\n+            PMMLPackage pmmlPkg =\n+                    kpkgs.getResourceTypePackages().computeIfAbsent(\n+                            ResourceType.PMML,\n+                            rtp -> new PMMLPackageImpl());\n+            pmmlPkg.addAll(Collections.singletonList(kiePMMLModel));\n+            if (kiePMMLModel instanceof HasNestedModels) {\n+                addModels(kbuilderImpl, ((HasNestedModels) kiePMMLModel).getNestedModels());\n+            }\n+        }\n+    }\n+\n     private static KnowledgeBuilderImpl createKnowledgeBuilderImpl(final Resource resource) {\n         KnowledgeBaseImpl defaultKnowledgeBase = new KnowledgeBaseImpl(\"PMML\", null);\n         KnowledgeBuilderImpl toReturn = new KnowledgeBuilderImpl(defaultKnowledgeBase);\n-        PredictionRuleMapper pmmlRuleMapper = loadPMMLRuleMapper(toReturn.getRootClassLoader(), resource);\n-        if (pmmlRuleMapper != null) {\n-            String ruleName = pmmlRuleMapper.getRuleName();\n-            Model model = loadModel(toReturn.getRootClassLoader(), ruleName);\n-            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(model));\n+        List<PredictionRuleMapper> pmmlRuleMappers = loadPMMLRuleMappers(toReturn.getRootClassLoader(), resource);\n+        if (!pmmlRuleMappers.isEmpty()) {\n+            List<Model> models =\n+                    pmmlRuleMappers.stream()\n+                            .map(PredictionRuleMapper::getModel)\n+                            .collect(Collectors.toList());\n+            toReturn = new KnowledgeBuilderImpl(KieBaseBuilder.createKieBaseFromModel(models));\n         }\n         return toReturn;\n     }\n \n-    private static PredictionRuleMapper loadPMMLRuleMapper(final ClassLoader classLoader,\n-                                                           final Resource resource) {\n+    private static List<PredictionRuleMapper> loadPMMLRuleMappers(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n+        PredictionRuleMappers predictionRuleMappers = loadPMMLRuleMappersClass(classLoader, resource);\n+        return predictionRuleMappers.getPredictionRuleMappers();\n+    }\n+\n+    private static PredictionRuleMappers loadPMMLRuleMappersClass(final ClassLoader classLoader,\n+                                                                  final Resource resource) {\n         String[] classNamePackageName = getFactoryClassNamePackageName(resource);\n         String packageName = classNamePackageName[1];\n-        String fullPMMLRuleMapperClassName = packageName + \".PredictionRuleMapperImpl\";\n+        String fullPMMLRuleMappersClassName = packageName + \".PredictionRuleMappersImpl\";\n         try {\n-            return (PredictionRuleMapper) classLoader.loadClass(fullPMMLRuleMapperClassName).getDeclaredConstructor().newInstance();\n+            return (PredictionRuleMappers) classLoader.loadClass(fullPMMLRuleMappersClassName).getDeclaredConstructor().newInstance();\n         } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | ClassCastException | NoSuchMethodException | InvocationTargetException e) {\n-            logger.info(String.format(\"%s class not found in rootClassLoader\", fullPMMLRuleMapperClassName));\n-            return null;\n+            throw new RuntimeException(String.format(\"%s class not found in rootClassLoader\",\n+                                                     fullPMMLRuleMappersClassName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzkyNQ=="}, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg3NzY2OnYy", "diffSide": "RIGHT", "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/PMMLKogito.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo0ODozNlrOHQFNRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzo0NzoyNlrOHQSG3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNDU4Mw==", "bodyText": "Can you please review this change? The new predictionRuleMappers seems unused", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486624583", "createdAt": "2020-09-10T20:48:36Z", "author": {"login": "danielezonca"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/PMMLKogito.java", "diffHunk": "@@ -52,7 +53,7 @@ private PMMLKogito() {\n      * Use {@link Application#predictionModels()} of Kogito API to programmatically access PMML assets and evaluate\n      * PMML decisions.\n      */\n-    public static Map<KieBase, KieRuntimeFactory> createKieRuntimeFactories(String... pmmlPaths) {\n+    public static Map<KieBase, KieRuntimeFactory> createKieRuntimeFactories(List<PredictionRuleMappers> predictionRuleMappers, String... pmmlPaths) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzNTkzMw==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486835933", "createdAt": "2020-09-11T07:47:26Z", "author": {"login": "gitgabrio"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/pmml/PMMLKogito.java", "diffHunk": "@@ -52,7 +53,7 @@ private PMMLKogito() {\n      * Use {@link Application#predictionModels()} of Kogito API to programmatically access PMML assets and evaluate\n      * PMML decisions.\n      */\n-    public static Map<KieBase, KieRuntimeFactory> createKieRuntimeFactories(String... pmmlPaths) {\n+    public static Map<KieBase, KieRuntimeFactory> createKieRuntimeFactories(List<PredictionRuleMappers> predictionRuleMappers, String... pmmlPaths) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNDU4Mw=="}, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg3ODc3OnYy", "diffSide": "RIGHT", "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/prediction/PredictionRuleMappers.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo0OTowMFrOHQFOBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwNzo0NzozMFrOHQSG-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNDc3Mw==", "bodyText": "Javadoc?", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486624773", "createdAt": "2020-09-10T20:49:00Z", "author": {"login": "danielezonca"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/prediction/PredictionRuleMappers.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.prediction;\n+\n+import java.util.List;\n+\n+public interface PredictionRuleMappers {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzNTk2Mw==", "bodyText": "@danielezonca\ndone", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486835963", "createdAt": "2020-09-11T07:47:30Z", "author": {"login": "gitgabrio"}, "path": "drools/kogito-pmml/src/main/java/org/kie/kogito/prediction/PredictionRuleMappers.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.prediction;\n+\n+import java.util.List;\n+\n+public interface PredictionRuleMappers {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNDc3Mw=="}, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg4MTc1OnYy", "diffSide": "RIGHT", "path": "kogito-build-parent/pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo0OTo1N1rOHQFP4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo0OTo1N1rOHQFP4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNTI1MQ==", "bodyText": "To be replaced with fixed version before merging", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486625251", "createdAt": "2020-09-10T20:49:57Z", "author": {"login": "danielezonca"}, "path": "kogito-build-parent/pom.xml", "diffHunk": "@@ -129,7 +129,7 @@\n     <version.org.keycloak>11.0.0</version.org.keycloak>\n     <version.org.mockito>3.3.3</version.org.mockito>\n     <version.org.mvel>2.4.7.Final</version.org.mvel>\n-    <version.org.kie7>7.43.0.Final</version.org.kie7>\n+    <version.org.kie7>7.44.0-SNAPSHOT</version.org.kie7>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg5MzU0OnYy", "diffSide": "RIGHT", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionRuleMappersGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo1MzozMFrOHQFXEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo1MzozMFrOHQFXEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNzA4OQ==", "bodyText": "2020", "url": "https://github.com/kiegroup/kogito-runtimes/pull/749#discussion_r486627089", "createdAt": "2020-09-10T20:53:30Z", "author": {"login": "danielezonca"}, "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/prediction/PredictionRuleMappersGenerator.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89cb14decb20502abd76fa08fb1a680f551d3b48"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4755, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}