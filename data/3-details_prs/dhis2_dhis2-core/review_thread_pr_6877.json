{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1ODYxODY5", "number": 6877, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDowNzo0M1rOFFm0jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDowNzo0M1rOFFm0jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDIzMjQ0OnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/preheat/supplier/classStrategy/AbstractSchemaStrategy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDowNzo0M1rOIGMqlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDowNzo0M1rOIGMqlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM2OTg3OQ==", "bodyText": "Do we have a jira issue for this todo?", "url": "https://github.com/dhis2/dhis2-core/pull/6877#discussion_r543369879", "createdAt": "2020-12-15T14:07:43Z", "author": {"login": "stian-sandvold"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/preheat/supplier/classStrategy/AbstractSchemaStrategy.java", "diffHunk": "@@ -109,24 +111,99 @@ protected void queryForIdentifiableObjects( TrackerPreheat preheat, Schema schem\n             }\n             else\n             {\n-                Query query = Query.from( schema );\n-                query.setUser( preheat.getUser() );\n-                query.add( generateRestrictionFromIdentifiers( idScheme, ids ) );\n-                query.setDefaults( Defaults.INCLUDE );\n-                if ( mapper.isAssignableFrom( CopyMapper.class ) )\n+                objects = cacheAwareFetch( preheat.getUser(), schema, identifier, ids, mapper );\n+            }\n+\n+            preheat.put( identifier, objects );\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private List<IdentifiableObject> cacheAwareFetch( User user, Schema schema, TrackerIdentifier identifier, List<String> ids, Class<? extends PreheatMapper> mapper )\n+    {\n+        TrackerIdScheme idScheme = identifier.getIdScheme();\n+        \n+        List<IdentifiableObject> objects;\n+        final String cacheKey = schema.getKlass().getSimpleName();\n+        \n+        if ( canCache() ) // check if this strategy requires caching\n+        {\n+            List<String> toRemove = new ArrayList<>();\n+            List<IdentifiableObject> cachedObjects = new ArrayList<>();\n+\n+            for ( String id : ids )\n+            {\n+                // is the object reference by the given id in cache?\n+                Optional<IdentifiableObject> o = cache.get( cacheKey, id );\n+                if ( o.isPresent()  )\n                 {\n-                    objects = queryService.query( query );\n+                    // add to objects to set into preheat\n+                    cachedObjects.add( o.get() );\n+                    // remove this id from list of id to fetch from db\n+                    toRemove.add( id );\n                 }\n-                else\n+            }\n+            // is there any object which was not found in cache?\n+            if ( ids.size() > toRemove.size() )\n+            {\n+                // remove from the list of ids the ids found in cache\n+                ids.removeAll( toRemove );\n+                \n+                // execute the query\n+                objects = map((List<IdentifiableObject>) queryService.query( buildQuery( schema, user, idScheme, ids ) ), mapper );\n+\n+                // put objects in query based on given scheme\n+                if ( idScheme.equals( TrackerIdScheme.UID ) )\n                 {\n-                    objects = queryService.query( query ).stream().map( o -> Mappers.getMapper( mapper ).map( o ) )\n-                        .map( IdentifiableObject.class::cast ).collect( Collectors.toList() );\n+                    objects.forEach( o -> cache.put( cacheKey, o.getUid(), o, getCacheTTL(), getCapacity() ) );\n                 }\n-\n+                else if ( idScheme.equals( TrackerIdScheme.CODE ) )\n+                {\n+                    objects.forEach( o -> cache.put( cacheKey, o.getCode(), o, getCacheTTL(), getCapacity() ) );\n+                }\n+                else if ( idScheme.equals( TrackerIdScheme.ATTRIBUTE ) )\n+                {\n+                    // TODO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d39d8386acf5141b3964a33a30269fc17e9feb00"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3669, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}