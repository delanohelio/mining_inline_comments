{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxMjA2MzUw", "number": 6674, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNzo0NzowNFrOE5MSmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDo0NDozMFrOE59QRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NDA1NjU2OnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/test/java/org/hisp/dhis/tracker/converter/RelationshipTrackerConverterServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNzo0NzowNFrOHzhnQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNzo0NzowNFrOHzhnQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc5MDE0NQ==", "bodyText": "Maybe change import collapse param? don't need to collapse into * here", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r523790145", "createdAt": "2020-11-15T17:47:04Z", "author": {"login": "mortenoh"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/test/java/org/hisp/dhis/tracker/converter/RelationshipTrackerConverterServiceTest.java", "diffHunk": "@@ -55,7 +55,7 @@\n import java.util.List;\n \n import static junit.framework.TestCase.assertNotNull;\n-import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93ecdcce1df3b6987da6a0fde26dc6a2af4b02ef"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NjI2NjU1OnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDo1NjoyM1rOHz1tNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOToxODozOVrOH0raOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExOTM1MQ==", "bodyText": "updateEnrollmentReferences and enrollment.setNotes seem to happen only in the enrollments that are in the payload as a separate entity.\nIf the enrollments are inside a TEI these 2 functions are not called.\nIs this correct?", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524119351", "createdAt": "2020-11-16T10:56:23Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5OTIyNw==", "bodyText": "You are absolutely right. I moved the note-updates to the for-loops that interate over the entire collections.", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524999227", "createdAt": "2020-11-17T09:18:39Z", "author": {"login": "stian-sandvold"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExOTM1MQ=="}, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NjI2ODUxOnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDo1Njo0MFrOHz1ugg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOToxODo1NlrOH0ra4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExOTY4Mg==", "bodyText": "Some as enrollments comment", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524119682", "createdAt": "2020-11-16T10:56:40Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5OTM5Mw==", "bodyText": "same solution as previous", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524999393", "createdAt": "2020-11-17T09:18:56Z", "author": {"login": "stian-sandvold"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExOTY4Mg=="}, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NjI3MjcyOnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDo1NzoxOFrOHz1xKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOToyMjowMVrOH0rjVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyMDM2MA==", "bodyText": "We already have a loop around enrollmentHashMap.values(), can we put this logic there?", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524120360", "createdAt": "2020-11-16T10:57:18Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMTU1OA==", "bodyText": "This should/will be moved to a preprocessor soon, but I will move them into the loop for now :)", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525001558", "createdAt": "2020-11-17T09:22:01Z", "author": {"login": "stian-sandvold"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyMDM2MA=="}, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NjI3MzU3OnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDo1NzoyOFrOHz1xyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOToyMjowMlrOH0rjYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyMDUyMg==", "bodyText": "Same as enrollments", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524120522", "createdAt": "2020-11-16T10:57:28Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()\n+            .forEach( enrollment -> enrollment\n+                .setNotes(\n+                    enrollment.getNotes().stream()\n+                        .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                        .collect( Collectors.toList() )\n+                ) );\n+\n+        eventHashMap.values()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMTU3MQ==", "bodyText": "This should/will be moved to a preprocessor soon, but I will move them into the loop for now :)", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525001571", "createdAt": "2020-11-17T09:22:02Z", "author": {"login": "stian-sandvold"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()\n+            .forEach( enrollment -> enrollment\n+                .setNotes(\n+                    enrollment.getNotes().stream()\n+                        .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                        .collect( Collectors.toList() )\n+                ) );\n+\n+        eventHashMap.values()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyMDUyMg=="}, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NjI5ODI5OnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMTowMToxMVrOHz2Bvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwOToyNDo0MlrOH0rqOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyNDYwNg==", "bodyText": "If 2 identical relationships without UID are in the payload, after updating the reference I think that the distinct will not recognise them as equals.", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524124606", "createdAt": "2020-11-16T11:01:11Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()\n+            .forEach( enrollment -> enrollment\n+                .setNotes(\n+                    enrollment.getNotes().stream()\n+                        .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                        .collect( Collectors.toList() )\n+                ) );\n+\n+        eventHashMap.values()\n+            .forEach(\n+                event -> event.setNotes( event.getNotes().stream()\n+                    .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                    .collect( Collectors.toList() )\n+                ) );\n+\n+        return TrackerBundleParams.builder()\n+            .trackedEntities( new ArrayList<>( trackedEntityMap.values() ) )\n+            .enrollments( new ArrayList<>( enrollmentHashMap.values() ) )\n+            .events( new ArrayList<>( eventHashMap.values() ) )\n+            .relationships( relationshipHashMap.values().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAwMzMyMg==", "bodyText": "You are right :) This is solved by Luciano's changes anyway, so I will just remove it!", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525003322", "createdAt": "2020-11-17T09:24:42Z", "author": {"login": "stian-sandvold"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()\n+            .forEach( enrollment -> enrollment\n+                .setNotes(\n+                    enrollment.getNotes().stream()\n+                        .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                        .collect( Collectors.toList() )\n+                ) );\n+\n+        eventHashMap.values()\n+            .forEach(\n+                event -> event.setNotes( event.getNotes().stream()\n+                    .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                    .collect( Collectors.toList() )\n+                ) );\n+\n+        return TrackerBundleParams.builder()\n+            .trackedEntities( new ArrayList<>( trackedEntityMap.values() ) )\n+            .enrollments( new ArrayList<>( enrollmentHashMap.values() ) )\n+            .events( new ArrayList<>( eventHashMap.values() ) )\n+            .relationships( relationshipHashMap.values().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyNDYwNg=="}, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjA3NjgzOnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDo0NDowNFrOH0u48Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDo0ODo1NFrOH0vE3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjI0MQ==", "bodyText": "If event.getEvent() is null, what is going to happen?", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525056241", "createdAt": "2020-11-17T10:44:04Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1OTI5NQ==", "bodyText": "The extractEvents method will update references, which will also generate UID if getEvent is null. So at this point, it can never be null :)", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525059295", "createdAt": "2020-11-17T10:48:54Z", "author": {"login": "stian-sandvold"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjI0MQ=="}, "originalCommit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjA3NzQyOnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDo0NDoxMVrOH0u5TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDo1MDozOFrOH0vJXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjMzMw==", "bodyText": "We are updating references only for the events that are coming as a separate entity in the payload.\nIf we have an event inside an enrollment and this event has no uid, at some point the validation will fail.\nIs this expected?", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525056333", "createdAt": "2020-11-17T10:44:11Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        Set<Relationship> relationships = new HashSet<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n-        {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            enrollment.setNotes( enrollment.getNotes().stream()\n+                .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() )\n+            );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA2MDQ0NA==", "bodyText": "The references are updated within \"extractEvents\", so this should not be a problem :)", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525060444", "createdAt": "2020-11-17T10:50:38Z", "author": {"login": "stian-sandvold"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        Set<Relationship> relationships = new HashSet<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n-        {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            enrollment.setNotes( enrollment.getNotes().stream()\n+                .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() )\n+            );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjMzMw=="}, "originalCommit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjA3ODc5OnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDo0NDozMFrOH0u6Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDo1MDo1MVrOH0vJ3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjUyNg==", "bodyText": "Same as events", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525056526", "createdAt": "2020-11-17T10:44:30Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA2MDU3NA==", "bodyText": "Same as events :)", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525060574", "createdAt": "2020-11-17T10:50:51Z", "author": {"login": "stian-sandvold"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjUyNg=="}, "originalCommit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3725, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}