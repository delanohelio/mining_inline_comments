{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5MTQ3NDQw", "number": 6344, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMDoxNzoxNlrOEs9-3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMDoxNzoyOFrOEs9_OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NTg4MzE5OnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-support/dhis-support-db-migration/src/main/java/org/hisp/dhis/db/migration/v36/V2_36_4__Remove_duplicate_mappings_from_categoryoption_to_usergroups.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMDoxNzoxNlrOHgfpBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMDoxNzoxNlrOHgfpBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzNDg4NA==", "bodyText": "looks fine to me.\nthis message is displaying count so it can be changed to for example\nNumber of userGroupAccessIds deleted from dataelementcategoryoptionusergroupaccesses table :", "url": "https://github.com/dhis2/dhis2-core/pull/6344#discussion_r503834884", "createdAt": "2020-10-13T10:17:16Z", "author": {"login": "zubaira"}, "path": "dhis-2/dhis-support/dhis-support-db-migration/src/main/java/org/hisp/dhis/db/migration/v36/V2_36_4__Remove_duplicate_mappings_from_categoryoption_to_usergroups.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package org.hisp.dhis.db.migration.v36;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import java.sql.ResultSet;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * @author Ameen Mohamed <ameen@dhis2.org>\n+ */\n+@Slf4j\n+public class V2_36_4__Remove_duplicate_mappings_from_categoryoption_to_usergroups\n+    extends BaseJavaMigration\n+{\n+\n+    private static final String USERGROUPID = \"usergroupid\";\n+\n+    private static final String CATEGORYOPTIONID = \"categoryoptionid\";\n+\n+    private static final String CHECK_DUPLICATE_CATOPT_USERGROUP_MAPPING = \"SELECT count(*),categoryoptionid,name,usergroupid  \" + \n+        \"FROM   (SELECT deco.*,uga.* \" + \n+        \"       FROM   dataelementcategoryoption deco \" + \n+        \"       LEFT JOIN dataelementcategoryoptionusergroupaccesses couga \" + \n+        \"               ON deco.categoryoptionid = couga.categoryoptionid \" + \n+        \"       LEFT JOIN usergroupaccess uga \" + \n+        \"               ON couga.usergroupaccessid = uga.usergroupaccessid) AS decouga \" + \n+        \"GROUP  BY categoryoptionid,name,usergroupid HAVING count(*) > 1\";\n+    \n+    private static final String GET_ACCESS_STRING_FOR_CO_UG_COMBO = \"SELECT usergroupaccessid,usergroupid,categoryoptionid, \" + \n+        \"CASE \" + \n+        \"WHEN access = '--------' THEN 1 \" + \n+        \"WHEN access = 'r-------' THEN 2 \" + \n+        \"WHEN access LIKE '_w------' THEN 3 \" + \n+        \"WHEN access LIKE '__r-----' THEN 4 \" + \n+        \"WHEN access LIKE '___w----' THEN 5 \" + \n+        \"ELSE 0 \" + \n+        \"END as accesslevel \" + \n+        \"FROM   (SELECT couga.categoryoptionid,uga.*  \" + \n+        \"       FROM  dataelementcategoryoptionusergroupaccesses couga \" + \n+        \"       LEFT JOIN usergroupaccess uga \" + \n+        \"               ON couga.usergroupaccessid = uga.usergroupaccessid \" +\n+        \" WHERE  categoryoptionid IN (%s)  and usergroupid IN (%s)) AS decouga order by accesslevel desc\";\n+    \n+    private static final String DELETE_CATOPT_USRGRP_ACCESS = \"delete from dataelementcategoryoptionusergroupaccesses where usergroupaccessid in (%s)\";\n+\n+    private static final String DELETE_USRGRP_ACCESS = \"delete from usergroupaccess where usergroupaccessid in (%s)\";\n+\n+    @Override\n+    public void migrate( Context context )\n+        throws Exception\n+    {\n+        List<DuplicateCategoryOptionUserGroupWithCount> duplicateCatOptUsrgrps = new ArrayList<>();\n+        Set<String> catOptIds = new HashSet<>();\n+        Set<String> userGroupIds = new HashSet<>();\n+        long totalCount = 0;\n+\n+        //1. Check if there are duplicate mappings. If not simply return.\n+        try ( Statement stmt = context.getConnection().createStatement();\n+            ResultSet rs = stmt.executeQuery( CHECK_DUPLICATE_CATOPT_USERGROUP_MAPPING ); )\n+        {\n+            if ( rs.next() == false )\n+            {\n+                log.info( \"No duplicate mappings for categoryoption to usergroups. Skipping duplicate cleanup migration\" );\n+                return;\n+            }\n+            else\n+            {\n+                DuplicateCategoryOptionUserGroupWithCount duplicateCatOptUsrgrp = null;\n+                do\n+                {       \n+                    duplicateCatOptUsrgrp = new DuplicateCategoryOptionUserGroupWithCount();\n+                    duplicateCatOptUsrgrp.setName( rs.getString( \"name\" ) );\n+                    duplicateCatOptUsrgrp.setCategoryOptionId( rs.getLong( CATEGORYOPTIONID ) );\n+                    catOptIds.add( rs.getString( CATEGORYOPTIONID )  );\n+                    duplicateCatOptUsrgrp.setUserGroupId( rs.getLong( USERGROUPID ) );\n+                    userGroupIds.add( rs.getString( USERGROUPID ) );\n+                    duplicateCatOptUsrgrp.setCount( rs.getInt( \"count\" ) );\n+                    totalCount = totalCount + rs.getInt( \"count\" );\n+                    duplicateCatOptUsrgrps.add( duplicateCatOptUsrgrp );\n+                }\n+                while ( rs.next() );\n+            }\n+        }\n+        \n+        Set<Pair<String,String>> catOptUsrGroupPairs = new HashSet<>();\n+        Set<String> deleteUserGroupAccessIds = new HashSet<>();\n+        \n+        String catOptIdsCommaSeparated = StringUtils.join( catOptIds, \",\" );\n+        String userGroupIdsCommaSeparated = StringUtils.join( userGroupIds, \",\" );\n+      \n+        // 2. Get ordered access strings for each categoryoptionid and  usergroupid combination \n+        try ( Statement stmt = context.getConnection().createStatement();\n+            ResultSet rs = stmt.executeQuery( String.format( GET_ACCESS_STRING_FOR_CO_UG_COMBO, catOptIdsCommaSeparated, userGroupIdsCommaSeparated ) ); )\n+        {\n+            Pair<String,String> currentPair = null;\n+            while ( rs.next() )\n+            {\n+                currentPair = Pair.of( rs.getString( CATEGORYOPTIONID ), rs.getString( USERGROUPID ) );\n+                if ( catOptUsrGroupPairs.contains( currentPair ) )\n+                {\n+                    deleteUserGroupAccessIds.add( rs.getString( \"usergroupaccessid\" ) );\n+                }\n+                else\n+                {\n+                    catOptUsrGroupPairs.add( currentPair );\n+                }\n+            }\n+\n+        }\n+        log.info( \"Total identified duplicate userGroupAccessIds to delete : \" + deleteUserGroupAccessIds.size() );\n+        log.info( \"Total catOpts duplicated in mappings: \" + duplicateCatOptUsrgrps.size() );\n+        log.info( \"Total impacted rows in usergroupaccess mapping tables: \" + totalCount );\n+      \n+        String usrGrpAccessIdsCommaSeparated = StringUtils.join( deleteUserGroupAccessIds, \",\" );\n+        \n+        try ( Statement stmt = context.getConnection().createStatement(); )\n+        {\n+            //Delete redundant usergroupaccessid from dataelementcategoryoptionusergroupaccesses table\n+            int deletedCougaCount = stmt.executeUpdate( String.format( DELETE_CATOPT_USRGRP_ACCESS, usrGrpAccessIdsCommaSeparated ) );\n+            log.info( \"Deleted userGroupAccessIds from dataelementcategoryoptionusergroupaccesses table : \" + deletedCougaCount );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30023d73fc474ec7c1ca6752376d098bffc541d"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NTg4NDA4OnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-support/dhis-support-db-migration/src/main/java/org/hisp/dhis/db/migration/v36/V2_36_4__Remove_duplicate_mappings_from_categoryoption_to_usergroups.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMDoxNzoyOFrOHgfphg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxMDoxNzoyOFrOHgfphg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzNTAxNA==", "bodyText": "same as above", "url": "https://github.com/dhis2/dhis2-core/pull/6344#discussion_r503835014", "createdAt": "2020-10-13T10:17:28Z", "author": {"login": "zubaira"}, "path": "dhis-2/dhis-support/dhis-support-db-migration/src/main/java/org/hisp/dhis/db/migration/v36/V2_36_4__Remove_duplicate_mappings_from_categoryoption_to_usergroups.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package org.hisp.dhis.db.migration.v36;\n+\n+/*\n+ * Copyright (c) 2004-2020, University of Oslo\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following disclaimer in the documentation\n+ * and/or other materials provided with the distribution.\n+ * Neither the name of the HISP project nor the names of its contributors may\n+ * be used to endorse or promote products derived from this software without\n+ * specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+import java.sql.ResultSet;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * @author Ameen Mohamed <ameen@dhis2.org>\n+ */\n+@Slf4j\n+public class V2_36_4__Remove_duplicate_mappings_from_categoryoption_to_usergroups\n+    extends BaseJavaMigration\n+{\n+\n+    private static final String USERGROUPID = \"usergroupid\";\n+\n+    private static final String CATEGORYOPTIONID = \"categoryoptionid\";\n+\n+    private static final String CHECK_DUPLICATE_CATOPT_USERGROUP_MAPPING = \"SELECT count(*),categoryoptionid,name,usergroupid  \" + \n+        \"FROM   (SELECT deco.*,uga.* \" + \n+        \"       FROM   dataelementcategoryoption deco \" + \n+        \"       LEFT JOIN dataelementcategoryoptionusergroupaccesses couga \" + \n+        \"               ON deco.categoryoptionid = couga.categoryoptionid \" + \n+        \"       LEFT JOIN usergroupaccess uga \" + \n+        \"               ON couga.usergroupaccessid = uga.usergroupaccessid) AS decouga \" + \n+        \"GROUP  BY categoryoptionid,name,usergroupid HAVING count(*) > 1\";\n+    \n+    private static final String GET_ACCESS_STRING_FOR_CO_UG_COMBO = \"SELECT usergroupaccessid,usergroupid,categoryoptionid, \" + \n+        \"CASE \" + \n+        \"WHEN access = '--------' THEN 1 \" + \n+        \"WHEN access = 'r-------' THEN 2 \" + \n+        \"WHEN access LIKE '_w------' THEN 3 \" + \n+        \"WHEN access LIKE '__r-----' THEN 4 \" + \n+        \"WHEN access LIKE '___w----' THEN 5 \" + \n+        \"ELSE 0 \" + \n+        \"END as accesslevel \" + \n+        \"FROM   (SELECT couga.categoryoptionid,uga.*  \" + \n+        \"       FROM  dataelementcategoryoptionusergroupaccesses couga \" + \n+        \"       LEFT JOIN usergroupaccess uga \" + \n+        \"               ON couga.usergroupaccessid = uga.usergroupaccessid \" +\n+        \" WHERE  categoryoptionid IN (%s)  and usergroupid IN (%s)) AS decouga order by accesslevel desc\";\n+    \n+    private static final String DELETE_CATOPT_USRGRP_ACCESS = \"delete from dataelementcategoryoptionusergroupaccesses where usergroupaccessid in (%s)\";\n+\n+    private static final String DELETE_USRGRP_ACCESS = \"delete from usergroupaccess where usergroupaccessid in (%s)\";\n+\n+    @Override\n+    public void migrate( Context context )\n+        throws Exception\n+    {\n+        List<DuplicateCategoryOptionUserGroupWithCount> duplicateCatOptUsrgrps = new ArrayList<>();\n+        Set<String> catOptIds = new HashSet<>();\n+        Set<String> userGroupIds = new HashSet<>();\n+        long totalCount = 0;\n+\n+        //1. Check if there are duplicate mappings. If not simply return.\n+        try ( Statement stmt = context.getConnection().createStatement();\n+            ResultSet rs = stmt.executeQuery( CHECK_DUPLICATE_CATOPT_USERGROUP_MAPPING ); )\n+        {\n+            if ( rs.next() == false )\n+            {\n+                log.info( \"No duplicate mappings for categoryoption to usergroups. Skipping duplicate cleanup migration\" );\n+                return;\n+            }\n+            else\n+            {\n+                DuplicateCategoryOptionUserGroupWithCount duplicateCatOptUsrgrp = null;\n+                do\n+                {       \n+                    duplicateCatOptUsrgrp = new DuplicateCategoryOptionUserGroupWithCount();\n+                    duplicateCatOptUsrgrp.setName( rs.getString( \"name\" ) );\n+                    duplicateCatOptUsrgrp.setCategoryOptionId( rs.getLong( CATEGORYOPTIONID ) );\n+                    catOptIds.add( rs.getString( CATEGORYOPTIONID )  );\n+                    duplicateCatOptUsrgrp.setUserGroupId( rs.getLong( USERGROUPID ) );\n+                    userGroupIds.add( rs.getString( USERGROUPID ) );\n+                    duplicateCatOptUsrgrp.setCount( rs.getInt( \"count\" ) );\n+                    totalCount = totalCount + rs.getInt( \"count\" );\n+                    duplicateCatOptUsrgrps.add( duplicateCatOptUsrgrp );\n+                }\n+                while ( rs.next() );\n+            }\n+        }\n+        \n+        Set<Pair<String,String>> catOptUsrGroupPairs = new HashSet<>();\n+        Set<String> deleteUserGroupAccessIds = new HashSet<>();\n+        \n+        String catOptIdsCommaSeparated = StringUtils.join( catOptIds, \",\" );\n+        String userGroupIdsCommaSeparated = StringUtils.join( userGroupIds, \",\" );\n+      \n+        // 2. Get ordered access strings for each categoryoptionid and  usergroupid combination \n+        try ( Statement stmt = context.getConnection().createStatement();\n+            ResultSet rs = stmt.executeQuery( String.format( GET_ACCESS_STRING_FOR_CO_UG_COMBO, catOptIdsCommaSeparated, userGroupIdsCommaSeparated ) ); )\n+        {\n+            Pair<String,String> currentPair = null;\n+            while ( rs.next() )\n+            {\n+                currentPair = Pair.of( rs.getString( CATEGORYOPTIONID ), rs.getString( USERGROUPID ) );\n+                if ( catOptUsrGroupPairs.contains( currentPair ) )\n+                {\n+                    deleteUserGroupAccessIds.add( rs.getString( \"usergroupaccessid\" ) );\n+                }\n+                else\n+                {\n+                    catOptUsrGroupPairs.add( currentPair );\n+                }\n+            }\n+\n+        }\n+        log.info( \"Total identified duplicate userGroupAccessIds to delete : \" + deleteUserGroupAccessIds.size() );\n+        log.info( \"Total catOpts duplicated in mappings: \" + duplicateCatOptUsrgrps.size() );\n+        log.info( \"Total impacted rows in usergroupaccess mapping tables: \" + totalCount );\n+      \n+        String usrGrpAccessIdsCommaSeparated = StringUtils.join( deleteUserGroupAccessIds, \",\" );\n+        \n+        try ( Statement stmt = context.getConnection().createStatement(); )\n+        {\n+            //Delete redundant usergroupaccessid from dataelementcategoryoptionusergroupaccesses table\n+            int deletedCougaCount = stmt.executeUpdate( String.format( DELETE_CATOPT_USRGRP_ACCESS, usrGrpAccessIdsCommaSeparated ) );\n+            log.info( \"Deleted userGroupAccessIds from dataelementcategoryoptionusergroupaccesses table : \" + deletedCougaCount );\n+           \n+            //Delete redundant usergroupaccessid from usergroupaccess table\n+            int deletedUgaCount = stmt.executeUpdate( String.format( DELETE_USRGRP_ACCESS, usrGrpAccessIdsCommaSeparated ) );\n+            log.info( \"Deleted userGroupAccessIds from usergroupaccess table : \" + deletedUgaCount );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30023d73fc474ec7c1ca6752376d098bffc541d"}, "originalPosition": 163}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3795, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}