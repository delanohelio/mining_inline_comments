{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxMjA2MzUw", "number": 6674, "title": "fix: Updated the Converter class; Fixed failing tests", "bodyText": "Updates the Converter to check all potential nested objects. During this process, we also assign UIDs where ever they are missing, and make sure references between nested objects remain after being flattened.\nWe also make sure we filter away notes with empty values. This should however be moved to a preprocessor class.\nAlso fixed failing tests:\nAdded event.event value (uid) for failing program rules test. Converter was not used here, so simlest solution was to add a uid since we are not testing the converter here.\nMade sure relationshipConverter test doesnt require specific order for relationships to be returned.", "createdAt": "2020-11-15T14:47:18Z", "url": "https://github.com/dhis2/dhis2-core/pull/6674", "merged": true, "mergeCommit": {"oid": "1c8e6224675f6388b50c890ec5d07764f4f97285"}, "closed": true, "closedAt": "2020-11-17T10:56:43Z", "author": {"login": "stian-sandvold"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdcxcGEgH2gAyNTIxMjA2MzUwOjkzZWNkY2NlMWRmM2I2OTg3ZGE2YTBmZGUyNmRjNmEyYWY0YjAyZWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABddXO9sAFqTUzMjIzNTE3NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "93ecdcce1df3b6987da6a0fde26dc6a2af4b02ef", "author": {"user": {"login": "stian-sandvold", "name": "Stian Sandvold"}}, "url": "https://github.com/dhis2/dhis2-core/commit/93ecdcce1df3b6987da6a0fde26dc6a2af4b02ef", "committedDate": "2020-11-15T14:43:09Z", "message": "Updated the Converter class; Fixed failing tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwODE5ODkx", "url": "https://github.com/dhis2/dhis2-core/pull/6674#pullrequestreview-530819891", "createdAt": "2020-11-15T17:47:04Z", "commit": {"oid": "93ecdcce1df3b6987da6a0fde26dc6a2af4b02ef"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNzo0NzowNFrOHzhnQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNzo0NzowNFrOHzhnQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc5MDE0NQ==", "bodyText": "Maybe change import collapse param? don't need to collapse into * here", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r523790145", "createdAt": "2020-11-15T17:47:04Z", "author": {"login": "mortenoh"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/test/java/org/hisp/dhis/tracker/converter/RelationshipTrackerConverterServiceTest.java", "diffHunk": "@@ -55,7 +55,7 @@\n import java.util.List;\n \n import static junit.framework.TestCase.assertNotNull;\n-import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93ecdcce1df3b6987da6a0fde26dc6a2af4b02ef"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed", "author": {"user": {"login": "stian-sandvold", "name": "Stian Sandvold"}}, "url": "https://github.com/dhis2/dhis2-core/commit/c3f11e59a52bb38b78c029df4d75d05fa8db08ed", "committedDate": "2020-11-16T07:58:29Z", "message": "expand import for Assert.*"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMjEzODA2", "url": "https://github.com/dhis2/dhis2-core/pull/6674#pullrequestreview-531213806", "createdAt": "2020-11-16T10:56:22Z", "commit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDo1NjoyM1rOHz1tNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMTowMToxMVrOHz2Bvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExOTM1MQ==", "bodyText": "updateEnrollmentReferences and enrollment.setNotes seem to happen only in the enrollments that are in the payload as a separate entity.\nIf the enrollments are inside a TEI these 2 functions are not called.\nIs this correct?", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524119351", "createdAt": "2020-11-16T10:56:23Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExOTY4Mg==", "bodyText": "Some as enrollments comment", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524119682", "createdAt": "2020-11-16T10:56:40Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyMDM2MA==", "bodyText": "We already have a loop around enrollmentHashMap.values(), can we put this logic there?", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524120360", "createdAt": "2020-11-16T10:57:18Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyMDUyMg==", "bodyText": "Same as enrollments", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524120522", "createdAt": "2020-11-16T10:57:28Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()\n+            .forEach( enrollment -> enrollment\n+                .setNotes(\n+                    enrollment.getNotes().stream()\n+                        .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                        .collect( Collectors.toList() )\n+                ) );\n+\n+        eventHashMap.values()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDEyNDYwNg==", "bodyText": "If 2 identical relationships without UID are in the payload, after updating the reference I think that the distinct will not recognise them as equals.", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r524124606", "createdAt": "2020-11-16T11:01:11Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,251 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .peek( enrollment -> enrollment.setNotes( enrollment.getNotes().stream()\n+                    .peek( this::updateNoteReferences )\n+                    .collect( Collectors.toList() )\n+                )\n+            )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n+\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        Set<Relationship> relationships = new HashSet<>();\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )\n+            .peek( event -> event.setNotes( event.getNotes().stream()\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() ) ) )\n+            .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n+        // Extract all relationships\n+        for ( Event event : eventHashMap.values() )\n         {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            extractRelationships( event )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n-        {\n-            enrollments.addAll( trackedEntity.getEnrollments().stream()\n-                .map( e -> addParent( e, trackedEntity.getTrackedEntity() ) ).collect( Collectors.toList() ) );\n-\n-            // Extract relationships from Tracked Entity\n-            relationships.addAll( trackedEntity.getRelationships() );\n+        // Set UID for all relationships\n+        dataBundle.getRelationships().stream()\n+            .peek( this::updateRelationshipReferences )\n+            .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+\n+        enrollmentHashMap.values()\n+            .forEach( enrollment -> enrollment\n+                .setNotes(\n+                    enrollment.getNotes().stream()\n+                        .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                        .collect( Collectors.toList() )\n+                ) );\n+\n+        eventHashMap.values()\n+            .forEach(\n+                event -> event.setNotes( event.getNotes().stream()\n+                    .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                    .collect( Collectors.toList() )\n+                ) );\n+\n+        return TrackerBundleParams.builder()\n+            .trackedEntities( new ArrayList<>( trackedEntityMap.values() ) )\n+            .enrollments( new ArrayList<>( enrollmentHashMap.values() ) )\n+            .events( new ArrayList<>( eventHashMap.values() ) )\n+            .relationships( relationshipHashMap.values().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMjE4MTQ0", "url": "https://github.com/dhis2/dhis2-core/pull/6674#pullrequestreview-531218144", "createdAt": "2020-11-16T11:02:19Z", "commit": {"oid": "c3f11e59a52bb38b78c029df4d75d05fa8db08ed"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efac254e3ce0af93a656b68a1ab97f42f6af735d", "author": {"user": {"login": "stian-sandvold", "name": "Stian Sandvold"}}, "url": "https://github.com/dhis2/dhis2-core/commit/efac254e3ce0af93a656b68a1ab97f42f6af735d", "committedDate": "2020-11-17T09:27:41Z", "message": "Fixed code based on initial feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c", "author": {"user": {"login": "stian-sandvold", "name": "Stian Sandvold"}}, "url": "https://github.com/dhis2/dhis2-core/commit/1adca824b3dd60095d1350829836a0463e1d9d8c", "committedDate": "2020-11-17T09:31:19Z", "message": "Merge branch 'NTI-converter-update' of github.com:dhis2/dhis2-core into NTI-converter-update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMjM1MTc1", "url": "https://github.com/dhis2/dhis2-core/pull/6674#pullrequestreview-532235175", "createdAt": "2020-11-17T10:44:03Z", "commit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDo0NDowNFrOH0u48Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDo0NDozMFrOH0u6Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjI0MQ==", "bodyText": "If event.getEvent() is null, what is going to happen?", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525056241", "createdAt": "2020-11-17T10:44:04Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjMzMw==", "bodyText": "We are updating references only for the events that are coming as a separate entity in the payload.\nIf we have an event inside an enrollment and this event has no uid, at some point the validation will fail.\nIs this expected?", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525056333", "createdAt": "2020-11-17T10:44:11Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        Set<Relationship> relationships = new HashSet<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n-        {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            enrollment.setNotes( enrollment.getNotes().stream()\n+                .filter( note -> !StringUtils.isEmpty( note.getValue() ) )\n+                .peek( this::updateNoteReferences )\n+                .collect( Collectors.toList() )\n+            );\n         }\n \n-        for ( TrackedEntity trackedEntity : bundle.getTrackedEntities() )\n+        // Set UID for all events and notes\n+        dataBundle.getEvents().stream()\n+            .peek( event -> updateEventReferences( event, event.getTrackedEntity(), event.getEnrollment() ) )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NjUyNg==", "bodyText": "Same as events", "url": "https://github.com/dhis2/dhis2-core/pull/6674#discussion_r525056526", "createdAt": "2020-11-17T10:44:30Z", "author": {"login": "enricocolasante"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1adca824b3dd60095d1350829836a0463e1d9d8c"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2272, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}