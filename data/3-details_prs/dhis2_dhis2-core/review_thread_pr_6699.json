{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyMzE0Mjc4", "number": 6699, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNzo1NjowN1rOE66ruA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNzo1Nzo1OFrOE66uAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjE0MzI4OnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNzo1NjowN1rOH2QqBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNzo1NjowN1rOH2QqBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY1ODA1NQ==", "bodyText": "As we discussed, make sure that we only generate UID for enrollment.getEnrollment()\nThe trackedEntity property should be left empty if it's not present in the original payload\nEnrollment:\nupdateReference(enrollment.getEnrollment)\nenrollment.getTei -> isEmpty() ? null : tei", "url": "https://github.com/dhis2/dhis2-core/pull/6699#discussion_r526658055", "createdAt": "2020-11-19T07:56:07Z", "author": {"login": "luciano-fiandesio"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46d87f4dfbf8ecf3b7e6a75823ac54ee2eddc70e"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjE0OTEyOnYy", "diffSide": "RIGHT", "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNzo1Nzo1OFrOH2Qtjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNzo1Nzo1OFrOH2Qtjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY1ODk1OQ==", "bodyText": "As we discussed, make sure that we only generate UID for event.setEvent()\nThe trackedEntity and enrollment property should be left empty if it's not present in the original payload.\nEvent:\nUpdateReference(event.getEvent)\nevent.getEnrollment -> isEmpty() ? null : enrollment\nevent.getTei -> isEmpty()? null : tei", "url": "https://github.com/dhis2/dhis2-core/pull/6699#discussion_r526658959", "createdAt": "2020-11-19T07:57:58Z", "author": {"login": "luciano-fiandesio"}, "path": "dhis-2/dhis-services/dhis-service-tracker/src/main/java/org/hisp/dhis/tracker/converter/TrackerBundleParamsConverter.java", "diffHunk": "@@ -84,174 +82,238 @@\n     extends\n     StdConverter<TrackerBundleParams, TrackerBundleParams>\n {\n+\n+    /**\n+     * Iterates over the collections of a dataBundle. If any objects in those collections have objects nested within\n+     * them, they are extracted. For each object we process, we make sure all references are valid as well.\n+     *\n+     * @param dataBundle containing collections to check and update.\n+     * @return a dataBundle with a flattened data structure, and valid uid references.\n+     */\n     @Override\n-    public TrackerBundleParams convert( TrackerBundleParams bundle )\n+    public TrackerBundleParams convert( TrackerBundleParams dataBundle )\n     {\n-        // pre assign UIDs to entities, if UIDs are missing\n-        generateUid( bundle );\n+        Map<String, TrackedEntity> trackedEntityMap = new HashMap<>();\n+        Map<String, Enrollment> enrollmentHashMap = new HashMap<>();\n+        Map<String, Event> eventHashMap = new HashMap<>();\n+        Map<String, Relationship> relationshipHashMap = new HashMap<>();\n \n-        if ( hasNestedStructure( bundle ) )\n+        // Extract all enrollments and relationships, and set parent reference.\n+        for ( TrackedEntity te : dataBundle.getTrackedEntities() )\n         {\n-            flattenPayload( bundle );\n-        }\n+            updateTrackedEntityReferences( te );\n+            trackedEntityMap.put( te.getTrackedEntity(), te );\n \n-        return bundle;\n-    }\n+            extractEnrollments( te )\n+                .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-    private void flattenPayload( TrackerBundleParams bundle )\n-    {\n+            extractRelationships( te )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n+        }\n \n-        List<Event> events = new ArrayList<>();\n+        // Set UID for all enrollments and notes\n+        dataBundle.getEnrollments().stream()\n+            .peek( enrollment -> updateEnrollmentReferences( enrollment, enrollment.getTrackedEntity() ) )\n+            .forEach( enrollment -> enrollmentHashMap.put( enrollment.getEnrollment(), enrollment ) );\n \n-        List<Enrollment> enrollments = new ArrayList<>();\n+        // Extract all events and relationships, and set parent references\n+        for ( Enrollment enrollment : enrollmentHashMap.values() )\n+        {\n+            extractEvents( enrollment )\n+                .forEach( event -> eventHashMap.put( event.getEvent(), event ) );\n \n-        Set<Relationship> relationships = new HashSet<>();\n+            extractRelationships( enrollment )\n+                .forEach( relationship -> relationshipHashMap.put( relationship.getRelationship(), relationship ) );\n \n-        // Iterate over **all** enrollments\n-        for ( Enrollment enrollment : bundle.getTrackedEntities().stream()\n-            .flatMap( l -> l.getEnrollments().stream() ).collect( Collectors.toList() ) )\n-        {\n-            // collect all events from enrollments and add them to the flattened events collection\n-            events.addAll( enrollment.getEvents().stream().map( e -> addParent( e, enrollment.getEnrollment() ) )\n-                .collect( Collectors.toList() ) );\n-\n-            // Extract relationships from enrollment\n-            relationships.addAll( enrollment.getRelationships() );\n-\n-            // Extract relationships from events\n-            relationships\n-                .addAll( events.stream().flatMap( l -> l.getRelationships().stream() ).collect( Collectors.toSet() ) );\n-\n-            // remove events and relationships from enrollment\n-            enrollment.setEvents( Collections.emptyList() );\n-            enrollment.setRelationships( Collections.emptyList() );\n-            // remove relationships from events\n-            events.forEach( e -> e.setRelationships( Collections.emptyList() ) );\n+            enrollment.setNotes( enrollment.getNotes().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46d87f4dfbf8ecf3b7e6a75823ac54ee2eddc70e"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3730, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}