{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYxOTYzNjM3", "number": 2103, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoxMzowMVrOEbOmuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyNjozMFrOEbOq0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg2Mjk5OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/client/ui/swing/boardview/AbstractWreckSprite.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoxMzowMVrOHFGIOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoxMzowMVrOHFGIOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNTMzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    bounds = new Rectangle(0,0,bv.hex_size.width, bv.hex_size.height);\n          \n          \n            \n                    bounds = new Rectangle(0, 0, bv.hex_size.width, bv.hex_size.height);", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475105338", "createdAt": "2020-08-22T16:13:01Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/client/ui/swing/boardview/AbstractWreckSprite.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * MegaMek - Copyright (C) 2020 - The MegaMek Team\n+ *\n+ *  This program is free software; you can redistribute it and/or modify it\n+ *  under the terms of the GNU General Public License as published by the Free\n+ *  Software Foundation; either version 2 of the License, or (at your option)\n+ *  any later version.\n+ *\n+ *  This program is distributed in the hope that it will be useful, but\n+ *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ *  for more details.\n+ */\n+\n+package megamek.client.ui.swing.boardview;\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+\n+import megamek.client.ui.swing.GUIPreferences;\n+import megamek.client.ui.swing.util.EntityWreckHelper;\n+import megamek.common.Entity;\n+import megamek.common.Terrains;\n+import megamek.common.util.ImageUtil;\n+\n+/**\n+ * Contains common functionality for wreck sprites (currently isometric and regular)\n+ * @author NickAragua\n+ *\n+ */\n+public abstract class AbstractWreckSprite extends Sprite {\n+    protected Entity entity;\n+\n+    protected Rectangle modelRect;\n+\n+    protected int secondaryPos;\n+    \n+    public AbstractWreckSprite(BoardView1 boardView1) {\n+        super(boardView1);\n+    }\n+    \n+    @Override\n+    public Rectangle getBounds() {\n+        // Start with the hex and add the label\n+        bounds = new Rectangle(0,0,bv.hex_size.width, bv.hex_size.height);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg2MzQ3OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/client/ui/swing/boardview/AbstractWreckSprite.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoxMzo0MVrOHFGIdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoxMzo0MVrOHFGIdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNTM5OA==", "bodyText": "Future proofing I guess:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (secondaryPos == -1) {\n          \n          \n            \n                    if (secondaryPos < 0 || secondaryPos >= entity.getSecondaryPositions().size()) {", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475105398", "createdAt": "2020-08-22T16:13:41Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/client/ui/swing/boardview/AbstractWreckSprite.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * MegaMek - Copyright (C) 2020 - The MegaMek Team\n+ *\n+ *  This program is free software; you can redistribute it and/or modify it\n+ *  under the terms of the GNU General Public License as published by the Free\n+ *  Software Foundation; either version 2 of the License, or (at your option)\n+ *  any later version.\n+ *\n+ *  This program is distributed in the hope that it will be useful, but\n+ *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ *  for more details.\n+ */\n+\n+package megamek.client.ui.swing.boardview;\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+\n+import megamek.client.ui.swing.GUIPreferences;\n+import megamek.client.ui.swing.util.EntityWreckHelper;\n+import megamek.common.Entity;\n+import megamek.common.Terrains;\n+import megamek.common.util.ImageUtil;\n+\n+/**\n+ * Contains common functionality for wreck sprites (currently isometric and regular)\n+ * @author NickAragua\n+ *\n+ */\n+public abstract class AbstractWreckSprite extends Sprite {\n+    protected Entity entity;\n+\n+    protected Rectangle modelRect;\n+\n+    protected int secondaryPos;\n+    \n+    public AbstractWreckSprite(BoardView1 boardView1) {\n+        super(boardView1);\n+    }\n+    \n+    @Override\n+    public Rectangle getBounds() {\n+        // Start with the hex and add the label\n+        bounds = new Rectangle(0,0,bv.hex_size.width, bv.hex_size.height);\n+        \n+        // Move to board position, save this origin for correct drawing\n+        Point hexOrigin = bounds.getLocation();\n+        Point ePos;\n+        if (secondaryPos == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg2NDg3OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/client/ui/swing/boardview/AbstractWreckSprite.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoxNToyNFrOHFGJDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoxNToyNFrOHFGJDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNTU0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if ((secondaryPos == -1) && GUIPreferences.getInstance()\n          \n          \n            \n                    if ((secondaryPos < 0) && GUIPreferences.getInstance()", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475105549", "createdAt": "2020-08-22T16:15:24Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/client/ui/swing/boardview/AbstractWreckSprite.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * MegaMek - Copyright (C) 2020 - The MegaMek Team\n+ *\n+ *  This program is free software; you can redistribute it and/or modify it\n+ *  under the terms of the GNU General Public License as published by the Free\n+ *  Software Foundation; either version 2 of the License, or (at your option)\n+ *  any later version.\n+ *\n+ *  This program is distributed in the hope that it will be useful, but\n+ *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ *  for more details.\n+ */\n+\n+package megamek.client.ui.swing.boardview;\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+\n+import megamek.client.ui.swing.GUIPreferences;\n+import megamek.client.ui.swing.util.EntityWreckHelper;\n+import megamek.common.Entity;\n+import megamek.common.Terrains;\n+import megamek.common.util.ImageUtil;\n+\n+/**\n+ * Contains common functionality for wreck sprites (currently isometric and regular)\n+ * @author NickAragua\n+ *\n+ */\n+public abstract class AbstractWreckSprite extends Sprite {\n+    protected Entity entity;\n+\n+    protected Rectangle modelRect;\n+\n+    protected int secondaryPos;\n+    \n+    public AbstractWreckSprite(BoardView1 boardView1) {\n+        super(boardView1);\n+    }\n+    \n+    @Override\n+    public Rectangle getBounds() {\n+        // Start with the hex and add the label\n+        bounds = new Rectangle(0,0,bv.hex_size.width, bv.hex_size.height);\n+        \n+        // Move to board position, save this origin for correct drawing\n+        Point hexOrigin = bounds.getLocation();\n+        Point ePos;\n+        if (secondaryPos == -1) {\n+            ePos = bv.getHexLocation(entity.getPosition());\n+        } else {\n+            ePos = bv.getHexLocation(entity.getSecondaryPositions().get(secondaryPos));\n+        }\n+        bounds.setLocation(hexOrigin.x + ePos.x, hexOrigin.y + ePos.y);\n+\n+        return bounds;\n+    }\n+\n+    /**\n+     * Creates the sprite for this entity. It is an extra pain to create\n+     * transparent images in AWT.\n+     */\n+    @Override\n+    public void prepare() {\n+        // figure out size\n+        String shortName = entity.getShortName();\n+        Font font = new Font(\"SansSerif\", Font.PLAIN, 10); //$NON-NLS-1$\n+        Rectangle tempRect = new Rectangle(47, 55, bv.getFontMetrics(font)\n+                .stringWidth(shortName) + 1, bv.getFontMetrics(font)\n+                .getAscent());\n+\n+        // create image for buffer\n+        image = ImageUtil.createAcceleratedImage(bounds.width, bounds.height);\n+        Graphics2D graph = (Graphics2D) image.getGraphics();\n+        \n+        // if the entity is underwater or would sink underwater, we want to make the wreckage translucent\n+        // so it looks like it sunk\n+        boolean entityIsUnderwater = (entity.relHeight() < 0) ||\n+                ((entity.relHeight() >= 0) && entity.getGame().getBoard().getHex(entity.getPosition()).containsTerrain(Terrains.WATER)) &&\n+                !EntityWreckHelper.entityOnBridge(entity);\n+        \n+        if(entityIsUnderwater) {\n+            graph.setComposite(AlphaComposite.getInstance(\n+                    AlphaComposite.SRC_OVER, 0.35f));\n+        }\n+\n+        // draw the 'destroyed decal' where appropriate\n+        boolean displayDestroyedDecal = EntityWreckHelper.displayDestroyedDecal(entity);\n+        \n+        if(displayDestroyedDecal) {\n+            Image destroyed = bv.tileManager.bottomLayerWreckMarkerFor(entity, 0);\n+            if (null != destroyed) {\n+                graph.drawImage(destroyed, 0, 0, this);\n+            }\n+        }\n+        \n+        // draw the 'fuel leak' decal where appropriate\n+        boolean drawFuelLeak = EntityWreckHelper.displayFuelLeak(entity);\n+        \n+        if(drawFuelLeak) {\n+            Image fuelLeak = bv.tileManager.bottomLayerFuelLeakMarkerFor(entity);\n+            if (null != fuelLeak) {\n+                graph.drawImage(fuelLeak, 0, 0, this);\n+            }\n+        }\n+        \n+        // draw the 'tires' or 'tracks' decal where appropriate\n+        boolean drawMotiveWreckage = EntityWreckHelper.displayMotiveDamage(entity);\n+        \n+        if(drawMotiveWreckage) {\n+            Image motiveWreckage = bv.tileManager.bottomLayerMotiveMarkerFor(entity);\n+            if (null != motiveWreckage) {\n+                graph.drawImage(motiveWreckage, 0, 0, this);\n+            }\n+        }\n+        \n+        // Draw wreck image, if we've got one.\n+        Image wreck = null;\n+        \n+        if(EntityWreckHelper.displayDevastation(entity)) {\n+            // objects in space should not have craters\n+            wreck = entity.getGame().getBoard().inSpace() ?\n+                    bv.tileManager.wreckMarkerFor(entity, secondaryPos) :\n+                    bv.tileManager.getCraterFor(entity, secondaryPos);\n+        } else {\n+            wreck = EntityWreckHelper.useExplicitWreckImage(entity) ? \n+                        bv.tileManager.wreckMarkerFor(entity, secondaryPos) :\n+                        bv.tileManager.imageFor(entity, secondaryPos);\n+        }\n+\n+        if (null != wreck) {\n+            graph.drawImage(wreck, 0, 0, this);\n+        }\n+        \n+        if(entityIsUnderwater) {\n+            graph.setComposite(AlphaComposite.getInstance(\n+                    AlphaComposite.SRC_OVER, 1.0f));\n+        }\n+        \n+        if ((secondaryPos == -1) && GUIPreferences.getInstance()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg2NjA3OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/client/ui/swing/boardview/IsometricWreckSprite.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoxNjo1NFrOHFGJmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoxNjo1NFrOHFGJmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNTY4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (secondaryPos == -1) {\n          \n          \n            \n                    if (secondaryPos < 0 || secondaryPos >= entity.getSecondaryPositions().size()) {", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475105689", "createdAt": "2020-08-22T16:16:54Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/client/ui/swing/boardview/IsometricWreckSprite.java", "diffHunk": "@@ -96,61 +73,12 @@ public void drawOnto(Graphics g, int x, int y, ImageObserver observer,\n     public Entity getEntity() {\n         return entity;\n     }\n-\n-    /**\n-     * Creates the sprite for this entity. It is an extra pain to create\n-     * transparent images in AWT.\n-     */\n-    @Override\n-    public void prepare() {\n-        // figure out size\n-        String shortName = entity.getShortName();\n-        Font font = new Font(\"SansSerif\", Font.PLAIN, 10); //$NON-NLS-1$\n-        Rectangle tempRect = new Rectangle(47, 55, bv.getFontMetrics(font)\n-                .stringWidth(shortName) + 1, bv.getFontMetrics(font)\n-                .getAscent());\n-\n-        // create image for buffer\n-        image = ImageUtil.createAcceleratedImage(bounds.width, bounds.height);\n-        Graphics graph = image.getGraphics();\n-\n-        // Draw wreck image,if we've got one.\n-        Image wreck = bv.tileManager.wreckMarkerFor(entity, -1);\n-        if (null != wreck) {\n-            graph.drawImage(wreck, 0, 0, this);\n-        }\n-\n-        if ((secondaryPos == -1) && GUIPreferences.getInstance()\n-                .getBoolean(GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL)) {\n-            // draw box with shortName\n-            Color text = Color.lightGray;\n-            Color bkgd = Color.darkGray;\n-            Color bord = Color.black;\n-\n-            graph.setFont(font);\n-            graph.setColor(bord);\n-            graph.fillRect(tempRect.x, tempRect.y, tempRect.width,\n-                    tempRect.height);\n-            tempRect.translate(-1, -1);\n-            graph.setColor(bkgd);\n-            graph.fillRect(tempRect.x, tempRect.y, tempRect.width,\n-                    tempRect.height);\n-            graph.setColor(text);\n-            graph.drawString(shortName, tempRect.x + 1,\n-                    (tempRect.y + tempRect.height) - 1);\n+    \n+    public Coords getPosition() {\n+        if (secondaryPos == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg2OTQ2OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/client/ui/swing/tileset/EntityImage.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyMDo1OFrOHFGLKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNzowNToxMlrOHFGaoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjA4OQ==", "bodyText": "Floating point math is weird, is this always going to be 1.0?", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475106089", "createdAt": "2020-08-22T16:20:58Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/client/ui/swing/tileset/EntityImage.java", "diffHunk": "@@ -132,17 +134,49 @@ public EntityImage(Image base, Image wreck, int tint, Image camo,\n         this.camo = camo;\r\n         parent = comp;\r\n         this.wreck = wreck;\r\n-        this.dmgLevel = entity.getDamageLevel();\r\n-        this.weight = entity.getWeight();\r\n+        this.dmgLevel = calculateDamageLevel(entity);\r\n+        // hack: gun emplacements are pretty beefy but have weight 0\r\n+        this.weight = entity instanceof GunEmplacement ?\r\n+                SMOKE_THREE + 1 : entity.getWeight();\r\n         isInfantry = entity instanceof Infantry;\r\n+        isTank = entity instanceof Tank;\r\n         isPreview = preview;\r\n-        isSlim = entity instanceof Tank || entity instanceof Aero;\r\n+        isSlim = (isTank && !(entity instanceof GunEmplacement));\r\n         isVerySlim = entity instanceof VTOL;\r\n         pos = secondaryPos;\r\n         isSingleHex = secondaryPos == -1;\r\n         decal = getDamageDecal(entity, secondaryPos);\r\n         smoke = getSmokeImage(entity, secondaryPos);\r\n     }\r\n+    \r\n+    /**\r\n+     * Worker function that calculates the entity's damage level for the purposes of displaying damage \r\n+     * to avoid particularly dumb-looking situations\r\n+     */\r\n+    private int calculateDamageLevel(Entity entity) {\r\n+        // gun emplacements don't show up as crippled when destroyed, which leads to them looking pristine\r\n+        if((entity instanceof GunEmplacement) && entity.isDestroyed()) {\r\n+            return Entity.DMG_CRIPPLED;\r\n+        }\r\n+        \r\n+        // aerospace fighters where the pilot ejects look pretty dumb without any damage decals\r\n+        // so let's give them at least some damage\r\n+        if(entity.isAirborne() && entity.getCrew().isEjected()) {\r\n+            return Math.max(Entity.DMG_HEAVY, entity.getDamageLevel(false));\r\n+        }\r\n+        \r\n+        int calculatedDamageLevel = entity.getDamageLevel();\r\n+        \r\n+        // crippled entities may be \"crippled\" due to harmless weapon jams or being out of ammo but \r\n+        // not having taken any actual damage\r\n+        if(calculatedDamageLevel == Entity.DMG_CRIPPLED) {\r\n+            if(entity.getArmorRemainingPercent() == 1.0) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjYzMQ==", "bodyText": "Double check your logic here and below, you're mixing fractions and percents.", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475106631", "createdAt": "2020-08-22T16:27:12Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/client/ui/swing/tileset/EntityImage.java", "diffHunk": "@@ -132,17 +134,49 @@ public EntityImage(Image base, Image wreck, int tint, Image camo,\n         this.camo = camo;\r\n         parent = comp;\r\n         this.wreck = wreck;\r\n-        this.dmgLevel = entity.getDamageLevel();\r\n-        this.weight = entity.getWeight();\r\n+        this.dmgLevel = calculateDamageLevel(entity);\r\n+        // hack: gun emplacements are pretty beefy but have weight 0\r\n+        this.weight = entity instanceof GunEmplacement ?\r\n+                SMOKE_THREE + 1 : entity.getWeight();\r\n         isInfantry = entity instanceof Infantry;\r\n+        isTank = entity instanceof Tank;\r\n         isPreview = preview;\r\n-        isSlim = entity instanceof Tank || entity instanceof Aero;\r\n+        isSlim = (isTank && !(entity instanceof GunEmplacement));\r\n         isVerySlim = entity instanceof VTOL;\r\n         pos = secondaryPos;\r\n         isSingleHex = secondaryPos == -1;\r\n         decal = getDamageDecal(entity, secondaryPos);\r\n         smoke = getSmokeImage(entity, secondaryPos);\r\n     }\r\n+    \r\n+    /**\r\n+     * Worker function that calculates the entity's damage level for the purposes of displaying damage \r\n+     * to avoid particularly dumb-looking situations\r\n+     */\r\n+    private int calculateDamageLevel(Entity entity) {\r\n+        // gun emplacements don't show up as crippled when destroyed, which leads to them looking pristine\r\n+        if((entity instanceof GunEmplacement) && entity.isDestroyed()) {\r\n+            return Entity.DMG_CRIPPLED;\r\n+        }\r\n+        \r\n+        // aerospace fighters where the pilot ejects look pretty dumb without any damage decals\r\n+        // so let's give them at least some damage\r\n+        if(entity.isAirborne() && entity.getCrew().isEjected()) {\r\n+            return Math.max(Entity.DMG_HEAVY, entity.getDamageLevel(false));\r\n+        }\r\n+        \r\n+        int calculatedDamageLevel = entity.getDamageLevel();\r\n+        \r\n+        // crippled entities may be \"crippled\" due to harmless weapon jams or being out of ammo but \r\n+        // not having taken any actual damage\r\n+        if(calculatedDamageLevel == Entity.DMG_CRIPPLED) {\r\n+            if(entity.getArmorRemainingPercent() == 1.0) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjA4OQ=="}, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTExMDA0OA==", "bodyText": "I can see a theoretical possibility that it'll come out higher than 1, but if it's below 1 we can consider it damaged.", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475110048", "createdAt": "2020-08-22T17:05:12Z", "author": {"login": "NickAragua"}, "path": "megamek/src/megamek/client/ui/swing/tileset/EntityImage.java", "diffHunk": "@@ -132,17 +134,49 @@ public EntityImage(Image base, Image wreck, int tint, Image camo,\n         this.camo = camo;\r\n         parent = comp;\r\n         this.wreck = wreck;\r\n-        this.dmgLevel = entity.getDamageLevel();\r\n-        this.weight = entity.getWeight();\r\n+        this.dmgLevel = calculateDamageLevel(entity);\r\n+        // hack: gun emplacements are pretty beefy but have weight 0\r\n+        this.weight = entity instanceof GunEmplacement ?\r\n+                SMOKE_THREE + 1 : entity.getWeight();\r\n         isInfantry = entity instanceof Infantry;\r\n+        isTank = entity instanceof Tank;\r\n         isPreview = preview;\r\n-        isSlim = entity instanceof Tank || entity instanceof Aero;\r\n+        isSlim = (isTank && !(entity instanceof GunEmplacement));\r\n         isVerySlim = entity instanceof VTOL;\r\n         pos = secondaryPos;\r\n         isSingleHex = secondaryPos == -1;\r\n         decal = getDamageDecal(entity, secondaryPos);\r\n         smoke = getSmokeImage(entity, secondaryPos);\r\n     }\r\n+    \r\n+    /**\r\n+     * Worker function that calculates the entity's damage level for the purposes of displaying damage \r\n+     * to avoid particularly dumb-looking situations\r\n+     */\r\n+    private int calculateDamageLevel(Entity entity) {\r\n+        // gun emplacements don't show up as crippled when destroyed, which leads to them looking pristine\r\n+        if((entity instanceof GunEmplacement) && entity.isDestroyed()) {\r\n+            return Entity.DMG_CRIPPLED;\r\n+        }\r\n+        \r\n+        // aerospace fighters where the pilot ejects look pretty dumb without any damage decals\r\n+        // so let's give them at least some damage\r\n+        if(entity.isAirborne() && entity.getCrew().isEjected()) {\r\n+            return Math.max(Entity.DMG_HEAVY, entity.getDamageLevel(false));\r\n+        }\r\n+        \r\n+        int calculatedDamageLevel = entity.getDamageLevel();\r\n+        \r\n+        // crippled entities may be \"crippled\" due to harmless weapon jams or being out of ammo but \r\n+        // not having taken any actual damage\r\n+        if(calculatedDamageLevel == Entity.DMG_CRIPPLED) {\r\n+            if(entity.getArmorRemainingPercent() == 1.0) {\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjA4OQ=="}, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg2OTg2OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/client/ui/swing/tileset/TilesetManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyMTozN1rOHFGLWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyMTozN1rOHFGLWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjEzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<EntityImage> mechImageList = new ArrayList<EntityImage>();\n          \n          \n            \n                private Map<ArrayList<Integer>, EntityImage> mechImages = new HashMap<ArrayList<Integer>, EntityImage>();\n          \n          \n            \n                private List<EntityImage> mechImageList = new ArrayList<>();\n          \n          \n            \n                private Map<ArrayList<Integer>, EntityImage> mechImages = new HashMap<>();", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475106137", "createdAt": "2020-08-22T16:21:37Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/client/ui/swing/tileset/TilesetManager.java", "diffHunk": "@@ -78,8 +88,10 @@\n     private MechTileset mechTileset = new MechTileset(Configuration.unitImagesDir());\n     private MechTileset wreckTileset = new MechTileset(\n             new MegaMekFile(Configuration.unitImagesDir(), DIR_NAME_WRECKS).getFile());\n-    private ArrayList<EntityImage> mechImageList = new ArrayList<EntityImage>();\n-    private HashMap<ArrayList<Integer>, EntityImage> mechImages = new HashMap<ArrayList<Integer>, EntityImage>();\n+    private List<EntityImage> mechImageList = new ArrayList<EntityImage>();\n+    private Map<ArrayList<Integer>, EntityImage> mechImages = new HashMap<ArrayList<Integer>, EntityImage>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg3MDE3OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/client/ui/swing/tileset/TilesetManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyMTo0OVrOHFGLew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyMTo0OVrOHFGLew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjE3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<Color, Image> ecmStaticImages = new HashMap<Color, Image>();\n          \n          \n            \n                private Map<Color, Image> ecmStaticImages = new HashMap<>();", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475106171", "createdAt": "2020-08-22T16:21:49Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/client/ui/swing/tileset/TilesetManager.java", "diffHunk": "@@ -100,7 +112,7 @@\n      * images for various colors (for Players, and possibly multiple players\n      * in the same hex).\n      */\n-    private HashMap<Color, Image> ecmStaticImages = new HashMap<Color, Image>();\n+    private Map<Color, Image> ecmStaticImages = new HashMap<Color, Image>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg3MTE5OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/client/ui/swing/tileset/TilesetManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyMzoyNFrOHFGL-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjo1ODoxNlrOHFGYKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjI5OA==", "bodyText": "What's the magic with 4?", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475106298", "createdAt": "2020-08-22T16:23:24Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/client/ui/swing/tileset/TilesetManager.java", "diffHunk": "@@ -179,6 +217,107 @@ public Image wreckMarkerFor(Entity entity, int secondaryPos) {\n         }\n         return entityImage.getWreckFacing(entity.getFacing());\n     }\n+    \n+    /** Retrieves the \"devastated\" decoration for the given entity */\n+    public Image getCraterFor(Entity entity, int secondaryPos) {\n+        Image marker = null;\n+        \n+        String suffix = EntityWreckHelper.getWeightSuffix(entity);\n+        String filename = String.format(\"crater_decal_%s.png\", suffix);\n+        String path = String.format(\"%s/%s\", DIR_NAME_WRECKS, DIR_NAME_BOTTOM_DECALS);\n+        \n+        if(wreckageDecals.containsKey(filename)) {\n+            marker = wreckageDecals.get(filename);\n+        } else {\n+            marker = TilesetManager.LoadSpecificImage(new File(Configuration.unitImagesDir(), path), filename);\n+            wreckageDecals.put(filename, marker);\n+        }\n+        \n+        return marker;\n+    }\n+    \n+    /** Retrieves the \"destroyed\" decoration for the given entity */\n+    public Image bottomLayerWreckMarkerFor(Entity entity, int secondaryPos) {\n+        Image marker = null;\n+\n+        // wreck filenames are in the format destroyed_decal_x_weightsuffix, where x is 1 through however many bottom splats we have\n+        // in the directory. To make sure we don't swap splats between entities, we make it depend on entity ID        \n+        String suffix = EntityWreckHelper.getWeightSuffix(entity);\n+        int wreckNum = (entity.getId() % this.wreckageDecalCount.get(suffix)) + 1;\n+        String filename = String.format(\"%s%d_%s.png\", FILENAME_PREFIX_WRECKS, wreckNum, suffix);\n+        String path = String.format(\"%s/%s\", DIR_NAME_WRECKS, DIR_NAME_BOTTOM_DECALS);\n+        \n+        if(wreckageDecals.containsKey(filename)) {\n+            marker = wreckageDecals.get(filename);\n+        } else {\n+            marker = TilesetManager.LoadSpecificImage(new File(Configuration.unitImagesDir(), path), filename);\n+            wreckageDecals.put(filename, marker);\n+        }\n+        \n+        return marker;\n+    }\n+    \n+    /** Retrieves the \"destroyed\" decoration for the given entity */\n+    public Image bottomLayerFuelLeakMarkerFor(Entity entity) {\n+        Image marker = null;\n+        \n+        String suffix = EntityWreckHelper.getWeightSuffix(entity);\n+        String filename = String.format(\"fuelleak_decal_%s.png\", suffix);\n+        String path = String.format(\"%s/%s\", DIR_NAME_WRECKS, DIR_NAME_BOTTOM_DECALS);\n+        \n+        int rotationKey = entity.getId() % 4;\n+        String imageKey = String.format(\"%s%s\", filename, rotationKey);\n+        \n+        if(!wreckageDecals.containsKey(imageKey)) {\n+            Image baseImage = TilesetManager.LoadSpecificImage(new File(Configuration.unitImagesDir(), path), filename);\n+            \n+            for(double x = 0; x < 4; x++) {\n+                RotateFilter rf = new RotateFilter(x * 90);\n+                String newImageKey = String.format(\"%s%s\", filename, (int) x);\n+                \n+                ImageProducer ip = new FilteredImageSource(baseImage.getSource(), rf);\n+                Image resultImage = Toolkit.getDefaultToolkit().createImage(ip);\n+                wreckageDecals.put(newImageKey, resultImage);\n+            }\n+        }\n+        \n+        marker = wreckageDecals.get(imageKey);\n+        \n+        return marker;\n+    }\n+    \n+    /** Retrieves the \"destroyed\" decoration for the given entity */\n+    public Image bottomLayerMotiveMarkerFor(Entity entity) {\n+        Image marker = null;\n+        \n+        String weightSuffix = EntityWreckHelper.getWeightSuffix(entity);\n+        String motivePrefix = EntityWreckHelper.getMotivePrefix(entity);\n+        \n+        if(motivePrefix != null) {\n+            String filename = String.format(\"%s_decal_%s.png\", motivePrefix, weightSuffix);\n+            String path = String.format(\"%s/%s\", DIR_NAME_WRECKS, DIR_NAME_BOTTOM_DECALS);\n+            \n+            int rotationKey = entity.getId() % 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwOTQxOA==", "bodyText": "I only made one of each \"motive damage\" decals, but I wanted a little variety, so I rotate them in 90 degree increments. Will turn the magic number into a constant.", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475109418", "createdAt": "2020-08-22T16:58:16Z", "author": {"login": "NickAragua"}, "path": "megamek/src/megamek/client/ui/swing/tileset/TilesetManager.java", "diffHunk": "@@ -179,6 +217,107 @@ public Image wreckMarkerFor(Entity entity, int secondaryPos) {\n         }\n         return entityImage.getWreckFacing(entity.getFacing());\n     }\n+    \n+    /** Retrieves the \"devastated\" decoration for the given entity */\n+    public Image getCraterFor(Entity entity, int secondaryPos) {\n+        Image marker = null;\n+        \n+        String suffix = EntityWreckHelper.getWeightSuffix(entity);\n+        String filename = String.format(\"crater_decal_%s.png\", suffix);\n+        String path = String.format(\"%s/%s\", DIR_NAME_WRECKS, DIR_NAME_BOTTOM_DECALS);\n+        \n+        if(wreckageDecals.containsKey(filename)) {\n+            marker = wreckageDecals.get(filename);\n+        } else {\n+            marker = TilesetManager.LoadSpecificImage(new File(Configuration.unitImagesDir(), path), filename);\n+            wreckageDecals.put(filename, marker);\n+        }\n+        \n+        return marker;\n+    }\n+    \n+    /** Retrieves the \"destroyed\" decoration for the given entity */\n+    public Image bottomLayerWreckMarkerFor(Entity entity, int secondaryPos) {\n+        Image marker = null;\n+\n+        // wreck filenames are in the format destroyed_decal_x_weightsuffix, where x is 1 through however many bottom splats we have\n+        // in the directory. To make sure we don't swap splats between entities, we make it depend on entity ID        \n+        String suffix = EntityWreckHelper.getWeightSuffix(entity);\n+        int wreckNum = (entity.getId() % this.wreckageDecalCount.get(suffix)) + 1;\n+        String filename = String.format(\"%s%d_%s.png\", FILENAME_PREFIX_WRECKS, wreckNum, suffix);\n+        String path = String.format(\"%s/%s\", DIR_NAME_WRECKS, DIR_NAME_BOTTOM_DECALS);\n+        \n+        if(wreckageDecals.containsKey(filename)) {\n+            marker = wreckageDecals.get(filename);\n+        } else {\n+            marker = TilesetManager.LoadSpecificImage(new File(Configuration.unitImagesDir(), path), filename);\n+            wreckageDecals.put(filename, marker);\n+        }\n+        \n+        return marker;\n+    }\n+    \n+    /** Retrieves the \"destroyed\" decoration for the given entity */\n+    public Image bottomLayerFuelLeakMarkerFor(Entity entity) {\n+        Image marker = null;\n+        \n+        String suffix = EntityWreckHelper.getWeightSuffix(entity);\n+        String filename = String.format(\"fuelleak_decal_%s.png\", suffix);\n+        String path = String.format(\"%s/%s\", DIR_NAME_WRECKS, DIR_NAME_BOTTOM_DECALS);\n+        \n+        int rotationKey = entity.getId() % 4;\n+        String imageKey = String.format(\"%s%s\", filename, rotationKey);\n+        \n+        if(!wreckageDecals.containsKey(imageKey)) {\n+            Image baseImage = TilesetManager.LoadSpecificImage(new File(Configuration.unitImagesDir(), path), filename);\n+            \n+            for(double x = 0; x < 4; x++) {\n+                RotateFilter rf = new RotateFilter(x * 90);\n+                String newImageKey = String.format(\"%s%s\", filename, (int) x);\n+                \n+                ImageProducer ip = new FilteredImageSource(baseImage.getSource(), rf);\n+                Image resultImage = Toolkit.getDefaultToolkit().createImage(ip);\n+                wreckageDecals.put(newImageKey, resultImage);\n+            }\n+        }\n+        \n+        marker = wreckageDecals.get(imageKey);\n+        \n+        return marker;\n+    }\n+    \n+    /** Retrieves the \"destroyed\" decoration for the given entity */\n+    public Image bottomLayerMotiveMarkerFor(Entity entity) {\n+        Image marker = null;\n+        \n+        String weightSuffix = EntityWreckHelper.getWeightSuffix(entity);\n+        String motivePrefix = EntityWreckHelper.getMotivePrefix(entity);\n+        \n+        if(motivePrefix != null) {\n+            String filename = String.format(\"%s_decal_%s.png\", motivePrefix, weightSuffix);\n+            String path = String.format(\"%s/%s\", DIR_NAME_WRECKS, DIR_NAME_BOTTOM_DECALS);\n+            \n+            int rotationKey = entity.getId() % 4;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjI5OA=="}, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg3MjcyOnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/client/ui/swing/util/EntityWreckHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyNToxOFrOHFGMqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjo1OTowMVrOHFGYWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjQ3Mg==", "bodyText": "Does this handle entities that have moved offboard? I know we've had some issues with that in the past.", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475106472", "createdAt": "2020-08-22T16:25:18Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/client/ui/swing/util/EntityWreckHelper.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * MegaMek - Copyright (C) 2020 - The MegaMek Team\n+ *\n+ *  This program is free software; you can redistribute it and/or modify it\n+ *  under the terms of the GNU General Public License as published by the Free\n+ *  Software Foundation; either version 2 of the License, or (at your option)\n+ *  any later version.\n+ *\n+ *  This program is distributed in the hope that it will be useful, but\n+ *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ *  for more details.\n+ */\n+\n+package megamek.client.ui.swing.util;\n+\n+import megamek.client.ui.swing.tileset.TilesetManager;\n+import megamek.common.Engine;\n+import megamek.common.Entity;\n+import megamek.common.EntityMovementMode;\n+import megamek.common.EntityWeightClass;\n+import megamek.common.GunEmplacement;\n+import megamek.common.IEntityRemovalConditions;\n+import megamek.common.IHex;\n+import megamek.common.Infantry;\n+import megamek.common.Mech;\n+import megamek.common.Tank;\n+import megamek.common.Terrains;\n+\n+/**\n+ * This class handles logic for displaying various kinds of damage and destruction decals\n+ * @author NickAragua\n+ * \n+ */\n+public class EntityWreckHelper {    \n+    /**\n+     * Logic that determines if we should be display \"destroyed\" decals below the destroyed entity.\n+     * Assumes that the entity is destroyed.\n+     */\n+    public static boolean displayDestroyedDecal(Entity entity) {\n+        // don't display \"generic\" destroyed decals in the following situations:\n+        //  in space (looks weird)\n+        //  for mechs/infantry/VTOLs (needs specialized icons) \n+        //  for units that were destroyed by ejection rather than unit destruction\n+        //  for units on top of a bridge (looks kind of stupid)\n+        \n+        if(entity.getGame().getBoard().inSpace() ||\n+                (entity instanceof Mech) ||\n+                (entity instanceof Infantry) ||\n+                (entity instanceof GunEmplacement) ||\n+                !entity.getSecondaryPositions().isEmpty() ||\n+                entityOnBridge(entity)) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+    \n+    public static boolean useExplicitWreckImage(Entity entity) {\n+        return entity instanceof Mech;\n+    }\n+    \n+    /**\n+     * Logic that determines whether we should display a 'fuel leak' for the given entity.\n+     */\n+    public static boolean displayFuelLeak(Entity entity) {\n+        return (entity instanceof Tank) &&\n+                (entity.getMovementMode() != EntityMovementMode.VTOL) && \n+                (entity.getEngine().getEngineType() == Engine.COMBUSTION_ENGINE) &&\n+                entity.isPermanentlyImmobilized(false) &&\n+                !entity.getGame().getBoard().inSpace() &&\n+                !entityOnBridge(entity);\n+    }\n+    \n+    /**\n+     * Whether we should display 'motive damage' for the given entity, meaning loose treads and such\n+     */\n+    public static boolean displayMotiveDamage(Entity entity) {\n+        return entity.isPermanentlyImmobilized(false) && \n+                ((entity.getMovementMode() == EntityMovementMode.WHEELED) ||\n+                (entity.getMovementMode() == EntityMovementMode.TRACKED)) && \n+                entity.getSecondaryPositions().isEmpty() &&\n+                !entity.getGame().getBoard().inSpace() &&\n+                !entityOnBridge(entity);\n+    }\n+    \n+    /**\n+     * Whether a given entity should display a crater instead of its standard wreckage marker.\n+     */\n+    public static boolean displayDevastation(Entity entity) {\n+        return (entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_DEVASTATED);\n+    }\n+    \n+    /**\n+     * Gets the prefix used to retrieve image files for motive-damaged entities\n+     */\n+    public static String getMotivePrefix(Entity entity) {\n+        if(!displayMotiveDamage(entity)) {\n+            return null;\n+        }\n+        \n+        switch(entity.getMovementMode()) {\n+        case WHEELED:\n+            return \"wheels\";\n+        case TRACKED:\n+            return \"treads\";\n+        default:\n+            return null;\n+        }\n+    }\n+    \n+    /**\n+     * Gets the weight class suffix for destruction decals for the given entity\n+     */\n+    public static String getWeightSuffix(Entity entity) {\n+        switch(entity.getWeightClass()) {\n+        case EntityWeightClass.WEIGHT_ULTRA_LIGHT:\n+            return TilesetManager.FILENAME_SUFFIX_WRECKS_ULTRALIGHT;\n+        case EntityWeightClass.WEIGHT_LIGHT:\n+            // this is a \"hack\" as some units < 20 tons are classified as 'light'\n+            // additionally, gun emplacements are \"light\" but should really have a little more debris.\n+            if ((entity.getWeight() > 0) && (entity.getWeight() < 20)) {\n+               return TilesetManager.FILENAME_SUFFIX_WRECKS_ULTRALIGHT; \n+            } else {\n+                return TilesetManager.FILENAME_SUFFIX_WRECKS_ASSAULTPLUS;\n+            }\n+        default:\n+            return TilesetManager.FILENAME_SUFFIX_WRECKS_ASSAULTPLUS;\n+        }\n+    }\n+    \n+    /**\n+     * Utility function that determines if the entity is on a bridge\n+     */\n+    public static boolean entityOnBridge(Entity entity) {   \n+        IHex hex = entity.getGame().getBoard().getHex(entity.getPosition());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwOTQ2Nw==", "bodyText": "Yeah, in that case, the hex comes back as null and the null check below catches it.", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475109467", "createdAt": "2020-08-22T16:59:01Z", "author": {"login": "NickAragua"}, "path": "megamek/src/megamek/client/ui/swing/util/EntityWreckHelper.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * MegaMek - Copyright (C) 2020 - The MegaMek Team\n+ *\n+ *  This program is free software; you can redistribute it and/or modify it\n+ *  under the terms of the GNU General Public License as published by the Free\n+ *  Software Foundation; either version 2 of the License, or (at your option)\n+ *  any later version.\n+ *\n+ *  This program is distributed in the hope that it will be useful, but\n+ *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+ *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ *  for more details.\n+ */\n+\n+package megamek.client.ui.swing.util;\n+\n+import megamek.client.ui.swing.tileset.TilesetManager;\n+import megamek.common.Engine;\n+import megamek.common.Entity;\n+import megamek.common.EntityMovementMode;\n+import megamek.common.EntityWeightClass;\n+import megamek.common.GunEmplacement;\n+import megamek.common.IEntityRemovalConditions;\n+import megamek.common.IHex;\n+import megamek.common.Infantry;\n+import megamek.common.Mech;\n+import megamek.common.Tank;\n+import megamek.common.Terrains;\n+\n+/**\n+ * This class handles logic for displaying various kinds of damage and destruction decals\n+ * @author NickAragua\n+ * \n+ */\n+public class EntityWreckHelper {    \n+    /**\n+     * Logic that determines if we should be display \"destroyed\" decals below the destroyed entity.\n+     * Assumes that the entity is destroyed.\n+     */\n+    public static boolean displayDestroyedDecal(Entity entity) {\n+        // don't display \"generic\" destroyed decals in the following situations:\n+        //  in space (looks weird)\n+        //  for mechs/infantry/VTOLs (needs specialized icons) \n+        //  for units that were destroyed by ejection rather than unit destruction\n+        //  for units on top of a bridge (looks kind of stupid)\n+        \n+        if(entity.getGame().getBoard().inSpace() ||\n+                (entity instanceof Mech) ||\n+                (entity instanceof Infantry) ||\n+                (entity instanceof GunEmplacement) ||\n+                !entity.getSecondaryPositions().isEmpty() ||\n+                entityOnBridge(entity)) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+    \n+    public static boolean useExplicitWreckImage(Entity entity) {\n+        return entity instanceof Mech;\n+    }\n+    \n+    /**\n+     * Logic that determines whether we should display a 'fuel leak' for the given entity.\n+     */\n+    public static boolean displayFuelLeak(Entity entity) {\n+        return (entity instanceof Tank) &&\n+                (entity.getMovementMode() != EntityMovementMode.VTOL) && \n+                (entity.getEngine().getEngineType() == Engine.COMBUSTION_ENGINE) &&\n+                entity.isPermanentlyImmobilized(false) &&\n+                !entity.getGame().getBoard().inSpace() &&\n+                !entityOnBridge(entity);\n+    }\n+    \n+    /**\n+     * Whether we should display 'motive damage' for the given entity, meaning loose treads and such\n+     */\n+    public static boolean displayMotiveDamage(Entity entity) {\n+        return entity.isPermanentlyImmobilized(false) && \n+                ((entity.getMovementMode() == EntityMovementMode.WHEELED) ||\n+                (entity.getMovementMode() == EntityMovementMode.TRACKED)) && \n+                entity.getSecondaryPositions().isEmpty() &&\n+                !entity.getGame().getBoard().inSpace() &&\n+                !entityOnBridge(entity);\n+    }\n+    \n+    /**\n+     * Whether a given entity should display a crater instead of its standard wreckage marker.\n+     */\n+    public static boolean displayDevastation(Entity entity) {\n+        return (entity.getRemovalCondition() == IEntityRemovalConditions.REMOVE_DEVASTATED);\n+    }\n+    \n+    /**\n+     * Gets the prefix used to retrieve image files for motive-damaged entities\n+     */\n+    public static String getMotivePrefix(Entity entity) {\n+        if(!displayMotiveDamage(entity)) {\n+            return null;\n+        }\n+        \n+        switch(entity.getMovementMode()) {\n+        case WHEELED:\n+            return \"wheels\";\n+        case TRACKED:\n+            return \"treads\";\n+        default:\n+            return null;\n+        }\n+    }\n+    \n+    /**\n+     * Gets the weight class suffix for destruction decals for the given entity\n+     */\n+    public static String getWeightSuffix(Entity entity) {\n+        switch(entity.getWeightClass()) {\n+        case EntityWeightClass.WEIGHT_ULTRA_LIGHT:\n+            return TilesetManager.FILENAME_SUFFIX_WRECKS_ULTRALIGHT;\n+        case EntityWeightClass.WEIGHT_LIGHT:\n+            // this is a \"hack\" as some units < 20 tons are classified as 'light'\n+            // additionally, gun emplacements are \"light\" but should really have a little more debris.\n+            if ((entity.getWeight() > 0) && (entity.getWeight() < 20)) {\n+               return TilesetManager.FILENAME_SUFFIX_WRECKS_ULTRALIGHT; \n+            } else {\n+                return TilesetManager.FILENAME_SUFFIX_WRECKS_ASSAULTPLUS;\n+            }\n+        default:\n+            return TilesetManager.FILENAME_SUFFIX_WRECKS_ASSAULTPLUS;\n+        }\n+    }\n+    \n+    /**\n+     * Utility function that determines if the entity is on a bridge\n+     */\n+    public static boolean entityOnBridge(Entity entity) {   \n+        IHex hex = entity.getGame().getBoard().getHex(entity.getPosition());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjQ3Mg=="}, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg3MzA1OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/common/GunEmplacement.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyNTo0NlrOHFGM0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjo1OTo0OFrOHFGYpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjUxMg==", "bodyText": "Do these need to be public?", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475106512", "createdAt": "2020-08-22T16:25:46Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/common/GunEmplacement.java", "diffHunk": "@@ -51,6 +51,9 @@\n             .setTechRating(RATING_A).setAvailability(RATING_A, RATING_A, RATING_A, RATING_A)\n             .setStaticTechLevel(SimpleTechLevel.INTRO);\n     \n+    public int initialBuildingCF;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwOTU0MQ==", "bodyText": "Nope.", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475109541", "createdAt": "2020-08-22T16:59:48Z", "author": {"login": "NickAragua"}, "path": "megamek/src/megamek/common/GunEmplacement.java", "diffHunk": "@@ -51,6 +51,9 @@\n             .setTechRating(RATING_A).setAvailability(RATING_A, RATING_A, RATING_A, RATING_A)\n             .setStaticTechLevel(SimpleTechLevel.INTRO);\n     \n+    public int initialBuildingCF;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjUxMg=="}, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTg3MzQ3OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/common/GunEmplacement.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNjoyNjozMFrOHFGNAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNzowMToyM1rOHFGZQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjU2MA==", "bodyText": "The logic in a previous file used 1.0 as if percent was a fraction. This seems to insinuate we're using percents.", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475106560", "createdAt": "2020-08-22T16:26:30Z", "author": {"login": "sixlettervariables"}, "path": "megamek/src/megamek/common/GunEmplacement.java", "diffHunk": "@@ -585,4 +588,42 @@ public int getArmorType(int loc) {\n     public boolean hasStealth() {\n         return false;\n     }\n+    \n+    /**\n+     * Sets the deployed flag. \n+     * Has the side effect of initializing building CF if deployed\n+     */\n+    @Override\n+    public void setDeployed(boolean deployed) {\n+        super.setDeployed(deployed);\n+        \n+        if(deployed) {\n+            Building occupiedStructure = getGame().getBoard().getBuildingAt(getPosition());\n+            \n+            initialBuildingCF = occupiedStructure.getCurrentCF(getPosition());\n+            initialBuildingArmor = occupiedStructure.getArmor(getPosition());\n+        } else {\n+            initialBuildingCF = initialBuildingArmor = 0;\n+        }\n+    }\n+    \n+    /**\n+     * How much more damage, percentage-wise, the gun emplacement's building can take\n+     */\n+    @Override\n+    public double getArmorRemainingPercent() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwOTY5Nw==", "bodyText": "Adjusted to be consistent with the other entity getArmorRemainingPercent() calculation.", "url": "https://github.com/MegaMek/megamek/pull/2103#discussion_r475109697", "createdAt": "2020-08-22T17:01:23Z", "author": {"login": "NickAragua"}, "path": "megamek/src/megamek/common/GunEmplacement.java", "diffHunk": "@@ -585,4 +588,42 @@ public int getArmorType(int loc) {\n     public boolean hasStealth() {\n         return false;\n     }\n+    \n+    /**\n+     * Sets the deployed flag. \n+     * Has the side effect of initializing building CF if deployed\n+     */\n+    @Override\n+    public void setDeployed(boolean deployed) {\n+        super.setDeployed(deployed);\n+        \n+        if(deployed) {\n+            Building occupiedStructure = getGame().getBoard().getBuildingAt(getPosition());\n+            \n+            initialBuildingCF = occupiedStructure.getCurrentCF(getPosition());\n+            initialBuildingArmor = occupiedStructure.getArmor(getPosition());\n+        } else {\n+            initialBuildingCF = initialBuildingArmor = 0;\n+        }\n+    }\n+    \n+    /**\n+     * How much more damage, percentage-wise, the gun emplacement's building can take\n+     */\n+    @Override\n+    public double getArmorRemainingPercent() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEwNjU2MA=="}, "originalCommit": {"oid": "0082aca784f7965b37bc3a140ea0e62ed9a9b083"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2876, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}