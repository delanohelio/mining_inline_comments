{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2NDA0MzU3", "number": 1754, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMDo1OVrODnkqOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODozMDozN1rODnlDVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODIxNjkxOnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/server/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMTowMFrOF1pylg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMTowMFrOF1pylg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzU0Mg==", "bodyText": "Change is here, and can theoretically null error if the Player doesn't have a team assigned (according to a note in getTeamForPlayer, it can return null).", "url": "https://github.com/MegaMek/megamek/pull/1754#discussion_r391803542", "createdAt": "2020-03-12T18:11:00Z", "author": {"login": "Windchild292"}, "path": "megamek/src/megamek/server/Server.java", "diffHunk": "@@ -3135,71 +3135,78 @@ private void receiveForwardIni(int connectionId) {\n         if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {\n             return;\n         }\n+        \n         // get the next player from the team this player is on.\n         IPlayer next = game.getTeamForPlayer(current).getNextValidPlayer(current, game);\n-        // if the chosen player is a valid player, we change the turn order and\n-        // inform the clients.\n-        if ((next != null) && (game.getEntitiesOwnedBy(next) != 0)\n-                && (game.getTurnForPlayer(next.getId()) != null)) {\n-\n-            int currentTurnIndex = game.getTurnIndex();\n-            // now look for the next occurrence of player next in the turn order\n-            List<GameTurn> turns = game.getTurnVector();\n-            GameTurn turn = game.getTurn();\n-            // not entirely necessary. As we will also check this for the\n-            // activity of the button but to be sure do it on the server too.\n-            boolean isGeneralMoveTurn = !(turn instanceof GameTurn.SpecificEntityTurn)\n-                    && !(turn instanceof GameTurn.UnitNumberTurn)\n-                    && !(turn instanceof GameTurn.UnloadStrandedTurn);\n-            if (!isGeneralMoveTurn) {\n-                // if this is not a general turn the player cannot forward his turn.\n-                return;\n-            }\n-\n-            // if it is an EntityClassTurn we have to check make sure, that the\n-            // turn it is exchanged with is the same kind of turn!\n-            // in fact this requires an access function to the mask of an\n-            // EntityClassTurn.\n-            boolean isEntityClassTurn = (turn instanceof GameTurn.EntityClassTurn);\n-            int classMask = 0;\n-            if (isEntityClassTurn) {\n-                classMask = ((GameTurn.EntityClassTurn) turn).getTurnCode();\n-            }\n-\n-            boolean switched = false;\n-            int nextTurnId = 0;\n-            for (int i = currentTurnIndex; i < turns.size(); i++) {\n-                // if we find a turn for the specific player, swap the current\n-                // player with the player noted there\n-                // and stop\n-                if (turns.get(i).isValid(next.getId(), game)) {\n-                    nextTurnId = i;\n-                    if (isEntityClassTurn) {\n-                        // if we had an EntityClassTurn\n-                        if ((turns.get(i) instanceof GameTurn.EntityClassTurn)) {\n-                            // and found another EntityClassTurn\n-                            if (!(((GameTurn.EntityClassTurn) turns.get(i)).getTurnCode() == classMask)) {\n-                                // both have to refer to the SAME class(es) or\n-                                // they need to be rejected.\n+        \n+        while(!next.equals(current)) {\n+            // if the chosen player is a valid player, we change the turn order and\n+            // inform the clients.\n+            if ((next != null) && (game.getEntitiesOwnedBy(next) != 0)\n+                    && (game.getTurnForPlayer(next.getId()) != null)) {\n+    \n+                int currentTurnIndex = game.getTurnIndex();\n+                // now look for the next occurrence of player next in the turn order\n+                List<GameTurn> turns = game.getTurnVector();\n+                GameTurn turn = game.getTurn();\n+                // not entirely necessary. As we will also check this for the\n+                // activity of the button but to be sure do it on the server too.\n+                boolean isGeneralMoveTurn = !(turn instanceof GameTurn.SpecificEntityTurn)\n+                        && !(turn instanceof GameTurn.UnitNumberTurn)\n+                        && !(turn instanceof GameTurn.UnloadStrandedTurn);\n+                if (!isGeneralMoveTurn) {\n+                    // if this is not a general turn the player cannot forward his turn.\n+                    return;\n+                }\n+    \n+                // if it is an EntityClassTurn we have to check make sure, that the\n+                // turn it is exchanged with is the same kind of turn!\n+                // in fact this requires an access function to the mask of an\n+                // EntityClassTurn.\n+                boolean isEntityClassTurn = (turn instanceof GameTurn.EntityClassTurn);\n+                int classMask = 0;\n+                if (isEntityClassTurn) {\n+                    classMask = ((GameTurn.EntityClassTurn) turn).getTurnCode();\n+                }\n+    \n+                boolean switched = false;\n+                int nextTurnId = 0;\n+                for (int i = currentTurnIndex; i < turns.size(); i++) {\n+                    // if we find a turn for the specific player, swap the current\n+                    // player with the player noted there\n+                    // and stop\n+                    if (turns.get(i).isValid(next.getId(), game)) {\n+                        nextTurnId = i;\n+                        if (isEntityClassTurn) {\n+                            // if we had an EntityClassTurn\n+                            if ((turns.get(i) instanceof GameTurn.EntityClassTurn)) {\n+                                // and found another EntityClassTurn\n+                                if (!(((GameTurn.EntityClassTurn) turns.get(i)).getTurnCode() == classMask)) {\n+                                    // both have to refer to the SAME class(es) or\n+                                    // they need to be rejected.\n+                                    continue;\n+                                }\n+                            } else {\n                                 continue;\n                             }\n-                        } else {\n-                            continue;\n                         }\n+                        switched = true;\n+                        break;\n                     }\n-                    switched = true;\n-                    break;\n                 }\n+    \n+                // update turn order\n+                if (switched) {\n+                    game.swapTurnOrder(currentTurnIndex, nextTurnId);\n+                    // update the turn packages for all players.\n+                    send(createTurnVectorPacket());\n+                    send(createTurnIndexPacket(connectionId));\n+                    return;\n+                }\n+                // if nothing changed return without doing anything\n             }\n-\n-            // update turn order\n-            if (switched) {\n-                game.swapTurnOrder(currentTurnIndex, nextTurnId);\n-                // update the turn packages for all players.\n-                send(createTurnVectorPacket());\n-                send(createTurnIndexPacket(connectionId));\n-            }\n-            // if nothing changed return without doing anything\n+            \n+            next = game.getTeamForPlayer(current).getNextValidPlayer(next, game);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61947e4563899ce98c9c7f426b580e5dc92a7c96"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODIxNzM4OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/server/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMToxMFrOF1py8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMToxMFrOF1py8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzYzMw==", "bodyText": "Change is here", "url": "https://github.com/MegaMek/megamek/pull/1754#discussion_r391803633", "createdAt": "2020-03-12T18:11:10Z", "author": {"login": "Windchild292"}, "path": "megamek/src/megamek/server/Server.java", "diffHunk": "@@ -3135,71 +3135,78 @@ private void receiveForwardIni(int connectionId) {\n         if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {\n             return;\n         }\n+        \n         // get the next player from the team this player is on.\n         IPlayer next = game.getTeamForPlayer(current).getNextValidPlayer(current, game);\n-        // if the chosen player is a valid player, we change the turn order and\n-        // inform the clients.\n-        if ((next != null) && (game.getEntitiesOwnedBy(next) != 0)\n-                && (game.getTurnForPlayer(next.getId()) != null)) {\n-\n-            int currentTurnIndex = game.getTurnIndex();\n-            // now look for the next occurrence of player next in the turn order\n-            List<GameTurn> turns = game.getTurnVector();\n-            GameTurn turn = game.getTurn();\n-            // not entirely necessary. As we will also check this for the\n-            // activity of the button but to be sure do it on the server too.\n-            boolean isGeneralMoveTurn = !(turn instanceof GameTurn.SpecificEntityTurn)\n-                    && !(turn instanceof GameTurn.UnitNumberTurn)\n-                    && !(turn instanceof GameTurn.UnloadStrandedTurn);\n-            if (!isGeneralMoveTurn) {\n-                // if this is not a general turn the player cannot forward his turn.\n-                return;\n-            }\n-\n-            // if it is an EntityClassTurn we have to check make sure, that the\n-            // turn it is exchanged with is the same kind of turn!\n-            // in fact this requires an access function to the mask of an\n-            // EntityClassTurn.\n-            boolean isEntityClassTurn = (turn instanceof GameTurn.EntityClassTurn);\n-            int classMask = 0;\n-            if (isEntityClassTurn) {\n-                classMask = ((GameTurn.EntityClassTurn) turn).getTurnCode();\n-            }\n-\n-            boolean switched = false;\n-            int nextTurnId = 0;\n-            for (int i = currentTurnIndex; i < turns.size(); i++) {\n-                // if we find a turn for the specific player, swap the current\n-                // player with the player noted there\n-                // and stop\n-                if (turns.get(i).isValid(next.getId(), game)) {\n-                    nextTurnId = i;\n-                    if (isEntityClassTurn) {\n-                        // if we had an EntityClassTurn\n-                        if ((turns.get(i) instanceof GameTurn.EntityClassTurn)) {\n-                            // and found another EntityClassTurn\n-                            if (!(((GameTurn.EntityClassTurn) turns.get(i)).getTurnCode() == classMask)) {\n-                                // both have to refer to the SAME class(es) or\n-                                // they need to be rejected.\n+        \n+        while(!next.equals(current)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61947e4563899ce98c9c7f426b580e5dc92a7c96"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODIyMzM4OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/server/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMzowNVrOF1p24A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxMzowNVrOF1p24A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNDY0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    while(!next.equals(current)) {\n          \n          \n            \n                    while (!current.equals(next)) {", "url": "https://github.com/MegaMek/megamek/pull/1754#discussion_r391804640", "createdAt": "2020-03-12T18:13:05Z", "author": {"login": "Windchild292"}, "path": "megamek/src/megamek/server/Server.java", "diffHunk": "@@ -3135,71 +3135,78 @@ private void receiveForwardIni(int connectionId) {\n         if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {\n             return;\n         }\n+        \n         // get the next player from the team this player is on.\n         IPlayer next = game.getTeamForPlayer(current).getNextValidPlayer(current, game);\n-        // if the chosen player is a valid player, we change the turn order and\n-        // inform the clients.\n-        if ((next != null) && (game.getEntitiesOwnedBy(next) != 0)\n-                && (game.getTurnForPlayer(next.getId()) != null)) {\n-\n-            int currentTurnIndex = game.getTurnIndex();\n-            // now look for the next occurrence of player next in the turn order\n-            List<GameTurn> turns = game.getTurnVector();\n-            GameTurn turn = game.getTurn();\n-            // not entirely necessary. As we will also check this for the\n-            // activity of the button but to be sure do it on the server too.\n-            boolean isGeneralMoveTurn = !(turn instanceof GameTurn.SpecificEntityTurn)\n-                    && !(turn instanceof GameTurn.UnitNumberTurn)\n-                    && !(turn instanceof GameTurn.UnloadStrandedTurn);\n-            if (!isGeneralMoveTurn) {\n-                // if this is not a general turn the player cannot forward his turn.\n-                return;\n-            }\n-\n-            // if it is an EntityClassTurn we have to check make sure, that the\n-            // turn it is exchanged with is the same kind of turn!\n-            // in fact this requires an access function to the mask of an\n-            // EntityClassTurn.\n-            boolean isEntityClassTurn = (turn instanceof GameTurn.EntityClassTurn);\n-            int classMask = 0;\n-            if (isEntityClassTurn) {\n-                classMask = ((GameTurn.EntityClassTurn) turn).getTurnCode();\n-            }\n-\n-            boolean switched = false;\n-            int nextTurnId = 0;\n-            for (int i = currentTurnIndex; i < turns.size(); i++) {\n-                // if we find a turn for the specific player, swap the current\n-                // player with the player noted there\n-                // and stop\n-                if (turns.get(i).isValid(next.getId(), game)) {\n-                    nextTurnId = i;\n-                    if (isEntityClassTurn) {\n-                        // if we had an EntityClassTurn\n-                        if ((turns.get(i) instanceof GameTurn.EntityClassTurn)) {\n-                            // and found another EntityClassTurn\n-                            if (!(((GameTurn.EntityClassTurn) turns.get(i)).getTurnCode() == classMask)) {\n-                                // both have to refer to the SAME class(es) or\n-                                // they need to be rejected.\n+        \n+        while(!next.equals(current)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61947e4563899ce98c9c7f426b580e5dc92a7c96"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODI2OTAyOnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/server/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoyNzowMFrOF1qULg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoyNzowMFrOF1qULg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxMjE0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        next = game.getTeamForPlayer(current).getNextValidPlayer(next, game);\n          \n          \n            \n                        next = team.getNextValidPlayer(next, game);", "url": "https://github.com/MegaMek/megamek/pull/1754#discussion_r391812142", "createdAt": "2020-03-12T18:27:00Z", "author": {"login": "Windchild292"}, "path": "megamek/src/megamek/server/Server.java", "diffHunk": "@@ -3135,71 +3135,78 @@ private void receiveForwardIni(int connectionId) {\n         if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {\n             return;\n         }\n+        \n         // get the next player from the team this player is on.\n         IPlayer next = game.getTeamForPlayer(current).getNextValidPlayer(current, game);\n-        // if the chosen player is a valid player, we change the turn order and\n-        // inform the clients.\n-        if ((next != null) && (game.getEntitiesOwnedBy(next) != 0)\n-                && (game.getTurnForPlayer(next.getId()) != null)) {\n-\n-            int currentTurnIndex = game.getTurnIndex();\n-            // now look for the next occurrence of player next in the turn order\n-            List<GameTurn> turns = game.getTurnVector();\n-            GameTurn turn = game.getTurn();\n-            // not entirely necessary. As we will also check this for the\n-            // activity of the button but to be sure do it on the server too.\n-            boolean isGeneralMoveTurn = !(turn instanceof GameTurn.SpecificEntityTurn)\n-                    && !(turn instanceof GameTurn.UnitNumberTurn)\n-                    && !(turn instanceof GameTurn.UnloadStrandedTurn);\n-            if (!isGeneralMoveTurn) {\n-                // if this is not a general turn the player cannot forward his turn.\n-                return;\n-            }\n-\n-            // if it is an EntityClassTurn we have to check make sure, that the\n-            // turn it is exchanged with is the same kind of turn!\n-            // in fact this requires an access function to the mask of an\n-            // EntityClassTurn.\n-            boolean isEntityClassTurn = (turn instanceof GameTurn.EntityClassTurn);\n-            int classMask = 0;\n-            if (isEntityClassTurn) {\n-                classMask = ((GameTurn.EntityClassTurn) turn).getTurnCode();\n-            }\n-\n-            boolean switched = false;\n-            int nextTurnId = 0;\n-            for (int i = currentTurnIndex; i < turns.size(); i++) {\n-                // if we find a turn for the specific player, swap the current\n-                // player with the player noted there\n-                // and stop\n-                if (turns.get(i).isValid(next.getId(), game)) {\n-                    nextTurnId = i;\n-                    if (isEntityClassTurn) {\n-                        // if we had an EntityClassTurn\n-                        if ((turns.get(i) instanceof GameTurn.EntityClassTurn)) {\n-                            // and found another EntityClassTurn\n-                            if (!(((GameTurn.EntityClassTurn) turns.get(i)).getTurnCode() == classMask)) {\n-                                // both have to refer to the SAME class(es) or\n-                                // they need to be rejected.\n+        \n+        while(!next.equals(current)) {\n+            // if the chosen player is a valid player, we change the turn order and\n+            // inform the clients.\n+            if ((next != null) && (game.getEntitiesOwnedBy(next) != 0)\n+                    && (game.getTurnForPlayer(next.getId()) != null)) {\n+    \n+                int currentTurnIndex = game.getTurnIndex();\n+                // now look for the next occurrence of player next in the turn order\n+                List<GameTurn> turns = game.getTurnVector();\n+                GameTurn turn = game.getTurn();\n+                // not entirely necessary. As we will also check this for the\n+                // activity of the button but to be sure do it on the server too.\n+                boolean isGeneralMoveTurn = !(turn instanceof GameTurn.SpecificEntityTurn)\n+                        && !(turn instanceof GameTurn.UnitNumberTurn)\n+                        && !(turn instanceof GameTurn.UnloadStrandedTurn);\n+                if (!isGeneralMoveTurn) {\n+                    // if this is not a general turn the player cannot forward his turn.\n+                    return;\n+                }\n+    \n+                // if it is an EntityClassTurn we have to check make sure, that the\n+                // turn it is exchanged with is the same kind of turn!\n+                // in fact this requires an access function to the mask of an\n+                // EntityClassTurn.\n+                boolean isEntityClassTurn = (turn instanceof GameTurn.EntityClassTurn);\n+                int classMask = 0;\n+                if (isEntityClassTurn) {\n+                    classMask = ((GameTurn.EntityClassTurn) turn).getTurnCode();\n+                }\n+    \n+                boolean switched = false;\n+                int nextTurnId = 0;\n+                for (int i = currentTurnIndex; i < turns.size(); i++) {\n+                    // if we find a turn for the specific player, swap the current\n+                    // player with the player noted there\n+                    // and stop\n+                    if (turns.get(i).isValid(next.getId(), game)) {\n+                        nextTurnId = i;\n+                        if (isEntityClassTurn) {\n+                            // if we had an EntityClassTurn\n+                            if ((turns.get(i) instanceof GameTurn.EntityClassTurn)) {\n+                                // and found another EntityClassTurn\n+                                if (!(((GameTurn.EntityClassTurn) turns.get(i)).getTurnCode() == classMask)) {\n+                                    // both have to refer to the SAME class(es) or\n+                                    // they need to be rejected.\n+                                    continue;\n+                                }\n+                            } else {\n                                 continue;\n                             }\n-                        } else {\n-                            continue;\n                         }\n+                        switched = true;\n+                        break;\n                     }\n-                    switched = true;\n-                    break;\n                 }\n+    \n+                // update turn order\n+                if (switched) {\n+                    game.swapTurnOrder(currentTurnIndex, nextTurnId);\n+                    // update the turn packages for all players.\n+                    send(createTurnVectorPacket());\n+                    send(createTurnIndexPacket(connectionId));\n+                    return;\n+                }\n+                // if nothing changed return without doing anything\n             }\n-\n-            // update turn order\n-            if (switched) {\n-                game.swapTurnOrder(currentTurnIndex, nextTurnId);\n-                // update the turn packages for all players.\n-                send(createTurnVectorPacket());\n-                send(createTurnIndexPacket(connectionId));\n-            }\n-            // if nothing changed return without doing anything\n+            \n+            next = game.getTeamForPlayer(current).getNextValidPlayer(next, game);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61947e4563899ce98c9c7f426b580e5dc92a7c96"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyODI4MTE3OnYy", "diffSide": "RIGHT", "path": "megamek/src/megamek/server/Server.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODozMDozOFrOF1qcHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODozNjoxMVrOF1qniQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxNDE3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \n          \n          \n            \n                    // get the next player from the team this player is on.\n          \n          \n            \n                    IPlayer next = game.getTeamForPlayer(current).getNextValidPlayer(current, game);\n          \n          \n            \n                    // get the team for the next player\n          \n          \n            \n                    Team team = game.getTeamForPlayer(current)\n          \n          \n            \n                    // Create the player\n          \n          \n            \n                    IPlayer next;\n          \n          \n            \n                    //the team can theoretically be null, so we need to check and ensure it is not a null value\n          \n          \n            \n                    if (team != null) {\n          \n          \n            \n                        // get the next player from the team this player is on.\n          \n          \n            \n                        next = team.getNextValidPlayer(current, game);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        next = null;\n          \n          \n            \n                    }", "url": "https://github.com/MegaMek/megamek/pull/1754#discussion_r391814175", "createdAt": "2020-03-12T18:30:38Z", "author": {"login": "Windchild292"}, "path": "megamek/src/megamek/server/Server.java", "diffHunk": "@@ -3135,71 +3135,78 @@ private void receiveForwardIni(int connectionId) {\n         if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {\n             return;\n         }\n+        \n         // get the next player from the team this player is on.\n         IPlayer next = game.getTeamForPlayer(current).getNextValidPlayer(current, game);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61947e4563899ce98c9c7f426b580e5dc92a7c96"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxNzA5Nw==", "bodyText": "This will properly handle the potential case of a null team, which shouldn't happen but the code for getTeamForPlayer says is a possibility.", "url": "https://github.com/MegaMek/megamek/pull/1754#discussion_r391817097", "createdAt": "2020-03-12T18:36:11Z", "author": {"login": "Windchild292"}, "path": "megamek/src/megamek/server/Server.java", "diffHunk": "@@ -3135,71 +3135,78 @@ private void receiveForwardIni(int connectionId) {\n         if (game.getOptions().booleanOption(OptionsConstants.RPG_INDIVIDUAL_INITIATIVE)) {\n             return;\n         }\n+        \n         // get the next player from the team this player is on.\n         IPlayer next = game.getTeamForPlayer(current).getNextValidPlayer(current, game);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxNDE3NQ=="}, "originalCommit": {"oid": "61947e4563899ce98c9c7f426b580e5dc92a7c96"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2522, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}