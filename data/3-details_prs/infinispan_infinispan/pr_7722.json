{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwNTA2MTIx", "number": 7722, "title": "ISPN-11020 Max Idle Take 2", "bodyText": "https://issues.redhat.com/browse/ISPN-11020", "createdAt": "2020-01-08T15:11:04Z", "url": "https://github.com/infinispan/infinispan/pull/7722", "merged": true, "mergeCommit": {"oid": "b2dee7a1f41f1d97985350cee7df25916cadff13"}, "closed": true, "closedAt": "2020-01-14T16:37:11Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4YOgJgFqTMzOTk5NzE0Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6TqW-AFqTM0MjY3MzI0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5OTk3MTQy", "url": "https://github.com/infinispan/infinispan/pull/7722#pullrequestreview-339997142", "createdAt": "2020-01-08T16:44:45Z", "commit": {"oid": "1b970affd9a25527dd7e266223aae75c7dc19a49"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxNjo0NDo0NVrOFbdCBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQxNjo0NDo1NFrOFbdCTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMTUyNA==", "bodyText": "useless blank line", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r364331524", "createdAt": "2020-01-08T16:44:45Z", "author": {"login": "tristantarrant"}, "path": "core/src/main/java/org/infinispan/commands/write/TouchCommand.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.infinispan.commands.write;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.infinispan.commands.CommandInvocationId;\n+import org.infinispan.commands.Visitor;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.context.impl.FlagBitSets;\n+\n+public class TouchCommand extends AbstractDataWriteCommand {\n+   public static final byte COMMAND_ID = 61;\n+\n+   public TouchCommand() {\n+   }\n+\n+   public TouchCommand(Object key, int segment, long flagsBitSet, CommandInvocationId commandInvocationId) {\n+      super(key, segment, flagsBitSet, commandInvocationId);\n+   }\n+\n+   @Override\n+   public byte getCommandId() {\n+      return COMMAND_ID;\n+   }\n+\n+   @Override\n+   public boolean isSuccessful() {\n+      return true;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      output.writeObject(key);\n+      UnsignedNumeric.writeUnsignedInt(output, segment);\n+      output.writeLong(FlagBitSets.copyWithoutRemotableFlags(getFlagsBitSet()));\n+      CommandInvocationId.writeTo(output, commandInvocationId);\n+   }\n+\n+   @Override\n+   public void readFrom(ObjectInput input) throws IOException, ClassNotFoundException {\n+      key = input.readObject();\n+      segment = UnsignedNumeric.readUnsignedInt(input);\n+      setFlagsBitSet(input.readLong());\n+      commandInvocationId = CommandInvocationId.readFrom(input);\n+   }\n+\n+   @Override\n+   public boolean isConditional() {\n+      return false;\n+   }\n+\n+   @Override\n+   public ValueMatcher getValueMatcher() {\n+      return ValueMatcher.MATCH_NON_NULL;\n+   }\n+\n+   @Override\n+   public void setValueMatcher(ValueMatcher valueMatcher) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b970affd9a25527dd7e266223aae75c7dc19a49"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDMzMTU5Ng==", "bodyText": "useless blank line", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r364331596", "createdAt": "2020-01-08T16:44:54Z", "author": {"login": "tristantarrant"}, "path": "core/src/main/java/org/infinispan/commands/write/TouchCommand.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.infinispan.commands.write;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.infinispan.commands.CommandInvocationId;\n+import org.infinispan.commands.Visitor;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.context.impl.FlagBitSets;\n+\n+public class TouchCommand extends AbstractDataWriteCommand {\n+   public static final byte COMMAND_ID = 61;\n+\n+   public TouchCommand() {\n+   }\n+\n+   public TouchCommand(Object key, int segment, long flagsBitSet, CommandInvocationId commandInvocationId) {\n+      super(key, segment, flagsBitSet, commandInvocationId);\n+   }\n+\n+   @Override\n+   public byte getCommandId() {\n+      return COMMAND_ID;\n+   }\n+\n+   @Override\n+   public boolean isSuccessful() {\n+      return true;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      output.writeObject(key);\n+      UnsignedNumeric.writeUnsignedInt(output, segment);\n+      output.writeLong(FlagBitSets.copyWithoutRemotableFlags(getFlagsBitSet()));\n+      CommandInvocationId.writeTo(output, commandInvocationId);\n+   }\n+\n+   @Override\n+   public void readFrom(ObjectInput input) throws IOException, ClassNotFoundException {\n+      key = input.readObject();\n+      segment = UnsignedNumeric.readUnsignedInt(input);\n+      setFlagsBitSet(input.readLong());\n+      commandInvocationId = CommandInvocationId.readFrom(input);\n+   }\n+\n+   @Override\n+   public boolean isConditional() {\n+      return false;\n+   }\n+\n+   @Override\n+   public ValueMatcher getValueMatcher() {\n+      return ValueMatcher.MATCH_NON_NULL;\n+   }\n+\n+   @Override\n+   public void setValueMatcher(ValueMatcher valueMatcher) {\n+\n+   }\n+\n+   @Override\n+   public void fail() {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b970affd9a25527dd7e266223aae75c7dc19a49"}, "originalPosition": 66}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "abdbc2fe09d41d745ea941b5ca0c7c78f0cd1ad1", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/abdbc2fe09d41d745ea941b5ca0c7c78f0cd1ad1", "committedDate": "2020-01-08T17:08:11Z", "message": "Scattered cache should now be fixed as well"}, "afterCommit": {"oid": "b1888638147bead249485fafa1934f42a39bf563", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/b1888638147bead249485fafa1934f42a39bf563", "committedDate": "2020-01-08T19:32:06Z", "message": "Scattered cache should now be fixed as well"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b1888638147bead249485fafa1934f42a39bf563", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/b1888638147bead249485fafa1934f42a39bf563", "committedDate": "2020-01-08T19:32:06Z", "message": "Scattered cache should now be fixed as well"}, "afterCommit": {"oid": "34151fbf91e83d4357cd45c08dbf9fb37908c87f", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/34151fbf91e83d4357cd45c08dbf9fb37908c87f", "committedDate": "2020-01-08T20:43:06Z", "message": "ISPN-11020 Max Idle Take 2\n\n* Now send a touch command on every read for max idle entries"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "34151fbf91e83d4357cd45c08dbf9fb37908c87f", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/34151fbf91e83d4357cd45c08dbf9fb37908c87f", "committedDate": "2020-01-08T20:43:06Z", "message": "ISPN-11020 Max Idle Take 2\n\n* Now send a touch command on every read for max idle entries"}, "afterCommit": {"oid": "e40b3f37121be2447c82453c6c8f7df7e786f7ce", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/e40b3f37121be2447c82453c6c8f7df7e786f7ce", "committedDate": "2020-01-09T05:52:19Z", "message": "Adding in failover tests and fixed a couple bugs\n\nHow do we handle pessimistic locking though?"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e40b3f37121be2447c82453c6c8f7df7e786f7ce", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/e40b3f37121be2447c82453c6c8f7df7e786f7ce", "committedDate": "2020-01-09T05:52:19Z", "message": "Adding in failover tests and fixed a couple bugs\n\nHow do we handle pessimistic locking though?"}, "afterCommit": {"oid": "9009240eff2612279ea4d2f8f91a5bc0749aa7b6", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9009240eff2612279ea4d2f8f91a5bc0749aa7b6", "committedDate": "2020-01-10T20:25:16Z", "message": "different touch approach"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/59b1abc3f530e038139b47a0889f3a373d756dbf", "committedDate": "2020-01-10T21:54:43Z", "message": "ISPN-11020 Max Idle Take 2\n\n* Now send a touch command on every read for max idle entries"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cc969d3060a4427a4a6709d23199eaecda4b2ede", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/cc969d3060a4427a4a6709d23199eaecda4b2ede", "committedDate": "2020-01-10T20:54:16Z", "message": "fixes"}, "afterCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/59b1abc3f530e038139b47a0889f3a373d756dbf", "committedDate": "2020-01-10T21:54:43Z", "message": "ISPN-11020 Max Idle Take 2\n\n* Now send a touch command on every read for max idle entries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNzQ1ODYz", "url": "https://github.com/infinispan/infinispan/pull/7722#pullrequestreview-341745863", "createdAt": "2020-01-13T10:22:59Z", "commit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMDoyMjo1OVrOFcyWtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjozMDo1NFrOFc1YdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyOTQ2MQ==", "bodyText": "I'd call it canExpireMaxIdle() to match the existing method canExpire().", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365729461", "createdAt": "2020-01-13T10:22:59Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/entries/InternalCacheEntry.java", "diffHunk": "@@ -24,6 +24,13 @@\n     */\n    boolean canExpire();\n \n+   /**\n+    * @return true if this entry can expire via max idle, false otherwise\n+    */\n+   default boolean isMaxIdleExpirable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMDgxMg==", "bodyText": "Please inline the method and replace the if (expiredStage != null) check with if (ice.canExpire())", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365730812", "createdAt": "2020-01-13T10:26:04Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java", "diffHunk": "@@ -109,28 +109,9 @@ private void handleExpiredEntryContextAddition(Boolean expired, InvocationContex\n       }\n    }\n \n-   private CompletionStage<Boolean> handlePossibleExpiredEntry(InternalCacheEntry ice, boolean write) {\n+   private CompletionStage<Boolean> handlePossibleExpiredEntry(InternalCacheEntry ice, int segment, boolean isWrite) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMTk5Mg==", "bodyText": "There's no point in having the parameters in the javadoc if they don't have a description, all we get is complaints from IntelliJ.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365731992", "createdAt": "2020-01-13T10:28:52Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/impl/InternalDataContainer.java", "diffHunk": "@@ -60,6 +60,15 @@\n     */\n    InternalCacheEntry<K, V> peek(int segment, Object k);\n \n+   /**\n+    *\n+    * @param segment\n+    * @param k\n+    * @param currentTimeMillis", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczNDQ4OQ==", "bodyText": "I think you need CompletableFutures.extractException.\nAnd I'd merge thenApply and exceptionally into a single handle.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365734489", "createdAt": "2020-01-13T10:34:36Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0Mzk4Mg==", "bodyText": "Should inline", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365743982", "createdAt": "2020-01-13T10:56:43Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -270,11 +296,48 @@ public boolean containsKey(Object key) {\n \n       @Override\n       public CompletableFuture<V> getAsync(K key) {\n-         try {\n-            return CompletableFuture.completedFuture(get(key));\n-         } catch (Throwable t) {\n-            return CompletableFutures.completedExceptionFuture(t);\n+         return getCacheEntryAsync(key)\n+               .thenApply(ice -> ice != null ? ice.getValue() : null);\n+      }\n+\n+      private InternalCacheEntry<K, V> internalPeekCacheEntry(Object key, int segment) {\n+         assertKeyNotNull(key);\n+         checkCanRun(cache, cache.getName());\n+         return getDataContainer().peek(segment, key);\n+      }\n+\n+      @Override\n+      public CacheEntry<K, V> getCacheEntry(Object key) {\n+         return syncGet(key);\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         return asyncGet(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NDI3MQ==", "bodyText": "Could inline syncGet() in getCacheEntry() and use that here.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365744271", "createdAt": "2020-01-13T10:57:22Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -242,21 +250,39 @@ public void wireRealCache() {\n        */\n       protected void internalWire(T cache) {\n          componentRegistry = cache.componentRegistry;\n+         expirationManager = cache.expirationManager;\n+         keyPartitioner = cache.keyPartitioner;\n          wireRealCache();\n       }\n \n+      @Override\n+      public InternalDataContainer<K, V> getDataContainer() {\n+         return (InternalDataContainer<K, V>) super.getDataContainer();\n+      }\n+\n       @Override\n       public V get(Object key) {\n-         assertKeyNotNull(key);\n-         checkCanRun(cache, cache.getName());\n-         // TODO: what should we do here? - This needs to be fixed in https://issues.redhat.com/browse/ISPN-11124\n-         InternalCacheEntry<K, V> ice = getDataContainer().get(key);\n+         InternalCacheEntry<K, V> ice = syncGet(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NTQxNQ==", "bodyText": "ice isn't modified, so you could move this if at the top", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365745415", "createdAt": "2020-01-13T11:00:10Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -270,11 +296,48 @@ public boolean containsKey(Object key) {\n \n       @Override\n       public CompletableFuture<V> getAsync(K key) {\n-         try {\n-            return CompletableFuture.completedFuture(get(key));\n-         } catch (Throwable t) {\n-            return CompletableFutures.completedExceptionFuture(t);\n+         return getCacheEntryAsync(key)\n+               .thenApply(ice -> ice != null ? ice.getValue() : null);\n+      }\n+\n+      private InternalCacheEntry<K, V> internalPeekCacheEntry(Object key, int segment) {\n+         assertKeyNotNull(key);\n+         checkCanRun(cache, cache.getName());\n+         return getDataContainer().peek(segment, key);\n+      }\n+\n+      @Override\n+      public CacheEntry<K, V> getCacheEntry(Object key) {\n+         return syncGet(key);\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         return asyncGet(key);\n+      }\n+\n+      private CompletableFuture<CacheEntry<K, V>> asyncGet(Object key) {\n+         int segment = keyPartitioner.getSegment(key);\n+         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n+         if (ice != null) {\n+            if (ice.canExpire()) {\n+               CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n+               if (CompletionStages.isCompletedSuccessfully(stage)) {\n+                  return CompletableFutures.completedNull();\n+               } else {\n+                  return stage.thenApply(expired -> {\n+                     if (expired == Boolean.TRUE) {\n+                        return null;\n+                     }\n+                     return (CacheEntry<K, V>) ice;\n+                  }).toCompletableFuture();\n+               }\n+            }\n+         }\n+         if (ice == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NjQ5Mg==", "bodyText": "Forgot to check if the entry was expired or not", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365746492", "createdAt": "2020-01-13T11:02:54Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -270,11 +296,48 @@ public boolean containsKey(Object key) {\n \n       @Override\n       public CompletableFuture<V> getAsync(K key) {\n-         try {\n-            return CompletableFuture.completedFuture(get(key));\n-         } catch (Throwable t) {\n-            return CompletableFutures.completedExceptionFuture(t);\n+         return getCacheEntryAsync(key)\n+               .thenApply(ice -> ice != null ? ice.getValue() : null);\n+      }\n+\n+      private InternalCacheEntry<K, V> internalPeekCacheEntry(Object key, int segment) {\n+         assertKeyNotNull(key);\n+         checkCanRun(cache, cache.getName());\n+         return getDataContainer().peek(segment, key);\n+      }\n+\n+      @Override\n+      public CacheEntry<K, V> getCacheEntry(Object key) {\n+         return syncGet(key);\n+      }\n+\n+      @Override\n+      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n+         return asyncGet(key);\n+      }\n+\n+      private CompletableFuture<CacheEntry<K, V>> asyncGet(Object key) {\n+         int segment = keyPartitioner.getSegment(key);\n+         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n+         if (ice != null) {\n+            if (ice.canExpire()) {\n+               CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n+               if (CompletionStages.isCompletedSuccessfully(stage)) {\n+                  return CompletableFutures.completedNull();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NzQ2OA==", "bodyText": "Maybe it's worth extracting some of this logic into a method createTouchResponseCollector(CacheMode, LocalizedCacheTopology)?", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365747468", "createdAt": "2020-01-13T11:05:28Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0ODI3OA==", "bodyText": "The first part is probably better suited in the super method's javadoc.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365748278", "createdAt": "2020-01-13T11:07:38Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n+            rpcManager.getSyncRpcOptions());\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n+\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1NDI5MA==", "bodyText": "If one of the backup owners dies, a rebalance is started, but for a while there are multiple owners.\nIf the primary owner dies, for a while there is no primary owner, then a new primary owner is selected and it backs up to the next node + invalidates the other owners.\nInvalidation commands triggered by regular writes are also sent asynchronously (and in batches), so it's quite common to have more than 1 backup owner.\nSee also the scattered package javadoc", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365754290", "createdAt": "2020-01-13T11:24:03Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n+            rpcManager.getSyncRpcOptions());\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n+\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+         // then the value is not expired\n+         if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            return Boolean.FALSE;\n+         }\n+         return Boolean.TRUE;\n+      });\n+   }\n \n-      if (trace) {\n-         log.tracef(\"Asking all read owners %s for key: %s - for latest access time\", info.readOwners(), key);\n+   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n+      @Override\n+      protected Boolean addTargetNotFound(Address sender) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n       }\n \n-      // Need to gather last access times\n-      RetrieveLastAccessCommand rlac = cf.running().buildRetrieveLastAccessCommand(key, value, segment);\n-      rlac.setTopologyId(topology.getTopologyId());\n-\n-      // In scattered cache read owners will only contain primary\n-      return rpcManager.invokeCommand(info.readOwners(), rlac, new MaxResponseCollector<>(access),\n-            rpcManager.getSyncRpcOptions()).toCompletableFuture();\n+      @Override\n+      protected Boolean addException(Address sender, Exception exception) {\n+         if (exception instanceof CacheException) {\n+            throw (CacheException) exception;\n+         }\n+         throw new CacheException(exception);\n+      }\n    }\n \n-   static class MaxResponseCollector<T extends Comparable<T>> extends ValidResponseCollector<T> {\n-      T highest;\n-\n-      MaxResponseCollector(T highest) {\n-         this.highest = highest;\n-      }\n+   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n \n       @Override\n-      public T finish() {\n-         return highest;\n+      public Boolean finish() {\n+         // No other node was touched\n+         return Boolean.FALSE;\n       }\n \n       @Override\n-      protected T addValidResponse(Address sender, ValidResponse response) {\n-         T value = (T) response.getResponseValue();\n-         if (trace) {\n-            log.tracef(\"Received response %s from %s when requesting access time for max idle\", value, sender);\n-         }\n-         if (value != null && (highest == null || highest.compareTo(value) < 0)) {\n-            highest = value;\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.TRUE) {\n+            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n+            // TODO: what if the read was when one of the backups or primary died?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ==", "bodyText": "I'd rather not return early, because you'd leave touch commands floating around, making tests less deterministic, while the scenario is hopefully really uncommon.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365764249", "createdAt": "2020-01-13T11:51:08Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n+            rpcManager.getSyncRpcOptions());\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n+\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+         // then the value is not expired\n+         if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            return Boolean.FALSE;\n+         }\n+         return Boolean.TRUE;\n+      });\n+   }\n \n-      if (trace) {\n-         log.tracef(\"Asking all read owners %s for key: %s - for latest access time\", info.readOwners(), key);\n+   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n+      @Override\n+      protected Boolean addTargetNotFound(Address sender) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n       }\n \n-      // Need to gather last access times\n-      RetrieveLastAccessCommand rlac = cf.running().buildRetrieveLastAccessCommand(key, value, segment);\n-      rlac.setTopologyId(topology.getTopologyId());\n-\n-      // In scattered cache read owners will only contain primary\n-      return rpcManager.invokeCommand(info.readOwners(), rlac, new MaxResponseCollector<>(access),\n-            rpcManager.getSyncRpcOptions()).toCompletableFuture();\n+      @Override\n+      protected Boolean addException(Address sender, Exception exception) {\n+         if (exception instanceof CacheException) {\n+            throw (CacheException) exception;\n+         }\n+         throw new CacheException(exception);\n+      }\n    }\n \n-   static class MaxResponseCollector<T extends Comparable<T>> extends ValidResponseCollector<T> {\n-      T highest;\n-\n-      MaxResponseCollector(T highest) {\n-         this.highest = highest;\n-      }\n+   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n \n       @Override\n-      public T finish() {\n-         return highest;\n+      public Boolean finish() {\n+         // No other node was touched\n+         return Boolean.FALSE;\n       }\n \n       @Override\n-      protected T addValidResponse(Address sender, ValidResponse response) {\n-         T value = (T) response.getResponseValue();\n-         if (trace) {\n-            log.tracef(\"Received response %s from %s when requesting access time for max idle\", value, sender);\n-         }\n-         if (value != null && (highest == null || highest.compareTo(value) < 0)) {\n-            highest = value;\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.TRUE) {\n+            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n+            // TODO: what if the read was when one of the backups or primary died?\n+            return Boolean.TRUE;\n          }\n          return null;\n       }\n+   }\n \n+   private static class TouchResponseCollector extends AbstractTouchResponseCollector {\n       @Override\n-      protected T addTargetNotFound(Address sender) {\n-         // We don't care about a node leaving\n-         return null;\n+      public Boolean finish() {\n+         // If all were touched, then the value isn't expired\n+         return Boolean.TRUE;\n       }\n \n       @Override\n-      protected T addException(Address sender, Exception exception) {\n-         throw ResponseCollectors.wrapRemoteException(sender, exception);\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.FALSE) {\n+            // Return early if any value wasn't touched!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2ODI0OQ==", "bodyText": "Please add a javadoc and explain the return value.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365768249", "createdAt": "2020-01-13T12:01:58Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -1,55 +1,44 @@\n-package org.infinispan.commands.remote.expiration;\n+package org.infinispan.expiration.impl;\n \n import java.io.IOException;\n import java.io.ObjectInput;\n import java.io.ObjectOutput;\n import java.util.concurrent.CompletableFuture;\n \n import org.infinispan.commands.InitializableCommand;\n-import org.infinispan.commands.SegmentSpecificCommand;\n import org.infinispan.commands.TopologyAffectedCommand;\n import org.infinispan.commands.remote.BaseRpcCommand;\n import org.infinispan.commons.io.UnsignedNumeric;\n-import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.commons.time.TimeService;\n import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.distribution.DistributionManager;\n import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.statetransfer.OutdatedTopologyException;\n import org.infinispan.util.ByteString;\n import org.infinispan.util.concurrent.CompletableFutures;\n \n-/**\n- * Command that will update the last access time for an entry given the specific time\n- * @author wburns\n- * @since 9.3\n- */\n-public class UpdateLastAccessCommand extends BaseRpcCommand implements InitializableCommand, TopologyAffectedCommand, SegmentSpecificCommand {\n+public class TouchCommand extends BaseRpcCommand implements InitializableCommand, TopologyAffectedCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NTEwNQ==", "bodyText": "I'd expect TouchCommand and a method named touchEntry to use the same convention for the return value.\nI suggest moving thenApply(touched -> !touched) outside the method.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365775105", "createdAt": "2020-01-13T12:20:46Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -252,22 +260,36 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata) {\n             cacheNotifier.notifyCacheEntryExpired(key, value, metadata, null)));\n    }\n \n-   protected Long localLastAccess(Object key, Object value, int segment) {\n-      InternalCacheEntry ice = dataContainer.running().peek(segment, key);\n-      if (ice != null && (value == null || value.equals(ice.getValue())) &&\n-            !ice.isExpired(timeService.wallClockTime())) {\n-         return ice.getLastUsed();\n+   @Override\n+   public CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> ice, int segment, boolean isWrite) {\n+      long currentTime = timeService.wallClockTime();\n+      if (ice.isExpired(currentTime)) {\n+         if (trace) {\n+            log.tracef(\"Retrieved entry for key %s was expired locally, attempting expiration removal\", ice.getKey());\n+         }\n+         CompletableFuture<Boolean> expiredStage = entryExpiredInMemory(ice, currentTime, isWrite);\n+         if (trace) {\n+            expiredStage = expiredStage.thenApply(expired -> {\n+               if (expired == Boolean.FALSE) {\n+                  log.tracef(\"Retrieved entry for key %s was found to not be expired.\", ice.getKey());\n+               } else {\n+                  log.tracef(\"Retrieved entry for key %s was confirmed to be expired.\", ice.getKey());\n+               }\n+               return expired;\n+            });\n+         }\n+         return expiredStage;\n+      } else if (!isWrite && ice.isMaxIdleExpirable()) {\n+         return touchEntry(ice, segment);\n       }\n-      return null;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long lastAccess = localLastAccess(key, value, segment);\n-      if (lastAccess != null) {\n-         return CompletableFuture.completedFuture(lastAccess);\n-      }\n-      return CompletableFutures.completedNull();\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry entry, int segment) {\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(entry.getKey(), segment);\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Boolean> future = (CompletableFuture) touchCommand.invokeAsync();\n+      return future.thenApply(touched -> !touched);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NTIyMA==", "bodyText": "Missing javadoc", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365775220", "createdAt": "2020-01-13T12:21:01Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/InternalExpirationManager.java", "diffHunk": "@@ -73,15 +73,5 @@ default void handleInStoreExpiration(MarshallableEntry<K, V> marshalledEntry) {\n       CompletionStages.join(handleInStoreExpirationInternal(marshalledEntry));\n    }\n \n-   /**\n-    * Retrieves the last access time for the given key in the data container if it is using max idle.\n-    * If the entry is not in the container or it is expired it will return null.\n-    * If the entry is present but cannot expire via max idle, it will return -1\n-    * If the entry is present and can expire via max idle but hasn't it will return a number > 0\n-    * @param key the key to retrieve the access time for\n-    * @param value the value to match if desired (this can be null)\n-    * @param segment the segment for the given key\n-    * @return the last access time if available\n-    */\n-   CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment);\n+   CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> entry, int segment, boolean isWrite);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3NzQ5Nw==", "bodyText": "MultipleCacheManagersTest#getKeyForCache(org.infinispan.Cache<?,?>, org.infinispan.Cache<?,?>...)", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365777497", "createdAt": "2020-01-13T12:27:04Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -340,4 +341,49 @@ public void testWriteExpiredEntry() throws InterruptedException {\n          ts2.advance(secondOneMilliAdvanced);\n       }\n    }\n+\n+   public void testMaxIdleReadNodeDiesPrimary() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTA2MA==", "bodyText": "killMember(3) calls waitForNoRebalance(caches), I think you need to block the rebalance and test expiration during the rebalance as well.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365779060", "createdAt": "2020-01-13T12:30:54Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -340,4 +341,49 @@ public void testWriteExpiredEntry() throws InterruptedException {\n          ts2.advance(secondOneMilliAdvanced);\n       }\n    }\n+\n+   public void testMaxIdleReadNodeDiesPrimary() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {\n+            return new MagicKey(c);\n+         }\n+         return new MagicKey(c, cache0);\n+      });\n+   }\n+\n+   public void testMaxIdleReadNodeDiesBackup() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {\n+            return new MagicKey(cache0);\n+         }\n+         return new MagicKey(cache0, c);\n+      });\n+   }\n+\n+   private void testMaxIdleNodeDies(Function<Cache<?, ?>, MagicKey> keyToUseFunction) {\n+      addClusterEnabledCacheManager(TestDataSCI.INSTANCE, configurationBuilder);\n+      waitForClusterToForm();\n+\n+      Cache<Object, String> cache3 = cache(3);\n+\n+      ControlledTimeService ts4 = new ControlledTimeService();\n+      TestingUtil.replaceComponent(manager(3), TimeService.class, ts4, true);\n+\n+      MagicKey key = keyToUseFunction.apply(cache3);\n+\n+      // We always write to cache3 so that scattered uses it as a backup if the key isn't owned by it\n+      cache3.put(key, \"max-idle\", -1, TimeUnit.MILLISECONDS, 100, TimeUnit.MILLISECONDS);\n+\n+      long justbeforeExpiration = 99;\n+      incrementAllTimeServices(justbeforeExpiration, TimeUnit.MILLISECONDS);\n+      ts4.advance(justbeforeExpiration);\n+\n+      assertNotNull(cache3.get(key));\n+\n+      killMember(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 115}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d679ec786cf71ea2163fbd859004470d7aab136", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/6d679ec786cf71ea2163fbd859004470d7aab136", "committedDate": "2020-01-13T15:54:26Z", "message": "some rework comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/a3f4aed51defa848a5ffade45f95bda2c7fcc086", "committedDate": "2020-01-13T17:08:56Z", "message": "hibernate fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMDA2MjEw", "url": "https://github.com/infinispan/infinispan/pull/7722#pullrequestreview-342006210", "createdAt": "2020-01-13T17:19:35Z", "commit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzoxOTozNlrOFc-WsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzoxOTozNlrOFc-WsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNjA2NQ==", "bodyText": "I was thinking more along the lines of checkExpiredMaxIdle()", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365926065", "createdAt": "2020-01-13T17:19:36Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,105 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMDA5Mzkw", "url": "https://github.com/infinispan/infinispan/pull/7722#pullrequestreview-342009390", "createdAt": "2020-01-13T17:24:49Z", "commit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzoyNDo1MFrOFc-gEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo1OToyM1rOFc_hSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyODQ2Ng==", "bodyText": "extra space", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365928466", "createdAt": "2020-01-13T17:24:50Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,105 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntryAndReturnIfExpired(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouchAndReturnIfExpired(key, segment)\n+            .handle((expired, t) -> {\n+               if (t != null) {\n+                  Throwable innerT = CompletableFutures.extractException(t);\n+                  if (innerT instanceof OutdatedTopologyException) {\n+                     if (trace) {\n+                        log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                     }\n+                     return attemptTouchAndReturnIfExpired(key, segment);\n+                  }\n+                  return CompletableFutures.<Boolean>completedExceptionFuture(t);\n+               } else {\n+                  return CompletableFuture.completedFuture(expired);\n+               }\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouchAndReturnIfExpired(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n \n-      if (trace) {\n-         log.tracef(\"Asking all read owners %s for key: %s - for latest access time\", info.readOwners(), key);\n-      }\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n \n-      // Need to gather last access times\n-      RetrieveLastAccessCommand rlac = cf.running().buildRetrieveLastAccessCommand(key, value, segment);\n-      rlac.setTopologyId(topology.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = invokeTouchCommandRemotely(touchCommand, lct, segment);\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n \n-      // In scattered cache read owners will only contain primary\n-      return rpcManager.invokeCommand(info.readOwners(), rlac, new MaxResponseCollector<>(access),\n-            rpcManager.getSyncRpcOptions()).toCompletableFuture();\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            return Boolean.FALSE;\n+         }\n+         return Boolean.TRUE;\n+      });\n    }\n \n-   static class MaxResponseCollector<T extends Comparable<T>> extends ValidResponseCollector<T> {\n-      T highest;\n+   private CompletionStage<Boolean> invokeTouchCommandRemotely(TouchCommand touchCommand, LocalizedCacheTopology lct,\n+         int segment) {\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+      // Scattered any node could be a backup, so we have to touch all members\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMTk0Mg==", "bodyText": "True, you don't need two concurrent expirations to get a false, just one expiration and a regular read, but still I'm not 100% sold on having those touch commands floating around.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365931942", "createdAt": "2020-01-13T17:32:18Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -412,58 +411,96 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n    }\n \n    @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long access = localLastAccess(key, value, segment);\n+   protected CompletionStage<Boolean> touchEntry(InternalCacheEntry ice, int segment) {\n+      Object key = ice.getKey();\n+      return attemptTouch(key, segment)\n+            .thenApply((Function<Boolean, CompletionStage<Boolean>>) CompletableFuture::completedFuture)\n+            .exceptionally(t -> {\n+               if (t instanceof OutdatedTopologyException) {\n+                  if (trace) {\n+                     log.tracef(\"Touch received OutdatedTopologyException, retrying\");\n+                  }\n+                  return attemptTouch(key, segment);\n+               }\n+               return CompletableFutures.completedExceptionFuture(t);\n+            })\n+            .thenCompose(Function.identity());\n+   }\n \n-      LocalizedCacheTopology topology = distributionManager.getCacheTopology();\n-      DistributionInfo info = topology.getDistribution(key);\n+   private CompletionStage<Boolean> attemptTouch(Object key, int segment) {\n+      LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+      DistributionInfo di = lct.getSegmentDistribution(segment);\n+\n+      boolean isScattered = configuration.clustering().cacheMode().isScattered();\n+      List<Address> owners =  isScattered ? lct.getActualMembers() : di.writeOwners();\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      touchCommand.setTopologyId(lct.getTopologyId());\n+      CompletionStage<Boolean> remoteStage = rpcManager.invokeCommand(owners, touchCommand,\n+            isScattered ? new ScatteredTouchResponseCollector() : new TouchResponseCollector(),\n+            rpcManager.getSyncRpcOptions());\n+      touchCommand.init(componentRegistry, false);\n+      CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n+\n+      return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n+         // Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+         // then the value is not expired\n+         if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            return Boolean.FALSE;\n+         }\n+         return Boolean.TRUE;\n+      });\n+   }\n \n-      if (trace) {\n-         log.tracef(\"Asking all read owners %s for key: %s - for latest access time\", info.readOwners(), key);\n+   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n+      @Override\n+      protected Boolean addTargetNotFound(Address sender) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n       }\n \n-      // Need to gather last access times\n-      RetrieveLastAccessCommand rlac = cf.running().buildRetrieveLastAccessCommand(key, value, segment);\n-      rlac.setTopologyId(topology.getTopologyId());\n-\n-      // In scattered cache read owners will only contain primary\n-      return rpcManager.invokeCommand(info.readOwners(), rlac, new MaxResponseCollector<>(access),\n-            rpcManager.getSyncRpcOptions()).toCompletableFuture();\n+      @Override\n+      protected Boolean addException(Address sender, Exception exception) {\n+         if (exception instanceof CacheException) {\n+            throw (CacheException) exception;\n+         }\n+         throw new CacheException(exception);\n+      }\n    }\n \n-   static class MaxResponseCollector<T extends Comparable<T>> extends ValidResponseCollector<T> {\n-      T highest;\n-\n-      MaxResponseCollector(T highest) {\n-         this.highest = highest;\n-      }\n+   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n \n       @Override\n-      public T finish() {\n-         return highest;\n+      public Boolean finish() {\n+         // No other node was touched\n+         return Boolean.FALSE;\n       }\n \n       @Override\n-      protected T addValidResponse(Address sender, ValidResponse response) {\n-         T value = (T) response.getResponseValue();\n-         if (trace) {\n-            log.tracef(\"Received response %s from %s when requesting access time for max idle\", value, sender);\n-         }\n-         if (value != null && (highest == null || highest.compareTo(value) < 0)) {\n-            highest = value;\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.TRUE) {\n+            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n+            // TODO: what if the read was when one of the backups or primary died?\n+            return Boolean.TRUE;\n          }\n          return null;\n       }\n+   }\n \n+   private static class TouchResponseCollector extends AbstractTouchResponseCollector {\n       @Override\n-      protected T addTargetNotFound(Address sender) {\n-         // We don't care about a node leaving\n-         return null;\n+      public Boolean finish() {\n+         // If all were touched, then the value isn't expired\n+         return Boolean.TRUE;\n       }\n \n       @Override\n-      protected T addException(Address sender, Exception exception) {\n-         throw ResponseCollectors.wrapRemoteException(sender, exception);\n+      protected Boolean addValidResponse(Address sender, ValidResponse response) {\n+         Boolean touched = (Boolean) response.getResponseValue();\n+         if (touched == Boolean.FALSE) {\n+            // Return early if any value wasn't touched!", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDI0OQ=="}, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMzE3NA==", "bodyText": "Empty tags", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365933174", "createdAt": "2020-01-13T17:34:58Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -252,22 +260,44 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata) {\n             cacheNotifier.notifyCacheEntryExpired(key, value, metadata, null)));\n    }\n \n-   protected Long localLastAccess(Object key, Object value, int segment) {\n-      InternalCacheEntry ice = dataContainer.running().peek(segment, key);\n-      if (ice != null && (value == null || value.equals(ice.getValue())) &&\n-            !ice.isExpired(timeService.wallClockTime())) {\n-         return ice.getLastUsed();\n+   @Override\n+   public CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> ice, int segment, boolean isWrite) {\n+      long currentTime = timeService.wallClockTime();\n+      if (ice.isExpired(currentTime)) {\n+         if (trace) {\n+            log.tracef(\"Retrieved entry for key %s was expired locally, attempting expiration removal\", ice.getKey());\n+         }\n+         CompletableFuture<Boolean> expiredStage = entryExpiredInMemory(ice, currentTime, isWrite);\n+         if (trace) {\n+            expiredStage = expiredStage.thenApply(expired -> {\n+               if (expired == Boolean.FALSE) {\n+                  log.tracef(\"Retrieved entry for key %s was found to not be expired.\", ice.getKey());\n+               } else {\n+                  log.tracef(\"Retrieved entry for key %s was confirmed to be expired.\", ice.getKey());\n+               }\n+               return expired;\n+            });\n+         }\n+         return expiredStage;\n+      } else if (!isWrite && ice.canExpireMaxIdle()) {\n+         return touchEntryAndReturnIfExpired(ice, segment);\n       }\n-      return null;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long lastAccess = localLastAccess(key, value, segment);\n-      if (lastAccess != null) {\n-         return CompletableFuture.completedFuture(lastAccess);\n-      }\n-      return CompletableFutures.completedNull();\n+   /**\n+    * Response is whether the value should be treated as expired - thus if both local and remote were able to touch\n+    * then the value is not expired. Note this is different then the touch command's response normally as that mentions\n+    * if it was touched or not\n+    * @param entry\n+    * @param segment\n+    * @return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMzU3MQ==", "bodyText": "IMO we shouldn't mention remote invocations here, just the first part, since ExpirationManagerImpl doesn't go remotely.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365933571", "createdAt": "2020-01-13T17:35:43Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -252,22 +260,44 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata) {\n             cacheNotifier.notifyCacheEntryExpired(key, value, metadata, null)));\n    }\n \n-   protected Long localLastAccess(Object key, Object value, int segment) {\n-      InternalCacheEntry ice = dataContainer.running().peek(segment, key);\n-      if (ice != null && (value == null || value.equals(ice.getValue())) &&\n-            !ice.isExpired(timeService.wallClockTime())) {\n-         return ice.getLastUsed();\n+   @Override\n+   public CompletionStage<Boolean> handlePossibleExpiration(InternalCacheEntry<K, V> ice, int segment, boolean isWrite) {\n+      long currentTime = timeService.wallClockTime();\n+      if (ice.isExpired(currentTime)) {\n+         if (trace) {\n+            log.tracef(\"Retrieved entry for key %s was expired locally, attempting expiration removal\", ice.getKey());\n+         }\n+         CompletableFuture<Boolean> expiredStage = entryExpiredInMemory(ice, currentTime, isWrite);\n+         if (trace) {\n+            expiredStage = expiredStage.thenApply(expired -> {\n+               if (expired == Boolean.FALSE) {\n+                  log.tracef(\"Retrieved entry for key %s was found to not be expired.\", ice.getKey());\n+               } else {\n+                  log.tracef(\"Retrieved entry for key %s was confirmed to be expired.\", ice.getKey());\n+               }\n+               return expired;\n+            });\n+         }\n+         return expiredStage;\n+      } else if (!isWrite && ice.canExpireMaxIdle()) {\n+         return touchEntryAndReturnIfExpired(ice, segment);\n       }\n-      return null;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   @Override\n-   public CompletableFuture<Long> retrieveLastAccess(Object key, Object value, int segment) {\n-      Long lastAccess = localLastAccess(key, value, segment);\n-      if (lastAccess != null) {\n-         return CompletableFuture.completedFuture(lastAccess);\n-      }\n-      return CompletableFutures.completedNull();\n+   /**\n+    * Response is whether the value should be treated as expired - thus if both local and remote were able to touch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNTUxNQ==", "bodyText": "I prefer saying a stage that will complete with {@code true} if the entry was expired and {@code false} otherwise.\nAlso duplicated in the main comment (The return stage will contain whether the entry was actually expired or not)", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365935515", "createdAt": "2020-01-13T17:39:47Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/InternalExpirationManager.java", "diffHunk": "@@ -74,14 +74,12 @@ default void handleInStoreExpiration(MarshallableEntry<K, V> marshalledEntry) {\n    }\n \n    /**\n-    * Retrieves the last access time for the given key in the data container if it is using max idle.\n-    * If the entry is not in the container or it is expired it will return null.\n-    * If the entry is present but cannot expire via max idle, it will return -1\n-    * If the entry is present and can expire via max idle but hasn't it will return a number > 0\n-    * @param key the key to retrieve the access time for\n-    * @param value the value to match if desired (this can be null)\n-    * @param segment the segment for the given key\n-    * @return the last access time if available\n+    * Handles processing for an entry that may be expired. This will remove the entry if it is expired, otherwise may\n+    * touch if it uses max idle. The return stage will contain whether the entry was actually expired or not\n+    * @param entry entry that may be expired\n+    * @param segment the segment of the entry\n+    * @param isWrite whether the command that saw the expired value was a write or not\n+    * @return a stage that when complete will return if the entry was expired", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNzI0NA==", "bodyText": "can suggests to me that it is parametrized and can do each independently. I'd rather say\nThis command updates a cache entry's last access timestamp. If eviction is enabled, it will also update the recency information.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365937244", "createdAt": "2020-01-13T17:43:23Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.expiration.impl;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.infinispan.commands.InitializableCommand;\n+import org.infinispan.commands.TopologyAffectedCommand;\n+import org.infinispan.commands.remote.BaseRpcCommand;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.distribution.DistributionInfo;\n+import org.infinispan.distribution.DistributionManager;\n+import org.infinispan.distribution.LocalizedCacheTopology;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.statetransfer.OutdatedTopologyException;\n+import org.infinispan.util.ByteString;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+/**\n+ * This command can be invoked to update a cache entry's recent access. This can involve updating its last access", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNzk1OQ==", "bodyText": "I think you can answer the question now :)", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365937959", "createdAt": "2020-01-13T17:44:50Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.expiration.impl;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.infinispan.commands.InitializableCommand;\n+import org.infinispan.commands.TopologyAffectedCommand;\n+import org.infinispan.commands.remote.BaseRpcCommand;\n+import org.infinispan.commons.io.UnsignedNumeric;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.distribution.DistributionInfo;\n+import org.infinispan.distribution.DistributionManager;\n+import org.infinispan.distribution.LocalizedCacheTopology;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.statetransfer.OutdatedTopologyException;\n+import org.infinispan.util.ByteString;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+/**\n+ * This command can be invoked to update a cache entry's recent access. This can involve updating its last access\n+ * with max idle as well as recent eviction access times.\n+ * <p>\n+ * This command returns a Boolean that is whether this command was able to touch the value or not.\n+ */\n+public class TouchCommand extends BaseRpcCommand implements InitializableCommand, TopologyAffectedCommand {\n+   public static final byte COMMAND_ID = 66;\n+\n+   private Object key;\n+   private int segment;\n+   private int topologyId = -1;\n+\n+   private InternalDataContainer internalDataContainer;\n+   private TimeService timeService;\n+   private DistributionManager distributionManager;\n+\n+   // Only here for CommandIdUniquenessTest\n+   private TouchCommand() { super(null); }\n+\n+   public TouchCommand(ByteString cacheName) {\n+      super(cacheName);\n+   }\n+\n+   public TouchCommand(ByteString cacheName, Object key, int segment) {\n+      super(cacheName);\n+      this.key = key;\n+      this.segment = segment;\n+   }\n+\n+   @Override\n+   public byte getCommandId() {\n+      return COMMAND_ID;\n+   }\n+\n+   @Override\n+   public boolean isReturnValueExpected() {\n+      return true;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      output.writeObject(key);\n+      UnsignedNumeric.writeUnsignedInt(output, segment);\n+   }\n+\n+   @Override\n+   public void readFrom(ObjectInput input) throws IOException, ClassNotFoundException {\n+      key = input.readObject();\n+      segment = UnsignedNumeric.readUnsignedInt(input);\n+   }\n+\n+   @Override\n+   public void init(ComponentRegistry componentRegistry, boolean isRemote) {\n+      internalDataContainer = componentRegistry.getInternalDataContainer().running();\n+      timeService = componentRegistry.getTimeService();\n+      // Invalidation cache doesn't set topology id - so we don't want to throw OTE in invokeAsync\n+      if (!componentRegistry.getConfiguration().clustering().cacheMode().isInvalidation()) {\n+         distributionManager = componentRegistry.getDistributionManager();\n+      }\n+   }\n+\n+   @Override\n+   public int getTopologyId() {\n+      return topologyId;\n+   }\n+\n+   @Override\n+   public void setTopologyId(int topologyId) {\n+      this.topologyId = topologyId;\n+   }\n+\n+   @Override\n+   public CompletableFuture<Object> invokeAsync() {\n+      boolean touched = internalDataContainer.touch(segment, key, timeService.wallClockTime());\n+      // Hibernate currently disables clustered expiration manager, which means we can have a topology id of -1\n+      // when using a clustered cache mode\n+      if (distributionManager != null && topologyId != -1) {\n+         LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n+         int currentTopologyId = lct.getTopologyId();\n+         if (currentTopologyId != topologyId) {\n+            return CompletableFutures.completedExceptionFuture(OutdatedTopologyException.RETRY_NEXT_TOPOLOGY);\n+         }\n+         DistributionInfo di = lct.getSegmentDistribution(segment);\n+         // If our node is a write owner but not read owner, that means we may not have the value yet - so we just\n+         // say we were touched anyways\n+         // TODO: is this is an issue with concurrent state response and not touching the new value?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NTE2MA==", "bodyText": "There are many tests that block a rebalance, in different ways, depending on the scenario they want to test.\nSome block the StateResponseCommand so that the they block the insertion of particular keys. Some only block the CacheTopologyControlCommand(REBALANCE_PHASE_CONFIRM) commands so the cache stays in a particular topology phase (usually READ_OLD_WRITE_ALL) after state transfer has finished.\nSome block the sender side, with ControlledRpcManager or ControlledTransport. Some block the receiver side, with many impls of InboundInvocationHandler, PerCacheInboundInvocationHandler, LocalTopologyManagerImpl, StateProviderImpl, or StateConsumerImpl.", "url": "https://github.com/infinispan/infinispan/pull/7722#discussion_r365945160", "createdAt": "2020-01-13T17:59:23Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -340,4 +341,49 @@ public void testWriteExpiredEntry() throws InterruptedException {\n          ts2.advance(secondOneMilliAdvanced);\n       }\n    }\n+\n+   public void testMaxIdleReadNodeDiesPrimary() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {\n+            return new MagicKey(c);\n+         }\n+         return new MagicKey(c, cache0);\n+      });\n+   }\n+\n+   public void testMaxIdleReadNodeDiesBackup() {\n+      testMaxIdleNodeDies(c -> {\n+         if (cacheMode.isScattered()) {\n+            return new MagicKey(cache0);\n+         }\n+         return new MagicKey(cache0, c);\n+      });\n+   }\n+\n+   private void testMaxIdleNodeDies(Function<Cache<?, ?>, MagicKey> keyToUseFunction) {\n+      addClusterEnabledCacheManager(TestDataSCI.INSTANCE, configurationBuilder);\n+      waitForClusterToForm();\n+\n+      Cache<Object, String> cache3 = cache(3);\n+\n+      ControlledTimeService ts4 = new ControlledTimeService();\n+      TestingUtil.replaceComponent(manager(3), TimeService.class, ts4, true);\n+\n+      MagicKey key = keyToUseFunction.apply(cache3);\n+\n+      // We always write to cache3 so that scattered uses it as a backup if the key isn't owned by it\n+      cache3.put(key, \"max-idle\", -1, TimeUnit.MILLISECONDS, 100, TimeUnit.MILLISECONDS);\n+\n+      long justbeforeExpiration = 99;\n+      incrementAllTimeServices(justbeforeExpiration, TimeUnit.MILLISECONDS);\n+      ts4.advance(justbeforeExpiration);\n+\n+      assertNotNull(cache3.get(key));\n+\n+      killMember(3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc3OTA2MA=="}, "originalCommit": {"oid": "59b1abc3f530e038139b47a0889f3a373d756dbf"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNjczMjQ3", "url": "https://github.com/infinispan/infinispan/pull/7722#pullrequestreview-342673247", "createdAt": "2020-01-14T16:37:00Z", "commit": {"oid": "a3f4aed51defa848a5ffade45f95bda2c7fcc086"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1434, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}