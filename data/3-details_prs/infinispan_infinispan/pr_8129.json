{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2MjIyNTQ4", "number": 8129, "title": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY", "bodyText": "https://issues.redhat.com/browse/ISPN-11478\nDepends on #8029", "createdAt": "2020-03-31T10:14:13Z", "url": "https://github.com/infinispan/infinispan/pull/8129", "merged": true, "mergeCommit": {"oid": "ecb0ff73fbc8df9898c96a79c4c300d44c239c0c"}, "closed": true, "closedAt": "2020-04-09T11:33:33Z", "author": {"login": "gustavonalle"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTAWd5gBqjMxODI1Njk2NDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcV4oE6gBqjMyMTc0MDUwOTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7f4f49c16bcd41c9855c0ecb1383a44b43b06b4c", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/7f4f49c16bcd41c9855c0ecb1383a44b43b06b4c", "committedDate": "2020-03-31T10:09:04Z", "message": "aaaaa"}, "afterCommit": {"oid": "3321164f16317c08f7404514fd20fa5b52d3e164", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/3321164f16317c08f7404514fd20fa5b52d3e164", "committedDate": "2020-03-31T10:14:42Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3321164f16317c08f7404514fd20fa5b52d3e164", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/3321164f16317c08f7404514fd20fa5b52d3e164", "committedDate": "2020-03-31T10:14:42Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/5781343b1f04b53900c78da8caba1bf452374b86", "committedDate": "2020-04-01T08:25:42Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1Mzc2MjY0", "url": "https://github.com/infinispan/infinispan/pull/8129#pullrequestreview-385376264", "createdAt": "2020-04-01T08:39:48Z", "commit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwODozOTo0OFrOF-2dGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwOToyNjo0OFrOF-4M1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0ODIxOA==", "bodyText": "If/Else to avoid unnecessary assignment?", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401448218", "createdAt": "2020-04-01T08:39:48Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -400,9 +400,16 @@ V mergeInternal(K key, V value, BiFunction<? super V, ? super V, ? extends V> re\n       assertKeyNotNull(key);\n       assertValueNotNull(value);\n       assertFunctionNotNull(remappingFunction);\n+      DataConversion keyDataConversion = getKeyDataConversion();\n+      DataConversion valueDataConversion = getValueDataConversion();\n+      if (remappingFunction instanceof BiFunctionMapper) {\n+         BiFunctionMapper biFunctionMapper = (BiFunctionMapper) remappingFunction;\n+         keyDataConversion = biFunctionMapper.getKeyDataConversion();\n+         valueDataConversion = biFunctionMapper.getValueDataConversion();\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MTYzMg==", "bodyText": "Redundant comment", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401451632", "createdAt": "2020-04-01T08:45:38Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java", "diffHunk": "@@ -32,12 +33,26 @@ public V apply(EntryView.ReadWriteEntryView<K, V> entry) {\n       try {\n          V merged = value;\n          if (entry.find().isPresent()) {\n-            merged = remappingFunction.apply(entry.get(), value);\n+            V t = entry.get();\n+            if (remappingFunction instanceof BiFunctionMapper) {\n+               BiFunctionMapper mapper = (BiFunctionMapper) this.remappingFunction;\n+               Object toStorage = mapper.getValueDataConversion().toStorage(t);\n+               merged = remappingFunction.apply((V) toStorage, value);\n+//               merged = remappingFunction.apply((V)fromStorage, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MjM4MA==", "bodyText": "else if?", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401452380", "createdAt": "2020-04-01T08:46:51Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/functional/functions/MergeFunction.java", "diffHunk": "@@ -32,12 +33,26 @@ public V apply(EntryView.ReadWriteEntryView<K, V> entry) {\n       try {\n          V merged = value;\n          if (entry.find().isPresent()) {\n-            merged = remappingFunction.apply(entry.get(), value);\n+            V t = entry.get();\n+            if (remappingFunction instanceof BiFunctionMapper) {\n+               BiFunctionMapper mapper = (BiFunctionMapper) this.remappingFunction;\n+               Object toStorage = mapper.getValueDataConversion().toStorage(t);\n+               merged = remappingFunction.apply((V) toStorage, value);\n+//               merged = remappingFunction.apply((V)fromStorage, value);\n+            } else {\n+               merged = remappingFunction.apply(t, value);\n+            }\n          }\n          if (merged == null) {\n             entry.set(merged);\n          } else {\n-            entry.set(merged, metadata);\n+            if (remappingFunction instanceof BiFunctionMapper) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MzAxNQ==", "bodyText": "Method is never used.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401453015", "createdAt": "2020-04-01T08:47:53Z", "author": {"login": "ryanemerson"}, "path": "commons/all/src/main/java/org/infinispan/commons/dataconversion/MediaType.java", "diffHunk": "@@ -245,6 +245,12 @@ public boolean hasStringType() {\n       return classType != null && classType.equals(String.class.getName());\n    }\n \n+   public boolean isBinary() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1NDUyNQ==", "bodyText": "We should remove org.infinispan.server.core.dataconversion.ProtostreamTranscoder and update it's usage to this class.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401454525", "createdAt": "2020-04-01T08:50:14Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package org.infinispan.encoding;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OBJECT;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OCTET_STREAM;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_PROTOSTREAM;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_UNKNOWN;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN;\n+import static org.infinispan.commons.dataconversion.StandardConversions.convertTextToObject;\n+import static org.infinispan.commons.dataconversion.StandardConversions.decodeOctetStream;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Optional;\n+\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.dataconversion.OneToManyTranscoder;\n+import org.infinispan.commons.dataconversion.StandardConversions;\n+import org.infinispan.commons.marshall.WrappedByteArray;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.ProtobufUtil;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Transcode between application/x-protostream and commons formats\n+ *\n+ * @since 10.0\n+ */\n+public class ProtostreamTranscoder extends OneToManyTranscoder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1NTA0OQ==", "bodyText": "It would nice to keep these inline as @Inject @ComponentName to be consistent with other classes.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401455049", "createdAt": "2020-04-01T08:51:11Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java", "diffHunk": "@@ -29,26 +32,35 @@\n @DefaultFactoryFor(classes = {EncoderRegistry.class})\n public class EncoderRegistryFactory extends AbstractComponentFactory implements AutoInstantiableFactory {\n    // Must not start the global marshaller or it will be too late for modules to register their externalizers\n-   @Inject @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)\n+   @Inject\n+   @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2MDQ5NA==", "bodyText": "This registration ultimately has been moved to the Refactored GlobalMarshaller on my branch ... can you add a comment so I don't forget to remove it here:\n// TODO Move registration to GlobalMarshaller ISPN-9622", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401460494", "createdAt": "2020-04-01T08:59:59Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/factories/EncoderRegistryFactory.java", "diffHunk": "@@ -29,26 +32,35 @@\n @DefaultFactoryFor(classes = {EncoderRegistry.class})\n public class EncoderRegistryFactory extends AbstractComponentFactory implements AutoInstantiableFactory {\n    // Must not start the global marshaller or it will be too late for modules to register their externalizers\n-   @Inject @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)\n+   @Inject\n+   @ComponentName(KnownComponentNames.INTERNAL_MARSHALLER)\n    ComponentRef<StreamingMarshaller> globalMarshaller;\n-   @Inject @ComponentName(KnownComponentNames.PERSISTENCE_MARSHALLER)\n+   @Inject\n+   @ComponentName(KnownComponentNames.PERSISTENCE_MARSHALLER)\n    PersistenceMarshaller persistenceMarshaller;\n-   @Inject EmbeddedCacheManager embeddedCacheManager;\n+   @Inject\n+   EmbeddedCacheManager embeddedCacheManager;\n+\n+   @Inject\n+   SerializationContextRegistry ctxRegistry;\n \n    @Override\n    public Object construct(String componentName) {\n+      ClassLoader classLoader = globalConfiguration.classLoader();\n       EncoderRegistryImpl encoderRegistry = new EncoderRegistryImpl();\n       ClassWhiteList classWhiteList = embeddedCacheManager.getClassWhiteList();\n+      String messageName = PersistenceContextInitializer.getFqTypeName(MarshallableUserObject.class);\n+      ctxRegistry.addMarshaller(SerializationContextRegistry.MarshallerType.GLOBAL, new MarshallableUserObject.Marshaller(messageName, persistenceMarshaller.getUserMarshaller()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2Mzk5Mw==", "bodyText": "I think you can re-use CountMarshallingPojo here and just configure the org.infinispan.test.TestDataSCI", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401463993", "createdAt": "2020-04-01T09:05:57Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java", "diffHunk": "@@ -67,12 +70,68 @@ public void testEvictPrimitiveKeyCustomValue() {\n             expectedReads++; // unmarshall old value if overwritten\n          expectedWrites++; // just the value\n       }\n-      assertEquals(expectedWrites, EvictionPojo.Externalizer.writes.get());\n-      assertEquals(expectedReads, EvictionPojo.Externalizer.reads.get());\n+      assertEquals(expectedWrites, EvictionPojoMarshaller.writes.get());\n+      assertEquals(expectedReads, EvictionPojoMarshaller.reads.get());\n+   }\n+\n+   static class EvictionPojoMarshaller implements org.infinispan.protostream.MessageMarshaller<EvictionPojo> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzAwNA==", "bodyText": "This made me think of ProtoStream support and then I saw that you created https://issues.redhat.com/browse/IPROTO-134 \ud83d\ude42", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401467004", "createdAt": "2020-04-01T09:11:00Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/eviction/impl/protostream/PrimitiveArrayCtx.java", "diffHunk": "@@ -0,0 +1,222 @@\n+package org.infinispan.eviction.impl.protostream;\n+\n+import static org.infinispan.protostream.FileDescriptorSource.fromString;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.protostream.MessageMarshaller;\n+import org.infinispan.protostream.SerializationContext;\n+import org.infinispan.protostream.SerializationContextInitializer;\n+\n+/**\n+ * Adds support for primitive and primitive wrapper arrays.\n+ */\n+public class PrimitiveArrayCtx implements SerializationContextInitializer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzkxNg==", "bodyText": "Why do we now get an IllegalArgumentException? I must have missed this change.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401467916", "createdAt": "2020-04-01T09:12:31Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/marshall/MarshalledValueSingleNodeTest.java", "diffHunk": "@@ -20,12 +19,12 @@ protected EmbeddedCacheManager createCacheManager() throws Exception {\n       return cm;\n    }\n \n-   @Test(expectedExceptions = MarshallingException.class)\n+   @Test(expectedExceptions = IllegalArgumentException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2ODg2Ng==", "bodyText": "Why add the extra variable?", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401468866", "createdAt": "2020-04-01T09:14:08Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/marshall/core/StoreAsBinaryTest.java", "diffHunk": "@@ -412,7 +411,8 @@ public void testEntrySetValueFromEntryCollections() {\n       m.put(key3, value3);\n       cache(0, \"replSync\").putAll(m);\n \n-      Set<Map.Entry<Object, Object>> entries = cache(0, \"replSync\").entrySet();\n+      Cache<Object, Object> replSync = cache(0, \"replSync\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3NTc3NQ==", "bodyText": "Nitpick, could you split the array over multiple lines like in the other @AutoProtoSchemaBuilder", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401475775", "createdAt": "2020-04-01T09:25:16Z", "author": {"login": "ryanemerson"}, "path": "multimap/src/test/java/org/infinispan/multimap/impl/MultimapSCI.java", "diffHunk": "@@ -3,10 +3,11 @@\n import org.infinispan.protostream.SerializationContextInitializer;\n import org.infinispan.protostream.annotations.AutoProtoSchemaBuilder;\n import org.infinispan.test.TestDataSCI;\n+import org.infinispan.test.data.Person;\n \n @AutoProtoSchemaBuilder(\n       dependsOn = TestDataSCI.class,\n-      includeClasses = SuperPerson.class,\n+      includeClasses = {Person.class, SuperPerson.class},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3NjgyMA==", "bodyText": "Is this for this PR?", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r401476820", "createdAt": "2020-04-01T09:26:48Z", "author": {"login": "ryanemerson"}, "path": "query/src/main/java/org/infinispan/query/impl/massindex/IndexWorker.java", "diffHunk": "@@ -67,42 +61,38 @@\n \n    @Override\n    public Void apply(EmbeddedCacheManager embeddedCacheManager) {\n-      Cache<Object, Object> cache = embeddedCacheManager.getCache(cacheName).getAdvancedCache().withStorageMediaType();\n-      AdvancedCache<Object, Object> unwrapped = SecurityActions.getUnwrappedCache(cache).getAdvancedCache();\n-      StorageType storageType = unwrapped.getCacheConfiguration().memory().storageType();\n-      if (storageType == StorageType.OBJECT) {\n-         cache = unwrapped.withWrapping(ByteArrayWrapper.class, IdentityWrapper.class);\n-      } else {\n-         cache = cache;  //todo [anistor] why not `unwrapped` instead ? do we need security for mass indexing ?\n-      }\n+      AdvancedCache<Object, Object> cache = SecurityActions.getUnwrappedCache(embeddedCacheManager.getCache(cacheName)).getAdvancedCache();\n+      DataConversion valueDataConversion = cache.getValueDataConversion();\n+      Wrapper valueWrapper = valueDataConversion.getWrapper();\n+      boolean valueFilterable = valueWrapper.isFilterable();\n \n-      SearchIntegrator searchIntegrator = ComponentRegistryUtils.getSearchIntegrator(unwrapped);\n-      KeyTransformationHandler keyTransformationHandler = ComponentRegistryUtils.getKeyTransformationHandler(unwrapped);\n-      TimeService timeService = ComponentRegistryUtils.getTimeService(unwrapped);\n+      AdvancedCache<Object, Object> reindexCache = valueFilterable ? cache.withStorageMediaType() : cache;\n+\n+      SearchIntegrator searchIntegrator = ComponentRegistryUtils.getSearchIntegrator(cache);\n+      KeyTransformationHandler keyTransformationHandler = ComponentRegistryUtils.getKeyTransformationHandler(cache);\n+      TimeService timeService = ComponentRegistryUtils.getTimeService(cache);\n \n       IndexUpdater indexUpdater = new IndexUpdater(searchIntegrator, keyTransformationHandler, timeService);\n-      ClusteringDependentLogic clusteringDependentLogic = SecurityActions.getClusteringDependentLogic(unwrapped);\n+      ClusteringDependentLogic clusteringDependentLogic = SecurityActions.getClusteringDependentLogic(cache);\n       KeyPartitioner keyPartitioner = ComponentRegistryUtils.getKeyPartitioner(cache);\n \n-      DataConversion keyDataConversion = unwrapped.getKeyDataConversion();\n-      DataConversion valueDataConversion = unwrapped.getValueDataConversion();\n-\n       if (keys == null || keys.size() == 0) {\n          preIndex(indexUpdater);\n          if (!skipIndex) {\n-            KeyValueFilter filter = getFilter(clusteringDependentLogic, keyDataConversion);\n-            try (Stream<CacheEntry<Object, Object>> stream = cache.getAdvancedCache().withFlags(Flag.CACHE_MODE_LOCAL)\n+            KeyValueFilter filter = getFilter(clusteringDependentLogic, reindexCache.getKeyDataConversion());\n+            try (Stream<CacheEntry<Object, Object>> stream = reindexCache.getAdvancedCache().withFlags(Flag.CACHE_MODE_LOCAL)\n                   .cacheEntrySet().stream()) {\n                Iterator<CacheEntry<Object, Object>> iterator = stream.filter(CacheFilters.predicate(filter)).iterator();\n-               Wrapper wrapper = unwrapped.getValueDataConversion().getWrapper();\n                while (iterator.hasNext()) {\n                   CacheEntry<Object, Object> next = iterator.next();\n-                  Object value = extractValue(next.getValue(), valueDataConversion);\n-                  Object storedKey = keyDataConversion.toStorage(next.getKey());\n-                  int segment = keyPartitioner.getSegment(storedKey);\n-                  if (value instanceof byte[] && storageType != OBJECT) {\n-                     value = wrapper.wrap(value);\n+                  Object key = next.getKey();\n+                  Object storedKey = reindexCache.getKeyDataConversion().toStorage(key);\n+                  Object value = next.getValue();\n+                  // TODO: Way to grab a cache without unwrapping? cache.withStoreMediaType(boolean unwrap)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 76}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/5781343b1f04b53900c78da8caba1bf452374b86", "committedDate": "2020-04-01T08:25:42Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "1b4b413869c7311ed37698c92bea52da19475315", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/1b4b413869c7311ed37698c92bea52da19475315", "committedDate": "2020-04-02T13:11:41Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NDE1MDY3", "url": "https://github.com/infinispan/infinispan/pull/8129#pullrequestreview-386415067", "createdAt": "2020-04-02T13:17:52Z", "commit": {"oid": "1b4b413869c7311ed37698c92bea52da19475315"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMzoxNzo1MlrOF_qulg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMzoxNzo1MlrOF_qulg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMwNDY2Mg==", "bodyText": "We should move this and ProtoStreamTextTranscoderTest.java to core as well.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402304662", "createdAt": "2020-04-02T13:17:52Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/test/java/org/infinispan/server/core/dataconversion/ProtostreamJsonTranscoderTest.java", "diffHunk": "@@ -6,6 +6,7 @@\n import java.nio.charset.StandardCharsets;\n \n import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.encoding.ProtostreamTranscoder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b4b413869c7311ed37698c92bea52da19475315"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1b4b413869c7311ed37698c92bea52da19475315", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/1b4b413869c7311ed37698c92bea52da19475315", "committedDate": "2020-04-02T13:11:41Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "committedDate": "2020-04-02T14:17:21Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NzczOTkx", "url": "https://github.com/infinispan/infinispan/pull/8129#pullrequestreview-386773991", "createdAt": "2020-04-02T20:59:47Z", "commit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMDo1OTo0N1rOF_8bwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTozMjozOVrOGAN1Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjU5NDc1NA==", "bodyText": "Shouldn't it be in another PR then?", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402594754", "createdAt": "2020-04-02T20:59:47Z", "author": {"login": "danberindei"}, "path": "commons/all/src/main/java/org/infinispan/commons/dataconversion/MediaType.java", "diffHunk": "@@ -245,6 +245,12 @@ public boolean hasStringType() {\n       return classType != null && classType.equals(String.class.getName());\n    }\n \n+   public boolean isBinary() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ1MzAxNQ=="}, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc3Mjk3NQ==", "bodyText": "What about compute, computeIfPresent, and computeIfAbsent?", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402772975", "createdAt": "2020-04-03T06:58:48Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -400,9 +400,16 @@ V mergeInternal(K key, V value, BiFunction<? super V, ? super V, ? extends V> re\n       assertKeyNotNull(key);\n       assertValueNotNull(value);\n       assertFunctionNotNull(remappingFunction);\n+      DataConversion keyDataConversion = getKeyDataConversion();\n+      DataConversion valueDataConversion = getValueDataConversion();\n+      if (remappingFunction instanceof BiFunctionMapper) {\n+         BiFunctionMapper biFunctionMapper = (BiFunctionMapper) remappingFunction;\n+         keyDataConversion = biFunctionMapper.getKeyDataConversion();\n+         valueDataConversion = biFunctionMapper.getValueDataConversion();\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0ODIxOA=="}, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDc2OQ==", "bodyText": "Is this is needed at all? All the constructors already have a storageMediaType parameter.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402804769", "createdAt": "2020-04-03T07:58:56Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -166,28 +173,17 @@ public void injectDependencies(@ComponentName(KnownComponentNames.CACHE_NAME) St\n       }\n       boolean internalCache = icr.isInternalCache(cacheName);\n       boolean embeddedMode = Configurations.isEmbeddedMode(gcr);\n-      this.storageMediaType = getStorageMediaType(configuration, embeddedMode, internalCache);\n+      this.storageMediaType = getStorageMediaType(configuration, embeddedMode, internalCache, persistenceMarshaller);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNzcxMQ==", "bodyText": "IMO if the cache has a user marshaller and the storage type is not OBJECT, then the cache should already be initialized with the user marshaller's media type as the storage type, we shouldn't do this check only when the DataConversion is shipped to another node and has its dependencies injected.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402807711", "createdAt": "2020-04-03T08:02:25Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -120,9 +120,12 @@ public void overrideWrapper(Class<? extends Wrapper> newWrapper, ComponentRegist\n    /**\n     * Obtain the configured {@link MediaType} for this instance, or assume sensible defaults.\n     */\n-   private MediaType getStorageMediaType(Configuration configuration, boolean embeddedMode, boolean internalCache) {\n+   private MediaType getStorageMediaType(Configuration configuration, boolean embeddedMode, boolean internalCache, PersistenceMarshaller persistenceMarshaller) {\n       EncodingConfiguration encodingConfiguration = configuration.encoding();\n       ContentTypeConfiguration contentTypeConfiguration = isKey ? encodingConfiguration.keyDataType() : encodingConfiguration.valueDataType();\n+      Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+      MediaType mediaType = userMarshaller.mediaType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMTAzNQ==", "bodyText": "Missing whitespace", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402811035", "createdAt": "2020-04-03T08:06:17Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -131,8 +134,11 @@ private MediaType getStorageMediaType(Configuration configuration, boolean embed\n       if (!embeddedMode && configuration.indexing().enabled() && contentTypeConfiguration.mediaType() == null) {\n          return MediaType.APPLICATION_PROTOSTREAM;\n       }\n+      if(internalCache) return MediaType.APPLICATION_OBJECT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMzgwOQ==", "bodyText": "There seems to be a disconnect between marshall and unmarshall... marshall decides whether to wrap the byte array (whatever that means) based on the wrapped parameter, while unmarshall decides whether the byte array is wrapped or not based on the type parameter. At the very least this deserves a comment to explain the difference. /cc @ryanemerson", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402813809", "createdAt": "2020-04-03T08:09:22Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java", "diffHunk": "@@ -113,19 +114,27 @@ public Object transcode(Object content, MediaType contentType, MediaType destina\n    }\n \n    private byte[] marshall(Object decoded, MediaType destinationType) throws IOException {\n-      Optional<String> wrappedParam = destinationType.getParameter(\"wrapped\");\n-      if (!wrappedParam.isPresent() || !wrappedParam.get().equals(\"false\"))\n-         return ProtobufUtil.toWrappedByteArray(ctx(), decoded);\n-      return ProtobufUtil.toByteArray(ctx(), decoded);\n+      try {\n+         Optional<String> wrappedParam = destinationType.getParameter(\"wrapped\");\n+         if (!wrappedParam.isPresent() || !wrappedParam.get().equals(\"false\"))\n+            return ProtobufUtil.toWrappedByteArray(ctx(), decoded);\n+         return ProtobufUtil.toByteArray(ctx(), decoded);\n+      } catch (IllegalArgumentException iae) {\n+         throw new MarshallingException(iae.getMessage());\n+      }\n    }\n \n    private Object unmarshall(byte[] bytes, MediaType destinationType) throws IOException {\n-      String type = destinationType.getClassType();\n-      if (type == null) {\n-         return ProtobufUtil.fromWrappedByteArray(ctx(), bytes);\n+      try {\n+         String type = destinationType.getClassType();\n+         if (type == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNjY4MQ==", "bodyText": "What storage type does the cache injected in components have, if not the storage media type?", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402816681", "createdAt": "2020-04-03T08:12:38Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/interceptors/distribution/DistributionBulkInterceptor.java", "diffHunk": "@@ -70,7 +70,7 @@ public Object visitEntrySetCommand(InvocationContext ctx, EntrySetCommand comman\n       protected final FlagAffectedCommand command;\n \n       private BackingEntrySet(Cache cache, CacheSet<CacheEntry<K, V>> entrySet, FlagAffectedCommand command) {\n-         super(cache);\n+         super(cache.getAdvancedCache().withStorageMediaType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0NTkyOA==", "bodyText": "A method would be clearer IMO", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402845928", "createdAt": "2020-04-03T08:46:28Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/dataconversion/DataConversionTest.java", "diffHunk": "@@ -65,11 +66,12 @@ public void testReadUnencoded() {\n       withCacheManager(new CacheManagerCallable(\n             createCacheManager(TestDataSCI.INSTANCE, cfg)) {\n          @Override\n-         public void call() throws IOException, InterruptedException {\n+         public void call() {\n             cm.getClassWhiteList().addClasses(Person.class);\n             Cache<String, Person> cache = cm.getCache();\n \n-            Marshaller marshaller = cache.getAdvancedCache().getComponentRegistry().getInternalMarshaller();\n+            DataConversion conversion = cache.getAdvancedCache().getValueDataConversion();\n+            Function<Object, byte[]> asStored = s -> (byte[]) conversion.convert(s, APPLICATION_OBJECT, APPLICATION_PROTOSTREAM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MDgyMA==", "bodyText": "\"16 more\" suddenly doesn't seem that important :)\nIMO we should remove these comments, I'd rather replace the constants in the code (e.g. line 217) with calculations to explain how we got the 144 or 104 bytes of overhead, or maybe a link to another place where the overhead is explained.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402850820", "createdAt": "2020-04-03T08:51:58Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java", "diffHunk": "@@ -142,7 +142,7 @@ protected void createCacheManagers() throws Throwable {\n             memoryConfigurationBuilder.size(SIZE);\n             break;\n          case BINARY:\n-            // 64 bytes per entry, however tests that add metadata require 16 more even\n+            // 144 bytes per entry, however tests that add metadata require 16 more even", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MTE3Mg==", "bodyText": "putIfAbsent isn't functional, as the method name implies.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402851172", "createdAt": "2020-04-03T08:52:19Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/eviction/impl/ExceptionEvictionTest.java", "diffHunk": "@@ -261,11 +261,11 @@ public void testExceptionOnInsert() {\n \n    public void testExceptionOnInsertFunctional() {\n       for (int i = 0; i < SIZE; ++i) {\n-         cache(0).computeIfAbsent(i, k -> SIZE);\n+         cache(0).putIfAbsent(i * 4096, SIZE * 4096);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MzY3OA==", "bodyText": "Why keep the random number?\nBut the bigger problem is that CountMarshallingPojo uses static fields for the marshall count, and it breaks when 2 of the many tests that use it run in parallel. Either it should have a custom raw marshaller, with a different marshaller instance in each test, or it should have a test name field and it should maintain a map of marshall counts per test.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402853678", "createdAt": "2020-04-03T08:55:04Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/eviction/impl/MarshalledValuesEvictionTest.java", "diffHunk": "@@ -22,97 +18,50 @@\n \n    private static final int CACHE_SIZE = 128;\n \n-\n    @Override\n    protected EmbeddedCacheManager createCacheManager() throws Exception {\n       ConfigurationBuilder cfg = new ConfigurationBuilder();\n       cfg.memory().size(CACHE_SIZE).evictionType(EvictionType.COUNT).storageType(StorageType.BINARY)\n             .expiration().wakeUpInterval(100L)\n             .locking().useLockStriping(false) // to minimise chances of deadlock in the unit test\n             .build();\n-      cacheManager = TestCacheManagerFactory.createCacheManager(cfg);\n+      cacheManager = TestCacheManagerFactory.createCacheManager(TestDataSCI.INSTANCE, cfg);\n       cache = cacheManager.getCache();\n       return cacheManager;\n    }\n \n    public void testEvictCustomKeyValue() {\n-      EvictionPojo.Externalizer.resetStats();\n+      CountMarshallingPojo.reset();\n       int expectedWrites = 0;\n       int expectedReads = 0;\n       for (int i = 0; i < CACHE_SIZE * 2; i++) {\n-         EvictionPojo p1 = new EvictionPojo();\n-         p1.i = (int) Util.random(2000);\n-         EvictionPojo p2 = new EvictionPojo();\n-         p2.i = 24;\n+         CountMarshallingPojo p1 = new CountMarshallingPojo((int) Util.random(2000));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MzA1NQ==", "bodyText": "Couldn't we just change the test so it doesn't use primitive arrays? :)\nMost cache operations won't work with primitive array keys, because the equals() implementation is wrong, and many cache operations also require equals() to work for values, so I would rather prohibit primitive array keys and values instead of adding special support in protostream.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402863055", "createdAt": "2020-04-03T09:05:48Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/eviction/impl/protostream/PrimitiveArrayCtx.java", "diffHunk": "@@ -0,0 +1,222 @@\n+package org.infinispan.eviction.impl.protostream;\n+\n+import static org.infinispan.protostream.FileDescriptorSource.fromString;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.protostream.MessageMarshaller;\n+import org.infinispan.protostream.SerializationContext;\n+import org.infinispan.protostream.SerializationContextInitializer;\n+\n+/**\n+ * Adds support for primitive and primitive wrapper arrays.\n+ */\n+public class PrimitiveArrayCtx implements SerializationContextInitializer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzAwNA=="}, "originalCommit": {"oid": "5781343b1f04b53900c78da8caba1bf452374b86"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2NTIzOQ==", "bodyText": "A static method would be clearer IMO, it's always applied directly.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402865239", "createdAt": "2020-04-03T09:08:22Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/persistence/LocalModePassivationTest.java", "diffHunk": "@@ -68,6 +73,13 @@ protected EmbeddedCacheManager createCacheManager() throws Exception {\n       return TestCacheManagerFactory.createCacheManager(builder);\n    }\n \n+   private static BiFunction<Cache<?, ?>, Object, WrappedByteArray> TO_DATA_CONTAINER =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2OTM1Mg==", "bodyText": "Please reformat only changed lines!\nI've seen quite a few whitespace changes on unmodified lines like this, but this jumped to me because I have Chained method calls / Align when multiline enabled in IntelliJ, and if you have it disabled, formatting the entire file changes the indent of all my lines.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402869352", "createdAt": "2020-04-03T09:14:13Z", "author": {"login": "danberindei"}, "path": "jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java", "diffHunk": "@@ -220,8 +228,8 @@ public V get(final K key) {\n       // ReadWriteMap.evalMany is not that useful since it forces us to transfer keys\n       List<? extends SimpleEntry<? extends K, CompletableFuture<R>>> list =\n             keys.stream()\n-                .map(k -> new SimpleEntry<>(k, map.eval(k, function)))\n-                .collect(Collectors.toList());\n+                  .map(k -> new SimpleEntry<>(k, map.eval(k, function)))\n+                  .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MDU5Nw==", "bodyText": "-1", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402870597", "createdAt": "2020-04-03T09:16:28Z", "author": {"login": "danberindei"}, "path": "jcache/embedded/src/main/java/org/infinispan/jcache/embedded/JCache.java", "diffHunk": "@@ -534,11 +543,12 @@ public void removeAll(Set<? extends K> keys) {\n             // does not block the commit of other, already persisted entries\n             AggregateCompletionStage<Void> stage = CompletionStages.aggregateCompletionStage();\n             keys.stream()\n-                .map(k -> rwMapSkipCacheLoad.eval(k, Remove.getInstance()))\n-                .forEach(stage::dependsOn);\n+                  .map(k -> rwMapSkipCacheLoad.eval(k, Remove.getInstance()))\n+                  .forEach(stage::dependsOn);\n             CompletionStages.join(stage.freeze());\n          } else {\n-            rwMapSkipCacheLoad.evalMany(keys, Remove.getInstance()).forEach(b -> {});\n+            rwMapSkipCacheLoad.evalMany(keys, Remove.getInstance()).forEach(b -> {\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3NjI4Ng==", "bodyText": "Is this really necessary? I thought JCache doesn't allow the user to override the data conversion.\nAlso the field/parameter names should include Conversion, key and value is a bit confusing.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402876286", "createdAt": "2020-04-03T09:26:27Z", "author": {"login": "danberindei"}, "path": "jcache/embedded/src/main/java/org/infinispan/jcache/embedded/functions/Invoke.java", "diffHunk": "@@ -28,13 +29,17 @@\n    private final EntryProcessor<K, V, R> processor;\n    private final Object[] arguments;\n    private final boolean storeByReference;\n+   private final DataConversion key;\n+   private final DataConversion value;\n    private PersistenceMarshaller marshaller;\n    private ExpiryPolicy expiryPolicy;\n \n-   public Invoke(EntryProcessor<K, V, R> processor, Object[] arguments, boolean storeByReference) {\n+   public Invoke(EntryProcessor<K, V, R> processor, Object[] arguments, boolean storeByReference, DataConversion key, DataConversion value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3ODM0NA==", "bodyText": "What's the expected media type for a Lucene cache? Couldn't you test for that instead of !APPLICATION_UNKNOWN?", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402878344", "createdAt": "2020-04-03T09:29:59Z", "author": {"login": "danberindei"}, "path": "lucene/lucene-directory/src/main/java/org/infinispan/lucene/directory/DirectoryBuilder.java", "diffHunk": "@@ -42,8 +43,12 @@ public static BuildContext newDirectoryInstance(Cache<?, ?> metadataCache, Cache\n     * Search\n     */\n    private static Cache<?, ?> decorateCache(Cache<?, ?> cache) {\n-      if (cache == null) return null;\n-      return cache.getAdvancedCache().withStorageMediaType();\n+      if(cache == null) return null;\n+      if(cache.getAdvancedCache().getValueDataConversion().getStorageMediaType().equals(MediaType.APPLICATION_UNKNOWN)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3OTc3MA==", "bodyText": "Missing whitespace (also on line 401)\nAlso, the javadoc of Wrapper.isFilterable() says true if the wrapped format is suitable to be indexed or filtered, thus avoiding extra unwrapping, but here you're doing the unwrapping in the true case. Maybe the javadoc is referring to something else?", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r402879770", "createdAt": "2020-04-03T09:32:39Z", "author": {"login": "danberindei"}, "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -398,15 +394,19 @@ private void performSearchWork(Work work, TransactionContext transactionContext)\n    }\n \n    private Object extractValue(Object storedValue) {\n-      return valueDataConversion.extractIndexable(storedValue);\n+      return this.cache.getValueDataConversion().extractIndexable(storedValue);\n    }\n \n    private Object extractKey(Object storedKey) {\n-      return keyDataConversion.extractIndexable(storedKey);\n+      if(storedKey == null) return null;\n+      DataConversion valueDataConversion = cache.getValueDataConversion();\n+      boolean protoWrapper = valueDataConversion.getWrapper().isFilterable();\n+      if(protoWrapper) return cache.getKeyDataConversion().getWrapper().unwrap(storedKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/12c2c9fa53d4cb7283abd3e6e024b528b01b3734", "committedDate": "2020-04-02T14:17:21Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/1d12f712af659235ec9ff67c71228eeb15cf6dbc", "committedDate": "2020-04-03T19:54:15Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1d12f712af659235ec9ff67c71228eeb15cf6dbc", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/1d12f712af659235ec9ff67c71228eeb15cf6dbc", "committedDate": "2020-04-03T19:54:15Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "41a3cf5ff301aacb69ab51896c92c604daac206d", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/41a3cf5ff301aacb69ab51896c92c604daac206d", "committedDate": "2020-04-03T21:15:17Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "41a3cf5ff301aacb69ab51896c92c604daac206d", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/41a3cf5ff301aacb69ab51896c92c604daac206d", "committedDate": "2020-04-03T21:15:17Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "5528d136c3e035fce9395fe4d787a0e3c4492cbb", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/5528d136c3e035fce9395fe4d787a0e3c4492cbb", "committedDate": "2020-04-04T10:13:40Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5528d136c3e035fce9395fe4d787a0e3c4492cbb", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/5528d136c3e035fce9395fe4d787a0e3c4492cbb", "committedDate": "2020-04-04T10:13:40Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "ed738330b13776a9fef301d73171c1071523b961", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/ed738330b13776a9fef301d73171c1071523b961", "committedDate": "2020-04-04T13:56:27Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed738330b13776a9fef301d73171c1071523b961", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/ed738330b13776a9fef301d73171c1071523b961", "committedDate": "2020-04-04T13:56:27Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "cca724dd7c14f22677656589edc431b818577817", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/cca724dd7c14f22677656589edc431b818577817", "committedDate": "2020-04-05T19:39:15Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00f99990aa94a76f0bd3c234b77416611b26b2b8", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/00f99990aa94a76f0bd3c234b77416611b26b2b8", "committedDate": "2020-04-06T11:45:23Z", "message": "aaaa"}, "afterCommit": {"oid": "a2811525c3f1eb2b39749b5f69fc8ab3a2d5a30f", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/a2811525c3f1eb2b39749b5f69fc8ab3a2d5a30f", "committedDate": "2020-04-06T11:45:57Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODczMzc4", "url": "https://github.com/infinispan/infinispan/pull/8129#pullrequestreview-388873378", "createdAt": "2020-04-07T07:59:11Z", "commit": {"oid": "a2811525c3f1eb2b39749b5f69fc8ab3a2d5a30f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo1OToxMVrOGB3iaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzo1OToxMVrOGB3iaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxMTY4OQ==", "bodyText": "Here too, if the cache injected in components has request media type == storage media type, then the conversion isn't necessary.\nEdit: You would still have to convert the value to the request media type, but I would rather make that conversion explicit here instead of converting the key back and forth.", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r404611689", "createdAt": "2020-04-07T07:59:11Z", "author": {"login": "danberindei"}, "path": "query/src/main/java/org/infinispan/query/clustered/commandworkers/CQLazyFetcher.java", "diffHunk": "@@ -31,7 +31,7 @@ Object extractValue(DocumentExtractor extractor, int docIndex) {\n       }\n       if (projection == null) {\n          Object key = extractKey(extractor, docIndex);\n-         return cache.get(key);\n+         return cache.get(fromStorage(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2811525c3f1eb2b39749b5f69fc8ab3a2d5a30f"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2811525c3f1eb2b39749b5f69fc8ab3a2d5a30f", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/a2811525c3f1eb2b39749b5f69fc8ab3a2d5a30f", "committedDate": "2020-04-06T11:45:57Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "bdf6d3b0b0d7bac76261bdec531f6423b53e864c", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/bdf6d3b0b0d7bac76261bdec531f6423b53e864c", "committedDate": "2020-04-08T09:39:05Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bdf6d3b0b0d7bac76261bdec531f6423b53e864c", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/bdf6d3b0b0d7bac76261bdec531f6423b53e864c", "committedDate": "2020-04-08T09:39:05Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "15c662a69c03e260563a1ee75c05bb7d0aef245e", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/15c662a69c03e260563a1ee75c05bb7d0aef245e", "committedDate": "2020-04-08T13:03:46Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTQzNDI1", "url": "https://github.com/infinispan/infinispan/pull/8129#pullrequestreview-390143425", "createdAt": "2020-04-08T16:36:02Z", "commit": {"oid": "15c662a69c03e260563a1ee75c05bb7d0aef245e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNTkyMTMx", "url": "https://github.com/infinispan/infinispan/pull/8129#pullrequestreview-390592131", "createdAt": "2020-04-09T08:30:37Z", "commit": {"oid": "15c662a69c03e260563a1ee75c05bb7d0aef245e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODozMDozOFrOGDO2jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODozMDozOFrOGDO2jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0MjI1NQ==", "bodyText": "Can you make use of one of the POJOs in TestDataSCI, say Key or Person. That way we don't need yet another test class and SerializationContextInitializer implementation.\nWhen I originally made ProtoStream the default I managed to remove a lot of duplicated code from the testsuite by removing internal test classes like these. So it would be great if we could stick to the already provided ones. This is a trivial Pojo, so it should work correctly unlike CountMarshallingPojo \ud83d\ude05", "url": "https://github.com/infinispan/infinispan/pull/8129#discussion_r406042255", "createdAt": "2020-04-09T08:30:38Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/dataconversion/ProtostreamTranscoderTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.dataconversion;\n+\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OBJECT;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_PROTOSTREAM;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.io.IOException;\n+\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.encoding.ProtostreamTranscoder;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.protostream.ProtobufUtil;\n+import org.infinispan.protostream.SerializationContext;\n+import org.infinispan.protostream.SerializationContextInitializer;\n+import org.infinispan.protostream.annotations.AutoProtoSchemaBuilder;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.test.dataconversion.AbstractTranscoderTest;\n+import org.mockito.Mockito;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+@Test(groups = \"functional\", testName = \"query.remote.impl.ProtostreamTranscoderTest\")\n+public class ProtostreamTranscoderTest extends AbstractTranscoderTest {\n+\n+   protected String dataSrc;\n+   private SerializationContext ctx = createCtx();\n+\n+   static final MediaType UNWRAPPED_PROTOSTREAM = APPLICATION_PROTOSTREAM.withParameter(\"wrapped\", \"false\");\n+   static final MediaType TYPED_OBJECT = APPLICATION_OBJECT.withParameter(\"type\", UserObject.class.getName());\n+\n+\n+   @BeforeClass(alwaysRun = true)\n+   public void setUp() {\n+      dataSrc = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\";\n+      SerializationContextRegistry registry = Mockito.mock(SerializationContextRegistry.class);\n+      Mockito.when(registry.getGlobalCtx()).thenReturn(ctx);\n+      transcoder = new ProtostreamTranscoder(registry, ProtostreamTranscoderTest.class.getClassLoader());\n+      supportedMediaTypes = transcoder.getSupportedMediaTypes();\n+   }\n+\n+   private SerializationContext createCtx() {\n+      SerializationContext ctx = ProtobufUtil.newSerializationContext();\n+      TestContextInitializer.INSTANCE.registerSchema(ctx);\n+      TestContextInitializer.INSTANCE.registerMarshallers(ctx);\n+      return ctx;\n+   }\n+\n+\n+   @Test\n+   @Override\n+   public void testTranscoderTranscode() throws Exception {\n+      Object transcoded = transcoder.transcode(dataSrc, TEXT_PLAIN, APPLICATION_PROTOSTREAM);\n+      assertTrue(transcoded instanceof byte[], \"Must be byte[]\");\n+\n+      Object transcodedBack = transcoder.transcode(transcoded, APPLICATION_PROTOSTREAM, TEXT_PLAIN);\n+\n+      // Must be String as byte[] as sent over the wire by hotrod\n+      assertTrue(transcodedBack instanceof byte[], \"Must be instance of byte[]\");\n+      assertEquals(dataSrc, new String((byte[]) transcodedBack, TEXT_PLAIN.getCharset().name()), \"Must be equal strings\");\n+   }\n+\n+   @Test\n+   public void testWrappedMessage() throws IOException {\n+      UserObject input = new UserObject(\"value\");\n+\n+      // Produces MessageWrapped and unwrapped payloads\n+      byte[] wrapped = (byte[]) transcoder.transcode(input, APPLICATION_OBJECT, APPLICATION_PROTOSTREAM);\n+      byte[] unwrapped = (byte[]) transcoder.transcode(input, APPLICATION_OBJECT, UNWRAPPED_PROTOSTREAM);\n+\n+      assertEquals(input, ProtobufUtil.fromWrappedByteArray(ctx, wrapped));\n+      assertEquals(input, ProtobufUtil.fromByteArray(ctx, unwrapped, UserObject.class));\n+\n+      // Convert from MessageWrapped back to object\n+      Object fromWrapped = transcoder.transcode(wrapped, APPLICATION_PROTOSTREAM, APPLICATION_OBJECT);\n+      assertEquals(input, fromWrapped);\n+\n+      // Convert from unwrapped payload back to object, specifying the object type\n+      Object fromUnWrappedWithType = transcoder.transcode(unwrapped, UNWRAPPED_PROTOSTREAM, TYPED_OBJECT);\n+      assertEquals(input, fromUnWrappedWithType);\n+\n+      // Should throw exception if trying to convert from unwrapped without passing the type\n+      try {\n+         transcoder.transcode(unwrapped, UNWRAPPED_PROTOSTREAM, APPLICATION_OBJECT);\n+         Assert.fail(\"should not convert from unwrapped without type\");\n+      } catch (MarshallingException ignored) {\n+      }\n+   }\n+\n+   @AutoProtoSchemaBuilder(\n+         includeClasses = {UserObject.class},\n+         schemaFileName = \"dataconversion.commons.proto\",\n+         schemaFilePath = \"proto/generated\",\n+         schemaPackageName = \"org.infinispan.dataconversion\")\n+   interface TestContextInitializer extends SerializationContextInitializer {\n+      TestContextInitializer INSTANCE = new TestContextInitializerImpl();\n+   }\n+\n+   static class UserObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c662a69c03e260563a1ee75c05bb7d0aef245e"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ea06795523bb66e349c84181c6729fe2e537a53", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/2ea06795523bb66e349c84181c6729fe2e537a53", "committedDate": "2020-04-09T08:56:37Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "15c662a69c03e260563a1ee75c05bb7d0aef245e", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/15c662a69c03e260563a1ee75c05bb7d0aef245e", "committedDate": "2020-04-08T13:03:46Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}, "afterCommit": {"oid": "2ea06795523bb66e349c84181c6729fe2e537a53", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/2ea06795523bb66e349c84181c6729fe2e537a53", "committedDate": "2020-04-09T08:56:37Z", "message": "ISPN-11478 Remove GlobalMarshaller usage on OFF_HEAP/BINARY"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1020, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}