{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNzM4MTk0", "number": 8783, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMToyODozMVrOEw84kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNDozMjo1OVrOFR6mxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzY0NjI3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMToyODozMVrOHm0hcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMjozNToxM1rOIYie1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODQ2NA==", "bodyText": "I'd like to see a comment explaining why is this true, or even better separate methods to manipulate the shared state atomically. It might also help to put hasPendingClear + pendingModifications in a State object, which could be then reused for the replicating modifications/clear.\nAlso, shouldn't this be checking replicatingClear as well?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510468464", "createdAt": "2020-10-22T21:28:31Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNjI4Ng==", "bodyText": "Hrmm, I will look to see if I can make this a bit more clear.\nAnd sure replicatingClear should be false as well.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511006286", "createdAt": "2020-10-23T16:37:49Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODQ2NA=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM4MTgwNA==", "bodyText": "I tried to add in the State object and I am not sold on it, I think the variables as they are currently is much simpler and obv requires less allocations.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r514381804", "createdAt": "2020-10-29T16:08:32Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODQ2NA=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYwMTY4NA==", "bodyText": "Ok, let's keep it this way then", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562601684", "createdAt": "2021-01-22T12:35:13Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODQ2NA=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzY0Njg1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMToyODo0NlrOHm0hzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMToyODo0NlrOHm0hzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODU1Ng==", "bodyText": "The javadoc is outdated.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510468556", "createdAt": "2020-10-22T21:28:46Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzcwNjk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMTo0ODoxOVrOHm1Fpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMzo1NjozN1rOIYlQYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ==", "bodyText": "Isn't it a risk that you're deciding to submit a new batch in one synchronized block and actually submitting the batch in a different block?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510477735", "createdAt": "2020-10-22T21:48:19Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNzM5Ng==", "bodyText": "The assignment of batchFuture protects that. You can only submit a batch if you assigned it to a new value.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511007396", "createdAt": "2020-10-23T16:39:47Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5MDgxMA==", "bodyText": "I'm pretty sure the assignment of batchFuture protects agains two threads both seeing a non-empty pendingModifications and each assigning its own CompletableFuture to batchFuture.\nOTOH I'm sure there's something else preventing 2 threads from both submitting a batch, it's just not clear from the code here.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511990810", "createdAt": "2020-10-26T14:13:20Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxMDU2MA==", "bodyText": "You can only submit a batch if you wrote to batchFuture though.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r512010560", "createdAt": "2020-10-26T14:38:30Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxMDkwMA==", "bodyText": "writing to batchFuture and submitting the batch are tied together and should only change together.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r512010900", "createdAt": "2020-10-26T14:39:00Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NTkxOA==", "bodyText": "I was a bit scared of coming back to this, but let me try to understand this again.\n\nThe assignment of batchFuture protects that. You can only submit a batch if you assigned it to a new value.\n\nThe assignment of batchFuture itself doesn't really protect against anything. If thread A sees !pendingModifications.isEmpty() || hasPendingClear, it writes to batchFuture, but that doesn't prevent thread B from also seeing that !pendingModifications.isEmpty() || hasPendingClear and also writing to batchFuture.\n\nI'm pretty sure the assignment of batchFuture protects agains two threads both seeing a non-empty pendingModifications\n\nI think I meant \"I'm not sure\", at least that's how I see it now.\n\nYou can only submit a batch if you wrote to batchFuture though.\n\nBut there's nothing preventing you from writing to batchFuture here. If there is something somewhere else, I think that link should be made clearer by adding a comment or by moving that code closer.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547285918", "createdAt": "2020-12-22T13:46:02Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MDc5Nw==", "bodyText": "Okay, I understand your concern. The part you are missing is that it isn't possible for two threads to invoke this to begin with as only a single thread can invoke submitTask at a time at \n  \n    \n      infinispan/core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java\n    \n    \n         Line 476\n      in\n      6729d3b\n    \n    \n    \n    \n\n        \n          \n           if (startNewBatch = batchFuture == null) { \n        \n    \n  \n\n.\nSo with this only one thread in submitModitification can assign the batchFuture and only if it is null. This means that submitTask is invoked in a thread at a time and batchFuture will be non null at the beginning, so its assignment you linked here will either put it to null or a new non null value. In the former case the loop doesn't continue, otherwise it resubmits the task again.\nI can add a more explicit comment to submitTask detailing this. It had a very brief comment, but wasn't really detailing this.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551580797", "createdAt": "2021-01-04T21:32:22Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAyODA2Mg==", "bodyText": "It's still not very clear to me, I'll definitely need a more explicit comment :)\nSo you're saying that when this code executes, batchFuture must be non-null, and any submitTask() running on another thread cannot submit a new batch?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560028062", "createdAt": "2021-01-19T09:23:48Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ3OTQxMA==", "bodyText": "It's still not very clear to me, I'll definitely need a more explicit comment :)\nSo you're saying that when this code executes, batchFuture must be non-null, and any submitTask() running on another thread cannot submit a new batch?\n\nNo, as mentioned on the submitTask method it states that submitModification checks the variable and ensures that only single modification can start the call. So it isn't possible for submitTask to be invoked from multiple threads concurrently. I have added the latter part to the method description as well.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560479410", "createdAt": "2021-01-19T20:36:48Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDczOTIxMA==", "bodyText": "It would be simpler if submitModification() was the only caller of submitTask().\nBut in submitTask() itself you have\nasyncBatchStage.whenComplete((ignore, t) -> {\n...\n            submitTask();\n         }", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560739210", "createdAt": "2021-01-20T07:47:35Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTk4MDcwMQ==", "bodyText": "Which is why I mentioned Invoking this method outside of this method... in the submitTask javadoc.\nBut the submitTask method is the only method that ever assigns batchFuture to null, which prevents concurrent modification as well. I have added another paragraph to the Javadoc.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r561980701", "createdAt": "2021-01-21T15:39:55Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0NzEzNg==", "bodyText": "Which is why I mentioned Invoking this method outside of this method... in the submitTask javadoc.\n\nSorry, that was too subtle for me... I guess my eyes just glazed over the second \"this method\".\n\nBut the submitTask method is the only method that ever assigns batchFuture to null, which prevents concurrent modification as well. I have added another paragraph to the Javadoc.\n\nPart of the reason I didn't read the javadoc correctly is that I didn't see the whenComplete() lambda as part of \"this method\". Lexically it's a part of submitTask(), but at the JVM level it's a separate method, and it runs separately, not during the submitTask() invocation.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562647136", "createdAt": "2021-01-22T13:56:37Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzcxNDU5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMTo1MTowMlrOHm1KOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDo0MjoxOFrOHoS1Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODkwNg==", "bodyText": "The apply() implementations expect the call to be synchronized on this, but there's no hint in the interface.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510478906", "createdAt": "2020-10-22T21:51:02Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNzc0NQ==", "bodyText": "Yeah, I had it this way originally. Been changed a few times now :) I can add it to the interface.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511007745", "createdAt": "2020-10-23T16:40:23Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODkwNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NjAzOA==", "bodyText": "Yeah, I had it this way originally\n\nDid you mean the apply method was declared synchronized?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511986038", "createdAt": "2020-10-26T14:06:52Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODkwNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxMzU5NQ==", "bodyText": "Yeah, that was in an early revision.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r512013595", "createdAt": "2020-10-26T14:42:18Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODkwNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 325}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODk3MTY0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzowMToyNFrOHnBJEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQwODoxMjowMlrOIWxlVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg==", "bodyText": "Hmmm, the javadoc of delete() doesn't say anything about the return value being optional.\nBut since it clearly is optional, could it be that we don't need the return value at all?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510675216", "createdAt": "2020-10-23T07:01:24Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxOTQ1MA==", "bodyText": "It is used by stuff like Map.remove and stats. It is just that when the store is async we essentially make it optional for performance. The prior async store did the same thing.  https://github.com/infinispan/infinispan/blob/10.1.x/core/src/main/java/org/infinispan/persistence/async/AsyncCacheWriter.java#L233", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r512019450", "createdAt": "2020-10-26T14:49:35Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxMTgxNQ==", "bodyText": "I don't think the result of store.delete() is needed for Cache.remove(key) or for cache statistics, CacheWriterInterceptor ignores it:\n\n  \n    \n      infinispan/core/src/main/java/org/infinispan/interceptors/impl/CacheWriterInterceptor.java\n    \n    \n         Line 219\n      in\n      7206596\n    \n    \n    \n    \n\n        \n          \n           return delayedValue(resultStage, rv);", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547311815", "createdAt": "2020-12-22T14:35:43Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NDg4Mg==", "bodyText": "I agree, but I am guessing we may want a stat for removes at some point. Either way there is no way the async store can properly update it the way it is used in CacheWriterInterceptor.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551594882", "createdAt": "2021-01-04T21:59:49Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MDcwMw==", "bodyText": "We already have the stat (removeHits). It's just that it's computed in CacheMgmtInterceptor based on the value that was loaded in the invocation context, not on the result of the store operation:\n\n  \n    \n      infinispan/core/src/main/java/org/infinispan/interceptors/impl/CacheMgmtInterceptor.java\n    \n    \n         Line 495\n      in\n      2d53d0a\n    \n    \n    \n    \n\n        \n          \n           if (removeCommand.isConditional()) {", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560040703", "createdAt": "2021-01-19T09:41:20Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ4MzA2Nw==", "bodyText": "Either way this seems like a discussion for another time. I really hate getting stuck in the weeds on something unrelated to the original PR making the PR wait on it. If you would I love for you to create a JIRA about changing the store SPI to not have that return value and we can discuss on Zulip or something.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560483067", "createdAt": "2021-01-19T20:43:35Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDc1MTk1OA==", "bodyText": "Sorry if I gave that impression, but I never meant to hold this PR, I was just asking a question because I didn't have a close look at this in the non-blocking SPI PR.\nAnyway, I created https://issues.redhat.com/browse/ISPN-12638 to replace the Boolean with Void", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560751958", "createdAt": "2021-01-20T08:12:02Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 372}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTAxMDk3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzoxNDozM1rOHnBf8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjoxOTo1MFrOHqj42g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg==", "bodyText": "There should be a comment explaining how these executors changes the test compared to using NamedExecutorsFactory.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510681072", "createdAt": "2020-10-23T07:14:33Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -100,12 +106,19 @@ void startMarshaller() {\n \n       nonBlockingExecutor = new ThreadPoolExecutor(0, ProcessorInfo.availableProcessors() * 2,\n             60L, TimeUnit.SECONDS,\n-            new LinkedBlockingQueue<>(),\n-            getTestThreadFactory(\"NonBlocking\"));\n+            new ArrayBlockingQueue<>(1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwODUzNg==", "bodyText": "This test was just like this before. I was only fixing it :(", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511008536", "createdAt": "2020-10-23T16:41:49Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -100,12 +106,19 @@ void startMarshaller() {\n \n       nonBlockingExecutor = new ThreadPoolExecutor(0, ProcessorInfo.availableProcessors() * 2,\n             60L, TimeUnit.SECONDS,\n-            new LinkedBlockingQueue<>(),\n-            getTestThreadFactory(\"NonBlocking\"));\n+            new ArrayBlockingQueue<>(1),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NTMwNA==", "bodyText": "Well, the queue was unbound before, and and it has a fixed capacity of 1 now. Is that fixing something?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511985304", "createdAt": "2020-10-26T14:05:51Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -100,12 +106,19 @@ void startMarshaller() {\n \n       nonBlockingExecutor = new ThreadPoolExecutor(0, ProcessorInfo.availableProcessors() * 2,\n             60L, TimeUnit.SECONDS,\n-            new LinkedBlockingQueue<>(),\n-            getTestThreadFactory(\"NonBlocking\"));\n+            new ArrayBlockingQueue<>(1),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5MTU3MQ==", "bodyText": "The big fix is that it is using the correct thread pools as before it wasn't using threads that were non blocking.\nI only put the queue size to 1 to force more contention, I can undo that.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511991571", "createdAt": "2020-10-26T14:14:26Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -100,12 +106,19 @@ void startMarshaller() {\n \n       nonBlockingExecutor = new ThreadPoolExecutor(0, ProcessorInfo.availableProcessors() * 2,\n             60L, TimeUnit.SECONDS,\n-            new LinkedBlockingQueue<>(),\n-            getTestThreadFactory(\"NonBlocking\"));\n+            new ArrayBlockingQueue<>(1),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzOTAxMw==", "bodyText": "I only put the queue size to 1 to force more contention, I can undo that.\n\nSince this is a stress test that might be useful, but it would need a code comment explaining where it creates more contention and why it's useful to test that way.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r513539013", "createdAt": "2020-10-28T15:29:07Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -100,12 +106,19 @@ void startMarshaller() {\n \n       nonBlockingExecutor = new ThreadPoolExecutor(0, ProcessorInfo.availableProcessors() * 2,\n             60L, TimeUnit.SECONDS,\n-            new LinkedBlockingQueue<>(),\n-            getTestThreadFactory(\"NonBlocking\"));\n+            new ArrayBlockingQueue<>(1),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM4OTUyNw==", "bodyText": "Okay.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r514389527", "createdAt": "2020-10-29T16:18:55Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -100,12 +106,19 @@ void startMarshaller() {\n \n       nonBlockingExecutor = new ThreadPoolExecutor(0, ProcessorInfo.availableProcessors() * 2,\n             60L, TimeUnit.SECONDS,\n-            new LinkedBlockingQueue<>(),\n-            getTestThreadFactory(\"NonBlocking\"));\n+            new ArrayBlockingQueue<>(1),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5MDIzNA==", "bodyText": "I have just reverted for now since the test doesn't exhibit enough pressure on the non blocking pool to cause a backpressure exception.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r514390234", "createdAt": "2020-10-29T16:19:50Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -100,12 +106,19 @@ void startMarshaller() {\n \n       nonBlockingExecutor = new ThreadPoolExecutor(0, ProcessorInfo.availableProcessors() * 2,\n             60L, TimeUnit.SECONDS,\n-            new LinkedBlockingQueue<>(),\n-            getTestThreadFactory(\"NonBlocking\"));\n+            new ArrayBlockingQueue<>(1),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTAzNzEwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzoyMjozOVrOHnBvRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDo1OToyMFrOIJ-ENw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ==", "bodyText": "IMO the comment is misleading. It says \"This per-key lock holder provides guarantees that the final expected\nstate has not been affected by ordering issues\", but the key lock is held while performing the store write as well, not just while updating the expectedState map.\nSame with the withStore method, it should be withKeyLock IMO. Also, the worker thread blocks to wait for the key lock and for the store write, and I'm not sure if that scenario is still relevant.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510684999", "createdAt": "2020-10-23T07:22:39Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -134,7 +147,7 @@ void stopMarshaller() throws InterruptedException {\n    // ImmortalCacheEntry{key=key165168, value=ImmortalCacheValue {value=61456}}}\n    // (Thread-194:) Expected state updated with key=key165168, value=61456\n    // (Thread-200:) Expected state updated with key=key165168, value=60483\n-   private LockContainer locks = new PerKeyLockContainer();\n+   private LockContainer locks;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwODkzMA==", "bodyText": "I didn't write this test at all. I would rather just remove all the garbage tbh. But I wasn't trying to completely rewrite this test, just get it to work.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511008930", "createdAt": "2020-10-23T16:42:33Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -134,7 +147,7 @@ void stopMarshaller() throws InterruptedException {\n    // ImmortalCacheEntry{key=key165168, value=ImmortalCacheValue {value=61456}}}\n    // (Thread-194:) Expected state updated with key=key165168, value=61456\n    // (Thread-200:) Expected state updated with key=key165168, value=60483\n-   private LockContainer locks = new PerKeyLockContainer();\n+   private LockContainer locks;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NDcwNA==", "bodyText": "I know the test is quite old and there's a lot of stuff that's out of date, but I don't think we're going to get any better opportunity to fix the outdated stuff later.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511984704", "createdAt": "2020-10-26T14:05:06Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -134,7 +147,7 @@ void stopMarshaller() throws InterruptedException {\n    // ImmortalCacheEntry{key=key165168, value=ImmortalCacheValue {value=61456}}}\n    // (Thread-194:) Expected state updated with key=key165168, value=61456\n    // (Thread-200:) Expected state updated with key=key165168, value=60483\n-   private LockContainer locks = new PerKeyLockContainer();\n+   private LockContainer locks;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQxMTc0OQ==", "bodyText": "So I change the name of withStore to withKeyLock but I am not sure how you want me to change the description for this method.\nI don't quite understand your comment about that the lock is held while doing the store write. That is how ISPN works. If the write is enqueued then it will release before it is written to the store and if it is enqueued but was \"full\" then it has to wait until it can be written before releasing the lock.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r514411749", "createdAt": "2020-10-29T16:49:07Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -134,7 +147,7 @@ void stopMarshaller() throws InterruptedException {\n    // ImmortalCacheEntry{key=key165168, value=ImmortalCacheValue {value=61456}}}\n    // (Thread-194:) Expected state updated with key=key165168, value=61456\n    // (Thread-200:) Expected state updated with key=key165168, value=60483\n-   private LockContainer locks = new PerKeyLockContainer();\n+   private LockContainer locks;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMyNDk4Mw==", "bodyText": "Thanks for renaming the method.\nYou're right that the key lock must be held while doing the write. I was thinking that if you changed the test to acquire and release the lock in a non-blocking way, the thread performing the store operation would no longer necessarily be the worker thread. It could be the same non-blocking thread that performed the previous operation on that key, and the lack of a context switch between the 2 operations might make a potential race more or less likely.\nThinking again, it's not worth the trouble to make this test more life-like, when we can stress-test a full cache instead.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547324983", "createdAt": "2020-12-22T14:59:20Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -134,7 +147,7 @@ void stopMarshaller() throws InterruptedException {\n    // ImmortalCacheEntry{key=key165168, value=ImmortalCacheValue {value=61456}}}\n    // (Thread-194:) Expected state updated with key=key165168, value=61456\n    // (Thread-200:) Expected state updated with key=key165168, value=60483\n-   private LockContainer locks = new PerKeyLockContainer();\n+   private LockContainer locks;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDg5NTU5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjo1OTozOFrOIJ6W1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNDoyOTowOVrOIYmh5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDIxNQ==", "bodyText": "Kind of off-topic, but shouldn't we also set a stopping flag so new requests are rejected?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547264215", "createdAt": "2020-12-22T12:59:38Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -130,36 +117,23 @@ public AsyncNonBlockingStore(NonBlockingStore<K, V> actual) {\n       segmentCount = storeConfiguration.segmented() ? cacheConfiguration.clustering().hash().numSegments() : 1;\n       asyncConfiguration = storeConfiguration.async();\n       modificationQueueSize = asyncConfiguration.modificationQueueSize();\n-      // It is possible for multiple threads to write to this processor at the same time\n-      submissionFlowable = UnicastProcessor.<Modification>create(1).toSerialized();\n       nonBlockingExecutor = ctx.getNonBlockingExecutor();\n-      startSub = submissionFlowable.window(requestFlowable).subscribe(this);\n+      stopped = false;\n       return actual.start(ctx);\n    }\n \n    @Override\n    public CompletionStage<Void> stop() {\n       CompletionStage<Void> asyncStage;\n-      if (submissionFlowable != null) {\n-         if (trace) {\n-            log.tracef(\"Stopping async store containing store %s\", actual);\n-         }\n-         submissionFlowable = null;\n-         asyncStage = awaitQuiescence().whenComplete((ignore, t) -> {\n-            // We can only dispose of the subscription after we are sure we are totally stopped\n-            if (startSub != null) {\n-               startSub.dispose();\n-               startSub = null;\n-            }\n-         });\n-\n-      } else {\n-         asyncStage = CompletableFutures.completedNull();\n+      if (trace) {\n+         log.tracef(\"Stopping async store containing store %s\", actual);\n       }\n+      asyncStage = awaitQuiescence();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU3NTc5NQ==", "bodyText": "Hrmm, I think it should be okay if I just move stopped = true; to the line before calling awaitQuiescence. There is still technically a tiny window, as this would really require a check before submitting to be 100%, but I am not too worried about that.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551575795", "createdAt": "2021-01-04T21:21:35Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -130,36 +117,23 @@ public AsyncNonBlockingStore(NonBlockingStore<K, V> actual) {\n       segmentCount = storeConfiguration.segmented() ? cacheConfiguration.clustering().hash().numSegments() : 1;\n       asyncConfiguration = storeConfiguration.async();\n       modificationQueueSize = asyncConfiguration.modificationQueueSize();\n-      // It is possible for multiple threads to write to this processor at the same time\n-      submissionFlowable = UnicastProcessor.<Modification>create(1).toSerialized();\n       nonBlockingExecutor = ctx.getNonBlockingExecutor();\n-      startSub = submissionFlowable.window(requestFlowable).subscribe(this);\n+      stopped = false;\n       return actual.start(ctx);\n    }\n \n    @Override\n    public CompletionStage<Void> stop() {\n       CompletionStage<Void> asyncStage;\n-      if (submissionFlowable != null) {\n-         if (trace) {\n-            log.tracef(\"Stopping async store containing store %s\", actual);\n-         }\n-         submissionFlowable = null;\n-         asyncStage = awaitQuiescence().whenComplete((ignore, t) -> {\n-            // We can only dispose of the subscription after we are sure we are totally stopped\n-            if (startSub != null) {\n-               startSub.dispose();\n-               startSub = null;\n-            }\n-         });\n-\n-      } else {\n-         asyncStage = CompletableFutures.completedNull();\n+      if (trace) {\n+         log.tracef(\"Stopping async store containing store %s\", actual);\n       }\n+      asyncStage = awaitQuiescence();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDIxNQ=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwOTg1MQ==", "bodyText": "I don't think that will work, unless you also remove the assertNotStopped() check in batch().", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560009851", "createdAt": "2021-01-19T08:56:15Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -130,36 +117,23 @@ public AsyncNonBlockingStore(NonBlockingStore<K, V> actual) {\n       segmentCount = storeConfiguration.segmented() ? cacheConfiguration.clustering().hash().numSegments() : 1;\n       asyncConfiguration = storeConfiguration.async();\n       modificationQueueSize = asyncConfiguration.modificationQueueSize();\n-      // It is possible for multiple threads to write to this processor at the same time\n-      submissionFlowable = UnicastProcessor.<Modification>create(1).toSerialized();\n       nonBlockingExecutor = ctx.getNonBlockingExecutor();\n-      startSub = submissionFlowable.window(requestFlowable).subscribe(this);\n+      stopped = false;\n       return actual.start(ctx);\n    }\n \n    @Override\n    public CompletionStage<Void> stop() {\n       CompletionStage<Void> asyncStage;\n-      if (submissionFlowable != null) {\n-         if (trace) {\n-            log.tracef(\"Stopping async store containing store %s\", actual);\n-         }\n-         submissionFlowable = null;\n-         asyncStage = awaitQuiescence().whenComplete((ignore, t) -> {\n-            // We can only dispose of the subscription after we are sure we are totally stopped\n-            if (startSub != null) {\n-               startSub.dispose();\n-               startSub = null;\n-            }\n-         });\n-\n-      } else {\n-         asyncStage = CompletableFutures.completedNull();\n+      if (trace) {\n+         log.tracef(\"Stopping async store containing store %s\", actual);\n       }\n+      asyncStage = awaitQuiescence();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDIxNQ=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY2ODAwNA==", "bodyText": "I created https://issues.redhat.com/browse/ISPN-12647 to look more closely at the shutdown procedure in all the bundled store implementations.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562668004", "createdAt": "2021-01-22T14:29:09Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -130,36 +117,23 @@ public AsyncNonBlockingStore(NonBlockingStore<K, V> actual) {\n       segmentCount = storeConfiguration.segmented() ? cacheConfiguration.clustering().hash().numSegments() : 1;\n       asyncConfiguration = storeConfiguration.async();\n       modificationQueueSize = asyncConfiguration.modificationQueueSize();\n-      // It is possible for multiple threads to write to this processor at the same time\n-      submissionFlowable = UnicastProcessor.<Modification>create(1).toSerialized();\n       nonBlockingExecutor = ctx.getNonBlockingExecutor();\n-      startSub = submissionFlowable.window(requestFlowable).subscribe(this);\n+      stopped = false;\n       return actual.start(ctx);\n    }\n \n    @Override\n    public CompletionStage<Void> stop() {\n       CompletionStage<Void> asyncStage;\n-      if (submissionFlowable != null) {\n-         if (trace) {\n-            log.tracef(\"Stopping async store containing store %s\", actual);\n-         }\n-         submissionFlowable = null;\n-         asyncStage = awaitQuiescence().whenComplete((ignore, t) -> {\n-            // We can only dispose of the subscription after we are sure we are totally stopped\n-            if (startSub != null) {\n-               startSub.dispose();\n-               startSub = null;\n-            }\n-         });\n-\n-      } else {\n-         asyncStage = CompletableFutures.completedNull();\n+      if (trace) {\n+         log.tracef(\"Stopping async store containing store %s\", actual);\n       }\n+      asyncStage = awaitQuiescence();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDIxNQ=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTAwNDA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMzozNDoyNVrOIJ7Vxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMzozNDoyNVrOIJ7Vxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MDMyNw==", "bodyText": "Shouldn't this be\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     assert replicatingModifications == null || replicatingModifications.isEmpty() && !isReplicatingClear;\n          \n          \n            \n                     assert (replicatingModifications == null || replicatingModifications.isEmpty()) && !isReplicatingClear;", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547280327", "createdAt": "2020-12-22T13:34:25Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -197,84 +171,78 @@ private synchronized void putClearModification() {\n    }\n \n    /**\n-    * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n-    * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n+    * This method should only be invoked after the `batchFuture` was written to in a synchronized block.\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n-\n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         // The isReplicatingClear would be true or replicatingModifications non empty if an update was currently pending\n+         // But we should only allow one at a time\n+         assert replicatingModifications == null || replicatingModifications.isEmpty() && !isReplicatingClear;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTA5MjEyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowMTowM1rOIJ8J_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQyMDo0NDoyNFrOIWhMow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5MzY5NA==", "bodyText": "Since the elements of the flatMap() flowable are CompletionStages, is it really ok to ignore all but the last element?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547293694", "createdAt": "2020-12-22T14:01:03Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MzIzOA==", "bodyText": "Yes, as we are invoking submitModification in a single thread it guarantees the last invocation will be later than any other invocation in the underlying batched queue. And since all elements in a given batch are completed at the same time, it is okay. I can add a comment though, good call out.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551583238", "createdAt": "2021-01-04T21:37:41Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5MzY5NA=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAzMDk2Mw==", "bodyText": "That too, but I was also thinking about what happens if one CompletionStage completes with an exception and then the last CompletionStage completes successfully.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560030963", "createdAt": "2021-01-19T09:27:39Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5MzY5NA=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ4MzQ5MQ==", "bodyText": "Okay.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560483491", "createdAt": "2021-01-19T20:44:24Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5MzY5NA=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 348}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTEwNDQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowNDo0NlrOIJ8RbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMTo0MDozOVrOIOCDCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTU5Ng==", "bodyText": "Incomplete statement.\nI'd also replace the passive voice (\"It is assumed that\") w/ something more imperative, e.g. \"This method is not thread safe, callers must ensure that it is not invoked on multiple threads in parallel.\"", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547295596", "createdAt": "2020-12-22T14:04:46Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.infinispan.persistence.async;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+\n+interface Modification {\n+   /**\n+    * Applies the modification to the provided async store.\n+    * <p>\n+    * It is assumed that callers of this method are done in a thread safe way, either by synchronizing\n+    * the invocation of this invocation, limiting concurrent invocations of this method or by\n+    * protecting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4NDUyMQ==", "bodyText": "Okay, I just changed it to your text :)", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551584521", "createdAt": "2021-01-04T21:40:39Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.infinispan.persistence.async;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+\n+interface Modification {\n+   /**\n+    * Applies the modification to the provided async store.\n+    * <p>\n+    * It is assumed that callers of this method are done in a thread safe way, either by synchronizing\n+    * the invocation of this invocation, limiting concurrent invocations of this method or by\n+    * protecting", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTU5Ng=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTEwNzAyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowNTozNVrOIJ8S5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMTo0MDo1MVrOIOCDWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTk3NA==", "bodyText": "Can this be removed?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547295974", "createdAt": "2020-12-22T14:05:35Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();\n+\n+         stageToWaitFor = pendingModifications.size() + replicatingSize > modificationQueueSize\n+               ? batchFuture : null;\n+         if (stageToWaitFor != null) {\n+            System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4NDYwMQ==", "bodyText": "Yes, had it for a debug spot :D", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551584601", "createdAt": "2021-01-04T21:40:51Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();\n+\n+         stageToWaitFor = pendingModifications.size() + replicatingSize > modificationQueueSize\n+               ? batchFuture : null;\n+         if (stageToWaitFor != null) {\n+            System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTk3NA=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 372}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTExNjE5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowODoxOFrOIJ8YSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMTo1MDo1MVrOIOCVDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NzM1NA==", "bodyText": "Maybe replicatingModifications should start non-null, so we can remove these null checks?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547297354", "createdAt": "2020-12-22T14:08:18Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4OTEzMw==", "bodyText": "Sure, will try assigning it to empty map.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551589133", "createdAt": "2021-01-04T21:50:51Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NzM1NA=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 367}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTE0MjUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDoxNjoxMlrOIJ8nyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMTo1MTo0MFrOIOCWVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwMTMyMg==", "bodyText": "How about submitStage instead? stageToWaitFor sounds like it could be anything.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547301322", "createdAt": "2020-12-22T14:16:12Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4OTQ2Mw==", "bodyText": "Okay.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551589463", "createdAt": "2021-01-04T21:51:40Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwMTMyMg=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 360}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTE3NjA4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDoyNTo0MFrOIJ87mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNDoxNjowN1rOIYl_kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwNjM5Mw==", "bodyText": "Is this really needed?\nThe way I see it, either store operations can complete on any thread, and switching to a non-blocking thread here is not needed, or store operations must complete on a non-blocking thread, and the batch future must have been completed on a non-blocking thread as well.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547306393", "createdAt": "2020-12-22T14:25:40Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();\n+\n+         stageToWaitFor = pendingModifications.size() + replicatingSize > modificationQueueSize\n+               ? batchFuture : null;\n+         if (stageToWaitFor != null) {\n+            System.currentTimeMillis();\n+         }\n+      }\n+\n+      if (trace) {\n+         log.tracef(\"A new modification %s has been enqueued with async store\", modification);\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n-         // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n+      }\n+      if (stageToWaitFor != null && trace) {\n+         log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n       }\n+      return stageToWaitFor == null ? CompletableFutures.completedNull() :\n+            stageToWaitFor.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5MTE2Nw==", "bodyText": "The problem isn't what thread it is invoked on but rather that a bunch of these could be enqueued waiting for the completion of this stage. The stageToWaitFor is the batchFuture so you could have hundreds or thousands depending upon this one stage, so we may not want to block completion of all of these on a single thread. But maybe that is okay?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551591167", "createdAt": "2021-01-04T21:55:17Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();\n+\n+         stageToWaitFor = pendingModifications.size() + replicatingSize > modificationQueueSize\n+               ? batchFuture : null;\n+         if (stageToWaitFor != null) {\n+            System.currentTimeMillis();\n+         }\n+      }\n+\n+      if (trace) {\n+         log.tracef(\"A new modification %s has been enqueued with async store\", modification);\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n-         // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n+      }\n+      if (stageToWaitFor != null && trace) {\n+         log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n       }\n+      return stageToWaitFor == null ? CompletableFutures.completedNull() :\n+            stageToWaitFor.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwNjM5Mw=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY1OTIxNg==", "bodyText": "I see.\nI was thinking running them on a single thread might be better for throughput, because you have less context switching. But submitting them to the executor is potentially better for latency, so let's keep it this way unless it comes up in the profiler at some point in the future.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562659216", "createdAt": "2021-01-22T14:16:07Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();\n+\n+         stageToWaitFor = pendingModifications.size() + replicatingSize > modificationQueueSize\n+               ? batchFuture : null;\n+         if (stageToWaitFor != null) {\n+            System.currentTimeMillis();\n+         }\n+      }\n+\n+      if (trace) {\n+         log.tracef(\"A new modification %s has been enqueued with async store\", modification);\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n-         // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n+      }\n+      if (stageToWaitFor != null && trace) {\n+         log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n       }\n+      return stageToWaitFor == null ? CompletableFutures.completedNull() :\n+            stageToWaitFor.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwNjM5Mw=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 392}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTIyODA1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDo0MDoxNFrOIJ9adA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNDoyMDo1MVrOIYmMSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNDI5Mg==", "bodyText": "I didn't get this comment, which test method has this problem? And what does the store write to key X get in a deadlock with?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547314292", "createdAt": "2020-12-22T14:40:14Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -370,7 +370,10 @@ private static ConfigurationBuilder config(boolean passivation) {\n          ConfigurationBuilder config = new ConfigurationBuilder();\n          config.memory().maxCount(1).persistence().passivation(passivation).addStore(LockableStoreConfigurationBuilder.class)\n                .async()\n-                  .modificationQueueSize(1)\n+                  // When using passivation we block a store write to key X - which in turn\n+                  // gets in a deadlock as it never completes - make sure to set queue size one\n+                  // higher so it can complete", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NzEwOA==", "bodyText": "The ordering in passivation. The problem is the doTestEndToEndPutPut test delays the store write from completing in the test directly. Thus the batch can't complete and thus if you submit a new write to the store it will be enqueued in the async batch and wont' complete.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551597108", "createdAt": "2021-01-04T22:05:05Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -370,7 +370,10 @@ private static ConfigurationBuilder config(boolean passivation) {\n          ConfigurationBuilder config = new ConfigurationBuilder();\n          config.memory().maxCount(1).persistence().passivation(passivation).addStore(LockableStoreConfigurationBuilder.class)\n                .async()\n-                  .modificationQueueSize(1)\n+                  // When using passivation we block a store write to key X - which in turn\n+                  // gets in a deadlock as it never completes - make sure to set queue size one\n+                  // higher so it can complete", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNDI5Mg=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY2MjQ3Mg==", "bodyText": "I like the new comment \ud83d\udc4d", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562662472", "createdAt": "2021-01-22T14:20:51Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -370,7 +370,10 @@ private static ConfigurationBuilder config(boolean passivation) {\n          ConfigurationBuilder config = new ConfigurationBuilder();\n          config.memory().maxCount(1).persistence().passivation(passivation).addStore(LockableStoreConfigurationBuilder.class)\n                .async()\n-                  .modificationQueueSize(1)\n+                  // When using passivation we block a store write to key X - which in turn\n+                  // gets in a deadlock as it never completes - make sure to set queue size one\n+                  // higher so it can complete", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNDI5Mg=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTI0MDU0OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDo0Mzo0MlrOIJ9iEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTo1MjozMlrOIWGpUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNjI0Mg==", "bodyText": "SLOW_STORE_WAIT is 100, waiting 205ms every time is too much IMO.\nThe store only has slow(true) for testConcurrentClearAndStop, so waiting 10ms to get a timeout should be enough.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547316242", "createdAt": "2020-12-22T14:43:42Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -412,7 +415,7 @@ public void call() throws InterruptedException {\n                   }\n                });\n \n-               Exceptions.expectException(TimeoutException.class, () -> f.get(100, TimeUnit.MILLISECONDS));\n+               Exceptions.expectException(TimeoutException.class, () -> f.get(DummyInMemoryStore.SLOW_STORE_WAIT * 2 + 5, TimeUnit.MILLISECONDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NjI2MQ==", "bodyText": "IIRC passivation actually has to hit the store twice, so it really should have been 200 originally. So the original number was too low. So I really only added 5 milliseconds. The biggest change is that it is based on the dummy slow time so you can tweak it in tests if needed.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551596261", "createdAt": "2021-01-04T22:03:07Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -412,7 +415,7 @@ public void call() throws InterruptedException {\n                   }\n                });\n \n-               Exceptions.expectException(TimeoutException.class, () -> f.get(100, TimeUnit.MILLISECONDS));\n+               Exceptions.expectException(TimeoutException.class, () -> f.get(DummyInMemoryStore.SLOW_STORE_WAIT * 2 + 5, TimeUnit.MILLISECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNjI0Mg=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0ODQ2Nw==", "bodyText": "This test's writes would finish in <1ms if they weren't waiting for store.delayedFuture (unless you're debugging, and then 200ms vs 10ms doesn't change anything).\nIf it was using slow(true), then it would make sense to give it 200ms to finish both writes, but it's not, so f will complete as soon as store.delayedFuture is completed.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560048467", "createdAt": "2021-01-19T09:52:32Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -412,7 +415,7 @@ public void call() throws InterruptedException {\n                   }\n                });\n \n-               Exceptions.expectException(TimeoutException.class, () -> f.get(100, TimeUnit.MILLISECONDS));\n+               Exceptions.expectException(TimeoutException.class, () -> f.get(DummyInMemoryStore.SLOW_STORE_WAIT * 2 + 5, TimeUnit.MILLISECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNjI0Mg=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MTMxMjM0OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNTowMzoxM1rOIJ-Mew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNTowMzoxM1rOIJ-Mew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMyNzA5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .location(\"/tmp\")\n          \n          \n            \n                        .location(location)", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547327099", "createdAt": "2020-12-22T15:03:13Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -153,6 +166,7 @@ void stopMarshaller() throws InterruptedException {\n             .getDefaultCacheConfiguration(false)\n             .persistence()\n             .addSingleFileStore()\n+            .location(\"/tmp\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjMwODM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODo1OToxNFrOIWEaMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODo1OToxNFrOIWEaMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAxMTgyNg==", "bodyText": "Markdown alert :)", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560011826", "createdAt": "2021-01-19T08:59:14Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -196,84 +171,81 @@ private synchronized void putClearModification() {\n    }\n \n    /**\n-    * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n-    * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n+    * This method is protected by the `batchFuture` instance variable. Invoking this method outside of this method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8249ad48b8202fdab57607c4d01090b4ae518d6e"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjUwMTQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTo0MjoyOVrOIWGOJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTo0MjoyOVrOIWGOJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MTUxMQ==", "bodyText": "Typo: IThis", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560041511", "createdAt": "2021-01-19T09:42:29Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.infinispan.persistence.async;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+\n+interface Modification {\n+   /**\n+    * Applies the modification to the provided async store.\n+    * <p>\n+    * IThis method is not thread safe, callers must ensure that it is not invoked on multiple threads in parallel.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8249ad48b8202fdab57607c4d01090b4ae518d6e"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjUwNzExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTo0Mzo1MVrOIWGRxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTo0Mzo1MVrOIWGRxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MjQzOA==", "bodyText": "Forgot to remove the segment-related stuff :)", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560042438", "createdAt": "2021-01-19T09:43:51Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.infinispan.persistence.async;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+\n+interface Modification {\n+   /**\n+    * Applies the modification to the provided async store.\n+    * <p>\n+    * IThis method is not thread safe, callers must ensure that it is not invoked on multiple threads in parallel.\n+    * @param store the store to apply the modification to\n+    * @param <K> key type\n+    * @param <V> value type\n+    */\n+   <K, V> void apply(AsyncNonBlockingStore<K, V> store);\n+\n+   /**\n+    * Returns the segment that maps to this modification. Some modifications may not map to a given\n+    * segment and may throw an {@link UnsupportedOperationException}.\n+    * @return the segment that maps to the modification\n+    */\n+   int getSegment();\n+\n+   /**\n+    * Returns this modification as a stage that is already complete. Some modifications may not map\n+    * to a given segment and may throw an {@link UnsupportedOperationException}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8249ad48b8202fdab57607c4d01090b4ae518d6e"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MzMwMzExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNDozMjo1OVrOIYmr5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNTowNTowNlrOIYoE2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY3MDU2NA==", "bodyText": "You removed the lastElement() call, so I think you can also remove this comment.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562670564", "createdAt": "2021-01-22T14:32:59Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -473,72 +459,70 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      // Note that all of these use the lastElement method to detect completion. This is okay only because the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae"}, "originalPosition": 385}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY5MzMzOQ==", "bodyText": "Sure.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562693339", "createdAt": "2021-01-22T15:05:06Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -473,72 +459,70 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      // Note that all of these use the lastElement method to detect completion. This is okay only because the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY3MDU2NA=="}, "originalCommit": {"oid": "9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae"}, "originalPosition": 385}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3871, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}