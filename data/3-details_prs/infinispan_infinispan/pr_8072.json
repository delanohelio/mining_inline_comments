{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNDg4NjAy", "number": 8072, "title": "ISPN-11299 Stale values can be indexed during State Transfer", "bodyText": "https://issues.redhat.com/browse/ISPN-11299", "createdAt": "2020-03-20T11:45:37Z", "url": "https://github.com/infinispan/infinispan/pull/8072", "merged": true, "mergeCommit": {"oid": "128874af7ab7204db85bb1ea1ed8248b3828ffdd"}, "closed": true, "closedAt": "2021-03-31T16:17:49Z", "author": {"login": "gustavonalle"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRbEHyABqjMxNjc5Nzk1Mzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeF5k_SAFqTYxODM2Mzk5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "481dd2a4d22f2aeaf09ad6ae9b16ae2f8679b7f0", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/481dd2a4d22f2aeaf09ad6ae9b16ae2f8679b7f0", "committedDate": "2020-03-20T11:44:25Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "9f35cbaaa37dff173730437f13387b0033f8cd74", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/9f35cbaaa37dff173730437f13387b0033f8cd74", "committedDate": "2020-03-26T11:54:30Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f35cbaaa37dff173730437f13387b0033f8cd74", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/9f35cbaaa37dff173730437f13387b0033f8cd74", "committedDate": "2020-03-26T11:54:30Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "8d833fe4f4897918083868c93807d3f809a9a5f3", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/8d833fe4f4897918083868c93807d3f809a9a5f3", "committedDate": "2020-05-19T10:32:46Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MzM1MDYw", "url": "https://github.com/infinispan/infinispan/pull/8072#pullrequestreview-414335060", "createdAt": "2020-05-19T11:03:35Z", "commit": {"oid": "8d833fe4f4897918083868c93807d3f809a9a5f3"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTowMzozNVrOGXbLDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMTowODoyMFrOGXbVKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNTYyOQ==", "bodyText": "I think you need to move the oldMetadata to ReadCommittedEntry", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427215629", "createdAt": "2020-05-19T11:03:35Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/container/entries/RepeatableReadEntry.java", "diffHunk": "@@ -17,12 +17,10 @@\n    private static final boolean trace = log.isTraceEnabled();\n \n    /* Value before the last modification. Serves as the previous value when the operation is retried */\n-   protected Object oldValue;\n    protected Metadata oldMetadata;\n \n    public RepeatableReadEntry(Object key, Object value, Metadata metadata) {\n       super(key, value, metadata);\n-      this.oldValue = value;\n       this.oldMetadata = metadata;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d833fe4f4897918083868c93807d3f809a9a5f3"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNTg4Ng==", "bodyText": "missing committed\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        log.tracef(\"Updating entry (key=%s removed=%s changed=%s created=%s value=%s metadata=%s)\",\n          \n          \n            \n                        log.tracef(\"Updating entry (key=%s removed=%s changed=%s created=%s committed=%s value=%s metadata=%s)\",", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427215886", "createdAt": "2020-05-19T11:04:06Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -157,7 +167,7 @@ private boolean shouldCommit() {\n       if (isChanged()) {\n          if (trace)\n             log.tracef(\"Updating entry (key=%s removed=%s changed=%s created=%s value=%s metadata=%s)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d833fe4f4897918083868c93807d3f809a9a5f3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg==", "bodyText": "I'm not sure if I agree with this change. if we have a case where setValue() is invoked multiple times, I would rather return \"prev\" than \"oldValue\".", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427218216", "createdAt": "2020-05-19T11:08:20Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -196,9 +206,8 @@ public long getLastUsed() {\n \n    @Override\n    public Object setValue(Object value) {\n-      Object prev = this.value;\n       this.value = value;\n-      return prev;\n+      return oldValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d833fe4f4897918083868c93807d3f809a9a5f3"}, "originalPosition": 60}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8d833fe4f4897918083868c93807d3f809a9a5f3", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/8d833fe4f4897918083868c93807d3f809a9a5f3", "committedDate": "2020-05-19T10:32:46Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "faf3b801d592f991f4ded689e20da811375e1527", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/faf3b801d592f991f4ded689e20da811375e1527", "committedDate": "2020-05-19T13:29:27Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "faf3b801d592f991f4ded689e20da811375e1527", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/faf3b801d592f991f4ded689e20da811375e1527", "committedDate": "2020-05-19T13:29:27Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "94a38ee74572b1f7e99a3ba25bf375bffd16553a", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/94a38ee74572b1f7e99a3ba25bf375bffd16553a", "committedDate": "2020-05-19T14:33:45Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NDQzOTk5", "url": "https://github.com/infinispan/infinispan/pull/8072#pullrequestreview-414443999", "createdAt": "2020-05-19T13:27:57Z", "commit": {"oid": "8d833fe4f4897918083868c93807d3f809a9a5f3"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMzoyNzo1N1rOGXgZkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNDo1NDo1M1rOGXkfGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMwMTI2Ng==", "bodyText": "Why not call setCommitted() immediately after shouldCommit()?", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427301266", "createdAt": "2020-05-19T13:27:57Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -143,11 +149,15 @@ public final void commit(DataContainer container) {\n       // only do stuff if there are changes.\n       if (shouldCommit()) {\n          if (isEvicted()) {\n-            return container.evict(segment, key);\n+            CompletionStage<Void> evict = container.evict(segment, key);\n+            setCommitted();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d833fe4f4897918083868c93807d3f809a9a5f3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM0Mjg5OA==", "bodyText": "AFAICT CallInterceptor.performPut() is the only caller that uses the return value, and it expects it to be prev (because the 2nd put in the same tx should return the value set by the 1st put.", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427342898", "createdAt": "2020-05-19T14:24:06Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -196,9 +206,8 @@ public long getLastUsed() {\n \n    @Override\n    public Object setValue(Object value) {\n-      Object prev = this.value;\n       this.value = value;\n-      return prev;\n+      return oldValue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg=="}, "originalCommit": {"oid": "8d833fe4f4897918083868c93807d3f809a9a5f3"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MTI3Ng==", "bodyText": "Needs javadoc, is this the value at the start of the transaction/operation, or is it supposed to be updated after every operation on this entry in the tx or after every retry that invokes setValue()?", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427351276", "createdAt": "2020-05-19T14:33:58Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -115,6 +117,10 @@ public final Object getValue() {\n       return value;\n    }\n \n+   public Object getOldValue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faf3b801d592f991f4ded689e20da811375e1527"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MjY2MA==", "bodyText": "Not sure how this is supposed to work when a tx writes to the same key 2 times, 3 times, etc. Personally I'd prefer an explicit update of oldValue and setValue always returning the current value (aka this.value) -- something CallInterceptor.performPut() already does?\nAt least the entry is removed from the context when a command is retried, so you don't have to worry about non-tx caches.", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427352660", "createdAt": "2020-05-19T14:35:41Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -195,9 +213,10 @@ public long getLastUsed() {\n    }\n \n    @Override\n-   public Object setValue(Object value) {\n-      Object prev = this.value;\n-      this.value = value;\n+   public Object setValue(Object newValue) {\n+      Object prev = oldValue;\n+      this.oldValue = this.value;\n+      this.value = newValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94a38ee74572b1f7e99a3ba25bf375bffd16553a"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2ODIxOQ==", "bodyText": "I'd do it without the AtomicInteger\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        countPerEntity.computeIfAbsent(entity, aClass -> new AtomicInteger(0)).incrementAndGet();\n          \n          \n            \n                        countPerEntity.merge(entity, 1, Integer::sum);", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427368219", "createdAt": "2020-05-19T14:54:53Z", "author": {"login": "danberindei"}, "path": "query/src/test/java/org/infinispan/query/blackbox/IndexingDuringStateTransferTest.java", "diffHunk": "@@ -214,4 +228,21 @@ private void test(Consumer<Cache<Object, Object>> op, Consumer<SearchManager> ch\n    private void assertFluffyIndexed(SearchManager sm) {\n       assertEquals(Collections.singletonList(FLUFFY), queryAll(sm, AnotherGrassEater.class));\n    }\n+\n+   private void waitForIndexSynced() {\n+      List<Cache<String, Object>> caches = caches();\n+      caches.forEach(c -> {\n+         SearchManager sm = Search.getSearchManager(c);\n+         DataContainer<String, Object> dataContainer = c.getAdvancedCache().getDataContainer();\n+         Map<Class<?>, AtomicInteger> countPerEntity = new HashMap<>();\n+         dataContainer.forEach(e -> {\n+            Class<?> entity = e.getValue().getClass();\n+            countPerEntity.computeIfAbsent(entity, aClass -> new AtomicInteger(0)).incrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94a38ee74572b1f7e99a3ba25bf375bffd16553a"}, "originalPosition": 108}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94a38ee74572b1f7e99a3ba25bf375bffd16553a", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/94a38ee74572b1f7e99a3ba25bf375bffd16553a", "committedDate": "2020-05-19T14:33:45Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "827003297a8b8f617f0d64e106e03bc157126e4f", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/827003297a8b8f617f0d64e106e03bc157126e4f", "committedDate": "2020-05-20T10:19:53Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "827003297a8b8f617f0d64e106e03bc157126e4f", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/827003297a8b8f617f0d64e106e03bc157126e4f", "committedDate": "2020-05-20T10:19:53Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "889ae26b4de2045c05252e62c564edc6f1bd747a", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/889ae26b4de2045c05252e62c564edc6f1bd747a", "committedDate": "2020-05-20T12:58:43Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1OTQ4Njg2", "url": "https://github.com/infinispan/infinispan/pull/8072#pullrequestreview-415948686", "createdAt": "2020-05-21T07:54:05Z", "commit": {"oid": "889ae26b4de2045c05252e62c564edc6f1bd747a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "889ae26b4de2045c05252e62c564edc6f1bd747a", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/889ae26b4de2045c05252e62c564edc6f1bd747a", "committedDate": "2020-05-20T12:58:43Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "1f2172847bf7c24aa2eda91286b06a87d57974e9", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/1f2172847bf7c24aa2eda91286b06a87d57974e9", "committedDate": "2021-03-05T17:40:13Z", "message": "wip"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEzMDkzNDIx", "url": "https://github.com/infinispan/infinispan/pull/8072#pullrequestreview-613093421", "createdAt": "2021-03-16T10:46:20Z", "commit": {"oid": "1f2172847bf7c24aa2eda91286b06a87d57974e9"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xNlQxMDo0NjoyMVrOI3fJXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xNlQxMDo0ODo0MVrOI3fQiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1Mjg5Mw==", "bodyText": "since processChange() returns a CompletionStage, you can change indexIfNeeded() to return the CompletionStage and void using the BlockingManager.", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r595052893", "createdAt": "2021-03-16T10:46:21Z", "author": {"login": "pruivo"}, "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,77 +145,79 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n          }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n+            // https://issues.redhat.com/browse/ISPN-11731\n+            return asyncValue(blockingManager.runBlocking(() -> indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()), cmd)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f2172847bf7c24aa2eda91286b06a87d57974e9"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1MzYwOQ==", "bodyText": "lambda here and in handleManyWriteCommand() are \"the same\". you could cache it and use it in both places.", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r595053609", "createdAt": "2021-03-16T10:47:16Z", "author": {"login": "pruivo"}, "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,77 +145,79 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f2172847bf7c24aa2eda91286b06a87d57974e9"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1NDcyOA==", "bodyText": "actually, you aren't waiting for the index to complete. maybe it is the source of your issues? I just notice you never wait on processChange() CompletableFuture", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r595054728", "createdAt": "2021-03-16T10:48:41Z", "author": {"login": "pruivo"}, "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,77 +145,79 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n          }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n+            // https://issues.redhat.com/browse/ISPN-11731\n+            return asyncValue(blockingManager.runBlocking(() -> indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()), cmd)\n+                  .thenApply(ignore -> rv));\n+         }\n+         return rv;\n+      });\n+   }\n+\n+   private Object handleManyWriteCommand(InvocationContext ctx, WriteCommand command) {\n+      if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n-      } else {\n-         Object prev = entry != null ? entry.getValue() : UNKNOWN;\n-         if (prev == null && unreliablePreviousValue(command)) {\n-            prev = UNKNOWN;\n+      }\n+      return invokeNextThenAccept(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return;\n          }\n-         Object oldValue = prev;\n-         return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n-            if (!cmd.isSuccessful()) {\n-               return rv;\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            for (Object key : command.getAffectedKeys()) {\n+               registerOldValue(ctx, key, unreliablePrevious, oldValues);\n             }\n-            CacheEntry entry2 = entry != null ? entry : rCtx.lookupEntry(cmd.getKey());\n-            if (entry2 != null && entry2.isChanged()) {\n-               // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n-               // https://issues.redhat.com/browse/ISPN-11731\n-               return asyncValue(processChange(rCtx, cmd, cmd.getKey(), oldValue, entry2.getValue())\n-                     .thenApply(ignore -> rv));\n+         } else {\n+            for (Object key : cmd.getAffectedKeys()) {\n+               indexIfNeeded(rCtx, cmd, unreliablePrevious, key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f2172847bf7c24aa2eda91286b06a87d57974e9"}, "originalPosition": 102}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f2172847bf7c24aa2eda91286b06a87d57974e9", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/1f2172847bf7c24aa2eda91286b06a87d57974e9", "committedDate": "2021-03-05T17:40:13Z", "message": "wip"}, "afterCommit": {"oid": "8b59e2607fb13db97010e10a9efa7cedb33ae0df", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/8b59e2607fb13db97010e10a9efa7cedb33ae0df", "committedDate": "2021-03-17T17:39:25Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8b59e2607fb13db97010e10a9efa7cedb33ae0df", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/8b59e2607fb13db97010e10a9efa7cedb33ae0df", "committedDate": "2021-03-17T17:39:25Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "59d322420ca091e9a7bd0aac4195db9e85da6865", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/59d322420ca091e9a7bd0aac4195db9e85da6865", "committedDate": "2021-03-17T17:41:08Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "59d322420ca091e9a7bd0aac4195db9e85da6865", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/59d322420ca091e9a7bd0aac4195db9e85da6865", "committedDate": "2021-03-17T17:41:08Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "71e05019f291a12ed6c7284feaca8c8ac0c4b118", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/71e05019f291a12ed6c7284feaca8c8ac0c4b118", "committedDate": "2021-03-18T15:50:15Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "71e05019f291a12ed6c7284feaca8c8ac0c4b118", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/71e05019f291a12ed6c7284feaca8c8ac0c4b118", "committedDate": "2021-03-18T15:50:15Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "239da3e1d4e73602159a55cc5cd561f862e295e0", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/239da3e1d4e73602159a55cc5cd561f862e295e0", "committedDate": "2021-03-18T21:27:49Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "239da3e1d4e73602159a55cc5cd561f862e295e0", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/239da3e1d4e73602159a55cc5cd561f862e295e0", "committedDate": "2021-03-18T21:27:49Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "4a1d43ae5e377defef471bb892e95b624010d22d", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/4a1d43ae5e377defef471bb892e95b624010d22d", "committedDate": "2021-03-19T00:14:55Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3Mjg5MjQ1", "url": "https://github.com/infinispan/infinispan/pull/8072#pullrequestreview-617289245", "createdAt": "2021-03-22T09:12:49Z", "commit": {"oid": "4a1d43ae5e377defef471bb892e95b624010d22d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQwOToxMjo0OVrOI6z0Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yMlQwOToxODoyOVrOI60D7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODUzNzI5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     boolean unreliablePrevious = unreliablePreviousValue(command);\n          \n          \n            \n                     boolean unreliablePrevious = unreliablePreviousValue(cmd);", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598537291", "createdAt": "2021-03-22T09:12:49Z", "author": {"login": "pruivo"}, "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a1d43ae5e377defef471bb892e95b624010d22d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODUzNzczMw==", "bodyText": "sed command => cmd\nsed ctx => rCtx", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598537733", "createdAt": "2021-03-22T09:13:28Z", "author": {"login": "pruivo"}, "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a1d43ae5e377defef471bb892e95b624010d22d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODUzODQ5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return asyncValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()).thenApply(ignored -> rv));\n          \n          \n            \n                        return delayedValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()), rv);", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598538493", "createdAt": "2021-03-22T09:14:32Z", "author": {"login": "pruivo"}, "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            return asyncValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()).thenApply(ignored -> rv));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a1d43ae5e377defef471bb892e95b624010d22d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODUzOTIzNQ==", "bodyText": "sed command => cmd\nsed ctx => rCtx", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598539235", "createdAt": "2021-03-22T09:15:31Z", "author": {"login": "pruivo"}, "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            return asyncValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()).thenApply(ignored -> rv));\n          }\n+         return rv;\n+      });\n+   }\n+\n+   private Object handleManyWriteCommand(InvocationContext ctx, WriteCommand command) {\n+      if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n-      } else {\n-         Object prev = entry != null ? entry.getValue() : UNKNOWN;\n-         if (prev == null && unreliablePreviousValue(command)) {\n-            prev = UNKNOWN;\n+      }\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n          }\n-         Object oldValue = prev;\n-         return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n-            if (!cmd.isSuccessful()) {\n-               return rv;\n-            }\n-            CacheEntry entry2 = entry != null ? entry : rCtx.lookupEntry(cmd.getKey());\n-            if (entry2 != null && entry2.isChanged()) {\n-               // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n-               // https://issues.redhat.com/browse/ISPN-11731\n-               return asyncValue(processChange(rCtx, cmd, cmd.getKey(), oldValue, entry2.getValue())\n-                     .thenApply(ignore -> rv));\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            for (Object key : command.getAffectedKeys()) {\n+               registerOldValue(ctx, key, unreliablePrevious, oldValues);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a1d43ae5e377defef471bb892e95b624010d22d"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODU0MDY0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return asyncValue(allOf(cmd.getAffectedKeys().stream().map(key -> indexIfNeeded(rCtx, cmd, unreliablePrevious, key)).toArray(CompletableFuture[]::new)));\n          \n          \n            \n                        return return delayedValue(allOf(cmd.getAffectedKeys().stream().map(key -> indexIfNeeded(rCtx, cmd, unreliablePrevious, key)).toArray(CompletableFuture[]::new)), rv);", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598540644", "createdAt": "2021-03-22T09:17:29Z", "author": {"login": "pruivo"}, "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            return asyncValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()).thenApply(ignored -> rv));\n          }\n+         return rv;\n+      });\n+   }\n+\n+   private Object handleManyWriteCommand(InvocationContext ctx, WriteCommand command) {\n+      if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n-      } else {\n-         Object prev = entry != null ? entry.getValue() : UNKNOWN;\n-         if (prev == null && unreliablePreviousValue(command)) {\n-            prev = UNKNOWN;\n+      }\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n          }\n-         Object oldValue = prev;\n-         return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n-            if (!cmd.isSuccessful()) {\n-               return rv;\n-            }\n-            CacheEntry entry2 = entry != null ? entry : rCtx.lookupEntry(cmd.getKey());\n-            if (entry2 != null && entry2.isChanged()) {\n-               // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n-               // https://issues.redhat.com/browse/ISPN-11731\n-               return asyncValue(processChange(rCtx, cmd, cmd.getKey(), oldValue, entry2.getValue())\n-                     .thenApply(ignore -> rv));\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            for (Object key : command.getAffectedKeys()) {\n+               registerOldValue(ctx, key, unreliablePrevious, oldValues);\n             }\n             return rv;\n-         });\n+         } else {\n+            return asyncValue(allOf(cmd.getAffectedKeys().stream().map(key -> indexIfNeeded(rCtx, cmd, unreliablePrevious, key)).toArray(CompletableFuture[]::new)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a1d43ae5e377defef471bb892e95b624010d22d"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODU0MTI5NQ==", "bodyText": "isStale is always false", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598541295", "createdAt": "2021-03-22T09:18:29Z", "author": {"login": "pruivo"}, "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            return asyncValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()).thenApply(ignored -> rv));\n          }\n+         return rv;\n+      });\n+   }\n+\n+   private Object handleManyWriteCommand(InvocationContext ctx, WriteCommand command) {\n+      if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n-      } else {\n-         Object prev = entry != null ? entry.getValue() : UNKNOWN;\n-         if (prev == null && unreliablePreviousValue(command)) {\n-            prev = UNKNOWN;\n+      }\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n          }\n-         Object oldValue = prev;\n-         return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n-            if (!cmd.isSuccessful()) {\n-               return rv;\n-            }\n-            CacheEntry entry2 = entry != null ? entry : rCtx.lookupEntry(cmd.getKey());\n-            if (entry2 != null && entry2.isChanged()) {\n-               // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n-               // https://issues.redhat.com/browse/ISPN-11731\n-               return asyncValue(processChange(rCtx, cmd, cmd.getKey(), oldValue, entry2.getValue())\n-                     .thenApply(ignore -> rv));\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            for (Object key : command.getAffectedKeys()) {\n+               registerOldValue(ctx, key, unreliablePrevious, oldValues);\n             }\n             return rv;\n-         });\n+         } else {\n+            return asyncValue(allOf(cmd.getAffectedKeys().stream().map(key -> indexIfNeeded(rCtx, cmd, unreliablePrevious, key)).toArray(CompletableFuture[]::new)));\n+         }\n+      });\n+   }\n+\n+   private void registerOldValue(InvocationContext ctx, Object key, boolean unreliablePrevious, Map<Object, Object> oldValues) {\n+      CacheEntry<?, ?> entryTx = ctx.lookupEntry(key);\n+      if (entryTx != null && (entryTx.getValue() != null || !unreliablePrevious)) {\n+         ReadCommittedEntry<?, ?> mvccEntry = (ReadCommittedEntry<?, ?>) entryTx;\n+         oldValues.putIfAbsent(key, mvccEntry.getOldValue());\n       }\n    }\n \n-   private Map<Object, Object> registerOldValues(TxInvocationContext ctx) {\n+   private Map<Object, Object> getOldValuesMap(TxInvocationContext<?> ctx) {\n       return txOldValues.computeIfAbsent(ctx.getGlobalTransaction(), gid -> {\n          ctx.getCacheTransaction().addListener(() -> txOldValues.remove(gid));\n          return new HashMap<>();\n       });\n    }\n \n-   private Object handleManyWriteCommand(InvocationContext ctx, WriteCommand command) {\n-      if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n-         return invokeNext(ctx, command);\n+   private CompletableFuture<?> indexIfNeeded(InvocationContext rCtx, WriteCommand cmd, boolean unreliablePrevious, Object key) {\n+      CacheEntry<?, ?> entry = rCtx.lookupEntry(key);\n+      boolean isStale = false;\n+      Object old = null;\n+      if (entry instanceof MVCCEntry) {\n+         ReadCommittedEntry<?, ?> mvccEntry = (ReadCommittedEntry<?, ?>) entry;\n+         isStale = !mvccEntry.isCommitted();\n+         old = unreliablePrevious ? UNKNOWN : mvccEntry.getOldValue();\n       }\n-      if (ctx.isInTxScope()) {\n-         Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-         for (Object key : command.getAffectedKeys()) {\n-            CacheEntry entry = ctx.lookupEntry(key);\n-            if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-               oldValues.putIfAbsent(key, entry.getValue());\n-            }\n+      if (entry != null && entry.isChanged() && !isStale) {\n+         if (log.isDebugEnabled()) {\n+            log.debugf(\"Try indexing command '%s',key='%s', oldValue='%s', stale='%s'\", cmd, key, old, isStale);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a1d43ae5e377defef471bb892e95b624010d22d"}, "originalPosition": 145}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a1d43ae5e377defef471bb892e95b624010d22d", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/4a1d43ae5e377defef471bb892e95b624010d22d", "committedDate": "2021-03-19T00:14:55Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "f3058224420a698d8f66636efbdfbb71059a239b", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/f3058224420a698d8f66636efbdfbb71059a239b", "committedDate": "2021-03-22T13:59:03Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cf802b883faed62a4d9460efc307bc176904e15", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/6cf802b883faed62a4d9460efc307bc176904e15", "committedDate": "2021-03-22T16:14:29Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f3058224420a698d8f66636efbdfbb71059a239b", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/f3058224420a698d8f66636efbdfbb71059a239b", "committedDate": "2021-03-22T13:59:03Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}, "afterCommit": {"oid": "6cf802b883faed62a4d9460efc307bc176904e15", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/6cf802b883faed62a4d9460efc307bc176904e15", "committedDate": "2021-03-22T16:14:29Z", "message": "ISPN-11299 Stale values can be indexed during State Transfer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE4MzYzOTky", "url": "https://github.com/infinispan/infinispan/pull/8072#pullrequestreview-618363992", "createdAt": "2021-03-23T09:23:00Z", "commit": {"oid": "6cf802b883faed62a4d9460efc307bc176904e15"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 949, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}