{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyOTc2ODAx", "number": 7737, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoyNToxNFrODYKFEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjo0NTowOFrODYKYGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjU3NTUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoyNToxNFrOFd2o-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMToxMzozNVrOFeV8zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0ODI0OQ==", "bodyText": "Please replace the comment with one or two actual examples so we'll know what to expect when debugging.\nAnd are you sure the TimeoutException is always the most nested suppressed throwable, or should we check if any of the suppressed exceptions is a TimeoutException?", "url": "https://github.com/infinispan/infinispan/pull/7737#discussion_r366848249", "createdAt": "2020-01-15T12:25:14Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -322,6 +318,24 @@ private boolean pollForCompletion(BlockingQueue<CompletableFuture<?>> queue, lon\n       return previousFuture;\n    }\n \n+   // Unfortunately a tx exception is part of a caused and suppressed - we need to make sure the real cause is available", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40a67bb397299ab6655de3b90cb6e9f90daa9628"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkxNjI4Mg==", "bodyText": "In my testing it was always the most nested. I can try to debug it again to get the layout, it was something like CompletionException caused by XAException supressing RemoteException caused by TimeoutException or something like that :P", "url": "https://github.com/infinispan/infinispan/pull/7737#discussion_r366916282", "createdAt": "2020-01-15T14:49:23Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -322,6 +318,24 @@ private boolean pollForCompletion(BlockingQueue<CompletableFuture<?>> queue, lon\n       return previousFuture;\n    }\n \n+   // Unfortunately a tx exception is part of a caused and suppressed - we need to make sure the real cause is available", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0ODI0OQ=="}, "originalCommit": {"oid": "40a67bb397299ab6655de3b90cb6e9f90daa9628"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkyNDg1MA==", "bodyText": "I'm quite curious now why the RemoteException is suppressed... looking at TransactionCoordinator.prepare(), it calls initCause(), not addSuppressed.", "url": "https://github.com/infinispan/infinispan/pull/7737#discussion_r366924850", "createdAt": "2020-01-15T15:04:18Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -322,6 +318,24 @@ private boolean pollForCompletion(BlockingQueue<CompletableFuture<?>> queue, lon\n       return previousFuture;\n    }\n \n+   // Unfortunately a tx exception is part of a caused and suppressed - we need to make sure the real cause is available", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0ODI0OQ=="}, "originalCommit": {"oid": "40a67bb397299ab6655de3b90cb6e9f90daa9628"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkyNjc2NQ==", "bodyText": "I reproduced again; I missed the ordering and the RollbackException :)\nCompletionException\n -> caused by RollbackException\n    -> suppressing XAException\n       -> caused by RemoteException\n         -> caused by TimeoutException", "url": "https://github.com/infinispan/infinispan/pull/7737#discussion_r366926765", "createdAt": "2020-01-15T15:07:50Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -322,6 +318,24 @@ private boolean pollForCompletion(BlockingQueue<CompletableFuture<?>> queue, lon\n       return previousFuture;\n    }\n \n+   // Unfortunately a tx exception is part of a caused and suppressed - we need to make sure the real cause is available", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0ODI0OQ=="}, "originalCommit": {"oid": "40a67bb397299ab6655de3b90cb6e9f90daa9628"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkyNjgzMw==", "bodyText": "adding to comments", "url": "https://github.com/infinispan/infinispan/pull/7737#discussion_r366926833", "createdAt": "2020-01-15T15:07:57Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -322,6 +318,24 @@ private boolean pollForCompletion(BlockingQueue<CompletableFuture<?>> queue, lon\n       return previousFuture;\n    }\n \n+   // Unfortunately a tx exception is part of a caused and suppressed - we need to make sure the real cause is available", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0ODI0OQ=="}, "originalCommit": {"oid": "40a67bb397299ab6655de3b90cb6e9f90daa9628"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2MTQwNA==", "bodyText": "Do we still need the comment here, now that it's explained at the call site?\nAnd I really hope lock timeouts aren't going to be very common, because these exceptions aren't cheap...\nOff-topic, but definitely related, I don't see any special handling for WriteSkewException, so I wonder if the user is supposed to go through the same hoops in order to detect a WSE and retry the tx. I'm assuming we can't avoid the RollbackException, at least for explicit transactions, but it would be nice if the user could check for WSE with\ncatch (RollbackException e) {\n   if (e.getCause() instanceof WriteSkewException) {\n       ... retry ... \n   }\n}", "url": "https://github.com/infinispan/infinispan/pull/7737#discussion_r366961404", "createdAt": "2020-01-15T16:03:59Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -322,6 +318,24 @@ private boolean pollForCompletion(BlockingQueue<CompletableFuture<?>> queue, lon\n       return previousFuture;\n    }\n \n+   // Unfortunately a tx exception is part of a caused and suppressed - we need to make sure the real cause is available", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0ODI0OQ=="}, "originalCommit": {"oid": "40a67bb397299ab6655de3b90cb6e9f90daa9628"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2NTk1OA==", "bodyText": "Do we still need the comment here, now that it's explained at the call site?\n\nI guess I can remove it, it seemed pretty mundane to me.\n\nAnd I really hope lock timeouts aren't going to be very common, because these exceptions aren't cheap...\n\nThe LockTimeout should be very rare. The tests we have just pound expiration really hard, as it keeps expiring and calling get/replace within milliseconds 100 times.\n\nOff-topic, but definitely related, I don't see any special handling for WriteSkewException, so I wonder if the user is supposed to go through the same hoops in order to detect a WSE and retry the tx. I'm assuming we can't avoid the RollbackException, at least for explicit transactions, but it would be nice if the user could check for WSE with\ncatch (RollbackException e) {\n   if (e.getCause() instanceof WriteSkewException) {\n       ... retry ... \n   }\n}\n\n\nAre you saying in general or in this case? Cause I wouldn't expect to handle WriteSkewException here and just propagate it. In the general case, I agree it would be quite annoying for a user to see the WriteSkewException as it is buried a few layers deep, including a suppressed (which is a royal PITA).", "url": "https://github.com/infinispan/infinispan/pull/7737#discussion_r366965958", "createdAt": "2020-01-15T16:12:06Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -322,6 +318,24 @@ private boolean pollForCompletion(BlockingQueue<CompletableFuture<?>> queue, lon\n       return previousFuture;\n    }\n \n+   // Unfortunately a tx exception is part of a caused and suppressed - we need to make sure the real cause is available", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0ODI0OQ=="}, "originalCommit": {"oid": "40a67bb397299ab6655de3b90cb6e9f90daa9628"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2MTIzMQ==", "bodyText": "I meant in general, I don't expect users to call removeXExpired(), but I debugged one of our tests and the hierarchy looks exactly the same for WriteSkewException. I created ISPN-11167 for the WriteSkewException.", "url": "https://github.com/infinispan/infinispan/pull/7737#discussion_r367361231", "createdAt": "2020-01-16T11:13:35Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -322,6 +318,24 @@ private boolean pollForCompletion(BlockingQueue<CompletableFuture<?>> queue, lon\n       return previousFuture;\n    }\n \n+   // Unfortunately a tx exception is part of a caused and suppressed - we need to make sure the real cause is available", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0ODI0OQ=="}, "originalCommit": {"oid": "40a67bb397299ab6655de3b90cb6e9f90daa9628"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjYyNDI3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/tx/PrepareCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjo0NTowOFrOFd3F7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNDo0OTo1NVrOFd6z3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTY2MQ==", "bodyText": "Could return false and avoid the variable.", "url": "https://github.com/infinispan/infinispan/pull/7737#discussion_r366855661", "createdAt": "2020-01-15T12:45:08Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/tx/PrepareCommand.java", "diffHunk": "@@ -189,7 +189,18 @@ public Object getKeyLockOwner() {\n \n    @Override\n    public boolean hasZeroLockAcquisition() {\n-      return false;\n+      if (modifications == null || modifications.length == 0) {\n+         return false;\n+      }\n+      boolean hasZeroLock = true;\n+      for (WriteCommand wc : modifications) {\n+         // If even a single command doesn't have the zero lock acquisition timeout flag, we can't use a zero timeout\n+         if (!wc.hasAnyFlag(FlagBitSets.ZERO_LOCK_ACQUISITION_TIMEOUT)) {\n+            hasZeroLock = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40a67bb397299ab6655de3b90cb6e9f90daa9628"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkxNjU3Mg==", "bodyText": "Yes, I had this at some point and undid it. I blame being up late at night when I made the change :)", "url": "https://github.com/infinispan/infinispan/pull/7737#discussion_r366916572", "createdAt": "2020-01-15T14:49:55Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/commands/tx/PrepareCommand.java", "diffHunk": "@@ -189,7 +189,18 @@ public Object getKeyLockOwner() {\n \n    @Override\n    public boolean hasZeroLockAcquisition() {\n-      return false;\n+      if (modifications == null || modifications.length == 0) {\n+         return false;\n+      }\n+      boolean hasZeroLock = true;\n+      for (WriteCommand wc : modifications) {\n+         // If even a single command doesn't have the zero lock acquisition timeout flag, we can't use a zero timeout\n+         if (!wc.hasAnyFlag(FlagBitSets.ZERO_LOCK_ACQUISITION_TIMEOUT)) {\n+            hasZeroLock = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTY2MQ=="}, "originalCommit": {"oid": "40a67bb397299ab6655de3b90cb6e9f90daa9628"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4145, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}