{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2Nzc3ODg4", "number": 8221, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowNDowM1rOD0pbbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyOTowOFrOD0qILg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTMxMzA5OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/logging/Log.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowNDowM1rOGJrq2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowNDowM1rOGJrq2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwNTg1MA==", "bodyText": "Unused Exception.", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r412805850", "createdAt": "2020-04-22T09:04:03Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/logging/Log.java", "diffHunk": "@@ -155,4 +157,13 @@\n \n    @Message(value = \"Cannot find InitialContextFactory '%s'\", id = 80039)\n    NoInitialContextException noInitialContextFactory(String className);\n+\n+   @Message(value = \"Invalid Unicode sequence '%s'\", id = 80040)\n+   IOException invalidUnicodeSequence(String sequence, @Cause NoSuchElementException e);\n+\n+   @Message(value = \"Decoding hashed password from users property file failed - should not be set as plain-text property file?\", id = 80041)\n+   RealmUnavailableException decodingPasswordFromPropertiesRealmFailed(@Cause Exception e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTMyMzI5OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/security/UserTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowNjoxNVrOGJrxGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowNjoxNVrOGJrxGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwNzQ1MA==", "bodyText": "algorithms = Arrays.stream(parameter.split(\",\")).collect(Collectors.toList());", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r412807450", "createdAt": "2020-04-22T09:06:15Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/UserTool.java", "diffHunk": "@@ -28,22 +41,47 @@\n    public static final String DEFAULT_GROUPS_PROPERTIES_FILE = \"groups.properties\";\n    public static final String DEFAULT_REALM_NAME = \"default\";\n \n+   private static final List<String> ALL_ALGORITHMS = Arrays.asList(\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_1,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_256,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_384,\n+         ScramDigestPassword.ALGORITHM_SCRAM_SHA_512,\n+         DigestPassword.ALGORITHM_DIGEST_MD5,\n+         DigestPassword.ALGORITHM_DIGEST_SHA,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_256,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_384,\n+         DigestPassword.ALGORITHM_DIGEST_SHA_512\n+   );\n+\n    private String username = null;\n    private String password = null;\n    private String realm = DEFAULT_REALM_NAME;\n    private String usersFileName = DEFAULT_USERS_PROPERTIES_FILE;\n    private String groupsFileName = DEFAULT_GROUPS_PROPERTIES_FILE;\n    private List<String> addGroups = new ArrayList<>();\n+   private List<String> algorithms = ALL_ALGORITHMS;\n    private boolean batchMode = false;\n-   private boolean plainText = true;\n+   private boolean plainText = false;\n \n    public static void main(String... args) {\n       UserTool userTool = new UserTool();\n       userTool.run(args);\n    }\n \n+   public UserTool() {\n+      SecurityActions.addSecurityProvider(WildFlyElytronPasswordProvider.getInstance());\n+   }\n+\n    protected void handleArgumentCommand(String command, String parameter, Iterator<String> args) {\n       switch (command) {\n+         case \"-a\":\n+            parameter = args.next();\n+         case \"--algorithms\":\n+            algorithms = new ArrayList<>();\n+            for (String algorithm : parameter.split(\",\")) {\n+               algorithms.add(algorithm);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTM0NTg5OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/security/UserTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxMToxMVrOGJr-gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxMToxMVrOGJr-gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMDg4Mw==", "bodyText": "Should we create this String using Messages.java?", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r412810883", "createdAt": "2020-04-22T09:11:11Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/UserTool.java", "diffHunk": "@@ -166,29 +209,55 @@ protected void runInternal() {\n       }\n    }\n \n-   private static String hashPassword(String username, String password, String realm) {\n+   private String encryptPassword(String username, String realm, String password) {\n       try {\n-         MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n-         byte[] hashed = md5.digest((username + \":\" + realm + \":\" + password).getBytes(StandardCharsets.UTF_8));\n-         return toHex(hashed);\n-      } catch (Exception e) {\n+         StringBuilder sb = new StringBuilder();\n+         for (String algorithm : algorithms) {\n+            PasswordFactory passwordFactory = PasswordFactory.getInstance(algorithm);\n+            AlgorithmParameterSpec spec;\n+            sb.append(algorithm);\n+            sb.append(\":\");\n+            switch (algorithm) {\n+               case ScramDigestPassword.ALGORITHM_SCRAM_SHA_1:\n+               case ScramDigestPassword.ALGORITHM_SCRAM_SHA_256:\n+               case ScramDigestPassword.ALGORITHM_SCRAM_SHA_384:\n+               case ScramDigestPassword.ALGORITHM_SCRAM_SHA_512:\n+                  spec = new IteratedSaltedPasswordAlgorithmSpec(ScramDigestPassword.DEFAULT_ITERATION_COUNT, salt(ScramDigestPassword.DEFAULT_SALT_SIZE));\n+                  break;\n+               case DigestPassword.ALGORITHM_DIGEST_MD5:\n+               case DigestPassword.ALGORITHM_DIGEST_SHA:\n+               case DigestPassword.ALGORITHM_DIGEST_SHA_256:\n+               case DigestPassword.ALGORITHM_DIGEST_SHA_384:\n+               case DigestPassword.ALGORITHM_DIGEST_SHA_512:\n+                  spec = new DigestPasswordAlgorithmSpec(username, realm);\n+                  break;\n+               default:\n+                  throw new IllegalArgumentException(\"Unknown algorithm \" + algorithm);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTM1NDQzOnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/security/UserTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxMzowMlrOGJsDfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxMzowMlrOGJsDfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMjE1Nw==", "bodyText": "groups.put(username, String.join(\",\", addGroups));", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r412812157", "createdAt": "2020-04-22T09:13:02Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/UserTool.java", "diffHunk": "@@ -151,11 +193,12 @@ protected void runInternal() {\n             exit(1);\n          }\n       }\n-      users.put(username, plainText ? password : hashPassword(username, password, realm));\n+      users.put(username, plainText ? password : encryptPassword(username, realm, password));\n       groups.put(username, addGroups.stream().collect(Collectors.joining(\",\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTM2OTkzOnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxNjoyNlrOGJsM_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxNjoyNlrOGJsM_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNDU5MA==", "bodyText": "Unnecessary whitespace between vars.", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r412814590", "createdAt": "2020-04-22T09:16:26Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "diffHunk": "@@ -0,0 +1,500 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.infinispan.server.Server.log;\n+import static org.wildfly.security.provider.util.ProviderUtil.INSTALLED_PROVIDERS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.Provider;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.server.Server;\n+import org.wildfly.common.Assert;\n+import org.wildfly.common.iteration.CodePointIterator;\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.principal.NamePrincipal;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.authz.MapAttributes;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.ClearPasswordSpec;\n+import org.wildfly.security.password.spec.PasswordSpec;\n+\n+/**\n+ * A {@link SecurityRealm} implementation that uses property files with encrypted passwords\n+ *\n+ * @author Darran Lofthouse &lt;darran.lofthouse@jboss.com&gt;\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ */\n+public class EncryptedPropertiesSecurityRealm implements SecurityRealm {\n+\n+   private static final String COMMENT_PREFIX1 = \"#\";\n+   private static final String COMMENT_PREFIX2 = \"!\";\n+   private static final String REALM_COMMENT_PREFIX = \"$REALM_NAME=\";\n+   private static final String COMMENT_SUFFIX = \"$\";\n+   private static final String ALGORITHM_COMMENT_PREFIX = \"$ALGORITHM=\";\n+\n+   private final Supplier<Provider[]> providers;\n+   private final String defaultRealm;\n+   private final boolean plainText;\n+\n+   private final String groupsAttribute;\n+\n+   private final AtomicReference<LoadedState> loadedState = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTM4MjE5OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxOTowN1rOGJsUew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToxOTowN1rOGJsUew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNjUwNw==", "bodyText": "Will produce  a NPE. I assume it should be &&.", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r412816507", "createdAt": "2020-04-22T09:19:07Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "diffHunk": "@@ -0,0 +1,500 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.infinispan.server.Server.log;\n+import static org.wildfly.security.provider.util.ProviderUtil.INSTALLED_PROVIDERS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.Provider;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.server.Server;\n+import org.wildfly.common.Assert;\n+import org.wildfly.common.iteration.CodePointIterator;\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.principal.NamePrincipal;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.authz.MapAttributes;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.ClearPasswordSpec;\n+import org.wildfly.security.password.spec.PasswordSpec;\n+\n+/**\n+ * A {@link SecurityRealm} implementation that uses property files with encrypted passwords\n+ *\n+ * @author Darran Lofthouse &lt;darran.lofthouse@jboss.com&gt;\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ */\n+public class EncryptedPropertiesSecurityRealm implements SecurityRealm {\n+\n+   private static final String COMMENT_PREFIX1 = \"#\";\n+   private static final String COMMENT_PREFIX2 = \"!\";\n+   private static final String REALM_COMMENT_PREFIX = \"$REALM_NAME=\";\n+   private static final String COMMENT_SUFFIX = \"$\";\n+   private static final String ALGORITHM_COMMENT_PREFIX = \"$ALGORITHM=\";\n+\n+   private final Supplier<Provider[]> providers;\n+   private final String defaultRealm;\n+   private final boolean plainText;\n+\n+   private final String groupsAttribute;\n+\n+   private final AtomicReference<LoadedState> loadedState = new AtomicReference<>();\n+\n+   private EncryptedPropertiesSecurityRealm(Builder builder) {\n+      plainText = builder.plainText;\n+      groupsAttribute = builder.groupsAttribute;\n+      providers = builder.providers;\n+      defaultRealm = builder.defaultRealm;\n+   }\n+\n+   @Override\n+   public RealmIdentity getRealmIdentity(final Principal principal) {\n+      if (!(principal instanceof NamePrincipal)) {\n+         log.tracef(\"PropertiesRealm: unsupported principal type: [%s]\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+      final LoadedState loadedState = this.loadedState.get();\n+\n+      final AccountEntry accountEntry = loadedState.getAccounts().get(principal.getName());\n+\n+      if (accountEntry == null) {\n+         log.tracef(\"PropertiesRealm: identity [%s] does not exist\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+\n+      return new RealmIdentity() {\n+\n+         @Override\n+         public Principal getRealmIdentityPrincipal() {\n+            return principal;\n+         }\n+\n+         @Override\n+         public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.canVerify(evidenceType, algorithmName)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType) {\n+            return getCredential(credentialType, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName) {\n+            return getCredential(credentialType, algorithmName, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return credentialType.cast(credential.clone());\n+               }\n+            }\n+            return null;\n+         }\n+\n+         @Override\n+         public boolean verifyEvidence(final Evidence evidence) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null || credential.canVerify(evidence)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTM5MDQ3OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyMTowMVrOGJsZpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyMTowMVrOGJsZpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNzgzMA==", "bodyText": "!accounts.containsKey(userName)", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r412817830", "createdAt": "2020-04-22T09:21:01Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "diffHunk": "@@ -0,0 +1,500 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.infinispan.server.Server.log;\n+import static org.wildfly.security.provider.util.ProviderUtil.INSTALLED_PROVIDERS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.Provider;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.server.Server;\n+import org.wildfly.common.Assert;\n+import org.wildfly.common.iteration.CodePointIterator;\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.principal.NamePrincipal;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.authz.MapAttributes;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.ClearPasswordSpec;\n+import org.wildfly.security.password.spec.PasswordSpec;\n+\n+/**\n+ * A {@link SecurityRealm} implementation that uses property files with encrypted passwords\n+ *\n+ * @author Darran Lofthouse &lt;darran.lofthouse@jboss.com&gt;\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ */\n+public class EncryptedPropertiesSecurityRealm implements SecurityRealm {\n+\n+   private static final String COMMENT_PREFIX1 = \"#\";\n+   private static final String COMMENT_PREFIX2 = \"!\";\n+   private static final String REALM_COMMENT_PREFIX = \"$REALM_NAME=\";\n+   private static final String COMMENT_SUFFIX = \"$\";\n+   private static final String ALGORITHM_COMMENT_PREFIX = \"$ALGORITHM=\";\n+\n+   private final Supplier<Provider[]> providers;\n+   private final String defaultRealm;\n+   private final boolean plainText;\n+\n+   private final String groupsAttribute;\n+\n+   private final AtomicReference<LoadedState> loadedState = new AtomicReference<>();\n+\n+   private EncryptedPropertiesSecurityRealm(Builder builder) {\n+      plainText = builder.plainText;\n+      groupsAttribute = builder.groupsAttribute;\n+      providers = builder.providers;\n+      defaultRealm = builder.defaultRealm;\n+   }\n+\n+   @Override\n+   public RealmIdentity getRealmIdentity(final Principal principal) {\n+      if (!(principal instanceof NamePrincipal)) {\n+         log.tracef(\"PropertiesRealm: unsupported principal type: [%s]\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+      final LoadedState loadedState = this.loadedState.get();\n+\n+      final AccountEntry accountEntry = loadedState.getAccounts().get(principal.getName());\n+\n+      if (accountEntry == null) {\n+         log.tracef(\"PropertiesRealm: identity [%s] does not exist\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+\n+      return new RealmIdentity() {\n+\n+         @Override\n+         public Principal getRealmIdentityPrincipal() {\n+            return principal;\n+         }\n+\n+         @Override\n+         public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.canVerify(evidenceType, algorithmName)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType) {\n+            return getCredential(credentialType, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName) {\n+            return getCredential(credentialType, algorithmName, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return credentialType.cast(credential.clone());\n+               }\n+            }\n+            return null;\n+         }\n+\n+         @Override\n+         public boolean verifyEvidence(final Evidence evidence) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null || credential.canVerify(evidence)) {\n+                  return credential.verify(evidence);\n+               }\n+            }\n+            log.tracef(\"Unable to verify evidence for identity [%s]\", principal);\n+            return false;\n+\n+         }\n+\n+         @Override\n+         public boolean exists() {\n+            return true;\n+         }\n+\n+         @Override\n+         public AuthorizationIdentity getAuthorizationIdentity() {\n+            return AuthorizationIdentity.basicIdentity(new MapAttributes(Collections.singletonMap(groupsAttribute, accountEntry.getGroups())));\n+         }\n+      };\n+   }\n+\n+   private PasswordFactory getPasswordFactory(final String algorithm) {\n+      try {\n+         return PasswordFactory.getInstance(algorithm, providers);\n+      } catch (NoSuchAlgorithmException e) {\n+         throw new IllegalStateException(e);\n+      }\n+   }\n+\n+   @Override\n+   public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+      Assert.checkNotNullParam(\"credentialType\", credentialType);\n+      return PasswordCredential.class.isAssignableFrom(credentialType) ? SupportLevel.POSSIBLY_SUPPORTED : SupportLevel.UNSUPPORTED;\n+   }\n+\n+   @Override\n+   public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+      return PasswordGuessEvidence.class.isAssignableFrom(evidenceType) ? SupportLevel.SUPPORTED : SupportLevel.UNSUPPORTED;\n+   }\n+\n+   /**\n+    * Loads this properties security realm from the given user and groups input streams.\n+    *\n+    * @param usersStream  the input stream from which the realm users are loaded\n+    * @param groupsStream the input stream from which the roles of realm users are loaded\n+    * @throws IOException if there is problem while reading the input streams or invalid content is loaded from streams\n+    */\n+   public void load(InputStream usersStream, InputStream groupsStream) throws IOException {\n+      Map<String, AccountEntry> accounts = new HashMap<>();\n+      Properties groups = new Properties();\n+\n+      if (groupsStream != null) {\n+         try (InputStreamReader is = new InputStreamReader(groupsStream, StandardCharsets.UTF_8);) {\n+            groups.load(is);\n+         }\n+      }\n+\n+      String realmName = null;\n+      String algorithm = \"clear\";\n+      if (usersStream != null) {\n+         try (BufferedReader reader = new BufferedReader(new InputStreamReader(usersStream, StandardCharsets.UTF_8))) {\n+            String currentLine;\n+            while ((currentLine = reader.readLine()) != null) {\n+               final String trimmed = currentLine.trim();\n+               if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(REALM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the realm name.\n+                  int start = trimmed.indexOf(REALM_COMMENT_PREFIX) + REALM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     realmName = trimmed.substring(start, end);\n+                  }\n+               } else if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(ALGORITHM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the algorithm name.\n+                  int start = trimmed.indexOf(ALGORITHM_COMMENT_PREFIX) + ALGORITHM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     algorithm = trimmed.substring(start, end);\n+                  }\n+               } else {\n+                  if (!(trimmed.startsWith(COMMENT_PREFIX1) || trimmed.startsWith(COMMENT_PREFIX2))) {\n+                     String username = null;\n+                     StringBuilder builder = new StringBuilder();\n+\n+                     CodePointIterator it = CodePointIterator.ofString(trimmed);\n+                     while (it.hasNext()) {\n+                        int cp = it.next();\n+                        if (cp == '\\\\' && it.hasNext()) { // escape\n+                           //might be regular escape of regex like characters \\\\t \\\\! or unicode \\\\uxxxx\n+                           int marker = it.next();\n+                           if (marker != 'u') {\n+                              builder.appendCodePoint(marker);\n+                           } else {\n+                              StringBuilder hex = new StringBuilder();\n+                              try {\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 builder.appendCodePoint((char) Integer.parseInt(hex.toString(), 16));\n+                              } catch (NoSuchElementException nsee) {\n+                                 throw Server.log.invalidUnicodeSequence(hex.toString(), nsee);\n+                              }\n+                           }\n+                        } else if (username == null && (cp == '=' || cp == ':')) { // username-password delimiter\n+                           username = builder.toString().trim();\n+                           builder = new StringBuilder();\n+                        } else {\n+                           builder.appendCodePoint(cp);\n+                        }\n+                     }\n+                     if (username != null) { // end of line and delimiter was read\n+                        List<Credential> credentials = new ArrayList<>();\n+                        switch (algorithm) {\n+                           case \"encrypted\":\n+                              String[] passwords = builder.toString().trim().split(\";\");\n+                              for (String password : passwords) {\n+                                 int colon = password.indexOf(':');\n+                                 byte[] passwordBytes = CodePointIterator.ofChars(password.substring(colon + 1).toCharArray()).base64Decode().drain();\n+                                 PasswordFactory factory = getPasswordFactory(password.substring(0, colon));\n+                                 PasswordSpec passwordSpec = BasicPasswordSpecEncoding.decode(passwordBytes);\n+                                 try {\n+                                    credentials.add(new PasswordCredential(factory.generatePassword(passwordSpec)));\n+                                 } catch (InvalidKeySpecException e) {\n+                                    throw new IOException(e);\n+                                 }\n+                              }\n+                              break;\n+                           case \"clear\":\n+                              PasswordFactory factory = getPasswordFactory(\"clear\");\n+                              try {\n+                                 credentials.add(new PasswordCredential(factory.generatePassword(new ClearPasswordSpec(builder.toString().trim().toCharArray()))));\n+                              } catch (InvalidKeySpecException e) {\n+                                 throw new IOException(e);\n+                              }\n+                              break;\n+                        }\n+\n+                        accounts.put(username, new AccountEntry(username, credentials, groups.getProperty(username)));\n+                     }\n+                  }\n+               }\n+            }\n+         }\n+\n+         if (realmName == null) {\n+            if (defaultRealm != null || plainText) {\n+               realmName = defaultRealm;\n+            } else {\n+               throw log.noRealmFoundInProperties();\n+            }\n+         }\n+      }\n+\n+      // users, which are in groups file only\n+      for (String userName : groups.stringPropertyNames()) {\n+         if (accounts.containsKey(userName) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTM5NTcwOnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyMjowNlrOGJscwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODoxNDo1MlrOGKcn3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxODYyNg==", "bodyText": "realmName is never used.", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r412818626", "createdAt": "2020-04-22T09:22:06Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "diffHunk": "@@ -0,0 +1,500 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.infinispan.server.Server.log;\n+import static org.wildfly.security.provider.util.ProviderUtil.INSTALLED_PROVIDERS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.Provider;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.server.Server;\n+import org.wildfly.common.Assert;\n+import org.wildfly.common.iteration.CodePointIterator;\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.principal.NamePrincipal;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.authz.MapAttributes;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.ClearPasswordSpec;\n+import org.wildfly.security.password.spec.PasswordSpec;\n+\n+/**\n+ * A {@link SecurityRealm} implementation that uses property files with encrypted passwords\n+ *\n+ * @author Darran Lofthouse &lt;darran.lofthouse@jboss.com&gt;\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ */\n+public class EncryptedPropertiesSecurityRealm implements SecurityRealm {\n+\n+   private static final String COMMENT_PREFIX1 = \"#\";\n+   private static final String COMMENT_PREFIX2 = \"!\";\n+   private static final String REALM_COMMENT_PREFIX = \"$REALM_NAME=\";\n+   private static final String COMMENT_SUFFIX = \"$\";\n+   private static final String ALGORITHM_COMMENT_PREFIX = \"$ALGORITHM=\";\n+\n+   private final Supplier<Provider[]> providers;\n+   private final String defaultRealm;\n+   private final boolean plainText;\n+\n+   private final String groupsAttribute;\n+\n+   private final AtomicReference<LoadedState> loadedState = new AtomicReference<>();\n+\n+   private EncryptedPropertiesSecurityRealm(Builder builder) {\n+      plainText = builder.plainText;\n+      groupsAttribute = builder.groupsAttribute;\n+      providers = builder.providers;\n+      defaultRealm = builder.defaultRealm;\n+   }\n+\n+   @Override\n+   public RealmIdentity getRealmIdentity(final Principal principal) {\n+      if (!(principal instanceof NamePrincipal)) {\n+         log.tracef(\"PropertiesRealm: unsupported principal type: [%s]\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+      final LoadedState loadedState = this.loadedState.get();\n+\n+      final AccountEntry accountEntry = loadedState.getAccounts().get(principal.getName());\n+\n+      if (accountEntry == null) {\n+         log.tracef(\"PropertiesRealm: identity [%s] does not exist\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+\n+      return new RealmIdentity() {\n+\n+         @Override\n+         public Principal getRealmIdentityPrincipal() {\n+            return principal;\n+         }\n+\n+         @Override\n+         public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.canVerify(evidenceType, algorithmName)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType) {\n+            return getCredential(credentialType, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName) {\n+            return getCredential(credentialType, algorithmName, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return credentialType.cast(credential.clone());\n+               }\n+            }\n+            return null;\n+         }\n+\n+         @Override\n+         public boolean verifyEvidence(final Evidence evidence) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null || credential.canVerify(evidence)) {\n+                  return credential.verify(evidence);\n+               }\n+            }\n+            log.tracef(\"Unable to verify evidence for identity [%s]\", principal);\n+            return false;\n+\n+         }\n+\n+         @Override\n+         public boolean exists() {\n+            return true;\n+         }\n+\n+         @Override\n+         public AuthorizationIdentity getAuthorizationIdentity() {\n+            return AuthorizationIdentity.basicIdentity(new MapAttributes(Collections.singletonMap(groupsAttribute, accountEntry.getGroups())));\n+         }\n+      };\n+   }\n+\n+   private PasswordFactory getPasswordFactory(final String algorithm) {\n+      try {\n+         return PasswordFactory.getInstance(algorithm, providers);\n+      } catch (NoSuchAlgorithmException e) {\n+         throw new IllegalStateException(e);\n+      }\n+   }\n+\n+   @Override\n+   public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+      Assert.checkNotNullParam(\"credentialType\", credentialType);\n+      return PasswordCredential.class.isAssignableFrom(credentialType) ? SupportLevel.POSSIBLY_SUPPORTED : SupportLevel.UNSUPPORTED;\n+   }\n+\n+   @Override\n+   public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+      return PasswordGuessEvidence.class.isAssignableFrom(evidenceType) ? SupportLevel.SUPPORTED : SupportLevel.UNSUPPORTED;\n+   }\n+\n+   /**\n+    * Loads this properties security realm from the given user and groups input streams.\n+    *\n+    * @param usersStream  the input stream from which the realm users are loaded\n+    * @param groupsStream the input stream from which the roles of realm users are loaded\n+    * @throws IOException if there is problem while reading the input streams or invalid content is loaded from streams\n+    */\n+   public void load(InputStream usersStream, InputStream groupsStream) throws IOException {\n+      Map<String, AccountEntry> accounts = new HashMap<>();\n+      Properties groups = new Properties();\n+\n+      if (groupsStream != null) {\n+         try (InputStreamReader is = new InputStreamReader(groupsStream, StandardCharsets.UTF_8);) {\n+            groups.load(is);\n+         }\n+      }\n+\n+      String realmName = null;\n+      String algorithm = \"clear\";\n+      if (usersStream != null) {\n+         try (BufferedReader reader = new BufferedReader(new InputStreamReader(usersStream, StandardCharsets.UTF_8))) {\n+            String currentLine;\n+            while ((currentLine = reader.readLine()) != null) {\n+               final String trimmed = currentLine.trim();\n+               if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(REALM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the realm name.\n+                  int start = trimmed.indexOf(REALM_COMMENT_PREFIX) + REALM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     realmName = trimmed.substring(start, end);\n+                  }\n+               } else if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(ALGORITHM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the algorithm name.\n+                  int start = trimmed.indexOf(ALGORITHM_COMMENT_PREFIX) + ALGORITHM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     algorithm = trimmed.substring(start, end);\n+                  }\n+               } else {\n+                  if (!(trimmed.startsWith(COMMENT_PREFIX1) || trimmed.startsWith(COMMENT_PREFIX2))) {\n+                     String username = null;\n+                     StringBuilder builder = new StringBuilder();\n+\n+                     CodePointIterator it = CodePointIterator.ofString(trimmed);\n+                     while (it.hasNext()) {\n+                        int cp = it.next();\n+                        if (cp == '\\\\' && it.hasNext()) { // escape\n+                           //might be regular escape of regex like characters \\\\t \\\\! or unicode \\\\uxxxx\n+                           int marker = it.next();\n+                           if (marker != 'u') {\n+                              builder.appendCodePoint(marker);\n+                           } else {\n+                              StringBuilder hex = new StringBuilder();\n+                              try {\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 builder.appendCodePoint((char) Integer.parseInt(hex.toString(), 16));\n+                              } catch (NoSuchElementException nsee) {\n+                                 throw Server.log.invalidUnicodeSequence(hex.toString(), nsee);\n+                              }\n+                           }\n+                        } else if (username == null && (cp == '=' || cp == ':')) { // username-password delimiter\n+                           username = builder.toString().trim();\n+                           builder = new StringBuilder();\n+                        } else {\n+                           builder.appendCodePoint(cp);\n+                        }\n+                     }\n+                     if (username != null) { // end of line and delimiter was read\n+                        List<Credential> credentials = new ArrayList<>();\n+                        switch (algorithm) {\n+                           case \"encrypted\":\n+                              String[] passwords = builder.toString().trim().split(\";\");\n+                              for (String password : passwords) {\n+                                 int colon = password.indexOf(':');\n+                                 byte[] passwordBytes = CodePointIterator.ofChars(password.substring(colon + 1).toCharArray()).base64Decode().drain();\n+                                 PasswordFactory factory = getPasswordFactory(password.substring(0, colon));\n+                                 PasswordSpec passwordSpec = BasicPasswordSpecEncoding.decode(passwordBytes);\n+                                 try {\n+                                    credentials.add(new PasswordCredential(factory.generatePassword(passwordSpec)));\n+                                 } catch (InvalidKeySpecException e) {\n+                                    throw new IOException(e);\n+                                 }\n+                              }\n+                              break;\n+                           case \"clear\":\n+                              PasswordFactory factory = getPasswordFactory(\"clear\");\n+                              try {\n+                                 credentials.add(new PasswordCredential(factory.generatePassword(new ClearPasswordSpec(builder.toString().trim().toCharArray()))));\n+                              } catch (InvalidKeySpecException e) {\n+                                 throw new IOException(e);\n+                              }\n+                              break;\n+                        }\n+\n+                        accounts.put(username, new AccountEntry(username, credentials, groups.getProperty(username)));\n+                     }\n+                  }\n+               }\n+            }\n+         }\n+\n+         if (realmName == null) {\n+            if (defaultRealm != null || plainText) {\n+               realmName = defaultRealm;\n+            } else {\n+               throw log.noRealmFoundInProperties();\n+            }\n+         }\n+      }\n+\n+      // users, which are in groups file only\n+      for (String userName : groups.stringPropertyNames()) {\n+         if (accounts.containsKey(userName) == false) {\n+            accounts.put(userName, new AccountEntry(userName, null, groups.getProperty(userName)));\n+         }\n+      }\n+\n+      loadedState.set(new LoadedState(accounts, realmName, System.currentTimeMillis()));\n+   }\n+\n+   /**\n+    * Get the time when the realm was last loaded.\n+    *\n+    * @return the time when the realm was last loaded (number of milliseconds since the standard base time)\n+    */\n+   public long getLoadTime() {\n+      return loadedState.get().getLoadTime();\n+   }\n+\n+   /**\n+    * Obtain a new {@link Builder} capable of building a {@link EncryptedPropertiesSecurityRealm}.\n+    *\n+    * @return a new {@link Builder} capable of building a {@link EncryptedPropertiesSecurityRealm}.\n+    */\n+   public static Builder builder() {\n+      return new Builder();\n+   }\n+\n+   /**\n+    * A builder for legacy properties security realms.\n+    */\n+   public static class Builder {\n+\n+      private Supplier<Provider[]> providers = INSTALLED_PROVIDERS;\n+      private InputStream usersStream;\n+      private InputStream groupsStream;\n+      private String defaultRealm = null;\n+      private boolean plainText;\n+      private String groupsAttribute = \"groups\";\n+\n+      Builder() {\n+      }\n+\n+      /**\n+       * Set the supplier for {@link Provider} instanced for use bu the realm.\n+       *\n+       * @param providers the supplier for {@link Provider} instanced for use bu the realm.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setProviders(Supplier<Provider[]> providers) {\n+         this.providers = providers;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set the {@link InputStream} to use to load the users.\n+       *\n+       * @param usersStream the {@link InputStream} to use to load the users.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setUsersStream(InputStream usersStream) {\n+         this.usersStream = usersStream;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set the {@link InputStream} to use to load the group information.\n+       *\n+       * @param groupsStream the {@link InputStream} to use to load the group information.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setGroupsStream(InputStream groupsStream) {\n+         this.groupsStream = groupsStream;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Where this realm returns an {@link AuthorizationIdentity} set the key on the Attributes that will be used to\n+       * hold the group membership information.\n+       *\n+       * @param groupsAttribute the key on the Attributes that will be used to hold the group membership information.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setGroupsAttribute(final String groupsAttribute) {\n+         this.groupsAttribute = groupsAttribute;\n+\n+         return this;\n+      }\n+\n+\n+      /**\n+       * Set the default realm name to use if no realm name is discovered in the properties file.\n+       *\n+       * @param defaultRealm the default realm name if one is not discovered in the properties file.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setDefaultRealm(String defaultRealm) {\n+         this.defaultRealm = defaultRealm;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set format of users property file - if the passwords are stored in plain text. Otherwise is HEX( MD5( username\n+       * \":\" realm \":\" password ) ) expected.\n+       *\n+       * @param plainText if the passwords are stored in plain text.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setPlainText(boolean plainText) {\n+         this.plainText = plainText;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Builds the {@link EncryptedPropertiesSecurityRealm}.\n+       *\n+       * @return built {@link EncryptedPropertiesSecurityRealm}\n+       * @throws IOException                   when loading of property files fails\n+       * @throws java.io.FileNotFoundException when property file does not exist\n+       * @throws RealmUnavailableException     when property file of users does not contain realm name specification\n+       */\n+      public EncryptedPropertiesSecurityRealm build() throws IOException {\n+         EncryptedPropertiesSecurityRealm realm = new EncryptedPropertiesSecurityRealm(this);\n+         realm.load(usersStream, groupsStream);\n+\n+         return realm;\n+      }\n+\n+   }\n+\n+   private static class LoadedState {\n+\n+      private final Map<String, AccountEntry> accounts;\n+      private final String realmName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 433}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYwNzkwMw==", "bodyText": "I'd rather keep it around in case we may want to use it. It's code that comes from Elytron's original implementation.", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r413607903", "createdAt": "2020-04-23T08:14:52Z", "author": {"login": "tristantarrant"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "diffHunk": "@@ -0,0 +1,500 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.infinispan.server.Server.log;\n+import static org.wildfly.security.provider.util.ProviderUtil.INSTALLED_PROVIDERS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.Provider;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.server.Server;\n+import org.wildfly.common.Assert;\n+import org.wildfly.common.iteration.CodePointIterator;\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.principal.NamePrincipal;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.authz.MapAttributes;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.ClearPasswordSpec;\n+import org.wildfly.security.password.spec.PasswordSpec;\n+\n+/**\n+ * A {@link SecurityRealm} implementation that uses property files with encrypted passwords\n+ *\n+ * @author Darran Lofthouse &lt;darran.lofthouse@jboss.com&gt;\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ */\n+public class EncryptedPropertiesSecurityRealm implements SecurityRealm {\n+\n+   private static final String COMMENT_PREFIX1 = \"#\";\n+   private static final String COMMENT_PREFIX2 = \"!\";\n+   private static final String REALM_COMMENT_PREFIX = \"$REALM_NAME=\";\n+   private static final String COMMENT_SUFFIX = \"$\";\n+   private static final String ALGORITHM_COMMENT_PREFIX = \"$ALGORITHM=\";\n+\n+   private final Supplier<Provider[]> providers;\n+   private final String defaultRealm;\n+   private final boolean plainText;\n+\n+   private final String groupsAttribute;\n+\n+   private final AtomicReference<LoadedState> loadedState = new AtomicReference<>();\n+\n+   private EncryptedPropertiesSecurityRealm(Builder builder) {\n+      plainText = builder.plainText;\n+      groupsAttribute = builder.groupsAttribute;\n+      providers = builder.providers;\n+      defaultRealm = builder.defaultRealm;\n+   }\n+\n+   @Override\n+   public RealmIdentity getRealmIdentity(final Principal principal) {\n+      if (!(principal instanceof NamePrincipal)) {\n+         log.tracef(\"PropertiesRealm: unsupported principal type: [%s]\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+      final LoadedState loadedState = this.loadedState.get();\n+\n+      final AccountEntry accountEntry = loadedState.getAccounts().get(principal.getName());\n+\n+      if (accountEntry == null) {\n+         log.tracef(\"PropertiesRealm: identity [%s] does not exist\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+\n+      return new RealmIdentity() {\n+\n+         @Override\n+         public Principal getRealmIdentityPrincipal() {\n+            return principal;\n+         }\n+\n+         @Override\n+         public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.canVerify(evidenceType, algorithmName)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType) {\n+            return getCredential(credentialType, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName) {\n+            return getCredential(credentialType, algorithmName, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return credentialType.cast(credential.clone());\n+               }\n+            }\n+            return null;\n+         }\n+\n+         @Override\n+         public boolean verifyEvidence(final Evidence evidence) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null || credential.canVerify(evidence)) {\n+                  return credential.verify(evidence);\n+               }\n+            }\n+            log.tracef(\"Unable to verify evidence for identity [%s]\", principal);\n+            return false;\n+\n+         }\n+\n+         @Override\n+         public boolean exists() {\n+            return true;\n+         }\n+\n+         @Override\n+         public AuthorizationIdentity getAuthorizationIdentity() {\n+            return AuthorizationIdentity.basicIdentity(new MapAttributes(Collections.singletonMap(groupsAttribute, accountEntry.getGroups())));\n+         }\n+      };\n+   }\n+\n+   private PasswordFactory getPasswordFactory(final String algorithm) {\n+      try {\n+         return PasswordFactory.getInstance(algorithm, providers);\n+      } catch (NoSuchAlgorithmException e) {\n+         throw new IllegalStateException(e);\n+      }\n+   }\n+\n+   @Override\n+   public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+      Assert.checkNotNullParam(\"credentialType\", credentialType);\n+      return PasswordCredential.class.isAssignableFrom(credentialType) ? SupportLevel.POSSIBLY_SUPPORTED : SupportLevel.UNSUPPORTED;\n+   }\n+\n+   @Override\n+   public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+      return PasswordGuessEvidence.class.isAssignableFrom(evidenceType) ? SupportLevel.SUPPORTED : SupportLevel.UNSUPPORTED;\n+   }\n+\n+   /**\n+    * Loads this properties security realm from the given user and groups input streams.\n+    *\n+    * @param usersStream  the input stream from which the realm users are loaded\n+    * @param groupsStream the input stream from which the roles of realm users are loaded\n+    * @throws IOException if there is problem while reading the input streams or invalid content is loaded from streams\n+    */\n+   public void load(InputStream usersStream, InputStream groupsStream) throws IOException {\n+      Map<String, AccountEntry> accounts = new HashMap<>();\n+      Properties groups = new Properties();\n+\n+      if (groupsStream != null) {\n+         try (InputStreamReader is = new InputStreamReader(groupsStream, StandardCharsets.UTF_8);) {\n+            groups.load(is);\n+         }\n+      }\n+\n+      String realmName = null;\n+      String algorithm = \"clear\";\n+      if (usersStream != null) {\n+         try (BufferedReader reader = new BufferedReader(new InputStreamReader(usersStream, StandardCharsets.UTF_8))) {\n+            String currentLine;\n+            while ((currentLine = reader.readLine()) != null) {\n+               final String trimmed = currentLine.trim();\n+               if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(REALM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the realm name.\n+                  int start = trimmed.indexOf(REALM_COMMENT_PREFIX) + REALM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     realmName = trimmed.substring(start, end);\n+                  }\n+               } else if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(ALGORITHM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the algorithm name.\n+                  int start = trimmed.indexOf(ALGORITHM_COMMENT_PREFIX) + ALGORITHM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     algorithm = trimmed.substring(start, end);\n+                  }\n+               } else {\n+                  if (!(trimmed.startsWith(COMMENT_PREFIX1) || trimmed.startsWith(COMMENT_PREFIX2))) {\n+                     String username = null;\n+                     StringBuilder builder = new StringBuilder();\n+\n+                     CodePointIterator it = CodePointIterator.ofString(trimmed);\n+                     while (it.hasNext()) {\n+                        int cp = it.next();\n+                        if (cp == '\\\\' && it.hasNext()) { // escape\n+                           //might be regular escape of regex like characters \\\\t \\\\! or unicode \\\\uxxxx\n+                           int marker = it.next();\n+                           if (marker != 'u') {\n+                              builder.appendCodePoint(marker);\n+                           } else {\n+                              StringBuilder hex = new StringBuilder();\n+                              try {\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 builder.appendCodePoint((char) Integer.parseInt(hex.toString(), 16));\n+                              } catch (NoSuchElementException nsee) {\n+                                 throw Server.log.invalidUnicodeSequence(hex.toString(), nsee);\n+                              }\n+                           }\n+                        } else if (username == null && (cp == '=' || cp == ':')) { // username-password delimiter\n+                           username = builder.toString().trim();\n+                           builder = new StringBuilder();\n+                        } else {\n+                           builder.appendCodePoint(cp);\n+                        }\n+                     }\n+                     if (username != null) { // end of line and delimiter was read\n+                        List<Credential> credentials = new ArrayList<>();\n+                        switch (algorithm) {\n+                           case \"encrypted\":\n+                              String[] passwords = builder.toString().trim().split(\";\");\n+                              for (String password : passwords) {\n+                                 int colon = password.indexOf(':');\n+                                 byte[] passwordBytes = CodePointIterator.ofChars(password.substring(colon + 1).toCharArray()).base64Decode().drain();\n+                                 PasswordFactory factory = getPasswordFactory(password.substring(0, colon));\n+                                 PasswordSpec passwordSpec = BasicPasswordSpecEncoding.decode(passwordBytes);\n+                                 try {\n+                                    credentials.add(new PasswordCredential(factory.generatePassword(passwordSpec)));\n+                                 } catch (InvalidKeySpecException e) {\n+                                    throw new IOException(e);\n+                                 }\n+                              }\n+                              break;\n+                           case \"clear\":\n+                              PasswordFactory factory = getPasswordFactory(\"clear\");\n+                              try {\n+                                 credentials.add(new PasswordCredential(factory.generatePassword(new ClearPasswordSpec(builder.toString().trim().toCharArray()))));\n+                              } catch (InvalidKeySpecException e) {\n+                                 throw new IOException(e);\n+                              }\n+                              break;\n+                        }\n+\n+                        accounts.put(username, new AccountEntry(username, credentials, groups.getProperty(username)));\n+                     }\n+                  }\n+               }\n+            }\n+         }\n+\n+         if (realmName == null) {\n+            if (defaultRealm != null || plainText) {\n+               realmName = defaultRealm;\n+            } else {\n+               throw log.noRealmFoundInProperties();\n+            }\n+         }\n+      }\n+\n+      // users, which are in groups file only\n+      for (String userName : groups.stringPropertyNames()) {\n+         if (accounts.containsKey(userName) == false) {\n+            accounts.put(userName, new AccountEntry(userName, null, groups.getProperty(userName)));\n+         }\n+      }\n+\n+      loadedState.set(new LoadedState(accounts, realmName, System.currentTimeMillis()));\n+   }\n+\n+   /**\n+    * Get the time when the realm was last loaded.\n+    *\n+    * @return the time when the realm was last loaded (number of milliseconds since the standard base time)\n+    */\n+   public long getLoadTime() {\n+      return loadedState.get().getLoadTime();\n+   }\n+\n+   /**\n+    * Obtain a new {@link Builder} capable of building a {@link EncryptedPropertiesSecurityRealm}.\n+    *\n+    * @return a new {@link Builder} capable of building a {@link EncryptedPropertiesSecurityRealm}.\n+    */\n+   public static Builder builder() {\n+      return new Builder();\n+   }\n+\n+   /**\n+    * A builder for legacy properties security realms.\n+    */\n+   public static class Builder {\n+\n+      private Supplier<Provider[]> providers = INSTALLED_PROVIDERS;\n+      private InputStream usersStream;\n+      private InputStream groupsStream;\n+      private String defaultRealm = null;\n+      private boolean plainText;\n+      private String groupsAttribute = \"groups\";\n+\n+      Builder() {\n+      }\n+\n+      /**\n+       * Set the supplier for {@link Provider} instanced for use bu the realm.\n+       *\n+       * @param providers the supplier for {@link Provider} instanced for use bu the realm.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setProviders(Supplier<Provider[]> providers) {\n+         this.providers = providers;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set the {@link InputStream} to use to load the users.\n+       *\n+       * @param usersStream the {@link InputStream} to use to load the users.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setUsersStream(InputStream usersStream) {\n+         this.usersStream = usersStream;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set the {@link InputStream} to use to load the group information.\n+       *\n+       * @param groupsStream the {@link InputStream} to use to load the group information.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setGroupsStream(InputStream groupsStream) {\n+         this.groupsStream = groupsStream;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Where this realm returns an {@link AuthorizationIdentity} set the key on the Attributes that will be used to\n+       * hold the group membership information.\n+       *\n+       * @param groupsAttribute the key on the Attributes that will be used to hold the group membership information.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setGroupsAttribute(final String groupsAttribute) {\n+         this.groupsAttribute = groupsAttribute;\n+\n+         return this;\n+      }\n+\n+\n+      /**\n+       * Set the default realm name to use if no realm name is discovered in the properties file.\n+       *\n+       * @param defaultRealm the default realm name if one is not discovered in the properties file.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setDefaultRealm(String defaultRealm) {\n+         this.defaultRealm = defaultRealm;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set format of users property file - if the passwords are stored in plain text. Otherwise is HEX( MD5( username\n+       * \":\" realm \":\" password ) ) expected.\n+       *\n+       * @param plainText if the passwords are stored in plain text.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setPlainText(boolean plainText) {\n+         this.plainText = plainText;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Builds the {@link EncryptedPropertiesSecurityRealm}.\n+       *\n+       * @return built {@link EncryptedPropertiesSecurityRealm}\n+       * @throws IOException                   when loading of property files fails\n+       * @throws java.io.FileNotFoundException when property file does not exist\n+       * @throws RealmUnavailableException     when property file of users does not contain realm name specification\n+       */\n+      public EncryptedPropertiesSecurityRealm build() throws IOException {\n+         EncryptedPropertiesSecurityRealm realm = new EncryptedPropertiesSecurityRealm(this);\n+         realm.load(usersStream, groupsStream);\n+\n+         return realm;\n+      }\n+\n+   }\n+\n+   private static class LoadedState {\n+\n+      private final Map<String, AccountEntry> accounts;\n+      private final String realmName;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxODYyNg=="}, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 433}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTQyMDUwOnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyNzozMFrOGJsrpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyNzozMFrOGJsrpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjQzNg==", "bodyText": "Can be simplified to:\n         return Arrays.stream(groups.split(\",\"))\n               .map(String::trim)\n               .filter(s -> !s.isEmpty())\n               .collect(Collectors.collectingAndThen(Collectors.toSet(), Collections::unmodifiableSet));", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r412822436", "createdAt": "2020-04-22T09:27:30Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "diffHunk": "@@ -0,0 +1,500 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.infinispan.server.Server.log;\n+import static org.wildfly.security.provider.util.ProviderUtil.INSTALLED_PROVIDERS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.Provider;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.server.Server;\n+import org.wildfly.common.Assert;\n+import org.wildfly.common.iteration.CodePointIterator;\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.principal.NamePrincipal;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.authz.MapAttributes;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.ClearPasswordSpec;\n+import org.wildfly.security.password.spec.PasswordSpec;\n+\n+/**\n+ * A {@link SecurityRealm} implementation that uses property files with encrypted passwords\n+ *\n+ * @author Darran Lofthouse &lt;darran.lofthouse@jboss.com&gt;\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ */\n+public class EncryptedPropertiesSecurityRealm implements SecurityRealm {\n+\n+   private static final String COMMENT_PREFIX1 = \"#\";\n+   private static final String COMMENT_PREFIX2 = \"!\";\n+   private static final String REALM_COMMENT_PREFIX = \"$REALM_NAME=\";\n+   private static final String COMMENT_SUFFIX = \"$\";\n+   private static final String ALGORITHM_COMMENT_PREFIX = \"$ALGORITHM=\";\n+\n+   private final Supplier<Provider[]> providers;\n+   private final String defaultRealm;\n+   private final boolean plainText;\n+\n+   private final String groupsAttribute;\n+\n+   private final AtomicReference<LoadedState> loadedState = new AtomicReference<>();\n+\n+   private EncryptedPropertiesSecurityRealm(Builder builder) {\n+      plainText = builder.plainText;\n+      groupsAttribute = builder.groupsAttribute;\n+      providers = builder.providers;\n+      defaultRealm = builder.defaultRealm;\n+   }\n+\n+   @Override\n+   public RealmIdentity getRealmIdentity(final Principal principal) {\n+      if (!(principal instanceof NamePrincipal)) {\n+         log.tracef(\"PropertiesRealm: unsupported principal type: [%s]\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+      final LoadedState loadedState = this.loadedState.get();\n+\n+      final AccountEntry accountEntry = loadedState.getAccounts().get(principal.getName());\n+\n+      if (accountEntry == null) {\n+         log.tracef(\"PropertiesRealm: identity [%s] does not exist\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+\n+      return new RealmIdentity() {\n+\n+         @Override\n+         public Principal getRealmIdentityPrincipal() {\n+            return principal;\n+         }\n+\n+         @Override\n+         public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.canVerify(evidenceType, algorithmName)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType) {\n+            return getCredential(credentialType, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName) {\n+            return getCredential(credentialType, algorithmName, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return credentialType.cast(credential.clone());\n+               }\n+            }\n+            return null;\n+         }\n+\n+         @Override\n+         public boolean verifyEvidence(final Evidence evidence) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null || credential.canVerify(evidence)) {\n+                  return credential.verify(evidence);\n+               }\n+            }\n+            log.tracef(\"Unable to verify evidence for identity [%s]\", principal);\n+            return false;\n+\n+         }\n+\n+         @Override\n+         public boolean exists() {\n+            return true;\n+         }\n+\n+         @Override\n+         public AuthorizationIdentity getAuthorizationIdentity() {\n+            return AuthorizationIdentity.basicIdentity(new MapAttributes(Collections.singletonMap(groupsAttribute, accountEntry.getGroups())));\n+         }\n+      };\n+   }\n+\n+   private PasswordFactory getPasswordFactory(final String algorithm) {\n+      try {\n+         return PasswordFactory.getInstance(algorithm, providers);\n+      } catch (NoSuchAlgorithmException e) {\n+         throw new IllegalStateException(e);\n+      }\n+   }\n+\n+   @Override\n+   public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+      Assert.checkNotNullParam(\"credentialType\", credentialType);\n+      return PasswordCredential.class.isAssignableFrom(credentialType) ? SupportLevel.POSSIBLY_SUPPORTED : SupportLevel.UNSUPPORTED;\n+   }\n+\n+   @Override\n+   public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+      return PasswordGuessEvidence.class.isAssignableFrom(evidenceType) ? SupportLevel.SUPPORTED : SupportLevel.UNSUPPORTED;\n+   }\n+\n+   /**\n+    * Loads this properties security realm from the given user and groups input streams.\n+    *\n+    * @param usersStream  the input stream from which the realm users are loaded\n+    * @param groupsStream the input stream from which the roles of realm users are loaded\n+    * @throws IOException if there is problem while reading the input streams or invalid content is loaded from streams\n+    */\n+   public void load(InputStream usersStream, InputStream groupsStream) throws IOException {\n+      Map<String, AccountEntry> accounts = new HashMap<>();\n+      Properties groups = new Properties();\n+\n+      if (groupsStream != null) {\n+         try (InputStreamReader is = new InputStreamReader(groupsStream, StandardCharsets.UTF_8);) {\n+            groups.load(is);\n+         }\n+      }\n+\n+      String realmName = null;\n+      String algorithm = \"clear\";\n+      if (usersStream != null) {\n+         try (BufferedReader reader = new BufferedReader(new InputStreamReader(usersStream, StandardCharsets.UTF_8))) {\n+            String currentLine;\n+            while ((currentLine = reader.readLine()) != null) {\n+               final String trimmed = currentLine.trim();\n+               if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(REALM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the realm name.\n+                  int start = trimmed.indexOf(REALM_COMMENT_PREFIX) + REALM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     realmName = trimmed.substring(start, end);\n+                  }\n+               } else if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(ALGORITHM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the algorithm name.\n+                  int start = trimmed.indexOf(ALGORITHM_COMMENT_PREFIX) + ALGORITHM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     algorithm = trimmed.substring(start, end);\n+                  }\n+               } else {\n+                  if (!(trimmed.startsWith(COMMENT_PREFIX1) || trimmed.startsWith(COMMENT_PREFIX2))) {\n+                     String username = null;\n+                     StringBuilder builder = new StringBuilder();\n+\n+                     CodePointIterator it = CodePointIterator.ofString(trimmed);\n+                     while (it.hasNext()) {\n+                        int cp = it.next();\n+                        if (cp == '\\\\' && it.hasNext()) { // escape\n+                           //might be regular escape of regex like characters \\\\t \\\\! or unicode \\\\uxxxx\n+                           int marker = it.next();\n+                           if (marker != 'u') {\n+                              builder.appendCodePoint(marker);\n+                           } else {\n+                              StringBuilder hex = new StringBuilder();\n+                              try {\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 builder.appendCodePoint((char) Integer.parseInt(hex.toString(), 16));\n+                              } catch (NoSuchElementException nsee) {\n+                                 throw Server.log.invalidUnicodeSequence(hex.toString(), nsee);\n+                              }\n+                           }\n+                        } else if (username == null && (cp == '=' || cp == ':')) { // username-password delimiter\n+                           username = builder.toString().trim();\n+                           builder = new StringBuilder();\n+                        } else {\n+                           builder.appendCodePoint(cp);\n+                        }\n+                     }\n+                     if (username != null) { // end of line and delimiter was read\n+                        List<Credential> credentials = new ArrayList<>();\n+                        switch (algorithm) {\n+                           case \"encrypted\":\n+                              String[] passwords = builder.toString().trim().split(\";\");\n+                              for (String password : passwords) {\n+                                 int colon = password.indexOf(':');\n+                                 byte[] passwordBytes = CodePointIterator.ofChars(password.substring(colon + 1).toCharArray()).base64Decode().drain();\n+                                 PasswordFactory factory = getPasswordFactory(password.substring(0, colon));\n+                                 PasswordSpec passwordSpec = BasicPasswordSpecEncoding.decode(passwordBytes);\n+                                 try {\n+                                    credentials.add(new PasswordCredential(factory.generatePassword(passwordSpec)));\n+                                 } catch (InvalidKeySpecException e) {\n+                                    throw new IOException(e);\n+                                 }\n+                              }\n+                              break;\n+                           case \"clear\":\n+                              PasswordFactory factory = getPasswordFactory(\"clear\");\n+                              try {\n+                                 credentials.add(new PasswordCredential(factory.generatePassword(new ClearPasswordSpec(builder.toString().trim().toCharArray()))));\n+                              } catch (InvalidKeySpecException e) {\n+                                 throw new IOException(e);\n+                              }\n+                              break;\n+                        }\n+\n+                        accounts.put(username, new AccountEntry(username, credentials, groups.getProperty(username)));\n+                     }\n+                  }\n+               }\n+            }\n+         }\n+\n+         if (realmName == null) {\n+            if (defaultRealm != null || plainText) {\n+               realmName = defaultRealm;\n+            } else {\n+               throw log.noRealmFoundInProperties();\n+            }\n+         }\n+      }\n+\n+      // users, which are in groups file only\n+      for (String userName : groups.stringPropertyNames()) {\n+         if (accounts.containsKey(userName) == false) {\n+            accounts.put(userName, new AccountEntry(userName, null, groups.getProperty(userName)));\n+         }\n+      }\n+\n+      loadedState.set(new LoadedState(accounts, realmName, System.currentTimeMillis()));\n+   }\n+\n+   /**\n+    * Get the time when the realm was last loaded.\n+    *\n+    * @return the time when the realm was last loaded (number of milliseconds since the standard base time)\n+    */\n+   public long getLoadTime() {\n+      return loadedState.get().getLoadTime();\n+   }\n+\n+   /**\n+    * Obtain a new {@link Builder} capable of building a {@link EncryptedPropertiesSecurityRealm}.\n+    *\n+    * @return a new {@link Builder} capable of building a {@link EncryptedPropertiesSecurityRealm}.\n+    */\n+   public static Builder builder() {\n+      return new Builder();\n+   }\n+\n+   /**\n+    * A builder for legacy properties security realms.\n+    */\n+   public static class Builder {\n+\n+      private Supplier<Provider[]> providers = INSTALLED_PROVIDERS;\n+      private InputStream usersStream;\n+      private InputStream groupsStream;\n+      private String defaultRealm = null;\n+      private boolean plainText;\n+      private String groupsAttribute = \"groups\";\n+\n+      Builder() {\n+      }\n+\n+      /**\n+       * Set the supplier for {@link Provider} instanced for use bu the realm.\n+       *\n+       * @param providers the supplier for {@link Provider} instanced for use bu the realm.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setProviders(Supplier<Provider[]> providers) {\n+         this.providers = providers;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set the {@link InputStream} to use to load the users.\n+       *\n+       * @param usersStream the {@link InputStream} to use to load the users.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setUsersStream(InputStream usersStream) {\n+         this.usersStream = usersStream;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set the {@link InputStream} to use to load the group information.\n+       *\n+       * @param groupsStream the {@link InputStream} to use to load the group information.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setGroupsStream(InputStream groupsStream) {\n+         this.groupsStream = groupsStream;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Where this realm returns an {@link AuthorizationIdentity} set the key on the Attributes that will be used to\n+       * hold the group membership information.\n+       *\n+       * @param groupsAttribute the key on the Attributes that will be used to hold the group membership information.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setGroupsAttribute(final String groupsAttribute) {\n+         this.groupsAttribute = groupsAttribute;\n+\n+         return this;\n+      }\n+\n+\n+      /**\n+       * Set the default realm name to use if no realm name is discovered in the properties file.\n+       *\n+       * @param defaultRealm the default realm name if one is not discovered in the properties file.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setDefaultRealm(String defaultRealm) {\n+         this.defaultRealm = defaultRealm;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set format of users property file - if the passwords are stored in plain text. Otherwise is HEX( MD5( username\n+       * \":\" realm \":\" password ) ) expected.\n+       *\n+       * @param plainText if the passwords are stored in plain text.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setPlainText(boolean plainText) {\n+         this.plainText = plainText;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Builds the {@link EncryptedPropertiesSecurityRealm}.\n+       *\n+       * @return built {@link EncryptedPropertiesSecurityRealm}\n+       * @throws IOException                   when loading of property files fails\n+       * @throws java.io.FileNotFoundException when property file does not exist\n+       * @throws RealmUnavailableException     when property file of users does not contain realm name specification\n+       */\n+      public EncryptedPropertiesSecurityRealm build() throws IOException {\n+         EncryptedPropertiesSecurityRealm realm = new EncryptedPropertiesSecurityRealm(this);\n+         realm.load(usersStream, groupsStream);\n+\n+         return realm;\n+      }\n+\n+   }\n+\n+   private static class LoadedState {\n+\n+      private final Map<String, AccountEntry> accounts;\n+      private final String realmName;\n+      private final long loadTime;\n+\n+      private LoadedState(Map<String, AccountEntry> accounts, String realmName, long loadTime) {\n+         this.accounts = accounts;\n+         this.realmName = realmName;\n+         this.loadTime = loadTime;\n+      }\n+\n+      public Map<String, AccountEntry> getAccounts() {\n+         return accounts;\n+      }\n+\n+      public String getRealmName() {\n+         return realmName;\n+      }\n+\n+      public long getLoadTime() {\n+         return loadTime;\n+      }\n+\n+   }\n+\n+   private static class AccountEntry {\n+\n+      private final String name;\n+      private final List<Credential> credentials;\n+      private final Set<String> groups;\n+\n+      private AccountEntry(String name, List<Credential> credentials, String groups) {\n+         this.name = name;\n+         this.credentials = credentials;\n+         this.groups = convertGroups(groups);\n+      }\n+\n+      private Set<String> convertGroups(String groups) {\n+         if (groups == null) {\n+            return Collections.emptySet();\n+         }\n+\n+         String[] groupArray = groups.split(\",\");\n+         Set<String> groupsSet = new HashSet<>(groupArray.length);\n+         for (String current : groupArray) {\n+            String value = current.trim();\n+            if (value.length() > 0) {\n+               groupsSet.add(value);\n+            }\n+         }\n+\n+         return Collections.unmodifiableSet(groupsSet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 482}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTQyNzY2OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyOTowOFrOGJswDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOToyOTowOFrOGJswDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMzU2NQ==", "bodyText": "Unnecessary whitespace.", "url": "https://github.com/infinispan/infinispan/pull/8221#discussion_r412823565", "createdAt": "2020-04-22T09:29:08Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/EncryptedPropertiesSecurityRealm.java", "diffHunk": "@@ -0,0 +1,500 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.infinispan.server.Server.log;\n+import static org.wildfly.security.provider.util.ProviderUtil.INSTALLED_PROVIDERS;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.Provider;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.server.Server;\n+import org.wildfly.common.Assert;\n+import org.wildfly.common.iteration.CodePointIterator;\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.principal.NamePrincipal;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.authz.MapAttributes;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.PasswordFactory;\n+import org.wildfly.security.password.spec.BasicPasswordSpecEncoding;\n+import org.wildfly.security.password.spec.ClearPasswordSpec;\n+import org.wildfly.security.password.spec.PasswordSpec;\n+\n+/**\n+ * A {@link SecurityRealm} implementation that uses property files with encrypted passwords\n+ *\n+ * @author Darran Lofthouse &lt;darran.lofthouse@jboss.com&gt;\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ */\n+public class EncryptedPropertiesSecurityRealm implements SecurityRealm {\n+\n+   private static final String COMMENT_PREFIX1 = \"#\";\n+   private static final String COMMENT_PREFIX2 = \"!\";\n+   private static final String REALM_COMMENT_PREFIX = \"$REALM_NAME=\";\n+   private static final String COMMENT_SUFFIX = \"$\";\n+   private static final String ALGORITHM_COMMENT_PREFIX = \"$ALGORITHM=\";\n+\n+   private final Supplier<Provider[]> providers;\n+   private final String defaultRealm;\n+   private final boolean plainText;\n+\n+   private final String groupsAttribute;\n+\n+   private final AtomicReference<LoadedState> loadedState = new AtomicReference<>();\n+\n+   private EncryptedPropertiesSecurityRealm(Builder builder) {\n+      plainText = builder.plainText;\n+      groupsAttribute = builder.groupsAttribute;\n+      providers = builder.providers;\n+      defaultRealm = builder.defaultRealm;\n+   }\n+\n+   @Override\n+   public RealmIdentity getRealmIdentity(final Principal principal) {\n+      if (!(principal instanceof NamePrincipal)) {\n+         log.tracef(\"PropertiesRealm: unsupported principal type: [%s]\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+      final LoadedState loadedState = this.loadedState.get();\n+\n+      final AccountEntry accountEntry = loadedState.getAccounts().get(principal.getName());\n+\n+      if (accountEntry == null) {\n+         log.tracef(\"PropertiesRealm: identity [%s] does not exist\", principal);\n+         return RealmIdentity.NON_EXISTENT;\n+      }\n+\n+      return new RealmIdentity() {\n+\n+         @Override\n+         public Principal getRealmIdentityPrincipal() {\n+            return principal;\n+         }\n+\n+         @Override\n+         public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.canVerify(evidenceType, algorithmName)) {\n+                  return SupportLevel.SUPPORTED;\n+               }\n+            }\n+            return SupportLevel.UNSUPPORTED;\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType) {\n+            return getCredential(credentialType, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName) {\n+            return getCredential(credentialType, algorithmName, null);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null && credential.matches(credentialType, algorithmName, parameterSpec)) {\n+                  return credentialType.cast(credential.clone());\n+               }\n+            }\n+            return null;\n+         }\n+\n+         @Override\n+         public boolean verifyEvidence(final Evidence evidence) {\n+            for (Credential credential : accountEntry.getCredentials()) {\n+               if (credential != null || credential.canVerify(evidence)) {\n+                  return credential.verify(evidence);\n+               }\n+            }\n+            log.tracef(\"Unable to verify evidence for identity [%s]\", principal);\n+            return false;\n+\n+         }\n+\n+         @Override\n+         public boolean exists() {\n+            return true;\n+         }\n+\n+         @Override\n+         public AuthorizationIdentity getAuthorizationIdentity() {\n+            return AuthorizationIdentity.basicIdentity(new MapAttributes(Collections.singletonMap(groupsAttribute, accountEntry.getGroups())));\n+         }\n+      };\n+   }\n+\n+   private PasswordFactory getPasswordFactory(final String algorithm) {\n+      try {\n+         return PasswordFactory.getInstance(algorithm, providers);\n+      } catch (NoSuchAlgorithmException e) {\n+         throw new IllegalStateException(e);\n+      }\n+   }\n+\n+   @Override\n+   public SupportLevel getCredentialAcquireSupport(final Class<? extends Credential> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) {\n+      Assert.checkNotNullParam(\"credentialType\", credentialType);\n+      return PasswordCredential.class.isAssignableFrom(credentialType) ? SupportLevel.POSSIBLY_SUPPORTED : SupportLevel.UNSUPPORTED;\n+   }\n+\n+   @Override\n+   public SupportLevel getEvidenceVerifySupport(final Class<? extends Evidence> evidenceType, final String algorithmName) {\n+      return PasswordGuessEvidence.class.isAssignableFrom(evidenceType) ? SupportLevel.SUPPORTED : SupportLevel.UNSUPPORTED;\n+   }\n+\n+   /**\n+    * Loads this properties security realm from the given user and groups input streams.\n+    *\n+    * @param usersStream  the input stream from which the realm users are loaded\n+    * @param groupsStream the input stream from which the roles of realm users are loaded\n+    * @throws IOException if there is problem while reading the input streams or invalid content is loaded from streams\n+    */\n+   public void load(InputStream usersStream, InputStream groupsStream) throws IOException {\n+      Map<String, AccountEntry> accounts = new HashMap<>();\n+      Properties groups = new Properties();\n+\n+      if (groupsStream != null) {\n+         try (InputStreamReader is = new InputStreamReader(groupsStream, StandardCharsets.UTF_8);) {\n+            groups.load(is);\n+         }\n+      }\n+\n+      String realmName = null;\n+      String algorithm = \"clear\";\n+      if (usersStream != null) {\n+         try (BufferedReader reader = new BufferedReader(new InputStreamReader(usersStream, StandardCharsets.UTF_8))) {\n+            String currentLine;\n+            while ((currentLine = reader.readLine()) != null) {\n+               final String trimmed = currentLine.trim();\n+               if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(REALM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the realm name.\n+                  int start = trimmed.indexOf(REALM_COMMENT_PREFIX) + REALM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     realmName = trimmed.substring(start, end);\n+                  }\n+               } else if (trimmed.startsWith(COMMENT_PREFIX1) && trimmed.contains(ALGORITHM_COMMENT_PREFIX)) {\n+                  // this is the line that contains the algorithm name.\n+                  int start = trimmed.indexOf(ALGORITHM_COMMENT_PREFIX) + ALGORITHM_COMMENT_PREFIX.length();\n+                  int end = trimmed.indexOf(COMMENT_SUFFIX, start);\n+                  if (end > -1) {\n+                     algorithm = trimmed.substring(start, end);\n+                  }\n+               } else {\n+                  if (!(trimmed.startsWith(COMMENT_PREFIX1) || trimmed.startsWith(COMMENT_PREFIX2))) {\n+                     String username = null;\n+                     StringBuilder builder = new StringBuilder();\n+\n+                     CodePointIterator it = CodePointIterator.ofString(trimmed);\n+                     while (it.hasNext()) {\n+                        int cp = it.next();\n+                        if (cp == '\\\\' && it.hasNext()) { // escape\n+                           //might be regular escape of regex like characters \\\\t \\\\! or unicode \\\\uxxxx\n+                           int marker = it.next();\n+                           if (marker != 'u') {\n+                              builder.appendCodePoint(marker);\n+                           } else {\n+                              StringBuilder hex = new StringBuilder();\n+                              try {\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 hex.appendCodePoint(it.next());\n+                                 builder.appendCodePoint((char) Integer.parseInt(hex.toString(), 16));\n+                              } catch (NoSuchElementException nsee) {\n+                                 throw Server.log.invalidUnicodeSequence(hex.toString(), nsee);\n+                              }\n+                           }\n+                        } else if (username == null && (cp == '=' || cp == ':')) { // username-password delimiter\n+                           username = builder.toString().trim();\n+                           builder = new StringBuilder();\n+                        } else {\n+                           builder.appendCodePoint(cp);\n+                        }\n+                     }\n+                     if (username != null) { // end of line and delimiter was read\n+                        List<Credential> credentials = new ArrayList<>();\n+                        switch (algorithm) {\n+                           case \"encrypted\":\n+                              String[] passwords = builder.toString().trim().split(\";\");\n+                              for (String password : passwords) {\n+                                 int colon = password.indexOf(':');\n+                                 byte[] passwordBytes = CodePointIterator.ofChars(password.substring(colon + 1).toCharArray()).base64Decode().drain();\n+                                 PasswordFactory factory = getPasswordFactory(password.substring(0, colon));\n+                                 PasswordSpec passwordSpec = BasicPasswordSpecEncoding.decode(passwordBytes);\n+                                 try {\n+                                    credentials.add(new PasswordCredential(factory.generatePassword(passwordSpec)));\n+                                 } catch (InvalidKeySpecException e) {\n+                                    throw new IOException(e);\n+                                 }\n+                              }\n+                              break;\n+                           case \"clear\":\n+                              PasswordFactory factory = getPasswordFactory(\"clear\");\n+                              try {\n+                                 credentials.add(new PasswordCredential(factory.generatePassword(new ClearPasswordSpec(builder.toString().trim().toCharArray()))));\n+                              } catch (InvalidKeySpecException e) {\n+                                 throw new IOException(e);\n+                              }\n+                              break;\n+                        }\n+\n+                        accounts.put(username, new AccountEntry(username, credentials, groups.getProperty(username)));\n+                     }\n+                  }\n+               }\n+            }\n+         }\n+\n+         if (realmName == null) {\n+            if (defaultRealm != null || plainText) {\n+               realmName = defaultRealm;\n+            } else {\n+               throw log.noRealmFoundInProperties();\n+            }\n+         }\n+      }\n+\n+      // users, which are in groups file only\n+      for (String userName : groups.stringPropertyNames()) {\n+         if (accounts.containsKey(userName) == false) {\n+            accounts.put(userName, new AccountEntry(userName, null, groups.getProperty(userName)));\n+         }\n+      }\n+\n+      loadedState.set(new LoadedState(accounts, realmName, System.currentTimeMillis()));\n+   }\n+\n+   /**\n+    * Get the time when the realm was last loaded.\n+    *\n+    * @return the time when the realm was last loaded (number of milliseconds since the standard base time)\n+    */\n+   public long getLoadTime() {\n+      return loadedState.get().getLoadTime();\n+   }\n+\n+   /**\n+    * Obtain a new {@link Builder} capable of building a {@link EncryptedPropertiesSecurityRealm}.\n+    *\n+    * @return a new {@link Builder} capable of building a {@link EncryptedPropertiesSecurityRealm}.\n+    */\n+   public static Builder builder() {\n+      return new Builder();\n+   }\n+\n+   /**\n+    * A builder for legacy properties security realms.\n+    */\n+   public static class Builder {\n+\n+      private Supplier<Provider[]> providers = INSTALLED_PROVIDERS;\n+      private InputStream usersStream;\n+      private InputStream groupsStream;\n+      private String defaultRealm = null;\n+      private boolean plainText;\n+      private String groupsAttribute = \"groups\";\n+\n+      Builder() {\n+      }\n+\n+      /**\n+       * Set the supplier for {@link Provider} instanced for use bu the realm.\n+       *\n+       * @param providers the supplier for {@link Provider} instanced for use bu the realm.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setProviders(Supplier<Provider[]> providers) {\n+         this.providers = providers;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set the {@link InputStream} to use to load the users.\n+       *\n+       * @param usersStream the {@link InputStream} to use to load the users.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setUsersStream(InputStream usersStream) {\n+         this.usersStream = usersStream;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set the {@link InputStream} to use to load the group information.\n+       *\n+       * @param groupsStream the {@link InputStream} to use to load the group information.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setGroupsStream(InputStream groupsStream) {\n+         this.groupsStream = groupsStream;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Where this realm returns an {@link AuthorizationIdentity} set the key on the Attributes that will be used to\n+       * hold the group membership information.\n+       *\n+       * @param groupsAttribute the key on the Attributes that will be used to hold the group membership information.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setGroupsAttribute(final String groupsAttribute) {\n+         this.groupsAttribute = groupsAttribute;\n+\n+         return this;\n+      }\n+\n+\n+      /**\n+       * Set the default realm name to use if no realm name is discovered in the properties file.\n+       *\n+       * @param defaultRealm the default realm name if one is not discovered in the properties file.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setDefaultRealm(String defaultRealm) {\n+         this.defaultRealm = defaultRealm;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Set format of users property file - if the passwords are stored in plain text. Otherwise is HEX( MD5( username\n+       * \":\" realm \":\" password ) ) expected.\n+       *\n+       * @param plainText if the passwords are stored in plain text.\n+       * @return this {@link Builder}\n+       */\n+      public Builder setPlainText(boolean plainText) {\n+         this.plainText = plainText;\n+\n+         return this;\n+      }\n+\n+      /**\n+       * Builds the {@link EncryptedPropertiesSecurityRealm}.\n+       *\n+       * @return built {@link EncryptedPropertiesSecurityRealm}\n+       * @throws IOException                   when loading of property files fails\n+       * @throws java.io.FileNotFoundException when property file does not exist\n+       * @throws RealmUnavailableException     when property file of users does not contain realm name specification\n+       */\n+      public EncryptedPropertiesSecurityRealm build() throws IOException {\n+         EncryptedPropertiesSecurityRealm realm = new EncryptedPropertiesSecurityRealm(this);\n+         realm.load(usersStream, groupsStream);\n+\n+         return realm;\n+      }\n+\n+   }\n+\n+   private static class LoadedState {\n+\n+      private final Map<String, AccountEntry> accounts;\n+      private final String realmName;\n+      private final long loadTime;\n+\n+      private LoadedState(Map<String, AccountEntry> accounts, String realmName, long loadTime) {\n+         this.accounts = accounts;\n+         this.realmName = realmName;\n+         this.loadTime = loadTime;\n+      }\n+\n+      public Map<String, AccountEntry> getAccounts() {\n+         return accounts;\n+      }\n+\n+      public String getRealmName() {\n+         return realmName;\n+      }\n+\n+      public long getLoadTime() {\n+         return loadTime;\n+      }\n+\n+   }\n+\n+   private static class AccountEntry {\n+\n+      private final String name;\n+      private final List<Credential> credentials;\n+      private final Set<String> groups;\n+\n+      private AccountEntry(String name, List<Credential> credentials, String groups) {\n+         this.name = name;\n+         this.credentials = credentials;\n+         this.groups = convertGroups(groups);\n+      }\n+\n+      private Set<String> convertGroups(String groups) {\n+         if (groups == null) {\n+            return Collections.emptySet();\n+         }\n+\n+         String[] groupArray = groups.split(\",\");\n+         Set<String> groupsSet = new HashSet<>(groupArray.length);\n+         for (String current : groupArray) {\n+            String value = current.trim();\n+            if (value.length() > 0) {\n+               groupsSet.add(value);\n+            }\n+         }\n+\n+         return Collections.unmodifiableSet(groupsSet);\n+      }\n+\n+      public String getName() {\n+         return name;\n+      }\n+\n+      public List<Credential> getCredentials() {\n+         return credentials;\n+      }\n+\n+\n+      public Set<String> getGroups() {\n+         return groups;\n+      }\n+   }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17bfb7ef851b1d2c8f93d53d3f0a2724c1ac5212"}, "originalPosition": 499}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4289, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}