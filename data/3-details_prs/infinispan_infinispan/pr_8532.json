{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NTAzNDY2", "number": 8532, "title": "ISPN-11723 Cluster Backup/Restore tool", "bodyText": "https://issues.redhat.com/browse/ISPN-11723\nhttps://issues.redhat.com/browse/ISPN-12095\nCLI support to follow in a separate PR ISPN-12095.\nThere's still some polishing required, mostly centred around threads in the BackupWriter and BackupReader.", "createdAt": "2020-07-07T15:53:26Z", "url": "https://github.com/infinispan/infinispan/pull/8532", "merged": true, "mergeCommit": {"oid": "5d72601bda5de8da069232c5108f4e195fab007e"}, "closed": true, "closedAt": "2020-08-20T13:25:50Z", "author": {"login": "ryanemerson"}, "timelineItems": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcy9ZgjABqjM1MjYxNTI3Mzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdAeA_QABqjM2NzE2MjQzNjU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7365f844ca2efda04154c3f7fb9d746d86701ca", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/f7365f844ca2efda04154c3f7fb9d746d86701ca", "committedDate": "2020-07-07T15:50:26Z", "message": "ISPN-11723 Cluster Backup/Restore tool\n\n- BackupManager interface exposed via ServerManagement\n- /v2/cluster/backup exposes cointainer backup\n- /v2/cluster/restore exposes cointainer restore\n- BackupManagerImplTest added\n- ClusterBackupIT added"}, "afterCommit": {"oid": "b2e1e963cf535ecf1e3bcb990b342e53a1738756", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/b2e1e963cf535ecf1e3bcb990b342e53a1738756", "committedDate": "2020-07-08T16:52:08Z", "message": "ISPN-11723 Cluster Backup/Restore tool\n\n- BackupManager interface exposed via ServerManagement\n- /v2/cluster/backup exposes cointainer backup\n- /v2/cluster/restore exposes cointainer restore\n- BackupManagerImplTest added\n- ClusterBackupIT added"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b2e1e963cf535ecf1e3bcb990b342e53a1738756", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/b2e1e963cf535ecf1e3bcb990b342e53a1738756", "committedDate": "2020-07-08T16:52:08Z", "message": "ISPN-11723 Cluster Backup/Restore tool\n\n- BackupManager interface exposed via ServerManagement\n- /v2/cluster/backup exposes cointainer backup\n- /v2/cluster/restore exposes cointainer restore\n- BackupManagerImplTest added\n- ClusterBackupIT added"}, "afterCommit": {"oid": "fead33ed2934588be06b2246c559531ff5d35df6", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/fead33ed2934588be06b2246c559531ff5d35df6", "committedDate": "2020-07-09T09:09:12Z", "message": "ISPN-11723 Cluster Backup/Restore tool\n\n- BackupManager interface exposed via ServerManagement\n- /v2/cluster/backup exposes cointainer backup\n- /v2/cluster/restore exposes cointainer restore\n- BackupManagerImplTest added\n- ClusterBackupIT added"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fead33ed2934588be06b2246c559531ff5d35df6", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/fead33ed2934588be06b2246c559531ff5d35df6", "committedDate": "2020-07-09T09:09:12Z", "message": "ISPN-11723 Cluster Backup/Restore tool\n\n- BackupManager interface exposed via ServerManagement\n- /v2/cluster/backup exposes cointainer backup\n- /v2/cluster/restore exposes cointainer restore\n- BackupManagerImplTest added\n- ClusterBackupIT added"}, "afterCommit": {"oid": "01d48dd061fe91831a2ba93352be630f1e3a8916", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/01d48dd061fe91831a2ba93352be630f1e3a8916", "committedDate": "2020-07-10T11:30:28Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "01d48dd061fe91831a2ba93352be630f1e3a8916", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/01d48dd061fe91831a2ba93352be630f1e3a8916", "committedDate": "2020-07-10T11:30:28Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}, "afterCommit": {"oid": "548a6c9d81e4ec1feca3dd2270e0dc148c779555", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/548a6c9d81e4ec1feca3dd2270e0dc148c779555", "committedDate": "2020-07-10T12:54:31Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "548a6c9d81e4ec1feca3dd2270e0dc148c779555", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/548a6c9d81e4ec1feca3dd2270e0dc148c779555", "committedDate": "2020-07-10T12:54:31Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}, "afterCommit": {"oid": "eb18a78b0989bec9090e874f3867e3ceca7a1487", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/eb18a78b0989bec9090e874f3867e3ceca7a1487", "committedDate": "2020-07-10T12:58:18Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb18a78b0989bec9090e874f3867e3ceca7a1487", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/eb18a78b0989bec9090e874f3867e3ceca7a1487", "committedDate": "2020-07-10T12:58:18Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}, "afterCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/870674768f73027512fec040a2cc52ec6d70ee6e", "committedDate": "2020-07-10T14:26:50Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NTA0NzEx", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-446504711", "createdAt": "2020-07-10T15:41:36Z", "commit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNTo0MTozNlrOGv8NOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNTo0MTozNlrOGv8NOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ==", "bodyText": "@param backup the bytes of the uploaded backup file. <= what is this exactly? is the full data in a single byte{]?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r452922681", "createdAt": "2020-07-10T15:41:36Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/870674768f73027512fec040a2cc52ec6d70ee6e", "committedDate": "2020-07-10T14:26:50Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}, "afterCommit": {"oid": "cba11f350f146453d2822f03c1baa48707a53912", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/cba11f350f146453d2822f03c1baa48707a53912", "committedDate": "2020-07-16T16:35:30Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cba11f350f146453d2822f03c1baa48707a53912", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/cba11f350f146453d2822f03c1baa48707a53912", "committedDate": "2020-07-16T16:35:30Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}, "afterCommit": {"oid": "82bd52a4ad5d4704767bed064483b437bf8f9391", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/82bd52a4ad5d4704767bed064483b437bf8f9391", "committedDate": "2020-07-20T12:39:57Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODM0ODgy", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-451834882", "createdAt": "2020-07-20T17:58:32Z", "commit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzo1ODozM1rOG0ZNnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDo1NzowM1rOG0fAJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5MjIyMw==", "bodyText": "We should probably add at least minor documentation to these.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457592223", "createdAt": "2020-07-20T17:58:33Z", "author": {"login": "wburns"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestClusterClient.java", "diffHunk": "@@ -17,4 +18,8 @@\n     * Shuts down the specified servers\n     */\n    CompletionStage<RestResponse> stop(List<String> server);\n+\n+   CompletionStage<RestResponse> backup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNTExMw==", "bodyText": "This isn't quite true. We should invoke Runnable in a blocking thread if the stage is completed on a non blocking thread. Looking closer whenCompleteBlocking has the same problem, maybe we should log a JIRA to take care of that though. We really need to add a blocking executor that checks the invoking thread if it is blocking or not before submitting.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457605113", "createdAt": "2020-07-20T18:21:53Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -106,6 +106,21 @@\n    <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n          BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n \n+   /**\n+    * Replacement for {@link CompletionStage#thenRunAsync(Runnable)} that invokes the {@code Runnable} in a blocking thread\n+    * (if the current thread is non-blocking) or in the current thread (if the current thread is blocking).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNzQwNw==", "bodyText": "You can change all of this to just return stage.thenRun(runnable);", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457607407", "createdAt": "2020-07-20T18:26:06Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManagerImpl.java", "diffHunk": "@@ -187,6 +187,23 @@ protected void start() {\n       return continueOnNonBlockingThread(stage.thenApplyAsync(function, blockingExecutor), traceId);\n    }\n \n+   @Override\n+   public <I> CompletionStage<Void> thenRun(CompletionStage<? extends I> stage, Runnable runnable, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked thenRun on a blocking thread, joining %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            CompletionStages.join(stage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0NDQ2Nw==", "bodyText": "No need for this variable.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457644467", "createdAt": "2020-07-20T19:34:26Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupManagerImpl.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.WORKING_DIR;\n+\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class BackupManagerImpl implements BackupManager {\n+\n+   private static final Log log = LogFactory.getLog(BackupManagerImpl.class, Log.class);\n+\n+   private final AtomicBoolean backupInProgress = new AtomicBoolean();\n+   private final AtomicBoolean restoreInProgress = new AtomicBoolean();\n+\n+   final Path rootDir;\n+   final BackupReader reader;\n+   final BackupWriter writer;\n+   final BlockingManager blockingManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1MjIzMw==", "bodyText": "I have never been a fan of doing stuff like this in a constructor. Maybe add a makeDirectories method to BackupManager?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457652233", "createdAt": "2020-07-20T19:49:03Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupManagerImpl.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.WORKING_DIR;\n+\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class BackupManagerImpl implements BackupManager {\n+\n+   private static final Log log = LogFactory.getLog(BackupManagerImpl.class, Log.class);\n+\n+   private final AtomicBoolean backupInProgress = new AtomicBoolean();\n+   private final AtomicBoolean restoreInProgress = new AtomicBoolean();\n+\n+   final Path rootDir;\n+   final BackupReader reader;\n+   final BackupWriter writer;\n+   final BlockingManager blockingManager;\n+   final Map<String, DefaultCacheManager> cacheManagers;\n+\n+   public BackupManagerImpl(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers,\n+                            Path dataRoot) {\n+      this.blockingManager = blockingManager;\n+      this.rootDir = dataRoot.resolve(WORKING_DIR);\n+      this.cacheManagers = cacheManagers;\n+      this.reader = new BackupReader(blockingManager, cacheManagers, rootDir);\n+      this.writer = new BackupWriter(blockingManager, cacheManagers, rootDir);\n+      rootDir.toFile().mkdir();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1Njk2MA==", "bodyText": "Is there a reason this isn't in the same code block as below? Unfortunately this will hand off the processing to a non blocking thread which will then just hand back off to a different blocking thread. If instead it is just one lambda it won't do this handoff.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457656960", "createdAt": "2020-07-20T19:58:11Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupReader.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.STAGING_ZIP;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.logging.LogFactory;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for reading backup bytes and restoring the contents to the appropriate cache manager.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupReader {\n+\n+   private static final Log log = LogFactory.getLog(BackupReader.class, Log.class);\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+   private final Path rootDir;\n+\n+   public BackupReader(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+   }\n+\n+   CompletionStage<Void> restore(InputStream is, Map<String, BackupManager.ContainerResources> params) {\n+      final Path stagingFile = rootDir.resolve(STAGING_ZIP);\n+\n+      CompletionStage<Void> createStagingFile = blockingManager.runBlocking(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1Nzg5MQ==", "bodyText": "Same here, this should be able to just be one big blockingManager.thenSupply call which returns a CompletionStage and then use thenCompose to flatten it.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457657891", "createdAt": "2020-07-20T19:59:52Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupReader.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.STAGING_ZIP;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.logging.LogFactory;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for reading backup bytes and restoring the contents to the appropriate cache manager.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupReader {\n+\n+   private static final Log log = LogFactory.getLog(BackupReader.class, Log.class);\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+   private final Path rootDir;\n+\n+   public BackupReader(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+   }\n+\n+   CompletionStage<Void> restore(InputStream is, Map<String, BackupManager.ContainerResources> params) {\n+      final Path stagingFile = rootDir.resolve(STAGING_ZIP);\n+\n+      CompletionStage<Void> createStagingFile = blockingManager.runBlocking(() -> {\n+         try {\n+            Files.copy(is, stagingFile);\n+         } catch (IOException e) {\n+            throw new CacheException(e);\n+         }\n+      }, \"create-staging\");\n+\n+      CompletionStage<?> processContainers = blockingManager.thenApplyBlocking(createStagingFile, Void -> {\n+         try (ZipFile zip = new ZipFile(stagingFile.toFile())) {\n+            Properties manifest = readManifestAndValidate(zip);\n+\n+            List<String> backupContainers = Arrays.asList(manifest.getProperty(CONTAINER_KEY).split(\",\"));\n+            Set<String> requestedContainers = new HashSet<>(params.keySet());\n+            requestedContainers.removeAll(backupContainers);\n+            if (!requestedContainers.isEmpty()) {\n+               throw log.unableToFindBackupResource(\"Containers\", requestedContainers);\n+            }\n+\n+            return CompletionStages.allOf(\n+                  params.entrySet().stream()\n+                        .map(e -> restoreContainer(e.getKey(), e.getValue(), zip))\n+                        .collect(Collectors.toList())\n+            );\n+         } catch (IOException e) {\n+            throw new CacheException(String.format(\"Unable to read zip file '%s'\", stagingFile));\n+         }\n+      }, \"read-manifest\");\n+\n+      return blockingManager.thenRun(processContainers, () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3MDA1NQ==", "bodyText": "Just use an AggregateCompletionStage instead of creating this list.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457670055", "createdAt": "2020-07-20T20:23:53Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupWriter.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.GLOBAL_CONFIG_FILE;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.configuration.global.GlobalConfiguration;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for creating backup files that can be used to restore a container/cache on a new cluster.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupWriter {\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+\n+   private final Path rootDir;\n+   private final ParserRegistry parserRegistry;\n+\n+   BackupWriter(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+      this.parserRegistry = new ParserRegistry();\n+   }\n+\n+   CompletionStage<Path> create(Map<String, BackupManager.ContainerResources> params) {\n+      List<CompletionStage<?>> stages = new ArrayList<>(params.size() + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3NDI5Ng==", "bodyText": "So should this method throw an exception when it isn't valid? I would expect the exception to be defined as being able to be thrown in the interface then.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457674296", "createdAt": "2020-07-20T20:32:10Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/ContainerResource.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package org.infinispan.server.core.backup;\n+\n+import java.util.Properties;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipFile;\n+\n+import org.infinispan.server.core.BackupManager;\n+\n+/**\n+ * An interface that defines how a {@link org.infinispan.server.core.BackupManager.ResourceType} is backed up and\n+ * restored by the {@link org.infinispan.server.core.BackupManager}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public interface ContainerResource {\n+\n+   /**\n+    * A method to ensure that the resources requested in the {@link BackupManager.ContainerResources}\n+    * are valid and can be included in a backup. This method is called for all {@link ContainerResource} implementations\n+    * before the backup process begins in order to allow a backup to fail-fast before any data is processed.\n+    */\n+   void prepareAndValidateBackup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY4NzA3OA==", "bodyText": "We should be able to use an AggregateCompletionStage here as well.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457687078", "createdAt": "2020-07-20T20:57:03Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupWriter.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.GLOBAL_CONFIG_FILE;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.configuration.global.GlobalConfiguration;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for creating backup files that can be used to restore a container/cache on a new cluster.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupWriter {\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+\n+   private final Path rootDir;\n+   private final ParserRegistry parserRegistry;\n+\n+   BackupWriter(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+      this.parserRegistry = new ParserRegistry();\n+   }\n+\n+   CompletionStage<Path> create(Map<String, BackupManager.ContainerResources> params) {\n+      List<CompletionStage<?>> stages = new ArrayList<>(params.size() + 1);\n+      for (Map.Entry<String, BackupManager.ContainerResources> e : params.entrySet()) {\n+         String container = e.getKey();\n+         EmbeddedCacheManager cm = cacheManagers.get(container);\n+         stages.add(createBackup(container, cm, e.getValue()));\n+      }\n+\n+      stages.add(writeManifest(cacheManagers.keySet()));\n+      return blockingManager.thenApplyBlocking(CompletionStages.allOf(stages), Void -> createZip(), \"create\");\n+   }\n+\n+   /**\n+    * Create a backup of the specified container.\n+    *\n+    * @param containerName the name of container to backup.\n+    * @param cm            the container to backup.\n+    * @param params        the {@link BackupManager.ContainerResources} object that determines what resources are included in\n+    *                      the backup for this container.\n+    * @return a {@link CompletionStage} that completes once the backup has finished.\n+    */\n+   private CompletionStage<Void> createBackup(String containerName, EmbeddedCacheManager cm, BackupManager.ContainerResources params) {\n+      Path containerRoot = rootDir.resolve(CONTAINER_KEY).resolve(containerName);\n+      containerRoot.toFile().mkdirs();\n+      GlobalComponentRegistry gcr = cm.getGlobalComponentRegistry();\n+      BlockingManager blockingManager = gcr.getComponent(BlockingManager.class);\n+\n+      Collection<ContainerResource> resources = ContainerResourceFactory.getInstance()\n+            .getResources(params, blockingManager, cm, containerRoot);\n+\n+      // Prepare and ensure all requested resources are valid before starting the backup process\n+      resources.forEach(ContainerResource::prepareAndValidateBackup);\n+\n+      List<CompletionStage<?>> stages = resources.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNDM4MDg4", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-452438088", "createdAt": "2020-07-21T13:11:11Z", "commit": {"oid": "82bd52a4ad5d4704767bed064483b437bf8f9391"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxMToxMVrOG03M3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxMToxMVrOG03M3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MzU1MA==", "bodyText": "Jackson databind is being killed, please avoid using it and use the internal mJson instead", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458083550", "createdAt": "2020-07-21T13:11:11Z", "author": {"login": "gustavonalle"}, "path": "server/tests/src/test/java/org/infinispan/server/functional/ClusterBackupIT.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package org.infinispan.server.functional;\n+\n+import static org.infinispan.functional.FunctionalTestUtils.await;\n+import static org.infinispan.util.concurrent.CompletionStages.join;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Arrays;\n+\n+import org.infinispan.client.rest.RestCacheClient;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestCounterClient;\n+import org.infinispan.client.rest.RestEntity;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.RestTaskClient;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.counter.api.Storage;\n+import org.infinispan.counter.configuration.Element;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82bd52a4ad5d4704767bed064483b437bf8f9391"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNDQwMTYx", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-452440161", "createdAt": "2020-07-21T13:13:29Z", "commit": {"oid": "82bd52a4ad5d4704767bed064483b437bf8f9391"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxMzoyOVrOG03Szg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxMzoyOVrOG03Szg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4NTA3MA==", "bodyText": "Please add documentation in the REST API for those two methods", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458085070", "createdAt": "2020-07-21T13:13:29Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ClusterResource.java", "diffHunk": "@@ -1,33 +1,52 @@\n package org.infinispan.rest.resources;\n \n+import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;\n import static io.netty.handler.codec.http.HttpResponseStatus.NO_CONTENT;\n+import static io.netty.handler.codec.http.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+import static org.infinispan.rest.framework.Method.GET;\n import static org.infinispan.rest.framework.Method.POST;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CompletionStage;\n \n+import org.infinispan.commons.dataconversion.MediaType;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n import org.infinispan.rest.framework.ResourceHandler;\n import org.infinispan.rest.framework.RestRequest;\n import org.infinispan.rest.framework.RestResponse;\n import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.logging.Log;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.logging.LogFactory;\n \n /**\n  * @since 10.0\n  */\n public class ClusterResource implements ResourceHandler {\n+\n+   private final static Log LOG = LogFactory.getLog(ClusterResource.class, Log.class);\n+\n    private final InvocationHelper invocationHelper;\n+   private final BackupManager backupManager;\n \n    public ClusterResource(InvocationHelper invocationHelper) {\n       this.invocationHelper = invocationHelper;\n+      this.backupManager = invocationHelper.getServer().getBackupManager();\n    }\n \n    @Override\n    public Invocations getInvocations() {\n       return new Invocations.Builder()\n             .invocation().methods(POST).path(\"/v2/cluster\").withAction(\"stop\").handleWith(this::stop)\n+            .invocation().methods(GET).path(\"/v2/cluster\").withAction(\"backup\").handleWith(this::backup)\n+            .invocation().methods(POST).path(\"/v2/cluster\").withAction(\"restore\").handleWith(this::restore)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82bd52a4ad5d4704767bed064483b437bf8f9391"}, "originalPosition": 49}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82bd52a4ad5d4704767bed064483b437bf8f9391", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/82bd52a4ad5d4704767bed064483b437bf8f9391", "committedDate": "2020-07-20T12:39:57Z", "message": "ISPN-12095 CLI: Add support for cluster backup/restore"}, "afterCommit": {"oid": "8c8a308c8256384661fae7f02f8091259132d0e5", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/8c8a308c8256384661fae7f02f8091259132d0e5", "committedDate": "2020-07-21T13:49:34Z", "message": "Address wburns comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7cb35f3670514986beed162f93afaf0f1666dc26", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/7cb35f3670514986beed162f93afaf0f1666dc26", "committedDate": "2020-07-22T11:50:36Z", "message": "Utilise ClusteredLock to ensure that only one backup/restore can occur at a given time"}, "afterCommit": {"oid": "dfc9e3acfa4c0fe8da6a3caec9f73679d0c69718", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/dfc9e3acfa4c0fe8da6a3caec9f73679d0c69718", "committedDate": "2020-07-22T16:48:18Z", "message": "ISPN-11723 REST API docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dfc9e3acfa4c0fe8da6a3caec9f73679d0c69718", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/dfc9e3acfa4c0fe8da6a3caec9f73679d0c69718", "committedDate": "2020-07-22T16:48:18Z", "message": "ISPN-11723 REST API docs"}, "afterCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/c6b1e7bfba81442df11dcd327c276e245ac98e21", "committedDate": "2020-07-22T17:05:18Z", "message": "ISPN-11723 REST API docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzOTkxOTg3", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-453991987", "createdAt": "2020-07-23T10:03:16Z", "commit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDowMzoxNlrOG2EBvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDowMzoxNlrOG2EBvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ==", "bodyText": "@gustavonalle As a backup is non-idempotent does it make more sense for this to be a POST?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r459342271", "createdAt": "2020-07-23T10:03:16Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/c6b1e7bfba81442df11dcd327c276e245ac98e21", "committedDate": "2020-07-22T17:05:18Z", "message": "ISPN-11723 REST API docs"}, "afterCommit": {"oid": "cd56ef01031bc2d4b948b04110698f2eb4d80595", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/cd56ef01031bc2d4b948b04110698f2eb4d80595", "committedDate": "2020-07-23T10:09:38Z", "message": "ISPN-11723 REST API docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d3ac2e26929945b1713cb619196be26cdb127a1a", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/d3ac2e26929945b1713cb619196be26cdb127a1a", "committedDate": "2020-07-29T17:02:08Z", "message": "Updated to allow for new RESTful api that splits resource creation and\nretrieval"}, "afterCommit": {"oid": "efedcd6e4718f909ec002c586f289f19d8703c3c", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/efedcd6e4718f909ec002c586f289f19d8703c3c", "committedDate": "2020-07-30T10:08:24Z", "message": "Updated to allow for new RESTful api that splits resource creation and\nretrieval"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "81293e5e5f9066f4a4b1c2ddfacd56de84adb458", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/81293e5e5f9066f4a4b1c2ddfacd56de84adb458", "committedDate": "2020-07-31T14:02:16Z", "message": "Fix checkstyle"}, "afterCommit": {"oid": "76138ebd042977a2d0f72f2d73e7a611212ae9d8", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/76138ebd042977a2d0f72f2d73e7a611212ae9d8", "committedDate": "2020-08-04T10:21:19Z", "message": "ISPN-11723 REST API docs added"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "76138ebd042977a2d0f72f2d73e7a611212ae9d8", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/76138ebd042977a2d0f72f2d73e7a611212ae9d8", "committedDate": "2020-08-04T10:21:19Z", "message": "ISPN-11723 REST API docs added"}, "afterCommit": {"oid": "dc8e76f5c9749882ec867ed84d90e7fa95b373fa", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/dc8e76f5c9749882ec867ed84d90e7fa95b373fa", "committedDate": "2020-08-05T10:31:28Z", "message": "ISPN-11723 REST API docs added"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dc8e76f5c9749882ec867ed84d90e7fa95b373fa", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/dc8e76f5c9749882ec867ed84d90e7fa95b373fa", "committedDate": "2020-08-05T10:31:28Z", "message": "ISPN-11723 REST API docs added"}, "afterCommit": {"oid": "5a7bffb7ec8256f0abb5a1623fc802849983a640", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/5a7bffb7ec8256f0abb5a1623fc802849983a640", "committedDate": "2020-08-05T10:39:48Z", "message": "ISPN-11723 REST API docs added"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5a7bffb7ec8256f0abb5a1623fc802849983a640", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/5a7bffb7ec8256f0abb5a1623fc802849983a640", "committedDate": "2020-08-05T10:39:48Z", "message": "ISPN-11723 REST API docs added"}, "afterCommit": {"oid": "273d51d75ac24b6893868ce0a373c07e368e1f24", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/273d51d75ac24b6893868ce0a373c07e368e1f24", "committedDate": "2020-08-06T10:04:01Z", "message": "ISPN-11723 REST API docs added"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "273d51d75ac24b6893868ce0a373c07e368e1f24", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/273d51d75ac24b6893868ce0a373c07e368e1f24", "committedDate": "2020-08-06T10:04:01Z", "message": "ISPN-11723 REST API docs added"}, "afterCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/c3d4a897db3ee4133a93c1032fefa531fb3fc27f", "committedDate": "2020-08-06T13:54:04Z", "message": "ISPN-11723 REST API docs added"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MTMxODE4", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-464131818", "createdAt": "2020-08-10T10:58:41Z", "commit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDo1ODo0MlrOG-J8Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDo1ODo0MlrOG-J8Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgyNzc5NQ==", "bodyText": "The REST related changes LGTM!", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r467827795", "createdAt": "2020-08-10T10:58:42Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java", "diffHunk": "@@ -108,6 +111,11 @@ public Invocations getInvocations() {\n \n             // Caches\n             .invocation().methods(GET).path(\"/v2/cache-managers/{name}/caches\").handleWith(this::getCaches)\n+\n+            // BackupManager\n+            .invocation().methods(GET).path(\"/v2/cache-managers/{name}/backups\").handleWith(this::getAllBackupNames)\n+            .invocation().methods(DELETE, GET, HEAD, POST).path(\"/v2/cache-managers/{name}/backups/{backupName}\").handleWith(this::backup)\n+            .invocation().methods(POST).path(\"/v2/cache-managers/{name}/backups\").withAction(\"restore\").handleWith(this::restore)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzMzODUz", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-464333853", "createdAt": "2020-08-10T15:27:43Z", "commit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyNzo0M1rOG-TggQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyNzo0M1rOG-TggQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NDUxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Retrieve a backup file with the given name from the server.\n          \n          \n            \n                * Retrieves a backup file with the given name from the server.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r467984513", "createdAt": "2020-08-10T15:27:43Z", "author": {"login": "oraNod"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "diffHunk": "@@ -46,4 +49,74 @@\n    CompletionStage<RestResponse> cancelPushState(String backup);\n \n    CompletionStage<RestResponse> caches();\n+\n+   /**\n+    * Creates a backup file containing all resources in this container.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name) {\n+      return createBackup(name, null);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param resources a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                  list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name, Map<String, List<String>> resources) {\n+      return createBackup(name, null, resources);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param workingDir the path of the server directory to be used to create the backup content and store the final\n+    *                   backup file. A null value indicates that the server default should be used.\n+    * @param resources  a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                   list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources);\n+\n+   /**\n+    * Retrieve a backup file with the given name from the server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzM0MTQ1", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-464334145", "createdAt": "2020-08-10T15:27:53Z", "commit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyNzo1M1rOG-Tg9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyNzo1M1rOG-Tg9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NDYyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Delete a backup file from the server.\n          \n          \n            \n                * Deletes a backup file from the server.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r467984628", "createdAt": "2020-08-10T15:27:53Z", "author": {"login": "oraNod"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "diffHunk": "@@ -46,4 +49,74 @@\n    CompletionStage<RestResponse> cancelPushState(String backup);\n \n    CompletionStage<RestResponse> caches();\n+\n+   /**\n+    * Creates a backup file containing all resources in this container.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name) {\n+      return createBackup(name, null);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param resources a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                  list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name, Map<String, List<String>> resources) {\n+      return createBackup(name, null, resources);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param workingDir the path of the server directory to be used to create the backup content and store the final\n+    *                   backup file. A null value indicates that the server default should be used.\n+    * @param resources  a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                   list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources);\n+\n+   /**\n+    * Retrieve a backup file with the given name from the server.\n+    *\n+    * @param name     the name of the backup.\n+    * @param skipBody if true, then a HEAD request is issued to the server and only the HTTP headers are returned.\n+    */\n+   CompletionStage<RestResponse> getBackup(String name, boolean skipBody);\n+\n+   /**\n+    * Delete a backup file from the server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzM3NTY1", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-464337565", "createdAt": "2020-08-10T15:29:24Z", "commit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyOToyNFrOG-Tk4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyOToyNFrOG-Tk4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NTYzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Retrieve a backup file with the given name from the server.\n          \n          \n            \n                * Retrieves a backup file with the given name from the server.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r467985633", "createdAt": "2020-08-10T15:29:24Z", "author": {"login": "oraNod"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestClusterClient.java", "diffHunk": "@@ -17,4 +18,41 @@\n     * Shuts down the specified servers\n     */\n    CompletionStage<RestResponse> stop(List<String> server);\n+\n+   /**\n+    * Creates a backup file containing the content of all containers in the cluster.\n+    *\n+    * @param name the name of the backup.\n+    */\n+   CompletionStage<RestResponse> createBackup(String name);\n+\n+   /**\n+    * Retrieve a backup file with the given name from the server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzM3ODgw", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-464337880", "createdAt": "2020-08-10T15:29:32Z", "commit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyOTozMlrOG-TlLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyOTozMlrOG-TlLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NTcwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Delete a backup file from the server.\n          \n          \n            \n                * Deletes a backup file from the server.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r467985709", "createdAt": "2020-08-10T15:29:32Z", "author": {"login": "oraNod"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestClusterClient.java", "diffHunk": "@@ -17,4 +18,41 @@\n     * Shuts down the specified servers\n     */\n    CompletionStage<RestResponse> stop(List<String> server);\n+\n+   /**\n+    * Creates a backup file containing the content of all containers in the cluster.\n+    *\n+    * @param name the name of the backup.\n+    */\n+   CompletionStage<RestResponse> createBackup(String name);\n+\n+   /**\n+    * Retrieve a backup file with the given name from the server.\n+    *\n+    * @param name     the name of the backup.\n+    * @param skipBody if true, then a HEAD request is issued to the server and only the HTTP headers are returned.\n+    */\n+   CompletionStage<RestResponse> getBackup(String name, boolean skipBody);\n+\n+   /**\n+    * Delete a backup file from the server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/c3d4a897db3ee4133a93c1032fefa531fb3fc27f", "committedDate": "2020-08-06T13:54:04Z", "message": "ISPN-11723 REST API docs added"}, "afterCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/2f57736b5792ba572c18792f105772d7eeea0b78", "committedDate": "2020-08-11T08:55:22Z", "message": "ISPN-11723 REST API docs added"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MTYzOTUy", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-466163952", "createdAt": "2020-08-12T18:21:22Z", "commit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODoyMToyMlrOG_tL7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxOTowNzowNVrOG_uvUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1MzgwNw==", "bodyText": "We don't specify what null does here. I am guessing it means everything? I only ask one of the default methods passes it.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469453807", "createdAt": "2020-08-12T18:21:22Z", "author": {"login": "wburns"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "diffHunk": "@@ -46,4 +49,74 @@\n    CompletionStage<RestResponse> cancelPushState(String backup);\n \n    CompletionStage<RestResponse> caches();\n+\n+   /**\n+    * Creates a backup file containing all resources in this container.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name) {\n+      return createBackup(name, null);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param resources a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                  list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name, Map<String, List<String>> resources) {\n+      return createBackup(name, null, resources);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param workingDir the path of the server directory to be used to create the backup content and store the final\n+    *                   backup file. A null value indicates that the server default should be used.\n+    * @param resources  a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1Mzg5MQ==", "bodyText": "Same about null here.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469453891", "createdAt": "2020-08-12T18:21:31Z", "author": {"login": "wburns"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "diffHunk": "@@ -46,4 +49,74 @@\n    CompletionStage<RestResponse> cancelPushState(String backup);\n \n    CompletionStage<RestResponse> caches();\n+\n+   /**\n+    * Creates a backup file containing all resources in this container.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name) {\n+      return createBackup(name, null);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param resources a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                  list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name, Map<String, List<String>> resources) {\n+      return createBackup(name, null, resources);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param workingDir the path of the server directory to be used to create the backup content and store the final\n+    *                   backup file. A null value indicates that the server default should be used.\n+    * @param resources  a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                   list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources);\n+\n+   /**\n+    * Retrieves a backup file with the given name from the server.\n+    *\n+    * @param name     the name of the backup.\n+    * @param skipBody if true, then a HEAD request is issued to the server and only the HTTP headers are returned.\n+    */\n+   CompletionStage<RestResponse> getBackup(String name, boolean skipBody);\n+\n+   /**\n+    * Deletes a backup file from the server.\n+    *\n+    * @param name the name of the backup.\n+    */\n+   CompletionStage<RestResponse> deleteBackup(String name);\n+\n+   /**\n+    * Restores all content associated with this containers name contained within the provided backup file. The backup\n+    * file is uploaded via the server endpoint for processing, returning once the restoration has completed.\n+    *\n+    * @param backup the backup {@link File} containing the data to be restored.\n+    */\n+   default CompletionStage<RestResponse> restore(File backup) {\n+      return restore(backup, null);\n+   }\n+\n+   /**\n+    * Restores the specified content from the backup file that's associated with this container's name.\n+    *\n+    * @param backup    the backup {@link File} containing the data to be restored.\n+    * @param resources a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NTIxNA==", "bodyText": "Do we need to escape any json characters here? Could the String contain valid json delimiters?\nGuessing the Json object does that for us.\nAlso does Json.factory().make(resources) not do what we want?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469455214", "createdAt": "2020-08-12T18:23:59Z", "author": {"login": "wburns"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/impl/okhttp/RestCacheManagerClientOkHttp.java", "diffHunk": "@@ -121,4 +128,75 @@ public String name() {\n    public CompletionStage<RestResponse> caches() {\n       return client.execute(baseCacheManagerUrl, \"caches\");\n    }\n+\n+   @Override\n+   public CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      if (workingDir != null)\n+         json.set(\"directory\", workingDir);\n+\n+      if (resources != null) {\n+         Json resourcesJson = Json.object();\n+         resources.forEach((k, v) -> resourcesJson.set(k, v.toArray(new String[0])));\n+         json.set(\"resources\", resourcesJson);\n+      }\n+      RequestBody body = new StringRestEntityOkHttp(MediaType.APPLICATION_JSON, json.toString()).toRequestBody();\n+      Request.Builder builder = backup(name).post(body);\n+      return client.execute(builder);\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> getBackup(String name, boolean skipBody) {\n+      Request.Builder builder = backup(name);\n+      if (skipBody)\n+         builder.head();\n+\n+      return client.execute(builder);\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> deleteBackup(String name) {\n+      return client.execute(backup(name).delete());\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> restore(File backup, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      if (resources != null) {\n+         resources.forEach((k, v) -> json.set(k, v.toArray(new String[0])));\n+      }\n+      RequestBody zipBody = new FileRestEntityOkHttp(MediaType.APPLICATION_ZIP, backup).toRequestBody();\n+\n+      RequestBody multipartBody = new MultipartBody.Builder()\n+            .addFormDataPart(\"resources\", json.toString())\n+            .addFormDataPart(\"backup\", backup.getName(), zipBody)\n+            .setType(MultipartBody.FORM)\n+            .build();\n+\n+      Request.Builder builder = restore().post(multipartBody);\n+      return client.execute(builder);\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> restore(String backupLocation, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      json.set(\"location\", backupLocation);\n+\n+      if (resources != null) {\n+         Json resourcesJson = Json.object();\n+         resources.forEach((k, v) -> resourcesJson.set(k, v.toArray(new String[0])));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NzM5Nw==", "bodyText": "Do we not want the info from the stores?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469457397", "createdAt": "2020-08-12T18:27:49Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1ODEzNw==", "bodyText": "This is redundant. You can just return the value returned from invoking entryPublisher.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469458137", "createdAt": "2020-08-12T18:29:07Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,\n+               DeliveryGuarantee.EXACTLY_ONCE, BUFFER_SIZE, PublisherTransformers.identity())\n+               .subscribe(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1OTEzNA==", "bodyText": "I am thinking it would be better to use BlockingManager#supplyBlocking and thenCompose invoke thenCompose on it. This way we won't be blocking a blocking thread unless it is processing a response to write to disk.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469459134", "createdAt": "2020-08-12T18:30:51Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2MzE3Ng==", "bodyText": "Can we not do this in subscribe instead?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469463176", "createdAt": "2020-08-12T18:38:00Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,\n+               DeliveryGuarantee.EXACTLY_ONCE, BUFFER_SIZE, PublisherTransformers.identity())\n+               .subscribe(s);\n+\n+         StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+         boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getKeyStorageMediaType());\n+         boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+         PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+         Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+         Flowable.using(\n+               () -> Files.newOutputStream(datFile),\n+               output ->\n+                     Flowable.fromPublisher(p)\n+                           .buffer(BUFFER_SIZE)\n+                           .flatMap(Flowable::fromIterable)\n+                           .map(e -> {\n+                              CacheBackupEntry be = new CacheBackupEntry();\n+                              be.key = keyMarshalling ? marshall(e.getKey(), userMarshaller) : (byte[]) scm.getKeyWrapper().unwrap(e.getKey());\n+                              be.value = valueMarshalling ? marshall(e.getValue(), userMarshaller) : (byte[]) scm.getValueWrapper().unwrap(e.getKey());\n+                              be.metadata = marshall(e.getMetadata(), persistenceMarshaller);\n+                              be.internalMetadata = e.getInternalMetadata();\n+                              be.created = e.getCreated();\n+                              be.lastUsed = e.getLastUsed();\n+                              return be;\n+                           })\n+                           .doOnNext(e -> writeMessageStream(e, serCtx, output))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2MzIyMA==", "bodyText": "This buffer and flatMap looks extraneous. What was the reason for them?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469463220", "createdAt": "2020-08-12T18:38:04Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,\n+               DeliveryGuarantee.EXACTLY_ONCE, BUFFER_SIZE, PublisherTransformers.identity())\n+               .subscribe(s);\n+\n+         StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+         boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getKeyStorageMediaType());\n+         boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+         PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+         Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+         Flowable.using(\n+               () -> Files.newOutputStream(datFile),\n+               output ->\n+                     Flowable.fromPublisher(p)\n+                           .buffer(BUFFER_SIZE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDA3NA==", "bodyText": "I noticed that we do an unbounded run of this. Should we limit how many blocking threads we are using? I worry about delaying actual operations on the server or even worse possibly getting some sort of livelock.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469464074", "createdAt": "2020-08-12T18:39:37Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDU3MA==", "bodyText": "Can we not just use state transfer chunk size? This is what the publisher will use whenever we make an actual user facing API for it ;)", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469464570", "createdAt": "2020-08-12T18:40:29Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3MzIyMA==", "bodyText": "So what you have here is handled a lot better if you add a method like the following to the BlockingManager\n   public <V> CompletionStage<Void> blockingPublisherToVoidStage(Publisher<V> publisher, Object traceId) {\n      CompletionStage<Void> stage = Flowable.defer(() -> {\n         Flowable<V> flowable = Flowable.fromPublisher(publisher);\n         if (isCurrentThreadBlocking()) {\n            return flowable;\n         }\n         if (trace) {\n            flowable = flowable.doOnSubscribe(subscription -> log.tracef(\"Subscribing to %s on blocking thread\"));\n         }\n         flowable = flowable.subscribeOn(blockingScheduler);\n         if (trace) {\n            flowable = flowable.doOnSubscribe(subscription -> log.tracef(\"Publisher subscribing thread is %s\"));\n         }\n         return flowable;\n      }).ignoreElements().toCompletionStage(null);\n\n      return continueOnNonBlockingThread(stage, traceId);\n   }\nI believe the doOnSubscribe is in the correct spot, but you may want to verify. The goal is to print it in the blocking thread so you can match operations between.\nThen you can just replace with this method and remove the subscribe below. This way it will properly resume on a non blocking thread. To be honest you may want to evaluate all your usages of runBlocking to see if you want to use this instead.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469473220", "createdAt": "2020-08-12T18:55:57Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CounterResource.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.COUNTERS;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.counter.api.CounterConfiguration;\n+import org.infinispan.counter.api.CounterManager;\n+import org.infinispan.counter.api.CounterType;\n+import org.infinispan.counter.api.StrongCounter;\n+import org.infinispan.counter.api.WeakCounter;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#COUNTERS}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CounterResource extends AbstractContainerResource {\n+\n+   private static final String COUNTERS_FILE = \"counters.dat\";\n+\n+   private final CounterManager counterManager;\n+   private final ImmutableSerializationContext serCtx;\n+\n+   CounterResource(BlockingManager blockingManager, EmbeddedCacheManager cm,\n+                   BackupManager.Resources params, Path root) {\n+      super(COUNTERS, params, blockingManager, root);\n+      GlobalComponentRegistry gcr = cm.getGlobalComponentRegistry();\n+      this.counterManager = gcr.getComponent(CounterManager.class);\n+      this.serCtx = gcr.getComponent(SerializationContextRegistry.class).getPersistenceCtx();\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      if (wildcard) {\n+         resources.addAll(counterManager.getCounterNames());\n+         return;\n+      }\n+\n+      for (String counterName : resources) {\n+         if (counterManager.getConfiguration(counterName) == null)\n+            throw log.unableToFindResource(type.toString(), counterName);\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      return blockingManager.runBlocking(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3OTI1MQ==", "bodyText": "It makes me wonder if we should add some extra methods to BlockingManager#BlockingExecutor to handle these types of cases.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469479251", "createdAt": "2020-08-12T19:07:05Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDA3NA=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 104}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/2f57736b5792ba572c18792f105772d7eeea0b78", "committedDate": "2020-08-11T08:55:22Z", "message": "ISPN-11723 REST API docs added"}, "afterCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/ca1605d5abf808eb41677c2f4a028aea86d931a4", "committedDate": "2020-08-13T10:57:19Z", "message": "Don docs feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODM5ODg5", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-466839889", "createdAt": "2020-08-13T14:52:32Z", "commit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDo1MjozMlrOHAPP0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTowODowMVrOHAP8YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAxMTg1OA==", "bodyText": "Looks like you can use\n      if (resources != null)\n         json.set(\"resources\", Json.factory().make(resources));\nfrom the other method.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470011858", "createdAt": "2020-08-13T14:52:32Z", "author": {"login": "wburns"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/impl/okhttp/RestCacheManagerClientOkHttp.java", "diffHunk": "@@ -121,4 +128,70 @@ public String name() {\n    public CompletionStage<RestResponse> caches() {\n       return client.execute(baseCacheManagerUrl, \"caches\");\n    }\n+\n+   @Override\n+   public CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      if (workingDir != null)\n+         json.set(\"directory\", workingDir);\n+\n+      if (resources != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyMzI2NA==", "bodyText": "Makes sense. This makes me wonder if we should have the default value be if the store it uses is shared or not.\nAlso I wonder if we should add support for the Flag SKIP_SHARED_CACHE_STORE in the ClusterPublisherManager", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470023264", "createdAt": "2020-08-13T15:08:01Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NzM5Nw=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 199}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODcyNDA3", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-466872407", "createdAt": "2020-08-13T15:26:39Z", "commit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToyNjo0MFrOHAQwMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozMTo0N1rOHAQ9nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzNjUzMQ==", "bodyText": "Technically this method can block as well. I would say we could use Cache#sizeAsync but that requires getting all elements. TBH, until we have a Cache#isEmptyAsync I would recommend just removing this if block. Although it would be quite simple to add this method to the cache if you wanted.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470036531", "createdAt": "2020-08-13T15:26:40Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+      Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+      // Create the cache backup dir and parents\n+      Path cacheRoot = root.resolve(cacheName);\n+      mkdirs(cacheRoot);\n+\n+      CompletionStage<Void> configStage = blockingManager.runBlocking(() -> {\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+      }, \"write-cache-config\");\n+\n+      if (cache.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzOTQzNQ==", "bodyText": "Sorry I didn't notice this earlier, but this doesn't do what you want sadly.\nYou need to do something like \n  \n    \n      infinispan/core/src/main/java/org/infinispan/stream/impl/DistributedCacheStream.java\n    \n    \n         Line 378\n      in\n      37abd44\n    \n    \n    \n    \n\n        \n          \n           .onErrorResumeNext(RxJavaInterop.cacheExceptionWrapper()), distributedBatchSize);", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470039435", "createdAt": "2020-08-13T15:30:57Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+      Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+      // Create the cache backup dir and parents\n+      Path cacheRoot = root.resolve(cacheName);\n+      mkdirs(cacheRoot);\n+\n+      CompletionStage<Void> configStage = blockingManager.runBlocking(() -> {\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+      }, \"write-cache-config\");\n+\n+      if (cache.isEmpty())\n+         return configStage;\n+\n+      ComponentRegistry cr = cache.getComponentRegistry();\n+      ClusterPublisherManager<Object, Object> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+      SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+      ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+      String dataFileName = dataFile(cacheName);\n+      Path datFile = cacheRoot.resolve(dataFileName);\n+\n+      int bufferSize = configuration.clustering().stateTransfer().chunkSize();\n+      Publisher<CacheEntry<Object, Object>> p = clusterPublisherManager.entryPublisher(null, null, null, true,\n+            DeliveryGuarantee.EXACTLY_ONCE, bufferSize, PublisherTransformers.identity());\n+\n+      StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+      boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getKeyStorageMediaType());\n+      boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+      PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+      Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+      CompletionStage<Void> contentStage = blockingManager.blockingPublisherToVoidStage(\n+            Flowable.using(\n+                  () -> Files.newOutputStream(datFile),\n+                  output ->\n+                        Flowable.fromPublisher(p)\n+                              .map(e -> {\n+                                 CacheBackupEntry be = new CacheBackupEntry();\n+                                 be.key = keyMarshalling ? marshall(e.getKey(), userMarshaller) : (byte[]) scm.getKeyWrapper().unwrap(e.getKey());\n+                                 be.value = valueMarshalling ? marshall(e.getValue(), userMarshaller) : (byte[]) scm.getValueWrapper().unwrap(e.getKey());\n+                                 be.metadata = marshall(e.getMetadata(), persistenceMarshaller);\n+                                 be.internalMetadata = e.getInternalMetadata();\n+                                 be.created = e.getCreated();\n+                                 be.lastUsed = e.getLastUsed();\n+                                 return be;\n+                              })\n+                              .doOnNext(e -> writeMessageStream(e, serCtx, output))\n+                              .doOnError(t -> {\n+                                 throw new CacheException(\"Unable to create cache backup\", t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzOTk2Nw==", "bodyText": "\ud83d\udc4d Forgot it returns a Disposable :(", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470039967", "createdAt": "2020-08-13T15:31:47Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,\n+               DeliveryGuarantee.EXACTLY_ONCE, BUFFER_SIZE, PublisherTransformers.identity())\n+               .subscribe(s);\n+\n+         StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+         boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getKeyStorageMediaType());\n+         boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+         PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+         Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+         Flowable.using(\n+               () -> Files.newOutputStream(datFile),\n+               output ->\n+                     Flowable.fromPublisher(p)\n+                           .buffer(BUFFER_SIZE)\n+                           .flatMap(Flowable::fromIterable)\n+                           .map(e -> {\n+                              CacheBackupEntry be = new CacheBackupEntry();\n+                              be.key = keyMarshalling ? marshall(e.getKey(), userMarshaller) : (byte[]) scm.getKeyWrapper().unwrap(e.getKey());\n+                              be.value = valueMarshalling ? marshall(e.getValue(), userMarshaller) : (byte[]) scm.getValueWrapper().unwrap(e.getKey());\n+                              be.metadata = marshall(e.getMetadata(), persistenceMarshaller);\n+                              be.internalMetadata = e.getInternalMetadata();\n+                              be.created = e.getCreated();\n+                              be.lastUsed = e.getLastUsed();\n+                              return be;\n+                           })\n+                           .doOnNext(e -> writeMessageStream(e, serCtx, output))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2MzE3Ng=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 224}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODc5MDM5", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-466879039", "createdAt": "2020-08-13T15:34:04Z", "commit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozNDowNFrOHARDZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozNDo0MlrOHARE1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MTQ0NQ==", "bodyText": "We can add an if (trace)", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470041445", "createdAt": "2020-08-13T15:34:04Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManagerImpl.java", "diffHunk": "@@ -246,6 +261,26 @@ protected void start() {\n       });\n    }\n \n+   public <V> CompletionStage<Void> blockingPublisherToVoidStage(Publisher<V> publisher, Object traceId) {\n+      CompletionStage<Void> stage = Flowable.defer(() -> {\n+         Flowable<V> flowable = Flowable.fromPublisher(publisher);\n+         if (isCurrentThreadBlocking()) {\n+            log.tracef(\"Invoked on a blocking thread, running %s in same blocking thread\", traceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MTgxNA==", "bodyText": "We should note the stage will always be completed upon a non blocking thread if the current thread is not a blocking one.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470041814", "createdAt": "2020-08-13T15:34:42Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -169,6 +184,19 @@\n     */\n    <V> Publisher<V> blockingPublisher(Publisher<V> publisher);\n \n+   /**\n+    * Subscribes to the provided blocking publisher using the the blocking executor, ignoring all elements and returning\n+    * a {@link CompletionStage} with a value of null when complete.\n+    * <p>\n+    * Note that if the current thread is blocking everything including subscription, publication and collection of\n+    * values will be done on the current thread.\n+    *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ad88219671bd4fd0e5aad27b1d5d6364ceb0ee2e", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/ad88219671bd4fd0e5aad27b1d5d6364ceb0ee2e", "committedDate": "2020-08-13T16:01:25Z", "message": "Will feedback 2.0"}, "afterCommit": {"oid": "3e0b7319afa90ef8dda846de3624827eebbbd964", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/3e0b7319afa90ef8dda846de3624827eebbbd964", "committedDate": "2020-08-13T16:20:43Z", "message": "ISPN-11723 REST API docs added"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTAxODgz", "url": "https://github.com/infinispan/infinispan/pull/8532#pullrequestreview-467101883", "createdAt": "2020-08-13T20:21:41Z", "commit": {"oid": "3e0b7319afa90ef8dda846de3624827eebbbd964"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e0b7319afa90ef8dda846de3624827eebbbd964", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/3e0b7319afa90ef8dda846de3624827eebbbd964", "committedDate": "2020-08-13T16:20:43Z", "message": "ISPN-11723 REST API docs added"}, "afterCommit": {"oid": "afb9ba558954d23cc966607b1405019ca56cced9", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/afb9ba558954d23cc966607b1405019ca56cced9", "committedDate": "2020-08-18T09:10:22Z", "message": "ISPN-11723 REST API docs added"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "afb9ba558954d23cc966607b1405019ca56cced9", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/afb9ba558954d23cc966607b1405019ca56cced9", "committedDate": "2020-08-18T09:10:22Z", "message": "ISPN-11723 REST API docs added"}, "afterCommit": {"oid": "83f0706eabce639bc97dab9171bd0656f0ecde11", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/83f0706eabce639bc97dab9171bd0656f0ecde11", "committedDate": "2020-08-19T09:23:06Z", "message": "Process cache config and content as a single blocking task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "637fa21fdd20258708c49687dfcd0b7a0a4ec14b", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/637fa21fdd20258708c49687dfcd0b7a0a4ec14b", "committedDate": "2020-08-19T15:41:38Z", "message": "ISPN-11723 Serialize modules default namespace\n\nThis allows the xml from a backup created in a past major version to be\ncorrectly parsed when imported by a future major version."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "83f0706eabce639bc97dab9171bd0656f0ecde11", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/83f0706eabce639bc97dab9171bd0656f0ecde11", "committedDate": "2020-08-19T09:23:06Z", "message": "Process cache config and content as a single blocking task"}, "afterCommit": {"oid": "f491132143ab0b421e0fd0cd84c2efdd436d27cc", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/f491132143ab0b421e0fd0cd84c2efdd436d27cc", "committedDate": "2020-08-19T15:41:38Z", "message": "Utilise blockingPublisher"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5029152cd0b6edfd07cec7312e98e17295d88c6", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/d5029152cd0b6edfd07cec7312e98e17295d88c6", "committedDate": "2020-08-19T16:15:10Z", "message": "ISPN-11723 Cluster Backup/Restore tool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14fbe3fe8e53f935f107954343c563549308348f", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/14fbe3fe8e53f935f107954343c563549308348f", "committedDate": "2020-08-19T16:15:10Z", "message": "ISPN-11723 REST API docs added"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f491132143ab0b421e0fd0cd84c2efdd436d27cc", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/f491132143ab0b421e0fd0cd84c2efdd436d27cc", "committedDate": "2020-08-19T15:41:38Z", "message": "Utilise blockingPublisher"}, "afterCommit": {"oid": "14fbe3fe8e53f935f107954343c563549308348f", "author": {"user": {"login": "ryanemerson", "name": "Ryan Emerson"}}, "url": "https://github.com/infinispan/infinispan/commit/14fbe3fe8e53f935f107954343c563549308348f", "committedDate": "2020-08-19T16:15:10Z", "message": "ISPN-11723 REST API docs added"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 507, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}