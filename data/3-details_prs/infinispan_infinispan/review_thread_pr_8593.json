{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NDc3NDE5", "number": 8593, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToyMTo1MFrOETmbKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNlQwOToyMjowOVrOFXZyOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTg3OTQ0OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/persistence/ClusterCacheLoaderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToyMTo1MFrOG5bJHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjo1NToyNlrOG5hwLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2NjcxNw==", "bodyText": "CacheModes need uncommenting \ud83d\ude42", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462866717", "createdAt": "2020-07-30T09:21:50Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/persistence/ClusterCacheLoaderTest.java", "diffHunk": "@@ -22,7 +22,7 @@\n  * @author Mircea.Markus@jboss.com\n  */\n @Test(groups = \"functional\", testName = \"persistence.ClusterCacheLoaderTest\")\n-@InCacheMode({ CacheMode.INVALIDATION_SYNC, CacheMode.DIST_SYNC, CacheMode.REPL_SYNC, CacheMode.SCATTERED_SYNC })\n+@InCacheMode({ CacheMode.INVALIDATION_SYNC/*, CacheMode.DIST_SYNC, CacheMode.REPL_SYNC, CacheMode.SCATTERED_SYNC*/ })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NTAyMg==", "bodyText": "Yes, forgot to put them back in.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462975022", "createdAt": "2020-07-30T12:55:26Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/persistence/ClusterCacheLoaderTest.java", "diffHunk": "@@ -22,7 +22,7 @@\n  * @author Mircea.Markus@jboss.com\n  */\n @Test(groups = \"functional\", testName = \"persistence.ClusterCacheLoaderTest\")\n-@InCacheMode({ CacheMode.INVALIDATION_SYNC, CacheMode.DIST_SYNC, CacheMode.REPL_SYNC, CacheMode.SCATTERED_SYNC })\n+@InCacheMode({ CacheMode.INVALIDATION_SYNC/*, CacheMode.DIST_SYNC, CacheMode.REPL_SYNC, CacheMode.SCATTERED_SYNC*/ })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2NjcxNw=="}, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTg5MjEzOnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToyNToyM1rOG5bRAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjo1NToxMVrOG5hviw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2ODczNw==", "bodyText": "Is it blocking?", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462868737", "createdAt": "2020-07-30T09:25:23Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NDg1OQ==", "bodyText": "No :) - I forgot to remove the TODO.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462974859", "createdAt": "2020-07-30T12:55:11Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2ODczNw=="}, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTkwMTE2OnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToyNzo1MlrOG5bWZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjo1NDo1OFrOG5hvCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MDExOA==", "bodyText": "Do these debug statements really add much as we will throw an exception below if the configuration is not valid.\nIf we remove the logs we can simplify this to a one-liner:\nboolean segmentsMatch = numSegments == null ? false : numSegments == segmentCount;", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462870118", "createdAt": "2020-07-30T09:27:52Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NDczMA==", "bodyText": "We don't always throw an exception below, so that is why I have debug statements so they can be seen.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462974730", "createdAt": "2020-07-30T12:54:58Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MDExOA=="}, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTkxMDg3OnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozMDozN1rOG5bcjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjo1NDoxNFrOG5htYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MTY5NA==", "bodyText": "Nitpick, but if we return early we can reduce the nesting:\nif (metadataValue == null)\n    return null;\n\nMetadata metadata = new EmbeddedMetadata.Builder()...", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462871694", "createdAt": "2020-07-30T09:30:37Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);\n+               remoteCache = remoteCache.withDataFormat(dataFormat);\n+            });\n    }\n \n    @Override\n-   public void stop() throws PersistenceException {\n-      remoteCacheManager.stop();\n+   public Set<Characteristic> characteristics() {\n+      Set<Characteristic> characteristics = EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION,\n+            Characteristic.SHAREABLE);\n+      if (supportsSegmentation) {\n+         characteristics.add(Characteristic.SEGMENTABLE);\n+      }\n+      return characteristics;\n    }\n \n    @Override\n-   public boolean isAvailable() {\n-      try {\n-         PingResponse pr = ((RemoteCacheImpl) remoteCache).ping();\n-         return pr.isSuccess();\n-      } catch (Exception e) {\n-         return false;\n-      }\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> remoteCacheManager.stop(), \"RemoteStore-stop\");\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> get(int segment, Object key) {\n-      return loadEntry(key);\n+   public CompletionStage<Boolean> isAvailable() {\n+      return remoteCache.ping()\n+            .handle((v, t) -> t == null && v.isSuccess());\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> loadEntry(Object key) throws PersistenceException {\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n       if (configuration.rawValues()) {\n          Object unwrappedKey;\n          if (key instanceof WrappedByteArray) {\n             unwrappedKey = ((WrappedByteArray) key).getBytes();\n          } else {\n             unwrappedKey = key;\n          }\n-         MetadataValue<?> value = remoteCache.getWithMetadata(unwrappedKey);\n-         if (value != null) {\n-            Metadata metadata = new EmbeddedMetadata.Builder()\n-                  .version(new NumericVersion(value.getVersion()))\n-                  .lifespan(value.getLifespan(), TimeUnit.SECONDS)\n-                  .maxIdle(value.getMaxIdle(), TimeUnit.SECONDS).build();\n-            long created = value.getCreated();\n-            long lastUsed = value.getLastUsed();\n-            Object realValue = value.getValue();\n-            if (realValue instanceof byte[]) {\n-               realValue = new WrappedByteArray((byte[]) realValue);\n+         CompletableFuture<MetadataValue<Object>> valueStage = remoteCache.getWithMetadataAsync(unwrappedKey);\n+         return valueStage.thenApply(metadataValue -> {\n+            if (metadataValue != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NDMwNQ==", "bodyText": "Sure, I didn't notice the code was like that before \ud83d\udc4d", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462974305", "createdAt": "2020-07-30T12:54:14Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);\n+               remoteCache = remoteCache.withDataFormat(dataFormat);\n+            });\n    }\n \n    @Override\n-   public void stop() throws PersistenceException {\n-      remoteCacheManager.stop();\n+   public Set<Characteristic> characteristics() {\n+      Set<Characteristic> characteristics = EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION,\n+            Characteristic.SHAREABLE);\n+      if (supportsSegmentation) {\n+         characteristics.add(Characteristic.SEGMENTABLE);\n+      }\n+      return characteristics;\n    }\n \n    @Override\n-   public boolean isAvailable() {\n-      try {\n-         PingResponse pr = ((RemoteCacheImpl) remoteCache).ping();\n-         return pr.isSuccess();\n-      } catch (Exception e) {\n-         return false;\n-      }\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> remoteCacheManager.stop(), \"RemoteStore-stop\");\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> get(int segment, Object key) {\n-      return loadEntry(key);\n+   public CompletionStage<Boolean> isAvailable() {\n+      return remoteCache.ping()\n+            .handle((v, t) -> t == null && v.isSuccess());\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> loadEntry(Object key) throws PersistenceException {\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n       if (configuration.rawValues()) {\n          Object unwrappedKey;\n          if (key instanceof WrappedByteArray) {\n             unwrappedKey = ((WrappedByteArray) key).getBytes();\n          } else {\n             unwrappedKey = key;\n          }\n-         MetadataValue<?> value = remoteCache.getWithMetadata(unwrappedKey);\n-         if (value != null) {\n-            Metadata metadata = new EmbeddedMetadata.Builder()\n-                  .version(new NumericVersion(value.getVersion()))\n-                  .lifespan(value.getLifespan(), TimeUnit.SECONDS)\n-                  .maxIdle(value.getMaxIdle(), TimeUnit.SECONDS).build();\n-            long created = value.getCreated();\n-            long lastUsed = value.getLastUsed();\n-            Object realValue = value.getValue();\n-            if (realValue instanceof byte[]) {\n-               realValue = new WrappedByteArray((byte[]) realValue);\n+         CompletableFuture<MetadataValue<Object>> valueStage = remoteCache.getWithMetadataAsync(unwrappedKey);\n+         return valueStage.thenApply(metadataValue -> {\n+            if (metadataValue != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MTY5NA=="}, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTkyNzUzOnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozNToxNlrOG5bnNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozNToxNlrOG5bnNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3NDQyMA==", "bodyText": "wrap(realValue)?", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462874420", "createdAt": "2020-07-30T09:35:16Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,199 +72,244 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassWhiteList whiteList = ctx.getCache().getCacheManager().getClassWhiteList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), whiteList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               // TODO: I believe this is blocking...\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);\n+               remoteCache = remoteCache.withDataFormat(dataFormat);\n+            });\n    }\n \n    @Override\n-   public void stop() throws PersistenceException {\n-      remoteCacheManager.stop();\n+   public Set<Characteristic> characteristics() {\n+      Set<Characteristic> characteristics = EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION,\n+            Characteristic.SHAREABLE);\n+      if (supportsSegmentation) {\n+         characteristics.add(Characteristic.SEGMENTABLE);\n+      }\n+      return characteristics;\n    }\n \n    @Override\n-   public boolean isAvailable() {\n-      try {\n-         PingResponse pr = ((RemoteCacheImpl) remoteCache).ping();\n-         return pr.isSuccess();\n-      } catch (Exception e) {\n-         return false;\n-      }\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> remoteCacheManager.stop(), \"RemoteStore-stop\");\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> get(int segment, Object key) {\n-      return loadEntry(key);\n+   public CompletionStage<Boolean> isAvailable() {\n+      return remoteCache.ping()\n+            .handle((v, t) -> t == null && v.isSuccess());\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> loadEntry(Object key) throws PersistenceException {\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n       if (configuration.rawValues()) {\n          Object unwrappedKey;\n          if (key instanceof WrappedByteArray) {\n             unwrappedKey = ((WrappedByteArray) key).getBytes();\n          } else {\n             unwrappedKey = key;\n          }\n-         MetadataValue<?> value = remoteCache.getWithMetadata(unwrappedKey);\n-         if (value != null) {\n-            Metadata metadata = new EmbeddedMetadata.Builder()\n-                  .version(new NumericVersion(value.getVersion()))\n-                  .lifespan(value.getLifespan(), TimeUnit.SECONDS)\n-                  .maxIdle(value.getMaxIdle(), TimeUnit.SECONDS).build();\n-            long created = value.getCreated();\n-            long lastUsed = value.getLastUsed();\n-            Object realValue = value.getValue();\n-            if (realValue instanceof byte[]) {\n-               realValue = new WrappedByteArray((byte[]) realValue);\n+         CompletableFuture<MetadataValue<Object>> valueStage = remoteCache.getWithMetadataAsync(unwrappedKey);\n+         return valueStage.thenApply(metadataValue -> {\n+            if (metadataValue != null) {\n+               Metadata metadata = new EmbeddedMetadata.Builder()\n+                     .version(new NumericVersion(metadataValue.getVersion()))\n+                     .lifespan(metadataValue.getLifespan(), TimeUnit.SECONDS)\n+                     .maxIdle(metadataValue.getMaxIdle(), TimeUnit.SECONDS).build();\n+               long created = metadataValue.getCreated();\n+               long lastUsed = metadataValue.getLastUsed();\n+               Object realValue = metadataValue.getValue();\n+               if (realValue instanceof byte[]) {\n+                  realValue = new WrappedByteArray((byte[]) realValue);\n+               }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTkzNzQ0OnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozODoxNFrOG5bthQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjo1MzoyN1rOG5hrkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3NjAzNw==", "bodyText": "We should probably add a static unwrap method, as this code is repeated several times. We can then use a method reference here.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462876037", "createdAt": "2020-07-30T09:38:14Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -319,45 +363,46 @@ private Object getValue(MarshallableEntry entry) {\n    }\n \n    @Override\n-   public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-      return Flowable.fromPublisher(publisher)\n-            .buffer(configuration.maxBatchSize())\n-            // TODO: this is blocking - when the full non blocking SPI is introduced this needs to chain returns\n-            // of the putAll to ensure that only a single batch is sent at a time\n-            .doOnNext(entries -> remoteCache.putAll(entries.stream().collect(Collectors.toMap(this::getKey, this::getValue))))\n-            .doOnError(PersistenceException::new)\n-            .ignoreElements()\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      Completable removeCompletable = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)\n+            .map(key -> key instanceof WrappedByteArray ? ((WrappedByteArray) key).getBytes() : key)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 491}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3Mzg0Mw==", "bodyText": "Okay.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462973843", "createdAt": "2020-07-30T12:53:27Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -319,45 +363,46 @@ private Object getValue(MarshallableEntry entry) {\n    }\n \n    @Override\n-   public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-      return Flowable.fromPublisher(publisher)\n-            .buffer(configuration.maxBatchSize())\n-            // TODO: this is blocking - when the full non blocking SPI is introduced this needs to chain returns\n-            // of the putAll to ensure that only a single batch is sent at a time\n-            .doOnNext(entries -> remoteCache.putAll(entries.stream().collect(Collectors.toMap(this::getKey, this::getValue))))\n-            .doOnError(PersistenceException::new)\n-            .ignoreElements()\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      Completable removeCompletable = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)\n+            .map(key -> key instanceof WrappedByteArray ? ((WrappedByteArray) key).getBytes() : key)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3NjAzNw=="}, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 491}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTk1MzQzOnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/internal/RemoteStoreBlockHoundIntegration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTo0MjozNlrOG5b3fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjo1MzowMlrOG5hqww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3ODU5MQ==", "bodyText": "In this PR?", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462878591", "createdAt": "2020-07-30T09:42:36Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/internal/RemoteStoreBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.infinispan.persistence.remote.internal;\n+\n+import org.kohsuke.MetaInfServices;\n+\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@MetaInfServices\n+public class RemoteStoreBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      // TODO: this needs to be moved to the client hotrod module when it adds BlockHound\n+      builder.allowBlockingCallsInside(\"org.infinispan.client.hotrod.impl.transport.netty.ChannelInitializer\", \"initSsl\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3MzYzNQ==", "bodyText": "No, we should do that in a separate one. However I can add a URL to the JIRA (and create if there isn't one).", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462973635", "createdAt": "2020-07-30T12:53:02Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/internal/RemoteStoreBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.infinispan.persistence.remote.internal;\n+\n+import org.kohsuke.MetaInfServices;\n+\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@MetaInfServices\n+public class RemoteStoreBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      // TODO: this needs to be moved to the client hotrod module when it adds BlockHound\n+      builder.allowBlockingCallsInside(\"org.infinispan.client.hotrod.impl.transport.netty.ChannelInitializer\", \"initSsl\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3ODU5MQ=="}, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTk1OTgxOnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/test/java/org/infinispan/persistence/remote/RemoteStoreTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTo0NDozM1rOG5b7nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjo1MzoyMVrOG5hrXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3OTY0NQ==", "bodyText": "Remove?", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462879645", "createdAt": "2020-07-30T09:44:33Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/test/java/org/infinispan/persistence/remote/RemoteStoreTest.java", "diffHunk": "@@ -38,45 +44,101 @@\n  * @since 4.1\n  */\n @Test(testName = \"persistence.remote.RemoteStoreTest\", groups = \"functional\")\n-public class RemoteStoreTest extends BaseStoreTest {\n+public class RemoteStoreTest extends BaseNonBlockingStoreTest {\n \n    private static final String REMOTE_CACHE = \"remote-cache\";\n    private EmbeddedCacheManager localCacheManager;\n+   private AdvancedCache<Object, Object> localCache;\n    private HotRodServer hrServer;\n+   private boolean segmented;\n+   private MediaType cacheMediaType;\n+   private boolean isRawValues;\n+\n+   private ProtoStreamMarshaller marshaller = new ProtoStreamMarshaller(ProtobufUtil.newSerializationContext());\n+\n+   public RemoteStoreTest segmented(boolean segmented) {\n+      this.segmented = segmented;\n+      return this;\n+   }\n+\n+   public RemoteStoreTest cacheMediaType(MediaType cacheMediaType) {\n+      this.cacheMediaType = cacheMediaType;\n+      return this;\n+   }\n+\n+   public RemoteStoreTest rawValues(boolean isRawValues) {\n+      this.isRawValues = isRawValues;\n+      return this;\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      return new Object[] {\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(true),\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(false),\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(true),\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(false),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(true),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(false),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(true),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(false),\n+      };\n+   }\n \n    @Override\n-   protected AdvancedLoadWriteStore createStore() {\n-      ConfigurationBuilder localBuilder = TestCacheManagerFactory.getDefaultCacheConfiguration(false);\n-      localBuilder.memory().evictionType(EvictionType.COUNT).size(WRITE_DELETE_BATCH_MAX_ENTRIES).expiration().wakeUpInterval(10L);\n+   protected String parameters() {\n+      return \"[\" + segmented + \", \" + cacheMediaType + \", \" + isRawValues + \"]\";\n+   }\n+\n+   @Override\n+   protected Configuration buildConfig(ConfigurationBuilder cb) {\n+      cb.memory().maxCount(WRITE_DELETE_BATCH_MAX_ENTRIES)\n+            .expiration().wakeUpInterval(10L);\n+\n+      // Unfortunately BaseNonBlockingStore stops and restarts the store, which can start a second hrServer - prevent that\n+      if (hrServer == null) {\n+         GlobalConfigurationBuilder globalConfig = new GlobalConfigurationBuilder().clusteredDefault();\n+         globalConfig.defaultCacheName(REMOTE_CACHE);\n+\n+         ConfigurationBuilder configurationBuilder = hotRodCacheConfiguration(cb);\n+         configurationBuilder.encoding().mediaType(cacheMediaType.toString());\n+         configurationBuilder.clustering().cacheMode(CacheMode.DIST_SYNC);\n+         localCacheManager = TestCacheManagerFactory.createClusteredCacheManager(\n+               globalConfig, configurationBuilder);\n+         TestingUtil.replaceComponent(localCacheManager, TimeService.class, timeService, true);\n+\n+         localCache = (AdvancedCache<Object, Object>) localCacheManager.getCache(REMOTE_CACHE).getAdvancedCache()\n+               .withMediaType(MediaType.APPLICATION_OBJECT_TYPE, MediaType.APPLICATION_OBJECT_TYPE);\n+         keyPartitioner = localCache.getAdvancedCache().getComponentRegistry().getComponent(KeyPartitioner.class);\n+\n+         hrServer = HotRodClientTestingUtil.startHotRodServer(localCacheManager);\n+         // In case if the server has to unmarshall the value, make sure to use the same marshaller\n+//         hrServer.setMarshaller(getMarshaller());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3Mzc4OA==", "bodyText": "Sure, I was more testing to see if it was needed, which it obviously isn't :)", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462973788", "createdAt": "2020-07-30T12:53:21Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/test/java/org/infinispan/persistence/remote/RemoteStoreTest.java", "diffHunk": "@@ -38,45 +44,101 @@\n  * @since 4.1\n  */\n @Test(testName = \"persistence.remote.RemoteStoreTest\", groups = \"functional\")\n-public class RemoteStoreTest extends BaseStoreTest {\n+public class RemoteStoreTest extends BaseNonBlockingStoreTest {\n \n    private static final String REMOTE_CACHE = \"remote-cache\";\n    private EmbeddedCacheManager localCacheManager;\n+   private AdvancedCache<Object, Object> localCache;\n    private HotRodServer hrServer;\n+   private boolean segmented;\n+   private MediaType cacheMediaType;\n+   private boolean isRawValues;\n+\n+   private ProtoStreamMarshaller marshaller = new ProtoStreamMarshaller(ProtobufUtil.newSerializationContext());\n+\n+   public RemoteStoreTest segmented(boolean segmented) {\n+      this.segmented = segmented;\n+      return this;\n+   }\n+\n+   public RemoteStoreTest cacheMediaType(MediaType cacheMediaType) {\n+      this.cacheMediaType = cacheMediaType;\n+      return this;\n+   }\n+\n+   public RemoteStoreTest rawValues(boolean isRawValues) {\n+      this.isRawValues = isRawValues;\n+      return this;\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      return new Object[] {\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(true),\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(false),\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(true),\n+            new RemoteStoreTest().segmented(false).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(false),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(true),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_OBJECT).rawValues(false),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(true),\n+            new RemoteStoreTest().segmented(true).cacheMediaType(MediaType.APPLICATION_PROTOSTREAM).rawValues(false),\n+      };\n+   }\n \n    @Override\n-   protected AdvancedLoadWriteStore createStore() {\n-      ConfigurationBuilder localBuilder = TestCacheManagerFactory.getDefaultCacheConfiguration(false);\n-      localBuilder.memory().evictionType(EvictionType.COUNT).size(WRITE_DELETE_BATCH_MAX_ENTRIES).expiration().wakeUpInterval(10L);\n+   protected String parameters() {\n+      return \"[\" + segmented + \", \" + cacheMediaType + \", \" + isRawValues + \"]\";\n+   }\n+\n+   @Override\n+   protected Configuration buildConfig(ConfigurationBuilder cb) {\n+      cb.memory().maxCount(WRITE_DELETE_BATCH_MAX_ENTRIES)\n+            .expiration().wakeUpInterval(10L);\n+\n+      // Unfortunately BaseNonBlockingStore stops and restarts the store, which can start a second hrServer - prevent that\n+      if (hrServer == null) {\n+         GlobalConfigurationBuilder globalConfig = new GlobalConfigurationBuilder().clusteredDefault();\n+         globalConfig.defaultCacheName(REMOTE_CACHE);\n+\n+         ConfigurationBuilder configurationBuilder = hotRodCacheConfiguration(cb);\n+         configurationBuilder.encoding().mediaType(cacheMediaType.toString());\n+         configurationBuilder.clustering().cacheMode(CacheMode.DIST_SYNC);\n+         localCacheManager = TestCacheManagerFactory.createClusteredCacheManager(\n+               globalConfig, configurationBuilder);\n+         TestingUtil.replaceComponent(localCacheManager, TimeService.class, timeService, true);\n+\n+         localCache = (AdvancedCache<Object, Object>) localCacheManager.getCache(REMOTE_CACHE).getAdvancedCache()\n+               .withMediaType(MediaType.APPLICATION_OBJECT_TYPE, MediaType.APPLICATION_OBJECT_TYPE);\n+         keyPartitioner = localCache.getAdvancedCache().getComponentRegistry().getComponent(KeyPartitioner.class);\n+\n+         hrServer = HotRodClientTestingUtil.startHotRodServer(localCacheManager);\n+         // In case if the server has to unmarshall the value, make sure to use the same marshaller\n+//         hrServer.setMarshaller(getMarshaller());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3OTY0NQ=="}, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDQ2MzQ5OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/CacheTopologyInfo.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjoyNToyOFrOG5gvrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzo0ODo0NFrOG5j1iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1ODUxMA==", "bodyText": "CacheTopologyInfo is accessible from RemoteCache.getCacheTopologyInfo(), so this is going to break backwards compatibility.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462958510", "createdAt": "2020-07-30T12:25:28Z", "author": {"login": "danberindei"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/CacheTopologyInfo.java", "diffHunk": "@@ -15,7 +15,7 @@\n    /**\n     * @return The number of configured segments for the cache.\n     */\n-   int getNumSegments();\n+   Integer getNumSegments();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3MjQ0Mg==", "bodyText": "It was already broken, I didn't change the underlying code. Just the API definition. So the only thing I broke is binary compatibility as it already threw a NPE before :)", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462972442", "createdAt": "2020-07-30T12:51:01Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/CacheTopologyInfo.java", "diffHunk": "@@ -15,7 +15,7 @@\n    /**\n     * @return The number of configured segments for the cache.\n     */\n-   int getNumSegments();\n+   Integer getNumSegments();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1ODUxMA=="}, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3ODg2Ng==", "bodyText": "https://github.com/infinispan/infinispan/blob/master/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/CacheTopologyInfoImpl.java#L15", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462978866", "createdAt": "2020-07-30T13:02:01Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/CacheTopologyInfo.java", "diffHunk": "@@ -15,7 +15,7 @@\n    /**\n     * @return The number of configured segments for the cache.\n     */\n-   int getNumSegments();\n+   Integer getNumSegments();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1ODUxMA=="}, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAwOTE2Mw==", "bodyText": "IIUC it was only broken for LOCAL caches, which aren't used that much on the server, no?", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r463009163", "createdAt": "2020-07-30T13:48:44Z", "author": {"login": "danberindei"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/CacheTopologyInfo.java", "diffHunk": "@@ -15,7 +15,7 @@\n    /**\n     * @return The number of configured segments for the cache.\n     */\n-   int getNumSegments();\n+   Integer getNumSegments();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1ODUxMA=="}, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDQ3NDMwOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjoyODo0NFrOG5g2aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjoyODo0NFrOG5g2aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MDIzMg==", "bodyText": "Should have @Override now", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r462960232", "createdAt": "2020-07-30T12:28:44Z", "author": {"login": "danberindei"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java", "diffHunk": "@@ -563,8 +563,8 @@ public void removeClientListener(Object listener) {\n       return result;\n    }\n \n-   public PingResponse ping() {\n-      return await(operationsFactory.newFaultTolerantPingOperation().execute());\n+   public CompletionStage<PingResponse> ping() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e502b6565f3756083dd5d3b397f673a59a28f95c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzkyNzA1OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec27.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMDoyODoxMFrOG7aixw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMDoyODoxMFrOG7aixw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk1NDA1NQ==", "bodyText": "A bit off-topic, but from reading the code, I think a null value should be fine.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r464954055", "createdAt": "2020-08-04T10:28:10Z", "author": {"login": "danberindei"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec27.java", "diffHunk": "@@ -23,7 +25,6 @@ public HeaderParams writeHeader(ByteBuf buf, HeaderParams params) {\n          IntSet segments, int batchSize) {\n       return new IteratorMapper<>(remoteCache.retrieveEntries(\n             // Use the ToEmptyBytesKeyValueFilterConverter to remove value payload\n-            \"org.infinispan.server.hotrod.HotRodServer$ToEmptyBytesKeyValueFilterConverter\", segments, batchSize),\n-            e -> (K) e.getKey());\n+            EMPTY_VAUE_CONVERTER, segments, batchSize), e -> (K) e.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e898323311376a9aee0b42ed1ff32aa6d22af24"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzk0MTE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/remote/ClusteredGetCommand.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMDozMjo0NlrOG7arVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMDozMjo0NlrOG7arVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk1NjI0Nw==", "bodyText": "It's cheaper to write -1 with SignedNumeric when the segment is missing.\nIt's also cheaper when reading, because autoboxing won't have to look up the segment in the Integer cache.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r464956247", "createdAt": "2020-08-04T10:32:46Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/remote/ClusteredGetCommand.java", "diffHunk": "@@ -109,14 +116,22 @@ public byte getCommandId() {\n    @Override\n    public void writeTo(ObjectOutput output) throws IOException {\n       output.writeObject(key);\n-      UnsignedNumeric.writeUnsignedInt(output, segment);\n+      if (segment != null) {\n+         output.writeBoolean(true);\n+         UnsignedNumeric.writeUnsignedInt(output, segment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e898323311376a9aee0b42ed1ff32aa6d22af24"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNDQ0MTc0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/configuration/parsing/Parser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMzowMjo1MlrOG7fX7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMzowMjo1MlrOG7fX7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE5OA==", "bodyText": "Could we change parseStoreAttribute to parse the base store attributes and let the specific store methods parse the store-specific attributes?\nThere's a bit of duplication, and I'm not sure why so many attributes are parsed but ignored unless the \"custom\" store is a SingleFileStore.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r465033198", "createdAt": "2020-08-04T13:02:52Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/configuration/parsing/Parser.java", "diffHunk": "@@ -2626,6 +2627,9 @@ private void parseCustomStore(final XMLExtendedStreamReader reader, final Config\n             case TRANSACTIONAL:\n                transactional = Boolean.parseBoolean(value);\n                break;\n+            case SEGMENTED:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e898323311376a9aee0b42ed1ff32aa6d22af24"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMjAzMTM4OnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwODowMDo1NVrOG8nvgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzozNzozNVrOG9aLuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxODg4MQ==", "bodyText": "unnecessary additional brackets", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466218881", "createdAt": "2020-08-06T08:00:55Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NTMwNw==", "bodyText": "Technically, they are needed as I am assigning a variable in there. Dan doesn't like these and usually makes me move them to a different line :D", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467045307", "createdAt": "2020-08-07T13:37:35Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxODg4MQ=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMjA0MzQwOnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwODowNDoxOVrOG8n3EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzozNzo1NlrOG9aMkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyMDgxNw==", "bodyText": "I think this needs to be debugf \ud83d\ude42", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466220817", "createdAt": "2020-08-06T08:04:19Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NTUyMg==", "bodyText": "Yea, this was only here for testing purposes. Let me change this, I might just remove.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467045522", "createdAt": "2020-08-07T13:37:56Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyMDgxNw=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMjA3MTQzOnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwODoxMToyOFrOG8oHmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjozNTo0NVrOG-WhYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNTA0OQ==", "bodyText": "We can reduce the verbosity of this and keep the logic in one place by adding a couple of methods that are then used for setting both key/value types and marshaller:\n               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n                  dataFormatBuilder.keyType(getMediaType(localKeyStorageType, marshaller));\n                  dataFormatBuilder.keyMarshaller(getMarshaller(localKeyStorageType, marshaller));\n               } else if (configuration.segmented()) {\n                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n               }\n               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n               if (!configuration.rawValues()) {\n                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n               }\n               if (localValueStorageType.equals(serverValueStorageType)) {\n                  dataFormatBuilder.valueType(getMediaType(localKeyStorageType, marshaller));\n                  dataFormatBuilder.valueMarshaller(getMarshaller(localKeyStorageType, marshaller));\n               }\n...\n   private MediaType getMediaType(MediaType local, Marshaller marshaller) {\n      return local.isBinary() ? local : marshaller.mediaType();\n   }\n\n   private Marshaller getMarshaller(MediaType local, Marshaller marshaller) {\n      return local.isBinary() ? IdentityMarshaller.INSTANCE : marshaller;\n   }\nOr we could just have the ternary operator inline.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466225049", "createdAt": "2020-08-06T08:11:28Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk5NzQxOQ==", "bodyText": "Hrmm, sure I can do this.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467997419", "createdAt": "2020-08-10T15:39:33Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNTA0OQ=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAwMDEyOQ==", "bodyText": "Unfortunately, this leads to a bit of a weird logic in that getMediaType takes a marshaller that is itself dependent upon getMarshaller as we don't want to ever use the media type from IdentityMarshaller. I will play this a bit more.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r468000129", "createdAt": "2020-08-10T15:41:37Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNTA0OQ=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzMzg5MA==", "bodyText": "I have changed it to ternary, which while doesn't consolidate the 2 branches think it makes the code a bit more straight forward that they are dependent upon each other.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r468033890", "createdAt": "2020-08-10T16:35:45Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNTA0OQ=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMjA4MTY5OnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwODoxNDoxOVrOG8oN1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzo0MTo0NFrOG9aVXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNjY0Nw==", "bodyText": "Nitpick, but unnecessary variable as the declaration is longer than the actual method call. I would just call thenApply directly.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466226647", "createdAt": "2020-08-06T08:14:19Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);\n+               remoteCache = remoteCache.withDataFormat(dataFormat);\n+            });\n    }\n \n    @Override\n-   public void stop() throws PersistenceException {\n-      remoteCacheManager.stop();\n+   public Set<Characteristic> characteristics() {\n+      Set<Characteristic> characteristics = EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION,\n+            Characteristic.SHAREABLE);\n+      if (supportsSegmentation) {\n+         characteristics.add(Characteristic.SEGMENTABLE);\n+      }\n+      return characteristics;\n    }\n \n    @Override\n-   public boolean isAvailable() {\n-      try {\n-         PingResponse pr = ((RemoteCacheImpl) remoteCache).ping();\n-         return pr.isSuccess();\n-      } catch (Exception e) {\n-         return false;\n-      }\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> remoteCacheManager.stop(), \"RemoteStore-stop\");\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> get(int segment, Object key) {\n-      return loadEntry(key);\n+   public CompletionStage<Boolean> isAvailable() {\n+      return remoteCache.ping()\n+            .handle((v, t) -> t == null && v.isSuccess());\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> loadEntry(Object key) throws PersistenceException {\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n       if (configuration.rawValues()) {\n-         Object unwrappedKey;\n-         if (key instanceof WrappedByteArray) {\n-            unwrappedKey = ((WrappedByteArray) key).getBytes();\n-         } else {\n-            unwrappedKey = key;\n-         }\n-         MetadataValue<?> value = remoteCache.getWithMetadata(unwrappedKey);\n-         if (value != null) {\n-            Metadata metadata = new EmbeddedMetadata.Builder()\n-                  .version(new NumericVersion(value.getVersion()))\n-                  .lifespan(value.getLifespan(), TimeUnit.SECONDS)\n-                  .maxIdle(value.getMaxIdle(), TimeUnit.SECONDS).build();\n-            long created = value.getCreated();\n-            long lastUsed = value.getLastUsed();\n-            Object realValue = value.getValue();\n-            if (realValue instanceof byte[]) {\n-               realValue = new WrappedByteArray((byte[]) realValue);\n+         Object unwrappedKey = unwrap(key);\n+         CompletableFuture<MetadataValue<Object>> valueStage = remoteCache.getWithMetadataAsync(unwrappedKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0Nzc3NA==", "bodyText": "Sure.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467047774", "createdAt": "2020-08-07T13:41:44Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -68,228 +72,257 @@\n  * @see <a href=\"http://community.jboss.org/wiki/JavaHotRodclient\">Hotrod Java Client</a>\n  * @since 4.1\n  */\n-@Store(shared = true)\n-@ThreadSafe\n @ConfiguredBy(RemoteStoreConfiguration.class)\n-public class RemoteStore<K, V> implements SegmentedAdvancedLoadWriteStore<K, V>, FlagAffectedStore<K, V> {\n+public class RemoteStore<K, V> implements NonBlockingStore<K, V> {\n \n    private static final Log log = LogFactory.getLog(RemoteStore.class, Log.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    private RemoteStoreConfiguration configuration;\n \n-   private volatile RemoteCacheManager remoteCacheManager;\n-   private volatile RemoteCache<Object, Object> remoteCache;\n+   private RemoteCacheManager remoteCacheManager;\n+   private InternalRemoteCache<Object, Object> remoteCache;\n \n    private InternalEntryFactory iceFactory;\n    private static final String LIFESPAN = \"lifespan\";\n    private static final String MAXIDLE = \"maxidle\";\n    protected InitializationContext ctx;\n    private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+   private int segmentCount;\n+   private boolean supportsSegmentation;\n \n    @Override\n-   public void init(InitializationContext ctx) {\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n       this.ctx = ctx;\n       this.configuration = ctx.getConfiguration();\n       this.entryFactory = ctx.getMarshallableEntryFactory();\n-   }\n+      this.blockingManager = ctx.getBlockingManager();\n+\n+      Configuration cacheConfiguration = ctx.getCache().getCacheConfiguration();\n+      ClusteringConfiguration clusterConfiguration = cacheConfiguration.clustering();\n+      this.segmentCount = clusterConfiguration.hash().numSegments();\n \n-   @Override\n-   public void start() throws PersistenceException {\n       final Marshaller marshaller;\n       if (configuration.marshaller() != null) {\n          marshaller = Util.getInstance(configuration.marshaller(), ctx.getCache().getAdvancedCache().getClassLoader());\n       } else if (configuration.hotRodWrapping()) {\n          marshaller = new HotRodEntryMarshaller(ctx.getByteBufferFactory());\n-      } else if (configuration.rawValues()) {\n-         ClassAllowList allowList = ctx.getCache().getCacheManager().getClassAllowList();\n-         marshaller = new GenericJBossMarshaller(Thread.currentThread().getContextClassLoader(), allowList);\n       } else {\n          marshaller = ctx.getPersistenceMarshaller();\n       }\n-      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n-      remoteCacheManager = new RemoteCacheManager(builder.build());\n \n-      if (configuration.remoteCacheName().isEmpty())\n-         remoteCache = remoteCacheManager.getCache();\n-      else\n-         remoteCache = remoteCacheManager.getCache(configuration.remoteCacheName());\n+      if (clusterConfiguration.cacheMode().isClustered() && !configuration.shared()) {\n+         throw log.clusteredRequiresBeingShared();\n+      }\n+\n       if (configuration.rawValues() && iceFactory == null) {\n          iceFactory = ctx.getCache().getAdvancedCache().getComponentRegistry().getComponent(InternalEntryFactory.class);\n       }\n+\n+      // Make sure threads are marked as non blocking if user didn't specify\n+      configuration.properties().putIfAbsent(\"blocking\", \"false\");\n+\n+      ConfigurationBuilder builder = buildRemoteConfiguration(configuration, marshaller);\n+\n+      return blockingManager.supplyBlocking(() -> {\n+         remoteCacheManager = new RemoteCacheManager(builder.build());\n+\n+         if (configuration.remoteCacheName().isEmpty())\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache();\n+         else\n+            remoteCache = (InternalRemoteCache<Object, Object>) remoteCacheManager.getCache(configuration.remoteCacheName());\n+\n+         return remoteCache.ping();\n+      }, \"RemoteStore-start\")\n+            .thenCompose(Function.identity())\n+            .thenAccept(pingResponse -> {\n+               String cacheName = ctx.getCache().getName();\n+               StorageConfigurationManager storageConfigurationManager = ctx.getCache().getAdvancedCache().getComponentRegistry()\n+                     .getComponent(StorageConfigurationManager.class);\n+               MediaType localKeyStorageType = storageConfigurationManager.getKeyStorageMediaType();\n+               MediaType serverKeyStorageType = pingResponse.getKeyMediaType();\n+\n+               MediaType localValueStorageType = storageConfigurationManager.getValueStorageMediaType();\n+               MediaType serverValueStorageType = pingResponse.getValueMediaType();\n+\n+               DataFormat.Builder dataFormatBuilder = DataFormat.builder().from(remoteCache.getDataFormat());\n+               Integer numSegments = remoteCache.getCacheTopologyInfo().getNumSegments();\n+               boolean segmentsMatch;\n+               if (numSegments == null) {\n+                  log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments was not found from the remote cache\", cacheName);\n+                  segmentsMatch = false;\n+               } else {\n+                  segmentsMatch = numSegments == segmentCount;\n+                  if (segmentsMatch) {\n+                     log.debugf(\"Remote Store for cache %s can support segmentation as the number of segments matched the remote cache\", cacheName);\n+                  } else {\n+                     log.debugf(\"Remote Store for cache %s cannot support segmentation as the number of segments %d do not match the remote cache %d\",\n+                           cacheName, segmentCount, numSegments);\n+                  }\n+               }\n+               if (!segmentsMatch && configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualSegments(segmentCount, numSegments);\n+               }\n+               if ((supportsSegmentation = localKeyStorageType.equals(serverKeyStorageType))) {\n+                  if (localKeyStorageType.isBinary()) {\n+                     dataFormatBuilder.keyType(localKeyStorageType);\n+                     // Make sure when the media types match that we don't marshall the value\n+                     dataFormatBuilder.keyMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.keyType(marshaller.mediaType());\n+                     dataFormatBuilder.keyMarshaller(marshaller);\n+                  }\n+               } else if (configuration.segmented()) {\n+                  throw log.segmentationRequiresEqualMediaTypes(localKeyStorageType, serverKeyStorageType);\n+               }\n+               // We store MarshalledEntry instances for the values when raw values is not set, instead of the stored value\n+               if (!configuration.rawValues()) {\n+                  localValueStorageType = MediaType.APPLICATION_OBJECT;\n+               }\n+               if (localValueStorageType.equals(serverValueStorageType)) {\n+                  if (localValueStorageType.isBinary()) {\n+                     dataFormatBuilder.valueType(localValueStorageType);\n+                     dataFormatBuilder.valueMarshaller(IdentityMarshaller.INSTANCE);\n+                  } else {\n+                     dataFormatBuilder.valueType(marshaller.mediaType());\n+                     dataFormatBuilder.valueMarshaller(marshaller);\n+                  }\n+               }\n+               DataFormat dataFormat = dataFormatBuilder.build();\n+               log.fatalf(\"Data format is %s\", dataFormat);\n+               remoteCache = remoteCache.withDataFormat(dataFormat);\n+            });\n    }\n \n    @Override\n-   public void stop() throws PersistenceException {\n-      remoteCacheManager.stop();\n+   public Set<Characteristic> characteristics() {\n+      Set<Characteristic> characteristics = EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION,\n+            Characteristic.SHAREABLE);\n+      if (supportsSegmentation) {\n+         characteristics.add(Characteristic.SEGMENTABLE);\n+      }\n+      return characteristics;\n    }\n \n    @Override\n-   public boolean isAvailable() {\n-      try {\n-         PingResponse pr = ((RemoteCacheImpl) remoteCache).ping();\n-         return pr.isSuccess();\n-      } catch (Exception e) {\n-         return false;\n-      }\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> remoteCacheManager.stop(), \"RemoteStore-stop\");\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> get(int segment, Object key) {\n-      return loadEntry(key);\n+   public CompletionStage<Boolean> isAvailable() {\n+      return remoteCache.ping()\n+            .handle((v, t) -> t == null && v.isSuccess());\n    }\n \n    @Override\n-   public MarshallableEntry<K, V> loadEntry(Object key) throws PersistenceException {\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n       if (configuration.rawValues()) {\n-         Object unwrappedKey;\n-         if (key instanceof WrappedByteArray) {\n-            unwrappedKey = ((WrappedByteArray) key).getBytes();\n-         } else {\n-            unwrappedKey = key;\n-         }\n-         MetadataValue<?> value = remoteCache.getWithMetadata(unwrappedKey);\n-         if (value != null) {\n-            Metadata metadata = new EmbeddedMetadata.Builder()\n-                  .version(new NumericVersion(value.getVersion()))\n-                  .lifespan(value.getLifespan(), TimeUnit.SECONDS)\n-                  .maxIdle(value.getMaxIdle(), TimeUnit.SECONDS).build();\n-            long created = value.getCreated();\n-            long lastUsed = value.getLastUsed();\n-            Object realValue = value.getValue();\n-            if (realValue instanceof byte[]) {\n-               realValue = new WrappedByteArray((byte[]) realValue);\n+         Object unwrappedKey = unwrap(key);\n+         CompletableFuture<MetadataValue<Object>> valueStage = remoteCache.getWithMetadataAsync(unwrappedKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyNjY0Nw=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMjExNDcxOnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwODoyMzoyM1rOG8oiOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzo0Mzo0MVrOG9aZ5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMTg2NA==", "bodyText": "To improve readability we can just do long lifespan = metadata != null ? toSeconds(metadata.lifespan(), entry.getKey()) : -1;\nThe put call is then just:\n      return remoteCache.putAsync(key, value, lifespan, TimeUnit.SECONDS, maxIdle, TimeUnit.SECONDS)\n            .thenApply(CompletableFutures.toNullFunction());\nI'm also not sure that the current trace message of outputting the key is particularly useful, so we could simplify toSeconds by removing the key param.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466231864", "createdAt": "2020-08-06T08:23:23Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -299,65 +332,61 @@ public void write(MarshallableEntry entry) throws PersistenceException {\n       Object key = getKey(entry);\n       Object value = getValue(entry);\n \n-      remoteCache.put(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n-            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS);\n+      return remoteCache.putAsync(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 472}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0ODkzNA==", "bodyText": "Sure, I didn't think to reduce the existing code :)", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467048934", "createdAt": "2020-08-07T13:43:41Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -299,65 +332,61 @@ public void write(MarshallableEntry entry) throws PersistenceException {\n       Object key = getKey(entry);\n       Object value = getValue(entry);\n \n-      remoteCache.put(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n-            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS);\n+      return remoteCache.putAsync(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMTg2NA=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 472}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMjExNzU3OnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwODoyNDoxM1rOG8oj_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzozODo0MFrOG9aORg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMjMxOQ==", "bodyText": "sp -> Flowable.fromPublisher can be replaced with method references throughout.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466232319", "createdAt": "2020-08-06T08:24:13Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -299,65 +332,61 @@ public void write(MarshallableEntry entry) throws PersistenceException {\n       Object key = getKey(entry);\n       Object value = getValue(entry);\n \n-      remoteCache.put(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n-            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS);\n+      return remoteCache.putAsync(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n+            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS)\n+            .thenApply(CompletableFutures.toNullFunction());\n    }\n \n    private Object getKey(MarshallableEntry entry) {\n-      Object key = entry.getKey();\n-      if (key instanceof WrappedByteArray)\n-         return ((WrappedByteArray) key).getBytes();\n-      return key;\n+      return unwrap(entry.getKey());\n    }\n \n    private Object getValue(MarshallableEntry entry) {\n       if (configuration.rawValues()) {\n-         Object value = entry.getValue();\n-         return value instanceof WrappedByteArray ? ((WrappedByteArray) value).getBytes() : value;\n+         return unwrap(entry.getValue());\n       }\n       return entry.getMarshalledValue();\n    }\n \n    @Override\n-   public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-      return Flowable.fromPublisher(publisher)\n-            .buffer(configuration.maxBatchSize())\n-            // TODO: this is blocking - when the full non blocking SPI is introduced this needs to chain returns\n-            // of the putAll to ensure that only a single batch is sent at a time\n-            .doOnNext(entries -> remoteCache.putAll(entries.stream().collect(Collectors.toMap(this::getKey, this::getValue))))\n-            .doOnError(PersistenceException::new)\n-            .ignoreElements()\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      Completable removeCompletable = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 506}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NTk1OA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467045958", "createdAt": "2020-08-07T13:38:40Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -299,65 +332,61 @@ public void write(MarshallableEntry entry) throws PersistenceException {\n       Object key = getKey(entry);\n       Object value = getValue(entry);\n \n-      remoteCache.put(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n-            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS);\n+      return remoteCache.putAsync(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n+            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS)\n+            .thenApply(CompletableFutures.toNullFunction());\n    }\n \n    private Object getKey(MarshallableEntry entry) {\n-      Object key = entry.getKey();\n-      if (key instanceof WrappedByteArray)\n-         return ((WrappedByteArray) key).getBytes();\n-      return key;\n+      return unwrap(entry.getKey());\n    }\n \n    private Object getValue(MarshallableEntry entry) {\n       if (configuration.rawValues()) {\n-         Object value = entry.getValue();\n-         return value instanceof WrappedByteArray ? ((WrappedByteArray) value).getBytes() : value;\n+         return unwrap(entry.getValue());\n       }\n       return entry.getMarshalledValue();\n    }\n \n    @Override\n-   public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-      return Flowable.fromPublisher(publisher)\n-            .buffer(configuration.maxBatchSize())\n-            // TODO: this is blocking - when the full non blocking SPI is introduced this needs to chain returns\n-            // of the putAll to ensure that only a single batch is sent at a time\n-            .doOnNext(entries -> remoteCache.putAll(entries.stream().collect(Collectors.toMap(this::getKey, this::getValue))))\n-            .doOnError(PersistenceException::new)\n-            .ignoreElements()\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      Completable removeCompletable = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMjMxOQ=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 506}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMjEyMzU4OnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwODoyNTo0MlrOG8onhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzo0NTo1MVrOG9afMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMzIyMA==", "bodyText": "Do we need to convert milliseconds to seconds here in the same manner as write()?", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r466233220", "createdAt": "2020-08-06T08:25:42Z", "author": {"login": "ryanemerson"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -299,65 +332,61 @@ public void write(MarshallableEntry entry) throws PersistenceException {\n       Object key = getKey(entry);\n       Object value = getValue(entry);\n \n-      remoteCache.put(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n-            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS);\n+      return remoteCache.putAsync(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n+            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS)\n+            .thenApply(CompletableFutures.toNullFunction());\n    }\n \n    private Object getKey(MarshallableEntry entry) {\n-      Object key = entry.getKey();\n-      if (key instanceof WrappedByteArray)\n-         return ((WrappedByteArray) key).getBytes();\n-      return key;\n+      return unwrap(entry.getKey());\n    }\n \n    private Object getValue(MarshallableEntry entry) {\n       if (configuration.rawValues()) {\n-         Object value = entry.getValue();\n-         return value instanceof WrappedByteArray ? ((WrappedByteArray) value).getBytes() : value;\n+         return unwrap(entry.getValue());\n       }\n       return entry.getMarshalledValue();\n    }\n \n    @Override\n-   public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-      return Flowable.fromPublisher(publisher)\n-            .buffer(configuration.maxBatchSize())\n-            // TODO: this is blocking - when the full non blocking SPI is introduced this needs to chain returns\n-            // of the putAll to ensure that only a single batch is sent at a time\n-            .doOnNext(entries -> remoteCache.putAll(entries.stream().collect(Collectors.toMap(this::getKey, this::getValue))))\n-            .doOnError(PersistenceException::new)\n-            .ignoreElements()\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      Completable removeCompletable = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)\n+            .map(RemoteStore::unwrap)\n+            .flatMapCompletable(key -> Completable.fromCompletionStage(remoteCache.removeAsync(key)), false, 10);\n+\n+      Completable putCompletable = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)\n+            .groupBy(MarshallableEntry::getMetadata)\n+            .flatMapCompletable(meFlowable -> meFlowable.buffer(configuration.maxBatchSize())\n+                  .flatMapCompletable(meList -> {\n+                     Map<Object, Object> map = meList.stream().collect(Collectors.toMap(this::getKey, this::getValue));\n+\n+                     Metadata metadata = meFlowable.getKey();\n+                     long lifespan = metadata != null ? metadata.lifespan() : -1;\n+                     long maxIdle = metadata != null ? metadata.maxIdle() : -1;\n+\n+                     return Completable.fromCompletionStage(remoteCache.putAllAsync(map, lifespan, TimeUnit.SECONDS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 521}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA1MDI5MA==", "bodyText": "Yes, probably. I was fixing the bug that batch before didn't pay attention to metadata and didn't quite get it right \ud83d\udc4d", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467050290", "createdAt": "2020-08-07T13:45:51Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -299,65 +332,61 @@ public void write(MarshallableEntry entry) throws PersistenceException {\n       Object key = getKey(entry);\n       Object value = getValue(entry);\n \n-      remoteCache.put(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n-            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS);\n+      return remoteCache.putAsync(key, value, toSeconds(lifespan, entry.getKey(), LIFESPAN), TimeUnit.SECONDS,\n+            toSeconds(maxIdle, entry.getKey(), MAXIDLE), TimeUnit.SECONDS)\n+            .thenApply(CompletableFutures.toNullFunction());\n    }\n \n    private Object getKey(MarshallableEntry entry) {\n-      Object key = entry.getKey();\n-      if (key instanceof WrappedByteArray)\n-         return ((WrappedByteArray) key).getBytes();\n-      return key;\n+      return unwrap(entry.getKey());\n    }\n \n    private Object getValue(MarshallableEntry entry) {\n       if (configuration.rawValues()) {\n-         Object value = entry.getValue();\n-         return value instanceof WrappedByteArray ? ((WrappedByteArray) value).getBytes() : value;\n+         return unwrap(entry.getValue());\n       }\n       return entry.getMarshalledValue();\n    }\n \n    @Override\n-   public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-      return Flowable.fromPublisher(publisher)\n-            .buffer(configuration.maxBatchSize())\n-            // TODO: this is blocking - when the full non blocking SPI is introduced this needs to chain returns\n-            // of the putAll to ensure that only a single batch is sent at a time\n-            .doOnNext(entries -> remoteCache.putAll(entries.stream().collect(Collectors.toMap(this::getKey, this::getValue))))\n-            .doOnError(PersistenceException::new)\n-            .ignoreElements()\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      Completable removeCompletable = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)\n+            .map(RemoteStore::unwrap)\n+            .flatMapCompletable(key -> Completable.fromCompletionStage(remoteCache.removeAsync(key)), false, 10);\n+\n+      Completable putCompletable = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp), publisherCount)\n+            .groupBy(MarshallableEntry::getMetadata)\n+            .flatMapCompletable(meFlowable -> meFlowable.buffer(configuration.maxBatchSize())\n+                  .flatMapCompletable(meList -> {\n+                     Map<Object, Object> map = meList.stream().collect(Collectors.toMap(this::getKey, this::getValue));\n+\n+                     Metadata metadata = meFlowable.getKey();\n+                     long lifespan = metadata != null ? metadata.lifespan() : -1;\n+                     long maxIdle = metadata != null ? metadata.maxIdle() : -1;\n+\n+                     return Completable.fromCompletionStage(remoteCache.putAllAsync(map, lifespan, TimeUnit.SECONDS,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzMzIyMA=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 521}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjQxMTQ2OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec27.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODozNzowOVrOG-F0LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjoxMjo1NVrOG-VrsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MDE3Mw==", "bodyText": "typo", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467760173", "createdAt": "2020-08-10T08:37:09Z", "author": {"login": "gustavonalle"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec27.java", "diffHunk": "@@ -13,6 +13,8 @@\n  */\n public class Codec27 extends Codec26 {\n \n+   public static final String EMPTY_VAUE_CONVERTER = \"org.infinispan.server.hotrod.HotRodServer$ToEmptyBytesKeyValueFilterConverter\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAyMDE0NQ==", "bodyText": "Fixed.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r468020145", "createdAt": "2020-08-10T16:12:55Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec27.java", "diffHunk": "@@ -13,6 +13,8 @@\n  */\n public class Codec27 extends Codec26 {\n \n+   public static final String EMPTY_VAUE_CONVERTER = \"org.infinispan.server.hotrod.HotRodServer$ToEmptyBytesKeyValueFilterConverter\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MDE3Mw=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjQyNjAwOnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/configuration/RemoteStoreConfiguration.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODo0MTo0NFrOG-F8_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjoxMjo0N1rOG-VrXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MjQyOQ==", "bodyText": "Could you please check if https://github.com/infinispan/infinispan/blob/8aa30677362ea1befcb5b9a828008dd0bc69d857/documentation/src/main/asciidoc/topics/ref_rolling_upgrade_remote_store.adoc can be updated to remove those deprecated attributes?", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r467762429", "createdAt": "2020-08-10T08:41:44Z", "author": {"login": "gustavonalle"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/configuration/RemoteStoreConfiguration.java", "diffHunk": "@@ -145,6 +149,10 @@ public ProtocolVersion protocol() {\n       return protocolVersion.get();\n    }\n \n+   /**\n+    * @deprecated since 12.0 - This option can still be needed when retrieving from a preexisting remote cache\n+    */\n+   @Deprecated\n    public boolean rawValues() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAyMDA2MA==", "bodyText": "TBH, I need to think about it more. I would rather leave them alone for this PR as I am not certain yet. TBH we may not be able to remove raw values even, it needs more thought. I created https://issues.redhat.com/browse/ISPN-12209 to do this.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r468020060", "createdAt": "2020-08-10T16:12:47Z", "author": {"login": "wburns"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/configuration/RemoteStoreConfiguration.java", "diffHunk": "@@ -145,6 +149,10 @@ public ProtocolVersion protocol() {\n       return protocolVersion.get();\n    }\n \n+   /**\n+    * @deprecated since 12.0 - This option can still be needed when retrieving from a preexisting remote cache\n+    */\n+   @Deprecated\n    public boolean rawValues() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2MjQyOQ=="}, "originalCommit": {"oid": "4a5bcd4ed4dbbf9b892938f8aa602fa28f6fb001"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMDgzMTczOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec27.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNlQwOToxMTo1OFrOIg65lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNlQwOToxMTo1OFrOIg65lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM5MDM1OQ==", "bodyText": "The comment still references the class name, but that doesn't make sense now that the class name was moved to a constant. I suggest Use a converter to remove the value payload instead.", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r571390359", "createdAt": "2021-02-06T09:11:58Z", "author": {"login": "danberindei"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec27.java", "diffHunk": "@@ -23,7 +25,6 @@ public HeaderParams writeHeader(ByteBuf buf, HeaderParams params) {\n          IntSet segments, int batchSize) {\n       return new IteratorMapper<>(remoteCache.retrieveEntries(\n             // Use the ToEmptyBytesKeyValueFilterConverter to remove value payload\n-            \"org.infinispan.server.hotrod.HotRodServer$ToEmptyBytesKeyValueFilterConverter\", segments, batchSize),\n-            e -> (K) e.getKey());\n+            EMPTY_VALUE_CONVERTER, segments, batchSize), e -> (K) e.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4724ac0d5768f4e942984055c4505f6f0b054ca"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMDgzMjk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/logging/Log.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNlQwOToxNDowNVrOIg66JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNlQwOToxNDowNVrOIg66JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM5MDUwMQ==", "bodyText": "\"does not have the SEGMENTABLE characteristic\" sounds better to me", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r571390501", "createdAt": "2021-02-06T09:14:05Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/logging/Log.java", "diffHunk": "@@ -2041,4 +2041,7 @@ CacheConfigurationException storeConfiguredHasBothReadAndWriteOnly(String storeC\n \n    @Message(value = \"Store %s cannot be configured to be shared as it does not contain the SHARED characteristic\", id = 600)\n    CacheConfigurationException storeConfiguredSharedButCharacteristicNotPresent(String storeClassName);\n+\n+   @Message(value = \"Store %s cannot be configured to be segmented as it does not contain the SEGMENTABLE characteristic\", id = 601)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4724ac0d5768f4e942984055c4505f6f0b054ca"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYwMDg0MDI2OnYy", "diffSide": "RIGHT", "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNlQwOToyMjowOVrOIg69cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNlQwOToyMjowOVrOIg69cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM5MTM0NQ==", "bodyText": "Why not throw an UnsupportedOperationException?", "url": "https://github.com/infinispan/infinispan/pull/8593#discussion_r571391345", "createdAt": "2021-02-06T09:22:09Z", "author": {"login": "danberindei"}, "path": "persistence/remote/src/main/java/org/infinispan/persistence/remote/RemoteStore.java", "diffHunk": "@@ -451,7 +477,19 @@ public RemoteStoreConfiguration getConfiguration() {\n    }\n \n    @Override\n-   public boolean shouldWrite(long commandFlags) {\n-      return !EnumUtil.containsAny(FlagBitSets.ROLLING_UPGRADE, commandFlags);\n+   public boolean ignoreCommandWithFlags(long commandFlags) {\n+      return EnumUtil.containsAny(FlagBitSets.ROLLING_UPGRADE, commandFlags);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> addSegments(IntSet segments) {\n+      // Here for documentation purposes. This method should never be invoked as we only support segmented when shared", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4724ac0d5768f4e942984055c4505f6f0b054ca"}, "originalPosition": 585}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4026, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}