{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NDUwNzAx", "number": 8240, "title": "ISPN-11424 Deprecate StorageType Configuration", "bodyText": "https://issues.redhat.com/browse/ISPN-11424", "createdAt": "2020-04-24T09:54:44Z", "url": "https://github.com/infinispan/infinispan/pull/8240", "merged": true, "mergeCommit": {"oid": "8150e1dabe7e95167088b0301a202984f1d19748"}, "closed": true, "closedAt": "2020-05-08T16:23:51Z", "author": {"login": "gustavonalle"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccaT-tgFqTQwMjY0NzM5Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcesU2AABqjMzMDk1NzgyNTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyNjQ3Mzk2", "url": "https://github.com/infinispan/infinispan/pull/8240#pullrequestreview-402647396", "createdAt": "2020-04-29T13:08:53Z", "commit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMzowODo1M1rOGN9-_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTozNDozOFrOGOEvMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMwMDIyMQ==", "bodyText": "Nitpick: space", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417300221", "createdAt": "2020-04-29T13:08:53Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/EncodingConfigurationBuilder.java", "diffHunk": "@@ -65,6 +82,11 @@ public EncodingConfiguration create() {\n \n    @Override\n    public void validate(GlobalConfiguration globalConfig) {\n+      if(mediaType != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMzNTY2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public boolean offHeap() {\n          \n          \n            \n               public boolean isStoredOffHeap() {", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417335666", "createdAt": "2020-04-29T13:58:05Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/MemoryConfiguration.java", "diffHunk": "@@ -18,51 +18,96 @@\n  * @author William Burns\n  */\n public class MemoryConfiguration implements Matchable<MemoryConfiguration>, ConfigurationInfo {\n+   public static final ElementDefinition<?> ELEMENT_DEFINITION = new DefaultElementDefinition<>(MEMORY.getLocalName());\n \n-   private final List<ConfigurationInfo> subElements;\n-   private final MemoryStorageConfiguration memoryStorageConfiguration;\n+   public static final AttributeDefinition<StorageType> STORAGE = AttributeDefinition.builder(\"storage\", StorageType.HEAP).immutable().build();\n+   public static final AttributeDefinition<String> MAX_SIZE = AttributeDefinition.builder(\"maxSize\", null, String.class).build();\n+   public static final AttributeDefinition<Long> MAX_COUNT = AttributeDefinition.builder(\"maxCount\", -1L).build();\n+   public static final AttributeDefinition<EvictionStrategy> EVICTION_STRATEGY = AttributeDefinition.builder(\"evictionStrategy\", EvictionStrategy.NONE).build();\n \n-   public static final ElementDefinition ELEMENT_DEFINITION = new DefaultElementDefinition(MEMORY.getLocalName());\n+   static AttributeSet attributeDefinitionSet() {\n+      return new AttributeSet(MemoryConfiguration.class, STORAGE, MAX_SIZE, MAX_COUNT, EVICTION_STRATEGY);\n+   }\n \n-   MemoryConfiguration(MemoryStorageConfiguration memoryStorageConfiguration) {\n+   private final AttributeSet attributes;\n+   private final MemoryStorageConfiguration memoryStorageConfiguration;\n+\n+   MemoryConfiguration(AttributeSet attributes, MemoryStorageConfiguration memoryStorageConfiguration) {\n+      this.attributes = attributes.checkProtection();\n       this.memoryStorageConfiguration = memoryStorageConfiguration;\n-      this.subElements = Collections.singletonList(memoryStorageConfiguration);\n    }\n \n    @Override\n-   public ElementDefinition getElementDefinition() {\n-      return ELEMENT_DEFINITION;\n+   public AttributeSet attributes() {\n+      return attributes;\n    }\n \n    @Override\n-   public List<ConfigurationInfo> subElements() {\n-      return subElements;\n+   public ElementDefinition<?> getElementDefinition() {\n+      return ELEMENT_DEFINITION;\n+   }\n+\n+   public boolean offHeap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMzODQ0NQ==", "bodyText": "Nitpick: space", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417338445", "createdAt": "2020-04-29T14:01:41Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/MemoryConfiguration.java", "diffHunk": "@@ -18,51 +18,96 @@\n  * @author William Burns\n  */\n public class MemoryConfiguration implements Matchable<MemoryConfiguration>, ConfigurationInfo {\n+   public static final ElementDefinition<?> ELEMENT_DEFINITION = new DefaultElementDefinition<>(MEMORY.getLocalName());\n \n-   private final List<ConfigurationInfo> subElements;\n-   private final MemoryStorageConfiguration memoryStorageConfiguration;\n+   public static final AttributeDefinition<StorageType> STORAGE = AttributeDefinition.builder(\"storage\", StorageType.HEAP).immutable().build();\n+   public static final AttributeDefinition<String> MAX_SIZE = AttributeDefinition.builder(\"maxSize\", null, String.class).build();\n+   public static final AttributeDefinition<Long> MAX_COUNT = AttributeDefinition.builder(\"maxCount\", -1L).build();\n+   public static final AttributeDefinition<EvictionStrategy> EVICTION_STRATEGY = AttributeDefinition.builder(\"evictionStrategy\", EvictionStrategy.NONE).build();\n \n-   public static final ElementDefinition ELEMENT_DEFINITION = new DefaultElementDefinition(MEMORY.getLocalName());\n+   static AttributeSet attributeDefinitionSet() {\n+      return new AttributeSet(MemoryConfiguration.class, STORAGE, MAX_SIZE, MAX_COUNT, EVICTION_STRATEGY);\n+   }\n \n-   MemoryConfiguration(MemoryStorageConfiguration memoryStorageConfiguration) {\n+   private final AttributeSet attributes;\n+   private final MemoryStorageConfiguration memoryStorageConfiguration;\n+\n+   MemoryConfiguration(AttributeSet attributes, MemoryStorageConfiguration memoryStorageConfiguration) {\n+      this.attributes = attributes.checkProtection();\n       this.memoryStorageConfiguration = memoryStorageConfiguration;\n-      this.subElements = Collections.singletonList(memoryStorageConfiguration);\n    }\n \n    @Override\n-   public ElementDefinition getElementDefinition() {\n-      return ELEMENT_DEFINITION;\n+   public AttributeSet attributes() {\n+      return attributes;\n    }\n \n    @Override\n-   public List<ConfigurationInfo> subElements() {\n-      return subElements;\n+   public ElementDefinition<?> getElementDefinition() {\n+      return ELEMENT_DEFINITION;\n+   }\n+\n+   public boolean offHeap() {\n+      return attributes.attribute(STORAGE).get() == StorageType.OFF_HEAP;\n+   }\n+\n+   /**\n+    * @return The max size in bytes or -1 if not configured.\n+    */\n+   public long maxSizeBytes() {\n+      String str = attributes.attribute(MAX_SIZE).get();\n+      if(str == null) return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMzOTAwOQ==", "bodyText": "I wonder if instead we should store the parsed value in the Configuration object. Otherwise everytime we invoke this we have to parse the String.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417339009", "createdAt": "2020-04-29T14:02:27Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/MemoryConfiguration.java", "diffHunk": "@@ -18,51 +18,96 @@\n  * @author William Burns\n  */\n public class MemoryConfiguration implements Matchable<MemoryConfiguration>, ConfigurationInfo {\n+   public static final ElementDefinition<?> ELEMENT_DEFINITION = new DefaultElementDefinition<>(MEMORY.getLocalName());\n \n-   private final List<ConfigurationInfo> subElements;\n-   private final MemoryStorageConfiguration memoryStorageConfiguration;\n+   public static final AttributeDefinition<StorageType> STORAGE = AttributeDefinition.builder(\"storage\", StorageType.HEAP).immutable().build();\n+   public static final AttributeDefinition<String> MAX_SIZE = AttributeDefinition.builder(\"maxSize\", null, String.class).build();\n+   public static final AttributeDefinition<Long> MAX_COUNT = AttributeDefinition.builder(\"maxCount\", -1L).build();\n+   public static final AttributeDefinition<EvictionStrategy> EVICTION_STRATEGY = AttributeDefinition.builder(\"evictionStrategy\", EvictionStrategy.NONE).build();\n \n-   public static final ElementDefinition ELEMENT_DEFINITION = new DefaultElementDefinition(MEMORY.getLocalName());\n+   static AttributeSet attributeDefinitionSet() {\n+      return new AttributeSet(MemoryConfiguration.class, STORAGE, MAX_SIZE, MAX_COUNT, EVICTION_STRATEGY);\n+   }\n \n-   MemoryConfiguration(MemoryStorageConfiguration memoryStorageConfiguration) {\n+   private final AttributeSet attributes;\n+   private final MemoryStorageConfiguration memoryStorageConfiguration;\n+\n+   MemoryConfiguration(AttributeSet attributes, MemoryStorageConfiguration memoryStorageConfiguration) {\n+      this.attributes = attributes.checkProtection();\n       this.memoryStorageConfiguration = memoryStorageConfiguration;\n-      this.subElements = Collections.singletonList(memoryStorageConfiguration);\n    }\n \n    @Override\n-   public ElementDefinition getElementDefinition() {\n-      return ELEMENT_DEFINITION;\n+   public AttributeSet attributes() {\n+      return attributes;\n    }\n \n    @Override\n-   public List<ConfigurationInfo> subElements() {\n-      return subElements;\n+   public ElementDefinition<?> getElementDefinition() {\n+      return ELEMENT_DEFINITION;\n+   }\n+\n+   public boolean offHeap() {\n+      return attributes.attribute(STORAGE).get() == StorageType.OFF_HEAP;\n+   }\n+\n+   /**\n+    * @return The max size in bytes or -1 if not configured.\n+    */\n+   public long maxSizeBytes() {\n+      String str = attributes.attribute(MAX_SIZE).get();\n+      if(str == null) return -1;\n+      return ByteQuantity.parse(str);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM0ODkzNg==", "bodyText": "I would just throw an exception if using both, to remove ambiguity.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417348936", "createdAt": "2020-04-29T14:15:17Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/MemoryConfigurationBuilder.java", "diffHunk": "@@ -127,39 +182,80 @@ public MemoryConfigurationBuilder evictionStrategy(EvictionStrategy strategy) {\n     * @return the configured eviction stategy\n     */\n    public EvictionStrategy evictionStrategy() {\n-      return memoryStorageConfigurationBuilder.evictionStrategy();\n+      return attributes.attribute(MemoryConfiguration.EVICTION_STRATEGY).get();\n    }\n \n-   @Override\n-   public void validate() {\n-      StorageType type = memoryStorageConfigurationBuilder.storageType();\n-      if (type != StorageType.OBJECT) {\n+   private boolean isSizeBounded() {\n+      return maxSize() != null;\n+   }\n+\n+   private boolean isCountBounded() {\n+      return maxCount() > 0;\n+   }\n+\n+   private void checkBinaryRequirement() {\n+      String keyType = encoding().key().mediaType();\n+      String valueType = encoding().value().mediaType();\n+      if (storageType() != StorageType.HEAP && storageType() != StorageType.OBJECT) {\n          if (getBuilder().clustering().hash().groups().isEnabled()) {\n-            throw CONFIG.groupingOnlyCompatibleWithObjectStorage(type);\n+            throw CONFIG.groupingOnlyCompatibleWithObjectStorage(keyType, valueType);\n          }\n       }\n \n-      long size = memoryStorageConfigurationBuilder.size();\n-      EvictionType evictionType = memoryStorageConfigurationBuilder.evictionType();\n-      if (evictionType == EvictionType.MEMORY) {\n-         switch (type) {\n-            case OBJECT:\n-               throw CONFIG.offHeapMemoryEvictionNotSupportedWithObject();\n+      boolean storageBinary = encoding().isStorageBinary() || storageType() != StorageType.HEAP;\n+      if (isSizeBounded() && !storageBinary) {\n+         throw CONFIG.offHeapMemoryEvictionNotSupportedWithObject();\n+      }\n+   }\n+\n+   private void translate() {\n+      long legacySize = memoryStorageConfigurationBuilder.size();\n+      switch (memoryStorageConfigurationBuilder.evictionType()) {\n+         case COUNT:\n+            maxCount(legacySize);\n+            break;\n+         case MEMORY:\n+            maxSize(String.valueOf(legacySize));\n+      }\n+      evictionStrategy(memoryStorageConfigurationBuilder.evictionStrategy());\n+   }\n+\n+   private boolean hasLegacyConfiguration() {\n+      return memoryStorageConfigurationBuilder.attributes().isModified() ||\n+            memoryStorageConfigurationBuilder.evictionType() != EvictionType.COUNT;\n+   }\n+\n+   @Override\n+   public void validate() {\n+      if (hasLegacyConfiguration()) {\n+         if (isSizeBounded() || isCountBounded()) {\n+            CONFIG.ignoredMemoryDeprecatedSettings(\"size\", memoryStorageConfigurationBuilder.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM1MDM2MA==", "bodyText": "Equality is also affected by the media type, if it is stored as binary for example.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417350360", "createdAt": "2020-04-29T14:17:06Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/StorageType.java", "diffHunk": "@@ -16,13 +16,24 @@\n    /**\n     * Objects are stored on heap as objects as provided. These are serialized across to other nodes and stored as\n     * deserialized instances of the object. Equality is defined by the equals method of the implementation class.\n+    * @deprecated since 11.0, use {@link StorageType#HEAP} instead.\n     */\n+   @Deprecated\n    OBJECT(Element.OBJECT),\n \n+   /**\n+    * Objects are stored on heap as objects as provided. The format is defined by the\n+    * configured {@link org.infinispan.commons.dataconversion.MediaType} in the cache's\n+    * {@link EncodingConfiguration}. Equality is defined by the equals method of the implementation class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM1MjAyNg==", "bodyText": "I would say lets put the pre 11 schema reading in the if so we can remove it without changing lines. Also I wouldn't expect to invoke both. Also we should log a warning if they are using the old xml in 11+", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417352026", "createdAt": "2020-04-29T14:19:10Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/parsing/Parser.java", "diffHunk": "@@ -1602,7 +1602,29 @@ private void parseDataContainer(final XMLExtendedStreamReader reader) throws XML\n \n    private void parseMemory(final XMLExtendedStreamReader reader, final ConfigurationBuilderHolder holder) throws XMLStreamException {\n       MemoryConfigurationBuilder memoryBuilder = holder.getCurrentConfigurationBuilder().memory();\n-      ParseUtils.requireNoAttributes(reader);\n+      if (reader.getSchema().since(11, 0)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM1NTI5Mg==", "bodyText": "Hrmm, this doesn't seem quite correct to me. Shouldn't it just be something to signify it is a byte array (protostream is more specific)?", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417355292", "createdAt": "2020-04-29T14:23:24Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/MemoryConfigurationBuilder.java", "diffHunk": "@@ -21,34 +24,70 @@\n public class MemoryConfigurationBuilder extends AbstractConfigurationChildBuilder implements Builder<MemoryConfiguration>, ConfigurationBuilderInfo {\n    private MemoryStorageConfigurationBuilder memoryStorageConfigurationBuilder;\n    private final List<ConfigurationBuilderInfo> elements;\n+   private final AttributeSet attributes;\n \n    MemoryConfigurationBuilder(ConfigurationBuilder builder) {\n       super(builder);\n       this.memoryStorageConfigurationBuilder = new MemoryStorageConfigurationBuilder(builder);\n       this.elements = Collections.singletonList(memoryStorageConfigurationBuilder);\n+      this.attributes = MemoryConfiguration.attributeDefinitionSet();\n    }\n \n    @Override\n    public Collection<ConfigurationBuilderInfo> getChildrenInfo() {\n       return elements;\n    }\n \n+   @Override\n+   public AttributeSet attributes() {\n+      return attributes;\n+   }\n+\n    /**\n     * Set the {@link StorageType} to determine how the data is stored in the data container.\n     * @param storageType the storage type of the underlying data\n     * @return this configuration builder\n     */\n    public MemoryConfigurationBuilder storageType(StorageType storageType) {\n-      memoryStorageConfigurationBuilder.storageType(storageType);\n+      StorageType config = storageType == StorageType.OBJECT ? StorageType.HEAP : storageType;\n+      if (config == StorageType.BINARY) {\n+         encoding().mediaType(MediaType.APPLICATION_PROTOSTREAM_TYPE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM1NTkxNg==", "bodyText": "Can we do some sort of validation on the media type? At least to make sure it is in the standard format (ie. type \"/\" [tree \".\"] subtype [\"+\" suffix] *[\";\" parameter]).", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417355916", "createdAt": "2020-04-29T14:24:09Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/parsing/Parser.java", "diffHunk": "@@ -1918,8 +1940,21 @@ protected void parseTransaction(XMLExtendedStreamReader reader, ConfigurationBui\n    }\n \n    protected void parseDataType(XMLExtendedStreamReader reader, ConfigurationBuilder builder, ConfigurationBuilderHolder holder) throws XMLStreamException {\n-      ParseUtils.requireNoAttributes(reader);\n       EncodingConfigurationBuilder encodingBuilder = builder.encoding();\n+      for (int i = 0; i < reader.getAttributeCount(); i++) {\n+         ParseUtils.requireNoNamespaceAttribute(reader, i);\n+         String value = reader.getAttributeValue(i);\n+         Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n+         if (attribute == Attribute.MEDIA_TYPE) {\n+            if (reader.getSchema().since(11, 0)) {\n+               encodingBuilder.mediaType(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM1NzMzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     if (attribute == Attribute.MEDIA_TYPE) {\n          \n          \n            \n                        if (reader.getSchema().since(11, 0)) {\n          \n          \n            \n                     if (attribute == Attribute.MEDIA_TYPE && reader.getSchema().since(11, 0)) {", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417357333", "createdAt": "2020-04-29T14:25:59Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/parsing/Parser.java", "diffHunk": "@@ -1918,8 +1940,21 @@ protected void parseTransaction(XMLExtendedStreamReader reader, ConfigurationBui\n    }\n \n    protected void parseDataType(XMLExtendedStreamReader reader, ConfigurationBuilder builder, ConfigurationBuilderHolder holder) throws XMLStreamException {\n-      ParseUtils.requireNoAttributes(reader);\n       EncodingConfigurationBuilder encodingBuilder = builder.encoding();\n+      for (int i = 0; i < reader.getAttributeCount(); i++) {\n+         ParseUtils.requireNoNamespaceAttribute(reader, i);\n+         String value = reader.getAttributeValue(i);\n+         Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n+         if (attribute == Attribute.MEDIA_TYPE) {\n+            if (reader.getSchema().since(11, 0)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM1OTU2Nw==", "bodyText": "Can it be changed and have a null media type?", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417359567", "createdAt": "2020-04-29T14:28:42Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -125,10 +124,11 @@ private MediaType getStorageMediaType(Configuration configuration, boolean embed\n       ContentTypeConfiguration contentTypeConfiguration = isKey ? encodingConfiguration.keyDataType() : encodingConfiguration.valueDataType();\n       Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n       MediaType mediaType = userMarshaller.mediaType();\n-      boolean heap = configuration.memory().storageType() == StorageType.OBJECT;\n+      boolean heap = !configuration.memory().offHeap();\n       // If explicitly configured, use the value provided\n       if (contentTypeConfiguration.isMediaTypeChanged()) {\n-         return contentTypeConfiguration.mediaType();\n+         MediaType configuredMediaType = contentTypeConfiguration.mediaType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM2NTI0Nw==", "bodyText": "Thinking we may want to clean this up a bit.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               @Message(value = \"Eviction size and count cannot be less than or equal to zero if eviction is enabled\", id = 424)\n          \n          \n            \n               @Message(value = \"Memory eviction is enabled, please specific a maximum size or count greater than zero\", id = 424)", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417365247", "createdAt": "2020-04-29T14:35:48Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/logging/Log.java", "diffHunk": "@@ -1461,7 +1461,7 @@ TimeoutException coordinatorTimeoutWaitingForView(int expectedViewId, int curren\n    @Message(value = \"Duplicate id found! AdvancedExternalizer id=%d is shared by another externalizer (%s)\", id = 423)\n    CacheConfigurationException duplicateExternalizerIdFound(int externalizerId, String otherExternalizer);\n \n-   @Message(value = \"Eviction size value cannot be less than or equal to zero if eviction is enabled\", id = 424)\n+   @Message(value = \"Eviction size and count cannot be less than or equal to zero if eviction is enabled\", id = 424)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM3MzYxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               @Message(value = \"Cannot configure both maxCount and maxSize\", id = 581)\n          \n          \n            \n               @Message(value = \"Cannot configure both maxCount and maxSize in memory configuration\", id = 581)", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417373615", "createdAt": "2020-04-29T14:46:05Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/logging/Log.java", "diffHunk": "@@ -1967,4 +1970,15 @@ TimeoutException coordinatorTimeoutWaitingForView(int expectedViewId, int curren\n \n    @Message(value = \"Failed to migrate persisted data.\", id = 580)\n    PersistenceException persistedDataMigrationFailed(@Cause Throwable cause);\n+\n+   @Message(value = \"Cannot configure both maxCount and maxSize\", id = 581)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM3NDY3Mg==", "bodyText": "Should probably make this the same as binary doc.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417374672", "createdAt": "2020-04-29T14:47:19Z", "author": {"login": "wburns"}, "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1312,6 +1323,7 @@\n         <xs:element name=\"off-heap\" type=\"tns:memory-off-heap\">\n           <xs:annotation>\n             <xs:documentation>\n+              Deprecated since 11.0. Use the storage attribute instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM3NDY5NA==", "bodyText": "Should probably make this the same as binary doc.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417374694", "createdAt": "2020-04-29T14:47:21Z", "author": {"login": "wburns"}, "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1292,6 +1300,7 @@\n         <xs:element name=\"object\" type=\"tns:memory-object\">\n           <xs:annotation>\n             <xs:documentation>\n+              Deprecated since 11.0. Use the storage attribute instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM4NTAwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                       Eviction occurs either the amount of memory exceeds the maximum size.\n          \n          \n            \n                       Eviction occurs after the approximate memory usage exceeds the maximum size.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417385000", "createdAt": "2020-04-29T15:00:23Z", "author": {"login": "wburns"}, "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1323,8 +1335,59 @@\n         </xs:element>\n       </xs:choice>\n     </xs:sequence>\n+    <xs:attribute name=\"max-size\" type=\"xs:string\">\n+      <xs:annotation>\n+        <xs:documentation>\n+           Defines the size of the data container in a byte quantity plus an optional multiplier.\n+           Supported multipliers are kB (kilobytes), MB (megabytes), GB (gigabytes) and TB (terabytes).\n+           Eviction occurs either the amount of memory exceeds the maximum size.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM4NTQxMQ==", "bodyText": "Guessing we may also want to mention that binary or off heap media type is specified.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417385411", "createdAt": "2020-04-29T15:00:55Z", "author": {"login": "wburns"}, "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1323,8 +1335,59 @@\n         </xs:element>\n       </xs:choice>\n     </xs:sequence>\n+    <xs:attribute name=\"max-size\" type=\"xs:string\">\n+      <xs:annotation>\n+        <xs:documentation>\n+           Defines the size of the data container in a byte quantity plus an optional multiplier.\n+           Supported multipliers are kB (kilobytes), MB (megabytes), GB (gigabytes) and TB (terabytes).\n+           Eviction occurs either the amount of memory exceeds the maximum size.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM4NTAwMA=="}, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwMTc1Nw==", "bodyText": "To keep consistent with max-size\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      Defines the max number of entries in the data container, before eviction occurs.\n          \n          \n            \n                      Defines the size of the data container by a count of entries. Eviction occurs after the container size exceeds the maximum count.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417401757", "createdAt": "2020-04-29T15:22:54Z", "author": {"login": "wburns"}, "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1323,8 +1335,59 @@\n         </xs:element>\n       </xs:choice>\n     </xs:sequence>\n+    <xs:attribute name=\"max-size\" type=\"xs:string\">\n+      <xs:annotation>\n+        <xs:documentation>\n+           Defines the size of the data container in a byte quantity plus an optional multiplier.\n+           Supported multipliers are kB (kilobytes), MB (megabytes), GB (gigabytes) and TB (terabytes).\n+           Eviction occurs either the amount of memory exceeds the maximum size.\n+        </xs:documentation>\n+      </xs:annotation>\n+    </xs:attribute>\n+    <xs:attribute name=\"max-count\" type=\"xs:long\" default=\"-1\">\n+      <xs:annotation>\n+        <xs:documentation>\n+          Defines the max number of entries in the data container, before eviction occurs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwMjE4Ng==", "bodyText": "Should probably mention that REMOVE is used if no strategy is defined but size or count are.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417402186", "createdAt": "2020-04-29T15:23:27Z", "author": {"login": "wburns"}, "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1323,8 +1335,59 @@\n         </xs:element>\n       </xs:choice>\n     </xs:sequence>\n+    <xs:attribute name=\"max-size\" type=\"xs:string\">\n+      <xs:annotation>\n+        <xs:documentation>\n+           Defines the size of the data container in a byte quantity plus an optional multiplier.\n+           Supported multipliers are kB (kilobytes), MB (megabytes), GB (gigabytes) and TB (terabytes).\n+           Eviction occurs either the amount of memory exceeds the maximum size.\n+        </xs:documentation>\n+      </xs:annotation>\n+    </xs:attribute>\n+    <xs:attribute name=\"max-count\" type=\"xs:long\" default=\"-1\">\n+      <xs:annotation>\n+        <xs:documentation>\n+          Defines the max number of entries in the data container, before eviction occurs.\n+        </xs:documentation>\n+      </xs:annotation>\n+    </xs:attribute>\n+    <xs:attribute name=\"eviction-strategy\" type=\"tns:eviction-strategy\">\n+      <xs:annotation>\n+        <xs:documentation>\n+          Specifies a strategy for evicting cache entries. Eviction always\n+          takes place when you define either the max-size or the max-count\n+          (but not both) for the data container.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwNjc3OQ==", "bodyText": "So to clarify we assume everything is binary if it has ByteArray as a type in the media type (ie. application/object;type=ByteArray) or it doesn't match application object?", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417406779", "createdAt": "2020-04-29T15:29:18Z", "author": {"login": "wburns"}, "path": "commons/all/src/main/java/org/infinispan/commons/dataconversion/MediaType.java", "diffHunk": "@@ -318,6 +319,15 @@ public String toStringExcludingParam(String... params) {\n       return builder.append(\"; \").append(strParams).toString();\n    }\n \n+   /**\n+    * @return true if the MediaType's java type is a byte array.\n+    */\n+   public boolean isBinary() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwODAyNw==", "bodyText": "Media types like text/* wouldn't be binary, although they could support size based eviction.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417408027", "createdAt": "2020-04-29T15:30:54Z", "author": {"login": "wburns"}, "path": "commons/all/src/main/java/org/infinispan/commons/dataconversion/MediaType.java", "diffHunk": "@@ -318,6 +319,15 @@ public String toStringExcludingParam(String... params) {\n       return builder.append(\"; \").append(strParams).toString();\n    }\n \n+   /**\n+    * @return true if the MediaType's java type is a byte array.\n+    */\n+   public boolean isBinary() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwNjc3OQ=="}, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwOTcyOQ==", "bodyText": "Also I am not sure for application/unknown etc.\nTo be honest thinking more we may need pluggable size calculators based on media type moving forward.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417409729", "createdAt": "2020-04-29T15:33:07Z", "author": {"login": "wburns"}, "path": "commons/all/src/main/java/org/infinispan/commons/dataconversion/MediaType.java", "diffHunk": "@@ -318,6 +319,15 @@ public String toStringExcludingParam(String... params) {\n       return builder.append(\"; \").append(strParams).toString();\n    }\n \n+   /**\n+    * @return true if the MediaType's java type is a byte array.\n+    */\n+   public boolean isBinary() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwNjc3OQ=="}, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQxMDg2Nw==", "bodyText": "We have the MemoryUnit class that already does a lot of this. Maybe we can consolidate?", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r417410867", "createdAt": "2020-04-29T15:34:38Z", "author": {"login": "wburns"}, "path": "commons/all/src/main/java/org/infinispan/commons/util/ByteQuantity.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.infinispan.commons.util;\n+\n+import static java.math.BigDecimal.TEN;\n+\n+import java.math.BigDecimal;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.infinispan.commons.logging.Log;\n+import org.infinispan.commons.logging.LogFactory;\n+\n+/**\n+ * Parser human-readable quantity of bytes.\n+ *\n+ * @since 11.0\n+ */\n+public final class ByteQuantity {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7"}, "originalPosition": 17}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/1e6493b00a7e7b96dcc406d6a9a0f6ce8523c9f7", "committedDate": "2020-04-24T09:53:06Z", "message": "ISPN-11424 Deprecate StorageType Configuration"}, "afterCommit": {"oid": "4b0caa5897b06bed4703cccec589859f287a6faf", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/4b0caa5897b06bed4703cccec589859f287a6faf", "committedDate": "2020-05-06T09:45:15Z", "message": "ISPN-11424 Deprecate StorageType Configuration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NjIyNzcy", "url": "https://github.com/infinispan/infinispan/pull/8240#pullrequestreview-406622772", "createdAt": "2020-05-06T13:40:39Z", "commit": {"oid": "4b0caa5897b06bed4703cccec589859f287a6faf"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo0MDozOVrOGRTguQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNDoyMDo1MVrOGRVbwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc5ODY0OQ==", "bodyText": "Hrmm, is there any reason we couldn't have added enhanced the parser of this class instead?\nAlso we don't have all the enum instances with the new one or conversions between.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r420798649", "createdAt": "2020-05-06T13:40:39Z", "author": {"login": "wburns"}, "path": "commons/all/src/main/java/org/infinispan/commons/util/MemoryUnit.java", "diffHunk": "@@ -1,5 +1,9 @@\n package org.infinispan.commons.util;\n \n+/**\n+ * @deprecated since 11.0, use {@link ByteQuantity} instead.\n+ */\n+@Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b0caa5897b06bed4703cccec589859f287a6faf"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwNDU4Nw==", "bodyText": "I wonder if this needs to be volatile or not.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r420804587", "createdAt": "2020-05-06T13:48:14Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/AttributeChangeTracker.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package org.infinispan.configuration.cache;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import org.infinispan.commons.configuration.attributes.AttributeSet;\n+\n+/**\n+ * Keeps track of modifications in a {@link AttributeSet}.\n+ *\n+ * @since 11.0\n+ */\n+class AttributeChangeTracker {\n+   private boolean isTracking = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b0caa5897b06bed4703cccec589859f287a6faf"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwNTg4Nw==", "bodyText": "Why calling concat here? I would worry this would prevent StringBuilder optimization for +'s.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r420805887", "createdAt": "2020-05-06T13:49:47Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/AttributeChangeTracker.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package org.infinispan.configuration.cache;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import org.infinispan.commons.configuration.attributes.AttributeSet;\n+\n+/**\n+ * Keeps track of modifications in a {@link AttributeSet}.\n+ *\n+ * @since 11.0\n+ */\n+class AttributeChangeTracker {\n+   private boolean isTracking = true;\n+   private final Set<String> changedAttributes = new LinkedHashSet<>();\n+\n+   AttributeChangeTracker(AttributeSet attributeSet) {\n+      attributeSet.attributes().forEach(a -> a.addListener((attr, oldVal) -> {\n+         if (this.isTracking) {\n+            String name = attr.name();\n+            Object value = attr.get();\n+            changedAttributes.add(name.concat(\"=\").concat(value == null ? \"\" : value.toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b0caa5897b06bed4703cccec589859f287a6faf"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwOTM1Ng==", "bodyText": "This seems a bit odd to me. We already set the key and value metadatatype in mediaType. And also shouldn't we only log this if the key or value media types were explicitly defined?", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r420809356", "createdAt": "2020-05-06T13:54:08Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/EncodingConfigurationBuilder.java", "diffHunk": "@@ -65,6 +82,11 @@ public EncodingConfiguration create() {\n \n    @Override\n    public void validate(GlobalConfiguration globalConfig) {\n+      if (mediaType != null) {\n+         CONFIG.ignoringSpecificMediaTypes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b0caa5897b06bed4703cccec589859f287a6faf"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgyNjg5NQ==", "bodyText": "This isn't needed. We should be able to just maintain the eviction strategy in the MemoryConfiguration(Builder) directly and the MemoryStorageConfiguration(Builder) just invokes the parent when setting or retrieving the value.\nI have a feeling we can do the same with size.\nThat is unless there was a reason we had to have separate config values for all of theses? But I would think that should reduce the complexity of the validate and other methods. This is what I did originally when changing eviction to memory element. https://github.com/infinispan/infinispan/blob/9.4.x/core/src/main/java/org/infinispan/configuration/cache/EvictionConfigurationBuilder.java#L82\nYou can also maintain the value in the child to see if it was set or not.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r420826895", "createdAt": "2020-05-06T14:16:29Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/cache/MemoryConfiguration.java", "diffHunk": "@@ -19,68 +20,160 @@\n  */\n public class MemoryConfiguration implements Matchable<MemoryConfiguration>, ConfigurationInfo {\n \n-   private final List<ConfigurationInfo> subElements;\n    private final MemoryStorageConfiguration memoryStorageConfiguration;\n \n-   public static final ElementDefinition ELEMENT_DEFINITION = new DefaultElementDefinition(MEMORY.getLocalName());\n+   public static final ElementDefinition<?> ELEMENT_DEFINITION = new DefaultElementDefinition<>(MEMORY.getLocalName());\n+\n+   public static final AttributeDefinition<StorageType> STORAGE = AttributeDefinition.builder(\"storage\", StorageType.HEAP).build();\n+   public static final AttributeDefinition<String> MAX_SIZE = AttributeDefinition.builder(\"maxSize\", null, String.class).build();\n+   public static final AttributeDefinition<Long> MAX_COUNT = AttributeDefinition.builder(\"maxCount\", -1L).build();\n+   public static final AttributeDefinition<EvictionStrategy> WHEN_FULL = AttributeDefinition.builder(\"whenFull\", EvictionStrategy.NONE).build();\n+   private long maxSizeBytes;\n+\n+   static AttributeSet attributeDefinitionSet() {\n+      return new AttributeSet(MemoryConfiguration.class, STORAGE, MAX_SIZE, MAX_COUNT, WHEN_FULL);\n+   }\n+\n+   private final AttributeSet attributes;\n \n-   MemoryConfiguration(MemoryStorageConfiguration memoryStorageConfiguration) {\n+   MemoryConfiguration(AttributeSet attributes, MemoryStorageConfiguration memoryStorageConfiguration) {\n       this.memoryStorageConfiguration = memoryStorageConfiguration;\n-      this.subElements = Collections.singletonList(memoryStorageConfiguration);\n+      this.attributes = attributes.checkProtection();\n+      String sizeString = attributes.attribute(MAX_SIZE).get();\n+      this.maxSizeBytes = sizeString == null ? -1 : ByteQuantity.parse(sizeString);\n    }\n \n    @Override\n-   public ElementDefinition getElementDefinition() {\n+   public ElementDefinition<?> getElementDefinition() {\n       return ELEMENT_DEFINITION;\n    }\n \n    @Override\n-   public List<ConfigurationInfo> subElements() {\n-      return subElements;\n+   public AttributeSet attributes() {\n+      return attributes;\n+   }\n+\n+   /**\n+    * @return true if the storage is off-heap\n+    */\n+   public boolean isOffHeap() {\n+      return attributes.attribute(STORAGE).get() == StorageType.OFF_HEAP;\n+   }\n+\n+   /**\n+    * @return The max size in bytes or -1 if not configured.\n+    */\n+   public long maxSizeBytes() {\n+      return maxSizeBytes;\n+   }\n+\n+   public String maxSize() {\n+      return attributes.attribute(MAX_SIZE).get();\n+   }\n+\n+   public void maxSize(String maxSize) {\n+      if (!isSizeBounded()) throw CONFIG.cannotIncreaseMaxSize();\n+\n+      maxSizeBytes = ByteQuantity.parse(maxSize);\n+      attributes.attribute(MAX_SIZE).set(maxSize);\n+   }\n+\n+   /**\n+    * @return the max number of entries in memory or -1 if not configured.\n+    */\n+   public long maxCount() {\n+      return attributes.attribute(MAX_COUNT).get();\n+   }\n+\n+   public void maxCount(long maxCount) {\n+      if (!isCountBounded()) throw CONFIG.cannotIncreaseMaxCount();\n+\n+      attributes.attribute(MAX_COUNT).set(maxCount);\n    }\n \n    /**\n     * Storage type to use for the data container\n     * @return\n+    * @deprecated Use {@link #storage()} instead.\n     */\n+   @Deprecated\n    public StorageType storageType() {\n       return memoryStorageConfiguration.storageType();\n    }\n \n+   /**\n+    * @return The memory {@link StorageType}.\n+    */\n+   public StorageType storage() {\n+      return attributes.attribute(STORAGE).get();\n+   }\n+\n    /**\n     * Size of the eviction, -1 if disabled\n-    * @return\n+    * @deprecated Since 11.0, use {@link #maxCount()} or {@link #maxSize()} to obtain\n+    * either the maximum number of entries or the maximum size of the data container.\n     */\n+   @Deprecated\n    public long size() {\n       return memoryStorageConfiguration.size();\n    }\n \n+   /**\n+    * @deprecated Since 11.0, use {@link MemoryConfiguration#maxCount(long)} or\n+    * {@link MemoryConfiguration#maxSize(String)} to dynamically configure the maximum number\n+    * of entries or the maximum size of the data container.\n+    */\n+   @Deprecated\n    public void size(long newSize) {\n+      if (isSizeBounded()) {\n+         attributes.attribute(MAX_SIZE).set(String.valueOf(newSize));\n+      } else {\n+         attributes.attribute(MAX_COUNT).set(newSize);\n+      }\n       memoryStorageConfiguration.size(newSize);\n    }\n \n    /**\n     * The configured eviction type\n-    * @return\n+    * @deprecated Since 11.0, use {@link #maxCount()} or {@link #maxSize()} to obtain either the maximum number of\n+    * entries or the maximum size of the data container.\n     */\n+   @Deprecated\n    public EvictionType evictionType() {\n       return memoryStorageConfiguration.evictionType();\n    }\n \n    /**\n     * The configured eviction strategy\n     * @return\n+    * @deprecated Since 11.0, use {@link #whenFull()}\n     */\n+   @Deprecated\n    public EvictionStrategy evictionStrategy() {\n       return memoryStorageConfiguration.evictionStrategy();\n    }\n \n+   /**\n+    * @return The configured {@link EvictionStrategy}.\n+    */\n+   public EvictionStrategy whenFull() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b0caa5897b06bed4703cccec589859f287a6faf"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgzMDE0NQ==", "bodyText": "We may want to include this in a separate PR. I just worry if this is tested, since xml schema validation can be ordered.", "url": "https://github.com/infinispan/infinispan/pull/8240#discussion_r420830145", "createdAt": "2020-05-06T14:20:51Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/configuration/serializing/Serializer.java", "diffHunk": "@@ -250,6 +248,7 @@ private void writeCacheContainer(XMLExtendedStreamWriter writer, ConfigurationHo\n             default:\n                break;\n          }\n+         writeExtraConfiguration(writer, config.modules());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b0caa5897b06bed4703cccec589859f287a6faf"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8786e66c3003960f9a00e4da2bbb5f591ae1d6a", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/e8786e66c3003960f9a00e4da2bbb5f591ae1d6a", "committedDate": "2020-05-06T17:42:10Z", "message": "ISPN-11424 Deprecate StorageType Configuration"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b0caa5897b06bed4703cccec589859f287a6faf", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/4b0caa5897b06bed4703cccec589859f287a6faf", "committedDate": "2020-05-06T09:45:15Z", "message": "ISPN-11424 Deprecate StorageType Configuration"}, "afterCommit": {"oid": "e8786e66c3003960f9a00e4da2bbb5f591ae1d6a", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/e8786e66c3003960f9a00e4da2bbb5f591ae1d6a", "committedDate": "2020-05-06T17:42:10Z", "message": "ISPN-11424 Deprecate StorageType Configuration"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 909, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}