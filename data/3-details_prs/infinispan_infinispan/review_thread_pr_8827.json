{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0OTAyMTE1", "number": 8827, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMDoxNjoxOVrOE97-rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMDo0ODoxMVrOFDrQng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMzgxMjkyOnYy", "diffSide": "RIGHT", "path": "commons/all/src/main/java/org/infinispan/commons/util/ByRef.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMDoxNjoxOVrOH64mdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMDoxNjoxOVrOH64mdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwNjgwNw==", "bodyText": "This doesn't look like a getAndSet but getAndAdd", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r531506807", "createdAt": "2020-11-27T10:16:19Z", "author": {"login": "tristantarrant"}, "path": "commons/all/src/main/java/org/infinispan/commons/util/ByRef.java", "diffHunk": "@@ -84,6 +84,12 @@ public void set(long i) {\n          ref = i;\n       }\n \n+      public long getAndSet(long i) {\n+         long ret = ref;\n+         ref += i;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70e3f119243a55a6420cc378509ebca7fb87db93"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MDA4NzU3OnYy", "diffSide": "LEFT", "path": "core/src/test/java/org/infinispan/eviction/impl/MemoryBasedEvictionFunctionalStoreAsBinaryTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNzo0MzoyOVrOH9OCTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDoxODowOVrOH9T6xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NTE1MA==", "bodyText": "Why the removal?", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r533955150", "createdAt": "2020-12-02T07:43:29Z", "author": {"login": "gustavonalle"}, "path": "core/src/test/java/org/infinispan/eviction/impl/MemoryBasedEvictionFunctionalStoreAsBinaryTest.java", "diffHunk": "@@ -39,8 +37,4 @@ public void testCustomClass() throws Exception {\n       }\n       assertTrue(cache.getAdvancedCache().getDataContainer().size() < numberInserted);\n    }\n-\n-   public void testJGroupsAddress() {\n-      cache.put(\"key\", new JGroupsAddress(new UUID()));\n-   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8848bcb281ec182f71bf59368e3b3960775fb316"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA1MTUyNg==", "bodyText": "This test no longer makes sense with the separation of the internal and user contexts, as it's trying to store the internal class JGroupsAddress.\nWe could keep the test and add a JGroupsAddress SCI to the configuration, but I don't think this is worthwhile as testCustomClass essentially does the same thing albeit with a different class.", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r534051526", "createdAt": "2020-12-02T10:18:09Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/eviction/impl/MemoryBasedEvictionFunctionalStoreAsBinaryTest.java", "diffHunk": "@@ -39,8 +37,4 @@ public void testCustomClass() throws Exception {\n       }\n       assertTrue(cache.getAdvancedCache().getDataContainer().size() < numberInserted);\n    }\n-\n-   public void testJGroupsAddress() {\n-      cache.put(\"key\", new JGroupsAddress(new UUID()));\n-   }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NTE1MA=="}, "originalCommit": {"oid": "8848bcb281ec182f71bf59368e3b3960775fb316"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MDA5NzcwOnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/test/resources/11_0_x_rocksdb_data/data/LOG", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNzo0NjozNlrOH9OH_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDoxOTo0NVrOH9T-ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NjYwNA==", "bodyText": "should not commit?", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r533956604", "createdAt": "2020-12-02T07:46:36Z", "author": {"login": "gustavonalle"}, "path": "persistence/rocksdb/src/test/resources/11_0_x_rocksdb_data/data/LOG", "diffHunk": "@@ -0,0 +1,256 @@\n+2020/11/23-10:53:43.160947 7f5a5c2ea700 RocksDB version: 6.8.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8848bcb281ec182f71bf59368e3b3960775fb316"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1Njg4OA==", "bodyText": "Same applies to everything from the data/ folder I suppose", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r533956888", "createdAt": "2020-12-02T07:47:09Z", "author": {"login": "gustavonalle"}, "path": "persistence/rocksdb/src/test/resources/11_0_x_rocksdb_data/data/LOG", "diffHunk": "@@ -0,0 +1,256 @@\n+2020/11/23-10:53:43.160947 7f5a5c2ea700 RocksDB version: 6.8.1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NjYwNA=="}, "originalCommit": {"oid": "8848bcb281ec182f71bf59368e3b3960775fb316"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA1MjU0Nw==", "bodyText": "We need to commit the data/ dir as this contains the 11.0.x which we migrate to the new format on startup in the RocksDBStoreCompatibilityTest", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r534052547", "createdAt": "2020-12-02T10:19:45Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/test/resources/11_0_x_rocksdb_data/data/LOG", "diffHunk": "@@ -0,0 +1,256 @@\n+2020/11/23-10:53:43.160947 7f5a5c2ea700 RocksDB version: 6.8.1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NjYwNA=="}, "originalCommit": {"oid": "8848bcb281ec182f71bf59368e3b3960775fb316"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MDEwMjU1OnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/test/resources/11_0_x_rocksdb_data/expired/OPTIONS-000005", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNzo0ODoxM1rOH9OK8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMToxMzo1OVrOH9WE1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NzM2Mw==", "bodyText": "Should not commit this (I think)", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r533957363", "createdAt": "2020-12-02T07:48:13Z", "author": {"login": "gustavonalle"}, "path": "persistence/rocksdb/src/test/resources/11_0_x_rocksdb_data/expired/OPTIONS-000005", "diffHunk": "@@ -0,0 +1,165 @@\n+# This is a RocksDB option file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8848bcb281ec182f71bf59368e3b3960775fb316"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA4Njg2OA==", "bodyText": "Yep, seems to be ok to remove", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r534086868", "createdAt": "2020-12-02T11:13:59Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/test/resources/11_0_x_rocksdb_data/expired/OPTIONS-000005", "diffHunk": "@@ -0,0 +1,165 @@\n+# This is a RocksDB option file.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk1NzM2Mw=="}, "originalCommit": {"oid": "8848bcb281ec182f71bf59368e3b3960775fb316"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MDEzMTYxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNzo1NzowMVrOH9Ob6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDo0MTo1N1rOH9U4fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk2MTcwNg==", "bodyText": "Does it have a Protostream JIRA to have this workaround removed?", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r533961706", "createdAt": "2020-12-02T07:57:01Z", "author": {"login": "gustavonalle"}, "path": "core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java", "diffHunk": "@@ -132,27 +124,92 @@ private boolean isWrapped(MediaType mediaType) {\n    }\n \n    private byte[] marshall(Object decoded, MediaType destinationType) throws IOException {\n-      try {\n-         if (isWrapped(destinationType)) return ProtobufUtil.toWrappedByteArray(ctx(), decoded);\n-         return ProtobufUtil.toByteArray(ctx(), decoded);\n-      } catch (IllegalArgumentException iae) {\n-         throw new MarshallingException(iae.getMessage());\n+      ImmutableSerializationContext ctx = getCtxForMarshalling(decoded);\n+      if (isWrapped(destinationType)) {\n+         return ProtobufUtil.toWrappedByteArray(ctx, decoded);\n       }\n+      return ProtobufUtil.toByteArray(ctx, decoded);\n    }\n \n    private Object unmarshall(byte[] bytes, MediaType contentType, MediaType destinationType) throws IOException {\n+      if (isWrapped(contentType))\n+         return unmarshallCascading(bytes);\n+\n+      String type = destinationType.getClassType();\n+      if (type == null) throw logger.missingTypeForUnwrappedPayload();\n+      Class<?> destination = Util.loadClass(type, classLoader);\n+      ImmutableSerializationContext ctx = getCtxForMarshalling(destination);\n+      return ProtobufUtil.fromByteArray(ctx, bytes, destination);\n+   }\n+\n+   private Object unmarshallCascading(byte[] bytes) throws IOException {\n+      // First try to unmarshalling with the user context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8848bcb281ec182f71bf59368e3b3960775fb316"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA2NzMyNQ==", "bodyText": "Yes IPROTO-139. I'll add comments to the workaround methods.", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r534067325", "createdAt": "2020-12-02T10:41:57Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/encoding/ProtostreamTranscoder.java", "diffHunk": "@@ -132,27 +124,92 @@ private boolean isWrapped(MediaType mediaType) {\n    }\n \n    private byte[] marshall(Object decoded, MediaType destinationType) throws IOException {\n-      try {\n-         if (isWrapped(destinationType)) return ProtobufUtil.toWrappedByteArray(ctx(), decoded);\n-         return ProtobufUtil.toByteArray(ctx(), decoded);\n-      } catch (IllegalArgumentException iae) {\n-         throw new MarshallingException(iae.getMessage());\n+      ImmutableSerializationContext ctx = getCtxForMarshalling(decoded);\n+      if (isWrapped(destinationType)) {\n+         return ProtobufUtil.toWrappedByteArray(ctx, decoded);\n       }\n+      return ProtobufUtil.toByteArray(ctx, decoded);\n    }\n \n    private Object unmarshall(byte[] bytes, MediaType contentType, MediaType destinationType) throws IOException {\n+      if (isWrapped(contentType))\n+         return unmarshallCascading(bytes);\n+\n+      String type = destinationType.getClassType();\n+      if (type == null) throw logger.missingTypeForUnwrappedPayload();\n+      Class<?> destination = Util.loadClass(type, classLoader);\n+      ImmutableSerializationContext ctx = getCtxForMarshalling(destination);\n+      return ProtobufUtil.fromByteArray(ctx, bytes, destination);\n+   }\n+\n+   private Object unmarshallCascading(byte[] bytes) throws IOException {\n+      // First try to unmarshalling with the user context", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk2MTcwNg=="}, "originalCommit": {"oid": "8848bcb281ec182f71bf59368e3b3960775fb316"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjIzNTg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/file/SingleFileStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDo1NTowOFrOIA6SfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDo1NTowOFrOIA6SfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyNTkxNg==", "bodyText": "It seems you don't need this ByRef if you change allocate to return a ByteBuffer instead.", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r537825916", "createdAt": "2020-12-07T20:55:08Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/file/SingleFileStore.java", "diffHunk": "@@ -213,27 +221,20 @@ public boolean isAvailable() {\n     * Rebuilds the in-memory index from file.\n     */\n    private void rebuildIndex() throws Exception {\n-      ByteBuffer buf = ByteBuffer.allocate(KEY_POS_11_0);\n+      ByRef<ByteBuffer> buf = new ByRef<>(ByteBuffer.allocate(KEY_POS_LATEST));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62860fc0ae7d2080b4936d167910ffac9695594"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Mzk4ODE0OnYy", "diffSide": "RIGHT", "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/stringbased/JdbcStringBasedStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMDo0ODoxMVrOIDcpoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNTo1MzoxOFrOID-0uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NjA0OA==", "bodyText": "I wonder should we confirm if the prior marshaller could be used? What if a DBA deletes the metadata table. I wonder if we should catch the exception and maybe mention that as a possibility?", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r540486048", "createdAt": "2020-12-10T20:48:11Z", "author": {"login": "wburns"}, "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/stringbased/JdbcStringBasedStore.java", "diffHunk": "@@ -160,6 +183,66 @@ public void start() {\n       }\n    }\n \n+   private void migrateFromV11() throws SQLException {\n+      // If a custom user marshaller was previously used, no need to update rows\n+      if (ctx.getGlobalConfiguration().serialization().marshaller() != null)\n+         return;\n+\n+      Connection conn = null;\n+      PreparedStatement ps = null;\n+      ResultSet rs = null;\n+      try {\n+         conn = connectionFactory.getConnection();\n+         conn.setAutoCommit(false);\n+         String sql = tableManager.getLoadNonExpiredAllRowsSql();\n+         ps = conn.prepareStatement(sql);\n+         ps.setLong(1, timeService.wallClockTime());\n+         rs = ps.executeQuery();\n+\n+         Marshaller userMarshaller = marshaller.getUserMarshaller();\n+         try (PreparedStatement upsertBatch = conn.prepareStatement(tableManager.getUpdateRowSql())) {\n+            int batchSize = 0;\n+            while (rs.next()) {\n+               batchSize++;\n+               InputStream inputStream = rs.getBinaryStream(1);\n+               String keyStr = rs.getString(2);\n+               long timestamp = rs.getLong(3);\n+               int segment = keyPartitioner == null ? -1 : rs.getInt(4);\n+\n+               MarshalledValue mv = unmarshall(inputStream, marshaller);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62860fc0ae7d2080b4936d167910ffac9695594"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA0NTk0NQ==", "bodyText": "We could, however this will only be the case for Infinispan 12. From Infinispan 13 I think we should throw an exception if !createOnStart and the meta table doesn't exist as it's not possible to distinguish between 11 and 12 data if no meta table exists.", "url": "https://github.com/infinispan/infinispan/pull/8827#discussion_r541045945", "createdAt": "2020-12-11T15:53:18Z", "author": {"login": "ryanemerson"}, "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/stringbased/JdbcStringBasedStore.java", "diffHunk": "@@ -160,6 +183,66 @@ public void start() {\n       }\n    }\n \n+   private void migrateFromV11() throws SQLException {\n+      // If a custom user marshaller was previously used, no need to update rows\n+      if (ctx.getGlobalConfiguration().serialization().marshaller() != null)\n+         return;\n+\n+      Connection conn = null;\n+      PreparedStatement ps = null;\n+      ResultSet rs = null;\n+      try {\n+         conn = connectionFactory.getConnection();\n+         conn.setAutoCommit(false);\n+         String sql = tableManager.getLoadNonExpiredAllRowsSql();\n+         ps = conn.prepareStatement(sql);\n+         ps.setLong(1, timeService.wallClockTime());\n+         rs = ps.executeQuery();\n+\n+         Marshaller userMarshaller = marshaller.getUserMarshaller();\n+         try (PreparedStatement upsertBatch = conn.prepareStatement(tableManager.getUpdateRowSql())) {\n+            int batchSize = 0;\n+            while (rs.next()) {\n+               batchSize++;\n+               InputStream inputStream = rs.getBinaryStream(1);\n+               String keyStr = rs.getString(2);\n+               long timestamp = rs.getLong(3);\n+               int segment = keyPartitioner == null ? -1 : rs.getInt(4);\n+\n+               MarshalledValue mv = unmarshall(inputStream, marshaller);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NjA0OA=="}, "originalCommit": {"oid": "e62860fc0ae7d2080b4936d167910ffac9695594"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3769, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}