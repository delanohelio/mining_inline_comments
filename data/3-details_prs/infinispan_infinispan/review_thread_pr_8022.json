{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2MTQ4NTc3", "number": 8022, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoxNjoxMVrODniBSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTo0MDoxN1rODoxm1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzc4NDQxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoxNjoxMVrOF1lecw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjo1OTo0MlrOF1nOBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczMjg1MQ==", "bodyText": "Not sure what above means here, but the lruLock is in SegmentedBoundedOffHeapDataContainer itself.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391732851", "createdAt": "2020-03-12T16:16:11Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -29,6 +30,8 @@ public void applyTo(BlockHound.Builder builder) {\n       // Block designates methods that should only hold a lock very briefly\n       {\n          CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, OffHeapConcurrentMap.class);\n+         // This acquires the locks from the above OffHeapConcurrentMap instance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2MTQxMg==", "bodyText": "The issue that identified it wasn't actually lruLock, but that it found it was the stamped lock from the off heap concurrent map.  However this fixes both :) I can change the comment.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391761412", "createdAt": "2020-03-12T16:59:42Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -29,6 +30,8 @@ public void applyTo(BlockHound.Builder builder) {\n       // Block designates methods that should only hold a lock very briefly\n       {\n          CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, OffHeapConcurrentMap.class);\n+         // This acquires the locks from the above OffHeapConcurrentMap instance", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczMjg1MQ=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzc4NzUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoxNjo1MFrOF1lgVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNzoxNTozOVrOF1nzxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczMzMzMg==", "bodyText": "I suggest removing them if they don't need a description", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391733332", "createdAt": "2020-03-12T16:16:50Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "diffHunk": "@@ -55,19 +56,22 @@\n    private final Queue<LockPlaceHolder> pendingRequest;\n    private final ConcurrentMap<Object, LockPlaceHolder> lockOwners;\n    private final Runnable releaseRunnable;\n-   private final Executor executor;\n+   private final Executor blockingExecutor;\n+   private final Executor nonBlockingExecutor;\n    private TimeService timeService;\n    @SuppressWarnings(\"CanBeFinal\")\n    private volatile LockPlaceHolder current;\n \n    /**\n     * Creates a new instance.\n     *\n-    * @param executor\n+    * @param blockingExecutor\n+    * @param nonBlockingExecutor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MTA3Ng==", "bodyText": "I will add a description.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391771076", "createdAt": "2020-03-12T17:15:39Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "diffHunk": "@@ -55,19 +56,22 @@\n    private final Queue<LockPlaceHolder> pendingRequest;\n    private final ConcurrentMap<Object, LockPlaceHolder> lockOwners;\n    private final Runnable releaseRunnable;\n-   private final Executor executor;\n+   private final Executor blockingExecutor;\n+   private final Executor nonBlockingExecutor;\n    private TimeService timeService;\n    @SuppressWarnings(\"CanBeFinal\")\n    private volatile LockPlaceHolder current;\n \n    /**\n     * Creates a new instance.\n     *\n-    * @param executor\n+    * @param blockingExecutor\n+    * @param nonBlockingExecutor", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczMzMzMg=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzgyMzg5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoyNTo1MVrOF1l3jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjowNTo0OFrOF27I8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczOTI3Ng==", "bodyText": "This should be in a separate commit for ISPN-11295.\nAlso, I would expect no blocking in the vast majority of cases, so we need an optimized path for that case and/or a PerfAck test to see if the extra thread switching affects performance.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391739276", "createdAt": "2020-03-12T16:25:51Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "diffHunk": "@@ -412,13 +418,13 @@ public InvocationStage toInvocationStage(Supplier<TimeoutException> timeoutSuppl\n             return checkState(notifier.getNow(lockState), InvocationStage::completedNullStage,\n                   ExceptionSyncInvocationStage::new, timeoutSupplier);\n          }\n-         return new SimpleAsyncInvocationStage(notifier.thenApplyAsync(state -> {\n+         return new SimpleAsyncInvocationStage(CompletionStages.continueOnExecutor(notifier.thenApplyAsync(state -> {\n             Object rv = checkState(state, () -> null, throwable -> throwable, timeoutSupplier);\n             if (rv != null) {\n                throw (RuntimeException) rv;\n             }\n             return null;\n-         }, executor));\n+         }, blockingExecutor), nonBlockingExecutor, this));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2MzI0Mg==", "bodyText": "In vast majority of cases this code is never even hit, because the notifier is normally usually done above. So I would think the thread switching here is probably not going to be an issue, and actually has a very high likely hood of actually blocking.\nThe reason the change is needed is because it then resumed the operation on the blocking thread, which we don't want.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391763242", "createdAt": "2020-03-12T17:02:42Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "diffHunk": "@@ -412,13 +418,13 @@ public InvocationStage toInvocationStage(Supplier<TimeoutException> timeoutSuppl\n             return checkState(notifier.getNow(lockState), InvocationStage::completedNullStage,\n                   ExceptionSyncInvocationStage::new, timeoutSupplier);\n          }\n-         return new SimpleAsyncInvocationStage(notifier.thenApplyAsync(state -> {\n+         return new SimpleAsyncInvocationStage(CompletionStages.continueOnExecutor(notifier.thenApplyAsync(state -> {\n             Object rv = checkState(state, () -> null, throwable -> throwable, timeoutSupplier);\n             if (rv != null) {\n                throw (RuntimeException) rv;\n             }\n             return null;\n-         }, executor));\n+         }, blockingExecutor), nonBlockingExecutor, this));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczOTI3Ng=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MDIzNA==", "bodyText": "I can make a separate commit for it.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391770234", "createdAt": "2020-03-12T17:14:16Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "diffHunk": "@@ -412,13 +418,13 @@ public InvocationStage toInvocationStage(Supplier<TimeoutException> timeoutSuppl\n             return checkState(notifier.getNow(lockState), InvocationStage::completedNullStage,\n                   ExceptionSyncInvocationStage::new, timeoutSupplier);\n          }\n-         return new SimpleAsyncInvocationStage(notifier.thenApplyAsync(state -> {\n+         return new SimpleAsyncInvocationStage(CompletionStages.continueOnExecutor(notifier.thenApplyAsync(state -> {\n             Object rv = checkState(state, () -> null, throwable -> throwable, timeoutSupplier);\n             if (rv != null) {\n                throw (RuntimeException) rv;\n             }\n             return null;\n-         }, executor));\n+         }, blockingExecutor), nonBlockingExecutor, this));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczOTI3Ng=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3NTk3Mw==", "bodyText": "I will take a closer look at this in general with this pass though. I should be able to solve it how I would want for ISPN-11295.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391775973", "createdAt": "2020-03-12T17:23:52Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "diffHunk": "@@ -412,13 +418,13 @@ public InvocationStage toInvocationStage(Supplier<TimeoutException> timeoutSuppl\n             return checkState(notifier.getNow(lockState), InvocationStage::completedNullStage,\n                   ExceptionSyncInvocationStage::new, timeoutSupplier);\n          }\n-         return new SimpleAsyncInvocationStage(notifier.thenApplyAsync(state -> {\n+         return new SimpleAsyncInvocationStage(CompletionStages.continueOnExecutor(notifier.thenApplyAsync(state -> {\n             Object rv = checkState(state, () -> null, throwable -> throwable, timeoutSupplier);\n             if (rv != null) {\n                throw (RuntimeException) rv;\n             }\n             return null;\n-         }, executor));\n+         }, blockingExecutor), nonBlockingExecutor, this));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczOTI3Ng=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEzMjU3MA==", "bodyText": "In vast majority of cases this code is never even hit, because the notifier is normally usually done above.\n\nThat depends on the access access pattern. PerfAck tests make each stressor use separate keys, so there is no contention, but when there is lots of contention the stage wouldn't be done.\nThe new approach resuming directly on a non-blocking thread looks much better!", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393132570", "createdAt": "2020-03-16T16:00:20Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "diffHunk": "@@ -412,13 +418,13 @@ public InvocationStage toInvocationStage(Supplier<TimeoutException> timeoutSuppl\n             return checkState(notifier.getNow(lockState), InvocationStage::completedNullStage,\n                   ExceptionSyncInvocationStage::new, timeoutSupplier);\n          }\n-         return new SimpleAsyncInvocationStage(notifier.thenApplyAsync(state -> {\n+         return new SimpleAsyncInvocationStage(CompletionStages.continueOnExecutor(notifier.thenApplyAsync(state -> {\n             Object rv = checkState(state, () -> null, throwable -> throwable, timeoutSupplier);\n             if (rv != null) {\n                throw (RuntimeException) rv;\n             }\n             return null;\n-         }, executor));\n+         }, blockingExecutor), nonBlockingExecutor, this));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczOTI3Ng=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEzNjM2OQ==", "bodyText": "Yeah, I am not sure why it needed a blocking thread before. So I am glad to change it to this now.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393136369", "createdAt": "2020-03-16T16:05:48Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "diffHunk": "@@ -412,13 +418,13 @@ public InvocationStage toInvocationStage(Supplier<TimeoutException> timeoutSuppl\n             return checkState(notifier.getNow(lockState), InvocationStage::completedNullStage,\n                   ExceptionSyncInvocationStage::new, timeoutSupplier);\n          }\n-         return new SimpleAsyncInvocationStage(notifier.thenApplyAsync(state -> {\n+         return new SimpleAsyncInvocationStage(CompletionStages.continueOnExecutor(notifier.thenApplyAsync(state -> {\n             Object rv = checkState(state, () -> null, throwable -> throwable, timeoutSupplier);\n             if (rv != null) {\n                throw (RuntimeException) rv;\n             }\n             return null;\n-         }, executor));\n+         }, blockingExecutor), nonBlockingExecutor, this));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczOTI3Ng=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzgzNzk4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/PerKeyLockContainer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoyOTowMlrOF1mAgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNDo0NTo0MFrOF2GaYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0MTU3MQ==", "bodyText": "I'd use field injection instead.\nlock.setTimeService(timeService) looks like it might be useful, but because there is no synchronization there's always a chance of missing one of the locks, so I'd remove that and force tests to replace the time service ahead of time.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391741571", "createdAt": "2020-03-12T16:29:02Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/PerKeyLockContainer.java", "diffHunk": "@@ -26,16 +26,19 @@\n \n    private static final int INITIAL_CAPACITY = 32;\n    private final ConcurrentMap<Object, InfinispanLock> lockMap;\n-   private Executor executor;\n+   private Executor blockingExecutor;\n+   private Executor nonBlockingExecutor;\n    private TimeService timeService;\n \n    public PerKeyLockContainer() {\n       lockMap = new ConcurrentHashMap<>(INITIAL_CAPACITY);\n    }\n \n    @Inject\n-   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor executor, TimeService timeService) {\n-      this.executor = executor;\n+   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor,\n+         @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor, TimeService timeService) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2NjI4NQ==", "bodyText": "I'd use field injection instead.\n\nI can change it, was just keeping it consistent with the previous code.\n\nlock.setTimeService(timeService) looks like it might be useful, but because there is no synchronization there's always a chance of missing one of the locks, so I'd remove that and force tests to replace the time service ahead of time.\n\nI thought you said before that cache initialization was thread safe in regards to visibility? Is this not true now?", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391766285", "createdAt": "2020-03-12T17:07:47Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/PerKeyLockContainer.java", "diffHunk": "@@ -26,16 +26,19 @@\n \n    private static final int INITIAL_CAPACITY = 32;\n    private final ConcurrentMap<Object, InfinispanLock> lockMap;\n-   private Executor executor;\n+   private Executor blockingExecutor;\n+   private Executor nonBlockingExecutor;\n    private TimeService timeService;\n \n    public PerKeyLockContainer() {\n       lockMap = new ConcurrentHashMap<>(INITIAL_CAPACITY);\n    }\n \n    @Inject\n-   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor executor, TimeService timeService) {\n-      this.executor = executor;\n+   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor,\n+         @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor, TimeService timeService) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0MTU3MQ=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3MjQ4MQ==", "bodyText": "Regular cache initialization is safe. But once a component A is started, there's no other synchronization to ensure that changes made to A's fields are properly seen by all threads that are concurrently accessing A.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r392272481", "createdAt": "2020-03-13T14:45:40Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/PerKeyLockContainer.java", "diffHunk": "@@ -26,16 +26,19 @@\n \n    private static final int INITIAL_CAPACITY = 32;\n    private final ConcurrentMap<Object, InfinispanLock> lockMap;\n-   private Executor executor;\n+   private Executor blockingExecutor;\n+   private Executor nonBlockingExecutor;\n    private TimeService timeService;\n \n    public PerKeyLockContainer() {\n       lockMap = new ConcurrentHashMap<>(INITIAL_CAPACITY);\n    }\n \n    @Inject\n-   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor executor, TimeService timeService) {\n-      this.executor = executor;\n+   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor,\n+         @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor, TimeService timeService) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0MTU3MQ=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzg5MzYyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/StripedLockContainer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjo0MzoyNVrOF1mj8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNDo0OTo1NlrOF2GkvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc1MDY0MA==", "bodyText": "We should set the executors on the other branch as well. Even though I'd rather avoid that other branch completely, there's too much code in the tests that relies on replacing components after startup.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391750640", "createdAt": "2020-03-12T16:43:25Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/StripedLockContainer.java", "diffHunk": "@@ -34,10 +34,11 @@ public StripedLockContainer(int concurrencyLevel) {\n    }\n \n    @Inject\n-   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor executor, TimeService timeService) {\n+   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor,\n+         @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor, TimeService timeService) {\n       for (int i = 0; i < sharedLocks.length; i++) {\n          if (sharedLocks[i] == null) {\n-            sharedLocks[i] = new InfinispanLock(executor, timeService);\n+            sharedLocks[i] = new InfinispanLock(blockingExecutor, nonBlockingExecutor, timeService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2ODc0NA==", "bodyText": "I think I will just remove the if/else block so it always creates a new one.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391768744", "createdAt": "2020-03-12T17:11:52Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/StripedLockContainer.java", "diffHunk": "@@ -34,10 +34,11 @@ public StripedLockContainer(int concurrencyLevel) {\n    }\n \n    @Inject\n-   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor executor, TimeService timeService) {\n+   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor,\n+         @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor, TimeService timeService) {\n       for (int i = 0; i < sharedLocks.length; i++) {\n          if (sharedLocks[i] == null) {\n-            sharedLocks[i] = new InfinispanLock(executor, timeService);\n+            sharedLocks[i] = new InfinispanLock(blockingExecutor, nonBlockingExecutor, timeService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc1MDY0MA=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3NTEzMw==", "bodyText": "I'm not sure that's ok either, as it will basically drop the locks that are held by in-progress operations/txs, and the dropped locks will never resume their waiters.\nAnd unfortunately modules that need to override core components use the same rewire() functionality as tests, so we can't say that it will only affect tests (although modules should do this before any locks can be acquired, there's no guarantee).", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r392275133", "createdAt": "2020-03-13T14:49:56Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/StripedLockContainer.java", "diffHunk": "@@ -34,10 +34,11 @@ public StripedLockContainer(int concurrencyLevel) {\n    }\n \n    @Inject\n-   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor executor, TimeService timeService) {\n+   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor,\n+         @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor, TimeService timeService) {\n       for (int i = 0; i < sharedLocks.length; i++) {\n          if (sharedLocks[i] == null) {\n-            sharedLocks[i] = new InfinispanLock(executor, timeService);\n+            sharedLocks[i] = new InfinispanLock(blockingExecutor, nonBlockingExecutor, timeService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc1MDY0MA=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzg5Njg4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/lock/InfinispanLockTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjo0NDoxMlrOF1mmDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNzoxMDo0NlrOF1noIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc1MTE4MA==", "bodyText": "Please use AbstractInfinispanTest.testExecutor() in the tests, with the common pool it's impossible to filter logs by test.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391751180", "createdAt": "2020-03-12T16:44:12Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/lock/InfinispanLockTest.java", "diffHunk": "@@ -41,7 +41,7 @@ public void testTimeout() throws InterruptedException {\n       final String lockOwner1 = \"LO1\";\n       final String lockOwner2 = \"LO2\";\n \n-      final InfinispanLock lock = new InfinispanLock(commonPool(), AbstractCacheTest.TIME_SERVICE);\n+      final InfinispanLock lock = new InfinispanLock(commonPool(), commonPool(), AbstractCacheTest.TIME_SERVICE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2ODA5Ng==", "bodyText": "Sure, I can change the existing reference to the updated one.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391768096", "createdAt": "2020-03-12T17:10:46Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/lock/InfinispanLockTest.java", "diffHunk": "@@ -41,7 +41,7 @@ public void testTimeout() throws InterruptedException {\n       final String lockOwner1 = \"LO1\";\n       final String lockOwner2 = \"LO2\";\n \n-      final InfinispanLock lock = new InfinispanLock(commonPool(), AbstractCacheTest.TIME_SERVICE);\n+      final InfinispanLock lock = new InfinispanLock(commonPool(), commonPool(), AbstractCacheTest.TIME_SERVICE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc1MTE4MA=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzkwNzE1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/lock/LockContainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjo0Njo0M1rOF1msmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNzoyMTozM1rOF1oBVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc1Mjg1Ng==", "bodyText": "I'm a bit scared that none of these tests need the executor, it suggests that maybe they don't cover all the code paths ;)", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391752856", "createdAt": "2020-03-12T16:46:43Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/lock/LockContainerTest.java", "diffHunk": "@@ -32,29 +30,28 @@\n  */\n @Test(groups = \"unit\", testName = \"lock.LockContainerTest\")\n public class LockContainerTest extends AbstractInfinispanTest {\n-   private final ExecutorService executor = new WithinThreadExecutor();\n \n    public void testSingleLockWithPerEntry() throws InterruptedException {\n       PerKeyLockContainer lockContainer = new PerKeyLockContainer();\n-      TestingUtil.inject(lockContainer, executor, AbstractCacheTest.TIME_SERVICE);\n+      TestingUtil.inject(lockContainer, AbstractCacheTest.TIME_SERVICE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3NDU1MA==", "bodyText": "I agree. As I mentioned above the executor is only used when it has to wait for the lock.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391774550", "createdAt": "2020-03-12T17:21:33Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/lock/LockContainerTest.java", "diffHunk": "@@ -32,29 +30,28 @@\n  */\n @Test(groups = \"unit\", testName = \"lock.LockContainerTest\")\n public class LockContainerTest extends AbstractInfinispanTest {\n-   private final ExecutorService executor = new WithinThreadExecutor();\n \n    public void testSingleLockWithPerEntry() throws InterruptedException {\n       PerKeyLockContainer lockContainer = new PerKeyLockContainer();\n-      TestingUtil.inject(lockContainer, executor, AbstractCacheTest.TIME_SERVICE);\n+      TestingUtil.inject(lockContainer, AbstractCacheTest.TIME_SERVICE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc1Mjg1Ng=="}, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjg4NzU3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/StripedLockContainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjowNjoyM1rOF27KVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjowNjoyM1rOF27KVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEzNjcyNw==", "bodyText": "I'm starting to think figuring out why a lock isn't unlocked after a BasicComponentRegistry.rewire() is too hard, and tests almost never replace executors anyway, so the master version of the method is safer.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393136727", "createdAt": "2020-03-16T16:06:23Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/StripedLockContainer.java", "diffHunk": "@@ -34,13 +34,10 @@ public StripedLockContainer(int concurrencyLevel) {\n    }\n \n    @Inject\n-   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor executor, TimeService timeService) {\n+   void inject(@ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor,\n+         TimeService timeService) {\n       for (int i = 0; i < sharedLocks.length; i++) {\n-         if (sharedLocks[i] == null) {\n-            sharedLocks[i] = new InfinispanLock(executor, timeService);\n-         } else {\n-            sharedLocks[i].setTimeService(timeService);\n-         }\n+         sharedLocks[i] = new InfinispanLock(nonBlockingExecutor, timeService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43c4bb7f852eded598b92e9f8e851ef2e5de3336"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDc5NzQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTozNDo0NFrOF3hwjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTo0NjoyN1rOF3iUWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc2OTEwMw==", "bodyText": "Not sure the comment belongs here", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393769103", "createdAt": "2020-03-17T15:34:44Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1384,25 +1388,42 @@ private long getMaxEntries() {\n       return Long.MAX_VALUE;\n    }\n \n-   private void preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n-      final Transaction transaction = suspendIfNeeded();\n-      boolean success = false;\n-      try {\n+   private Single<?> preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n+      // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n+      InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n+      CompletionStage<Object> stage;\n+      if (configuration.transaction().transactionMode().isTransactional() && transactionManager != null) {\n+         final Transaction transaction = suspendIfNeeded();\n+         CompletionStage<Transaction> putStage;\n          try {\n             beginIfNeeded();\n-            // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n-            InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n-            cache.put(me.getKey(), me.getValue(), metadata);\n-            success = true;\n+            putStage = cache.putAsync(me.getKey(), me.getValue(), metadata)\n+               .thenApply(ignore -> {\n+                  try {\n+                     return transactionManager.suspend();\n+                  } catch (SystemException e) {\n+                     throw new PersistenceException(\"Unable to preload!\", e);\n+                  }\n+               });\n          } catch (Exception e) {\n             throw new PersistenceException(\"Unable to preload!\", e);\n-         } finally {\n-            commitIfNeeded(success);\n          }\n-      } finally {\n-         //commitIfNeeded can throw an exception, so we need a try { } finally { }\n-         resumeIfNeeded(transaction);\n+         stage = (CompletionStage) putStage.whenCompleteAsync((pendingTransaction, t) -> {\n+            try {\n+               transactionManager.resume(pendingTransaction);\n+               commitIfNeeded(t == null);\n+            } catch (InvalidTransactionException | SystemException e) {\n+               throw new PersistenceException(\"Unable to preload!\", e);\n+            } finally {\n+               //commitIfNeeded can throw an exception, so we need a try { } finally { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc3ODI2Ng==", "bodyText": "Sure I can remove.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393778266", "createdAt": "2020-03-17T15:46:27Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1384,25 +1388,42 @@ private long getMaxEntries() {\n       return Long.MAX_VALUE;\n    }\n \n-   private void preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n-      final Transaction transaction = suspendIfNeeded();\n-      boolean success = false;\n-      try {\n+   private Single<?> preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n+      // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n+      InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n+      CompletionStage<Object> stage;\n+      if (configuration.transaction().transactionMode().isTransactional() && transactionManager != null) {\n+         final Transaction transaction = suspendIfNeeded();\n+         CompletionStage<Transaction> putStage;\n          try {\n             beginIfNeeded();\n-            // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n-            InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n-            cache.put(me.getKey(), me.getValue(), metadata);\n-            success = true;\n+            putStage = cache.putAsync(me.getKey(), me.getValue(), metadata)\n+               .thenApply(ignore -> {\n+                  try {\n+                     return transactionManager.suspend();\n+                  } catch (SystemException e) {\n+                     throw new PersistenceException(\"Unable to preload!\", e);\n+                  }\n+               });\n          } catch (Exception e) {\n             throw new PersistenceException(\"Unable to preload!\", e);\n-         } finally {\n-            commitIfNeeded(success);\n          }\n-      } finally {\n-         //commitIfNeeded can throw an exception, so we need a try { } finally { }\n-         resumeIfNeeded(transaction);\n+         stage = (CompletionStage) putStage.whenCompleteAsync((pendingTransaction, t) -> {\n+            try {\n+               transactionManager.resume(pendingTransaction);\n+               commitIfNeeded(t == null);\n+            } catch (InvalidTransactionException | SystemException e) {\n+               throw new PersistenceException(\"Unable to preload!\", e);\n+            } finally {\n+               //commitIfNeeded can throw an exception, so we need a try { } finally { }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc2OTEwMw=="}, "originalCommit": {"oid": "b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDgwOTcyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTozNzoyMlrOF3h4Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTozNzoyMlrOF3h4Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc3MTEwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  CompletionStage<Object> stage;\n          \n          \n            \n                  CompletionStage<?> stage;", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393771103", "createdAt": "2020-03-17T15:37:22Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1384,25 +1388,42 @@ private long getMaxEntries() {\n       return Long.MAX_VALUE;\n    }\n \n-   private void preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n-      final Transaction transaction = suspendIfNeeded();\n-      boolean success = false;\n-      try {\n+   private Single<?> preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n+      // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n+      InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n+      CompletionStage<Object> stage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDgyMzkwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTo0MDoxN1rOF3iBVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTo0NjoxOVrOF3iT_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc3MzM5Nw==", "bodyText": "The return value isn't used, so completionStageToSingle() should work -- or there should be a comment explaining why the double conversion is needed.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393773397", "createdAt": "2020-03-17T15:40:17Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1384,25 +1388,42 @@ private long getMaxEntries() {\n       return Long.MAX_VALUE;\n    }\n \n-   private void preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n-      final Transaction transaction = suspendIfNeeded();\n-      boolean success = false;\n-      try {\n+   private Single<?> preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n+      // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n+      InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n+      CompletionStage<Object> stage;\n+      if (configuration.transaction().transactionMode().isTransactional() && transactionManager != null) {\n+         final Transaction transaction = suspendIfNeeded();\n+         CompletionStage<Transaction> putStage;\n          try {\n             beginIfNeeded();\n-            // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n-            InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n-            cache.put(me.getKey(), me.getValue(), metadata);\n-            success = true;\n+            putStage = cache.putAsync(me.getKey(), me.getValue(), metadata)\n+               .thenApply(ignore -> {\n+                  try {\n+                     return transactionManager.suspend();\n+                  } catch (SystemException e) {\n+                     throw new PersistenceException(\"Unable to preload!\", e);\n+                  }\n+               });\n          } catch (Exception e) {\n             throw new PersistenceException(\"Unable to preload!\", e);\n-         } finally {\n-            commitIfNeeded(success);\n          }\n-      } finally {\n-         //commitIfNeeded can throw an exception, so we need a try { } finally { }\n-         resumeIfNeeded(transaction);\n+         stage = (CompletionStage) putStage.whenCompleteAsync((pendingTransaction, t) -> {\n+            try {\n+               transactionManager.resume(pendingTransaction);\n+               commitIfNeeded(t == null);\n+            } catch (InvalidTransactionException | SystemException e) {\n+               throw new PersistenceException(\"Unable to preload!\", e);\n+            } finally {\n+               //commitIfNeeded can throw an exception, so we need a try { } finally { }\n+               resumeIfNeeded(transaction);\n+            }\n+         }, blockingExecutor);\n+      } else {\n+         stage = cache.putAsync(me.getKey(), me.getValue(), metadata);\n       }\n+      return RxJavaInterop.completionStageToMaybe(stage)\n+            .toSingle(me);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc3ODE3NQ==", "bodyText": "It is used sadly because stage can have a null value and we have to have a non null one. Same reason why I can't use CompletionStage<?> above.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393778175", "createdAt": "2020-03-17T15:46:19Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1384,25 +1388,42 @@ private long getMaxEntries() {\n       return Long.MAX_VALUE;\n    }\n \n-   private void preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n-      final Transaction transaction = suspendIfNeeded();\n-      boolean success = false;\n-      try {\n+   private Single<?> preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n+      // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n+      InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n+      CompletionStage<Object> stage;\n+      if (configuration.transaction().transactionMode().isTransactional() && transactionManager != null) {\n+         final Transaction transaction = suspendIfNeeded();\n+         CompletionStage<Transaction> putStage;\n          try {\n             beginIfNeeded();\n-            // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n-            InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n-            cache.put(me.getKey(), me.getValue(), metadata);\n-            success = true;\n+            putStage = cache.putAsync(me.getKey(), me.getValue(), metadata)\n+               .thenApply(ignore -> {\n+                  try {\n+                     return transactionManager.suspend();\n+                  } catch (SystemException e) {\n+                     throw new PersistenceException(\"Unable to preload!\", e);\n+                  }\n+               });\n          } catch (Exception e) {\n             throw new PersistenceException(\"Unable to preload!\", e);\n-         } finally {\n-            commitIfNeeded(success);\n          }\n-      } finally {\n-         //commitIfNeeded can throw an exception, so we need a try { } finally { }\n-         resumeIfNeeded(transaction);\n+         stage = (CompletionStage) putStage.whenCompleteAsync((pendingTransaction, t) -> {\n+            try {\n+               transactionManager.resume(pendingTransaction);\n+               commitIfNeeded(t == null);\n+            } catch (InvalidTransactionException | SystemException e) {\n+               throw new PersistenceException(\"Unable to preload!\", e);\n+            } finally {\n+               //commitIfNeeded can throw an exception, so we need a try { } finally { }\n+               resumeIfNeeded(transaction);\n+            }\n+         }, blockingExecutor);\n+      } else {\n+         stage = cache.putAsync(me.getKey(), me.getValue(), metadata);\n       }\n+      return RxJavaInterop.completionStageToMaybe(stage)\n+            .toSingle(me);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc3MzM5Nw=="}, "originalCommit": {"oid": "b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8"}, "originalPosition": 251}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4430, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}