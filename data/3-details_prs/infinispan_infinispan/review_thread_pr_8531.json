{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NDgxMDg0", "number": 8531, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjowMjoxMlrOENVGQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjoyMzo0NlrOENVhNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDEyNjA5OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/HeaderCorrelatorHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjowMjoxMlrOGv85vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNjo0MjoyMVrOGwdOfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNDA3Ng==", "bodyText": "maybe it is a stupid question, but isn't this instance shared between requests? I mean, this scenario:\nreq1: sets streamId=1\nreq2: sets streamId=2\nresp from req1: read streamId==2\nresp from req2: read streamId==2 again?", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452934076", "createdAt": "2020-07-10T16:02:12Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/HeaderCorrelatorHandler.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.infinispan.rest;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http2.HttpConversionUtil;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Handler to propagate HTTP headers between requests and responses.\n+ *\n+ * @since 12.0\n+ */\n+class HeaderCorrelatorHandler extends ChannelDuplexHandler {\n+\n+   public static final AsciiString STREAM_ID_HEADER = HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text();\n+   private Integer streamId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1MzcwNQ==", "bodyText": "It is only shared if annotated with @Sharable. If not, it will have a new instance per pipeline\nhttps://netty.io/4.0/api/io/netty/channel/ChannelHandler.Sharable.html", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452953705", "createdAt": "2020-07-10T16:40:25Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/HeaderCorrelatorHandler.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.infinispan.rest;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http2.HttpConversionUtil;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Handler to propagate HTTP headers between requests and responses.\n+ *\n+ * @since 12.0\n+ */\n+class HeaderCorrelatorHandler extends ChannelDuplexHandler {\n+\n+   public static final AsciiString STREAM_ID_HEADER = HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text();\n+   private Integer streamId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNDA3Ng=="}, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk2NTk2OA==", "bodyText": "I will double check the threading since you mentioned. Maybe a volatile is needed in the streamId.", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452965968", "createdAt": "2020-07-10T17:05:05Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/HeaderCorrelatorHandler.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.infinispan.rest;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http2.HttpConversionUtil;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Handler to propagate HTTP headers between requests and responses.\n+ *\n+ * @since 12.0\n+ */\n+class HeaderCorrelatorHandler extends ChannelDuplexHandler {\n+\n+   public static final AsciiString STREAM_ID_HEADER = HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text();\n+   private Integer streamId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNDA3Ng=="}, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ2MzY3OQ==", "bodyText": "This is fine @pruivo. According to https://netty.io/wiki/new-and-noteworthy-in-4.0.html#wiki-h2-33:\nThere is always happens-before relationship between each ChannelHandler method invocations made by Netty. \nA user does not need to define a volatile field to keep the state of a handler.\n\nand\nNetty will never call a ChannelHandler's methods concurrently, unless the ChannelHandler is \nannotated with @Sharable.\n\nBut I did find an issue with this handler with HTTP/2. Since it's a multiplexing protocol (several requests identified by streamId travel through the same connection), Netty must create a child channel for each stream id to avoid the problem you describe. There was a bogus http2 pipeline that was not doing it. I removed it.", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r453463679", "createdAt": "2020-07-13T06:42:21Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/HeaderCorrelatorHandler.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.infinispan.rest;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http2.HttpConversionUtil;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Handler to propagate HTTP headers between requests and responses.\n+ *\n+ * @since 12.0\n+ */\n+class HeaderCorrelatorHandler extends ChannelDuplexHandler {\n+\n+   public static final AsciiString STREAM_ID_HEADER = HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text();\n+   private Integer streamId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNDA3Ng=="}, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDEzMDE4OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjowMzoyNFrOGv88Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwOToyNjo0MVrOGwgcLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNDc0Mg==", "bodyText": "is it required in this method? configureHttp1() adds another RestRequestHandler after this one.", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452934742", "createdAt": "2020-07-10T16:03:24Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "diffHunk": "@@ -76,22 +78,56 @@ public void configurePipeline(ChannelPipeline pipeline, String protocol) {\n     */\n    protected void configureHttp2(ChannelPipeline pipeline) {\n       pipeline.addLast(getHttp11To2ConnectionHandler());\n+      addHttp1Handlers(pipeline);\n+   }\n+\n+   /**\n+    * Adds the commons Http1 handlers to the pipeline.\n+    */\n+   private void addHttp1Handlers(ChannelPipeline pipeline) {\n+      // Handles http content encoding (gzip)\n+      pipeline.addLast(new HttpContentCompressor(restServer.getConfiguration().getCompressionLevel()));\n+      // Handles chunked data\n+      pipeline.addLast(new HttpObjectAggregator(maxContentLength()));\n+      // Handles Http/2 headers propagation from request to response\n+      pipeline.addLast(new HeaderCorrelatorHandler());\n+      // Handles CORS\n+      pipeline.addLast(new CorsHandler(getCorsConfigs(), true));\n+      // Handles Keep-alive\n+      pipeline.addLast(new HttpServerKeepAliveHandler());\n+      // Handles the writing of ChunkedInputs\n       pipeline.addLast(new ChunkedWriteHandler());\n-      pipeline.addLast(\"rest-handler-http2\", new RestRequestHandler(restServer));\n+      // Handles REST request\n+      pipeline.addLast(new RestRequestHandler(restServer));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1OTMzNA==", "bodyText": "let me check", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452959334", "createdAt": "2020-07-10T16:51:52Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "diffHunk": "@@ -76,22 +78,56 @@ public void configurePipeline(ChannelPipeline pipeline, String protocol) {\n     */\n    protected void configureHttp2(ChannelPipeline pipeline) {\n       pipeline.addLast(getHttp11To2ConnectionHandler());\n+      addHttp1Handlers(pipeline);\n+   }\n+\n+   /**\n+    * Adds the commons Http1 handlers to the pipeline.\n+    */\n+   private void addHttp1Handlers(ChannelPipeline pipeline) {\n+      // Handles http content encoding (gzip)\n+      pipeline.addLast(new HttpContentCompressor(restServer.getConfiguration().getCompressionLevel()));\n+      // Handles chunked data\n+      pipeline.addLast(new HttpObjectAggregator(maxContentLength()));\n+      // Handles Http/2 headers propagation from request to response\n+      pipeline.addLast(new HeaderCorrelatorHandler());\n+      // Handles CORS\n+      pipeline.addLast(new CorsHandler(getCorsConfigs(), true));\n+      // Handles Keep-alive\n+      pipeline.addLast(new HttpServerKeepAliveHandler());\n+      // Handles the writing of ChunkedInputs\n       pipeline.addLast(new ChunkedWriteHandler());\n-      pipeline.addLast(\"rest-handler-http2\", new RestRequestHandler(restServer));\n+      // Handles REST request\n+      pipeline.addLast(new RestRequestHandler(restServer));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNDc0Mg=="}, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzUxNjMzMg==", "bodyText": "I got rid of Http11RequestHandler altogether. It seems overkill to have an extra class just to handle an extra if", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r453516332", "createdAt": "2020-07-13T09:26:41Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "diffHunk": "@@ -76,22 +78,56 @@ public void configurePipeline(ChannelPipeline pipeline, String protocol) {\n     */\n    protected void configureHttp2(ChannelPipeline pipeline) {\n       pipeline.addLast(getHttp11To2ConnectionHandler());\n+      addHttp1Handlers(pipeline);\n+   }\n+\n+   /**\n+    * Adds the commons Http1 handlers to the pipeline.\n+    */\n+   private void addHttp1Handlers(ChannelPipeline pipeline) {\n+      // Handles http content encoding (gzip)\n+      pipeline.addLast(new HttpContentCompressor(restServer.getConfiguration().getCompressionLevel()));\n+      // Handles chunked data\n+      pipeline.addLast(new HttpObjectAggregator(maxContentLength()));\n+      // Handles Http/2 headers propagation from request to response\n+      pipeline.addLast(new HeaderCorrelatorHandler());\n+      // Handles CORS\n+      pipeline.addLast(new CorsHandler(getCorsConfigs(), true));\n+      // Handles Keep-alive\n+      pipeline.addLast(new HttpServerKeepAliveHandler());\n+      // Handles the writing of ChunkedInputs\n       pipeline.addLast(new ChunkedWriteHandler());\n-      pipeline.addLast(\"rest-handler-http2\", new RestRequestHandler(restServer));\n+      // Handles REST request\n+      pipeline.addLast(new RestRequestHandler(restServer));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNDc0Mg=="}, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDEzMTQyOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjowMzo0N1rOGv89FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo1MToxNlrOGv-bNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNDkzMw==", "bodyText": "well, it says HTTP2... does it work with HTTP1?", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452934933", "createdAt": "2020-07-10T16:03:47Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "diffHunk": "@@ -76,22 +78,56 @@ public void configurePipeline(ChannelPipeline pipeline, String protocol) {\n     */\n    protected void configureHttp2(ChannelPipeline pipeline) {\n       pipeline.addLast(getHttp11To2ConnectionHandler());\n+      addHttp1Handlers(pipeline);\n+   }\n+\n+   /**\n+    * Adds the commons Http1 handlers to the pipeline.\n+    */\n+   private void addHttp1Handlers(ChannelPipeline pipeline) {\n+      // Handles http content encoding (gzip)\n+      pipeline.addLast(new HttpContentCompressor(restServer.getConfiguration().getCompressionLevel()));\n+      // Handles chunked data\n+      pipeline.addLast(new HttpObjectAggregator(maxContentLength()));\n+      // Handles Http/2 headers propagation from request to response", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1OTAyOA==", "bodyText": "Our handlers act as if they were dealing in HTTP/1 only, Netty provides a series of adaptors from HTTP2 to HTTP1 and back when the connection is HTTP/2. The only thing we should do is to send this streamId if it is present. It won't be in HTTP1 connections so this new handler becomes a no-op", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452959028", "createdAt": "2020-07-10T16:51:16Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "diffHunk": "@@ -76,22 +78,56 @@ public void configurePipeline(ChannelPipeline pipeline, String protocol) {\n     */\n    protected void configureHttp2(ChannelPipeline pipeline) {\n       pipeline.addLast(getHttp11To2ConnectionHandler());\n+      addHttp1Handlers(pipeline);\n+   }\n+\n+   /**\n+    * Adds the commons Http1 handlers to the pipeline.\n+    */\n+   private void addHttp1Handlers(ChannelPipeline pipeline) {\n+      // Handles http content encoding (gzip)\n+      pipeline.addLast(new HttpContentCompressor(restServer.getConfiguration().getCompressionLevel()));\n+      // Handles chunked data\n+      pipeline.addLast(new HttpObjectAggregator(maxContentLength()));\n+      // Handles Http/2 headers propagation from request to response", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNDkzMw=="}, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDEzNDkyOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjowNDo1M1rOGv8_Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjowNDo1M1rOGv8_Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkzNTUwNw==", "bodyText": "maybe change the method name to addCommonHandlers. it isn't clear for me if this method should register only HTTP1 or HTTP2 or both handlers :)", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452935507", "createdAt": "2020-07-10T16:04:53Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "diffHunk": "@@ -76,22 +78,56 @@ public void configurePipeline(ChannelPipeline pipeline, String protocol) {\n     */\n    protected void configureHttp2(ChannelPipeline pipeline) {\n       pipeline.addLast(getHttp11To2ConnectionHandler());\n+      addHttp1Handlers(pipeline);\n+   }\n+\n+   /**\n+    * Adds the commons Http1 handlers to the pipeline.\n+    */\n+   private void addHttp1Handlers(ChannelPipeline pipeline) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDE2NjU2OnYy", "diffSide": "RIGHT", "path": "server/rest/src/test/java/org/infinispan/rest/assertion/ResponseAssertion.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjoxNTowMFrOGv9TxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjoxNTowMFrOGv9TxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk0MDc0MA==", "bodyText": "nitpick: final", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452940740", "createdAt": "2020-07-10T16:15:00Z", "author": {"login": "pruivo"}, "path": "server/rest/src/test/java/org/infinispan/rest/assertion/ResponseAssertion.java", "diffHunk": "@@ -54,11 +57,16 @@\n    private RestResponse response;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDE3OTUxOnYy", "diffSide": "RIGHT", "path": "server/rest/src/test/java/org/infinispan/rest/resources/AbstractRestResourceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjoxODo1OVrOGv9bwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjoxODo1OVrOGv9bwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk0Mjc4NQ==", "bodyText": "nitpick: instead of a boolean, I probably use protocol(org.infinispan.client.rest.configuration.Protocol) to be future proof \ud83d\udc4d", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452942785", "createdAt": "2020-07-10T16:18:59Z", "author": {"login": "pruivo"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/AbstractRestResourceTest.java", "diffHunk": "@@ -59,19 +63,31 @@\n    private final List<RestServerHelper> restServers = new ArrayList<>(NUM_SERVERS);\n \n    protected boolean security;\n+   protected boolean http2;\n+   protected boolean ssl;\n \n    protected CacheIgnoreManager ignoreManager;\n \n    @Override\n    protected String parameters() {\n-      return \"[security=\" + security + \"]\";\n+      return \"[security=\" + security + \", http2=\" + http2 + \", ssl=\" + ssl + \"]\";\n    }\n \n    protected AbstractRestResourceTest withSecurity(boolean security) {\n       this.security = security;\n       return this;\n    }\n \n+   protected AbstractRestResourceTest http2(boolean http2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDE4MjY1OnYy", "diffSide": "RIGHT", "path": "server/rest/src/test/java/org/infinispan/rest/resources/CacheResourceTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjoxOTo1NlrOGv9drw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo1NTo0N1rOGv-j1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk0MzI3OQ==", "bodyText": "security and ssl tests with HTTP1 missing?", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452943279", "createdAt": "2020-07-10T16:19:56Z", "author": {"login": "pruivo"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/CacheResourceTest.java", "diffHunk": "@@ -86,12 +86,13 @@ protected void defineCaches(EmbeddedCacheManager cm) {\n    public Object[] factory() {\n       return new Object[]{\n             new CacheResourceTest().withSecurity(false),\n-            new CacheResourceTest().withSecurity(true),\n+            new CacheResourceTest().withSecurity(true).http2(true),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk0NDExMA==", "bodyText": "ps. org.infinispan.rest.resources.CacheResourceOffHeapTest be changed as well to test all combination (hopefully not an overkill)", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452944110", "createdAt": "2020-07-10T16:21:29Z", "author": {"login": "pruivo"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/CacheResourceTest.java", "diffHunk": "@@ -86,12 +86,13 @@ protected void defineCaches(EmbeddedCacheManager cm) {\n    public Object[] factory() {\n       return new Object[]{\n             new CacheResourceTest().withSecurity(false),\n-            new CacheResourceTest().withSecurity(true),\n+            new CacheResourceTest().withSecurity(true).http2(true),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk0MzI3OQ=="}, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk2MTIzOA==", "bodyText": "I will add https and  http1. I though it'd be rare, since we usually offer http/2 after the protocol negotiation during the SSL handshake, but you never know what are the clients out there. And Offheap + any combination is not necessary I think. It will bloat the test suite", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452961238", "createdAt": "2020-07-10T16:55:47Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/CacheResourceTest.java", "diffHunk": "@@ -86,12 +86,13 @@ protected void defineCaches(EmbeddedCacheManager cm) {\n    public Object[] factory() {\n       return new Object[]{\n             new CacheResourceTest().withSecurity(false),\n-            new CacheResourceTest().withSecurity(true),\n+            new CacheResourceTest().withSecurity(true).http2(true),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk0MzI3OQ=="}, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDE5MzQxOnYy", "diffSide": "RIGHT", "path": "server/rest/src/test/java/org/infinispan/rest/resources/CacheV2ResourceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjoyMzowOVrOGv9kUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo1Njo0M1rOGv-lyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk0NDk3OA==", "bodyText": "same comment as above", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452944978", "createdAt": "2020-07-10T16:23:09Z", "author": {"login": "pruivo"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/CacheV2ResourceTest.java", "diffHunk": "@@ -71,8 +71,9 @@ protected void defineCaches(EmbeddedCacheManager cm) {\n    @Override\n    public Object[] factory() {\n       return new Object[]{\n-            new CacheV2ResourceTest().withSecurity(true),\n-            new CacheV2ResourceTest().withSecurity(false)\n+            new CacheV2ResourceTest().withSecurity(false),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk2MTczOA==", "bodyText": "I will probably add SSL + HTTP1 to either cachev1 or cachev2, not both, to avoiding passing the 1.000 tests mark :)", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452961738", "createdAt": "2020-07-10T16:56:43Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/CacheV2ResourceTest.java", "diffHunk": "@@ -71,8 +71,9 @@ protected void defineCaches(EmbeddedCacheManager cm) {\n    @Override\n    public Object[] factory() {\n       return new Object[]{\n-            new CacheV2ResourceTest().withSecurity(true),\n-            new CacheV2ResourceTest().withSecurity(false)\n+            new CacheV2ResourceTest().withSecurity(false),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk0NDk3OA=="}, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDE5NTEwOnYy", "diffSide": "RIGHT", "path": "server/rest/src/test/java/org/infinispan/rest/resources/StaticResourceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjoyMzo0NlrOGv9lWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjoyMzo0NlrOGv9lWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk0NTI0MA==", "bodyText": "same as above :)", "url": "https://github.com/infinispan/infinispan/pull/8531#discussion_r452945240", "createdAt": "2020-07-10T16:23:46Z", "author": {"login": "pruivo"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/StaticResourceTest.java", "diffHunk": "@@ -55,18 +72,12 @@ private RestResponse call(String path, String ifModifiedSince) {\n       return join(rawClient.get(path, allHeaders));\n    }\n \n-   @Override\n-   protected RestClientConfigurationBuilder getClientConfig() {\n-      RestClientConfigurationBuilder builder = super.getClientConfig();\n-      builder.followRedirects(true);\n-      return builder;\n-   }\n-\n    @Override\n    public Object[] factory() {\n       return new Object[]{\n             new StaticResourceTest().withSecurity(false),\n-            new StaticResourceTest().withSecurity(true),\n+            new StaticResourceTest().withSecurity(true).http2(true),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85d32ef448371d7bb3092b645d34dde42f215b9c"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3977, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}