{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MDAxMjUw", "number": 8400, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDowODozMFrOEA52UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDowODozMFrOEA52UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MzgzMjQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDowODozMFrOGceHUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDoxOToxN1rOGcen1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUwNjcwNA==", "bodyText": "Shouldn't this be storeStatus.store.rollback?\nIt's worrying that this wasn't detected by our testsuite \ud83d\ude31", "url": "https://github.com/infinispan/infinispan/pull/8400#discussion_r432506704", "createdAt": "2020-05-29T14:08:30Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -885,55 +897,47 @@ private boolean shouldWrite(StoreStatus storeStatus, Predicate<? super StoreConf\n    }\n \n    @Override\n-   public CompletionStage<Void> prepareAllTxStores(Transaction transaction, BatchModification batchModification,\n+   public CompletionStage<Void> prepareAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n          Predicate<? super StoreConfiguration> predicate) throws PersistenceException {\n-      return Completable.using(\n-            this::acquireReadLock,\n-            ignore -> {\n-               checkStoreAvailability();\n-               if (trace) {\n-                  log.tracef(\"Preparing batch for store: %s on transaction %s\", batchModification, transaction);\n-               }\n-               return Flowable.fromIterable(stores)\n-                     .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n-                     // Let the prepare work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.prepareWithModifications(transaction, batchModification)));\n-            },\n-            this::releaseReadLock\n-      ).toCompletionStage(null);\n+      //noinspection unchecked\n+      return batchOperation(txInvocationContext, null, (stores, segmentCount, removeFlowable,\n+            putFlowable) -> stores.prepareWithModifications(txInvocationContext.getTransaction(), segmentCount, removeFlowable, putFlowable))\n+            .thenApply(CompletableFutures.toNullFunction());\n    }\n \n    @Override\n-   public CompletionStage<Void> commitAllTxStores(Transaction transaction, Predicate<? super StoreConfiguration> predicate) {\n+   public CompletionStage<Void> commitAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n+         Predicate<? super StoreConfiguration> predicate) {\n       return Completable.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n-                  log.tracef(\"Committing transaction %s to stores\", transaction);\n+                  log.tracef(\"Committing transaction %s to stores\", txInvocationContext);\n                }\n                return Flowable.fromIterable(stores)\n                      .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n                      // Let the commit work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(transaction)));\n+                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(txInvocationContext.getTransaction())));\n             },\n             this::releaseReadLock\n       ).toCompletionStage(null);\n    }\n \n    @Override\n-   public CompletionStage<Void> rollbackAllTxStores(Transaction transaction, Predicate<? super StoreConfiguration> predicate) {\n+   public CompletionStage<Void> rollbackAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n+         Predicate<? super StoreConfiguration> predicate) {\n       return Completable.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n-                  log.tracef(\"Rolling back transaction %s for stores\", transaction);\n+                  log.tracef(\"Rolling back transaction %s for stores\", txInvocationContext);\n                }\n                return Flowable.fromIterable(stores)\n                      .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n                      // Let the rollback work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(transaction)));\n+                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(txInvocationContext.getTransaction())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f920e997951c4a8a777a9b1e06adf722d7176f6d"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUxMTY5Mw==", "bodyText": ":( My guess it the JDBC store just doesn't have great coverage around this case. I can fix this and I will log a JIRA to create a test case for JDBC store.", "url": "https://github.com/infinispan/infinispan/pull/8400#discussion_r432511693", "createdAt": "2020-05-29T14:15:47Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -885,55 +897,47 @@ private boolean shouldWrite(StoreStatus storeStatus, Predicate<? super StoreConf\n    }\n \n    @Override\n-   public CompletionStage<Void> prepareAllTxStores(Transaction transaction, BatchModification batchModification,\n+   public CompletionStage<Void> prepareAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n          Predicate<? super StoreConfiguration> predicate) throws PersistenceException {\n-      return Completable.using(\n-            this::acquireReadLock,\n-            ignore -> {\n-               checkStoreAvailability();\n-               if (trace) {\n-                  log.tracef(\"Preparing batch for store: %s on transaction %s\", batchModification, transaction);\n-               }\n-               return Flowable.fromIterable(stores)\n-                     .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n-                     // Let the prepare work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.prepareWithModifications(transaction, batchModification)));\n-            },\n-            this::releaseReadLock\n-      ).toCompletionStage(null);\n+      //noinspection unchecked\n+      return batchOperation(txInvocationContext, null, (stores, segmentCount, removeFlowable,\n+            putFlowable) -> stores.prepareWithModifications(txInvocationContext.getTransaction(), segmentCount, removeFlowable, putFlowable))\n+            .thenApply(CompletableFutures.toNullFunction());\n    }\n \n    @Override\n-   public CompletionStage<Void> commitAllTxStores(Transaction transaction, Predicate<? super StoreConfiguration> predicate) {\n+   public CompletionStage<Void> commitAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n+         Predicate<? super StoreConfiguration> predicate) {\n       return Completable.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n-                  log.tracef(\"Committing transaction %s to stores\", transaction);\n+                  log.tracef(\"Committing transaction %s to stores\", txInvocationContext);\n                }\n                return Flowable.fromIterable(stores)\n                      .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n                      // Let the commit work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(transaction)));\n+                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(txInvocationContext.getTransaction())));\n             },\n             this::releaseReadLock\n       ).toCompletionStage(null);\n    }\n \n    @Override\n-   public CompletionStage<Void> rollbackAllTxStores(Transaction transaction, Predicate<? super StoreConfiguration> predicate) {\n+   public CompletionStage<Void> rollbackAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n+         Predicate<? super StoreConfiguration> predicate) {\n       return Completable.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n-                  log.tracef(\"Rolling back transaction %s for stores\", transaction);\n+                  log.tracef(\"Rolling back transaction %s for stores\", txInvocationContext);\n                }\n                return Flowable.fromIterable(stores)\n                      .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n                      // Let the rollback work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(transaction)));\n+                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(txInvocationContext.getTransaction())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUwNjcwNA=="}, "originalCommit": {"oid": "f920e997951c4a8a777a9b1e06adf722d7176f6d"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUxNTAyOQ==", "bodyText": "Fixed the typo", "url": "https://github.com/infinispan/infinispan/pull/8400#discussion_r432515029", "createdAt": "2020-05-29T14:19:17Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -885,55 +897,47 @@ private boolean shouldWrite(StoreStatus storeStatus, Predicate<? super StoreConf\n    }\n \n    @Override\n-   public CompletionStage<Void> prepareAllTxStores(Transaction transaction, BatchModification batchModification,\n+   public CompletionStage<Void> prepareAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n          Predicate<? super StoreConfiguration> predicate) throws PersistenceException {\n-      return Completable.using(\n-            this::acquireReadLock,\n-            ignore -> {\n-               checkStoreAvailability();\n-               if (trace) {\n-                  log.tracef(\"Preparing batch for store: %s on transaction %s\", batchModification, transaction);\n-               }\n-               return Flowable.fromIterable(stores)\n-                     .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n-                     // Let the prepare work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.prepareWithModifications(transaction, batchModification)));\n-            },\n-            this::releaseReadLock\n-      ).toCompletionStage(null);\n+      //noinspection unchecked\n+      return batchOperation(txInvocationContext, null, (stores, segmentCount, removeFlowable,\n+            putFlowable) -> stores.prepareWithModifications(txInvocationContext.getTransaction(), segmentCount, removeFlowable, putFlowable))\n+            .thenApply(CompletableFutures.toNullFunction());\n    }\n \n    @Override\n-   public CompletionStage<Void> commitAllTxStores(Transaction transaction, Predicate<? super StoreConfiguration> predicate) {\n+   public CompletionStage<Void> commitAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n+         Predicate<? super StoreConfiguration> predicate) {\n       return Completable.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n-                  log.tracef(\"Committing transaction %s to stores\", transaction);\n+                  log.tracef(\"Committing transaction %s to stores\", txInvocationContext);\n                }\n                return Flowable.fromIterable(stores)\n                      .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n                      // Let the commit work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(transaction)));\n+                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(txInvocationContext.getTransaction())));\n             },\n             this::releaseReadLock\n       ).toCompletionStage(null);\n    }\n \n    @Override\n-   public CompletionStage<Void> rollbackAllTxStores(Transaction transaction, Predicate<? super StoreConfiguration> predicate) {\n+   public CompletionStage<Void> rollbackAllTxStores(TxInvocationContext<AbstractCacheTransaction> txInvocationContext,\n+         Predicate<? super StoreConfiguration> predicate) {\n       return Completable.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n-                  log.tracef(\"Rolling back transaction %s for stores\", transaction);\n+                  log.tracef(\"Rolling back transaction %s for stores\", txInvocationContext);\n                }\n                return Flowable.fromIterable(stores)\n                      .filter(storeStatus -> shouldPerformTransactionOperation(storeStatus, predicate))\n                      // Let the rollback work in parallel across the stores\n-                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(transaction)));\n+                     .flatMapCompletable(storeStatus -> Completable.fromCompletionStage(storeStatus.store.commit(txInvocationContext.getTransaction())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUwNjcwNA=="}, "originalCommit": {"oid": "f920e997951c4a8a777a9b1e06adf722d7176f6d"}, "originalPosition": 132}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4119, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}