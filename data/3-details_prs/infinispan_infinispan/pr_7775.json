{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1OTA5ODU4", "number": 7775, "title": "ISPN-9082 Off Heap max idle", "bodyText": "https://issues.redhat.com/browse/ISPN-9082\nhttps://issues.redhat.com/browse/ISPN-11204", "createdAt": "2020-01-22T15:16:11Z", "url": "https://github.com/infinispan/infinispan/pull/7775", "merged": true, "mergeCommit": {"oid": "d1418f4b0f93ec80bbe093c4405aa0d46be9c2a2"}, "closed": true, "closedAt": "2020-02-04T16:00:41Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-2NzXgBqjI5ODY4ODAwNzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_bWEbABqjI5OTM1MjQxODM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c99dba8331aadbc8dd634b32f1d6c86b6be6e96", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/2c99dba8331aadbc8dd634b32f1d6c86b6be6e96", "committedDate": "2020-01-22T15:02:15Z", "message": "ISPN-11204 Response Collector addResponse value can be ignored"}, "afterCommit": {"oid": "6f4a7efa3f3c1508d915a80601b258021296167d", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/6f4a7efa3f3c1508d915a80601b258021296167d", "committedDate": "2020-01-28T19:07:57Z", "message": "retry for optimistic reads"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6f4a7efa3f3c1508d915a80601b258021296167d", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/6f4a7efa3f3c1508d915a80601b258021296167d", "committedDate": "2020-01-28T19:07:57Z", "message": "retry for optimistic reads"}, "afterCommit": {"oid": "430f81df9b0b6b82afad9db3c89330e3fa37953d", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/430f81df9b0b6b82afad9db3c89330e3fa37953d", "committedDate": "2020-01-28T19:32:50Z", "message": "retry for optimistic reads"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "430f81df9b0b6b82afad9db3c89330e3fa37953d", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/430f81df9b0b6b82afad9db3c89330e3fa37953d", "committedDate": "2020-01-28T19:32:50Z", "message": "retry for optimistic reads"}, "afterCommit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "committedDate": "2020-01-28T20:08:42Z", "message": "Retry for max idle and optimistic reads in addition to writes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTY2Mjg5", "url": "https://github.com/infinispan/infinispan/pull/7775#pullrequestreview-350166289", "createdAt": "2020-01-29T14:53:11Z", "commit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNDo1MzoxMVrOFjLO7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODoxNTozMVrOFjSitw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyODUyNA==", "bodyText": "Couldn't getMapForSegment() return a TouchableMap, or rather a PeekableTouchableMap, in order to avoid the instanceof check?", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372428524", "createdAt": "2020-01-29T14:53:11Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/impl/AbstractInternalDataContainer.java", "diffHunk": "@@ -124,6 +124,12 @@ public void start() {\n    public boolean touch(int segment, Object k, long currentTimeMillis) {\n       ConcurrentMap<K, InternalCacheEntry<K, V>> entries = getMapForSegment(segment);\n       if (entries != null) {\n+         if (trace) {\n+            log.tracef(\"Touching key %s in container with time of %d\", k, currentTimeMillis);\n+         }\n+         if (entries instanceof TouchableMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ1ODM1Nw==", "bodyText": "Shouldn't it throw an exception instead?", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372458357", "createdAt": "2020-01-29T15:38:24Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/offheap/OffHeapConcurrentMap.java", "diffHunk": "@@ -160,6 +161,52 @@ public OffHeapConcurrentMap(OffHeapMemoryAllocator allocator,\n       }\n    }\n \n+   @Override\n+   public boolean touchKey(Object k, long currentTimeMillis) {\n+      if (!(k instanceof WrappedBytes)) {\n+         return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ==", "bodyText": "Why would the metadata size be different?", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372482995", "createdAt": "2020-01-29T16:17:23Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/offheap/OffHeapEntryFactoryImpl.java", "diffHunk": "@@ -503,4 +523,105 @@ public long calculateSize(WrappedBytes key, WrappedBytes value, Metadata metadat\n       }\n       return UnpooledOffHeapMemoryAllocator.estimateSizeOverhead(totalSize + metadataSize);\n    }\n+\n+   @Override\n+   public long updateMaxIdle(long address, long currentTimeMillis) {\n+      // 16 bytes for eviction if needed (optional)\n+      // 8 bytes for linked pointer\n+      long offset = evictionEnabled ? 24 : 8;\n+\n+      byte metadataType = MEMORY.getByte(address, offset);\n+\n+      if ((metadataType & (IMMORTAL + MORTAL)) != 0) {\n+         return 0;\n+      }\n+\n+      // skips over metadataType, hashCode\n+      offset += 5;\n+\n+      int keySize = MEMORY.getInt(address, offset);\n+      offset += 4;\n+\n+      boolean hasVersion = (metadataType & HAS_VERSION) != 0;\n+\n+      if ((metadataType & TRANSIENT) != 0) {\n+         // Skip the metadataSize (if version present), valueSize and the keyBytes\n+         offset += ((hasVersion ? 4 : 0) + 4 + keySize);\n+         // Skip the max idle value\n+         storeLongLittleEndian(address, offset + 8, currentTimeMillis);\n+         return 0;\n+      }\n+      if ((metadataType & TRANSIENT_MORTAL) != 0) {\n+         // Skip the metadataSize (if version present), valueSize and the keyBytes\n+         offset += ((hasVersion ? 4 : 0) + 4 + keySize);\n+         // Skip the lifespan/max idle values and created\n+         storeLongLittleEndian(address, offset + 24, currentTimeMillis);\n+         return 0;\n+      }\n+\n+      byte[] metadataBytes = new byte[MEMORY.getInt(address, offset)];\n+      int metadataSize = metadataBytes.length;\n+      offset += 4;\n+\n+      int valueSize = MEMORY.getInt(address, offset);\n+      offset += 4;\n+\n+      // skips over the actual key bytes\n+      offset += keySize;\n+\n+      MEMORY.getBytes(address, offset, metadataBytes, 0, metadataSize);\n+\n+      Metadata metadata;\n+      try {\n+         metadata = (Metadata) marshaller.objectFromByteBuffer(metadataBytes);\n+      } catch (IOException | ClassNotFoundException e) {\n+         throw new CacheException(e);\n+      }\n+\n+      Metadata newMetadata = metadata.builder()\n+            .maxIdle(currentTimeMillis, TimeUnit.MILLISECONDS)\n+            .build();\n+\n+      byte[] newMetadataBytes;\n+      try {\n+         newMetadataBytes = marshaller.objectToByteBuffer(newMetadata, metadataSize);\n+      } catch (IOException e) {\n+         throw new CacheException(e);\n+      } catch (InterruptedException e) {\n+         Thread.currentThread().interrupt();\n+         throw new CacheException(e);\n+      }\n+\n+      int newMetdataSize = newMetadataBytes.length;\n+      if (newMetdataSize != metadataSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5MTI1Nw==", "bodyText": "\ud83d\udc4d, it's easier to reason about your own future than the previous operation's future", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372491257", "createdAt": "2020-01-29T16:30:22Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -360,17 +322,51 @@ Throwable getNestedThrowable(Throwable t) {\n          lifespan = entry.getLifespan();\n          expiredMortal = ExpiryHelper.isExpiredMortal(lifespan, entry.getCreated(), currentTime);\n       }\n+      CompletableFuture<Boolean> future;\n       if (expiredMortal) {\n-         CompletableFuture<Boolean> future = handleLifespanExpireEntry(entry.getKey(), value, lifespan, isWrite);\n+         future = handleLifespanExpireEntry(entry.getKey(), value, lifespan, isWrite);\n          // We don't want to block the user while the remove expired is happening for lifespan on a read\n-         if (waitOnLifespanExpiration(isWrite)) {\n-            return future;\n+         if (!waitOnLifespanExpiration(isWrite)) {\n+            return CompletableFutures.completedTrue();\n          }\n-         return CompletableFutures.completedTrue();\n       } else {\n          // This means it expired transiently - this will block user until we confirm the entry is okay\n-         return handleMaxIdleExpireEntry(entry.getKey(), value, entry.getMaxIdle(), isWrite);\n+         future = handleMaxIdleExpireEntry(entry.getKey(), value, entry.getMaxIdle(), isWrite);\n       }\n+\n+      return future.handle((expired, t) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzNzExMQ==", "bodyText": "I wonder how bad would it be to copy the ICE into a MvccEntry all the time.\nI've never liked the synchronized (cacheEntry) stuff, and JMC always complains that the JVM tried biased locking and it didn't work out.", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372537111", "createdAt": "2020-01-29T17:52:51Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -452,18 +447,22 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n             .thenCompose(Function.identity());\n    }\n \n-   private CompletionStage<Boolean> checkExpiredMaxIdle(Object key, int segment) {\n+   private CompletionStage<Boolean> attemptTouchAndReturnIfExpired(InternalCacheEntry ice, int segment) {\n       LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n \n-      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(ice.getKey(), segment);\n       touchCommand.setTopologyId(lct.getTopologyId());\n \n       CompletionStage<Boolean> remoteStage = invokeTouchCommandRemotely(touchCommand, lct, segment);\n       touchCommand.init(componentRegistry, false);\n+      long accessTime = timeService.wallClockTime();\n+      touchCommand.setAccessTime(accessTime);\n       CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n \n       return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n          if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            // The ICE can be a copy in cases such as off heap - we need to update its time that is reported to the user", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzNzU5Mw==", "bodyText": "IMO transient is better than a comment.", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372537593", "createdAt": "2020-01-29T17:53:48Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -35,6 +35,9 @@\n    private TimeService timeService;\n    private DistributionManager distributionManager;\n \n+   // This is not replicated - here solely to avoid additional time lookups in callers\n+   private long accessTime = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzOTg3OA==", "bodyText": "On the local node you don't need to call invokeAsync(), you can add a new method that takes the access time as a parameter. Then invokeAsync() would call the new method with timeService.wallClockTime(), and you wouldn't need a field.", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372539878", "createdAt": "2020-01-29T17:58:20Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -90,9 +93,14 @@ public void setTopologyId(int topologyId) {\n       this.topologyId = topologyId;\n    }\n \n+   public void setAccessTime(long currentTimeMillis) {\n+      this.accessTime = currentTimeMillis;\n+   }\n+\n    @Override\n    public CompletableFuture<Object> invokeAsync() {\n-      boolean touched = internalDataContainer.touch(segment, key, timeService.wallClockTime());\n+      long accessTime = this.accessTime == -1 ? timeService.wallClockTime() : this.accessTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg==", "bodyText": "-1, this is an eviction test and not a storage test.", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372545636", "createdAt": "2020-01-29T18:10:01Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -50,17 +54,37 @@\n \n    protected ConfigurationBuilder configurationBuilder;\n \n+   protected StorageType storageType;\n+\n+   protected ClusterExpirationFunctionalTest storageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return concat(super.parameterNames(), \"storageType\");\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return concat(super.parameterValues(), storageType);\n+   }\n+\n    @Override\n    public Object[] factory() {\n-      return new Object[] {\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.DIST_SYNC).transactional(true).lockingMode(LockingMode.OPTIMISTIC),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.DIST_SYNC).transactional(true).lockingMode(LockingMode.PESSIMISTIC),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.DIST_SYNC).transactional(false),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.REPL_SYNC).transactional(true).lockingMode(LockingMode.OPTIMISTIC),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.REPL_SYNC).transactional(true).lockingMode(LockingMode.PESSIMISTIC),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.REPL_SYNC).transactional(false),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.SCATTERED_SYNC).transactional(false),\n-      };\n+      return Arrays.stream(StorageType.values())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0ODI3OQ==", "bodyText": "IMO MagicKey could do it, but instead of computing a hashCode and always returning it, it needs to generate a random value so that the hash of the serialized form has the required owners.", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372548279", "createdAt": "2020-01-29T18:15:31Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -139,16 +164,40 @@ private void testLifespanExpiredEntryRetrieval(Cache<Object, String> primaryOwne\n       }\n    }\n \n-   private MagicKey createKey(Cache<Object, String> primaryOwner, Cache<Object, String> backupOwner) {\n-      if (cacheMode.isScattered()) {\n-         return new MagicKey(primaryOwner);\n+   private Object createKey(Cache<Object, String> primaryOwner, Cache<Object, String> backupOwner) {\n+      if (storageType == StorageType.OBJECT) {\n+         if (cacheMode.isScattered()) {\n+            return new MagicKey(primaryOwner);\n+         } else {\n+            return new MagicKey(primaryOwner, backupOwner);\n+         }\n       } else {\n-         return new MagicKey(primaryOwner, backupOwner);\n+         // BINARY and OFF heap can't use MagicKey as they are serialized", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06"}, "originalPosition": 102}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61f75625c07d8b8c45332282999030b4d0c8098d", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/61f75625c07d8b8c45332282999030b4d0c8098d", "committedDate": "2020-01-30T14:23:33Z", "message": "ISPN-9082 Off Heap maxIdle expiration works like lifespan"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0309bf41bc84451836853a95f4fda22f02704c1b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/0309bf41bc84451836853a95f4fda22f02704c1b", "committedDate": "2020-01-30T14:23:33Z", "message": "ISPN-11204 Response Collector addResponse value can be ignored"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae8e14d5ad4ed15a609161f22899c29ee5c094cb", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/ae8e14d5ad4ed15a609161f22899c29ee5c094cb", "committedDate": "2020-01-29T19:46:17Z", "message": "some rework comments"}, "afterCommit": {"oid": "0309bf41bc84451836853a95f4fda22f02704c1b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/0309bf41bc84451836853a95f4fda22f02704c1b", "committedDate": "2020-01-30T14:23:33Z", "message": "ISPN-11204 Response Collector addResponse value can be ignored"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1233, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}