{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2MTQ4NTc3", "number": 8022, "title": "ISPN-11443 PersistenceManagerImpl thread checks need to be updated", "bodyText": "https://issues.redhat.com/browse/ISPN-11443\nhttps://issues.redhat.com/browse/ISPN-11450\nhttps://issues.redhat.com/browse/ISPN-11295", "createdAt": "2020-03-10T13:56:48Z", "url": "https://github.com/infinispan/infinispan/pull/8022", "merged": true, "mergeCommit": {"oid": "11f0f7a5fcd27a13b5efccff225d4f6a12a2d8c3"}, "closed": true, "closedAt": "2020-03-18T05:42:49Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcM-pMegFqTM3MzcwMTU1Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOltJGgBqjMxMzgyMTc0OTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzAxNTUz", "url": "https://github.com/infinispan/infinispan/pull/8022#pullrequestreview-373701553", "createdAt": "2020-03-12T16:16:10Z", "commit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoxNjoxMVrOF1lecw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjo0Njo0M1rOF1msmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczMjg1MQ==", "bodyText": "Not sure what above means here, but the lruLock is in SegmentedBoundedOffHeapDataContainer itself.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391732851", "createdAt": "2020-03-12T16:16:11Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -29,6 +30,8 @@ public void applyTo(BlockHound.Builder builder) {\n       // Block designates methods that should only hold a lock very briefly\n       {\n          CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, OffHeapConcurrentMap.class);\n+         // This acquires the locks from the above OffHeapConcurrentMap instance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczMzMzMg==", "bodyText": "I suggest removing them if they don't need a description", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391733332", "createdAt": "2020-03-12T16:16:50Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "diffHunk": "@@ -55,19 +56,22 @@\n    private final Queue<LockPlaceHolder> pendingRequest;\n    private final ConcurrentMap<Object, LockPlaceHolder> lockOwners;\n    private final Runnable releaseRunnable;\n-   private final Executor executor;\n+   private final Executor blockingExecutor;\n+   private final Executor nonBlockingExecutor;\n    private TimeService timeService;\n    @SuppressWarnings(\"CanBeFinal\")\n    private volatile LockPlaceHolder current;\n \n    /**\n     * Creates a new instance.\n     *\n-    * @param executor\n+    * @param blockingExecutor\n+    * @param nonBlockingExecutor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczOTI3Ng==", "bodyText": "This should be in a separate commit for ISPN-11295.\nAlso, I would expect no blocking in the vast majority of cases, so we need an optimized path for that case and/or a PerfAck test to see if the extra thread switching affects performance.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391739276", "createdAt": "2020-03-12T16:25:51Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/InfinispanLock.java", "diffHunk": "@@ -412,13 +418,13 @@ public InvocationStage toInvocationStage(Supplier<TimeoutException> timeoutSuppl\n             return checkState(notifier.getNow(lockState), InvocationStage::completedNullStage,\n                   ExceptionSyncInvocationStage::new, timeoutSupplier);\n          }\n-         return new SimpleAsyncInvocationStage(notifier.thenApplyAsync(state -> {\n+         return new SimpleAsyncInvocationStage(CompletionStages.continueOnExecutor(notifier.thenApplyAsync(state -> {\n             Object rv = checkState(state, () -> null, throwable -> throwable, timeoutSupplier);\n             if (rv != null) {\n                throw (RuntimeException) rv;\n             }\n             return null;\n-         }, executor));\n+         }, blockingExecutor), nonBlockingExecutor, this));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc0MTU3MQ==", "bodyText": "I'd use field injection instead.\nlock.setTimeService(timeService) looks like it might be useful, but because there is no synchronization there's always a chance of missing one of the locks, so I'd remove that and force tests to replace the time service ahead of time.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391741571", "createdAt": "2020-03-12T16:29:02Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/PerKeyLockContainer.java", "diffHunk": "@@ -26,16 +26,19 @@\n \n    private static final int INITIAL_CAPACITY = 32;\n    private final ConcurrentMap<Object, InfinispanLock> lockMap;\n-   private Executor executor;\n+   private Executor blockingExecutor;\n+   private Executor nonBlockingExecutor;\n    private TimeService timeService;\n \n    public PerKeyLockContainer() {\n       lockMap = new ConcurrentHashMap<>(INITIAL_CAPACITY);\n    }\n \n    @Inject\n-   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor executor, TimeService timeService) {\n-      this.executor = executor;\n+   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor,\n+         @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor, TimeService timeService) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc1MDY0MA==", "bodyText": "We should set the executors on the other branch as well. Even though I'd rather avoid that other branch completely, there's too much code in the tests that relies on replacing components after startup.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391750640", "createdAt": "2020-03-12T16:43:25Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/StripedLockContainer.java", "diffHunk": "@@ -34,10 +34,11 @@ public StripedLockContainer(int concurrencyLevel) {\n    }\n \n    @Inject\n-   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor executor, TimeService timeService) {\n+   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor,\n+         @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor, TimeService timeService) {\n       for (int i = 0; i < sharedLocks.length; i++) {\n          if (sharedLocks[i] == null) {\n-            sharedLocks[i] = new InfinispanLock(executor, timeService);\n+            sharedLocks[i] = new InfinispanLock(blockingExecutor, nonBlockingExecutor, timeService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc1MTE4MA==", "bodyText": "Please use AbstractInfinispanTest.testExecutor() in the tests, with the common pool it's impossible to filter logs by test.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391751180", "createdAt": "2020-03-12T16:44:12Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/lock/InfinispanLockTest.java", "diffHunk": "@@ -41,7 +41,7 @@ public void testTimeout() throws InterruptedException {\n       final String lockOwner1 = \"LO1\";\n       final String lockOwner2 = \"LO2\";\n \n-      final InfinispanLock lock = new InfinispanLock(commonPool(), AbstractCacheTest.TIME_SERVICE);\n+      final InfinispanLock lock = new InfinispanLock(commonPool(), commonPool(), AbstractCacheTest.TIME_SERVICE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc1Mjg1Ng==", "bodyText": "I'm a bit scared that none of these tests need the executor, it suggests that maybe they don't cover all the code paths ;)", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r391752856", "createdAt": "2020-03-12T16:46:43Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/lock/LockContainerTest.java", "diffHunk": "@@ -32,29 +30,28 @@\n  */\n @Test(groups = \"unit\", testName = \"lock.LockContainerTest\")\n public class LockContainerTest extends AbstractInfinispanTest {\n-   private final ExecutorService executor = new WithinThreadExecutor();\n \n    public void testSingleLockWithPerEntry() throws InterruptedException {\n       PerKeyLockContainer lockContainer = new PerKeyLockContainer();\n-      TestingUtil.inject(lockContainer, executor, AbstractCacheTest.TIME_SERVICE);\n+      TestingUtil.inject(lockContainer, AbstractCacheTest.TIME_SERVICE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "045051f6a94dbaf2e0ceb6843763b26199e49a04", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/045051f6a94dbaf2e0ceb6843763b26199e49a04", "committedDate": "2020-03-10T13:56:24Z", "message": "ISPN-11450 SegmentedBoundedOffHeapDataContainer#ensureSize should be marked as okay to be blocking"}, "afterCommit": {"oid": "43c4bb7f852eded598b92e9f8e851ef2e5de3336", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/43c4bb7f852eded598b92e9f8e851ef2e5de3336", "committedDate": "2020-03-12T18:16:02Z", "message": "ISPN-11295 InfinispanLock needs to block on a blocking thread but continue its operation on a non blocking thread"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MzYxNTk5", "url": "https://github.com/infinispan/infinispan/pull/8022#pullrequestreview-375361599", "createdAt": "2020-03-16T16:06:23Z", "commit": {"oid": "43c4bb7f852eded598b92e9f8e851ef2e5de3336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjowNjoyM1rOF27KVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjowNjoyM1rOF27KVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzEzNjcyNw==", "bodyText": "I'm starting to think figuring out why a lock isn't unlocked after a BasicComponentRegistry.rewire() is too hard, and tests almost never replace executors anyway, so the master version of the method is safer.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393136727", "createdAt": "2020-03-16T16:06:23Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/locks/impl/StripedLockContainer.java", "diffHunk": "@@ -34,13 +34,10 @@ public StripedLockContainer(int concurrencyLevel) {\n    }\n \n    @Inject\n-   void inject(@ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor executor, TimeService timeService) {\n+   void inject(@ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR) Executor nonBlockingExecutor,\n+         TimeService timeService) {\n       for (int i = 0; i < sharedLocks.length; i++) {\n-         if (sharedLocks[i] == null) {\n-            sharedLocks[i] = new InfinispanLock(executor, timeService);\n-         } else {\n-            sharedLocks[i].setTimeService(timeService);\n-         }\n+         sharedLocks[i] = new InfinispanLock(nonBlockingExecutor, timeService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43c4bb7f852eded598b92e9f8e851ef2e5de3336"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43c4bb7f852eded598b92e9f8e851ef2e5de3336", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/43c4bb7f852eded598b92e9f8e851ef2e5de3336", "committedDate": "2020-03-12T18:16:02Z", "message": "ISPN-11295 InfinispanLock needs to block on a blocking thread but continue its operation on a non blocking thread"}, "afterCommit": {"oid": "f89c3397294b6ed808d84510a91bfc1072a7bd36", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/f89c3397294b6ed808d84510a91bfc1072a7bd36", "committedDate": "2020-03-16T16:09:16Z", "message": "ISPN-11295 InfinispanLock needs to block on a blocking thread but continue its operation on a non blocking thread"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MzY1NjQ5", "url": "https://github.com/infinispan/infinispan/pull/8022#pullrequestreview-375365649", "createdAt": "2020-03-16T16:10:49Z", "commit": {"oid": "f89c3397294b6ed808d84510a91bfc1072a7bd36"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2MTUwNDAx", "url": "https://github.com/infinispan/infinispan/pull/8022#pullrequestreview-376150401", "createdAt": "2020-03-17T15:34:44Z", "commit": {"oid": "b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTozNDo0NFrOF3hwjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNTo0MDoxN1rOF3iBVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc2OTEwMw==", "bodyText": "Not sure the comment belongs here", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393769103", "createdAt": "2020-03-17T15:34:44Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1384,25 +1388,42 @@ private long getMaxEntries() {\n       return Long.MAX_VALUE;\n    }\n \n-   private void preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n-      final Transaction transaction = suspendIfNeeded();\n-      boolean success = false;\n-      try {\n+   private Single<?> preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n+      // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n+      InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n+      CompletionStage<Object> stage;\n+      if (configuration.transaction().transactionMode().isTransactional() && transactionManager != null) {\n+         final Transaction transaction = suspendIfNeeded();\n+         CompletionStage<Transaction> putStage;\n          try {\n             beginIfNeeded();\n-            // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n-            InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n-            cache.put(me.getKey(), me.getValue(), metadata);\n-            success = true;\n+            putStage = cache.putAsync(me.getKey(), me.getValue(), metadata)\n+               .thenApply(ignore -> {\n+                  try {\n+                     return transactionManager.suspend();\n+                  } catch (SystemException e) {\n+                     throw new PersistenceException(\"Unable to preload!\", e);\n+                  }\n+               });\n          } catch (Exception e) {\n             throw new PersistenceException(\"Unable to preload!\", e);\n-         } finally {\n-            commitIfNeeded(success);\n          }\n-      } finally {\n-         //commitIfNeeded can throw an exception, so we need a try { } finally { }\n-         resumeIfNeeded(transaction);\n+         stage = (CompletionStage) putStage.whenCompleteAsync((pendingTransaction, t) -> {\n+            try {\n+               transactionManager.resume(pendingTransaction);\n+               commitIfNeeded(t == null);\n+            } catch (InvalidTransactionException | SystemException e) {\n+               throw new PersistenceException(\"Unable to preload!\", e);\n+            } finally {\n+               //commitIfNeeded can throw an exception, so we need a try { } finally { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc3MTEwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  CompletionStage<Object> stage;\n          \n          \n            \n                  CompletionStage<?> stage;", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393771103", "createdAt": "2020-03-17T15:37:22Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1384,25 +1388,42 @@ private long getMaxEntries() {\n       return Long.MAX_VALUE;\n    }\n \n-   private void preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n-      final Transaction transaction = suspendIfNeeded();\n-      boolean success = false;\n-      try {\n+   private Single<?> preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n+      // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n+      InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n+      CompletionStage<Object> stage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc3MzM5Nw==", "bodyText": "The return value isn't used, so completionStageToSingle() should work -- or there should be a comment explaining why the double conversion is needed.", "url": "https://github.com/infinispan/infinispan/pull/8022#discussion_r393773397", "createdAt": "2020-03-17T15:40:17Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1384,25 +1388,42 @@ private long getMaxEntries() {\n       return Long.MAX_VALUE;\n    }\n \n-   private void preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n-      final Transaction transaction = suspendIfNeeded();\n-      boolean success = false;\n-      try {\n+   private Single<?> preloadKey(AdvancedCache<Object, Object> cache, MarshallableEntry me) {\n+      // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n+      InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n+      CompletionStage<Object> stage;\n+      if (configuration.transaction().transactionMode().isTransactional() && transactionManager != null) {\n+         final Transaction transaction = suspendIfNeeded();\n+         CompletionStage<Transaction> putStage;\n          try {\n             beginIfNeeded();\n-            // CallInterceptor will preserve the timestamps if the metadata is an InternalMetadataImpl instance\n-            InternalMetadataImpl metadata = new InternalMetadataImpl(me.getMetadata(), me.created(), me.lastUsed());\n-            cache.put(me.getKey(), me.getValue(), metadata);\n-            success = true;\n+            putStage = cache.putAsync(me.getKey(), me.getValue(), metadata)\n+               .thenApply(ignore -> {\n+                  try {\n+                     return transactionManager.suspend();\n+                  } catch (SystemException e) {\n+                     throw new PersistenceException(\"Unable to preload!\", e);\n+                  }\n+               });\n          } catch (Exception e) {\n             throw new PersistenceException(\"Unable to preload!\", e);\n-         } finally {\n-            commitIfNeeded(success);\n          }\n-      } finally {\n-         //commitIfNeeded can throw an exception, so we need a try { } finally { }\n-         resumeIfNeeded(transaction);\n+         stage = (CompletionStage) putStage.whenCompleteAsync((pendingTransaction, t) -> {\n+            try {\n+               transactionManager.resume(pendingTransaction);\n+               commitIfNeeded(t == null);\n+            } catch (InvalidTransactionException | SystemException e) {\n+               throw new PersistenceException(\"Unable to preload!\", e);\n+            } finally {\n+               //commitIfNeeded can throw an exception, so we need a try { } finally { }\n+               resumeIfNeeded(transaction);\n+            }\n+         }, blockingExecutor);\n+      } else {\n+         stage = cache.putAsync(me.getKey(), me.getValue(), metadata);\n       }\n+      return RxJavaInterop.completionStageToMaybe(stage)\n+            .toSingle(me);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8"}, "originalPosition": 251}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "073217b78178065e54a85da679630624992173d5", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/073217b78178065e54a85da679630624992173d5", "committedDate": "2020-03-17T16:56:28Z", "message": "ISPN-11443 PersistenceManagerImpl thread checks need to be updated"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0863893a91e6ef21d4ac7b7bca9dd601b8060259", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/0863893a91e6ef21d4ac7b7bca9dd601b8060259", "committedDate": "2020-03-17T16:56:39Z", "message": "changed to concat map to prevent concurrency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50f0b25d42d0a7205e3bb1c3a8361686d5c6e253", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/50f0b25d42d0a7205e3bb1c3a8361686d5c6e253", "committedDate": "2020-03-17T16:56:39Z", "message": "ISPN-11450 SegmentedBoundedOffHeapDataContainer#ensureSize should be marked as okay to be blocking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11207859f4ba0b62e29d27ad535c2672c445fb32", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/11207859f4ba0b62e29d27ad535c2672c445fb32", "committedDate": "2020-03-17T16:56:39Z", "message": "ISPN-11295 InfinispanLock needs to block on a blocking thread but continue its operation on a non blocking thread"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/b8ef985cdebf93f77f9ccd0d366f9a3da3bf5ec8", "committedDate": "2020-03-17T12:51:58Z", "message": "changed to concat map to prevent concurrency"}, "afterCommit": {"oid": "11207859f4ba0b62e29d27ad535c2672c445fb32", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/11207859f4ba0b62e29d27ad535c2672c445fb32", "committedDate": "2020-03-17T16:56:39Z", "message": "ISPN-11295 InfinispanLock needs to block on a blocking thread but continue its operation on a non blocking thread"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1092, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}