{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NTczNTIw", "number": 8300, "title": "ISPN-10446 Protobuf resource", "bodyText": "CRUD\n Errors\n Docs\n\nhttps://issues.redhat.com/browse/ISPN-10446", "createdAt": "2020-05-09T13:08:55Z", "url": "https://github.com/infinispan/infinispan/pull/8300", "merged": true, "mergeCommit": {"oid": "8b026b49e12150453678e4c4e4894311ed66a2e2"}, "closed": true, "closedAt": "2020-05-19T19:21:06Z", "author": {"login": "karesti"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgXFh_gBqjMzMjQ5NjQwNTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABci3No5gBqjMzNTI3NDkwNjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4866979761d0a41cd8ed75d9411863327bdc98e8", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/4866979761d0a41cd8ed75d9411863327bdc98e8", "committedDate": "2020-05-09T13:08:12Z", "message": "ISPN-10446 Protobuf resource"}, "afterCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "committedDate": "2020-05-11T22:05:06Z", "message": "ISPN-10446 Protobuf Schema endpoint doc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5ODI1Njcz", "url": "https://github.com/infinispan/infinispan/pull/8300#pullrequestreview-409825673", "createdAt": "2020-05-12T08:42:44Z", "commit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODo0Mjo0NFrOGT8UDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToyMDozNFrOGT91aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NDMwMA==", "bodyText": "This lookup should be done in the constructor, as it does not depend on the request: we are always returning in the same format", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423564300", "createdAt": "2020-05-12T08:42:44Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODY4NQ==", "bodyText": "This should be non-blocking. I reckon it should be similar to \n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 221\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           return Flowable.fromIterable(cachesHealth.entrySet()) \n        \n    \n  \n\n or at least wrap it in an executor", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423568685", "createdAt": "2020-05-12T08:49:00Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzMyNQ==", "bodyText": "The REST server should return code 204 (HttpResponseStatus.NO_CONTENT) for POST without a response body", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423577325", "createdAt": "2020-05-12T09:01:58Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3Nzg1NA==", "bodyText": "No need to return a body if the validation is success: it should simply return code 204 (see above)", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423577854", "createdAt": "2020-05-12T09:02:50Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);\n+      return cache.putAsync(schemaName, contents.asString())\n+            .thenCompose(r -> cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX))\n+            .thenApply(validationError -> {\n+               String validation = \"success\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MDE1Mw==", "bodyText": "It'd be better to report errors in the same format as other resources. This is how query reports it:\n{\n    \"error\":{\n        \"message\":\"Invalid search request\",\n        \"cause\":\"org.infinispan.ParseException...\"\n    }\n}\nmessage is a user friendly description of the error and cause is the output of exception.stackTrace() where applicable.\nThere is already the class org.infinispan.query.remote.json.JsonQueryErrorResult for this format, I think we should move it to the rest module and reuse for non-query resources", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423580153", "createdAt": "2020-05-12T09:06:24Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);\n+      return cache.putAsync(schemaName, contents.asString())\n+            .thenCompose(r -> cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX))\n+            .thenApply(validationError -> {\n+               String validation = \"success\";\n+               if(validationError != null) {\n+                  validation = validationError.toString();\n+                  builder.status(HttpResponseStatus.BAD_REQUEST);\n+               }\n+               String json = String.format(\"{validation:%s}\", validation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MzcxMA==", "bodyText": "Nitpick: \"accept\" header is not used in PUT requests", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423583710", "createdAt": "2020-05-12T09:12:02Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.Test;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   public void getEmptySchemas() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(\"[ ]\", jsonNode.toPrettyString());\n+   }\n+\n+   @Test\n+   public void getNotFoundProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/error\")\n+            .content(new StringContentProvider(errorProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NDA3MA==", "bodyText": ".accept can be removed", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423584070", "createdAt": "2020-05-12T09:12:37Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.Test;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   public void getEmptySchemas() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(\"[ ]\", jsonNode.toPrettyString());\n+   }\n+\n+   @Test\n+   public void getNotFoundProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/error\")\n+            .content(new StringContentProvider(errorProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      String validation = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isBadRequest();\n+      ResponseAssertion.assertThat(response).hasReturnedText(\"{validation:\" + validation + \"}\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", validation);\n+   }\n+\n+   @Test\n+   public void crudCorrectProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NzQ1MQ==", "bodyText": "PUT and POST should have different behaviours:  POST will return CONFLICT if the entity with the same name already exists, while PUT will replace the entity. Take a look at how the CacheResource handles both methods:\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/BaseCacheResource.java\n    \n    \n         Line 82\n      in\n      6d78de6\n    \n    \n    \n    \n\n        \n          \n           CompletionStage<RestResponse> putValueToCache(RestRequest request) { \n        \n    \n  \n\n\nWe should either discern between the two verbs, or support just the PUT", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423587451", "createdAt": "2020-05-12T09:17:55Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4OTIyNw==", "bodyText": "I am conflicted between /v2/protobuf or /v2/schema for the REST endpoint path. WDYT @anistor?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423589227", "createdAt": "2020-05-12T09:20:34Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 49}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c", "committedDate": "2020-05-11T22:05:06Z", "message": "ISPN-10446 Protobuf Schema endpoint doc"}, "afterCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "committedDate": "2020-05-13T22:00:54Z", "message": "ISPN-10446 Protobuf Schema endpoint doc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNTY5NzQ3", "url": "https://github.com/infinispan/infinispan/pull/8300#pullrequestreview-411569747", "createdAt": "2020-05-14T08:19:49Z", "commit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoxOTo1MFrOGVRJcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoxOTo1MFrOGVRJcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA==", "bodyText": "@wburns this is not ok ?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424954224", "createdAt": "2020-05-14T08:19:50Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/5280cbfc7238abdbed852cd7cf8e9a80c824bbb8", "committedDate": "2020-05-13T22:00:54Z", "message": "ISPN-10446 Protobuf Schema endpoint doc"}, "afterCommit": {"oid": "e1840b65f3b8a36d580ed1b39f6b7b4df67ab906", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/e1840b65f3b8a36d580ed1b39f6b7b4df67ab906", "committedDate": "2020-05-14T08:25:39Z", "message": "ISPN-10446 Protobuf Schema Resource docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e1840b65f3b8a36d580ed1b39f6b7b4df67ab906", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/e1840b65f3b8a36d580ed1b39f6b7b4df67ab906", "committedDate": "2020-05-14T08:25:39Z", "message": "ISPN-10446 Protobuf Schema Resource docs"}, "afterCommit": {"oid": "f3fcdcae4b986f3179ef1336635cc43558d6d91f", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/f3fcdcae4b986f3179ef1336635cc43558d6d91f", "committedDate": "2020-05-15T08:22:57Z", "message": "ISPN-10446 Protobuf Schema Resource docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "73dc5b795b1d93ab0676e988dddba75abb1478dc", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/73dc5b795b1d93ab0676e988dddba75abb1478dc", "committedDate": "2020-05-15T12:22:04Z", "message": "Update ref_rest_protobuf.adoc\n\ndoc suggestions for ref_rest_protobuf.adoc"}, "afterCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/76cff2bac32cd828189959a2fa2caddd2b478589", "committedDate": "2020-05-15T14:00:45Z", "message": "ISPN-10446 Protobuf Schema Resource docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyODEwNzM0", "url": "https://github.com/infinispan/infinispan/pull/8300#pullrequestreview-412810734", "createdAt": "2020-05-15T16:50:24Z", "commit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyODIzOTQ4", "url": "https://github.com/infinispan/infinispan/pull/8300#pullrequestreview-412823948", "createdAt": "2020-05-15T17:10:22Z", "commit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoxMDoyM1rOGWNIlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo1NTo0N1rOGWOilA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA==", "bodyText": "Not sure what \"adds the schema\" is here. Shouldn't it just return BAD_REQUEST?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425937044", "createdAt": "2020-05-15T17:10:23Z", "author": {"login": "wburns"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDAwNA==", "bodyText": "This section is duplicate of above?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425940004", "createdAt": "2020-05-15T17:16:07Z", "author": {"login": "wburns"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/protobuf/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a\n+protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/protobuf/{schemaName}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDM0Mw==", "bodyText": "There seems to be a lot of duplication in this doc. Or maybe I am missing something?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425940343", "createdAt": "2020-05-15T17:16:48Z", "author": {"login": "wburns"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/protobuf/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a\n+protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_delete_protobuf']\n+= Deleting Protobuf Schemas\n+Remove Protobuf schemas from {brandname} clusters with `DELETE` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+DELETE /rest/v2/protobuf/{schemaName}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDY1NQ==", "bodyText": "Nitpick: extra spaces.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425940655", "createdAt": "2020-05-15T17:17:28Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MzUzNw==", "bodyText": "I find .collect(Collectors.toSet()) is more succinct.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425943537", "createdAt": "2020-05-15T17:23:28Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjEwNQ==", "bodyText": "This is another blocking call here. Unfortunately, the more I look at this it should really be done using BlockingManager#blockingPublisher on the Flowable.fromIterable(cache.entrySet()) and then doing non blocking calls aftwerds.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946105", "createdAt": "2020-05-15T17:28:25Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjM1OQ==", "bodyText": "It appears we are never using the value, so just cache.keySet() should be good.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946359", "createdAt": "2020-05-15T17:28:56Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjQ3OQ==", "bodyText": "This seems a bit odd that we are collecting into a Set to then sort and then collect it into a List. can we not just use http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html#sorted-java.util.Comparator- and then collect that into a List that is finally mapped to the response?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946479", "createdAt": "2020-05-15T17:29:11Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjU4OQ==", "bodyText": "Nitpick: extra spaces.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946589", "createdAt": "2020-05-15T17:29:24Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw==", "bodyText": "I am not sure how error handling is done on the rest side, but when returning a CompletionStage, I would normally expect this exception to be in the Stage.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946917", "createdAt": "2020-05-15T17:30:04Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzQyMQ==", "bodyText": "CompletableFutures.completedNull() instead.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425947421", "createdAt": "2020-05-15T17:31:02Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzU2MQ==", "bodyText": "Nitpick: spacing on if blocks are missing here and a few below.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425947561", "createdAt": "2020-05-15T17:31:21Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjE1Mg==", "bodyText": "Util.EMPTY_BYTE_ARRAY", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425952152", "createdAt": "2020-05-15T17:40:20Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA==", "bodyText": "Do we want to at least log the exception?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425952404", "createdAt": "2020-05-15T17:40:50Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw==", "bodyText": "Unfortunately this isn't quite a record class. Please make a constructor with final fields.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425953703", "createdAt": "2020-05-15T17:43:22Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NDEyMw==", "bodyText": "Same here re: final and constructor.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425954123", "createdAt": "2020-05-15T17:44:12Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {\n+      public String message;\n+      public String cause;\n+   }\n+   static class ProtoSchema {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ==", "bodyText": "Nitpick: Might as well put it on the line above to save some indention.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425959905", "createdAt": "2020-05-15T17:55:27Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MDA4NA==", "bodyText": "Or does Jackson not like that?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425960084", "createdAt": "2020-05-15T17:55:47Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 225}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "405fdd0c266bce1ad10bce99e0cc11ad0668f1ba", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/405fdd0c266bce1ad10bce99e0cc11ad0668f1ba", "committedDate": "2020-05-18T09:14:40Z", "message": "Update ref_rest_protobuf.adoc\n\nupdate to docs to remove duplication and apply feedback"}, "afterCommit": {"oid": "2fe5ecd91149890924a4f7dfe286a17608f9b185", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/2fe5ecd91149890924a4f7dfe286a17608f9b185", "committedDate": "2020-05-18T11:54:28Z", "message": "ISPN-10446 Protobuf Schema Resource docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fe5ecd91149890924a4f7dfe286a17608f9b185", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/2fe5ecd91149890924a4f7dfe286a17608f9b185", "committedDate": "2020-05-18T11:54:28Z", "message": "ISPN-10446 Protobuf Schema Resource docs"}, "afterCommit": {"oid": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "committedDate": "2020-05-18T12:12:58Z", "message": "ISPN-10446 Protobuf Schema Resource"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/c28e21067e37b189cc7afdf6fede99c4f9bf2a00", "committedDate": "2020-05-18T12:12:58Z", "message": "ISPN-10446 Protobuf Schema Resource"}, "afterCommit": {"oid": "84f7a2ae2908befdcf8d86ed2bec21f139fd06ed", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/84f7a2ae2908befdcf8d86ed2bec21f139fd06ed", "committedDate": "2020-05-18T12:25:42Z", "message": "ISPN-10446 Protobuf Schema Resource"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "84f7a2ae2908befdcf8d86ed2bec21f139fd06ed", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/84f7a2ae2908befdcf8d86ed2bec21f139fd06ed", "committedDate": "2020-05-18T12:25:42Z", "message": "ISPN-10446 Protobuf Schema Resource"}, "afterCommit": {"oid": "c1b6422ae172d82d06ee66cbc4d8027ede610440", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/c1b6422ae172d82d06ee66cbc4d8027ede610440", "committedDate": "2020-05-18T15:36:55Z", "message": "ISPN-10446 Protobuf Schema Resource"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzNzMwOTc3", "url": "https://github.com/infinispan/infinispan/pull/8300#pullrequestreview-413730977", "createdAt": "2020-05-18T15:58:35Z", "commit": {"oid": "c1b6422ae172d82d06ee66cbc4d8027ede610440"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTo1ODozNVrOGW9qGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTo1ODozNVrOGW9qGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMjA1OA==", "bodyText": "This is more like what I would expect. However you didn't fix the indentation on the following lines as they can all now be moved 3 spaces to the left. Or however IntelliJ says the formatter wants :)", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426732058", "createdAt": "2020-05-18T15:58:35Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+      return putSchema.thenCompose(r -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1b6422ae172d82d06ee66cbc4d8027ede610440"}, "originalPosition": 132}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c1b6422ae172d82d06ee66cbc4d8027ede610440", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/c1b6422ae172d82d06ee66cbc4d8027ede610440", "committedDate": "2020-05-18T15:36:55Z", "message": "ISPN-10446 Protobuf Schema Resource"}, "afterCommit": {"oid": "2f8f983aa6ed9ebc9be583903a7b0f292b4ce285", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/2f8f983aa6ed9ebc9be583903a7b0f292b4ce285", "committedDate": "2020-05-18T16:36:29Z", "message": "ISPN-10446 Protobuf Schema Resource"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f8f983aa6ed9ebc9be583903a7b0f292b4ce285", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/2f8f983aa6ed9ebc9be583903a7b0f292b4ce285", "committedDate": "2020-05-18T16:36:29Z", "message": "ISPN-10446 Protobuf Schema Resource"}, "afterCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "committedDate": "2020-05-18T16:46:15Z", "message": "ISPN-10446 Protobuf Schema Resource"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MTk1Mzkx", "url": "https://github.com/infinispan/infinispan/pull/8300#pullrequestreview-414195391", "createdAt": "2020-05-19T08:01:33Z", "commit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODowMTozM1rOGXUbVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODo0Mjo0MlrOGXWA5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNTEwOQ==", "bodyText": "PUT will not return CONFLICT: it will create if the schema does not exist or replace it otherwise", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427105109", "createdAt": "2020-05-19T08:01:33Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} stores the schema and returns the error in the response body.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/protobuf/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a\n+protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMzIwOQ==", "bodyText": "We need to rename this to /v2/schemas to conform with the other resources:\n/v2/counters/, /v2/caches/, /v2/tasks and so on.\n@oraNod also need to change all the doc references", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427113209", "createdAt": "2020-05-19T08:15:06Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA==", "bodyText": "This will cause a PUT for a totally new schema to return 404...\nPUT should create the schema if it does not exist or replace if it already exists.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427118544", "createdAt": "2020-05-19T08:23:35Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEzMTExMQ==", "bodyText": "In order to clarify a bit further on how schemas work, I suggest:\nIf the schema already exists, {brandname} returns `CONFLICT`. If the schema is not valid, either because of syntax errors, or because some of its dependencies are missing, {brandname} stores the schema and returns the error in the response body.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427131111", "createdAt": "2020-05-19T08:42:42Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} stores the schema and returns the error in the response body.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/c5a86f789fcfc4e127c7c6ff51afe9f69214f787", "committedDate": "2020-05-18T16:46:15Z", "message": "ISPN-10446 Protobuf Schema Resource"}, "afterCommit": {"oid": "97b1a46f3c2e3dc4354279def36838ff97bb58da", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/97b1a46f3c2e3dc4354279def36838ff97bb58da", "committedDate": "2020-05-19T10:02:52Z", "message": "ISPN-10446 Protobuf Schema Resource"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "97b1a46f3c2e3dc4354279def36838ff97bb58da", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/97b1a46f3c2e3dc4354279def36838ff97bb58da", "committedDate": "2020-05-19T10:02:52Z", "message": "ISPN-10446 Protobuf Schema Resource"}, "afterCommit": {"oid": "eecbb918fa56160b1f49d3d775065d8f27766f9a", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/eecbb918fa56160b1f49d3d775065d8f27766f9a", "committedDate": "2020-05-19T15:39:01Z", "message": "ISPN-10446 Protobuf Schema Resource"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eecbb918fa56160b1f49d3d775065d8f27766f9a", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/eecbb918fa56160b1f49d3d775065d8f27766f9a", "committedDate": "2020-05-19T15:39:01Z", "message": "ISPN-10446 Protobuf Schema Resource"}, "afterCommit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c", "committedDate": "2020-05-19T15:39:41Z", "message": "ISPN-10446 Protobuf Schema Resource"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NTg5Nzkw", "url": "https://github.com/infinispan/infinispan/pull/8300#pullrequestreview-414589790", "createdAt": "2020-05-19T15:53:31Z", "commit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1MzozMVrOGXnKEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1ODo1M1rOGXnZFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMTk4NA==", "bodyText": "Outdated", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427411984", "createdAt": "2020-05-19T15:53:31Z", "author": {"login": "danberindei"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,81 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/schemas/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`.\n+If the schema is not valid, either because of syntax errors, or because some of its dependencies are missing,\n+{brandname} stores the schema and returns the error in the response body.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/schemas/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/schemas/{schemaName}\n+----\n+\n+If the schema doesn't exist, {brandname} returns `NOT FOUND`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTgzMQ==", "bodyText": "Should change the name of this method (and updateNonExistingSchema) considering that PUT now means \"create or update\". I'd just replace update with put.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427415831", "createdAt": "2020-05-19T15:58:53Z", "author": {"login": "danberindei"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.security.auth.Subject;\n+import java.security.PrivilegedAction;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   @BeforeMethod(alwaysRun = true)\n+   @Override\n+   public void createBeforeMethod() {\n+      //Clear schema cache to avoid conflicts between methods\n+      Subject.doAs(ADMIN_USER, (PrivilegedAction<Void>) () -> {\n+         cacheManagers.get(0).getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME).clear();\n+         return null;\n+      });\n+   }\n+\n+   public void listSchemasWhenEmpty() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(0, jsonNode.size());\n+   }\n+\n+   @Test\n+   public void getNotExistingSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void updateNonExistingSchema() throws Exception {\n+      String person = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = updateSchema(\"person\", person);\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = addSchema(\"error\", errorProto);\n+\n+      String cause = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContent());\n+      assertEquals(\"error.proto\", jsonNode.get(\"name\").asText());\n+      assertEquals(\"Schema error.proto has errors\", jsonNode.get(\"error\").get(\"message\").asText());\n+      assertEquals(cause, jsonNode.get(\"error\").get(\"cause\").asText());\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/error\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"error.proto\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", cause);\n+   }\n+\n+   @Test\n+   public void crudSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      // Create\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(\"null\", jsonNode.get(\"error\").asText());\n+\n+      // Read\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/person.proto\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Update\n+      response = updateSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      // Delete\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.DELETE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void createTwiceSchema() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isConflicted();\n+   }\n+\n+   @Test\n+   public void addAndGetListOrderedByName() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      addSchema(\"users\", personProto);\n+      addSchema(\"people\", personProto);\n+      addSchema(\"dancers\", personProto);\n+\n+      String url = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      ContentResponse response = client.newRequest(url)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(3, jsonNode.size());\n+      assertEquals(\"dancers.proto\", jsonNode.get(0).get(\"name\").asText());\n+      assertEquals(\"people.proto\", jsonNode.get(1).get(\"name\").asText());\n+      assertEquals(\"users.proto\", jsonNode.get(2).get(\"name\").asText());\n+   }\n+\n+   private ContentResponse addSchema(String schemaName, String schemaContent)\n+         throws InterruptedException, TimeoutException, ExecutionException {\n+      return callAPI(schemaName, schemaContent, HttpMethod.POST);\n+   }\n+\n+   private ContentResponse updateSchema(String schemaName, String schemaContent)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c"}, "originalPosition": 184}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjA1MTM2", "url": "https://github.com/infinispan/infinispan/pull/8300#pullrequestreview-414605136", "createdAt": "2020-05-19T16:10:24Z", "commit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "committedDate": "2020-05-19T16:38:58Z", "message": "ISPN-10446 Protobuf Schema Resource"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c", "committedDate": "2020-05-19T15:39:41Z", "message": "ISPN-10446 Protobuf Schema Resource"}, "afterCommit": {"oid": "98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "author": {"user": {"login": "karesti", "name": "Katia Aresti"}}, "url": "https://github.com/infinispan/infinispan/commit/98a253cfb5a3e4d5f26835e50e462ccc9c296f81", "committedDate": "2020-05-19T16:38:58Z", "message": "ISPN-10446 Protobuf Schema Resource"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 742, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}