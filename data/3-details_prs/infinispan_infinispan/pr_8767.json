{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwODE3MDgz", "number": 8767, "title": "ISPN-10216 Implement bloom filter based near cache invalidations", "bodyText": "https://issues.redhat.com/browse/ISPN-10216", "createdAt": "2020-10-09T20:57:11Z", "url": "https://github.com/infinispan/infinispan/pull/8767", "merged": true, "mergeCommit": {"oid": "c30d5eec14e7877b8130ce0a01ec96f3ef26fcbd"}, "closed": true, "closedAt": "2020-11-09T21:38:13Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSOJ0WABqjM4NzMyNzA1OTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABda6cAYgBqjM5NzU1Nzc1NTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "133b13f9d45c674ee1b630bf39947e5233e0ea92", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/133b13f9d45c674ee1b630bf39947e5233e0ea92", "committedDate": "2020-10-09T20:48:00Z", "message": "ISPN-10216 Implement bloom filter based near cache invalidations"}, "afterCommit": {"oid": "a0566ab0dbd93513145e138cd7bbfe423999b7dd", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/a0566ab0dbd93513145e138cd7bbfe423999b7dd", "committedDate": "2020-10-13T19:57:09Z", "message": "ISPN-10216 Implement bloom filter based near cache invalidations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0566ab0dbd93513145e138cd7bbfe423999b7dd", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/a0566ab0dbd93513145e138cd7bbfe423999b7dd", "committedDate": "2020-10-13T19:57:09Z", "message": "ISPN-10216 Implement bloom filter based near cache invalidations"}, "afterCommit": {"oid": "92e7444f5eb4688719701072873d3014978818b6", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/92e7444f5eb4688719701072873d3014978818b6", "committedDate": "2020-10-21T15:49:41Z", "message": "ISPN-10216 Implement bloom filter based near cache invalidations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NTUyNzEz", "url": "https://github.com/infinispan/infinispan/pull/8767#pullrequestreview-515552713", "createdAt": "2020-10-23T10:47:03Z", "commit": {"oid": "92e7444f5eb4688719701072873d3014978818b6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxMDo0NzowM1rOHnIrJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxMDo0NzowM1rOHnIrJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5ODYzMA==", "bodyText": "aren't we giving up on protocol versions? I thought we no longer increment versions and just add new operations (and keep the old ones unchanged)", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r510798630", "createdAt": "2020-10-23T10:47:03Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/ProtocolVersion.java", "diffHunk": "@@ -35,10 +36,11 @@\n    PROTOCOL_VERSION_28(2, 8, new Codec28()),\n    PROTOCOL_VERSION_29(2, 9, new Codec29()),\n    PROTOCOL_VERSION_30(3, 0, new Codec30()),\n+   PROTOCOL_VERSION_31(3, 1, new Codec31()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e7444f5eb4688719701072873d3014978818b6"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92e7444f5eb4688719701072873d3014978818b6", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/92e7444f5eb4688719701072873d3014978818b6", "committedDate": "2020-10-21T15:49:41Z", "message": "ISPN-10216 Implement bloom filter based near cache invalidations"}, "afterCommit": {"oid": "4026f6553ea9b90d8bb7c53e7a6206ecf6222bc4", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/4026f6553ea9b90d8bb7c53e7a6206ecf6222bc4", "committedDate": "2020-10-23T15:50:33Z", "message": "ISPN-10216 Implement bloom filter based near cache invalidations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4026f6553ea9b90d8bb7c53e7a6206ecf6222bc4", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/4026f6553ea9b90d8bb7c53e7a6206ecf6222bc4", "committedDate": "2020-10-23T15:50:33Z", "message": "ISPN-10216 Implement bloom filter based near cache invalidations"}, "afterCommit": {"oid": "d5f7f9891b65948693a03bd3b48b830c3daa2770", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/d5f7f9891b65948693a03bd3b48b830c3daa2770", "committedDate": "2020-11-06T16:09:15Z", "message": "ISPN-10216 Implement bloom filter based near cache invalidations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2MzkxNDcz", "url": "https://github.com/infinispan/infinispan/pull/8767#pullrequestreview-526391473", "createdAt": "2020-11-09T15:49:25Z", "commit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNTo0OToyNVrOHv1F6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoyNTo0MVrOHv2wZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkxNDk4Nw==", "bodyText": "is maxEntries==0 a valid value?", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519914987", "createdAt": "2020-11-09T15:49:25Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/configuration/NearCacheConfigurationBuilder.java", "diffHunk": "@@ -71,19 +83,25 @@ public NearCacheConfigurationBuilder cacheNamePattern(Pattern pattern) {\n \n    @Override\n    public void validate() {\n-      if (mode.enabled() && maxEntries == null)\n-         throw HOTROD.nearCacheMaxEntriesUndefined();\n+      if (mode.enabled()) {\n+         if (maxEntries == null) {\n+            throw HOTROD.nearCacheMaxEntriesUndefined();\n+         } else if (maxEntries < 0 && bloomFilter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkyMTY5Mg==", "bodyText": "it is not clear to me where the SocketAddress is required.\nI noticed the signature change in org.infinispan.client.hotrod.event.impl.EventDispatcher#executeFailover() but I've never found any invocation that uses the SocketAddress (neither the Short for that matter... it could be Void)", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519921692", "createdAt": "2020-11-09T15:57:36Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/counter/impl/NotificationManager.java", "diffHunk": "@@ -108,13 +108,13 @@ private void removeListener(String counterName, HandleImpl<?> handle) {\n       });\n    }\n \n-   private CompletableFuture<Short> failover() {\n+   private CompletableFuture<SocketAddress> failover() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMDE3Mg==", "bodyText": "typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           // cache values upon a retry as we can't guarantee the bloom filter is updated on the serevr properly\n          \n          \n            \n                           // cache values upon a retry as we can't guarantee the bloom filter is updated on the server properly", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519930172", "createdAt": "2020-11-09T16:09:17Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/InvalidatedNearRemoteCache.java", "diffHunk": "@@ -42,21 +64,47 @@\n       return value.thenApply(v -> v != null ? v.getValue() : null);\n    }\n \n+   private int getCurrentVersion() {\n+      if (bloomFilterUpdateVersion != null) {\n+         return bloomFilterUpdateVersion.get();\n+      }\n+      return 0;\n+   }\n+\n    @Override\n    public CompletableFuture<MetadataValue<V>> getWithMetadataAsync(K key) {\n       MetadataValue<V> nearValue = nearcache.get(key);\n       if (nearValue == null) {\n          clientStatistics.incrementNearCacheMisses();\n-         CompletableFuture<MetadataValue<V>> remoteValue = super.getWithMetadataAsync(key);\n+         int prevVersion = getCurrentVersion();\n+         RetryAwareCompletionStage<MetadataValue<V>> remoteValue = super.getWithMetadataAsync(key, listenerAddress);\n          return remoteValue.thenApply(v -> {\n+            // We cannot cache the value if a retry was required - which means we did not talk to the listener node\n             if (v != null) {\n-               nearcache.putIfAbsent(key, v);\n-               if (v.getMaxIdle() > 0) {\n-                  HOTROD.nearCacheMaxIdleUnsupported();\n+               // If previous version is odd we can't cache as that means it was started during\n+               // a bloom filter update. We also can't cache if the new version doesn't match the prior\n+               // as it overlapped a bloom update.\n+               if ((prevVersion & 1) == 1 || prevVersion != getCurrentVersion()) {\n+                  if (trace) {\n+                     log.tracef(\"Unable to cache returned value for key %s as operation was performed during a\" +\n+                           \" bloom filter update\");\n+                  }\n+               }\n+               // Having a listener address means it has a bloom filter. When we have a bloom filter we cannot\n+               // cache values upon a retry as we can't guarantee the bloom filter is updated on the serevr properly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMzIxNw==", "bodyText": "unused", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519933217", "createdAt": "2020-11-09T16:13:27Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AddBloomNearCacheClientListenerOperation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package org.infinispan.client.hotrod.impl.operations;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.DataFormat;\n+import org.infinispan.client.hotrod.RemoteCacheManager;\n+import org.infinispan.client.hotrod.annotation.ClientListener;\n+import org.infinispan.client.hotrod.configuration.Configuration;\n+import org.infinispan.client.hotrod.event.impl.ClientEventDispatcher;\n+import org.infinispan.client.hotrod.event.impl.ClientListenerNotifier;\n+import org.infinispan.client.hotrod.impl.InternalRemoteCache;\n+import org.infinispan.client.hotrod.impl.protocol.Codec;\n+import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;\n+import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;\n+import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+/**\n+ * @author Galder Zamarre\u00f1o\n+ */\n+public class AddBloomNearCacheClientListenerOperation extends ClientListenerOperation {\n+\n+   private final int bloomFilterBits;\n+   private final InternalRemoteCache<?, ?> remoteCache;\n+\n+   protected AddBloomNearCacheClientListenerOperation(Codec codec, ChannelFactory channelFactory,\n+                                                      String cacheName, AtomicInteger topologyId, int flags, Configuration cfg,\n+                                                      ClientListenerNotifier listenerNotifier, Object listener,\n+                                                      DataFormat dataFormat,\n+                                                      int bloomFilterBits, InternalRemoteCache<?, ?> remoteCache) {\n+      this(codec, channelFactory, cacheName, topologyId, flags, cfg, generateListenerId(),\n+            listenerNotifier, listener, dataFormat, bloomFilterBits,\n+            remoteCache);\n+   }\n+\n+   private AddBloomNearCacheClientListenerOperation(Codec codec, ChannelFactory channelFactory,\n+                                                    String cacheName, AtomicInteger topologyId, int flags, Configuration cfg,\n+                                                    byte[] listenerId, ClientListenerNotifier listenerNotifier, Object listener,\n+                                                    DataFormat dataFormat,\n+                                                    int bloomFilterBits, InternalRemoteCache<?, ?> remoteCache) {\n+      super(ADD_BLOOM_FILTER_NEAR_CACHE_LISTENER_REQUEST, ADD_BLOOM_FILTER_NEAR_CACHE_LISTENER_RESPONSE, codec, channelFactory,\n+            RemoteCacheManager.cacheNameBytes(cacheName), topologyId, flags, cfg, listenerId, dataFormat, listener,\n+            cacheName, listenerNotifier);\n+      this.bloomFilterBits = bloomFilterBits;\n+      this.remoteCache = remoteCache;\n+   }\n+\n+   public AddBloomNearCacheClientListenerOperation copy() {\n+      return new AddBloomNearCacheClientListenerOperation(codec, channelFactory, cacheNameString, header.topologyId(), flags, cfg,\n+            listenerId, listenerNotifier, listener, dataFormat,\n+            bloomFilterBits, remoteCache);\n+   }\n+\n+   @Override\n+   protected void actualExecute(Channel channel) {\n+      ClientListener clientListener = extractClientListener();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzNDQ1Mg==", "bodyText": "unused", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519934452", "createdAt": "2020-11-09T16:15:07Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ClientListenerOperation.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.infinispan.client.hotrod.impl.operations;\n+\n+import static org.infinispan.client.hotrod.logging.Log.HOTROD;\n+\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.DataFormat;\n+import org.infinispan.client.hotrod.annotation.ClientListener;\n+import org.infinispan.client.hotrod.configuration.Configuration;\n+import org.infinispan.client.hotrod.event.impl.ClientListenerNotifier;\n+import org.infinispan.client.hotrod.impl.protocol.Codec;\n+import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;\n+import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;\n+import org.infinispan.client.hotrod.impl.transport.netty.ChannelRecord;\n+import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;\n+import org.infinispan.commons.util.ReflectionUtil;\n+import org.infinispan.commons.util.Util;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+public abstract class ClientListenerOperation extends RetryOnFailureOperation<SocketAddress> {\n+   public final byte[] listenerId;\n+   public final Object listener;\n+   protected final String cacheNameString;\n+   protected final ClientListenerNotifier listenerNotifier;\n+\n+   // Holds which address we are currently executing the operation on\n+   protected SocketAddress address;\n+\n+   protected ClientListenerOperation(short requestCode, short responseCode, Codec codec, ChannelFactory channelFactory,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzNzY0OQ==", "bodyText": "I would rather disable the bloom filter in org.infinispan.client.hotrod.RemoteCacheManager#createRemoteCache(java.lang.String) since you have access to the version than add a new method to the codec.", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519937649", "createdAt": "2020-11-09T16:19:37Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec20.java", "diffHunk": "@@ -87,6 +87,13 @@ public void writeExpirationParams(ByteBuf buf, long lifespan, TimeUnit lifespanT\n       ByteBufUtil.writeVInt(buf, maxIdleSeconds);\n    }\n \n+   @Override\n+   public void writeBloomFilter(ByteBuf buf, int bloomFilterBits) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0MTAzMA==", "bodyText": "nit: key's iterator would be enough.", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519941030", "createdAt": "2020-11-09T16:24:11Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/near/NearCache.java", "diffHunk": "@@ -1,13 +1,15 @@\n package org.infinispan.client.hotrod.near;\n \n+import java.util.Map;\n+\n import org.infinispan.client.hotrod.MetadataValue;\n \n /**\n  * Near cache contract.\n  *\n  * @since 7.1\n  */\n-public interface NearCache<K, V> {\n+public interface NearCache<K, V> extends Iterable<Map.Entry<K, MetadataValue<V>>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0MjI0NQ==", "bodyText": "could be cached in the constructor?", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519942245", "createdAt": "2020-11-09T16:25:41Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/near/NearCacheService.java", "diffHunk": "@@ -28,26 +38,62 @@\n \n    private final NearCacheConfiguration config;\n    private final ClientListenerNotifier listenerNotifier;\n+   private final AtomicInteger nearCacheRemovals = new AtomicInteger();\n    private Object listener;\n    private byte[] listenerId;\n    private NearCache<K, V> cache;\n    private Runnable invalidationCallback;\n+   private int bloomFilterBits = -1;\n+   private InternalRemoteCache<K, V> remote;\n+\n+   private SocketAddress listenerAddress;\n \n    protected NearCacheService(NearCacheConfiguration config, ClientListenerNotifier listenerNotifier) {\n       this.config = config;\n       this.listenerNotifier = listenerNotifier;\n    }\n \n-   public void start(RemoteCache<K, V> remote) {\n+   public SocketAddress start(InternalRemoteCache<K, V> remote) {\n       if (cache == null) {\n          // Create near cache\n-         cache = createNearCache(config);\n+         cache = createNearCache(config, this::entryRemovedFromNearCache);\n          // Add a listener that updates the near cache\n          listener = new InvalidatedNearCacheListener<>(this);\n-         remote.addClientListener(listener);\n+         int maxEntries = config.maxEntries();\n+         if (maxEntries > 0 && config.bloomFilter()) {\n+            bloomFilterBits = determineBloomFilterBits(maxEntries);\n+            listenerAddress = remote.addNearCacheListener(listener, bloomFilterBits);\n+         } else {\n+            remote.addClientListener(listener);\n+         }\n          // Get the listener ID for faster listener connected lookups\n          listenerId = listenerNotifier.findListenerId(listener);\n       }\n+      this.remote = remote;\n+      return listenerAddress;\n+   }\n+\n+   private static int determineBloomFilterBits(int maxEntries) {\n+      int bloomFilterBitScaler = Integer.parseInt(System.getProperty(\"infinispan.bloom-filter.bit-multiplier\", \"4\"));\n+      return maxEntries * bloomFilterBitScaler;\n+   }\n+\n+   void entryRemovedFromNearCache(K key, MetadataValue<V> value) {\n+      // We want to scale the update frequency of the bloom filter to be based on the number of max entries\n+      // This number along with default values of 3 hash algorithms and 4x bit size we end up with\n+      // between 14.689 and 16.573 percent hits per entry.\n+      int updateThreshold = config.maxEntries() / 16 + 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "537a49195ba31db035dc7e9f606f141fe5675b53", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/537a49195ba31db035dc7e9f606f141fe5675b53", "committedDate": "2020-11-09T20:04:14Z", "message": "ISPN-10216 Implement bloom filter based near cache invalidations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0aef505c7afc659d7ff2d223531baa4104bb42b6", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/0aef505c7afc659d7ff2d223531baa4104bb42b6", "committedDate": "2020-11-09T17:45:20Z", "message": "Pedro review comments"}, "afterCommit": {"oid": "537a49195ba31db035dc7e9f606f141fe5675b53", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/537a49195ba31db035dc7e9f606f141fe5675b53", "committedDate": "2020-11-09T20:04:14Z", "message": "ISPN-10216 Implement bloom filter based near cache invalidations"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 370, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}