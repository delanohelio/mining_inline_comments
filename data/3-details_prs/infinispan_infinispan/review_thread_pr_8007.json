{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTI5MDM2", "number": 8007, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTowOTo1MVrODslIBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozNzoyN1rODslzhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDcyMTk5OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/context/ServerInitialContextFactoryBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTowOTo1MVrOF9gYbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMTo0OToyOFrOF9l-tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAzNzk5OQ==", "bodyText": "AFAICT NAMED_OBJECTS is always empty.", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400037999", "createdAt": "2020-03-30T09:09:51Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/context/ServerInitialContextFactoryBuilder.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.infinispan.server.context;\n+\n+import java.io.Closeable;\n+import java.util.Hashtable;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.naming.spi.InitialContextFactory;\n+import javax.naming.spi.InitialContextFactoryBuilder;\n+\n+import org.infinispan.commons.util.Util;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class ServerInitialContextFactoryBuilder implements InitialContextFactoryBuilder, Closeable {\n+\n+   private final ConcurrentMap<String, Object> NAMED_OBJECTS;\n+\n+   public ServerInitialContextFactoryBuilder() {\n+      NAMED_OBJECTS = new ConcurrentHashMap<>();\n+   }\n+\n+   @Override\n+   public InitialContextFactory createInitialContextFactory(Hashtable<?, ?> environment) {\n+      return new ServerInitialContextFactory(NAMED_OBJECTS);\n+   }\n+\n+   @Override\n+   public void close() {\n+      // Closes any AutoCloseable objects stored in the context\n+      NAMED_OBJECTS.values().stream().filter(v -> v instanceof AutoCloseable).forEach(o -> Util.close((AutoCloseable) o));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afdae3a4784a062cfc7a103bdcee4f654feaaf98"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyOTcxNw==", "bodyText": "No, it will be filled by calls to ServerInitialContext.bind", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400129717", "createdAt": "2020-03-30T11:49:28Z", "author": {"login": "tristantarrant"}, "path": "server/runtime/src/main/java/org/infinispan/server/context/ServerInitialContextFactoryBuilder.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.infinispan.server.context;\n+\n+import java.io.Closeable;\n+import java.util.Hashtable;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import javax.naming.spi.InitialContextFactory;\n+import javax.naming.spi.InitialContextFactoryBuilder;\n+\n+import org.infinispan.commons.util.Util;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class ServerInitialContextFactoryBuilder implements InitialContextFactoryBuilder, Closeable {\n+\n+   private final ConcurrentMap<String, Object> NAMED_OBJECTS;\n+\n+   public ServerInitialContextFactoryBuilder() {\n+      NAMED_OBJECTS = new ConcurrentHashMap<>();\n+   }\n+\n+   @Override\n+   public InitialContextFactory createInitialContextFactory(Hashtable<?, ?> environment) {\n+      return new ServerInitialContextFactory(NAMED_OBJECTS);\n+   }\n+\n+   @Override\n+   public void close() {\n+      // Closes any AutoCloseable objects stored in the context\n+      NAMED_OBJECTS.values().stream().filter(v -> v instanceof AutoCloseable).forEach(o -> Util.close((AutoCloseable) o));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAzNzk5OQ=="}, "originalCommit": {"oid": "afdae3a4784a062cfc7a103bdcee4f654feaaf98"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDczNTk0OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/resources/schema/infinispan-server-11.0.xsd", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToxMzoxMVrOF9gg6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMTo0MzoxMlrOF9lxQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MDE2OQ==", "bodyText": "Why are the CDATA blocks required throughout when the content is just a String in most cases?", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400040169", "createdAt": "2020-03-30T09:13:11Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/resources/schema/infinispan-server-11.0.xsd", "diffHunk": "@@ -80,6 +82,146 @@\n       </xs:simpleContent>\n    </xs:complexType>\n \n+   <xs:complexType name=\"data-sources\">\n+      <xs:sequence>\n+         <xs:element type=\"tns:data-source\" name=\"data-source\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\n+      </xs:sequence>\n+   </xs:complexType>\n+\n+   <xs:complexType name=\"data-source\">\n+      <xs:all>\n+         <xs:element type=\"tns:data-source-connection-factory\" name=\"connection-factory\">\n+            <xs:annotation>\n+               <xs:documentation><![CDATA[ Configuration for the connection factory ]]></xs:documentation>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afdae3a4784a062cfc7a103bdcee4f654feaaf98"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyNjI3Mg==", "bodyText": "I copied those from the WildFly agroal subsystem XSD :)", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400126272", "createdAt": "2020-03-30T11:43:12Z", "author": {"login": "tristantarrant"}, "path": "server/runtime/src/main/resources/schema/infinispan-server-11.0.xsd", "diffHunk": "@@ -80,6 +82,146 @@\n       </xs:simpleContent>\n    </xs:complexType>\n \n+   <xs:complexType name=\"data-sources\">\n+      <xs:sequence>\n+         <xs:element type=\"tns:data-source\" name=\"data-source\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\n+      </xs:sequence>\n+   </xs:complexType>\n+\n+   <xs:complexType name=\"data-source\">\n+      <xs:all>\n+         <xs:element type=\"tns:data-source-connection-factory\" name=\"connection-factory\">\n+            <xs:annotation>\n+               <xs:documentation><![CDATA[ Configuration for the connection factory ]]></xs:documentation>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MDE2OQ=="}, "originalCommit": {"oid": "afdae3a4784a062cfc7a103bdcee4f654feaaf98"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDc0MTU1OnYy", "diffSide": "RIGHT", "path": "server/testdriver/core/src/main/java/org/infinispan/server/test/core/persistence/ContainerDatabase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToxNDozM1rOF9gkSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToxNDozM1rOF9gkSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MTAzNQ==", "bodyText": "Redundant empty line", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400041035", "createdAt": "2020-03-30T09:14:33Z", "author": {"login": "ryanemerson"}, "path": "server/testdriver/core/src/main/java/org/infinispan/server/test/core/persistence/ContainerDatabase.java", "diffHunk": "@@ -40,15 +46,31 @@\n    public void start() {\n       log.infof(\"Starting database %s\", getType());\n       container.start();\n+      String containerIpAddress = container.getContainerIpAddress();\n+      try {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afdae3a4784a062cfc7a103bdcee4f654feaaf98"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDc0NDk5OnYy", "diffSide": "RIGHT", "path": "server/testdriver/core/src/main/java/org/infinispan/server/test/core/proxy/SocketProxy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToxNTozMVrOF9gmoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToxNTozMVrOF9gmoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MTYzMw==", "bodyText": "\"map\" is redundant", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400041633", "createdAt": "2020-03-30T09:15:31Z", "author": {"login": "ryanemerson"}, "path": "server/testdriver/core/src/main/java/org/infinispan/server/test/core/proxy/SocketProxy.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.infinispan.server.test.core.proxy;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.commons.logging.Log;\n+import org.infinispan.commons.logging.LogFactory;\n+import org.infinispan.commons.util.Util;\n+\n+/**\n+ * A generic socket proxy. This is used to map overcome a design choice in testcontainers which doesn't allow mapping", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afdae3a4784a062cfc7a103bdcee4f654feaaf98"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDc1NzQyOnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/ManagedConnectionOperations.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToxODo0MFrOF9guYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwODowOTozNVrOF-KCpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MzYxOA==", "bodyText": "The following can be removed as they're just using the default values:\n\nfetchPersistentState\nignoreModifications\nignoreModifications\nshared", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400043618", "createdAt": "2020-03-30T09:18:40Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/ManagedConnectionOperations.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.junit4.DatabaseServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category(Persistence.class)\n+public class ManagedConnectionOperations {\n+\n+   @ClassRule\n+   public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+   @ClassRule\n+   public static DatabaseServerRule DATABASE = new DatabaseServerRule(SERVERS);\n+\n+   @Rule\n+   public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+   public ManagedConnectionOperations() {\n+      DATABASE.setDatabaseType(\"h2\");\n+   }\n+\n+   private org.infinispan.configuration.cache.ConfigurationBuilder createConfigurationBuilder() {\n+\n+      org.infinispan.configuration.cache.ConfigurationBuilder builder = new org.infinispan.configuration.cache.ConfigurationBuilder();\n+      builder.persistence().addStore(JdbcStringBasedStoreConfigurationBuilder.class)\n+            .fetchPersistentState(false)\n+            .ignoreModifications(false)\n+            .purgeOnStartup(false)\n+            .shared(false)\n+            .table()\n+            .dropOnExit(true)\n+            .createOnStart(true)\n+            .tableNamePrefix(\"TBL\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afdae3a4784a062cfc7a103bdcee4f654feaaf98"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcyMDU0OA==", "bodyText": "Done", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400720548", "createdAt": "2020-03-31T08:09:35Z", "author": {"login": "tristantarrant"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/ManagedConnectionOperations.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.junit4.DatabaseServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category(Persistence.class)\n+public class ManagedConnectionOperations {\n+\n+   @ClassRule\n+   public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+   @ClassRule\n+   public static DatabaseServerRule DATABASE = new DatabaseServerRule(SERVERS);\n+\n+   @Rule\n+   public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+   public ManagedConnectionOperations() {\n+      DATABASE.setDatabaseType(\"h2\");\n+   }\n+\n+   private org.infinispan.configuration.cache.ConfigurationBuilder createConfigurationBuilder() {\n+\n+      org.infinispan.configuration.cache.ConfigurationBuilder builder = new org.infinispan.configuration.cache.ConfigurationBuilder();\n+      builder.persistence().addStore(JdbcStringBasedStoreConfigurationBuilder.class)\n+            .fetchPersistentState(false)\n+            .ignoreModifications(false)\n+            .purgeOnStartup(false)\n+            .shared(false)\n+            .table()\n+            .dropOnExit(true)\n+            .createOnStart(true)\n+            .tableNamePrefix(\"TBL\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MzYxOA=="}, "originalCommit": {"oid": "afdae3a4784a062cfc7a103bdcee4f654feaaf98"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDc5MjEzOnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/configuration/DataSourceConfigurationBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToyNzoyN1rOF9hEQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToyNzoyN1rOF9hEQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0OTIxOA==", "bodyText": "Unused variable", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400049218", "createdAt": "2020-03-30T09:27:27Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/configuration/DataSourceConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.infinispan.server.configuration;\n+\n+import java.util.Map;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.commons.configuration.attributes.Attribute;\n+import org.infinispan.commons.configuration.attributes.AttributeSet;\n+\n+import io.agroal.api.configuration.AgroalConnectionFactoryConfiguration;\n+\n+public class DataSourceConfigurationBuilder implements Builder<DataSourceConfiguration> {\n+\n+   private final AttributeSet attributes;\n+   private final ServerConfigurationBuilder server;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7782c3a3bdb546f49c6ee94404e371ba2b7b7162"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDgwMTQzOnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/configuration/DataSourcesConfigurationBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToyOTozNFrOF9hJ5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOToyOTozNFrOF9hJ5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1MDY2MQ==", "bodyText": "final?", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400050661", "createdAt": "2020-03-30T09:29:34Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/configuration/DataSourcesConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.infinispan.server.configuration;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.commons.configuration.attributes.AttributeSet;\n+\n+public class DataSourcesConfigurationBuilder implements Builder<DataSourcesConfiguration> {\n+\n+   private final AttributeSet attributes;\n+   private final ServerConfigurationBuilder server;\n+\n+   private Map<String, DataSourceConfigurationBuilder> dataSources = new LinkedHashMap<>(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7782c3a3bdb546f49c6ee94404e371ba2b7b7162"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDgwNTk5OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/configuration/DataSourcesConfigurationBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozMDozNVrOF9hMhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozMDozNVrOF9hMhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1MTMzMg==", "bodyText": "Should we make the validate method a default no-op in the interface? Doesn't have to be in this PR.", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400051332", "createdAt": "2020-03-30T09:30:35Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/configuration/DataSourcesConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.infinispan.server.configuration;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.commons.configuration.attributes.AttributeSet;\n+\n+public class DataSourcesConfigurationBuilder implements Builder<DataSourcesConfiguration> {\n+\n+   private final AttributeSet attributes;\n+   private final ServerConfigurationBuilder server;\n+\n+   private Map<String, DataSourceConfigurationBuilder> dataSources = new LinkedHashMap<>(2);\n+\n+   DataSourcesConfigurationBuilder(ServerConfigurationBuilder server) {\n+      this.server = server;\n+      attributes = DataSourcesConfiguration.attributeDefinitionSet();\n+   }\n+\n+   DataSourceConfigurationBuilder dataSource(String name, String jndiName) {\n+      DataSourceConfigurationBuilder builder = new DataSourceConfigurationBuilder(server, name, jndiName);\n+      dataSources.put(name, builder);\n+      return builder;\n+   }\n+\n+   @Override\n+   public void validate() {\n+   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7782c3a3bdb546f49c6ee94404e371ba2b7b7162"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDgxODA1OnYy", "diffSide": "RIGHT", "path": "server/testdriver/core/src/main/java/org/infinispan/server/test/core/proxy/SocketProxy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozMzozMFrOF9hTug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozMzozMFrOF9hTug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1MzE3OA==", "bodyText": "Empty finally statement. I think this is redundant anyway as using try with resources.", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400053178", "createdAt": "2020-03-30T09:33:30Z", "author": {"login": "ryanemerson"}, "path": "server/testdriver/core/src/main/java/org/infinispan/server/test/core/proxy/SocketProxy.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.infinispan.server.test.core.proxy;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.commons.logging.Log;\n+import org.infinispan.commons.logging.LogFactory;\n+import org.infinispan.commons.util.Util;\n+\n+/**\n+ * A generic socket proxy. This is used to map overcome a design choice in testcontainers which doesn't allow mapping\n+ * container ports to a known port on the host (to avoid clashes).\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class SocketProxy implements AutoCloseable {\n+   static final Log log = LogFactory.getLog(SocketProxy.class);\n+   final InetAddress bindAddress;\n+   final int localPort;\n+   final InetAddress remoteAddress;\n+   final int remotePort;\n+   final CountDownLatch latch;\n+   private ServerSocket serverSocket;\n+\n+   public SocketProxy(InetAddress bindAddress, int localPort, InetAddress remoteAddress, int remotePort) {\n+      this.bindAddress = bindAddress;\n+      this.localPort = localPort;\n+      this.remoteAddress = remoteAddress;\n+      this.remotePort = remotePort;\n+      this.latch = new CountDownLatch(2);\n+      start();\n+   }\n+\n+   public void start() {\n+      try {\n+         serverSocket = new ServerSocket(localPort, 10, bindAddress);\n+         serverSocket.setSoTimeout(5000);\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+      new Thread(() -> {\n+         while (latch.getCount() > 1) {\n+            try {\n+               Socket localSocket = serverSocket.accept();\n+               // We have an incoming connection, let's establish a connection to the remote port\n+               Socket remoteSocket = new Socket(remoteAddress, remotePort);\n+               remoteSocket.setSoTimeout(20000);\n+\n+               new Thread(() -> {\n+                  // remote -> local\n+                  try (InputStream remoteSocketInputStream = remoteSocket.getInputStream(); OutputStream localSocketOutputStream = localSocket.getOutputStream()) {\n+                     log.debug(\"remote->local: opened\");\n+                     byte[] remoteBuffer = new byte[4096];\n+                     int remoteBytesRead;\n+                     while ((remoteBytesRead = remoteSocketInputStream.read(remoteBuffer)) != -1) {\n+                        localSocketOutputStream.write(remoteBuffer, 0, remoteBytesRead);\n+                        localSocketOutputStream.flush();\n+                        log.debugf(\"remote->local: transferred %d bytes\\n\", remoteBytesRead);\n+                     }\n+                  } catch (IOException e) {\n+                     log.error(\"remote->local\", e);\n+                  } finally {\n+                  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7782c3a3bdb546f49c6ee94404e371ba2b7b7162"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDgyMTMxOnYy", "diffSide": "RIGHT", "path": "server/testdriver/core/src/main/java/org/infinispan/server/test/core/proxy/SocketProxy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozNDoxNFrOF9hVrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozNDoxNFrOF9hVrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1MzY3OA==", "bodyText": "How about:\n// We have an incoming connection, let's establish a connection to the remote port\n            try(Socket localSocket = serverSocket.accept();\n                Socket remoteSocket = new Socket(remoteAddress, remotePort)) {", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400053678", "createdAt": "2020-03-30T09:34:14Z", "author": {"login": "ryanemerson"}, "path": "server/testdriver/core/src/main/java/org/infinispan/server/test/core/proxy/SocketProxy.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.infinispan.server.test.core.proxy;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.commons.logging.Log;\n+import org.infinispan.commons.logging.LogFactory;\n+import org.infinispan.commons.util.Util;\n+\n+/**\n+ * A generic socket proxy. This is used to map overcome a design choice in testcontainers which doesn't allow mapping\n+ * container ports to a known port on the host (to avoid clashes).\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class SocketProxy implements AutoCloseable {\n+   static final Log log = LogFactory.getLog(SocketProxy.class);\n+   final InetAddress bindAddress;\n+   final int localPort;\n+   final InetAddress remoteAddress;\n+   final int remotePort;\n+   final CountDownLatch latch;\n+   private ServerSocket serverSocket;\n+\n+   public SocketProxy(InetAddress bindAddress, int localPort, InetAddress remoteAddress, int remotePort) {\n+      this.bindAddress = bindAddress;\n+      this.localPort = localPort;\n+      this.remoteAddress = remoteAddress;\n+      this.remotePort = remotePort;\n+      this.latch = new CountDownLatch(2);\n+      start();\n+   }\n+\n+   public void start() {\n+      try {\n+         serverSocket = new ServerSocket(localPort, 10, bindAddress);\n+         serverSocket.setSoTimeout(5000);\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+      new Thread(() -> {\n+         while (latch.getCount() > 1) {\n+            try {\n+               Socket localSocket = serverSocket.accept();\n+               // We have an incoming connection, let's establish a connection to the remote port\n+               Socket remoteSocket = new Socket(remoteAddress, remotePort);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7782c3a3bdb546f49c6ee94404e371ba2b7b7162"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDgyNzUwOnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/datasource/DataSourceFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozNTo1NFrOF9hZeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozNTo1NFrOF9hZeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1NDY0OQ==", "bodyText": "factory::jdbcProperty", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400054649", "createdAt": "2020-03-30T09:35:54Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/datasource/DataSourceFactory.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.infinispan.server.datasource;\n+\n+import java.sql.SQLException;\n+import java.time.Duration;\n+\n+import javax.sql.DataSource;\n+\n+import org.infinispan.commons.util.ReflectionUtil;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.configuration.DataSourceConfiguration;\n+\n+import io.agroal.api.AgroalDataSource;\n+import io.agroal.api.configuration.supplier.AgroalConnectionFactoryConfigurationSupplier;\n+import io.agroal.api.configuration.supplier.AgroalConnectionPoolConfigurationSupplier;\n+import io.agroal.api.configuration.supplier.AgroalDataSourceConfigurationSupplier;\n+import io.agroal.api.security.NamePrincipal;\n+import io.agroal.api.security.SimplePassword;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class DataSourceFactory {\n+\n+   public static DataSource create(DataSourceConfiguration configuration) throws SQLException, ClassNotFoundException {\n+      AgroalConnectionFactoryConfigurationSupplier factory = new AgroalConnectionFactoryConfigurationSupplier();\n+      Class<?> driverClass = ReflectionUtil.getClassForName(configuration.driver(), Thread.currentThread().getContextClassLoader());\n+      factory.connectionProviderClass(driverClass)\n+            .jdbcTransactionIsolation(configuration.transactionIsolation())\n+            .jdbcUrl(configuration.url())\n+            .principal(new NamePrincipal(configuration.username()))\n+            .credential(new SimplePassword(configuration.password()))\n+            .initialSql(configuration.initialSql());\n+      configuration.connectionProperties().forEach((k, v) -> factory.jdbcProperty(k, v));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7782c3a3bdb546f49c6ee94404e371ba2b7b7162"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDgzMDYzOnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/configuration/DataSourceConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozNjo0OVrOF9hbbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozNjo0OVrOF9hbbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1NTE0OA==", "bodyText": "Defaults should be 0L", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400055148", "createdAt": "2020-03-30T09:36:49Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/configuration/DataSourceConfiguration.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package org.infinispan.server.configuration;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.infinispan.commons.configuration.ConfigurationInfo;\n+import org.infinispan.commons.configuration.attributes.AttributeDefinition;\n+import org.infinispan.commons.configuration.attributes.AttributeSet;\n+import org.infinispan.commons.configuration.elements.DefaultElementDefinition;\n+import org.infinispan.commons.configuration.elements.ElementDefinition;\n+\n+import io.agroal.api.configuration.AgroalConnectionFactoryConfiguration;\n+import io.agroal.api.configuration.AgroalConnectionFactoryConfiguration.TransactionIsolation;\n+\n+public class DataSourceConfiguration implements ConfigurationInfo {\n+\n+   static final AttributeDefinition<String> NAME = AttributeDefinition.builder(\"name\", null, String.class).build();\n+   static final AttributeDefinition<String> JNDI_NAME = AttributeDefinition.builder(\"jndiName\", null, String.class).build();\n+   static final AttributeDefinition<Boolean> STATISTICS = AttributeDefinition.builder(\"statistics\", false, Boolean.class).build();\n+\n+   static final AttributeDefinition<String> DRIVER = AttributeDefinition.builder(\"driver\", null, String.class).build();\n+   static final AttributeDefinition<String> URL = AttributeDefinition.builder(\"url\", null, String.class).build();\n+   static final AttributeDefinition<String> USERNAME = AttributeDefinition.builder(\"username\", null, String.class).build();\n+   static final AttributeDefinition<String> PASSWORD = AttributeDefinition.builder(\"password\", null, String.class).build();\n+   static final AttributeDefinition<String> INITIAL_SQL = AttributeDefinition.builder(\"initialSql\", null, String.class).build();\n+   static final AttributeDefinition<TransactionIsolation> TRANSACTION_ISOLATION = AttributeDefinition.builder(\"transactionIsolation\", TransactionIsolation.READ_COMMITTED, AgroalConnectionFactoryConfiguration.TransactionIsolation.class).build();\n+\n+   static final AttributeDefinition<Integer> MAX_SIZE = AttributeDefinition.builder(\"maxSize\", null, Integer.class).build();\n+   static final AttributeDefinition<Integer> MIN_SIZE = AttributeDefinition.builder(\"minSize\", 0, Integer.class).build();\n+   static final AttributeDefinition<Integer> INITIAL_SIZE = AttributeDefinition.builder(\"initialSize\", 0, Integer.class).build();\n+\n+   static final AttributeDefinition<Long> BLOCKING_TIMEOUT = AttributeDefinition.builder(\"blockingTimeout\", 0l, Long.class).build();\n+   static final AttributeDefinition<Long> BACKGROUND_VALIDATION = AttributeDefinition.builder(\"backgroundValidation\", 0l, Long.class).build();\n+   static final AttributeDefinition<Long> LEAK_DETECTION = AttributeDefinition.builder(\"leakDetection\", 0l, Long.class).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7782c3a3bdb546f49c6ee94404e371ba2b7b7162"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDgzMzMzOnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/configuration/ServerConfigurationParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozNzoyN1rOF9hdBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwOTozNzoyN1rOF9hdBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1NTU1OA==", "bodyText": "Doesn't do anything", "url": "https://github.com/infinispan/infinispan/pull/8007#discussion_r400055558", "createdAt": "2020-03-30T09:37:27Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/java/org/infinispan/server/configuration/ServerConfigurationParser.java", "diffHunk": "@@ -962,6 +968,138 @@ private void parseKerberos(XMLExtendedStreamReader reader, ServerIdentitiesConfi\n       }\n    }\n \n+   private void parseDataSources(XMLExtendedStreamReader reader, ServerConfigurationBuilder builder) throws XMLStreamException {\n+      DataSourcesConfigurationBuilder dataSources = builder.dataSources();\n+      while (reader.hasNext() && (reader.nextTag() != XMLStreamConstants.END_ELEMENT)) {\n+         Element element = Element.forName(reader.getLocalName());\n+         switch (element) {\n+            case DATA_SOURCE: {\n+               parseDataSource(reader, dataSources);\n+               break;\n+            }\n+            default:\n+               throw ParseUtils.unexpectedElement(reader);\n+         }\n+      }\n+   }\n+\n+   private void parseDataSource(XMLExtendedStreamReader reader, DataSourcesConfigurationBuilder dataSourcesBuilder) throws XMLStreamException {\n+      String[] attributes = ParseUtils.requireAttributes(reader, Attribute.NAME, Attribute.JNDI_NAME);\n+      String name = attributes[0];\n+      String jndiName = attributes[1];\n+      DataSourceConfigurationBuilder dataSourceBuilder = dataSourcesBuilder.dataSource(name, jndiName);\n+      for (int i = 0; i < reader.getAttributeCount(); i++) {\n+         ParseUtils.requireNoNamespaceAttribute(reader, i);\n+         String value = reader.getAttributeValue(i);\n+         Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n+         switch (attribute) {\n+            case JNDI_NAME:\n+            case NAME:\n+               // already parsed\n+               break;\n+            case STATISTICS:\n+               Boolean.parseBoolean(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7782c3a3bdb546f49c6ee94404e371ba2b7b7162"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4423, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}