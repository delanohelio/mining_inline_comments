{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA5MDY4MDE0", "number": 8809, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoyMjo1NVrOEzZ0dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzozMjozM1rOEzaD-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzM1ODYxOnYy", "diffSide": "RIGHT", "path": "query-core/src/main/java/org/infinispan/query/core/stats/SearchStatistics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoyMjo1NVrOHqmpTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoyMjo1NVrOHqmpTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzNTQwNw==", "bodyText": "Java docs", "url": "https://github.com/infinispan/infinispan/pull/8809#discussion_r514435407", "createdAt": "2020-10-29T17:22:55Z", "author": {"login": "karesti"}, "path": "query-core/src/main/java/org/infinispan/query/core/stats/SearchStatistics.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package org.infinispan.query.core.stats;\n+\n+/**\n+ * Exposes query and index statistics for a cache.\n+ *\n+ * @since 12.0\n+ */\n+public interface SearchStatistics {\n+\n+   QueryStatistics getQueryStatistics();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36b8a7b4577e73551ea4147d1d0269cb5c533ee"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzM3MTA0OnYy", "diffSide": "RIGHT", "path": "query-core/src/main/java/org/infinispan/query/core/stats/impl/SearchStatsRetriever.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoyNTo1MlrOHqmxPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoyNTo1MlrOHqmxPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzNzQzOQ==", "bodyText": "javadocs ?", "url": "https://github.com/infinispan/infinispan/pull/8809#discussion_r514437439", "createdAt": "2020-10-29T17:25:52Z", "author": {"login": "karesti"}, "path": "query-core/src/main/java/org/infinispan/query/core/stats/impl/SearchStatsRetriever.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package org.infinispan.query.core.stats.impl;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.query.core.stats.SearchStatistics;\n+\n+/**\n+ * @since 12.0\n+ */\n+public interface SearchStatsRetriever {\n+\n+   SearchStatistics getSearchStatistics();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36b8a7b4577e73551ea4147d1d0269cb5c533ee"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzM3NjMxOnYy", "diffSide": "RIGHT", "path": "query-core/src/test/java/org/infinispan/query/core/stats/impl/LocalQueryStatisticsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoyNzoxMFrOHqm0jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoyNzoxMFrOHqm0jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzODI4Ng==", "bodyText": "delete comment", "url": "https://github.com/infinispan/infinispan/pull/8809#discussion_r514438286", "createdAt": "2020-10-29T17:27:10Z", "author": {"login": "karesti"}, "path": "query-core/src/test/java/org/infinispan/query/core/stats/impl/LocalQueryStatisticsTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.infinispan.query.core.stats.impl;\n+\n+import static org.infinispan.query.core.stats.impl.LocalQueryStatisticsTest.QueryType.HYBRID;\n+import static org.infinispan.query.core.stats.impl.LocalQueryStatisticsTest.QueryType.INDEX_DISTRIBUTED;\n+import static org.infinispan.query.core.stats.impl.LocalQueryStatisticsTest.QueryType.INDEX_LOCAL;\n+import static org.infinispan.query.core.stats.impl.LocalQueryStatisticsTest.QueryType.NON_INDEXED;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Random;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import org.testng.annotations.Test;\n+\n+@Test(groups = \"unit\", testName = \"query.core.impl.LocalQueryStatisticsTest\")\n+public class LocalQueryStatisticsTest {\n+\n+   public static final int THREADS = 10;\n+   public static final int MAX_SAMPLE_LATENCY = 10_000;\n+   public static final int SAMPLE_SIZE = 1_000_000;\n+   private static final Random RANDOM = new Random(0);\n+\n+   enum QueryType {INDEX_LOCAL, INDEX_DISTRIBUTED, HYBRID, NON_INDEXED}\n+\n+   private final Map<Query, Long> timePerQuery = LongStream.rangeClosed(1, SAMPLE_SIZE).boxed()\n+         .collect(Collectors.toMap(Query::random, l -> (long) RANDOM.nextInt(MAX_SAMPLE_LATENCY)));\n+\n+   @Test\n+   public void testRecord() throws Exception {\n+      LocalQueryStatistics statistics = new LocalQueryStatistics();\n+      ExecutorService executorService = Executors.newFixedThreadPool(THREADS);\n+\n+      BlockingQueue<Entry<Query, Long>> data = new LinkedBlockingDeque<>(timePerQuery.entrySet());\n+\n+      CountDownLatch countDownLatch = new CountDownLatch(1);\n+      for (int i = 1; i <= THREADS; i++) {\n+         executorService.submit(() -> {\n+            try {\n+               countDownLatch.await();\n+               while (!data.isEmpty()) {\n+                  Entry<Query, Long> take = data.poll(1, TimeUnit.SECONDS);\n+                  if (take == null) continue;\n+                  Query q = take.getKey();\n+                  Long time = take.getValue();\n+                  switch (q.getType()) {\n+                     case INDEX_LOCAL:\n+                        statistics.localIndexedQueryExecuted(q.str, time);\n+                        break;\n+                     case HYBRID:\n+                        statistics.hybridQueryExecuted(q.str, time);\n+                        break;\n+                     case INDEX_DISTRIBUTED:\n+                        statistics.distributedIndexedQueryExecuted(q.str, time);\n+                        break;\n+                     case NON_INDEXED:\n+                        statistics.nonIndexedQueryExecuted(q.str, time);\n+                        break;\n+                  }\n+                  statistics.entityLoaded(time / 2);\n+               }\n+            } catch (InterruptedException ignored) {\n+            }\n+         });\n+      }\n+      countDownLatch.countDown();\n+      executorService.shutdown();\n+      executorService.awaitTermination(30, TimeUnit.SECONDS);\n+\n+      assertEquals(count(INDEX_LOCAL), statistics.getLocalIndexedQueryCount());\n+      assertEquals(avg(INDEX_LOCAL), statistics.getLocalIndexedQueryAvgTime());\n+      assertEquals(max(INDEX_LOCAL), statistics.getLocalIndexedQueryMaxTime());\n+      assertEquals(slowestQuery(INDEX_LOCAL), statistics.getSlowestLocalIndexedQuery());\n+\n+      assertEquals(count(INDEX_DISTRIBUTED), statistics.getDistributedIndexedQueryCount());\n+      assertEquals(avg(INDEX_DISTRIBUTED), statistics.getDistributedIndexedQueryAvgTime());\n+      assertEquals(max(INDEX_DISTRIBUTED), statistics.getLocalIndexedQueryMaxTime());\n+      assertEquals(slowestQuery(INDEX_DISTRIBUTED), statistics.getSlowestDistributedIndexedQuery());\n+\n+      assertEquals(count(HYBRID), statistics.getHybridQueryCount());\n+      assertEquals(avg(HYBRID), statistics.getHybridQueryAvgTime());\n+      assertEquals(max(HYBRID), statistics.getHybridQueryMaxTime());\n+      assertEquals(slowestQuery(HYBRID), statistics.getSlowestHybridQuery());\n+\n+      assertEquals(count(NON_INDEXED), statistics.getNonIndexedQueryCount());\n+      assertEquals(avg(NON_INDEXED), statistics.getNonIndexedQueryAvgTime());\n+      assertEquals(max(NON_INDEXED), statistics.getNonIndexedQueryMaxTime());\n+      assertEquals(slowestQuery(NON_INDEXED), statistics.getSlowestNonIndexedQuery());\n+\n+      assertEquals(SAMPLE_SIZE, statistics.getLoadCount());\n+//      assertEquals(loadAverage, statistics.getLoadAvgTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36b8a7b4577e73551ea4147d1d0269cb5c533ee"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMzM5ODMzOnYy", "diffSide": "RIGHT", "path": "server/rest/src/test/java/org/infinispan/rest/search/BaseRestSearchTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzozMjozM1rOHqnCZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNzo0OToxOVrOHrEROA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0MTgzMQ==", "bodyText": "why are we using these assertions stil? I think we can make use of assertThat assertions now\nbut i won't be stopping this pr to get merged for that", "url": "https://github.com/infinispan/infinispan/pull/8809#discussion_r514441831", "createdAt": "2020-10-29T17:32:33Z", "author": {"login": "karesti"}, "path": "server/rest/src/test/java/org/infinispan/rest/search/BaseRestSearchTest.java", "diffHunk": "@@ -342,14 +342,21 @@ public void testQueryStats() throws Exception {\n    }\n \n    @Test\n-   public void testIndexStats() throws Exception {\n+   public void testIndexStats() {\n       RestResponse response = join(cacheClient.indexStats());\n \n       if (!getConfigBuilder().indexing().enabled()) {\n          ResponseAssertion.assertThat(response).isBadRequest();\n       } else {\n          ResponseAssertion.assertThat(response).isOk();\n-         // TODO HSEARCH-3129 Restore support for statistics\n+         Json stats = Json.read(response.getBody());\n+         Json indexClassNames = stats.at(\"indexed_class_names\");\n+\n+         String indexName = \"org.infinispan.rest.search.entity.Person\";\n+         assertEquals(indexClassNames.at(0).asString(), indexName);\n+         assertNotNull(stats.at(\"indexed_entities_count\"));\n+         //TODO: Index sizes are not currently exposed (HSEARCH-4056)\n+         assertTrue(stats.at(\"index_sizes\").at(indexName).asInteger() >= 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b36b8a7b4577e73551ea4147d1d0269cb5c533ee"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkyMDc2MA==", "bodyText": "this was a code snipped that was deleted when Hibernate Search was migrated, I just put it back. Since this is all deprecated stuff, I won't bother changing it.", "url": "https://github.com/infinispan/infinispan/pull/8809#discussion_r514920760", "createdAt": "2020-10-30T07:49:19Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/test/java/org/infinispan/rest/search/BaseRestSearchTest.java", "diffHunk": "@@ -342,14 +342,21 @@ public void testQueryStats() throws Exception {\n    }\n \n    @Test\n-   public void testIndexStats() throws Exception {\n+   public void testIndexStats() {\n       RestResponse response = join(cacheClient.indexStats());\n \n       if (!getConfigBuilder().indexing().enabled()) {\n          ResponseAssertion.assertThat(response).isBadRequest();\n       } else {\n          ResponseAssertion.assertThat(response).isOk();\n-         // TODO HSEARCH-3129 Restore support for statistics\n+         Json stats = Json.read(response.getBody());\n+         Json indexClassNames = stats.at(\"indexed_class_names\");\n+\n+         String indexName = \"org.infinispan.rest.search.entity.Person\";\n+         assertEquals(indexClassNames.at(0).asString(), indexName);\n+         assertNotNull(stats.at(\"indexed_entities_count\"));\n+         //TODO: Index sizes are not currently exposed (HSEARCH-4056)\n+         assertTrue(stats.at(\"index_sizes\").at(indexName).asInteger() >= 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0MTgzMQ=="}, "originalCommit": {"oid": "b36b8a7b4577e73551ea4147d1d0269cb5c533ee"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3748, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}