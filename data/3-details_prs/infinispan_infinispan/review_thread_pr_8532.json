{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NTAzNDY2", "number": 8532, "reviewThreads": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNTo0MTozNlrOENUqgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozNDo0MlrOEYG9CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDA1NTA2OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "isResolved": false, "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNTo0MTozNlrOGv8NOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMDo1MVrOG1fQNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ==", "bodyText": "@param backup the bytes of the uploaded backup file. <= what is this exactly? is the full data in a single byte{]?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r452922681", "createdAt": "2020-07-10T15:41:36Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI0Mzg0OA==", "bodyText": "This should really be an InputStream or a ReadableByteChannel", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457243848", "createdAt": "2020-07-20T10:03:33Z", "author": {"login": "tristantarrant"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI0OTcwNw==", "bodyText": "Sorry I forgot to get back to your original comment Pedro.\nAgreed it shouldn't be byte[], I will update this in the interface. We do have a bigger issue at the moment though, which is AFAIK we can only receive the bytes from a RestRequest via ContentSource#rawContent() which returns a byte[]. As backups will most likely be large, we should support Streams for uploads/downloads with HTTP2, maybe with a fallback of chunked transfer encoding for HTTP/1.1\n\\cc @gustavonalle", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457249707", "createdAt": "2020-07-20T10:12:07Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA3ODk3OQ==", "bodyText": "Do we really need to send a giant amount of data to the server?  Can't you just accept a Path to a file somewhere?\nIf we really need it, it's a great opportunity to expand the REST framework to support a stream of data, using chunked transfer, as it'd be supported both for HTTP/1 and HTTP/2", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458078979", "createdAt": "2020-07-21T13:04:10Z", "author": {"login": "gustavonalle"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExNjg1MQ==", "bodyText": "Do we really need to send a giant amount of data to the server? Can't you just accept a Path to a file somewhere?\n\nHow do you get the file from the various clients to the server if you don't upload it? The idea is that this will work in Openshift and can be triggered via the Cli and eventually the console.\nWe could also add the option of the server importing the contents of a local backup file on server startup. In which case the server can pass a InputStream of the local file to the restore method.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458116851", "createdAt": "2020-07-21T13:56:53Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExOTcxMw==", "bodyText": "If we really need it, it's a great opportunity to expand the REST framework to support a stream of data, using chunked transfer, as it'd be supported both for HTTP/1 and HTTP/2\n\nMy understanding is that chunked transfer was removed in HTTP/2 https://en.wikipedia.org/wiki/Chunked_transfer_encoding.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458119713", "createdAt": "2020-07-21T14:00:30Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyMzg4Nw==", "bodyText": "Our REST server is using HTTP/1 tunnelled in HTTP/2 frames, so it should work.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458123887", "createdAt": "2020-07-21T14:06:14Z", "author": {"login": "gustavonalle"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEyNTE4Mw==", "bodyText": "How do you get the file from the various clients to the server if you don't upload it?\n\nI was just wondering 1 TB backups being sent through HTTP from the client to the server and got a bit worried :)", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458125183", "createdAt": "2020-07-21T14:07:57Z", "author": {"login": "gustavonalle"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE0MjgwNg==", "bodyText": "One question: the other way around, i.e., producing the backup, does it first create it on disk and then send it to the client? If so, maybe chunking is not the best but https://en.wikipedia.org/wiki/Byte_serving", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458142806", "createdAt": "2020-07-21T14:30:50Z", "author": {"login": "gustavonalle"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2NTY3OA==", "bodyText": "does it first create it on disk and then send it to the client\n\nYep. Currently this is a very simple implementation where it's stored as staging.zip, however if we take advantange of byte serving and assign an Id per backup request, we could allow for failed downloads to be resumed. Although we would probably need some form of garbage collection for backups whom's downloads never complete.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458165678", "createdAt": "2020-07-21T15:00:05Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2OTkyMA==", "bodyText": "ok, we can always revisit it later and change from chunked -> bytes", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458169920", "createdAt": "2020-07-21T15:05:46Z", "author": {"login": "gustavonalle"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczOTc2NA==", "bodyText": "I've created https://issues.redhat.com/browse/ISPN-12145 to track the implementation of chunked transfer encoding.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458739764", "createdAt": "2020-07-22T12:00:51Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/BackupManager.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package org.infinispan.server.core;\n+\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+\n+/**\n+ * Handles all tasks related to the creation/restoration of server backups.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@Scope(Scopes.GLOBAL)\n+public interface BackupManager {\n+   /**\n+    * Create a backup of all containers configured on the server.\n+    *\n+    * @return a {@link CompletionStage} that on completion returns the {@link Path} to the created backup file.\n+    */\n+   CompletionStage<Path> create();\n+\n+   /**\n+    * Restore container content from the provided backup bytes.\n+    *\n+    * @param backup the bytes of the uploaded backup file.\n+    * @return a {@link CompletionStage} that completes when all of the entries in the backup have been restored.\n+    */\n+   CompletionStage<Void> restore(byte[] backup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjkyMjY4MQ=="}, "originalCommit": {"oid": "870674768f73027512fec040a2cc52ec6d70ee6e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTM4OTEyOnYy", "diffSide": "RIGHT", "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestClusterClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzo1ODozM1rOG0ZNnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNzo1ODozM1rOG0ZNnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5MjIyMw==", "bodyText": "We should probably add at least minor documentation to these.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457592223", "createdAt": "2020-07-20T17:58:33Z", "author": {"login": "wburns"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestClusterClient.java", "diffHunk": "@@ -17,4 +18,8 @@\n     * Shuts down the specified servers\n     */\n    CompletionStage<RestResponse> stop(List<String> server);\n+\n+   CompletionStage<RestResponse> backup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTQ3MDY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODoyMTo1M1rOG0Z_-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwODo1OTo1M1rOG0uxCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNTExMw==", "bodyText": "This isn't quite true. We should invoke Runnable in a blocking thread if the stage is completed on a non blocking thread. Looking closer whenCompleteBlocking has the same problem, maybe we should log a JIRA to take care of that though. We really need to add a blocking executor that checks the invoking thread if it is blocking or not before submitting.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457605113", "createdAt": "2020-07-20T18:21:53Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -106,6 +106,21 @@\n    <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n          BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n \n+   /**\n+    * Replacement for {@link CompletionStage#thenRunAsync(Runnable)} that invokes the {@code Runnable} in a blocking thread\n+    * (if the current thread is non-blocking) or in the current thread (if the current thread is blocking).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0NTM1NQ==", "bodyText": "I definitely think this is a fix for a different PR. In this case I just used thenApplyBlocking as a basis of this implementation, so I assume that also has the same issue.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457945355", "createdAt": "2020-07-21T08:59:53Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -106,6 +106,21 @@\n    <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n          BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n \n+   /**\n+    * Replacement for {@link CompletionStage#thenRunAsync(Runnable)} that invokes the {@code Runnable} in a blocking thread\n+    * (if the current thread is non-blocking) or in the current thread (if the current thread is blocking).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNTExMw=="}, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTQ4NTExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODoyNjowNlrOG0aI7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODoyNjowNlrOG0aI7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNzQwNw==", "bodyText": "You can change all of this to just return stage.thenRun(runnable);", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457607407", "createdAt": "2020-07-20T18:26:06Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManagerImpl.java", "diffHunk": "@@ -187,6 +187,23 @@ protected void start() {\n       return continueOnNonBlockingThread(stage.thenApplyAsync(function, blockingExecutor), traceId);\n    }\n \n+   @Override\n+   public <I> CompletionStage<Void> thenRun(CompletionStage<? extends I> stage, Runnable runnable, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked thenRun on a blocking thread, joining %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            CompletionStages.join(stage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTcyMTI4OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxOTozNDoyNlrOG0cZsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxOTozNDoyNlrOG0cZsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY0NDQ2Nw==", "bodyText": "No need for this variable.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457644467", "createdAt": "2020-07-20T19:34:26Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupManagerImpl.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.WORKING_DIR;\n+\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class BackupManagerImpl implements BackupManager {\n+\n+   private static final Log log = LogFactory.getLog(BackupManagerImpl.class, Log.class);\n+\n+   private final AtomicBoolean backupInProgress = new AtomicBoolean();\n+   private final AtomicBoolean restoreInProgress = new AtomicBoolean();\n+\n+   final Path rootDir;\n+   final BackupReader reader;\n+   final BackupWriter writer;\n+   final BlockingManager blockingManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTc3MTAxOnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxOTo0OTowM1rOG0c4CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwOTozODoxMFrOG0wJmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1MjIzMw==", "bodyText": "I have never been a fan of doing stuff like this in a constructor. Maybe add a makeDirectories method to BackupManager?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457652233", "createdAt": "2020-07-20T19:49:03Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupManagerImpl.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.WORKING_DIR;\n+\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class BackupManagerImpl implements BackupManager {\n+\n+   private static final Log log = LogFactory.getLog(BackupManagerImpl.class, Log.class);\n+\n+   private final AtomicBoolean backupInProgress = new AtomicBoolean();\n+   private final AtomicBoolean restoreInProgress = new AtomicBoolean();\n+\n+   final Path rootDir;\n+   final BackupReader reader;\n+   final BackupWriter writer;\n+   final BlockingManager blockingManager;\n+   final Map<String, DefaultCacheManager> cacheManagers;\n+\n+   public BackupManagerImpl(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers,\n+                            Path dataRoot) {\n+      this.blockingManager = blockingManager;\n+      this.rootDir = dataRoot.resolve(WORKING_DIR);\n+      this.cacheManagers = cacheManagers;\n+      this.reader = new BackupReader(blockingManager, cacheManagers, rootDir);\n+      this.writer = new BackupWriter(blockingManager, cacheManagers, rootDir);\n+      rootDir.toFile().mkdir();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk2ODAyNg==", "bodyText": "Good catch. As the rootDir is provided via Server.java I have moved the creation there.\nI've add a BackupManager#init method that can be used for all resource initialisation.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457968026", "createdAt": "2020-07-21T09:38:10Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupManagerImpl.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.WORKING_DIR;\n+\n+import java.io.InputStream;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class BackupManagerImpl implements BackupManager {\n+\n+   private static final Log log = LogFactory.getLog(BackupManagerImpl.class, Log.class);\n+\n+   private final AtomicBoolean backupInProgress = new AtomicBoolean();\n+   private final AtomicBoolean restoreInProgress = new AtomicBoolean();\n+\n+   final Path rootDir;\n+   final BackupReader reader;\n+   final BackupWriter writer;\n+   final BlockingManager blockingManager;\n+   final Map<String, DefaultCacheManager> cacheManagers;\n+\n+   public BackupManagerImpl(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers,\n+                            Path dataRoot) {\n+      this.blockingManager = blockingManager;\n+      this.rootDir = dataRoot.resolve(WORKING_DIR);\n+      this.cacheManagers = cacheManagers;\n+      this.reader = new BackupReader(blockingManager, cacheManagers, rootDir);\n+      this.writer = new BackupWriter(blockingManager, cacheManagers, rootDir);\n+      rootDir.toFile().mkdir();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1MjIzMw=="}, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTgwMTIwOnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxOTo1ODoxMVrOG0dKgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwOTowNzo0NlrOG0vDQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1Njk2MA==", "bodyText": "Is there a reason this isn't in the same code block as below? Unfortunately this will hand off the processing to a non blocking thread which will then just hand back off to a different blocking thread. If instead it is just one lambda it won't do this handoff.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457656960", "createdAt": "2020-07-20T19:58:11Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupReader.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.STAGING_ZIP;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.logging.LogFactory;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for reading backup bytes and restoring the contents to the appropriate cache manager.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupReader {\n+\n+   private static final Log log = LogFactory.getLog(BackupReader.class, Log.class);\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+   private final Path rootDir;\n+\n+   public BackupReader(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+   }\n+\n+   CompletionStage<Void> restore(InputStream is, Map<String, BackupManager.ContainerResources> params) {\n+      final Path stagingFile = rootDir.resolve(STAGING_ZIP);\n+\n+      CompletionStage<Void> createStagingFile = blockingManager.runBlocking(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1MDAxOA==", "bodyText": "I was trying to make it more fine-grained, but after your explanation I can see that doesn't really make sense as the operations obviously depend on each other \ud83d\ude42", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457950018", "createdAt": "2020-07-21T09:07:46Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupReader.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.STAGING_ZIP;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.logging.LogFactory;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for reading backup bytes and restoring the contents to the appropriate cache manager.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupReader {\n+\n+   private static final Log log = LogFactory.getLog(BackupReader.class, Log.class);\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+   private final Path rootDir;\n+\n+   public BackupReader(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+   }\n+\n+   CompletionStage<Void> restore(InputStream is, Map<String, BackupManager.ContainerResources> params) {\n+      final Path stagingFile = rootDir.resolve(STAGING_ZIP);\n+\n+      CompletionStage<Void> createStagingFile = blockingManager.runBlocking(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1Njk2MA=="}, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTgwNjYyOnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxOTo1OTo1MlrOG0dOIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwOToxNjoxMFrOG0vWfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1Nzg5MQ==", "bodyText": "Same here, this should be able to just be one big blockingManager.thenSupply call which returns a CompletionStage and then use thenCompose to flatten it.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457657891", "createdAt": "2020-07-20T19:59:52Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupReader.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.STAGING_ZIP;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.logging.LogFactory;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for reading backup bytes and restoring the contents to the appropriate cache manager.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupReader {\n+\n+   private static final Log log = LogFactory.getLog(BackupReader.class, Log.class);\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+   private final Path rootDir;\n+\n+   public BackupReader(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+   }\n+\n+   CompletionStage<Void> restore(InputStream is, Map<String, BackupManager.ContainerResources> params) {\n+      final Path stagingFile = rootDir.resolve(STAGING_ZIP);\n+\n+      CompletionStage<Void> createStagingFile = blockingManager.runBlocking(() -> {\n+         try {\n+            Files.copy(is, stagingFile);\n+         } catch (IOException e) {\n+            throw new CacheException(e);\n+         }\n+      }, \"create-staging\");\n+\n+      CompletionStage<?> processContainers = blockingManager.thenApplyBlocking(createStagingFile, Void -> {\n+         try (ZipFile zip = new ZipFile(stagingFile.toFile())) {\n+            Properties manifest = readManifestAndValidate(zip);\n+\n+            List<String> backupContainers = Arrays.asList(manifest.getProperty(CONTAINER_KEY).split(\",\"));\n+            Set<String> requestedContainers = new HashSet<>(params.keySet());\n+            requestedContainers.removeAll(backupContainers);\n+            if (!requestedContainers.isEmpty()) {\n+               throw log.unableToFindBackupResource(\"Containers\", requestedContainers);\n+            }\n+\n+            return CompletionStages.allOf(\n+                  params.entrySet().stream()\n+                        .map(e -> restoreContainer(e.getKey(), e.getValue(), zip))\n+                        .collect(Collectors.toList())\n+            );\n+         } catch (IOException e) {\n+            throw new CacheException(String.format(\"Unable to read zip file '%s'\", stagingFile));\n+         }\n+      }, \"read-manifest\");\n+\n+      return blockingManager.thenRun(processContainers, () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1NDk0MA==", "bodyText": "I have updated it to return processContainers.thenRun(() -> {...}); as we only require CompletionStage<Void>.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457954940", "createdAt": "2020-07-21T09:16:10Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupReader.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.STAGING_ZIP;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.logging.LogFactory;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.server.core.logging.Log;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for reading backup bytes and restoring the contents to the appropriate cache manager.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupReader {\n+\n+   private static final Log log = LogFactory.getLog(BackupReader.class, Log.class);\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+   private final Path rootDir;\n+\n+   public BackupReader(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+   }\n+\n+   CompletionStage<Void> restore(InputStream is, Map<String, BackupManager.ContainerResources> params) {\n+      final Path stagingFile = rootDir.resolve(STAGING_ZIP);\n+\n+      CompletionStage<Void> createStagingFile = blockingManager.runBlocking(() -> {\n+         try {\n+            Files.copy(is, stagingFile);\n+         } catch (IOException e) {\n+            throw new CacheException(e);\n+         }\n+      }, \"create-staging\");\n+\n+      CompletionStage<?> processContainers = blockingManager.thenApplyBlocking(createStagingFile, Void -> {\n+         try (ZipFile zip = new ZipFile(stagingFile.toFile())) {\n+            Properties manifest = readManifestAndValidate(zip);\n+\n+            List<String> backupContainers = Arrays.asList(manifest.getProperty(CONTAINER_KEY).split(\",\"));\n+            Set<String> requestedContainers = new HashSet<>(params.keySet());\n+            requestedContainers.removeAll(backupContainers);\n+            if (!requestedContainers.isEmpty()) {\n+               throw log.unableToFindBackupResource(\"Containers\", requestedContainers);\n+            }\n+\n+            return CompletionStages.allOf(\n+                  params.entrySet().stream()\n+                        .map(e -> restoreContainer(e.getKey(), e.getValue(), zip))\n+                        .collect(Collectors.toList())\n+            );\n+         } catch (IOException e) {\n+            throw new CacheException(String.format(\"Unable to read zip file '%s'\", stagingFile));\n+         }\n+      }, \"read-manifest\");\n+\n+      return blockingManager.thenRun(processContainers, () -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1Nzg5MQ=="}, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTg4MjY2OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupWriter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDoyMzo1M1rOG0d9pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwOToyODo1OFrOG0v0ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3MDA1NQ==", "bodyText": "Just use an AggregateCompletionStage instead of creating this list.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457670055", "createdAt": "2020-07-20T20:23:53Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupWriter.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.GLOBAL_CONFIG_FILE;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.configuration.global.GlobalConfiguration;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for creating backup files that can be used to restore a container/cache on a new cluster.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupWriter {\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+\n+   private final Path rootDir;\n+   private final ParserRegistry parserRegistry;\n+\n+   BackupWriter(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+      this.parserRegistry = new ParserRegistry();\n+   }\n+\n+   CompletionStage<Path> create(Map<String, BackupManager.ContainerResources> params) {\n+      List<CompletionStage<?>> stages = new ArrayList<>(params.size() + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1NjUzNQ==", "bodyText": "I completely forgot that existed \ud83d\ude42", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457956535", "createdAt": "2020-07-21T09:18:56Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupWriter.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.GLOBAL_CONFIG_FILE;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.configuration.global.GlobalConfiguration;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for creating backup files that can be used to restore a container/cache on a new cluster.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupWriter {\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+\n+   private final Path rootDir;\n+   private final ParserRegistry parserRegistry;\n+\n+   BackupWriter(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+      this.parserRegistry = new ParserRegistry();\n+   }\n+\n+   CompletionStage<Path> create(Map<String, BackupManager.ContainerResources> params) {\n+      List<CompletionStage<?>> stages = new ArrayList<>(params.size() + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3MDA1NQ=="}, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk2MjYxOQ==", "bodyText": "I have updated all instances that were previously using CompletionStages#allOf(Collection) and removed that static method.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457962619", "createdAt": "2020-07-21T09:28:58Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupWriter.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.GLOBAL_CONFIG_FILE;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.configuration.global.GlobalConfiguration;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for creating backup files that can be used to restore a container/cache on a new cluster.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupWriter {\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+\n+   private final Path rootDir;\n+   private final ParserRegistry parserRegistry;\n+\n+   BackupWriter(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+      this.parserRegistry = new ParserRegistry();\n+   }\n+\n+   CompletionStage<Path> create(Map<String, BackupManager.ContainerResources> params) {\n+      List<CompletionStage<?>> stages = new ArrayList<>(params.size() + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3MDA1NQ=="}, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTkwOTk4OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/ContainerResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDozMjoxMFrOG0eOOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDozMjoxMFrOG0eOOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3NDI5Ng==", "bodyText": "So should this method throw an exception when it isn't valid? I would expect the exception to be defined as being able to be thrown in the interface then.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457674296", "createdAt": "2020-07-20T20:32:10Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/ContainerResource.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package org.infinispan.server.core.backup;\n+\n+import java.util.Properties;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipFile;\n+\n+import org.infinispan.server.core.BackupManager;\n+\n+/**\n+ * An interface that defines how a {@link org.infinispan.server.core.BackupManager.ResourceType} is backed up and\n+ * restored by the {@link org.infinispan.server.core.BackupManager}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public interface ContainerResource {\n+\n+   /**\n+    * A method to ensure that the resources requested in the {@link BackupManager.ContainerResources}\n+    * are valid and can be included in a backup. This method is called for all {@link ContainerResource} implementations\n+    * before the backup process begins in order to allow a backup to fail-fast before any data is processed.\n+    */\n+   void prepareAndValidateBackup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTk5MTI0OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDo1NzowM1rOG0fAJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDo1NzowM1rOG0fAJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY4NzA3OA==", "bodyText": "We should be able to use an AggregateCompletionStage here as well.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r457687078", "createdAt": "2020-07-20T20:57:03Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/BackupWriter.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.server.core.backup;\n+\n+import static org.infinispan.server.core.backup.Constants.CONTAINERS_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.CONTAINER_KEY;\n+import static org.infinispan.server.core.backup.Constants.GLOBAL_CONFIG_FILE;\n+import static org.infinispan.server.core.backup.Constants.MANIFEST_PROPERTIES_FILE;\n+import static org.infinispan.server.core.backup.Constants.VERSION_KEY;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.util.Version;\n+import org.infinispan.configuration.global.GlobalConfiguration;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.server.core.backup.resources.ContainerResourceFactory;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+/**\n+ * Responsible for creating backup files that can be used to restore a container/cache on a new cluster.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+class BackupWriter {\n+\n+   private final BlockingManager blockingManager;\n+   private final Map<String, DefaultCacheManager> cacheManagers;\n+\n+   private final Path rootDir;\n+   private final ParserRegistry parserRegistry;\n+\n+   BackupWriter(BlockingManager blockingManager, Map<String, DefaultCacheManager> cacheManagers, Path rootDir) {\n+      this.blockingManager = blockingManager;\n+      this.cacheManagers = cacheManagers;\n+      this.rootDir = rootDir;\n+      this.parserRegistry = new ParserRegistry();\n+   }\n+\n+   CompletionStage<Path> create(Map<String, BackupManager.ContainerResources> params) {\n+      List<CompletionStage<?>> stages = new ArrayList<>(params.size() + 1);\n+      for (Map.Entry<String, BackupManager.ContainerResources> e : params.entrySet()) {\n+         String container = e.getKey();\n+         EmbeddedCacheManager cm = cacheManagers.get(container);\n+         stages.add(createBackup(container, cm, e.getValue()));\n+      }\n+\n+      stages.add(writeManifest(cacheManagers.keySet()));\n+      return blockingManager.thenApplyBlocking(CompletionStages.allOf(stages), Void -> createZip(), \"create\");\n+   }\n+\n+   /**\n+    * Create a backup of the specified container.\n+    *\n+    * @param containerName the name of container to backup.\n+    * @param cm            the container to backup.\n+    * @param params        the {@link BackupManager.ContainerResources} object that determines what resources are included in\n+    *                      the backup for this container.\n+    * @return a {@link CompletionStage} that completes once the backup has finished.\n+    */\n+   private CompletionStage<Void> createBackup(String containerName, EmbeddedCacheManager cm, BackupManager.ContainerResources params) {\n+      Path containerRoot = rootDir.resolve(CONTAINER_KEY).resolve(containerName);\n+      containerRoot.toFile().mkdirs();\n+      GlobalComponentRegistry gcr = cm.getGlobalComponentRegistry();\n+      BlockingManager blockingManager = gcr.getComponent(BlockingManager.class);\n+\n+      Collection<ContainerResource> resources = ContainerResourceFactory.getInstance()\n+            .getResources(params, blockingManager, cm, containerRoot);\n+\n+      // Prepare and ensure all requested resources are valid before starting the backup process\n+      resources.forEach(ContainerResource::prepareAndValidateBackup);\n+\n+      List<CompletionStage<?>> stages = resources.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350a0de8d92deed38601adbc2d869144da87502d"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1ODU4MDEzOnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/functional/ClusterBackupIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxMToxMVrOG03M3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxMToxMVrOG03M3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MzU1MA==", "bodyText": "Jackson databind is being killed, please avoid using it and use the internal mJson instead", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458083550", "createdAt": "2020-07-21T13:11:11Z", "author": {"login": "gustavonalle"}, "path": "server/tests/src/test/java/org/infinispan/server/functional/ClusterBackupIT.java", "diffHunk": "@@ -0,0 +1,186 @@\n+package org.infinispan.server.functional;\n+\n+import static org.infinispan.functional.FunctionalTestUtils.await;\n+import static org.infinispan.util.concurrent.CompletionStages.join;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Arrays;\n+\n+import org.infinispan.client.rest.RestCacheClient;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestCounterClient;\n+import org.infinispan.client.rest.RestEntity;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.RestTaskClient;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.counter.api.Storage;\n+import org.infinispan.counter.configuration.Element;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ArrayNode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82bd52a4ad5d4704767bed064483b437bf8f9391"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1ODU4OTYxOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ClusterResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxMzoyOVrOG03Szg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxMzoyOVrOG03Szg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4NTA3MA==", "bodyText": "Please add documentation in the REST API for those two methods", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r458085070", "createdAt": "2020-07-21T13:13:29Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ClusterResource.java", "diffHunk": "@@ -1,33 +1,52 @@\n package org.infinispan.rest.resources;\n \n+import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;\n import static io.netty.handler.codec.http.HttpResponseStatus.NO_CONTENT;\n+import static io.netty.handler.codec.http.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static java.util.concurrent.CompletableFuture.completedFuture;\n+import static org.infinispan.rest.framework.Method.GET;\n import static org.infinispan.rest.framework.Method.POST;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CompletionStage;\n \n+import org.infinispan.commons.dataconversion.MediaType;\n import org.infinispan.rest.InvocationHelper;\n import org.infinispan.rest.NettyRestResponse;\n import org.infinispan.rest.framework.ResourceHandler;\n import org.infinispan.rest.framework.RestRequest;\n import org.infinispan.rest.framework.RestResponse;\n import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.logging.Log;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.logging.LogFactory;\n \n /**\n  * @since 10.0\n  */\n public class ClusterResource implements ResourceHandler {\n+\n+   private final static Log LOG = LogFactory.getLog(ClusterResource.class, Log.class);\n+\n    private final InvocationHelper invocationHelper;\n+   private final BackupManager backupManager;\n \n    public ClusterResource(InvocationHelper invocationHelper) {\n       this.invocationHelper = invocationHelper;\n+      this.backupManager = invocationHelper.getServer().getBackupManager();\n    }\n \n    @Override\n    public Invocations getInvocations() {\n       return new Invocations.Builder()\n             .invocation().methods(POST).path(\"/v2/cluster\").withAction(\"stop\").handleWith(this::stop)\n+            .invocation().methods(GET).path(\"/v2/cluster\").withAction(\"backup\").handleWith(this::backup)\n+            .invocation().methods(POST).path(\"/v2/cluster\").withAction(\"restore\").handleWith(this::restore)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82bd52a4ad5d4704767bed064483b437bf8f9391"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjYzODQxOnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "isResolved": true, "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDowMzoxNlrOG2EBvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxMzowMToyOFrOG6HssA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ==", "bodyText": "@gustavonalle As a backup is non-idempotent does it make more sense for this to be a POST?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r459342271", "createdAt": "2020-07-23T10:03:16Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1MjI0NQ==", "bodyText": "Does it trigger a backup or simply re-downloads something that was already produced?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r459352245", "createdAt": "2020-07-23T10:23:13Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM1MzU2Ng==", "bodyText": "It always initiates a new backup and downloads the result.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r459353566", "createdAt": "2020-07-23T10:25:47Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2OTEwNQ==", "bodyText": "According to the newly recent changes we were required to do, everything with side-effect should be a POST.\nBut a POST downloading something is not \"RESTful\", and according to [1], there is a way to handle this: return a 201 code with a location header of the newly created resource or 202 if the resource was accepted but not ready.\n[1] https://tools.ietf.org/html/rfc7231#section-6.3.2\nI think we should make backup a proper resource:\n\nTrigger the backup with a certain name and return 202 (Accepted)\n\nPOST /rest/v2/cache-managers/{cacheManagerName}/backups/{backupName}\n\n\nGet the backup, returning it with 200 or 202 if it's not ready yet\n\nGET /rest/v2/cache-managers/{cacheManagerName}/backups/{backupName}\n\n\nDelete a certain backup\n\nDELETE /rest/v2/cache-managers/{cacheManagerName}/backups/{backupName}\n\n\nRestore a backup\n\nPOST /rest/v2/cache-managers/{cacheManagerName}/backups/{backupName}?action=restore", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r459369105", "createdAt": "2020-07-23T10:59:17Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM3NjA0OQ==", "bodyText": "I like this proposal a lot \ud83d\udc4d\nFor the CLI I can make it so that stages 1..3 appear as a single operation", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r459376049", "createdAt": "2020-07-23T11:15:01Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Mjk1OQ==", "bodyText": "Restore a backup\n\nPOST /rest/v2/cache-managers/{cacheManagerName}/backups/{backupName}?action=restore\n\n\nFor this I have added very basic support for multipart/form-data. This way the parameters used to filter the content from the backup file can be included as JSON as part of the payload, which will be flexible longer term than just utilising query params.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r462452959", "createdAt": "2020-07-29T17:06:32Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1ODY0Mw==", "bodyText": "If I am not mistaken, we haven't been using multipart/form-data, instead just use the JSON document as payload.\nFYI, this is how search handles it:\nPOST /rest/v2/caches/{cacheName}?action=search\n{\n \"query\":\"from Entity where name:\\\"user1\\\"\",\n \"max_results\":20,\n \"offset\":10\n}\nquery params are part of the document", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r462758643", "createdAt": "2020-07-30T06:16:17Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMTcyOA==", "bodyText": "The difference here is that we need to send both the application/json parameters and the application/zip backup file in a single request.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r462831728", "createdAt": "2020-07-30T08:22:19Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzNjk1NA==", "bodyText": "fair enough, I was imagining that backups wouldn't travel via HTTP, but rather be triggered, restored and deleted from a known folder only.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r462836954", "createdAt": "2020-07-30T08:31:09Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg0MDk4NA==", "bodyText": "Unfortunately I don't believe that approach is flexible enough for Openshift and restoring backups to rolled out clusters. We previously discussed this and ways we can improve performance going forward, but I think for the initial PR at least the important thing to focus on is the REST API and BackupManager internals.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r462840984", "createdAt": "2020-07-30T08:38:02Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg0NTczNQ==", "bodyText": "I am thinking the scenario for large datasets, say GBs (or TBs) of data.\nStarting the CLI from another continent pointing to the cluster, and asking a backup will be very slow. A restore would involve transferring that amount of data again, all via http.\nIf the CLI is run in the same network as the cluster, it wouldn't be so bad, but it would still be faster if the server writes the backup to a certain file, and restore from that same place, without the data passing through REST.\nAnother thing related to sizes, the rest server where the backup is triggered need to have space to hold the full cluster worth of data, otherwise it will have disk errors. The way I imagine backups working on cloud env is to attach a larger volume, with a certain proximity to the cluster, so this would imply the possibility for the user to choose the directory of destination.\nWDYT?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r462845735", "createdAt": "2020-07-30T08:45:58Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2MDAwMQ==", "bodyText": "The way I imagine backups working on cloud env is to attach a larger volume, with a certain proximity to the cluster, so this would imply the possibility for the user to choose the directory of destination.\n\nI agree, this is the way to go. For typical Infinispan deployments there is no need for a large volume, so it's too restrictive to assume that  a server's volume would have the capacity to store content spread across the cluster.\nI think that we should allow the following:\n\n\nAllow users to specify an optional path when creating a backup. This determines both the working-dir and final location of the created backup file. If no path is specified, then we utilise the current location ISPN_HOME/server/data/backup-manager/{backupName}/{backupName}.zip\n\n\nRestore via a path specified in the JSON payload. The file is processed from the locally available path with no file upload etc.\n\n\nRestore via upload. Allows smaller backups to be restored without attaching additional volumes and simple Console user experience, i.e. upload backup via browser form.\n\nUsers can optionally provide a custom working-dir path via JSON, if a larger volume is required for processing.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r462860001", "createdAt": "2020-07-30T09:09:50Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5NTM5NA==", "bodyText": "+1 for items 1), 2)\nStill in doubt about passing backups through HTTP though, but I am not ferociously against it \ud83d\ude04\nSo assuming we decide to add later the path reference based backups as described above (in a follow up PR), it'd be wise to avoid disruptions to the REST API. I suppose\nPOST /rest/v2/cache-managers/{cacheManagerName}/backups/{backupName}\n\nCan be used for both cases right? If the backup is not there, then it should have a reference for a path.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r462895394", "createdAt": "2020-07-30T10:13:48Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkxMTMyNA==", "bodyText": "So assuming we decide to add later the path reference based backups as described above (in a follow up PR), it'd be wise to avoid disruptions to the REST API. I suppose\n\nI'm actually making the changes atm and it doesn't alter things too much, so it should be Ok to make it into this PR.\n\nCan be used for both cases right? If the backup is not there, then it should have a reference for a path.\n\n\ud83d\udc4d I was thinking the JSON would be the following for referenced based backup and restore requests:\n{\n  \"backup-dir\": \"/some/path\",\n  \"resources\": {\n     \"caches\": \"[*]\"\n   }\n}\nThe Content-Type of the restore request determines what course of action is taken:\n\napplication/zip uploads the backup and processes all resource\napplication/json reference based restore, reading backups from backup-dir/{backupName}.zip and only processing resources in the \"resources\" object if specified.\nmultipart/form-data uploads the backup and processes the specified resources in the json. \"backup-dir\" still respected as the working directory if specified.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r462911324", "createdAt": "2020-07-30T10:46:02Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU5NjcyMA==", "bodyText": "Updated. I removed the option to upload via application/zip as netty allows files uploaded via multipart/form-data to be stored to disk, whereas that does not seem possible with application/zip. The latter is all that is required by html forms, so this shouldn't be an issue for the console.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r463596720", "createdAt": "2020-07-31T13:01:28Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_cache_managers.adoc", "diffHunk": "@@ -204,3 +204,112 @@ include::json_examples/rest_cache_stats_response.json[]\n * `current_number_of_entries_in_memory` shows the total number of entries currently in all caches, excluding passivated entries.\n * `hit_ratio` provides the total percentage hit/(hit+miss) ratio for all caches.\n * `retrievals` shows the total number of `get()` operations.\n+\n+[id='rest_v2_backup_manager']\n+= Backup {brandname} Cache Manager content\n+Download a backup file (application/zip) containing all resources (Caches, Cache configurations, Counters, Proto schemas, Scripts)\n+that are currently stored in the cache manager. The contents of the cluster backup file can then be restored\n+via the link:#rest_v2_restore_manager[restore] action.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/cache-managers/{cacheManagerName}?action=backup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MjI3MQ=="}, "originalCommit": {"oid": "c6b1e7bfba81442df11dcd327c276e245ac98e21"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMjg1NDY0OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDo1ODo0MlrOG-J8Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDo1ODo0MlrOG-J8Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgyNzc5NQ==", "bodyText": "The REST related changes LGTM!", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r467827795", "createdAt": "2020-08-10T10:58:42Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java", "diffHunk": "@@ -108,6 +111,11 @@ public Invocations getInvocations() {\n \n             // Caches\n             .invocation().methods(GET).path(\"/v2/cache-managers/{name}/caches\").handleWith(this::getCaches)\n+\n+            // BackupManager\n+            .invocation().methods(GET).path(\"/v2/cache-managers/{name}/backups\").handleWith(this::getAllBackupNames)\n+            .invocation().methods(DELETE, GET, HEAD, POST).path(\"/v2/cache-managers/{name}/backups/{backupName}\").handleWith(this::backup)\n+            .invocation().methods(POST).path(\"/v2/cache-managers/{name}/backups\").withAction(\"restore\").handleWith(this::restore)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzg3MjE5OnYy", "diffSide": "RIGHT", "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyNzo0M1rOG-TggQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyNzo0M1rOG-TggQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NDUxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Retrieve a backup file with the given name from the server.\n          \n          \n            \n                * Retrieves a backup file with the given name from the server.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r467984513", "createdAt": "2020-08-10T15:27:43Z", "author": {"login": "oraNod"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "diffHunk": "@@ -46,4 +49,74 @@\n    CompletionStage<RestResponse> cancelPushState(String backup);\n \n    CompletionStage<RestResponse> caches();\n+\n+   /**\n+    * Creates a backup file containing all resources in this container.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name) {\n+      return createBackup(name, null);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param resources a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                  list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name, Map<String, List<String>> resources) {\n+      return createBackup(name, null, resources);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param workingDir the path of the server directory to be used to create the backup content and store the final\n+    *                   backup file. A null value indicates that the server default should be used.\n+    * @param resources  a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                   list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources);\n+\n+   /**\n+    * Retrieve a backup file with the given name from the server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzg3MzAzOnYy", "diffSide": "RIGHT", "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyNzo1M1rOG-Tg9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyNzo1M1rOG-Tg9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NDYyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Delete a backup file from the server.\n          \n          \n            \n                * Deletes a backup file from the server.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r467984628", "createdAt": "2020-08-10T15:27:53Z", "author": {"login": "oraNod"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "diffHunk": "@@ -46,4 +49,74 @@\n    CompletionStage<RestResponse> cancelPushState(String backup);\n \n    CompletionStage<RestResponse> caches();\n+\n+   /**\n+    * Creates a backup file containing all resources in this container.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name) {\n+      return createBackup(name, null);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param resources a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                  list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name, Map<String, List<String>> resources) {\n+      return createBackup(name, null, resources);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param workingDir the path of the server directory to be used to create the backup content and store the final\n+    *                   backup file. A null value indicates that the server default should be used.\n+    * @param resources  a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                   list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources);\n+\n+   /**\n+    * Retrieve a backup file with the given name from the server.\n+    *\n+    * @param name     the name of the backup.\n+    * @param skipBody if true, then a HEAD request is issued to the server and only the HTTP headers are returned.\n+    */\n+   CompletionStage<RestResponse> getBackup(String name, boolean skipBody);\n+\n+   /**\n+    * Delete a backup file from the server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzg3OTMyOnYy", "diffSide": "RIGHT", "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestClusterClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyOToyNFrOG-Tk4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyOToyNFrOG-Tk4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NTYzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Retrieve a backup file with the given name from the server.\n          \n          \n            \n                * Retrieves a backup file with the given name from the server.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r467985633", "createdAt": "2020-08-10T15:29:24Z", "author": {"login": "oraNod"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestClusterClient.java", "diffHunk": "@@ -17,4 +18,41 @@\n     * Shuts down the specified servers\n     */\n    CompletionStage<RestResponse> stop(List<String> server);\n+\n+   /**\n+    * Creates a backup file containing the content of all containers in the cluster.\n+    *\n+    * @param name the name of the backup.\n+    */\n+   CompletionStage<RestResponse> createBackup(String name);\n+\n+   /**\n+    * Retrieve a backup file with the given name from the server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzg3OTgwOnYy", "diffSide": "RIGHT", "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestClusterClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyOTozMlrOG-TlLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNToyOTozMlrOG-TlLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NTcwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Delete a backup file from the server.\n          \n          \n            \n                * Deletes a backup file from the server.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r467985709", "createdAt": "2020-08-10T15:29:32Z", "author": {"login": "oraNod"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestClusterClient.java", "diffHunk": "@@ -17,4 +18,41 @@\n     * Shuts down the specified servers\n     */\n    CompletionStage<RestResponse> stop(List<String> server);\n+\n+   /**\n+    * Creates a backup file containing the content of all containers in the cluster.\n+    *\n+    * @param name the name of the backup.\n+    */\n+   CompletionStage<RestResponse> createBackup(String name);\n+\n+   /**\n+    * Retrieve a backup file with the given name from the server.\n+    *\n+    * @param name     the name of the backup.\n+    * @param skipBody if true, then a HEAD request is issued to the server and only the HTTP headers are returned.\n+    */\n+   CompletionStage<RestResponse> getBackup(String name, boolean skipBody);\n+\n+   /**\n+    * Delete a backup file from the server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3d4a897db3ee4133a93c1032fefa531fb3fc27f"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzMyNjA5OnYy", "diffSide": "RIGHT", "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODoyMToyMlrOG_tL7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODoyMToyMlrOG_tL7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1MzgwNw==", "bodyText": "We don't specify what null does here. I am guessing it means everything? I only ask one of the default methods passes it.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469453807", "createdAt": "2020-08-12T18:21:22Z", "author": {"login": "wburns"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "diffHunk": "@@ -46,4 +49,74 @@\n    CompletionStage<RestResponse> cancelPushState(String backup);\n \n    CompletionStage<RestResponse> caches();\n+\n+   /**\n+    * Creates a backup file containing all resources in this container.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name) {\n+      return createBackup(name, null);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param resources a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                  list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name, Map<String, List<String>> resources) {\n+      return createBackup(name, null, resources);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param workingDir the path of the server directory to be used to create the backup content and store the final\n+    *                   backup file. A null value indicates that the server default should be used.\n+    * @param resources  a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzMyNjY5OnYy", "diffSide": "RIGHT", "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODoyMTozMVrOG_tMQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODoyMTozMVrOG_tMQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1Mzg5MQ==", "bodyText": "Same about null here.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469453891", "createdAt": "2020-08-12T18:21:31Z", "author": {"login": "wburns"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/RestCacheManagerClient.java", "diffHunk": "@@ -46,4 +49,74 @@\n    CompletionStage<RestResponse> cancelPushState(String backup);\n \n    CompletionStage<RestResponse> caches();\n+\n+   /**\n+    * Creates a backup file containing all resources in this container.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name) {\n+      return createBackup(name, null);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param resources a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                  list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   default CompletionStage<RestResponse> createBackup(String name, Map<String, List<String>> resources) {\n+      return createBackup(name, null, resources);\n+   }\n+\n+   /**\n+    * Creates a backup file containing only the resources specified in the provided {@link Map}.\n+    *\n+    * @param workingDir the path of the server directory to be used to create the backup content and store the final\n+    *                   backup file. A null value indicates that the server default should be used.\n+    * @param resources  a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided\n+    *                   list only contains \"*\" then all available resources of that type are backed up.\n+    */\n+   CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources);\n+\n+   /**\n+    * Retrieves a backup file with the given name from the server.\n+    *\n+    * @param name     the name of the backup.\n+    * @param skipBody if true, then a HEAD request is issued to the server and only the HTTP headers are returned.\n+    */\n+   CompletionStage<RestResponse> getBackup(String name, boolean skipBody);\n+\n+   /**\n+    * Deletes a backup file from the server.\n+    *\n+    * @param name the name of the backup.\n+    */\n+   CompletionStage<RestResponse> deleteBackup(String name);\n+\n+   /**\n+    * Restores all content associated with this containers name contained within the provided backup file. The backup\n+    * file is uploaded via the server endpoint for processing, returning once the restoration has completed.\n+    *\n+    * @param backup the backup {@link File} containing the data to be restored.\n+    */\n+   default CompletionStage<RestResponse> restore(File backup) {\n+      return restore(backup, null);\n+   }\n+\n+   /**\n+    * Restores the specified content from the backup file that's associated with this container's name.\n+    *\n+    * @param backup    the backup {@link File} containing the data to be restored.\n+    * @param resources a map of BackupManager.Resources.Type with the names of the resources to backup. If the provided", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzMzNDY4OnYy", "diffSide": "RIGHT", "path": "client/rest-client/src/main/java/org/infinispan/client/rest/impl/okhttp/RestCacheManagerClientOkHttp.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODoyMzo1OVrOG_tRbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1NToyMVrOHACYLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NTIxNA==", "bodyText": "Do we need to escape any json characters here? Could the String contain valid json delimiters?\nGuessing the Json object does that for us.\nAlso does Json.factory().make(resources) not do what we want?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469455214", "createdAt": "2020-08-12T18:23:59Z", "author": {"login": "wburns"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/impl/okhttp/RestCacheManagerClientOkHttp.java", "diffHunk": "@@ -121,4 +128,75 @@ public String name() {\n    public CompletionStage<RestResponse> caches() {\n       return client.execute(baseCacheManagerUrl, \"caches\");\n    }\n+\n+   @Override\n+   public CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      if (workingDir != null)\n+         json.set(\"directory\", workingDir);\n+\n+      if (resources != null) {\n+         Json resourcesJson = Json.object();\n+         resources.forEach((k, v) -> resourcesJson.set(k, v.toArray(new String[0])));\n+         json.set(\"resources\", resourcesJson);\n+      }\n+      RequestBody body = new StringRestEntityOkHttp(MediaType.APPLICATION_JSON, json.toString()).toRequestBody();\n+      Request.Builder builder = backup(name).post(body);\n+      return client.execute(builder);\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> getBackup(String name, boolean skipBody) {\n+      Request.Builder builder = backup(name);\n+      if (skipBody)\n+         builder.head();\n+\n+      return client.execute(builder);\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> deleteBackup(String name) {\n+      return client.execute(backup(name).delete());\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> restore(File backup, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      if (resources != null) {\n+         resources.forEach((k, v) -> json.set(k, v.toArray(new String[0])));\n+      }\n+      RequestBody zipBody = new FileRestEntityOkHttp(MediaType.APPLICATION_ZIP, backup).toRequestBody();\n+\n+      RequestBody multipartBody = new MultipartBody.Builder()\n+            .addFormDataPart(\"resources\", json.toString())\n+            .addFormDataPart(\"backup\", backup.getName(), zipBody)\n+            .setType(MultipartBody.FORM)\n+            .build();\n+\n+      Request.Builder builder = restore().post(multipartBody);\n+      return client.execute(builder);\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> restore(String backupLocation, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      json.set(\"location\", backupLocation);\n+\n+      if (resources != null) {\n+         Json resourcesJson = Json.object();\n+         resources.forEach((k, v) -> resourcesJson.set(k, v.toArray(new String[0])));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMTAwNg==", "bodyText": "Do we need to escape any json characters here? Could the String contain valid json delimiters?\n\nI don't think so, there shouldn't be any JSON passed in the Map.\n\nAlso does Json.factory().make(resources) not do what we want?\n\nYes \ud83d\ude42. I didn't know about that before.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469801006", "createdAt": "2020-08-13T08:55:21Z", "author": {"login": "ryanemerson"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/impl/okhttp/RestCacheManagerClientOkHttp.java", "diffHunk": "@@ -121,4 +128,75 @@ public String name() {\n    public CompletionStage<RestResponse> caches() {\n       return client.execute(baseCacheManagerUrl, \"caches\");\n    }\n+\n+   @Override\n+   public CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      if (workingDir != null)\n+         json.set(\"directory\", workingDir);\n+\n+      if (resources != null) {\n+         Json resourcesJson = Json.object();\n+         resources.forEach((k, v) -> resourcesJson.set(k, v.toArray(new String[0])));\n+         json.set(\"resources\", resourcesJson);\n+      }\n+      RequestBody body = new StringRestEntityOkHttp(MediaType.APPLICATION_JSON, json.toString()).toRequestBody();\n+      Request.Builder builder = backup(name).post(body);\n+      return client.execute(builder);\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> getBackup(String name, boolean skipBody) {\n+      Request.Builder builder = backup(name);\n+      if (skipBody)\n+         builder.head();\n+\n+      return client.execute(builder);\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> deleteBackup(String name) {\n+      return client.execute(backup(name).delete());\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> restore(File backup, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      if (resources != null) {\n+         resources.forEach((k, v) -> json.set(k, v.toArray(new String[0])));\n+      }\n+      RequestBody zipBody = new FileRestEntityOkHttp(MediaType.APPLICATION_ZIP, backup).toRequestBody();\n+\n+      RequestBody multipartBody = new MultipartBody.Builder()\n+            .addFormDataPart(\"resources\", json.toString())\n+            .addFormDataPart(\"backup\", backup.getName(), zipBody)\n+            .setType(MultipartBody.FORM)\n+            .build();\n+\n+      Request.Builder builder = restore().post(multipartBody);\n+      return client.execute(builder);\n+   }\n+\n+   @Override\n+   public CompletionStage<RestResponse> restore(String backupLocation, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      json.set(\"location\", backupLocation);\n+\n+      if (resources != null) {\n+         Json resourcesJson = Json.object();\n+         resources.forEach((k, v) -> resourcesJson.set(k, v.toArray(new String[0])));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NTIxNA=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzM0ODcwOnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODoyNzo0OVrOG_tZ9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToyNzo1NlrOHAQzmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NzM5Nw==", "bodyText": "Do we not want the info from the stores?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469457397", "createdAt": "2020-08-12T18:27:49Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc4MzM5MQ==", "bodyText": "This is something that I have been in two minds about. Originally I was thinking that if data is already persisted, then the stores can also be migrated by the user, but this isn't very user-friendly especially if stores are not shared and we have a large cluster. Having a centralised backup greatly simplifies this, so including stores by default makes more sense on second thought.\nIn the case of a large shared store, probably JDBC based, it's probably not desired to have the store content in the backup. Once the core backup/restore pieces are in place (CLI, Operator etc) we can add a parameter to toggle this behaviour.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469783391", "createdAt": "2020-08-13T08:27:29Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NzM5Nw=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyMzI2NA==", "bodyText": "Makes sense. This makes me wonder if we should have the default value be if the store it uses is shared or not.\nAlso I wonder if we should add support for the Flag SKIP_SHARED_CACHE_STORE in the ClusterPublisherManager", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470023264", "createdAt": "2020-08-13T15:08:01Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NzM5Nw=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzMDE1MQ==", "bodyText": "This makes me wonder if we should have the default value be if the store it uses is shared or not\n\nTbh I think this could be difficult to explain to the user in a transparent way. Having a consistent default and then documenting that it's possible to backup in-memory contents only is much simpler IMO. We can then add a note explaining that for larger shared stores it's probably desirable to enable this option.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470030151", "createdAt": "2020-08-13T15:17:52Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NzM5Nw=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzNzQwMQ==", "bodyText": "Also I wonder if we should add support for the Flag SKIP_SHARED_CACHE_STORE in the ClusterPublisherManager\n\nMakes sense. It would be perfect for this use-case", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470037401", "createdAt": "2020-08-13T15:27:56Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NzM5Nw=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzM1MzA2OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODoyOTowN1rOG_tc2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODoyOTowN1rOG_tc2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1ODEzNw==", "bodyText": "This is redundant. You can just return the value returned from invoking entryPublisher.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469458137", "createdAt": "2020-08-12T18:29:07Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,\n+               DeliveryGuarantee.EXACTLY_ONCE, BUFFER_SIZE, PublisherTransformers.identity())\n+               .subscribe(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzM1OTUyOnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODozMDo1MVrOG_tgvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTowOTowMFrOHAP-9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1OTEzNA==", "bodyText": "I am thinking it would be better to use BlockingManager#supplyBlocking and thenCompose invoke thenCompose on it. This way we won't be blocking a blocking thread unless it is processing a response to write to disk.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469459134", "createdAt": "2020-08-12T18:30:51Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg0NTIwMw==", "bodyText": "I'm not sure what you mean here. I have updated createCacheBackup to use BlockingManager#blockingPublisherToVoidStage, does ^ suggestion still apply with my latest changes?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469845203", "createdAt": "2020-08-13T10:10:57Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1OTEzNA=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAyMzkyNA==", "bodyText": "I suggested this originally and didn't go back to change this one. So using the new method is preferred.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470023924", "createdAt": "2020-08-13T15:09:00Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1OTEzNA=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzM4NDg2OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODozODowMFrOG_twiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozMTo0N1rOHAQ9nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2MzE3Ng==", "bodyText": "Can we not do this in subscribe instead?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469463176", "createdAt": "2020-08-12T18:38:00Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,\n+               DeliveryGuarantee.EXACTLY_ONCE, BUFFER_SIZE, PublisherTransformers.identity())\n+               .subscribe(s);\n+\n+         StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+         boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getKeyStorageMediaType());\n+         boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+         PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+         Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+         Flowable.using(\n+               () -> Files.newOutputStream(datFile),\n+               output ->\n+                     Flowable.fromPublisher(p)\n+                           .buffer(BUFFER_SIZE)\n+                           .flatMap(Flowable::fromIterable)\n+                           .map(e -> {\n+                              CacheBackupEntry be = new CacheBackupEntry();\n+                              be.key = keyMarshalling ? marshall(e.getKey(), userMarshaller) : (byte[]) scm.getKeyWrapper().unwrap(e.getKey());\n+                              be.value = valueMarshalling ? marshall(e.getValue(), userMarshaller) : (byte[]) scm.getValueWrapper().unwrap(e.getKey());\n+                              be.metadata = marshall(e.getMetadata(), persistenceMarshaller);\n+                              be.internalMetadata = e.getInternalMetadata();\n+                              be.created = e.getCreated();\n+                              be.lastUsed = e.getLastUsed();\n+                              return be;\n+                           })\n+                           .doOnNext(e -> writeMessageStream(e, serCtx, output))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwODcxMw==", "bodyText": "I don't think so, because subscribe returns a Disposable but we need to return a Publisher so that it can be consumed as the Flowable.using sourceSupplier. This is similar to the JpaStore#createBatchFlowable code.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469808713", "createdAt": "2020-08-13T09:08:16Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,\n+               DeliveryGuarantee.EXACTLY_ONCE, BUFFER_SIZE, PublisherTransformers.identity())\n+               .subscribe(s);\n+\n+         StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+         boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getKeyStorageMediaType());\n+         boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+         PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+         Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+         Flowable.using(\n+               () -> Files.newOutputStream(datFile),\n+               output ->\n+                     Flowable.fromPublisher(p)\n+                           .buffer(BUFFER_SIZE)\n+                           .flatMap(Flowable::fromIterable)\n+                           .map(e -> {\n+                              CacheBackupEntry be = new CacheBackupEntry();\n+                              be.key = keyMarshalling ? marshall(e.getKey(), userMarshaller) : (byte[]) scm.getKeyWrapper().unwrap(e.getKey());\n+                              be.value = valueMarshalling ? marshall(e.getValue(), userMarshaller) : (byte[]) scm.getValueWrapper().unwrap(e.getKey());\n+                              be.metadata = marshall(e.getMetadata(), persistenceMarshaller);\n+                              be.internalMetadata = e.getInternalMetadata();\n+                              be.created = e.getCreated();\n+                              be.lastUsed = e.getLastUsed();\n+                              return be;\n+                           })\n+                           .doOnNext(e -> writeMessageStream(e, serCtx, output))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2MzE3Ng=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzOTk2Nw==", "bodyText": "\ud83d\udc4d Forgot it returns a Disposable :(", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470039967", "createdAt": "2020-08-13T15:31:47Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,\n+               DeliveryGuarantee.EXACTLY_ONCE, BUFFER_SIZE, PublisherTransformers.identity())\n+               .subscribe(s);\n+\n+         StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+         boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getKeyStorageMediaType());\n+         boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+         PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+         Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+         Flowable.using(\n+               () -> Files.newOutputStream(datFile),\n+               output ->\n+                     Flowable.fromPublisher(p)\n+                           .buffer(BUFFER_SIZE)\n+                           .flatMap(Flowable::fromIterable)\n+                           .map(e -> {\n+                              CacheBackupEntry be = new CacheBackupEntry();\n+                              be.key = keyMarshalling ? marshall(e.getKey(), userMarshaller) : (byte[]) scm.getKeyWrapper().unwrap(e.getKey());\n+                              be.value = valueMarshalling ? marshall(e.getValue(), userMarshaller) : (byte[]) scm.getValueWrapper().unwrap(e.getKey());\n+                              be.metadata = marshall(e.getMetadata(), persistenceMarshaller);\n+                              be.internalMetadata = e.getInternalMetadata();\n+                              be.created = e.getCreated();\n+                              be.lastUsed = e.getLastUsed();\n+                              return be;\n+                           })\n+                           .doOnNext(e -> writeMessageStream(e, serCtx, output))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2MzE3Ng=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzM4NTE2OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODozODowNFrOG_twtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOToxMjozNlrOHADA4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2MzIyMA==", "bodyText": "This buffer and flatMap looks extraneous. What was the reason for them?", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469463220", "createdAt": "2020-08-12T18:38:04Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,\n+               DeliveryGuarantee.EXACTLY_ONCE, BUFFER_SIZE, PublisherTransformers.identity())\n+               .subscribe(s);\n+\n+         StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+         boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getKeyStorageMediaType());\n+         boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+         PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+         Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+         Flowable.using(\n+               () -> Files.newOutputStream(datFile),\n+               output ->\n+                     Flowable.fromPublisher(p)\n+                           .buffer(BUFFER_SIZE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgxMTQyNQ==", "bodyText": "I honestly can't remember. Removed.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469811425", "createdAt": "2020-08-13T09:12:36Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      return blockingManager.runBlocking(() -> {\n+         AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+         Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+         // Create the cache backup dir and parents\n+         Path cacheRoot = root.resolve(cacheName);\n+         mkdirs(cacheRoot);\n+\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+\n+         // Write in-memory cache contents to .dat file if the cache is not empty\n+         if (cache.isEmpty())\n+            return;\n+\n+         ComponentRegistry cr = cache.getComponentRegistry();\n+         ClusterPublisherManager<?, ?> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+         SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+         ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+         String dataFileName = dataFile(cacheName);\n+         Path datFile = cacheRoot.resolve(dataFileName);\n+\n+         Publisher<CacheEntry<?, ?>> p = s -> clusterPublisherManager.entryPublisher(null, null, null, false,\n+               DeliveryGuarantee.EXACTLY_ONCE, BUFFER_SIZE, PublisherTransformers.identity())\n+               .subscribe(s);\n+\n+         StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+         boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getKeyStorageMediaType());\n+         boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+         PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+         Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+         Flowable.using(\n+               () -> Files.newOutputStream(datFile),\n+               output ->\n+                     Flowable.fromPublisher(p)\n+                           .buffer(BUFFER_SIZE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2MzIyMA=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzM5MDk4OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODozOTozN1rOG_t0Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjozMjozMFrOHATUkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDA3NA==", "bodyText": "I noticed that we do an unbounded run of this. Should we limit how many blocking threads we are using? I worry about delaying actual operations on the server or even worse possibly getting some sort of livelock.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469464074", "createdAt": "2020-08-12T18:39:37Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3OTI1MQ==", "bodyText": "It makes me wonder if we should add some extra methods to BlockingManager#BlockingExecutor to handle these types of cases.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469479251", "createdAt": "2020-08-12T19:07:05Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDA3NA=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg2MDAwMg==", "bodyText": "Agreed that we should limit the number of blocking threads are used by this, as even if there is a reasonably modest number of caches this could cause issues.\nI think BlockingManager.BlockingExecutor could provide all of the BlockingManager methods with the exception of limitedBlockingExecutor. That way we can do something like:\n     BlockingManager.BlockingExecutor executor = blockingManager.limitedBlockingExecutor(\"cache-backup-executor\", 5);\n     for (String cache : resources)\n         stages.dependsOn(createCacheBackup(cache, executor));\nTo reduce repetition in the BlockingManager interface, we can create another interface BlockingOperations and then do the following:\npublic interface BlockingManager extends BlockingOperations {\n\n    BlockingExecutor limitedBlockingExecutor(String name, int concurrency);\n\n    interface BlockingExecutor extends BlockingOperations {\n    }\n}\nBlockingManagerImpl would then just provide versions of the BlockingOperations methods that take a Scheduler|Executor as an additional parameter.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469860002", "createdAt": "2020-08-13T10:39:43Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDA3NA=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg2Mjg2Nw==", "bodyText": "Similarly we could avoid BlockingOperations by adding a method that returns a BackupManager implementation that utilies a LimitedExecutor:\nBlockingManager limitedBlockingManager(int concurrency);", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469862867", "createdAt": "2020-08-13T10:45:46Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDA3NA=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3NzAxNw==", "bodyText": "I look forward to seeing this change in another PR \ud83d\udc4d", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470077017", "createdAt": "2020-08-13T16:29:57Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDA3NA=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3ODYxMA==", "bodyText": "I have created ISPN-12226 to track the BlockingManager enhancements and ISPN-12227 for the changes to the BackupManager.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470078610", "createdAt": "2020-08-13T16:32:30Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?\n+   private static final int BUFFER_SIZE = 100;\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDA3NA=="}, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzM5NDM3OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo0MDoyOVrOG_t1-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo0MDoyOVrOG_t1-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDU3MA==", "bodyText": "Can we not just use state transfer chunk size? This is what the publisher will use whenever we make an actual user facing API for it ;)", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469464570", "createdAt": "2020-08-12T18:40:29Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,282 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   // TODO what size?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzQ0ODQ5OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CounterResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo1NTo1N1rOG_uXxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo1NTo1N1rOG_uXxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3MzIyMA==", "bodyText": "So what you have here is handled a lot better if you add a method like the following to the BlockingManager\n   public <V> CompletionStage<Void> blockingPublisherToVoidStage(Publisher<V> publisher, Object traceId) {\n      CompletionStage<Void> stage = Flowable.defer(() -> {\n         Flowable<V> flowable = Flowable.fromPublisher(publisher);\n         if (isCurrentThreadBlocking()) {\n            return flowable;\n         }\n         if (trace) {\n            flowable = flowable.doOnSubscribe(subscription -> log.tracef(\"Subscribing to %s on blocking thread\"));\n         }\n         flowable = flowable.subscribeOn(blockingScheduler);\n         if (trace) {\n            flowable = flowable.doOnSubscribe(subscription -> log.tracef(\"Publisher subscribing thread is %s\"));\n         }\n         return flowable;\n      }).ignoreElements().toCompletionStage(null);\n\n      return continueOnNonBlockingThread(stage, traceId);\n   }\nI believe the doOnSubscribe is in the correct spot, but you may want to verify. The goal is to print it in the blocking thread so you can match operations between.\nThen you can just replace with this method and remove the subscribe below. This way it will properly resume on a non blocking thread. To be honest you may want to evaluate all your usages of runBlocking to see if you want to use this instead.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r469473220", "createdAt": "2020-08-12T18:55:57Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CounterResource.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.COUNTERS;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.counter.api.CounterConfiguration;\n+import org.infinispan.counter.api.CounterManager;\n+import org.infinispan.counter.api.CounterType;\n+import org.infinispan.counter.api.StrongCounter;\n+import org.infinispan.counter.api.WeakCounter;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#COUNTERS}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CounterResource extends AbstractContainerResource {\n+\n+   private static final String COUNTERS_FILE = \"counters.dat\";\n+\n+   private final CounterManager counterManager;\n+   private final ImmutableSerializationContext serCtx;\n+\n+   CounterResource(BlockingManager blockingManager, EmbeddedCacheManager cm,\n+                   BackupManager.Resources params, Path root) {\n+      super(COUNTERS, params, blockingManager, root);\n+      GlobalComponentRegistry gcr = cm.getGlobalComponentRegistry();\n+      this.counterManager = gcr.getComponent(CounterManager.class);\n+      this.serCtx = gcr.getComponent(SerializationContextRegistry.class).getPersistenceCtx();\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      if (wildcard) {\n+         resources.addAll(counterManager.getCounterNames());\n+         return;\n+      }\n+\n+      for (String counterName : resources) {\n+         if (counterManager.getConfiguration(counterName) == null)\n+            throw log.unableToFindResource(type.toString(), counterName);\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      return blockingManager.runBlocking(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f57736b5792ba572c18792f105772d7eeea0b78"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjk2MTMzOnYy", "diffSide": "RIGHT", "path": "client/rest-client/src/main/java/org/infinispan/client/rest/impl/okhttp/RestCacheManagerClientOkHttp.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDo1MjozMlrOHAPP0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDo1MjozMlrOHAPP0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAxMTg1OA==", "bodyText": "Looks like you can use\n      if (resources != null)\n         json.set(\"resources\", Json.factory().make(resources));\nfrom the other method.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470011858", "createdAt": "2020-08-13T14:52:32Z", "author": {"login": "wburns"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/impl/okhttp/RestCacheManagerClientOkHttp.java", "diffHunk": "@@ -121,4 +128,70 @@ public String name() {\n    public CompletionStage<RestResponse> caches() {\n       return client.execute(baseCacheManagerUrl, \"caches\");\n    }\n+\n+   @Override\n+   public CompletionStage<RestResponse> createBackup(String name, String workingDir, Map<String, List<String>> resources) {\n+      Json json = Json.object();\n+      if (workingDir != null)\n+         json.set(\"directory\", workingDir);\n+\n+      if (resources != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzExOTI2OnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToyNjo0MFrOHAQwMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozNDoxOFrOHARD3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzNjUzMQ==", "bodyText": "Technically this method can block as well. I would say we could use Cache#sizeAsync but that requires getting all elements. TBH, until we have a Cache#isEmptyAsync I would recommend just removing this if block. Although it would be quite simple to add this method to the cache if you wanted.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470036531", "createdAt": "2020-08-13T15:26:40Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+      Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+      // Create the cache backup dir and parents\n+      Path cacheRoot = root.resolve(cacheName);\n+      mkdirs(cacheRoot);\n+\n+      CompletionStage<Void> configStage = blockingManager.runBlocking(() -> {\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+      }, \"write-cache-config\");\n+\n+      if (cache.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MTU2NQ==", "bodyText": "I'll remove the if block ... this PR is already pretty large", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470041565", "createdAt": "2020-08-13T15:34:18Z", "author": {"login": "ryanemerson"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+      Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+      // Create the cache backup dir and parents\n+      Path cacheRoot = root.resolve(cacheName);\n+      mkdirs(cacheRoot);\n+\n+      CompletionStage<Void> configStage = blockingManager.runBlocking(() -> {\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+      }, \"write-cache-config\");\n+\n+      if (cache.isEmpty())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzNjUzMQ=="}, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzEzNzcxOnYy", "diffSide": "RIGHT", "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozMDo1N1rOHAQ7iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozMDo1N1rOHAQ7iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzOTQzNQ==", "bodyText": "Sorry I didn't notice this earlier, but this doesn't do what you want sadly.\nYou need to do something like \n  \n    \n      infinispan/core/src/main/java/org/infinispan/stream/impl/DistributedCacheStream.java\n    \n    \n         Line 378\n      in\n      37abd44\n    \n    \n    \n    \n\n        \n          \n           .onErrorResumeNext(RxJavaInterop.cacheExceptionWrapper()), distributedBatchSize);", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470039435", "createdAt": "2020-08-13T15:30:57Z", "author": {"login": "wburns"}, "path": "server/core/src/main/java/org/infinispan/server/core/backup/resources/CacheResource.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package org.infinispan.server.core.backup.resources;\n+\n+import static org.infinispan.server.core.BackupManager.Resources.Type.CACHES;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.concurrent.CompletionStage;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.cache.impl.InvocationHelper;\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.commons.marshall.MarshallingException;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.parsing.ConfigurationBuilderHolder;\n+import org.infinispan.configuration.parsing.ParserRegistry;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.encoding.impl.StorageConfigurationManager;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.InternalMetadataImpl;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.protostream.ImmutableSerializationContext;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.reactive.publisher.PublisherTransformers;\n+import org.infinispan.reactive.publisher.impl.ClusterPublisherManager;\n+import org.infinispan.reactive.publisher.impl.DeliveryGuarantee;\n+import org.infinispan.registry.InternalCacheRegistry;\n+import org.infinispan.server.core.BackupManager;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.BlockingManager;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+\n+/**\n+ * {@link org.infinispan.server.core.backup.ContainerResource} implementation for {@link\n+ * BackupManager.Resources.Type#CACHES}.\n+ *\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ */\n+public class CacheResource extends AbstractContainerResource {\n+\n+   private static final String MEMCACHED_CACHE = \"memcachedCache\";\n+\n+   private final EmbeddedCacheManager cm;\n+   private final ParserRegistry parserRegistry;\n+\n+   CacheResource(BlockingManager blockingManager, ParserRegistry parserRegistry, EmbeddedCacheManager cm,\n+                 BackupManager.Resources params, Path root) {\n+      super(CACHES, params, blockingManager, root);\n+      this.cm = cm;\n+      this.parserRegistry = parserRegistry;\n+   }\n+\n+   @Override\n+   public void prepareAndValidateBackup() {\n+      InternalCacheRegistry icr = cm.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);\n+\n+      Set<String> caches = wildcard ? cm.getCacheConfigurationNames() : resources;\n+      for (String cache : caches) {\n+         Configuration config = cm.getCacheConfiguration(cache);\n+\n+         if (wildcard) {\n+            // For wildcard resources, we ignore internal caches, however explicitly requested internal caches are allowed\n+            if (config == null || config.isTemplate() || icr.isInternalCache(cache) || MEMCACHED_CACHE.equals(cache)) {\n+               continue;\n+            }\n+            resources.add(cache);\n+         } else if (config == null) {\n+            throw log.unableToFindResource(type.toString(), cache);\n+         } else if (config.isTemplate()) {\n+            throw new CacheException(String.format(\"Unable to backup %s '%s' as it is a template not a cache\", type, cache));\n+         }\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> backup() {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cache : resources)\n+         stages.dependsOn(createCacheBackup(cache));\n+      return stages.freeze();\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> restore(ZipFile zip) {\n+      AggregateCompletionStage<Void> stages = CompletionStages.aggregateCompletionStage();\n+      for (String cacheName : resources) {\n+         stages.dependsOn(blockingManager.runBlocking(() -> {\n+            Path cacheRoot = root.resolve(cacheName);\n+\n+            // Process .xml\n+            String configFile = configFile(cacheName);\n+            String zipPath = cacheRoot.resolve(configFile).toString();\n+            try (InputStream is = zip.getInputStream(zip.getEntry(zipPath))) {\n+               ConfigurationBuilderHolder builderHolder = parserRegistry.parse(is, null);\n+               Configuration cfg = builderHolder.getNamedConfigurationBuilders().get(cacheName).build();\n+               cm.defineConfiguration(cacheName, cfg);\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+\n+            // Process .dat\n+            String dataFile = dataFile(cacheName);\n+            String data = cacheRoot.resolve(dataFile).toString();\n+            ZipEntry zipEntry = zip.getEntry(data);\n+            if (zipEntry == null)\n+               return;\n+\n+            AdvancedCache<Object, Object> cache = cm.getCache(cacheName).getAdvancedCache();\n+            ComponentRegistry cr = cache.getComponentRegistry();\n+            CommandsFactory commandsFactory = cr.getCommandsFactory();\n+            KeyPartitioner keyPartitioner = cr.getComponent(KeyPartitioner.class);\n+            InvocationHelper invocationHelper = cr.getComponent(InvocationHelper.class);\n+            StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+            PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+            Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+            boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+            boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+\n+            SerializationContextRegistry ctxRegistry = cm.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+            ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+            try (InputStream is = zip.getInputStream(zipEntry)) {\n+               while (is.available() > 0) {\n+                  CacheBackupEntry entry = readMessageStream(serCtx, CacheBackupEntry.class, is);\n+                  Object key = keyMarshalling ? unmarshall(entry.key, userMarshaller) : scm.getKeyWrapper().wrap(entry.key);\n+                  Object value = valueMarshalling ? unmarshall(entry.value, userMarshaller) : scm.getKeyWrapper().wrap(entry.value);\n+                  Metadata metadata = unmarshall(entry.metadata, persistenceMarshaller);\n+                  Metadata internalMetadataImpl = new InternalMetadataImpl(metadata, entry.created, entry.lastUsed);\n+\n+                  PutKeyValueCommand cmd = commandsFactory.buildPutKeyValueCommand(key, value, keyPartitioner.getSegment(key),\n+                        internalMetadataImpl, FlagBitSets.IGNORE_RETURN_VALUES);\n+                  cmd.setInternalMetadata(entry.internalMetadata);\n+                  invocationHelper.invoke(cmd, 1);\n+               }\n+            } catch (IOException e) {\n+               throw new CacheException(e);\n+            }\n+         }, \"restore-cache-\" + cacheName));\n+      }\n+      return stages.freeze();\n+   }\n+\n+   private CompletionStage<Void> createCacheBackup(String cacheName) {\n+      AdvancedCache<?, ?> cache = cm.getCache(cacheName).getAdvancedCache();\n+      Configuration configuration = cm.getCacheConfiguration(cacheName);\n+\n+      // Create the cache backup dir and parents\n+      Path cacheRoot = root.resolve(cacheName);\n+      mkdirs(cacheRoot);\n+\n+      CompletionStage<Void> configStage = blockingManager.runBlocking(() -> {\n+         // Write configuration file\n+         String xmlFileName = configFile(cacheName);\n+         Path xmlPath = cacheRoot.resolve(xmlFileName);\n+         try (OutputStream os = Files.newOutputStream(xmlPath)) {\n+            parserRegistry.serialize(os, cacheName, configuration);\n+         } catch (XMLStreamException | IOException e) {\n+            throw new CacheException(String.format(\"Unable to create backup file '%s'\", xmlFileName), e);\n+         }\n+      }, \"write-cache-config\");\n+\n+      if (cache.isEmpty())\n+         return configStage;\n+\n+      ComponentRegistry cr = cache.getComponentRegistry();\n+      ClusterPublisherManager<Object, Object> clusterPublisherManager = cr.getClusterPublisherManager().running();\n+      SerializationContextRegistry ctxRegistry = cr.getGlobalComponentRegistry().getComponent(SerializationContextRegistry.class);\n+      ImmutableSerializationContext serCtx = ctxRegistry.getPersistenceCtx();\n+\n+      String dataFileName = dataFile(cacheName);\n+      Path datFile = cacheRoot.resolve(dataFileName);\n+\n+      int bufferSize = configuration.clustering().stateTransfer().chunkSize();\n+      Publisher<CacheEntry<Object, Object>> p = clusterPublisherManager.entryPublisher(null, null, null, true,\n+            DeliveryGuarantee.EXACTLY_ONCE, bufferSize, PublisherTransformers.identity());\n+\n+      StorageConfigurationManager scm = cr.getComponent(StorageConfigurationManager.class);\n+      boolean keyMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getKeyStorageMediaType());\n+      boolean valueMarshalling = MediaType.APPLICATION_OBJECT.equals(scm.getValueStorageMediaType());\n+      PersistenceMarshaller persistenceMarshaller = cr.getPersistenceMarshaller();\n+      Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n+\n+      CompletionStage<Void> contentStage = blockingManager.blockingPublisherToVoidStage(\n+            Flowable.using(\n+                  () -> Files.newOutputStream(datFile),\n+                  output ->\n+                        Flowable.fromPublisher(p)\n+                              .map(e -> {\n+                                 CacheBackupEntry be = new CacheBackupEntry();\n+                                 be.key = keyMarshalling ? marshall(e.getKey(), userMarshaller) : (byte[]) scm.getKeyWrapper().unwrap(e.getKey());\n+                                 be.value = valueMarshalling ? marshall(e.getValue(), userMarshaller) : (byte[]) scm.getValueWrapper().unwrap(e.getKey());\n+                                 be.metadata = marshall(e.getMetadata(), persistenceMarshaller);\n+                                 be.internalMetadata = e.getInternalMetadata();\n+                                 be.created = e.getCreated();\n+                                 be.lastUsed = e.getLastUsed();\n+                                 return be;\n+                              })\n+                              .doOnNext(e -> writeMessageStream(e, serCtx, output))\n+                              .doOnError(t -> {\n+                                 throw new CacheException(\"Unable to create cache backup\", t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzE1MDA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozNDowNFrOHARDZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozNDowNFrOHARDZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MTQ0NQ==", "bodyText": "We can add an if (trace)", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470041445", "createdAt": "2020-08-13T15:34:04Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManagerImpl.java", "diffHunk": "@@ -246,6 +261,26 @@ protected void start() {\n       });\n    }\n \n+   public <V> CompletionStage<Void> blockingPublisherToVoidStage(Publisher<V> publisher, Object traceId) {\n+      CompletionStage<Void> stage = Flowable.defer(() -> {\n+         Flowable<V> flowable = Flowable.fromPublisher(publisher);\n+         if (isCurrentThreadBlocking()) {\n+            log.tracef(\"Invoked on a blocking thread, running %s in same blocking thread\", traceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzE1MjA4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozNDo0MlrOHARE1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozNDo0MlrOHARE1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MTgxNA==", "bodyText": "We should note the stage will always be completed upon a non blocking thread if the current thread is not a blocking one.", "url": "https://github.com/infinispan/infinispan/pull/8532#discussion_r470041814", "createdAt": "2020-08-13T15:34:42Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -169,6 +184,19 @@\n     */\n    <V> Publisher<V> blockingPublisher(Publisher<V> publisher);\n \n+   /**\n+    * Subscribes to the provided blocking publisher using the the blocking executor, ignoring all elements and returning\n+    * a {@link CompletionStage} with a value of null when complete.\n+    * <p>\n+    * Note that if the current thread is blocking everything including subscription, publication and collection of\n+    * values will be done on the current thread.\n+    *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1605d5abf808eb41677c2f4a028aea86d931a4"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3984, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}