{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNzQ1NTgx", "number": 8180, "title": "ISPN-11611 Add internal metadata to persistence", "bodyText": "https://issues.redhat.com/browse/ISPN-11611\nDepends on: #8113", "createdAt": "2020-04-08T09:51:55Z", "url": "https://github.com/infinispan/infinispan/pull/8180", "merged": true, "mergeCommit": {"oid": "ed7a8734c6ad27730b2b641536628cadb0b4477c"}, "closed": true, "closedAt": "2020-04-23T16:08:42Z", "author": {"login": "pruivo"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVrAKLgBqjMyMTUwMjU1NDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcaeAZfABqjMyNjUzMzYzNjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ebbd01bbe4c2ad1fedeea88fb7b8e37ba6eacbdf", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/ebbd01bbe4c2ad1fedeea88fb7b8e37ba6eacbdf", "committedDate": "2020-04-08T09:44:23Z", "message": "ISPN-11611 Add internal metadata to persistence"}, "afterCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/2deb8329ca43d4d4d7293622f4be10093d7ee0af", "committedDate": "2020-04-08T17:04:24Z", "message": "ISPN-11611 Add internal metadata to persistence"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNjA2MDI1", "url": "https://github.com/infinispan/infinispan/pull/8180#pullrequestreview-390606025", "createdAt": "2020-04-09T08:49:56Z", "commit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODo0OTo1NlrOGDPiGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwOTo1NTo1MVrOGDR3kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzQwMA==", "bodyText": "Unnecessary cast to InternalCacheEntry and should be MarshallableEntry<?, ?>", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406053400", "createdAt": "2020-04-09T08:49:56Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/eviction/impl/PassivationManagerImpl.java", "diffHunk": "@@ -72,10 +71,9 @@ private boolean isL1Key(Object key) {\n       return distributionManager != null && !distributionManager.getCacheTopology().isWriteOwner(key);\n    }\n \n-   private CompletionStage<Boolean> doPassivate(Object key, CacheEntry<?, ?> entry) {\n+   private CompletionStage<Boolean> doPassivate(Object key, InternalCacheEntry<?, ?> entry) {\n       if (trace) log.tracef(\"Passivating entry %s\", toStr(key));\n-         MarshallableEntry<?, ?> marshalledEntry = marshalledEntryFactory.create(key, entry.getValue(), entry.getMetadata(),\n-               entry.getCreated(), entry.getLastUsed());\n+      MarshallableEntry marshalledEntry = marshalledEntryFactory.create((InternalCacheEntry) entry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzY3OA==", "bodyText": "Unnecessary cast to InternalCacheEntry", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406053678", "createdAt": "2020-04-09T08:50:26Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/eviction/impl/PassivationManagerImpl.java", "diffHunk": "@@ -120,10 +118,7 @@ public void passivateAll() throws PersistenceException {\n       }\n \n       int count = container.sizeIncludingExpired();\n-      Iterable<MarshallableEntry> iterable = () -> new IteratorMapper<>(container.iterator(), e -> {\n-         return marshalledEntryFactory.create(e.getKey(), e.getValue(), e.getMetadata(), e.getExpiryTime(),\n-                                              e.getLastUsed());\n-      });\n+      Iterable<MarshallableEntry> iterable = () -> new IteratorMapper<>(container.iterator(), e -> marshalledEntryFactory.create((InternalCacheEntry) e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1NjQ0OQ==", "bodyText": "We can avoid some of the unchecked call warnings:\n      InternalCacheValue<?> sv = entryFactory.getValueFromCtx(key, ctx);\n      return sv != null ? marshalledEntryFactory.create(key, sv) : null;", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406056449", "createdAt": "2020-04-09T08:55:11Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/CacheWriterInterceptor.java", "diffHunk": "@@ -501,7 +501,7 @@ public int getNumberOfPersistedEntries() {\n \n    MarshallableEntry marshalledEntry(InvocationContext ctx, Object key) {\n       InternalCacheValue sv = entryFactory.getValueFromCtx(key, ctx);\n-      return sv != null ? marshalledEntryFactory.create(key, sv.getValue(), sv.getMetadata(), sv.getCreated(), sv.getLastUsed()) : null;\n+      return sv != null ? marshalledEntryFactory.create(key, sv) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1ODc5OA==", "bodyText": "Changing the MarshallableEntryFactory variable to:\nprivate final MarshallableEntryFactory<?, ?> marshalledEntryFactory;\nWe can quickly update the usages to be MarshallableEntry<?, ?> and CacheEntry<?, ?> throughout the class.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406058798", "createdAt": "2020-04-09T08:58:59Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/TxBatchUpdater.java", "diffHunk": "@@ -178,7 +178,7 @@ private Object visitModify(InvocationContext ctx, FlagAffectedCommand command, O\n             if (generateStatistics) putCount++;\n             InternalCacheValue sv = entryFactory.getValueFromCtx(key, ctx);\n             if (sv != null) {\n-               MarshallableEntry me = marshalledEntryFactory.create(key, sv.getValue(), sv.getMetadata(), sv.getCreated(), sv.getLastUsed());\n+               MarshallableEntry me = marshalledEntryFactory.create(key, sv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA2NTE5MQ==", "bodyText": "Unnecessary whitespace", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406065191", "createdAt": "2020-04-09T09:10:17Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/file/SingleFileStore.java", "diffHunk": "@@ -510,14 +518,35 @@ public boolean delete(Object key) {\n       if (loadValue) {\n          valueBb = factory.newByteBuffer(data, fe.keyLen, fe.dataLen);\n       }\n-      if (loadMetadata && fe.metadataLen > 0) {\n-         int metaLength = fe.metadataLen - TIMESTAMP_BYTES;\n-         metadataBb = factory.newByteBuffer(data, fe.keyLen + fe.dataLen, metaLength);\n-         ByteBuffer buffer = ByteBuffer.wrap(data, fe.keyLen + fe.dataLen + metaLength, TIMESTAMP_BYTES);\n+      if (loadMetadata) {\n+         long created = -1;\n+         long lastUsed = -1;\n+         org.infinispan.commons.io.ByteBuffer metadataBb = null;\n+         org.infinispan.commons.io.ByteBuffer internalMetadataBb = null;\n+\n+         int offset = fe.keyLen + fe.dataLen;\n+         if (fe.metadataLen > 0) {\n+            int metaLength = fe.metadataLen - TIMESTAMP_BYTES;\n+            metadataBb = factory.newByteBuffer(data, offset, metaLength);\n+\n+            offset += metaLength;\n \n-         long created = fe.expiryTime > 0 ? buffer.getLong() : -1;\n-         long lastUsed = fe.expiryTime > 0 ? buffer.getLong() : -1;\n-         return entryFactory.create(keyBb, valueBb, metadataBb, created, lastUsed);\n+            ByteBuffer buffer = ByteBuffer.wrap(data, offset, TIMESTAMP_BYTES);\n+\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NjMwNA==", "bodyText": "This won't be compatible with a 10.1.x SingleFileStore. To keep the FileEntry compatible, we could alter the MAGIC array to determine which version we're reading from.\nFor example:\nprivate static final byte[] MAGIC_10.1.x = new byte[]{'F', 'C', 'S', '1'};\nprivate static final byte[] MAGIC = new byte[]{'F', 'C', 'S', '2'};\nWe then pass boolean readInternalMetadata to rebuildIndex() and handle accordingly.\nObviously we would need a test with the 10.1.x bytes to ensure this works correctly.\n\\cc @wburns", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406076304", "createdAt": "2020-04-09T09:29:09Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/file/SingleFileStore.java", "diffHunk": "@@ -196,11 +197,12 @@ private void rebuildIndex() throws Exception {\n          int keyLen = buf.getInt();\n          int dataLen = buf.getInt();\n          int metadataLen = buf.getInt();\n+         int internalMetadataLen = buf.getInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3NzE2Ng==", "bodyText": "Nitpick, but can we inline like elsewhere.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406077166", "createdAt": "2020-04-09T09:30:27Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -145,6 +141,10 @@\n    @Inject Transport transport;\n    @Inject @ComponentName(NON_BLOCKING_EXECUTOR)\n    ExecutorService nonBlockingExecutor;\n+   @Inject\n+   ComponentRef<InvocationHelper> invocationHelper;\n+   @Inject\n+   ComponentRef<CommandsFactory> commandsFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3OTk4NQ==", "bodyText": "JPA is still a dark art to me. Will this have any impact on backwards compatibility? Or will the new field simply not be set if it does not exist?", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406079985", "createdAt": "2020-04-09T09:35:27Z", "author": {"login": "ryanemerson"}, "path": "persistence/jpa/src/main/java/org/infinispan/persistence/jpa/impl/MetadataEntity.java", "diffHunk": "@@ -39,6 +39,9 @@\n    private long lastUsed;\n    @Version\n    private int version;\n+   @Lob\n+   @Column(length = 65535)\n+   private byte[] internalMetadata;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA4MDk1Nw==", "bodyText": "Why is this change necessary?", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406080957", "createdAt": "2020-04-09T09:37:15Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -309,25 +309,21 @@ public void deleteBatch(Iterable<Object> keys) {\n \n     private void putExpireDbData(ExpiryEntry entry) throws InterruptedException, RocksDBException, IOException,\n        ClassNotFoundException {\n-        try {\n-            final byte[] expiryBytes = marshall(entry.expiry);\n-            final byte[] existingBytes = expiredDb.get(expiryBytes);\n-\n-            if (existingBytes != null) {\n-                // in the case of collision make the value a List ...\n-                final Object existing = unmarshall(existingBytes);\n-                if (existing instanceof ExpiryBucket) {\n-                    ((ExpiryBucket) existing).entries.add(entry.keyBytes);\n-                    expiredDb.put(expiryBytes, marshall(existing));\n-                } else {\n-                    ExpiryBucket bucket = new ExpiryBucket(existingBytes, entry.keyBytes);\n-                    expiredDb.put(expiryBytes, marshall(bucket));\n-                }\n+        final byte[] expiryBytes = marshall(entry.expiry);\n+        final byte[] existingBytes = expiredDb.get(expiryBytes);\n+\n+        if (existingBytes != null) {\n+            // in the case of collision make the value a List ...\n+            final Object existing = unmarshall(existingBytes);\n+            if (existing instanceof ExpiryBucket) {\n+                ((ExpiryBucket) existing).entries.add(entry.keyBytes);\n+                expiredDb.put(expiryBytes, marshall(existing));\n             } else {\n-                expiredDb.put(expiryBytes, entry.keyBytes);\n+                ExpiryBucket bucket = new ExpiryBucket(existingBytes, entry.keyBytes);\n+                expiredDb.put(expiryBytes, marshall(bucket));\n             }\n-        } catch (IOException | InterruptedException | RocksDBException | ClassNotFoundException e) {\n-            throw e;\n+        } else {\n+            expiredDb.put(expiryBytes, entry.keyBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5MTY2NQ==", "bodyText": "Like the SFS this won't be backwards compatible as the HEADER_SIZE has changed, however in this case we can't workaround this using the MAGIC array as it does not exist. So I think we might need to add a magic field, and read accordingly depending on whether it is/isn't present.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r406091665", "createdAt": "2020-04-09T09:55:51Z", "author": {"login": "ryanemerson"}, "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/EntryHeader.java", "diffHunk": "@@ -23,6 +24,7 @@ public EntryHeader(ByteBuffer buffer) {\n       this.keyLength = buffer.getShort();\n       this.metadataLength = buffer.getShort();\n       this.valueLength = buffer.getInt();\n+      this.internalMetadataLength = buffer.getInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af"}, "originalPosition": 20}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2deb8329ca43d4d4d7293622f4be10093d7ee0af", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/2deb8329ca43d4d4d7293622f4be10093d7ee0af", "committedDate": "2020-04-08T17:04:24Z", "message": "ISPN-11611 Add internal metadata to persistence"}, "afterCommit": {"oid": "2d987312072d97521f826944a8dc29d04103faeb", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/2d987312072d97521f826944a8dc29d04103faeb", "committedDate": "2020-04-09T13:57:26Z", "message": "ISPN-11611 Add internal metadata to persistence"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e511ce34c9d7386a9aa3b0820d4201650fd045c", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/8e511ce34c9d7386a9aa3b0820d4201650fd045c", "committedDate": "2020-04-13T09:09:00Z", "message": "Fix SFS"}, "afterCommit": {"oid": "dbc950b0e4bac66be391e5651b2e3c42d76522cd", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/dbc950b0e4bac66be391e5651b2e3c42d76522cd", "committedDate": "2020-04-13T15:49:31Z", "message": "Fix SIFS"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzk1MDc0", "url": "https://github.com/infinispan/infinispan/pull/8180#pullrequestreview-392795074", "createdAt": "2020-04-14T10:21:28Z", "commit": {"oid": "dbc950b0e4bac66be391e5651b2e3c42d76522cd"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMDoyMToyOFrOGFIEdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMDoyNjoyMVrOGFIPpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyODI3Nw==", "bodyText": "Don't forget \ud83d\ude42", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408028277", "createdAt": "2020-04-14T10:21:28Z", "author": {"login": "ryanemerson"}, "path": "commons/all/src/main/java/org/infinispan/commons/io/EmptyByteBuffer.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package org.infinispan.commons.io;\n+\n+import org.infinispan.commons.util.Util;\n+\n+/**\n+ * //TODO document this!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbc950b0e4bac66be391e5651b2e3c42d76522cd"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyOTA2NQ==", "bodyText": "HEADER_SIZE_10_1 and HEADER_SIZE_11_0 would be more informative.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408029065", "createdAt": "2020-04-14T10:22:45Z", "author": {"login": "ryanemerson"}, "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/EntryHeader.java", "diffHunk": "@@ -7,26 +7,33 @@\n  */\n public class EntryHeader {\n    static final int MAGIC = 0xBE11A61C;\n-   static final boolean useMagic = false;\n-   static final int HEADER_SIZE = 28 + (useMagic ? 4 : 0);\n+   //no magic neither no internal metadata\n+   static final int OLD_HEADER_SIZE = 24;\n+   static final int HEADER_SIZE = 32;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbc950b0e4bac66be391e5651b2e3c42d76522cd"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMTE0Mg==", "bodyText": "I would prefer to avoid writing MAGIC per header if possilbe. However, if we can't avoid that we should at least store it as a single byte. useMagic was only ever used for testing, so we don't have to worry about the compatibility of this field as it was never used in production.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408031142", "createdAt": "2020-04-14T10:26:21Z", "author": {"login": "ryanemerson"}, "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/EntryHeader.java", "diffHunk": "@@ -53,12 +60,26 @@ public long expiryTime() {\n       return expiration;\n    }\n \n+   public int getHeaderLength() {\n+      return headerLength;\n+   }\n+\n    @Override\n    public String toString() {\n       return String.format(\"[keyLength=%d, valueLength=%d, metadataLength=%d, internalMetadataLength=%d,seqId=%d, expiration=%d]\", keyLength, valueLength, metadataLength, internalMetadataLength, seqId, expiration);\n    }\n \n    public int totalLength() {\n-      return keyLength + metadataLength + internalMetadataLength + valueLength + HEADER_SIZE;\n+      return keyLength + metadataLength + internalMetadataLength + valueLength + headerLength;\n+   }\n+\n+   public static void writeHeader(ByteBuffer buf, short keyLength, short metadataLength, int valueLength, int internalMetadataLength, long seqId, long expiration) {\n+      buf.putInt(EntryHeader.MAGIC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbc950b0e4bac66be391e5651b2e3c42d76522cd"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyODAzMzI2", "url": "https://github.com/infinispan/infinispan/pull/8180#pullrequestreview-392803326", "createdAt": "2020-04-14T10:33:47Z", "commit": {"oid": "3209115ecc0fd3e6ef5b08b035a6a091fe984279"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMDozMzo0N1rOGFIfTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMDozMzo0N1rOGFIfTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNTE1MQ==", "bodyText": "What if the user is migrating a store from the existing version of Infinispan, i.e. 11.x?", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r408035151", "createdAt": "2020-04-14T10:33:47Z", "author": {"login": "ryanemerson"}, "path": "tools/src/main/java/org/infinispan/tools/store/migrator/file/SoftIndexFileStoreIterator.java", "diffHunk": "@@ -85,7 +85,7 @@ public MarshallableEntry next() {\n                      byte[] serializedValue = EntryRecord.readValue(handle, header, offset);\n \n                      offset += header.totalLength();\n-                     if (EntryRecord.readEntryHeader(handle, offset) == null) {\n+                     if (EntryRecord.readOldEntryHeader(handle, offset) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3209115ecc0fd3e6ef5b08b035a6a091fe984279"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3209115ecc0fd3e6ef5b08b035a6a091fe984279", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/3209115ecc0fd3e6ef5b08b035a6a091fe984279", "committedDate": "2020-04-14T09:08:37Z", "message": "Fix SIFS migrator tool"}, "afterCommit": {"oid": "1536ecf1815069237237e414f40b36ab7b2ca7f8", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/1536ecf1815069237237e414f40b36ab7b2ca7f8", "committedDate": "2020-04-14T10:53:45Z", "message": "ISPN-11611 Add internal metadata to persistence"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1536ecf1815069237237e414f40b36ab7b2ca7f8", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/1536ecf1815069237237e414f40b36ab7b2ca7f8", "committedDate": "2020-04-14T10:53:45Z", "message": "ISPN-11611 Add internal metadata to persistence"}, "afterCommit": {"oid": "d4256abeb22908a556288a7e490dd7e3e1a76e9d", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/d4256abeb22908a556288a7e490dd7e3e1a76e9d", "committedDate": "2020-04-14T10:57:54Z", "message": "ISPN-11611 Add internal metadata to persistence"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d4256abeb22908a556288a7e490dd7e3e1a76e9d", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/d4256abeb22908a556288a7e490dd7e3e1a76e9d", "committedDate": "2020-04-14T10:57:54Z", "message": "ISPN-11611 Add internal metadata to persistence"}, "afterCommit": {"oid": "65a8334a2def849f1ba8b1014adfac88a9622f0e", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/65a8334a2def849f1ba8b1014adfac88a9622f0e", "committedDate": "2020-04-14T14:33:54Z", "message": "ISPN-11611 Add internal metadata to persistence"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65a8334a2def849f1ba8b1014adfac88a9622f0e", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/65a8334a2def849f1ba8b1014adfac88a9622f0e", "committedDate": "2020-04-14T14:33:54Z", "message": "ISPN-11611 Add internal metadata to persistence"}, "afterCommit": {"oid": "3bf8d3ce459065f2271d528e55268741267ca84b", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/3bf8d3ce459065f2271d528e55268741267ca84b", "committedDate": "2020-04-14T15:36:01Z", "message": "ISPN-11611 Add internal metadata to persistence"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3bf8d3ce459065f2271d528e55268741267ca84b", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/3bf8d3ce459065f2271d528e55268741267ca84b", "committedDate": "2020-04-14T15:36:01Z", "message": "ISPN-11611 Add internal metadata to persistence"}, "afterCommit": {"oid": "22777f3968555493613fe5097d08a3d6385c9cb7", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/22777f3968555493613fe5097d08a3d6385c9cb7", "committedDate": "2020-04-20T08:40:46Z", "message": "ISPN-11611 Add internal metadata to persistence"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MzAzMTA1", "url": "https://github.com/infinispan/infinispan/pull/8180#pullrequestreview-396303105", "createdAt": "2020-04-20T09:49:10Z", "commit": {"oid": "22777f3968555493613fe5097d08a3d6385c9cb7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTo0OToxMFrOGIMVlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDoxNjoyMlrOGINX2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI0MzkyNA==", "bodyText": "Can we replace this with a EMPTY_INSTANCE field in ByteBufferImpl? So:\npublic static final ByteBufferImpl EMPTY_INSTANCE = new ByteBufferImpl(Util.EMPTY_BYTE_ARRAY);\n...\n   @Override\n   public ByteBufferImpl copy() {\n      if (this == EMPTY_INSTANCE)\n          return this;\n      byte[] new_buf = buf != null ? new byte[length] : null;\n      int new_length = new_buf != null ? new_buf.length : 0;\n      if (new_buf != null)\n         System.arraycopy(buf, offset, new_buf, 0, length);\n      return new ByteBufferImpl(new_buf, 0, new_length);\n   }\nPolymorphism introduces headaches on the Protostream marshalling side, so avoiding unnecessary cases like this will make our marshalling code much cleaner as I only have to handle one ByteBuffer implementation.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411243924", "createdAt": "2020-04-20T09:49:10Z", "author": {"login": "ryanemerson"}, "path": "commons/all/src/main/java/org/infinispan/commons/io/EmptyByteBuffer.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package org.infinispan.commons.io;\n+\n+import org.infinispan.commons.util.Util;\n+\n+/**\n+ * An empty {@link ByteBuffer} implementation.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public class EmptyByteBuffer implements ByteBuffer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22777f3968555493613fe5097d08a3d6385c9cb7"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI0NjgwNQ==", "bodyText": "If we have EMPTY_INSTANCE in ByteBufferImpl we can create a static create method in that class that can be used throughout our code.\npublic static ByteBuffer create(byte[] array) {\n    return array == null || array.length == 0 ? EMPTY_INSTANCE : new ByteBufferImpl(array);\n}", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411246805", "createdAt": "2020-04-20T09:53:41Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/marshall/persistence/impl/MarshalledValueImpl.java", "diffHunk": "@@ -21,21 +22,27 @@\n @ProtoTypeId(ProtoStreamTypeIds.MARSHALLED_VALUE_IMPL)\n public class MarshalledValueImpl implements MarshalledValue {\n \n-   static final MarshalledValue EMPTY = new MarshalledValueImpl((ByteBuffer) null, null, -1, -1);\n+   static final MarshalledValue EMPTY = new MarshalledValueImpl(null, null, null, -1, -1);\n \n    private final ByteBuffer valueBytes;\n    private final ByteBuffer metadataBytes;\n+   private final ByteBuffer internalMetadataBytes;\n    private final long created;\n    private final long lastUsed;\n \n+   private static ByteBuffer wrap(byte[] array) {\n+      return array == null || array.length == 0 ? EmptyByteBuffer.INSTANCE : new ByteBufferImpl(array);\n+   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22777f3968555493613fe5097d08a3d6385c9cb7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI0NzM3Ng==", "bodyText": "name attribute is redundant as the proto name will already be \"internalMetadata\"", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411247376", "createdAt": "2020-04-20T09:54:32Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/marshall/persistence/impl/MarshalledValueImpl.java", "diffHunk": "@@ -62,6 +69,11 @@ public long getLastUsed() {\n       return lastUsed;\n    }\n \n+   @ProtoField(number = 5, name = \"internalMetadata\")\n+   byte[] getInternalMetadata() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22777f3968555493613fe5097d08a3d6385c9cb7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI1NzI0Nw==", "bodyText": "I don't think these static methods simplify things. arrayLength and bufferLenth are only called once as well. I would prefer just to keep the checks inline.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411257247", "createdAt": "2020-04-20T10:10:17Z", "author": {"login": "ryanemerson"}, "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/EntryRecord.java", "diffHunk": "@@ -117,17 +150,31 @@ private static int read(FileProvider.Handle handle, ByteBuffer buffer, long posi\n       return read;\n    }\n \n+   private static int arrayLength(byte[] array) {\n+      return array == null ? 0 : array.length;\n+   }\n+\n+   private static short arrayLengthAsShort(byte[] array) {\n+      return array == null ? 0 : (short) array.length;\n+   }\n+\n+   private static int bufferLength(org.infinispan.commons.io.ByteBuffer byteBuffer) {\n+      return byteBuffer == null ? 0 : byteBuffer.getLength();\n+   }\n+\n+   private static short bufferLengthAsShort(org.infinispan.commons.io.ByteBuffer byteBuffer) {\n+      return byteBuffer == null ? 0 : (short) byteBuffer.getLength();\n+   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22777f3968555493613fe5097d08a3d6385c9cb7"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI1ODkwMQ==", "bodyText": "I think this log and a message indicating that the migration has sucessfully completed should be info the same as in SFS.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411258901", "createdAt": "2020-04-20T10:13:05Z", "author": {"login": "ryanemerson"}, "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/SoftIndexFileStore.java", "diffHunk": "@@ -163,40 +164,93 @@ public void start() {\n       compactor.setIndex(index);\n       startIndex();\n       final AtomicLong maxSeqId = new AtomicLong(0);\n-      if (index.isLoaded()) {\n-         log.debug(\"Not building the index - loaded from persisted state\");\n-      } else if (configuration.purgeOnStartup()) {\n-         log.debug(\"Not building the index - purge will be executed\");\n+      boolean migrateData = false;\n+\n+      if (!configuration.purgeOnStartup()) {\n+         // we don't destroy the data on startup\n+         // get the old files\n+         FileProvider oldFileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit(), \"\");\n+         if (oldFileProvider.hasFiles()) {\n+            log.debug(\"Migrate old format to new format.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22777f3968555493613fe5097d08a3d6385c9cb7"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MDg5MQ==", "bodyText": "Nitpick. Single line comment", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r411260891", "createdAt": "2020-04-20T10:16:22Z", "author": {"login": "ryanemerson"}, "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/SoftIndexFileStore.java", "diffHunk": "@@ -163,40 +164,93 @@ public void start() {\n       compactor.setIndex(index);\n       startIndex();\n       final AtomicLong maxSeqId = new AtomicLong(0);\n-      if (index.isLoaded()) {\n-         log.debug(\"Not building the index - loaded from persisted state\");\n-      } else if (configuration.purgeOnStartup()) {\n-         log.debug(\"Not building the index - purge will be executed\");\n+      boolean migrateData = false;\n+\n+      if (!configuration.purgeOnStartup()) {\n+         // we don't destroy the data on startup\n+         // get the old files\n+         FileProvider oldFileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit(), \"\");\n+         if (oldFileProvider.hasFiles()) {\n+            log.debug(\"Migrate old format to new format.\");\n+            migrateFromOldFormat(oldFileProvider);\n+            migrateData = true;\n+         } else if (index.isLoaded()) {\n+            log.debug(\"Not building the index - loaded from persisted state\");\n+         } else {\n+            log.debug(\"Building the index\");\n+            buildIndex(maxSeqId);\n+         }\n       } else {\n-         log.debug(\"Building the index\");\n+         log.debug(\"Not building the index - purge will be executed\");\n+      }\n+      if (!migrateData) {\n+         logAppender.setSeqId(maxSeqId.get() + 1);\n+      }\n+   }\n \n-         Flowable<Integer> filePublisher = filePublisher();\n-         CompletionStage<Void> stage = handleFilePublisher(filePublisher.doAfterNext(compactor::completeFile), false, false,\n-               (file, offset, size, serializedKey, entryMetadata, serializedValue, seqId, expiration) -> {\n-                  long prevSeqId;\n-                  while (seqId > (prevSeqId = maxSeqId.get()) && !maxSeqId.compareAndSet(prevSeqId, seqId)) {\n+   private void migrateFromOldFormat(FileProvider oldFileProvider) {\n+      try {\n+         index.clear();\n+      } catch (IOException e) {\n+         throw new PersistenceException(e);\n+      }\n+      long lastIndex = -1;\n+      try(CloseableIterator<Integer> it = oldFileProvider.getFileIterator()) {\n+         while (it.hasNext()) {\n+            int fileId = it.next();\n+            try (FileProvider.Handle handle = oldFileProvider.getFile(fileId)) {\n+               int offset = 0;\n+               while (true) {\n+                  EntryHeader header = EntryRecord.readOldEntryHeader(handle, offset);\n+                  if (header == null) {\n+                     //end of file. go to next one\n+                     break;\n                   }\n-                  Object key = marshaller.objectFromByteBuffer(serializedKey);\n-                  if (trace) {\n-                     log.tracef(\"Loaded %d:%d (seqId %d, expiration %d)\", file, offset, seqId, expiration);\n+                  MarshallableEntry<Object, Object> entry = readEntry(handle, header, offset, null);\n+                  // entry is null if expired or removed (tombstone)\n+                  // in both case, we can ignore it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22777f3968555493613fe5097d08a3d6385c9cb7"}, "originalPosition": 96}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1d5739b36290b863eacf083d9e8293185a2d889c", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/1d5739b36290b863eacf083d9e8293185a2d889c", "committedDate": "2020-04-21T10:02:59Z", "message": "Try fix SIFS store"}, "afterCommit": {"oid": "fd70260bb7d7b9944e75d7281f1696b4d193ed94", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/fd70260bb7d7b9944e75d7281f1696b4d193ed94", "committedDate": "2020-04-21T10:16:24Z", "message": "Try fix SIFS store"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3OTU3NTk3", "url": "https://github.com/infinispan/infinispan/pull/8180#pullrequestreview-397957597", "createdAt": "2020-04-22T08:25:54Z", "commit": {"oid": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODoyNTo1NFrOGJp9Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwODo1MjoyMVrOGJrJow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3Nzc5NQ==", "bodyText": "Why is this necessary? Can't we just use tmpDirectory(Class<?> test)?", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412777795", "createdAt": "2020-04-22T08:25:54Z", "author": {"login": "ryanemerson"}, "path": "commons-test/src/main/java/org/infinispan/commons/test/CommonsTestingUtil.java", "diffHunk": "@@ -47,6 +47,17 @@ public static String tmpDirectory() {\n       return System.getProperty(\"infinispan.test.tmpdir\", System.getProperty(\"java.io.tmpdir\"));\n    }\n \n+   /**\n+    * Creates a path to a unique (per test) temporary directory. The directory is created in the platform's temp\n+    * directory (set by {@code java.io.tmpdir}).\n+    *\n+    * @param test test that requires this directory.\n+    * @return an absolute path\n+    */\n+   public static String javaTmpDirectory(Class<?> test) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc3OTk0OQ==", "bodyText": "Can be:\nreturn ByteBufferImpl.create(b, offset, length);`", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412779949", "createdAt": "2020-04-22T08:28:43Z", "author": {"login": "ryanemerson"}, "path": "commons/all/src/main/java/org/infinispan/commons/io/ByteBufferFactoryImpl.java", "diffHunk": "@@ -8,6 +8,6 @@\n \n    @Override\n    public ByteBuffer newByteBuffer(byte[] b, int offset, int length) {\n-      return new ByteBufferImpl(b, offset, length);\n+      return b == null || b.length == 0 || length == 0 ? ByteBufferImpl.EMPTY_INSTANCE : new ByteBufferImpl(b, offset, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4NDc5Mg==", "bodyText": "Nitpick. Unnecessary empty line", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412784792", "createdAt": "2020-04-22T08:35:16Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/persistence/file/SingleFileStoreCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package org.infinispan.persistence.file;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.FileLookupFactory;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.persistence.PersistenceCompatibilityTest;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests if {@link SingleFileStore} can migrate data from Infinispan 10.1.x.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"persistence.file.SingleFileStoreCompatibilityTest\")\n+public class SingleFileStoreCompatibilityTest extends PersistenceCompatibilityTest<String> {\n+\n+   private static final String DATA_10_1 = \"10_1_x_sfs_data/sfs-store-cache.dat\";\n+   private String tmpDirectory;\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4NjQ3NQ==", "bodyText": "We can pass this to the constructor of PersistenceCompatibilityTest so that we don't have to override setup and teardown in all of the tests.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412786475", "createdAt": "2020-04-22T08:37:37Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/persistence/file/SingleFileStoreCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package org.infinispan.persistence.file;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.FileLookupFactory;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.persistence.PersistenceCompatibilityTest;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests if {@link SingleFileStore} can migrate data from Infinispan 10.1.x.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"persistence.file.SingleFileStoreCompatibilityTest\")\n+public class SingleFileStoreCompatibilityTest extends PersistenceCompatibilityTest<String> {\n+\n+   private static final String DATA_10_1 = \"10_1_x_sfs_data/sfs-store-cache.dat\";\n+   private String tmpDirectory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4NzY0NQ==", "bodyText": "We can set the Global persistent location here:\nbuilder.globalState().persistentLocation(CommonsTestingUtil.tmpDirectory())\nThat way not all of the tests have to override amendGlobalConfigurationBuilder and it should not negatively effect the JPA and JDBC tests that don't need it.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412787645", "createdAt": "2020-04-22T08:39:16Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/persistence/PersistenceCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.persistence;\n+\n+import static org.infinispan.persistence.PersistenceUtil.getQualifiedLocation;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.util.FileLookupFactory;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.test.SingleCacheManagerTest;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Base compatibility test for cache stores.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\")\n+public abstract class PersistenceCompatibilityTest<T> extends SingleCacheManagerTest {\n+\n+   private static final int NUMBER_KEYS = 10;\n+   private final KeyValueWrapper<String, String, T> valueWrapper;\n+\n+   protected PersistenceCompatibilityTest(KeyValueWrapper<String, String, T> valueWrapper) {\n+      this.valueWrapper = valueWrapper;\n+   }\n+\n+   private static String key(int index) {\n+      return \"key-\" + index;\n+   }\n+\n+   private static String value(int index) {\n+      return \"value-\" + index;\n+   }\n+\n+   protected static void copyFile(String file_10_1, Path location, String fileName) throws IOException {\n+      InputStream is = FileLookupFactory.newInstance()\n+            .lookupFile(file_10_1, Thread.currentThread().getContextClassLoader());\n+      File f = new File(location.toFile(), fileName);\n+      Files.copy(is, f.toPath(), StandardCopyOption.REPLACE_EXISTING);\n+   }\n+\n+   @Test\n+   public void testReadWriteFrom101() throws Exception {\n+      // 10 keys\n+      // even keys stored, odd keys removed\n+      beforeStartCache();\n+      Cache<String, T> cache = cacheManager.getCache(cacheName());\n+\n+      for (int i = 0; i < NUMBER_KEYS; ++i) {\n+         String key = key(i);\n+         if (i % 2 != 0) {\n+            assertNull(\"Expected null value for key \" + key, cache.get(key));\n+         } else {\n+            assertEquals(\"Wrong value read for key \" + key, value(i), valueWrapper.unwrap(cache.get(key)));\n+         }\n+      }\n+\n+      for (int i = 0; i < NUMBER_KEYS; ++i) {\n+         if (i % 2 != 0) {\n+            String key = key(i);\n+            cache.put(key, valueWrapper.wrap(key, value(i)));\n+         }\n+      }\n+\n+      for (int i = 0; i < NUMBER_KEYS; ++i) {\n+         String key = key(i);\n+         assertEquals(\"Wrong value read for key \" + key, value(i), valueWrapper.unwrap(cache.get(key)));\n+      }\n+\n+   }\n+\n+   protected abstract void beforeStartCache() throws Exception;\n+\n+   @Override\n+   protected EmbeddedCacheManager createCacheManager() throws Exception {\n+      GlobalConfigurationBuilder builder = new GlobalConfigurationBuilder().nonClusteredDefault();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NTg5OQ==", "bodyText": "It would be good to have the prefix values as constants, e.g. 10_1_PREFIX = \"\", 11_0_PREFIX=\"ispn.\"", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412795899", "createdAt": "2020-04-22T08:50:27Z", "author": {"login": "ryanemerson"}, "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/SoftIndexFileStore.java", "diffHunk": "@@ -150,7 +151,7 @@ public void start() {\n       temporaryTable = new TemporaryTable(configuration.indexQueueLength() * configuration.indexSegments());\n       storeQueue = new SyncProcessingQueue<>();\n       indexQueue = new IndexQueue(configuration.indexSegments(), configuration.indexQueueLength());\n-      fileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit());\n+      fileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit(), \"ispn.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NjQ4OQ==", "bodyText": "We should use the statements you introduced in Log.java", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412796489", "createdAt": "2020-04-22T08:51:13Z", "author": {"login": "ryanemerson"}, "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/SoftIndexFileStore.java", "diffHunk": "@@ -163,40 +164,95 @@ public void start() {\n       compactor.setIndex(index);\n       startIndex();\n       final AtomicLong maxSeqId = new AtomicLong(0);\n-      if (index.isLoaded()) {\n-         log.debug(\"Not building the index - loaded from persisted state\");\n-      } else if (configuration.purgeOnStartup()) {\n-         log.debug(\"Not building the index - purge will be executed\");\n+      boolean migrateData = false;\n+\n+      if (!configuration.purgeOnStartup()) {\n+         // we don't destroy the data on startup\n+         // get the old files\n+         FileProvider oldFileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit(), \"\");\n+         if (oldFileProvider.hasFiles()) {\n+            org.infinispan.util.logging.Log.PERSISTENCE.info(\"Migrating data new format...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NzM0Nw==", "bodyText": "The code will be a lot cleaner if we statically import PERSISTENCE log.", "url": "https://github.com/infinispan/infinispan/pull/8180#discussion_r412797347", "createdAt": "2020-04-22T08:52:21Z", "author": {"login": "ryanemerson"}, "path": "persistence/soft-index/src/main/java/org/infinispan/persistence/sifs/SoftIndexFileStore.java", "diffHunk": "@@ -163,40 +164,95 @@ public void start() {\n       compactor.setIndex(index);\n       startIndex();\n       final AtomicLong maxSeqId = new AtomicLong(0);\n-      if (index.isLoaded()) {\n-         log.debug(\"Not building the index - loaded from persisted state\");\n-      } else if (configuration.purgeOnStartup()) {\n-         log.debug(\"Not building the index - purge will be executed\");\n+      boolean migrateData = false;\n+\n+      if (!configuration.purgeOnStartup()) {\n+         // we don't destroy the data on startup\n+         // get the old files\n+         FileProvider oldFileProvider = new FileProvider(getDataLocation(), configuration.openFilesLimit(), \"\");\n+         if (oldFileProvider.hasFiles()) {\n+            org.infinispan.util.logging.Log.PERSISTENCE.info(\"Migrating data new format...\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NjQ4OQ=="}, "originalCommit": {"oid": "9279238abaeb47d6ba267cd76d33ba86d7e31dbc"}, "originalPosition": 50}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e18303f919c6af2f1826c6d7ddf5f7fd1202c73", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/9e18303f919c6af2f1826c6d7ddf5f7fd1202c73", "committedDate": "2020-04-22T11:20:34Z", "message": "ByteBufferImpl changes"}, "afterCommit": {"oid": "78875fb7e2282eef53d37f30f80c6e57bb3410c0", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/78875fb7e2282eef53d37f30f80c6e57bb3410c0", "committedDate": "2020-04-23T10:47:49Z", "message": "ISPN-11611 Add internal metadata to persistence"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f192aa916f4786495667e2483d6bc4ec7ef836e", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/3f192aa916f4786495667e2483d6bc4ec7ef836e", "committedDate": "2020-04-23T14:45:29Z", "message": "ISPN-11611 Add internal metadata to persistence"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "78875fb7e2282eef53d37f30f80c6e57bb3410c0", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/78875fb7e2282eef53d37f30f80c6e57bb3410c0", "committedDate": "2020-04-23T10:47:49Z", "message": "ISPN-11611 Add internal metadata to persistence"}, "afterCommit": {"oid": "3f192aa916f4786495667e2483d6bc4ec7ef836e", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/3f192aa916f4786495667e2483d6bc4ec7ef836e", "committedDate": "2020-04-23T14:45:29Z", "message": "ISPN-11611 Add internal metadata to persistence"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 835, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}