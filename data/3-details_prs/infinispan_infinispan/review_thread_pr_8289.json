{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MjgzODMz", "number": 8289, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzo1NTo1MlrOD8xUWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDo1NDowOFrOD854Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDQ5MTc3OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/titles/xsite/xsite.asciidoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzo1NTo1M1rOGV6XuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwODoyMToxNFrOGV7Kdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyOTYyNA==", "bodyText": "remove  {infinispanversion}? wdyt?", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425629624", "createdAt": "2020-05-15T07:55:53Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/titles/xsite/xsite.asciidoc", "diffHunk": "@@ -14,7 +14,12 @@ include::../{topics}/attributes/community-attributes.adoc[]\n :stem: asciimath\n \n //Title\n-= Replicating Data Across Sites with {brandname} {infinispanversion}\n+= {brandname} {infinispanversion} Guide to Cross-Site Replication", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY0MjYxNQ==", "bodyText": "sounds good", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425642615", "createdAt": "2020-05-15T08:21:14Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/titles/xsite/xsite.asciidoc", "diffHunk": "@@ -14,7 +14,12 @@ include::../{topics}/attributes/community-attributes.adoc[]\n :stem: asciimath\n \n //Title\n-= Replicating Data Across Sites with {brandname} {infinispanversion}\n+= {brandname} {infinispanversion} Guide to Cross-Site Replication", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyOTYyNA=="}, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDQ5NTU5OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzo1NzoxM1rOGV6aRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDo1MzoyMFrOGWAEIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMDI3Ng==", "bodyText": "typo? is => isn't", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425630276", "createdAt": "2020-05-15T07:57:13Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMDUzNg==", "bodyText": "@pruivo I'm not sure. if the vector value is greater or less then it means there is a conflict, right?\nmaybe we should say if the vector value for \"k1\" does not match?", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425700536", "createdAt": "2020-05-15T10:07:26Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMDI3Ng=="}, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwOTQyOQ==", "bodyText": "This is my point of view:\n[1,1] is \"strictly\" less than [2,1], [1,2] (no conflict)\n[2,1] is \"strictly\" greater than [1,1], [0,1], [1,0] (no conflict)\n[1,2] is conflicting with [2,1]\nso, I have no idea how to put that in words xD", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425709429", "createdAt": "2020-05-15T10:24:36Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMDI3Ng=="}, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyMjkxNA==", "bodyText": "thanks @pruivo that's a great catch.", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425722914", "createdAt": "2020-05-15T10:53:20Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMDI3Ng=="}, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDUwMzg3OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzo1OTo1MlrOGV6f2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwODoyNToyMlrOGV7Taw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMTcwNg==", "bodyText": "link to compareTo javadoc?\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/String.html#compareTo-java.lang.String-", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425631706", "createdAt": "2020-05-15T07:59:52Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.\n \n-//Following the same example, if \"k1\" conflicts between **LON** and **NYC**,\n-//{brandname} always uses \"k1\" in **LON**.\n+When it finds conflicting entries, {brandname} uses the Java `compareTo(String", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY0NDkwNw==", "bodyText": "added. thanks.", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425644907", "createdAt": "2020-05-15T08:25:22Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.\n \n-//Following the same example, if \"k1\" conflicts between **LON** and **NYC**,\n-//{brandname} always uses \"k1\" in **LON**.\n+When it finds conflicting entries, {brandname} uses the Java `compareTo(String", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMTcwNg=="}, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MDUwODQ3OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwODowMToxNFrOGV6iyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwODowMToxNFrOGV6iyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMjQ1OA==", "bodyText": "I may be confused, but I think it is lexicographically lower/lesser... A is preceding B.", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425632458", "createdAt": "2020-05-15T08:01:14Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.\n \n-//Following the same example, if \"k1\" conflicts between **LON** and **NYC**,\n-//{brandname} always uses \"k1\" in **LON**.\n+When it finds conflicting entries, {brandname} uses the Java `compareTo(String\n+anotherString)` method to compare site names. To determine which key takes\n+priority, {brandname} selects the site name that is lexicographically greater", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTg5NDM1OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDo1NDowOFrOGWIQcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDo1NDowOFrOGWIQcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1NzEzNw==", "bodyText": "@tristantarrant How about this as a tip to assign priority to sites?", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425857137", "createdAt": "2020-05-15T14:54:08Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,61 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n+\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//dnaro: notes for IRAC conflict resolution\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is not strictly greater or less between **LON** and **NYC**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+When it finds conflicting entries, {brandname} uses the Java `compareTo(String\n+anotherString)` method to compare site names. To determine which key takes\n+priority, {brandname} selects the site name that is lexicographically less\n+than the other. Keys from a site named **AAA** take priority over keys from a\n+site named **AAB** and so on.\n \n-//Following the same example, if \"k1\" conflicts between **LON** and **NYC**,\n-//{brandname} always uses \"k1\" in **LON**.\n+Following the same example, to resolve the conflict for \"k1\", {brandname} uses\n+the value for \"k1\" that originates from **LON**. This results in \"k1=5\" in both\n+**LON** and **NYC** after {brandname} resolves the conflict and replicates the\n+value.\n+\n+[TIP]\n+====\n+Prepend site names with numbers as a simple way to represent the order of\n+priority for resolving conflicting entries; for example, **1LON** and **2NYC**.\n+====", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06893859b617d2bb99aac03c29774e2c4fce3475"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4175, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}