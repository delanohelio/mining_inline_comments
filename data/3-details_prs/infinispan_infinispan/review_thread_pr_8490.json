{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2MTU0NTI4", "number": 8490, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoxNzoyMVrOEGsHow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzozMTo1NVrOEHqqVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDQ5NzYzOnYy", "diffSide": "RIGHT", "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoxNzoyMVrOGlo-1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTo1MTozOFrOGmBbFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMTk0Mg==", "bodyText": "Ideally we shouldn't be adding SQL to the src/main files just for use in test cases. This SQL is part of the standard, so it should run on all DBs, i.e. no need to override this SQL on a per DB level, so I think you should just use this directly in your test TableManipulation class.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442121942", "createdAt": "2020-06-18T10:17:21Z", "author": {"login": "ryanemerson"}, "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "diffHunk": "@@ -294,18 +298,36 @@ protected String initSelectIdRowSql() {\n       return String.format(\"SELECT %s FROM %s WHERE %s = ?\", config.idColumnName(), tableName, config.idColumnName());\n    }\n \n+   protected String initSelectIdRowSqlWithLike() {\n+      return String.format(\"SELECT %s FROM %s WHERE %s LIKE ?\", config.idColumnName(), tableName, config.idColumnName());\n+   }\n+\n    @Override\n    public String getSelectIdRowSql() {\n       return selectIdRowSql;\n    }\n \n+   @Override\n+   public String getSelectIdRowSqlWithLike() {\n+      return selectIdRowSqlWithLike;\n+   }\n+\n    protected String initCountNonExpiredRowsSql() {\n       return \"SELECT COUNT(*) FROM \" + tableName +\n             \" WHERE \" + config.timestampColumnName() + \" < 0 OR \" + config.timestampColumnName() + \" > ?\";\n    }\n \n+   protected String initCountRowsSql() {\n+      return \"SELECT COUNT(*) FROM \" + tableName;\n+   }\n+\n    @Override\n    public String getCountNonExpiredRowsSql() {\n+      return countNonExpiredRowsSql;\n+   }\n+\n+   @Override\n+   public String getCountRowsSql() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyMjM4OA==", "bodyText": "@ryanemerson updated", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442522388", "createdAt": "2020-06-18T21:51:38Z", "author": {"login": "gustavolira"}, "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "diffHunk": "@@ -294,18 +298,36 @@ protected String initSelectIdRowSql() {\n       return String.format(\"SELECT %s FROM %s WHERE %s = ?\", config.idColumnName(), tableName, config.idColumnName());\n    }\n \n+   protected String initSelectIdRowSqlWithLike() {\n+      return String.format(\"SELECT %s FROM %s WHERE %s LIKE ?\", config.idColumnName(), tableName, config.idColumnName());\n+   }\n+\n    @Override\n    public String getSelectIdRowSql() {\n       return selectIdRowSql;\n    }\n \n+   @Override\n+   public String getSelectIdRowSqlWithLike() {\n+      return selectIdRowSqlWithLike;\n+   }\n+\n    protected String initCountNonExpiredRowsSql() {\n       return \"SELECT COUNT(*) FROM \" + tableName +\n             \" WHERE \" + config.timestampColumnName() + \" < 0 OR \" + config.timestampColumnName() + \" > ?\";\n    }\n \n+   protected String initCountRowsSql() {\n+      return \"SELECT COUNT(*) FROM \" + tableName;\n+   }\n+\n    @Override\n    public String getCountNonExpiredRowsSql() {\n+      return countNonExpiredRowsSql;\n+   }\n+\n+   @Override\n+   public String getCountRowsSql() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMTk0Mg=="}, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDUwMDU5OnYy", "diffSide": "RIGHT", "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoxODowM1rOGlpAlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoxODowM1rOGlpAlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMjM4OA==", "bodyText": "Should also just be in the test TableManipulation class.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442122388", "createdAt": "2020-06-18T10:18:03Z", "author": {"login": "ryanemerson"}, "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "diffHunk": "@@ -294,18 +298,36 @@ protected String initSelectIdRowSql() {\n       return String.format(\"SELECT %s FROM %s WHERE %s = ?\", config.idColumnName(), tableName, config.idColumnName());\n    }\n \n+   protected String initSelectIdRowSqlWithLike() {\n+      return String.format(\"SELECT %s FROM %s WHERE %s LIKE ?\", config.idColumnName(), tableName, config.idColumnName());\n+   }\n+\n    @Override\n    public String getSelectIdRowSql() {\n       return selectIdRowSql;\n    }\n \n+   @Override\n+   public String getSelectIdRowSqlWithLike() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDUwNjA2OnYy", "diffSide": "RIGHT", "path": "server/tests/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoxOTo0N1rOGlpEKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoxOTo0N1rOGlpEKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMzMwNA==", "bodyText": "We should define this version in the root pom.xml like we do for h2, e.g. <versionx.com.h2database.h2/>", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442123304", "createdAt": "2020-06-18T10:19:47Z", "author": {"login": "ryanemerson"}, "path": "server/tests/pom.xml", "diffHunk": "@@ -73,6 +73,18 @@\n          <artifactId>h2</artifactId>\n          <scope>test</scope>\n       </dependency>\n+      <dependency>\n+         <groupId>mysql</groupId>\n+         <artifactId>mysql-connector-java</artifactId>\n+         <version>8.0.20</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDUwNjQ2OnYy", "diffSide": "RIGHT", "path": "server/tests/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoxOTo1NlrOGlpEbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTo1MTo1M1rOGmBbaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMzM3Mg==", "bodyText": "We should define this version in the root pom.xml like we do for h2, e.g. <versionx.com.h2database.h2/>", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442123372", "createdAt": "2020-06-18T10:19:56Z", "author": {"login": "ryanemerson"}, "path": "server/tests/pom.xml", "diffHunk": "@@ -73,6 +73,18 @@\n          <artifactId>h2</artifactId>\n          <scope>test</scope>\n       </dependency>\n+      <dependency>\n+         <groupId>mysql</groupId>\n+         <artifactId>mysql-connector-java</artifactId>\n+         <version>8.0.20</version>\n+         <scope>test</scope>\n+      </dependency>\n+      <dependency>\n+         <groupId>org.postgresql</groupId>\n+         <artifactId>postgresql</artifactId>\n+         <version>42.2.5</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyMjQ3Mg==", "bodyText": "done", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442522472", "createdAt": "2020-06-18T21:51:53Z", "author": {"login": "gustavolira"}, "path": "server/tests/pom.xml", "diffHunk": "@@ -73,6 +73,18 @@\n          <artifactId>h2</artifactId>\n          <scope>test</scope>\n       </dependency>\n+      <dependency>\n+         <groupId>mysql</groupId>\n+         <artifactId>mysql-connector-java</artifactId>\n+         <version>8.0.20</version>\n+         <scope>test</scope>\n+      </dependency>\n+      <dependency>\n+         <groupId>org.postgresql</groupId>\n+         <artifactId>postgresql</artifactId>\n+         <version>42.2.5</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMzM3Mg=="}, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDUxMjQ4OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/TableManipulation.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoyMTo0NFrOGlpISg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQxODozMTo0N1rOGmnxGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNDM2Mg==", "bodyText": "You need to make sure the resources returned by TableManipulation are always closed after a test has finished ... this is probably the cause of the ThreadLeakChecker failures.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442124362", "createdAt": "2020-06-18T10:21:44Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/TableManipulation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.infinispan.server.persistence;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+\n+import org.infinispan.commons.marshall.ProtoStreamMarshaller;\n+import org.infinispan.commons.marshall.WrappedByteArray;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfiguration;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.connectionfactory.ConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.connectionfactory.PooledConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.table.TableManager;\n+import org.infinispan.persistence.jdbc.impl.table.TableManagerFactory;\n+import org.infinispan.persistence.keymappers.DefaultTwoWayKey2StringMapper;\n+\n+public class TableManipulation {\n+\n+   private String cacheName;\n+   private ConnectionFactory connectionFactory;\n+   private Connection connection;\n+   private PooledConnectionFactoryConfigurationBuilder persistenceConfiguration;\n+   private ConfigurationBuilder configurationBuilder;\n+\n+   public TableManipulation(String cacheName, PooledConnectionFactoryConfigurationBuilder persistenceConfiguration, ConfigurationBuilder configurationBuilder) {\n+      this.cacheName = cacheName;\n+      this.persistenceConfiguration = persistenceConfiguration;\n+      this.configurationBuilder = configurationBuilder;\n+   }\n+\n+   private ConnectionFactory getConnectionFactory() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyMzM5Ng==", "bodyText": "@ryanemerson I fixed some ThreadLeakChecker but there's one ThreadLeak that is still happening, I don't know why it's happening.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442523396", "createdAt": "2020-06-18T21:54:16Z", "author": {"login": "gustavolira"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/TableManipulation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.infinispan.server.persistence;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+\n+import org.infinispan.commons.marshall.ProtoStreamMarshaller;\n+import org.infinispan.commons.marshall.WrappedByteArray;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfiguration;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.connectionfactory.ConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.connectionfactory.PooledConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.table.TableManager;\n+import org.infinispan.persistence.jdbc.impl.table.TableManagerFactory;\n+import org.infinispan.persistence.keymappers.DefaultTwoWayKey2StringMapper;\n+\n+public class TableManipulation {\n+\n+   private String cacheName;\n+   private ConnectionFactory connectionFactory;\n+   private Connection connection;\n+   private PooledConnectionFactoryConfigurationBuilder persistenceConfiguration;\n+   private ConfigurationBuilder configurationBuilder;\n+\n+   public TableManipulation(String cacheName, PooledConnectionFactoryConfigurationBuilder persistenceConfiguration, ConfigurationBuilder configurationBuilder) {\n+      this.cacheName = cacheName;\n+      this.persistenceConfiguration = persistenceConfiguration;\n+      this.configurationBuilder = configurationBuilder;\n+   }\n+\n+   private ConnectionFactory getConnectionFactory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNDM2Mg=="}, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMjMxNg==", "bodyText": "@wburns Can you remember what was leaking the agroal connection on your PR before?", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442702316", "createdAt": "2020-06-19T08:19:10Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/TableManipulation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.infinispan.server.persistence;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+\n+import org.infinispan.commons.marshall.ProtoStreamMarshaller;\n+import org.infinispan.commons.marshall.WrappedByteArray;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfiguration;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.connectionfactory.ConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.connectionfactory.PooledConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.table.TableManager;\n+import org.infinispan.persistence.jdbc.impl.table.TableManagerFactory;\n+import org.infinispan.persistence.keymappers.DefaultTwoWayKey2StringMapper;\n+\n+public class TableManipulation {\n+\n+   private String cacheName;\n+   private ConnectionFactory connectionFactory;\n+   private Connection connection;\n+   private PooledConnectionFactoryConfigurationBuilder persistenceConfiguration;\n+   private ConfigurationBuilder configurationBuilder;\n+\n+   public TableManipulation(String cacheName, PooledConnectionFactoryConfigurationBuilder persistenceConfiguration, ConfigurationBuilder configurationBuilder) {\n+      this.cacheName = cacheName;\n+      this.persistenceConfiguration = persistenceConfiguration;\n+      this.configurationBuilder = configurationBuilder;\n+   }\n+\n+   private ConnectionFactory getConnectionFactory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNDM2Mg=="}, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg4Mjc4OA==", "bodyText": "Mine was a bug in the start method of the PersistenceManagerImpl, I highly doubt it is related and it shouldn't be able to resurface now.\nhttps://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java#L198", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r442882788", "createdAt": "2020-06-19T14:46:44Z", "author": {"login": "wburns"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/TableManipulation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.infinispan.server.persistence;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+\n+import org.infinispan.commons.marshall.ProtoStreamMarshaller;\n+import org.infinispan.commons.marshall.WrappedByteArray;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfiguration;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.connectionfactory.ConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.connectionfactory.PooledConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.table.TableManager;\n+import org.infinispan.persistence.jdbc.impl.table.TableManagerFactory;\n+import org.infinispan.persistence.keymappers.DefaultTwoWayKey2StringMapper;\n+\n+public class TableManipulation {\n+\n+   private String cacheName;\n+   private ConnectionFactory connectionFactory;\n+   private Connection connection;\n+   private PooledConnectionFactoryConfigurationBuilder persistenceConfiguration;\n+   private ConfigurationBuilder configurationBuilder;\n+\n+   public TableManipulation(String cacheName, PooledConnectionFactoryConfigurationBuilder persistenceConfiguration, ConfigurationBuilder configurationBuilder) {\n+      this.cacheName = cacheName;\n+      this.persistenceConfiguration = persistenceConfiguration;\n+      this.configurationBuilder = configurationBuilder;\n+   }\n+\n+   private ConnectionFactory getConnectionFactory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNDM2Mg=="}, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1MDYxNg==", "bodyText": "@ryanemerson I removed the dependency from TableManager and fixed all thread leaker", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443150616", "createdAt": "2020-06-20T18:31:47Z", "author": {"login": "gustavolira"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/TableManipulation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.infinispan.server.persistence;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+\n+import org.infinispan.commons.marshall.ProtoStreamMarshaller;\n+import org.infinispan.commons.marshall.WrappedByteArray;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfiguration;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.connectionfactory.ConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.connectionfactory.PooledConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.table.TableManager;\n+import org.infinispan.persistence.jdbc.impl.table.TableManagerFactory;\n+import org.infinispan.persistence.keymappers.DefaultTwoWayKey2StringMapper;\n+\n+public class TableManipulation {\n+\n+   private String cacheName;\n+   private ConnectionFactory connectionFactory;\n+   private Connection connection;\n+   private PooledConnectionFactoryConfigurationBuilder persistenceConfiguration;\n+   private ConfigurationBuilder configurationBuilder;\n+\n+   public TableManipulation(String cacheName, PooledConnectionFactoryConfigurationBuilder persistenceConfiguration, ConfigurationBuilder configurationBuilder) {\n+      this.cacheName = cacheName;\n+      this.persistenceConfiguration = persistenceConfiguration;\n+      this.configurationBuilder = configurationBuilder;\n+   }\n+\n+   private ConnectionFactory getConnectionFactory() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNDM2Mg=="}, "originalCommit": {"oid": "dfa7fd4d14e73ddbc9eeff5ec4e80ccb976ef5ab"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzEzODU4OnYy", "diffSide": "RIGHT", "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoyMTo0NVrOGm6r_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoyMTo0NVrOGm6r_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MDYwNA==", "bodyText": "This method is never used", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443460604", "createdAt": "2020-06-22T10:21:45Z", "author": {"login": "ryanemerson"}, "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "diffHunk": "@@ -294,6 +294,10 @@ protected String initSelectIdRowSql() {\n       return String.format(\"SELECT %s FROM %s WHERE %s = ?\", config.idColumnName(), tableName, config.idColumnName());\n    }\n \n+   protected String initSelectIdRowSqlWithLike() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzE0MDY4OnYy", "diffSide": "RIGHT", "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoyMjoyNVrOGm6tRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoyMjoyNVrOGm6tRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MDkzNA==", "bodyText": "As this will be the only change to the production files, I think we should revert it.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443460934", "createdAt": "2020-06-22T10:22:25Z", "author": {"login": "ryanemerson"}, "path": "persistence/jdbc/src/main/java/org/infinispan/persistence/jdbc/impl/table/AbstractTableManager.java", "diffHunk": "@@ -72,7 +72,7 @@\n       this.selectIdRowSql = initSelectIdRowSql();\n       this.deleteRowSql = initDeleteRowSql();\n       this.loadAllRowsSql = initLoadAllRowsSql();\n-      this.countRowsSql = initCountNonExpiredRowsSql();\n+      this.countNonExpiredRowsSql = initCountNonExpiredRowsSql();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzE2MTk2OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcConfigurationUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoyODo1NFrOGm66Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoyODo1NFrOGm66Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2NDI3OA==", "bodyText": "This method is always called after directly after the instance is created, e.g. new JdbcConfigurationUtil().createPersistenceConfiguration() ... why not just add these params to the constructor so that we can just do:\nnew JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, false).setEviction() etc.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443464278", "createdAt": "2020-06-22T10:28:54Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcConfigurationUtil.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package org.infinispan.server.persistence;\n+\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfigurationBuilder;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+\n+public class JdbcConfigurationUtil {\n+\n+    private PooledConnectionFactoryConfigurationBuilder persistenceConfiguration;\n+    private ConfigurationBuilder configurationBuilder;\n+    private CacheMode cacheMode;\n+\n+    public JdbcConfigurationUtil(CacheMode cacheMode) {\n+        configurationBuilder = new ConfigurationBuilder();\n+        this.cacheMode = cacheMode;\n+    }\n+\n+    public JdbcConfigurationUtil createPersistenceConfiguration(Database database, boolean passivation, boolean preload) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzE3MTIxOnYy", "diffSide": "RIGHT", "path": "server/testdriver/junit4/src/main/java/org/infinispan/server/test/junit4/InfinispanServerRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozMTo0MlrOGm7AIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNTo1NTozN1rOGnG-1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2NTc2Mg==", "bodyText": "Why is this change required?", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443465762", "createdAt": "2020-06-22T10:31:42Z", "author": {"login": "ryanemerson"}, "path": "server/testdriver/junit4/src/main/java/org/infinispan/server/test/junit4/InfinispanServerRule.java", "diffHunk": "@@ -78,8 +78,8 @@ public void evaluate() throws Throwable {\n             } finally {\n                InfinispanServerRule.this.after(testName);\n                if (manageServer && testServer.isDriverInitialized()) {\n-                  testServer.afterListeners();\n                   testServer.getDriver().stop(testName);\n+                  testServer.afterListeners();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2MjAzOA==", "bodyText": "@ryanemerson Without this change we will receive SocketTimeoutException: connect timed out a lot", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443662038", "createdAt": "2020-06-22T15:55:37Z", "author": {"login": "gustavolira"}, "path": "server/testdriver/junit4/src/main/java/org/infinispan/server/test/junit4/InfinispanServerRule.java", "diffHunk": "@@ -78,8 +78,8 @@ public void evaluate() throws Throwable {\n             } finally {\n                InfinispanServerRule.this.after(testName);\n                if (manageServer && testServer.isDriverInitialized()) {\n-                  testServer.afterListeners();\n                   testServer.getDriver().stop(testName);\n+                  testServer.afterListeners();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2NTc2Mg=="}, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzE3Mzk0OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/functional/MemcachedOperations.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozMjozNlrOGm7B2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozMjozNlrOGm7B2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2NjIwMA==", "bodyText": "These changes seem fine, but do they belong in this commit? They aren't related to JDBC.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443466200", "createdAt": "2020-06-22T10:32:36Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/functional/MemcachedOperations.java", "diffHunk": "@@ -28,4 +33,37 @@ public void testMemcachedOperations() {\n       cache.set(\"k1\", 0, \"v1\");\n       assertEquals(\"v1\", cache.get(\"k1\"));\n    }\n+\n+   @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzE3NzY4OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/functional/RestOperations.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozMzo1MFrOGm7EIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozMzo1MFrOGm7EIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2Njc4Nw==", "bodyText": "Again this seems fine, but it isn't related to the current commit and Jira ticket. If you want to add this test, create a new Jira and add as a separate commit please.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443466787", "createdAt": "2020-06-22T10:33:50Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/functional/RestOperations.java", "diffHunk": "@@ -73,6 +74,19 @@ public void testRestOperations() {\n       assertEquals(protocol, response.getProtocol());\n    }\n \n+   @Test\n+   public void testPutWithTimeToLive() throws InterruptedException {\n+      RestClientConfigurationBuilder builder = new RestClientConfigurationBuilder();\n+      builder.protocol(protocol);\n+      RestClient client = SERVER_TEST.rest().withClientConfiguration(builder).create();\n+      RestCacheClient cache = client.cache(SERVER_TEST.getMethodName());\n+      sync(cache.post(\"k1\", \"v1\", 1, 1));\n+      assertEquals(HttpResponseStatus.OK.code(), sync(cache.get(\"k1\")).getStatus());\n+      Thread.sleep(2000);\n+      assertEquals(HttpResponseStatus.NOT_FOUND.code(), sync(cache.get(\"k1\")).getStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzE4MzIxOnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/AsyncJdbcStringBasedCacheStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozNTozMlrOGm7HnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDozNTozMlrOGm7HnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2NzY3Ng==", "bodyText": "< ... same for the other for loops.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443467676", "createdAt": "2020-06-22T10:35:32Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/AsyncJdbcStringBasedCacheStore.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class AsyncJdbcStringBasedCacheStore {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    public AsyncJdbcStringBasedCacheStore(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPutRemove() throws Exception {\n+        int numEntries = 10;\n+        String keyPrefix = \"testPutRemove-k-\";\n+        String valuePrefix = \"testPutRemove-k-\";\n+\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        // test PUT operation\n+        for (int i = 0; i != numEntries; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzIxNDIyOnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationDisabled.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo0NjoxN1rOGm7bXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo0NjoxN1rOGm7bXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3MjczMw==", "bodyText": "This isn't testing that preload works, as it is just checking the cache size which will include the loaders. Instead you should assert that the entry is in-memory by doing cache.withFlags(Flag.SKIP_CACHE_LOAD).size()", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443472733", "createdAt": "2020-06-22T10:46:17Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationDisabled.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivationDisabled {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivationDisabled(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+        // test passivation==false, database should contain all entries which are in the cache\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        assertNotNull(table.getValueByKey(\"k2\"));\n+\n+        SERVERS.getServerDriver().stop(0);\n+        SERVERS.getServerDriver().restart(0);\n+\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        assertNotNull(table.getValueByKey(\"k2\"));\n+        assertEquals(\"v1\", cache.get(\"k1\"));\n+        assertEquals(\"v2\", cache.get(\"k2\"));\n+        //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+        //and the cache are the same sets of keys)\n+        cache.remove(\"k1\");\n+        assertNull(table.getValueByKey(\"k1\"));\n+        cache.clear();\n+        table.releaseConnection();\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurge() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.clear();\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        assertNotNull(table.getValueByKey(\"k2\"));\n+\n+        SERVERS.getServerDriver().stop(0);\n+        SERVERS.getServerDriver().restart(0);\n+\n+        // test preload==true, entries should be immediately in the cache after restart\n+        assertEquals(2, cache.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzIxODMwOnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationDisabled.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo0Nzo0MVrOGm7d3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo0Nzo0MVrOGm7d3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3MzM3NA==", "bodyText": "It's probably worth ensuring that the key is not in-memory first, so assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k1\") followed by assertEquals(\"v1\", cache.get(\"k1\"));", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443473374", "createdAt": "2020-06-22T10:47:41Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationDisabled.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivationDisabled {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivationDisabled(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+        // test passivation==false, database should contain all entries which are in the cache\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        assertNotNull(table.getValueByKey(\"k2\"));\n+\n+        SERVERS.getServerDriver().stop(0);\n+        SERVERS.getServerDriver().restart(0);\n+\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        assertNotNull(table.getValueByKey(\"k2\"));\n+        assertEquals(\"v1\", cache.get(\"k1\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzIyNzIzOnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/TableManipulation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo1MDo0M1rOGm7jjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo1MDo0M1rOGm7jjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3NDgzMQ==", "bodyText": "If we adapt this to implements AutoCloseable, we can move the releaseConnection logic to the stop() implementation and then just do the following when using the code:\ntry (TableManipulation tm = new TableManipulation(..)) {\n // Test logic\n}", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443474831", "createdAt": "2020-06-22T10:50:43Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/TableManipulation.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.server.persistence;\n+\n+import java.sql.Connection;\n+import java.sql.Driver;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Enumeration;\n+\n+import org.infinispan.commons.marshall.ProtoStreamMarshaller;\n+import org.infinispan.commons.marshall.WrappedByteArray;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.JdbcUtil;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfiguration;\n+import org.infinispan.persistence.jdbc.configuration.PooledConnectionFactoryConfigurationBuilder;\n+import org.infinispan.persistence.jdbc.connectionfactory.ConnectionFactory;\n+import org.infinispan.persistence.jdbc.impl.connectionfactory.PooledConnectionFactory;\n+import org.infinispan.persistence.keymappers.DefaultTwoWayKey2StringMapper;\n+\n+import com.mysql.cj.jdbc.AbandonedConnectionCleanupThread;\n+\n+public class TableManipulation {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzIzNTU2OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationEnabled.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo1MzoxMVrOGm7otQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo1MzoxMVrOGm7otQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3NjE0OQ==", "bodyText": "There's no need todo this via REST. We can just utilise Flag.SKIP_CACHE_LOAD.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443476149", "createdAt": "2020-06-22T10:53:11Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationEnabled.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == true --cache entries should get to the cache store only when evicted\n+ * preload == false --after server restart, entries should NOT be preloaded to the cache\n+ * purge == false --all entries should remain in the cache store after server restart\n+ * (must be false so that we can test preload)\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivationEnabled {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivationEnabled(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPassivateAfterEviction() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, true, false)\n+                .setEvition()\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+        //not yet in store (eviction size=2)\n+        assertTrue(table.getValueByKey(\"k1\") == null);\n+        assertTrue(table.getValueByKey(\"k2\") == null);\n+        cache.put(\"k3\", \"v3\");\n+        assertEquals(\"v3\", cache.get(\"k3\"));\n+        ///now some key is evicted and stored in store\n+        assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+        assertEquals(1, table.countAllRows());\n+        assertNotNull(table.getValueByKey(\"k1\"));\n+        table.releaseConnection();\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testSoftRestartWithoutPreload() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, true, false)\n+                .setEvition()\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+        //not yet in store (eviction.max-entries=2, LRU)\n+        assertTrue(table.getValueByKey(\"k1\") == null);\n+        assertTrue(table.getValueByKey(\"k2\") == null);\n+        cache.put(\"k3\", \"v3\");\n+        //now some key is evicted and stored in store\n+        assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+        assertEquals(1, table.countAllRows());\n+        SERVERS.getServerDriver().stop(0);\n+        SERVERS.getServerDriver().restart(0); //soft stop should store all entries from cache to store\n+\n+        // test preload==false\n+        assertEquals(0, getNumberOfEntriesInMemory(cache.getName()));\n+        // test purge==false, entries should remain in the database after restart\n+        assertEquals(3, table.countAllRows());\n+        assertEquals(\"v1\", cache.get(\"k1\"));\n+        table.releaseConnection();\n+    }\n+\n+    /**\n+     * This test differs from the preceding expecting 1 entry in the DB\n+     * after fail-over instead of 3 when doing soft\n+     * restart.\n+     */\n+    @Test(timeout = 600000)\n+    public void testFailoverWithoutPreload() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC)\n+                .createPersistenceConfiguration(database, true, false)\n+                .setEvition()\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder());\n+\n+        cache.put(\"k1\", \"v1\");\n+        cache.put(\"k2\", \"v2\");\n+        assertTrue(table.getValueByKey(\"k1\") == null);\n+        assertTrue(table.getValueByKey(\"k2\") == null);\n+        cache.put(\"k3\", \"v3\");\n+        assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+        assertEquals(1, table.countAllRows());\n+        SERVERS.getServerDriver().kill(0);\n+        SERVERS.getServerDriver().restart(0);\n+        assertEquals(0, getNumberOfEntriesInMemory(cache.getName()));\n+        assertEquals(1, table.countAllRows());\n+        assertEquals(\"v1\", cache.get(\"k1\"));\n+        table.releaseConnection();\n+    }\n+\n+    private int getNumberOfEntriesInMemory(String cacheName) throws JsonProcessingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzI1Mjc4OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationEnabled.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo1ODo1OFrOGm7zpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDo1ODo1OFrOGm7zpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ3ODk1MA==", "bodyText": "I think we should consolidate the two JdbcStringBasedCacheStorePassivation* tests into a single JdbcStringBasedCacheStore test. We can then just use the method names to distinguish the preload enabled/disabled tests.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443478950", "createdAt": "2020-06-22T10:58:58Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivationEnabled.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == true --cache entries should get to the cache store only when evicted\n+ * preload == false --after server restart, entries should NOT be preloaded to the cache\n+ * purge == false --all entries should remain in the cache store after server restart\n+ * (must be false so that we can test preload)\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivationEnabled {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivationEnabled(String databaseType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fdc2b544ffa357c020e2bb97fd7cd93019e4fe0"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDY5NTE0OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/AsyncJdbcStringBasedCacheStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoxNjo0NlrOGnJ7_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoxNjo0NlrOGnJ7_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMDQ2Mg==", "bodyText": "<", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443710462", "createdAt": "2020-06-22T17:16:46Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/AsyncJdbcStringBasedCacheStore.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class AsyncJdbcStringBasedCacheStore {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    public AsyncJdbcStringBasedCacheStore(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPutRemove() throws Exception {\n+        int numEntries = 10;\n+        String keyPrefix = \"testPutRemove-k-\";\n+        String valuePrefix = \"testPutRemove-k-\";\n+\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            // test PUT operation\n+            for (int i = 0; i < numEntries; i++) {\n+                cache.putAsync(keyPrefix+i, valuePrefix+i).toCompletableFuture().get();\n+            }\n+\n+            assertCountRow(table.countAllRows(), numEntries);\n+            for (int i = 0; i != numEntries; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDY5OTg5OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoxODowOFrOGnJ_BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoxODowOFrOGnJ_BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMTIzNg==", "bodyText": "This is failing checkstyle.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443711236", "createdAt": "2020-06-22T17:18:08Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.clear();\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            // test preload==true, entries should be immediately in the cache after restart\n+            assertEquals(2, cache.size());\n+            // test purge==false, entries should remain in the database after restart\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+        }\n+;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDcwNTA1OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoxOTo1NlrOGnKCkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoxOTo1NlrOGnKCkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMjE0NQ==", "bodyText": "Lots of empty lines where you've added the try() {} blocks, can you remove please.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443712145", "createdAt": "2020-06-22T17:19:56Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDcxMzEzOnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoyMjowM1rOGnKHWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoyMjowM1rOGnKHWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxMzM3MA==", "bodyText": "This test is identical to the contents of testSoftRestartWithoutPreloadPassivationEnabled AFAICT, except it does not have the restart. testSoftRestartWithoutPreloadPassivationEnabled should be sufficient`", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443713370", "createdAt": "2020-06-22T17:22:03Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.clear();\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            // test preload==true, entries should be immediately in the cache after restart\n+            assertEquals(2, cache.size());\n+            // test purge==false, entries should remain in the database after restart\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+        }\n+;\n+    }\n+\n+    /*\n+     * This should verify that DefaultTwoWayKey2StringMapper on server side can work with ByteArrayKey which\n+     * is always produced by HotRod client regardless of type of key being stored in a cache.\n+     */\n+    @Test(timeout = 600000)\n+    public void testStoreDataWithHotRodClientPassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<Object, Object> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            Double doubleKey = 10.0;\n+            Double doubleValue = 20.0;\n+\n+            assertEquals(0, cache.size());\n+            assertTrue(table.countAllRows() == 0);\n+            cache.put(doubleKey, doubleValue);\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertEquals(1, table.countAllRows());\n+            assertEquals(doubleValue, cache.get(doubleKey));\n+        }\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPassivateAfterEvictionPassivationEnabled() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDczODEzOnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoyOTo0OFrOGnKXog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzoyOTo0OFrOGnKXog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNzUzOA==", "bodyText": "testDefaultTwoWayKey2StringMapper? That way the test name reflects what we're trying to test.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443717538", "createdAt": "2020-06-22T17:29:48Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.clear();\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            // test preload==true, entries should be immediately in the cache after restart\n+            assertEquals(2, cache.size());\n+            // test purge==false, entries should remain in the database after restart\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+        }\n+;\n+    }\n+\n+    /*\n+     * This should verify that DefaultTwoWayKey2StringMapper on server side can work with ByteArrayKey which\n+     * is always produced by HotRod client regardless of type of key being stored in a cache.\n+     */\n+    @Test(timeout = 600000)\n+    public void testStoreDataWithHotRodClientPassivationFalse() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDc0MDE1OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzozMDoyN1rOGnKZBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzozMDoyN1rOGnKZBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNzg5Mg==", "bodyText": "The default behaviour is for purge = false; passivation = false, so I think testPreload() is sufficient.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443717892", "createdAt": "2020-06-22T17:30:27Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDc0MDcwOnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzozMDozN1rOGnKZWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzozMjoyM1rOGnKczg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNzk3OQ==", "bodyText": "testFailover()", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443717979", "createdAt": "2020-06-22T17:30:37Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxODg2Mg==", "bodyText": "Btw we should not have a timeout on any test, testng listener will handle that.", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443718862", "createdAt": "2020-06-22T17:32:23Z", "author": {"login": "wburns"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNzk3OQ=="}, "originalCommit": {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDc0Mjc3OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzozMToxN1rOGnKawA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzozMToxN1rOGnKawA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxODMzNg==", "bodyText": "testSoftRestartWithPassivation", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443718336", "createdAt": "2020-06-22T17:31:17Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.clear();\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            // test preload==true, entries should be immediately in the cache after restart\n+            assertEquals(2, cache.size());\n+            // test purge==false, entries should remain in the database after restart\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+        }\n+;\n+    }\n+\n+    /*\n+     * This should verify that DefaultTwoWayKey2StringMapper on server side can work with ByteArrayKey which\n+     * is always produced by HotRod client regardless of type of key being stored in a cache.\n+     */\n+    @Test(timeout = 600000)\n+    public void testStoreDataWithHotRodClientPassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<Object, Object> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            Double doubleKey = 10.0;\n+            Double doubleValue = 20.0;\n+\n+            assertEquals(0, cache.size());\n+            assertTrue(table.countAllRows() == 0);\n+            cache.put(doubleKey, doubleValue);\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertEquals(1, table.countAllRows());\n+            assertEquals(doubleValue, cache.get(doubleKey));\n+        }\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPassivateAfterEvictionPassivationEnabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, true, false)\n+              .setEvition()\n+              .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            //not yet in store (eviction size=2)\n+            assertTrue(table.getValueByKey(\"k1\") == null);\n+            assertTrue(table.getValueByKey(\"k2\") == null);\n+            cache.put(\"k3\", \"v3\");\n+            assertEquals(\"v3\", cache.get(\"k3\"));\n+            ///now some key is evicted and stored in store\n+            assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+            assertEquals(1, table.countAllRows());\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testSoftRestartWithoutPreloadPassivationEnabled() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDc0NDU1OnYy", "diffSide": "RIGHT", "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzozMTo1NVrOGnKcAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzozMTo1NVrOGnKcAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxODY1OA==", "bodyText": "testFailoverWithPassivation", "url": "https://github.com/infinispan/infinispan/pull/8490#discussion_r443718658", "createdAt": "2020-06-22T17:31:55Z", "author": {"login": "ryanemerson"}, "path": "server/tests/src/test/java/org/infinispan/server/persistence/JdbcStringBasedCacheStorePassivation.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.infinispan.server.persistence;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.infinispan.client.hotrod.Flag;\n+import org.infinispan.client.hotrod.RemoteCache;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.server.test.core.category.Persistence;\n+import org.infinispan.server.test.core.persistence.Database;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests String-based jdbc cache store under the following circumstances:\n+ * <p>\n+ * passivation == false --all cache entries should always be also in the cache store\n+ * preload == true --after server restart, all entries should appear in the cache immediately\n+ * purge == false --all entries should remain in the cache store after server  * restart\n+ * <p>\n+ * Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.\n+ *\n+ */\n+@Category(Persistence.class)\n+@RunWith(Parameterized.class)\n+public class JdbcStringBasedCacheStorePassivation {\n+\n+    @ClassRule\n+    public static InfinispanServerRule SERVERS = PersistenceIT.SERVERS;\n+\n+    @Rule\n+    public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+    private final Database database;\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Collection<Object[]> data() {\n+        String[] databaseTypes = PersistenceIT.DATABASE.getDatabaseTypes();\n+        List<Object[]> params = new ArrayList<>(databaseTypes.length);\n+        for (String databaseType : databaseTypes) {\n+            params.add(new Object[]{databaseType});\n+        }\n+        return params;\n+    }\n+\n+    public JdbcStringBasedCacheStorePassivation(String databaseType) {\n+        this.database = PersistenceIT.DATABASE.getDatabase(databaseType);\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testFailoverWithPassivationDisabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+            assertNull(cache.withFlags(Flag.SKIP_CACHE_LOAD).get(\"k3\"));\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+            assertEquals(\"v2\", cache.get(\"k2\"));\n+            //when the entry is removed from the cache, it should be also removed from the cache store (the store\n+            //and the cache are the same sets of keys)\n+            cache.remove(\"k1\");\n+            assertNull(table.getValueByKey(\"k1\"));\n+            cache.clear();\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPreloadWithoutPurgePassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.clear();\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0);\n+\n+            // test preload==true, entries should be immediately in the cache after restart\n+            assertEquals(2, cache.size());\n+            // test purge==false, entries should remain in the database after restart\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+            assertNotNull(table.getValueByKey(\"k2\"));\n+        }\n+;\n+    }\n+\n+    /*\n+     * This should verify that DefaultTwoWayKey2StringMapper on server side can work with ByteArrayKey which\n+     * is always produced by HotRod client regardless of type of key being stored in a cache.\n+     */\n+    @Test(timeout = 600000)\n+    public void testStoreDataWithHotRodClientPassivationFalse() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, false, true)\n+                .setLockingConfigurations();\n+        RemoteCache<Object, Object> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            Double doubleKey = 10.0;\n+            Double doubleValue = 20.0;\n+\n+            assertEquals(0, cache.size());\n+            assertTrue(table.countAllRows() == 0);\n+            cache.put(doubleKey, doubleValue);\n+            // test passivation==false, database should contain all entries which are in the cache\n+            assertEquals(1, table.countAllRows());\n+            assertEquals(doubleValue, cache.get(doubleKey));\n+        }\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testPassivateAfterEvictionPassivationEnabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, true, false)\n+              .setEvition()\n+              .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            //not yet in store (eviction size=2)\n+            assertTrue(table.getValueByKey(\"k1\") == null);\n+            assertTrue(table.getValueByKey(\"k2\") == null);\n+            cache.put(\"k3\", \"v3\");\n+            assertEquals(\"v3\", cache.get(\"k3\"));\n+            ///now some key is evicted and stored in store\n+            assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+            assertEquals(1, table.countAllRows());\n+            assertNotNull(table.getValueByKey(\"k1\"));\n+        }\n+\n+    }\n+\n+    @Test(timeout = 600000)\n+    public void testSoftRestartWithoutPreloadPassivationEnabled() throws Exception {\n+        JdbcConfigurationUtil jdbcUtil = new JdbcConfigurationUtil(CacheMode.REPL_SYNC, database, true, false)\n+              .setEvition()\n+              .setLockingConfigurations();\n+        RemoteCache<String, String> cache = SERVER_TEST.hotrod().withServerConfiguration(jdbcUtil.getConfigurationBuilder()).create();\n+        try(TableManipulation table = new TableManipulation(cache.getName(), jdbcUtil.getPersistenceConfiguration(), jdbcUtil.getConfigurationBuilder())) {\n+            cache.put(\"k1\", \"v1\");\n+            cache.put(\"k2\", \"v2\");\n+            //not yet in store (eviction.max-entries=2, LRU)\n+            assertTrue(table.getValueByKey(\"k1\") == null);\n+            assertTrue(table.getValueByKey(\"k2\") == null);\n+            cache.put(\"k3\", \"v3\");\n+            //now some key is evicted and stored in store\n+            assertTrue(2 == getNumberOfEntriesInMemory(cache.getName()));\n+            assertEquals(1, table.countAllRows());\n+            SERVERS.getServerDriver().stop(0);\n+            SERVERS.getServerDriver().restart(0); //soft stop should store all entries from cache to store\n+\n+            // test preload==false\n+            assertEquals(0, getNumberOfEntriesInMemory(cache.getName()));\n+            // test purge==false, entries should remain in the database after restart\n+            assertEquals(3, table.countAllRows());\n+            assertEquals(\"v1\", cache.get(\"k1\"));\n+        }\n+\n+    }\n+\n+    /**\n+     * This test differs from the preceding expecting 1 entry in the DB\n+     * after fail-over instead of 3 when doing soft\n+     * restart.\n+     */\n+    @Test(timeout = 600000)\n+    public void testFailoverWithoutPreloadPassivationEnabled() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2adf6b70779c02b06b42cf3a7feefe5f61f4f71d"}, "originalPosition": 202}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4085, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}