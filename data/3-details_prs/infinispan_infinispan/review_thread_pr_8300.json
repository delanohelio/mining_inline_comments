{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NTczNTIw", "number": 8300, "reviewThreads": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODo0Mjo0NFrOD7jQvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1ODo1M1rOD93Vpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzcwMzAxOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODo0Mjo0NFrOGT8UDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoxMDozMlrOGUOOQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NDMwMA==", "bodyText": "This lookup should be done in the constructor, as it does not depend on the request: we are always returning in the same format", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423564300", "createdAt": "2020-05-12T08:42:44Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg1NzcyOA==", "bodyText": "it does depend when authz is enabled with the subject ...", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423857728", "createdAt": "2020-05-12T16:10:32Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NDMwMA=="}, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzcyOTc4OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODo0OTowMFrOGT8lLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjo1MTo1OVrOGUwB9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODY4NQ==", "bodyText": "This should be non-blocking. I reckon it should be similar to \n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 221\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           return Flowable.fromIterable(cachesHealth.entrySet()) \n        \n    \n  \n\n or at least wrap it in an executor", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423568685", "createdAt": "2020-05-12T08:49:00Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NzMyNQ==", "bodyText": "done", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424257325", "createdAt": "2020-05-13T08:19:27Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODY4NQ=="}, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMTYzNg==", "bodyText": "This is not fixed yet. It needs to be done using the blocking executor, because this cache is persisted. To be honest (not for this PR) the server/rest module needs blockhound added to find these automatically.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424411636", "createdAt": "2020-05-13T12:51:59Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODY4NQ=="}, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzc4MTkwOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTowMTo1OFrOGT9G7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjozODowNVrOGUvfzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzMyNQ==", "bodyText": "The REST server should return code 204 (HttpResponseStatus.NO_CONTENT) for POST without a response body", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423577325", "createdAt": "2020-05-12T09:01:58Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwMjg5Mg==", "bodyText": "I have changed this dealing POST and PUT (create and update)", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424402892", "createdAt": "2020-05-13T12:38:05Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NzMyNQ=="}, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzc4NTE1OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTowMjo1MFrOGT9I_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTowMjo1MFrOGT9I_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3Nzg1NA==", "bodyText": "No need to return a body if the validation is success: it should simply return code 204 (see above)", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423577854", "createdAt": "2020-05-12T09:02:50Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);\n+      return cache.putAsync(schemaName, contents.asString())\n+            .thenCompose(r -> cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX))\n+            .thenApply(validationError -> {\n+               String validation = \"success\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzc5OTI1OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTowNjoyNFrOGT9R-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjo1MTo1MFrOGUwBhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MDE1Mw==", "bodyText": "It'd be better to report errors in the same format as other resources. This is how query reports it:\n{\n    \"error\":{\n        \"message\":\"Invalid search request\",\n        \"cause\":\"org.infinispan.ParseException...\"\n    }\n}\nmessage is a user friendly description of the error and cause is the output of exception.stackTrace() where applicable.\nThere is already the class org.infinispan.query.remote.json.JsonQueryErrorResult for this format, I think we should move it to the rest module and reuse for non-query resources", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423580153", "createdAt": "2020-05-12T09:06:24Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);\n+      return cache.putAsync(schemaName, contents.asString())\n+            .thenCompose(r -> cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX))\n+            .thenApply(validationError -> {\n+               String validation = \"success\";\n+               if(validationError != null) {\n+                  validation = validationError.toString();\n+                  builder.status(HttpResponseStatus.BAD_REQUEST);\n+               }\n+               String json = String.format(\"{validation:%s}\", validation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMTUyNg==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424411526", "createdAt": "2020-05-13T12:51:50Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)\n+            .invocation().methods(GET).path(\"/v2/protobuf/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/protobuf/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      List<ProtoSchema> protoSchemas = cache.entrySet().stream()\n+            .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+            .map(cacheEntry -> {\n+               String error = (String) cache\n+                     .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               ProtoSchema protoSchema = new ProtoSchema();\n+               protoSchema.name = cacheEntry.getKey().toString();\n+               protoSchema.validation = error == null ? \"success\" : error;\n+               return protoSchema;\n+            })\n+            .collect(Collectors.toList());\n+\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+      try {\n+         responseBuilder\n+               .status(OK)\n+               .contentType(APPLICATION_JSON)\n+               .entity(invocationHelper.getMapper().writeValueAsBytes(protoSchemas));\n+      } catch (JsonProcessingException e) {\n+         responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+      }\n+\n+      return CompletableFuture.completedFuture(responseBuilder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException();\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      builder.status(HttpResponseStatus.OK);\n+      return cache.putAsync(schemaName, contents.asString())\n+            .thenCompose(r -> cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX))\n+            .thenApply(validationError -> {\n+               String validation = \"success\";\n+               if(validationError != null) {\n+                  validation = validationError.toString();\n+                  builder.status(HttpResponseStatus.BAD_REQUEST);\n+               }\n+               String json = String.format(\"{validation:%s}\", validation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MDE1Mw=="}, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzgxOTU1OnYy", "diffSide": "RIGHT", "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToxMjowMlrOGT9f3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToxMjowMlrOGT9f3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MzcxMA==", "bodyText": "Nitpick: \"accept\" header is not used in PUT requests", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423583710", "createdAt": "2020-05-12T09:12:02Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.Test;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   public void getEmptySchemas() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(\"[ ]\", jsonNode.toPrettyString());\n+   }\n+\n+   @Test\n+   public void getNotFoundProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/error\")\n+            .content(new StringContentProvider(errorProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzgyMTczOnYy", "diffSide": "RIGHT", "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToxMjozN1rOGT9hRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODoyMTo0NVrOGUms9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NDA3MA==", "bodyText": ".accept can be removed", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423584070", "createdAt": "2020-05-12T09:12:37Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.Test;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   public void getEmptySchemas() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(\"[ ]\", jsonNode.toPrettyString());\n+   }\n+\n+   @Test\n+   public void getNotFoundProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/error\")\n+            .content(new StringContentProvider(errorProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      String validation = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isBadRequest();\n+      ResponseAssertion.assertThat(response).hasReturnedText(\"{validation:\" + validation + \"}\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", validation);\n+   }\n+\n+   @Test\n+   public void crudCorrectProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1ODgwNA==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424258804", "createdAt": "2020-05-13T08:21:45Z", "author": {"login": "karesti"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.Test;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   public void getEmptySchemas() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(\"[ ]\", jsonNode.toPrettyString());\n+   }\n+\n+   @Test\n+   public void getNotFoundProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/error\")\n+            .content(new StringContentProvider(errorProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      String validation = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isBadRequest();\n+      ResponseAssertion.assertThat(response).hasReturnedText(\"{validation:\" + validation + \"}\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", validation);\n+   }\n+\n+   @Test\n+   public void crudCorrectProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/protobuf\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .header(\"Content-type\", \"text/plain; charset=utf-8\")\n+            .method(HttpMethod.PUT)\n+            .accept(APPLICATION_JSON_TYPE).send();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NDA3MA=="}, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzg0MjM0OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToxNzo1NVrOGT9uew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMjo1MTo1OVrOGUwB7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NzQ1MQ==", "bodyText": "PUT and POST should have different behaviours:  POST will return CONFLICT if the entity with the same name already exists, while PUT will replace the entity. Take a look at how the CacheResource handles both methods:\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/BaseCacheResource.java\n    \n    \n         Line 82\n      in\n      6d78de6\n    \n    \n    \n    \n\n        \n          \n           CompletionStage<RestResponse> putValueToCache(RestRequest request) { \n        \n    \n  \n\n\nWe should either discern between the two verbs, or support just the PUT", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423587451", "createdAt": "2020-05-12T09:17:55Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxMTYyOQ==", "bodyText": "I'm doing this", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424411629", "createdAt": "2020-05-13T12:51:59Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)\n+            .invocation().methods(PUT, POST).path(\"/v2/protobuf/{schemaName}\").handleWith(this::addOrEditSchema)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4NzQ1MQ=="}, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzg1MzY5OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToyMDozNFrOGT91aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOTo1MzozOVrOGT_FaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4OTIyNw==", "bodyText": "I am conflicted between /v2/protobuf or /v2/schema for the REST endpoint path. WDYT @anistor?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423589227", "createdAt": "2020-05-12T09:20:34Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5NzYwMw==", "bodyText": "@gustavonalle I know the question isn't for me but I'd be in favour of /v2/schema for consistency with the CLI as that is the command you use to upload .proto files.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423597603", "createdAt": "2020-05-12T09:33:49Z", "author": {"login": "oraNod"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4OTIyNw=="}, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwOTcwNQ==", "bodyText": "Allright!!!", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r423609705", "createdAt": "2020-05-12T09:53:39Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/protobuf\").handleWith(this::getSchemasNames)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4OTIyNw=="}, "originalCommit": {"oid": "a9de55db0497f22b6cfa3979fbeeee8f5ca34c2c"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjMxMTgxOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODoxOTo1MFrOGVRJcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMDozOToyN1rOGVyvJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA==", "bodyText": "@wburns this is not ok ?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r424954224", "createdAt": "2020-05-14T08:19:50Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMDE4OQ==", "bodyText": "No, unfortunately the iterator returned from cache.entrySet() is blocking. This is why normally the ClusterPublisher is used as it allows for non blocking \"iteration\". But unfortunately without the new API, there is no easy way to do it with media type conversions.\nI think the simplest way for now is just to delegate this call to the blocking thread pool.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425110189", "createdAt": "2020-05-14T12:50:35Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMDU4Ng==", "bodyText": "That is unless the PROTOBUF_METADATA_CACHE_NAME cache doesn't do any media type conversions, then you can just use the ClusterPublisherManager directly.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425110586", "createdAt": "2020-05-14T12:51:15Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMzE2MQ==", "bodyText": "ClusterPublisherManager does not work with EncoderCache instances?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425113161", "createdAt": "2020-05-14T12:55:15Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExMzgxMg==", "bodyText": "It is not exposed via an EncoderCache in any way. It is solely a component currently.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425113812", "createdAt": "2020-05-14T12:56:23Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNTYxNg==", "bodyText": "The problem is I was expecting to effectively expose this from the new API, so I didn't add anything for out internal use. Maybe we should add an internal method only somewhere. The issue with ClusterPublisherManager is that the API of it is probably unwieldy to power users and we normally hide a lot of that from the user.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425115616", "createdAt": "2020-05-14T12:59:11Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNTk0MQ==", "bodyText": "So this one should be changed as well?\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 221\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           return Flowable.fromIterable(cachesHealth.entrySet())", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425115941", "createdAt": "2020-05-14T12:59:40Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNjYzNQ==", "bodyText": "So this one should be changed as well?\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 221\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           return Flowable.fromIterable(cachesHealth.entrySet()) \n        \n    \n  \n\n\n\nI have to check the cachesHealth configuration. If it can be distributed or have a store, then yes it needs to be changed.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425116635", "createdAt": "2020-05-14T13:00:42Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNzE4Nw==", "bodyText": "Oh actually cachesHealth is just a HashMap :) However, \n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/resources/CacheManagerResource.java\n    \n    \n         Line 214\n      in\n      1fc5a2e\n    \n    \n    \n    \n\n        \n          \n           cacheNames.removeAll(internalCacheRegistry.getInternalCacheNames()); \n        \n    \n  \n\n can block as mentioned in the comment.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425117187", "createdAt": "2020-05-14T13:01:33Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNzM5Ng==", "bodyText": "As I mentioned if we add blockhound to server/rest we won't have to conjecture about these and it will just fail the test if it blocks :)", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425117396", "createdAt": "2020-05-14T13:01:53Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUwNDU0OA==", "bodyText": "Check out #8323", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425504548", "createdAt": "2020-05-15T00:39:27Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.query.remote.json.JsonQueryErrorResult;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDIyNA=="}, "originalCommit": {"oid": "5280cbfc7238abdbed852cd7cf8e9a80c824bbb8"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjM4NDIzOnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "isResolved": true, "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoxMDoyM1rOGWNIlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNjoyMDoxMVrOGW-gkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA==", "bodyText": "Not sure what \"adds the schema\" is here. Shouldn't it just return BAD_REQUEST?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425937044", "createdAt": "2020-05-15T17:10:23Z", "author": {"login": "wburns"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ3Nzk0NA==", "bodyText": "@karesti should we be more specific and say \"adds the schema to the ___protobuf_metadata cache?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426477944", "createdAt": "2020-05-18T09:07:16Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU2OTcxMQ==", "bodyText": "No, because for me this cache is an implementation detail.\nNo because today even a wrong schema is stored.\nthe thing is that if the file is not correct, a validation is done, and then you retrieve the validation result from a key linked to the file in the cache", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426569711", "createdAt": "2020-05-18T11:53:28Z", "author": {"login": "karesti"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMTUwNQ==", "bodyText": "It being stored isn't an implementation detail, it is part of the interface of adding and verifying a schema. My comment is that the wording \"adds the schema\" seems a bit weird with it also returning BAD_REQUEST. If I was a user I would think that is a bit weird.\nEven if the wording is \"still registers the schema but returns a BAD_REQUEST response code. Or something like that.\nAlso I think we should add response code to these strings such as CONFLICT, because does that mean the body contains it or what. It is ambiguous.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426701505", "createdAt": "2020-05-18T15:15:15Z", "author": {"login": "wburns"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNjYxNA==", "bodyText": "the bad_request error was a review of @gustavonalle\nI was responding to @oraNod suggestion of mentioning the cache name, because for me this is an implementation detail\nfor what it is better to say in english, you are far way better than me, so I'm ok about it", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426706614", "createdAt": "2020-05-18T15:22:41Z", "author": {"login": "karesti"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyMjQyNw==", "bodyText": "Does it really add the wrong schema to the cache? My understanding was it would add a filename.error only", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426722427", "createdAt": "2020-05-18T15:45:30Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyOTI2MQ==", "bodyText": "I think it adds the schema, oh maybe I understood it wrong ?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426729261", "createdAt": "2020-05-18T15:55:20Z", "author": {"login": "karesti"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyOTkzMw==", "bodyText": "My point is that when a user invokes this endpoint and they get a BAD_REQUEST response code back. I personally would never expect it to be inserted into the cache still. That is why I am saying we must be very explicit if this is the behavior we want and mention this as I would not expect it.\nIt ends up making it that the user may get BAD_REQUEST back now and then when they reinsert with the schema correct they would get CONFLICT which is not what I think anyone would expect.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426729933", "createdAt": "2020-05-18T15:56:17Z", "author": {"login": "wburns"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMTkwMQ==", "bodyText": "it stores the schema and adds an additional key", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426731901", "createdAt": "2020-05-18T15:58:22Z", "author": {"login": "karesti"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczNDI3Nw==", "bodyText": "I was never a fan of the whole inserting a schema puts an exception in another key/cache thing tbh. I feel like something like schema registration should be an operation that you either insert it and it is valid or it doesn't insert and you get an exception. If we mirror how the query cache does it, I am just saying it needs to be documented much more than \"adds the schema\" for such a case imo.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426734277", "createdAt": "2020-05-18T16:01:57Z", "author": {"login": "wburns"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczNTg0Mw==", "bodyText": "@wburns I prefer created or ok for schemas with error too", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426735843", "createdAt": "2020-05-18T16:04:22Z", "author": {"login": "karesti"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczNTk3Ng==", "bodyText": "I will change that", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426735976", "createdAt": "2020-05-18T16:04:36Z", "author": {"login": "karesti"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczNzYwMA==", "bodyText": "Yes, just checked and it does. Anyway, it does seem weird that \"adds the schema\" and return BAD_REQUEST at the same time.\nOTOH, I am not a particular fan of forcing the user to do two requests when registering the protobuf: one for the schema and another to check a key containing .error. The REST endpoint should make things easier rather than simply exposing all the complexities behind it. The way @karesti implemented is fine to me  \ud83d\udc4d .\nI'd even go further by not mention in the documentation what it does, just say Registers the schema, return OK if registration is successful or BAD_REQUEST with the error otherwise.\nNow the fact that it stores the wrong schema, require a tiny adjustment to the Resource: we can't return CONFLICT since when the schema is wrong, the user will not be able to override the schema with a POST again, it will already be there \ud83d\ude1e This sucks from the usability perspective, so we should only support PUT that always allow replacing.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426737600", "createdAt": "2020-05-18T16:07:03Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0NjAwMA==", "bodyText": "it stores the schema and adds an additional key\n\nWhen the schema is wrong, it stores in the cache but does not registers the schema in the serialization context. I don't think we should really worry about it. Just don't mention in the document about storing or caches with underscores in names, but document as a 'registration' operation: it either does or doesn't", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426746000", "createdAt": "2020-05-18T16:20:11Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkzNzA0NA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQwMjQ0OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoxNjowN1rOGWNUJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTowOToxMlrOGWuN2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDAwNA==", "bodyText": "This section is duplicate of above?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425940004", "createdAt": "2020-05-15T17:16:07Z", "author": {"login": "wburns"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/protobuf/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a\n+protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/protobuf/{schemaName}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ3OTA2NQ==", "bodyText": "@wburns this one is a PUT the other is a GET. granted they do look like duplicates.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426479065", "createdAt": "2020-05-18T09:09:12Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/protobuf/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a\n+protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/protobuf/{schemaName}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDAwNA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQwNDM1OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoxNjo0OFrOGWNVdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTowOTo0OFrOGWuPKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDM0Mw==", "bodyText": "There seems to be a lot of duplication in this doc. Or maybe I am missing something?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425940343", "createdAt": "2020-05-15T17:16:48Z", "author": {"login": "wburns"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/protobuf/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a\n+protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_delete_protobuf']\n+= Deleting Protobuf Schemas\n+Remove Protobuf schemas from {brandname} clusters with `DELETE` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+DELETE /rest/v2/protobuf/{schemaName}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ3OTQwMA==", "bodyText": "@wburns thanks for commenting on the duplication. I felt it was too repetitive myself but had some doubts and needed some time to think about it. I'll add another commit with some suggestions to reduce the duplication. it's probably too distracting.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426479400", "createdAt": "2020-05-18T09:09:48Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/protobuf/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a\n+protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} adds the schema and returns `BAD_REQUEST`.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_delete_protobuf']\n+= Deleting Protobuf Schemas\n+Remove Protobuf schemas from {brandname} clusters with `DELETE` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+DELETE /rest/v2/protobuf/{schemaName}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDM0Mw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQwNjEzOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoxNzoyOFrOGWNWrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMTo1NzoyNVrOGWz3_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDY1NQ==", "bodyText": "Nitpick: extra spaces.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425940655", "createdAt": "2020-05-15T17:17:28Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MTc3NQ==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426571775", "createdAt": "2020-05-18T11:57:25Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MDY1NQ=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQyMjc5OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoyMzoyOFrOGWNh8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMTo1Njo0N1rOGWz2rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MzUzNw==", "bodyText": "I find .collect(Collectors.toSet()) is more succinct.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425943537", "createdAt": "2020-05-15T17:23:28Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MTQzNw==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426571437", "createdAt": "2020-05-18T11:56:47Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0MzUzNw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQzODMwOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoyODoyNVrOGWNr-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo1NzoyNVrOGWOl3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjEwNQ==", "bodyText": "This is another blocking call here. Unfortunately, the more I look at this it should really be done using BlockingManager#blockingPublisher on the Flowable.fromIterable(cache.entrySet()) and then doing non blocking calls aftwerds.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946105", "createdAt": "2020-05-15T17:28:25Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MDkyNw==", "bodyText": "But I guess we can leave this as is for now. This whole chunk will need to be redone to use a ClusterPublisher at some point anyways.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425960927", "createdAt": "2020-05-15T17:57:25Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjEwNQ=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQzOTY5OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoyODo1NlrOGWNs9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMjoxNToyOFrOGW0cig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjM1OQ==", "bodyText": "It appears we are never using the value, so just cache.keySet() should be good.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946359", "createdAt": "2020-05-15T17:28:56Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4MTEzMA==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426581130", "createdAt": "2020-05-18T12:15:28Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjM1OQ=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ0MDM5OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoyOToxMVrOGWNtbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMjoyMDozMFrOGW0nFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjQ3OQ==", "bodyText": "This seems a bit odd that we are collecting into a Set to then sort and then collect it into a List. can we not just use http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html#sorted-java.util.Comparator- and then collect that into a List that is finally mapped to the response?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946479", "createdAt": "2020-05-15T17:29:11Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4MzgzMA==", "bodyText": "yes", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426583830", "createdAt": "2020-05-18T12:20:30Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjQ3OQ=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ0MTA1OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoyOToyNFrOGWNt3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzoyOToyNFrOGWNt3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjU4OQ==", "bodyText": "Nitpick: extra spaces.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946589", "createdAt": "2020-05-15T17:29:24Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ0MzE5OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzozMDowNFrOGWNvJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNjo0MDoyM1rOGW_P-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw==", "bodyText": "I am not sure how error handling is done on the rest side, but when returning a CompletionStage, I would normally expect this exception to be in the Stage.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425946917", "createdAt": "2020-05-15T17:30:04Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4NTY0Nw==", "bodyText": "the exception is catchd in the BaseHttpRequestHandler\nI'm following other examples\nwe should maybe talk about the overral design on this ?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426585647", "createdAt": "2020-05-18T12:23:53Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5ODUyMw==", "bodyText": "Sorry I don't see how BaseHttpRequestHandler can be possibly handling this. The handleError is only invoked from 2 places checking CompletionStage results. If a method can return a CompletionStage, it should not be throwing an exception that is from user input. It should only be from bugs in our code.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426698523", "createdAt": "2020-05-18T15:11:07Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNjAwNg==", "bodyText": "It is caught at RestDispatcherImpl#dispatch btw.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426706006", "createdAt": "2020-05-18T15:21:51Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNzY2MA==", "bodyText": "can we deal this in another PR and talk about it with @gustavonalle ? because I'm not adding anything new and IMO this is another PR more global subject", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426707660", "createdAt": "2020-05-18T15:24:06Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwODQ4Mw==", "bodyText": "So I guess this code is okay, however it smells to me as we talked before at the F2F when the return type of a method is CompletionStage that any exceptions an invoker should be able to receive should be encapsulated in the Stage.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426708483", "createdAt": "2020-05-18T15:25:17Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0MTIzMQ==", "bodyText": "BaseHttpRequestHandler#handleError should handle uncaught exceptions from the resources, and also log it\n\n  \n    \n      infinispan/server/rest/src/main/java/org/infinispan/rest/BaseHttpRequestHandler.java\n    \n    \n         Line 33\n      in\n      1f25924\n    \n    \n    \n    \n\n        \n          \n           getLogger().errorWhileResponding(responseException); \n        \n    \n  \n\n\nCould you please open a separate JIRA on how to align the error handling with what was discussed?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426741231", "createdAt": "2020-05-18T16:12:41Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc1ODEzNw==", "bodyText": "is this JIRA not enough ? https://issues.redhat.com/browse/ISPN-11853", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426758137", "createdAt": "2020-05-18T16:40:23Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NjkxNw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ0NjM4OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzozMTowMlrOGWNxHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMjoyNTowOVrOGW0xBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzQyMQ==", "bodyText": "CompletableFutures.completedNull() instead.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425947421", "createdAt": "2020-05-15T17:31:02Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4NjM3NQ==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426586375", "createdAt": "2020-05-18T12:25:09Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzQyMQ=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ0NzI4OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzozMToyMVrOGWNxqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMjoyNDoyNVrOGW0vUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzU2MQ==", "bodyText": "Nitpick: spacing on if blocks are missing here and a few below.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425947561", "createdAt": "2020-05-15T17:31:21Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU4NTkzOA==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426585938", "createdAt": "2020-05-18T12:24:25Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NzU2MQ=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ3NTcwOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0MDoyMFrOGWODmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMjoxMDo1MFrOGW0TIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjE1Mg==", "bodyText": "Util.EMPTY_BYTE_ARRAY", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425952152", "createdAt": "2020-05-15T17:40:20Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3ODcyMA==", "bodyText": "k", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426578720", "createdAt": "2020-05-18T12:10:50Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjE1Mg=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ3NzI3OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0MDo1MFrOGWOElA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNjoxNjowNVrOGW-WwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA==", "bodyText": "Do we want to at least log the exception?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425952404", "createdAt": "2020-05-15T17:40:50Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MzE3NA==", "bodyText": "I change this launching an exception, but should not be happening\nit's uneven across resources now, sometimes we launch a throw new RestResponseException(e); and others just catch", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426573174", "createdAt": "2020-05-18T12:00:01Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NTU2OQ==", "bodyText": "I understand that different failures may be propagated. But I think we should at least log an exception instead of just catching it and making it impossible to debug.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426695569", "createdAt": "2020-05-18T15:07:01Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwNDA1OQ==", "bodyText": "And sorry the previous code doing this should at least log the error as a trace as well. We should not be swallowing exceptions, except for in very rare cases (especially when we can be reporting an error to the user).", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426704059", "createdAt": "2020-05-18T15:19:00Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwOTI1MQ==", "bodyText": "there is a global issue concerning logging in the REST resources.\nCan we discuss this too with @gustavonalle so we can do some follow up PR on error handling and logging strategy, please?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426709251", "createdAt": "2020-05-18T15:26:21Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMTc4Mg==", "bodyText": "There is an error JSON document to report errors, the query endpoint is using it", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426711782", "createdAt": "2020-05-18T15:30:00Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMzEyMA==", "bodyText": "Some endpoints are not implementing this to handle JsonProcessingException as it is very unlikely (impossible?) this error would be thrown since the JSON is mapped via Jackson based on always the same class", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426713120", "createdAt": "2020-05-18T15:31:56Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMzA2OQ==", "bodyText": "I don't think just adding a single trace message needs another PR... And I have heard many a developer say something is very unlikely to impossible, including myself, and it ends up  happening. So I would rather have at least a trace message when I am completely ignoring a checked Exception.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426733069", "createdAt": "2020-05-18T16:00:07Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc0MzQ4OA==", "bodyText": "Ok, I agree adding log won't hurt  \ud83d\ude04", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426743488", "createdAt": "2020-05-18T16:16:05Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MjQwNA=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ4NTMxOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0MzoyMlrOGWOJpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMjowODo0OFrOGW0PNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw==", "bodyText": "Unfortunately this isn't quite a record class. Please make a constructor with final fields.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425953703", "createdAt": "2020-05-15T17:43:22Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MDA4NA==", "bodyText": "Or does Jackson not like that?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425960084", "createdAt": "2020-05-15T17:55:47Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3NzcxNg==", "bodyText": "all the other classes are done like this and I recall it is related", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426577716", "createdAt": "2020-05-18T12:08:48Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzcwMw=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ4NzgzOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0NDoxMlrOGWOLSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0NDoxMlrOGWOLSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NDEyMw==", "bodyText": "Same here re: final and constructor.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425954123", "createdAt": "2020-05-15T17:44:12Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {\n+               if(isOkOrCreated(builder)) {\n+                  return cache.getAsync(schemaName + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+               } else {\n+                  return CompletableFuture.completedFuture(null);\n+               }\n+            })\n+            .thenApply(validationError -> {\n+               if(isOkOrCreated(builder)) {\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = schemaName;\n+                  if(validationError != null) {\n+                     protoSchema.error = createErrorContent(schemaName, (String) validationError);\n+                     builder.status(HttpResponseStatus.BAD_REQUEST);\n+                  }\n+                  byte[] detailsResponse = new byte[0];\n+                  try {\n+                     detailsResponse = invocationHelper.getMapper().writeValueAsBytes(protoSchema);\n+                  } catch (JsonProcessingException e) {\n+                     builder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return builder.contentType(APPLICATION_JSON).entity(detailsResponse).build();\n+               } else {\n+                  return builder.build();\n+               }\n+            });\n+   }\n+\n+   private boolean isOkOrCreated(NettyRestResponse.Builder builder) {\n+      return builder.getHttpStatus() == HttpResponseStatus.CREATED || builder.getHttpStatus() == HttpResponseStatus.OK;\n+   }\n+\n+   private CompletionStage<RestResponse> getSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      return restCacheManager.getPrivilegedInternalEntry(cache, schemaName, true).thenApply(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         if(entry == null) {\n+            responseBuilder.status(HttpResponseStatus.NOT_FOUND.code());\n+         } else {\n+            responseBuilder.status(HttpResponseStatus.OK.code());\n+            responseBuilder.contentType(MediaType.TEXT_PLAIN);\n+            responseBuilder.entity(entry.getValue());\n+         }\n+         return responseBuilder.build();\n+      });\n+   }\n+\n+   private CompletionStage<RestResponse> deleteSchema(RestRequest request) {\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      RestCacheManager<Object> restCacheManager = invocationHelper.getRestCacheManager();\n+      AdvancedCache<Object, Object> protobufCache = restCacheManager.getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return restCacheManager.getPrivilegedInternalEntry(protobufCache, schemaName, true).thenCompose(entry -> {\n+         NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+         responseBuilder.status(HttpResponseStatus.NOT_FOUND);\n+\n+         if (entry instanceof InternalCacheEntry) {\n+               responseBuilder.status(HttpResponseStatus.NO_CONTENT.code());\n+               return restCacheManager.remove(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, schemaName,\n+                     MediaType.MATCH_ALL, request)\n+                     .thenApply(v -> responseBuilder.build());\n+         }\n+         return CompletableFuture.completedFuture(responseBuilder.build());\n+      });\n+   }\n+\n+   private ValidationError createErrorContent(String schemaName, String cause) {\n+      String message = \"Schema \" + schemaName + \" has errors\";\n+      ValidationError validationError = new ValidationError();\n+      validationError.message = message;\n+      validationError.cause = cause;\n+      return validationError;\n+   }\n+\n+   private String checkMandatorySchemaName(RestRequest request) {\n+      String schemaName = request.variables().get(\"schemaName\");\n+      if (schemaName == null)\n+         throw new NoKeyException(\"schemaName\");\n+      return schemaName.endsWith(ProtobufMetadataManager.PROTO_KEY_SUFFIX) ? schemaName : schemaName + ProtobufMetadataManager.PROTO_KEY_SUFFIX;\n+   }\n+\n+   static class ValidationError {\n+      public String message;\n+      public String cause;\n+   }\n+   static class ProtoSchema {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjUyMjU4OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo1NToyN1rOGWOh4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTozMjoyOVrOGW8hag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ==", "bodyText": "Nitpick: Might as well put it on the line above to save some indention.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r425959905", "createdAt": "2020-05-15T17:55:27Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3ODQ0Nw==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426578447", "createdAt": "2020-05-18T12:10:13Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NjUwMw==", "bodyText": "This wasn't updated?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426696503", "createdAt": "2020-05-18T15:08:16Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwODE0Mg==", "bodyText": "it was, but maybe I understood wrong what you meant by indention", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426708142", "createdAt": "2020-05-18T15:24:48Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMzQ1MA==", "bodyText": "ok now I got it", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426713450", "createdAt": "2020-05-18T15:32:29Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.entrySet())\n+               .filter(cacheEntry -> !((String)cacheEntry.getKey()).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(cacheEntry -> {\n+                  String error = (String) cache\n+                        .get(cacheEntry.getKey() + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = cacheEntry.getKey().toString();\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .collectInto(new HashSet<ProtoSchema>(), Set::add)\n+                .map(protoSchemas -> {\n+                  try {\n+                     List<ProtoSchema> sortedCacheInfos = protoSchemas.stream()\n+                           .sorted(Comparator.comparing(s -> s.name))\n+                           .collect(Collectors.toList());\n+                     byte[] bytes = objectMapper.writeValueAsBytes(sortedCacheInfos);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     responseBuilder.status(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+\n+      return putSchema\n+            .thenCompose(r -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1OTkwNQ=="}, "originalCommit": {"oid": "76cff2bac32cd828189959a2fa2caddd2b478589"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzY5MzA2OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTo1ODozNVrOGW9qGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNjo0NjowMFrOGW_dJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMjA1OA==", "bodyText": "This is more like what I would expect. However you didn't fix the indentation on the following lines as they can all now be moved 3 spaces to the left. Or however IntelliJ says the formatter wants :)", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426732058", "createdAt": "2020-05-18T15:58:35Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+      return putSchema.thenCompose(r -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1b6422ae172d82d06ee66cbc4d8027ede610440"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2MTUxMQ==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r426761511", "createdAt": "2020-05-18T16:46:00Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);\n+            } else {\n+               builder.status(HttpResponseStatus.OK);\n+            }\n+            return result;\n+         });\n+      }\n+      return putSchema.thenCompose(r -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjczMjA1OA=="}, "originalCommit": {"oid": "c1b6422ae172d82d06ee66cbc4d8027ede610440"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDA0NzQwOnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODowMTozM1rOGXUbVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDowMzoxN1rOGXZJNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNTEwOQ==", "bodyText": "PUT will not return CONFLICT: it will create if the schema does not exist or replace it otherwise", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427105109", "createdAt": "2020-05-19T08:01:33Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} stores the schema and returns the error in the response body.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/protobuf/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a\n+protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4MjM5MA==", "bodyText": "Updating is not creating, so no", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427182390", "createdAt": "2020-05-19T10:03:17Z", "author": {"login": "karesti"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} stores the schema and returns the error in the response body.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/protobuf/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a\n+protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNTEwOQ=="}, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDA5NzQ0OnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODoxNTowNlrOGXU6-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwOTo0Mzo0MFrOGXYbLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMzIwOQ==", "bodyText": "We need to rename this to /v2/schemas to conform with the other resources:\n/v2/counters/, /v2/caches/, /v2/tasks and so on.\n@oraNod also need to change all the doc references", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427113209", "createdAt": "2020-05-19T08:15:06Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MDYwNQ==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427170605", "createdAt": "2020-05-19T09:43:40Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMzIwOQ=="}, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDEzMDQwOnYy", "diffSide": "RIGHT", "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODoyMzozNVrOGXVP0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDowODo1OVrOGXZWug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA==", "bodyText": "This will cause a PUT for a totally new schema to return 404...\nPUT should create the schema if it does not exist or replace if it already exists.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427118544", "createdAt": "2020-05-19T08:23:35Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2ODk2Mg==", "bodyText": "but if someone has deleted the schema and you are creating it at the same time again ?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427168962", "createdAt": "2020-05-19T09:40:59Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MDAzMQ==", "bodyText": "? You mean concurrent requests, one with PUT and another with DELETE?", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427170031", "createdAt": "2020-05-19T09:42:41Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4MDQ4NQ==", "bodyText": "for me you use POST to create a total new schema. And then put to modify schemas. this way the action from the user is clear. if you try to modify an already existing schema but the schema does not exist anymore, you get to know", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427180485", "createdAt": "2020-05-19T10:00:07Z", "author": {"login": "karesti"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTMzMg==", "bodyText": "nope, PUT should be like AddOrReplace", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427185332", "createdAt": "2020-05-19T10:08:06Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTg1MA==", "bodyText": "More info: https://tools.ietf.org/html/rfc2616#page-55", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427185850", "createdAt": "2020-05-19T10:08:59Z", "author": {"login": "gustavonalle"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ProtobufResource.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.reactivex.rxjava3.core.Flowable;\n+import org.infinispan.AdvancedCache;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.query.remote.client.ProtobufMetadataManagerConstants;\n+import org.infinispan.rest.InvocationHelper;\n+import org.infinispan.rest.NettyRestResponse;\n+import org.infinispan.rest.RestResponseException;\n+import org.infinispan.rest.cachemanager.RestCacheManager;\n+import org.infinispan.rest.framework.ContentSource;\n+import org.infinispan.rest.framework.ResourceHandler;\n+import org.infinispan.rest.framework.RestRequest;\n+import org.infinispan.rest.framework.RestResponse;\n+import org.infinispan.rest.framework.impl.Invocations;\n+import org.infinispan.rest.operations.exceptions.NoDataFoundException;\n+import org.infinispan.rest.operations.exceptions.NoKeyException;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import java.util.Comparator;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;\n+import static org.infinispan.rest.framework.Method.DELETE;\n+import static org.infinispan.rest.framework.Method.GET;\n+import static org.infinispan.rest.framework.Method.POST;\n+import static org.infinispan.rest.framework.Method.PUT;\n+\n+/**\n+ * Protobuf schema manipulation Resource\n+ *\n+ * @author Katia Aresti\n+ * @since 11\n+ */\n+public class ProtobufResource extends BaseCacheResource implements ResourceHandler {\n+\n+   private final ObjectMapper objectMapper;\n+\n+   public ProtobufResource(InvocationHelper invocationHelper) {\n+      super(invocationHelper);\n+      objectMapper = invocationHelper.getMapper();\n+   }\n+\n+   @Override\n+   public Invocations getInvocations() {\n+      return new Invocations.Builder()\n+            // Key related operations\n+            .invocation().methods(GET).path(\"/v2/schema\").handleWith(this::getSchemasNames)\n+            .invocation().methods(POST).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,true))\n+            .invocation().methods(PUT).path(\"/v2/schema/{schemaName}\").handleWith(r -> addOrEditSchema(r,false))\n+            .invocation().methods(GET).path(\"/v2/schema/{schemaName}\").handleWith(this::getSchema)\n+            .invocation().method(DELETE).path(\"/v2/schema/{schemaName}\").handleWith(this::deleteSchema)\n+            .create();\n+   }\n+\n+   private CompletionStage<RestResponse> getSchemasNames(RestRequest request) {\n+      NettyRestResponse.Builder responseBuilder = new NettyRestResponse.Builder();\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      return CompletableFuture.supplyAsync(() ->\n+          Flowable.fromIterable(cache.keySet())\n+               .filter(key -> !((String)key).endsWith(ProtobufMetadataManager.ERRORS_KEY_SUFFIX))\n+               .map(key -> {\n+                  String error = (String) cache\n+                        .get(key + ProtobufMetadataManagerConstants.ERRORS_KEY_SUFFIX);\n+                  ProtoSchema protoSchema = new ProtoSchema();\n+                  protoSchema.name = (String) key;\n+                  if (error != null) {\n+                     protoSchema.error = createErrorContent(protoSchema.name, error);\n+                  }\n+                  return protoSchema;\n+               })\n+                .sorted(Comparator.comparing(s -> s.name))\n+                .collect(Collectors.toList())\n+                .map(protoSchemas -> {\n+                  try {\n+                     byte[] bytes = objectMapper.writeValueAsBytes(protoSchemas);\n+                     responseBuilder.contentType(APPLICATION_JSON).entity(bytes);\n+                  } catch (JsonProcessingException e) {\n+                     throw new RestResponseException(e);\n+                  }\n+                  return (RestResponse) responseBuilder.build();\n+               })\n+                .toCompletionStage()\n+      , invocationHelper.getExecutor())\n+            .thenCompose(Function.identity());\n+   }\n+\n+   private CompletionStage<RestResponse> addOrEditSchema(RestRequest request, boolean create) {\n+\n+      String schemaName = checkMandatorySchemaName(request);\n+\n+      ContentSource contents = request.contents();\n+      if (contents == null) throw new NoDataFoundException(\"Schema data not sent in the request\");\n+\n+      AdvancedCache<Object, Object> cache = invocationHelper.getRestCacheManager()\n+            .getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME, request);\n+\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      CompletableFuture<Object> putSchema;\n+      if (create) {\n+         putSchema = cache.putIfAbsentAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.CREATED);\n+            } else {\n+               builder.status(HttpResponseStatus.CONFLICT);\n+            }\n+            return result;\n+         });\n+      } else {\n+         putSchema = cache.replaceAsync(schemaName, contents.asString()).thenApply(result -> {\n+            if (result == null) {\n+               builder.status(HttpResponseStatus.NOT_FOUND);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExODU0NA=="}, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MDIwNzc3OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODo0Mjo0MlrOGXWA5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDowMTowM1rOGXZEDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEzMTExMQ==", "bodyText": "In order to clarify a bit further on how schemas work, I suggest:\nIf the schema already exists, {brandname} returns `CONFLICT`. If the schema is not valid, either because of syntax errors, or because some of its dependencies are missing, {brandname} stores the schema and returns the error in the response body.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427131111", "createdAt": "2020-05-19T08:42:42Z", "author": {"login": "gustavonalle"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} stores the schema and returns the error in the response body.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4MTA3MQ==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427181071", "createdAt": "2020-05-19T10:01:03Z", "author": {"login": "karesti"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,82 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/protobuf/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`. If the schema is\n+not valid, {brandname} stores the schema and returns the error in the response body.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEzMTExMQ=="}, "originalCommit": {"oid": "c5a86f789fcfc4e127c7c6ff51afe9f69214f787"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTkzOTk2OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1MzozMVrOGXnKEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjozOToxMFrOGXpF3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMTk4NA==", "bodyText": "Outdated", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427411984", "createdAt": "2020-05-19T15:53:31Z", "author": {"login": "danberindei"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,81 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/schemas/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`.\n+If the schema is not valid, either because of syntax errors, or because some of its dependencies are missing,\n+{brandname} stores the schema and returns the error in the response body.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/schemas/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/schemas/{schemaName}\n+----\n+\n+If the schema doesn't exist, {brandname} returns `NOT FOUND`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzY3OQ==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427443679", "createdAt": "2020-05-19T16:39:10Z", "author": {"login": "karesti"}, "path": "documentation/src/main/asciidoc/topics/ref_rest_protobuf.adoc", "diffHunk": "@@ -0,0 +1,81 @@\n+[id='rest_v2_create_protobuf']\n+= Creating Protobuf Schemas\n+Create Protobuf schemas across {brandname} clusters with `POST` requests that\n+include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+POST /rest/v2/schemas/{schemaName}\n+----\n+\n+If the schema already exists, {brandname} returns `CONFLICT`.\n+If the schema is not valid, either because of syntax errors, or because some of its dependencies are missing,\n+{brandname} stores the schema and returns the error in the response body.\n+\n+{brandname} responds with the schema name and any errors.\n+\n+[source,json,options=\"nowrap\",subs=attributes+]\n+----\n+include::json_examples/rest_protobuf_create_update_schema_response.json[]\n+----\n+\n+* `name` is the name of the Protobuf schema.\n+* `error` is `null` for valid Protobuf schemas. If {brandname} cannot successfully validate the schema, it returns errors.\n+\n+[id='rest_v2_get_protobuf']\n+= Reading Protobuf Schemas\n+Retrieve Protobuf schema from {brandname} with `GET` requests.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+GET /rest/v2/schemas/{schemaName}\n+----\n+\n+[id='rest_v2_update_protobuf']\n+= Updating Protobuf Schemas\n+Modify Protobuf schemas with `PUT` requests that include the content of a protobuf file in the payload.\n+\n+[source,options=\"nowrap\",subs=attributes+]\n+----\n+PUT /rest/v2/schemas/{schemaName}\n+----\n+\n+If the schema doesn't exist, {brandname} returns `NOT FOUND`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMTk4NA=="}, "originalCommit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTk2MzkxOnYy", "diffSide": "RIGHT", "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTo1ODo1M1rOGXnZFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOToyMTowNFrOGXvK9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTgzMQ==", "bodyText": "Should change the name of this method (and updateNonExistingSchema) considering that PUT now means \"create or update\". I'd just replace update with put.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427415831", "createdAt": "2020-05-19T15:58:53Z", "author": {"login": "danberindei"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.security.auth.Subject;\n+import java.security.PrivilegedAction;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   @BeforeMethod(alwaysRun = true)\n+   @Override\n+   public void createBeforeMethod() {\n+      //Clear schema cache to avoid conflicts between methods\n+      Subject.doAs(ADMIN_USER, (PrivilegedAction<Void>) () -> {\n+         cacheManagers.get(0).getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME).clear();\n+         return null;\n+      });\n+   }\n+\n+   public void listSchemasWhenEmpty() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(0, jsonNode.size());\n+   }\n+\n+   @Test\n+   public void getNotExistingSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void updateNonExistingSchema() throws Exception {\n+      String person = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = updateSchema(\"person\", person);\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = addSchema(\"error\", errorProto);\n+\n+      String cause = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContent());\n+      assertEquals(\"error.proto\", jsonNode.get(\"name\").asText());\n+      assertEquals(\"Schema error.proto has errors\", jsonNode.get(\"error\").get(\"message\").asText());\n+      assertEquals(cause, jsonNode.get(\"error\").get(\"cause\").asText());\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/error\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"error.proto\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", cause);\n+   }\n+\n+   @Test\n+   public void crudSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      // Create\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(\"null\", jsonNode.get(\"error\").asText());\n+\n+      // Read\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/person.proto\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Update\n+      response = updateSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      // Delete\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.DELETE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void createTwiceSchema() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isConflicted();\n+   }\n+\n+   @Test\n+   public void addAndGetListOrderedByName() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      addSchema(\"users\", personProto);\n+      addSchema(\"people\", personProto);\n+      addSchema(\"dancers\", personProto);\n+\n+      String url = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      ContentResponse response = client.newRequest(url)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(3, jsonNode.size());\n+      assertEquals(\"dancers.proto\", jsonNode.get(0).get(\"name\").asText());\n+      assertEquals(\"people.proto\", jsonNode.get(1).get(\"name\").asText());\n+      assertEquals(\"users.proto\", jsonNode.get(2).get(\"name\").asText());\n+   }\n+\n+   private ContentResponse addSchema(String schemaName, String schemaContent)\n+         throws InterruptedException, TimeoutException, ExecutionException {\n+      return callAPI(schemaName, schemaContent, HttpMethod.POST);\n+   }\n+\n+   private ContentResponse updateSchema(String schemaName, String schemaContent)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzcxNg==", "bodyText": "ok", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427443716", "createdAt": "2020-05-19T16:39:15Z", "author": {"login": "karesti"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.security.auth.Subject;\n+import java.security.PrivilegedAction;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   @BeforeMethod(alwaysRun = true)\n+   @Override\n+   public void createBeforeMethod() {\n+      //Clear schema cache to avoid conflicts between methods\n+      Subject.doAs(ADMIN_USER, (PrivilegedAction<Void>) () -> {\n+         cacheManagers.get(0).getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME).clear();\n+         return null;\n+      });\n+   }\n+\n+   public void listSchemasWhenEmpty() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(0, jsonNode.size());\n+   }\n+\n+   @Test\n+   public void getNotExistingSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void updateNonExistingSchema() throws Exception {\n+      String person = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = updateSchema(\"person\", person);\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = addSchema(\"error\", errorProto);\n+\n+      String cause = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContent());\n+      assertEquals(\"error.proto\", jsonNode.get(\"name\").asText());\n+      assertEquals(\"Schema error.proto has errors\", jsonNode.get(\"error\").get(\"message\").asText());\n+      assertEquals(cause, jsonNode.get(\"error\").get(\"cause\").asText());\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/error\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"error.proto\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", cause);\n+   }\n+\n+   @Test\n+   public void crudSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      // Create\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(\"null\", jsonNode.get(\"error\").asText());\n+\n+      // Read\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/person.proto\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Update\n+      response = updateSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      // Delete\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.DELETE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void createTwiceSchema() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isConflicted();\n+   }\n+\n+   @Test\n+   public void addAndGetListOrderedByName() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      addSchema(\"users\", personProto);\n+      addSchema(\"people\", personProto);\n+      addSchema(\"dancers\", personProto);\n+\n+      String url = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      ContentResponse response = client.newRequest(url)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(3, jsonNode.size());\n+      assertEquals(\"dancers.proto\", jsonNode.get(0).get(\"name\").asText());\n+      assertEquals(\"people.proto\", jsonNode.get(1).get(\"name\").asText());\n+      assertEquals(\"users.proto\", jsonNode.get(2).get(\"name\").asText());\n+   }\n+\n+   private ContentResponse addSchema(String schemaName, String schemaContent)\n+         throws InterruptedException, TimeoutException, ExecutionException {\n+      return callAPI(schemaName, schemaContent, HttpMethod.POST);\n+   }\n+\n+   private ContentResponse updateSchema(String schemaName, String schemaContent)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTgzMQ=="}, "originalCommit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0MzI4NA==", "bodyText": "I believe this was missed, however I won't stop this from integrating it.", "url": "https://github.com/infinispan/infinispan/pull/8300#discussion_r427543284", "createdAt": "2020-05-19T19:21:04Z", "author": {"login": "wburns"}, "path": "server/rest/src/test/java/org/infinispan/rest/resources/ProtobufResourceTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.infinispan.rest.resources;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.infinispan.query.remote.ProtobufMetadataManager;\n+import org.infinispan.rest.assertion.ResponseAssertion;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.security.auth.Subject;\n+import java.security.PrivilegedAction;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON_TYPE;\n+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN_TYPE;\n+import static org.infinispan.commons.util.Util.getResourceAsString;\n+import static org.testng.AssertJUnit.assertEquals;\n+\n+@Test(groups = \"functional\", testName = \"rest.ProtobufResourceTest\")\n+public class ProtobufResourceTest extends AbstractRestResourceTest {\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new ProtobufResourceTest().withSecurity(false),\n+            new ProtobufResourceTest().withSecurity(true),\n+      };\n+   }\n+\n+   @BeforeMethod(alwaysRun = true)\n+   @Override\n+   public void createBeforeMethod() {\n+      //Clear schema cache to avoid conflicts between methods\n+      Subject.doAs(ADMIN_USER, (PrivilegedAction<Void>) () -> {\n+         cacheManagers.get(0).getCache(ProtobufMetadataManager.PROTOBUF_METADATA_CACHE_NAME).clear();\n+         return null;\n+      });\n+   }\n+\n+   public void listSchemasWhenEmpty() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContentAsString());\n+      assertEquals(0, jsonNode.size());\n+   }\n+\n+   @Test\n+   public void getNotExistingSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      ContentResponse response = client.newRequest(BASE_URL + \"/coco\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void updateNonExistingSchema() throws Exception {\n+      String person = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = updateSchema(\"person\", person);\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+   }\n+\n+   @Test\n+   public void putAndGetWrongProtobuf() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+\n+      String errorProto = getResourceAsString(\"error.proto\", getClass().getClassLoader());\n+\n+      ContentResponse response = addSchema(\"error\", errorProto);\n+\n+      String cause = \"java.lang.IllegalStateException:\"\n+            + \" Syntax error in error.proto at 3:8: unexpected label: messoge\";\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      JsonNode jsonNode = new ObjectMapper().readTree(response.getContent());\n+      assertEquals(\"error.proto\", jsonNode.get(\"name\").asText());\n+      assertEquals(\"Schema error.proto has errors\", jsonNode.get(\"error\").get(\"message\").asText());\n+      assertEquals(cause, jsonNode.get(\"error\").get(\"cause\").asText());\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/error\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"error.proto\");\n+\n+      checkListProtobufEndpointUrl(\"error.proto\", cause);\n+   }\n+\n+   @Test\n+   public void crudSchema() throws Exception {\n+      String BASE_URL = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+\n+      // Create\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(\"null\", jsonNode.get(\"error\").asText());\n+\n+      // Read\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Read adding .proto should also work\n+      response = client.newRequest(BASE_URL + \"/person.proto\")\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+      ResponseAssertion.assertThat(response).isOk();\n+      ResponseAssertion.assertThat(response).hasContentEqualToFile(\"person.proto\");\n+\n+      // Update\n+      response = updateSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      // Delete\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.DELETE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+\n+      response = client.newRequest(BASE_URL + \"/person\")\n+            .content(new StringContentProvider(personProto))\n+            .method(HttpMethod.GET)\n+            .accept(TEXT_PLAIN_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isNotFound();\n+   }\n+\n+   @Test\n+   public void createTwiceSchema() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      ContentResponse response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isOk();\n+      response = addSchema(\"person\", personProto);\n+      ResponseAssertion.assertThat(response).isConflicted();\n+   }\n+\n+   @Test\n+   public void addAndGetListOrderedByName() throws Exception {\n+      String personProto = getResourceAsString(\"person.proto\", getClass().getClassLoader());\n+      addSchema(\"users\", personProto);\n+      addSchema(\"people\", personProto);\n+      addSchema(\"dancers\", personProto);\n+\n+      String url = String.format(\"http://localhost:%d/rest/v2/schemas\", restServer().getPort());\n+      ContentResponse response = client.newRequest(url)\n+            .method(HttpMethod.GET)\n+            .accept(APPLICATION_JSON_TYPE).send();\n+\n+      ResponseAssertion.assertThat(response).isOk();\n+      ObjectMapper objectMapper = new ObjectMapper();\n+      JsonNode jsonNode = objectMapper.readTree(response.getContent());\n+      assertEquals(3, jsonNode.size());\n+      assertEquals(\"dancers.proto\", jsonNode.get(0).get(\"name\").asText());\n+      assertEquals(\"people.proto\", jsonNode.get(1).get(\"name\").asText());\n+      assertEquals(\"users.proto\", jsonNode.get(2).get(\"name\").asText());\n+   }\n+\n+   private ContentResponse addSchema(String schemaName, String schemaContent)\n+         throws InterruptedException, TimeoutException, ExecutionException {\n+      return callAPI(schemaName, schemaContent, HttpMethod.POST);\n+   }\n+\n+   private ContentResponse updateSchema(String schemaName, String schemaContent)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNTgzMQ=="}, "originalCommit": {"oid": "65ca29e4bfb1a0dc07a9301ea15a7f5028fb180c"}, "originalPosition": 184}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4194, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}