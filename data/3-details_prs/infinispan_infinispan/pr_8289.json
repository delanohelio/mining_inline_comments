{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MjgzODMz", "number": 8289, "title": "ISPN-11780 updating xsite docs for IRAC implementation", "bodyText": "https://issues.redhat.com/browse/ISPN-11780", "createdAt": "2020-05-06T19:16:36Z", "url": "https://github.com/infinispan/infinispan/pull/8289", "merged": true, "mergeCommit": {"oid": "f23d35f89bc8ea7850dda8e8c8b8e14066d2a541"}, "closed": true, "closedAt": "2020-05-18T19:46:45Z", "author": {"login": "oraNod"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceuObQABqjMzMTAwNTcxOTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcilSlxAFqTQxMzg5MDYyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "380600ebcd484125f9452976b9198c19cdf8bd0d", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/380600ebcd484125f9452976b9198c19cdf8bd0d", "committedDate": "2020-05-06T19:15:45Z", "message": "ISPN-11780 updating xsite docs for IRAC implementation"}, "afterCommit": {"oid": "33364793a73e7e3d490d13a1c7e1e856b5e59cbf", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/33364793a73e7e3d490d13a1c7e1e856b5e59cbf", "committedDate": "2020-05-06T19:54:56Z", "message": "ISPN-11780 updating xsite docs for IRAC implementation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "33364793a73e7e3d490d13a1c7e1e856b5e59cbf", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/33364793a73e7e3d490d13a1c7e1e856b5e59cbf", "committedDate": "2020-05-06T19:54:56Z", "message": "ISPN-11780 updating xsite docs for IRAC implementation"}, "afterCommit": {"oid": "fb1bdfdf02cc1d665aaa601cf1e211ce1c4bce69", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/fb1bdfdf02cc1d665aaa601cf1e211ce1c4bce69", "committedDate": "2020-05-12T15:41:56Z", "message": "be more explicit about conflict resolution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb1bdfdf02cc1d665aaa601cf1e211ce1c4bce69", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/fb1bdfdf02cc1d665aaa601cf1e211ce1c4bce69", "committedDate": "2020-05-12T15:41:56Z", "message": "be more explicit about conflict resolution"}, "afterCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/edc8eb82ebcf42a8127a49c2eecb7a9403f789f7", "committedDate": "2020-05-14T09:45:22Z", "message": "ISPN-11780 updating xsite docs for IRAC implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNDI1OTUw", "url": "https://github.com/infinispan/infinispan/pull/8289#pullrequestreview-412425950", "createdAt": "2020-05-15T07:55:52Z", "commit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzo1NTo1M1rOGV6XuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwODowMToxNFrOGV6iyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyOTYyNA==", "bodyText": "remove  {infinispanversion}? wdyt?", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425629624", "createdAt": "2020-05-15T07:55:53Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/titles/xsite/xsite.asciidoc", "diffHunk": "@@ -14,7 +14,12 @@ include::../{topics}/attributes/community-attributes.adoc[]\n :stem: asciimath\n \n //Title\n-= Replicating Data Across Sites with {brandname} {infinispanversion}\n+= {brandname} {infinispanversion} Guide to Cross-Site Replication", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMDI3Ng==", "bodyText": "typo? is => isn't", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425630276", "createdAt": "2020-05-15T07:57:13Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMTcwNg==", "bodyText": "link to compareTo javadoc?\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/String.html#compareTo-java.lang.String-", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425631706", "createdAt": "2020-05-15T07:59:52Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.\n \n-//Following the same example, if \"k1\" conflicts between **LON** and **NYC**,\n-//{brandname} always uses \"k1\" in **LON**.\n+When it finds conflicting entries, {brandname} uses the Java `compareTo(String", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMjQ1OA==", "bodyText": "I may be confused, but I think it is lexicographically lower/lesser... A is preceding B.", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425632458", "createdAt": "2020-05-15T08:01:14Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.\n \n-//Following the same example, if \"k1\" conflicts between **LON** and **NYC**,\n-//{brandname} always uses \"k1\" in **LON**.\n+When it finds conflicting entries, {brandname} uses the Java `compareTo(String\n+anotherString)` method to compare site names. To determine which key takes\n+priority, {brandname} selects the site name that is lexicographically greater", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7"}, "originalPosition": 79}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04640f384c300c0d56f05484e6275fdc2295a94c", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/04640f384c300c0d56f05484e6275fdc2295a94c", "committedDate": "2020-05-15T10:52:19Z", "message": "ISPN-11780 updating xsite docs for IRAC implementation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/edc8eb82ebcf42a8127a49c2eecb7a9403f789f7", "committedDate": "2020-05-14T09:45:22Z", "message": "ISPN-11780 updating xsite docs for IRAC implementation"}, "afterCommit": {"oid": "04640f384c300c0d56f05484e6275fdc2295a94c", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/04640f384c300c0d56f05484e6275fdc2295a94c", "committedDate": "2020-05-15T10:52:19Z", "message": "ISPN-11780 updating xsite docs for IRAC implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06893859b617d2bb99aac03c29774e2c4fce3475", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/06893859b617d2bb99aac03c29774e2c4fce3475", "committedDate": "2020-05-15T14:52:43Z", "message": "add tip for number in site name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNzIwNjY3", "url": "https://github.com/infinispan/infinispan/pull/8289#pullrequestreview-412720667", "createdAt": "2020-05-15T14:54:08Z", "commit": {"oid": "06893859b617d2bb99aac03c29774e2c4fce3475"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDo1NDowOFrOGWIQcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDo1NDowOFrOGWIQcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1NzEzNw==", "bodyText": "@tristantarrant How about this as a tip to assign priority to sites?", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425857137", "createdAt": "2020-05-15T14:54:08Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,61 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n+\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//dnaro: notes for IRAC conflict resolution\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is not strictly greater or less between **LON** and **NYC**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+When it finds conflicting entries, {brandname} uses the Java `compareTo(String\n+anotherString)` method to compare site names. To determine which key takes\n+priority, {brandname} selects the site name that is lexicographically less\n+than the other. Keys from a site named **AAA** take priority over keys from a\n+site named **AAB** and so on.\n \n-//Following the same example, if \"k1\" conflicts between **LON** and **NYC**,\n-//{brandname} always uses \"k1\" in **LON**.\n+Following the same example, to resolve the conflict for \"k1\", {brandname} uses\n+the value for \"k1\" that originates from **LON**. This results in \"k1=5\" in both\n+**LON** and **NYC** after {brandname} resolves the conflict and replicates the\n+value.\n+\n+[TIP]\n+====\n+Prepend site names with numbers as a simple way to represent the order of\n+priority for resolving conflicting entries; for example, **1LON** and **2NYC**.\n+====", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06893859b617d2bb99aac03c29774e2c4fce3475"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzODkwNjI4", "url": "https://github.com/infinispan/infinispan/pull/8289#pullrequestreview-413890628", "createdAt": "2020-05-18T19:46:18Z", "commit": {"oid": "06893859b617d2bb99aac03c29774e2c4fce3475"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 720, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}