{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0MDM0OTk4", "number": 8611, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0NjoxOFrOEf-USg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1NToxNFrOEf-ieA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTYyMzE0OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Backup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0NjoxOFrOHMk6Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzoyNDoxNVrOHMmaeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTY5NA==", "bodyText": "the cast can't fail ?", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482949694", "createdAt": "2020-09-03T12:46:18Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Backup.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package org.infinispan.cli.commands;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.aesh.io.FileResource;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.completers.BackupCompleter;\n+import org.infinispan.cli.completers.CacheCompleter;\n+import org.infinispan.cli.completers.CacheConfigurationCompleter;\n+import org.infinispan.cli.completers.CounterCompleter;\n+import org.infinispan.cli.completers.SchemaCompleter;\n+import org.infinispan.cli.completers.TaskCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Backup.CMD, description = \"Manages container backup creation and restoration\", activator = ConnectionActivator.class,\n+      groupCommands = {Backup.Create.class, Backup.Delete.class, Backup.Get.class, Backup.ListBackups.class, Backup.Restore.class})\n+public class Backup extends CliCommand {\n+\n+   public static final String CMD = \"backup\";\n+   public static final String CACHES = \"caches\";\n+   public static final String CACHE_CONFIGS = \"cache-configs\";\n+   public static final String COUNTERS = \"counters\";\n+   public static final String PROTO_SCHEMAS = \"proto-schemas\";\n+   public static final String SCRIPTS = \"scripts\";\n+   public static final String[] ALL_RESOURCE_TYPES = new String[]{CACHES, CACHE_CONFIGS, COUNTERS, PROTO_SCHEMAS, SCRIPTS};\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   public static Map<String, List<String>> createResourceMap(CommandInputLine cmd) {\n+      Map<String, List<String>> resourceMap = new HashMap<>();\n+      for (String resource : Backup.ALL_RESOURCE_TYPES) {\n+         if (cmd.hasArg(resource)) {\n+            resourceMap.put(resource, cmd.argAs(resource));\n+         }\n+      }\n+      return resourceMap;\n+   }\n+\n+   @CommandDefinition(name = Delete.CMD, description = \"Delete a backup on the server\", activator = ConnectionActivator.class)\n+   public static class Delete extends AbstractBackupCommand {\n+      public static final String CMD = \"delete\";\n+\n+      @Argument(description = \"The name of the backup\", completer = BackupCompleter.class, required = true)\n+      String name;\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         return invocation.execute(\n+               new CommandInputLine(Backup.CMD)\n+                     .arg(TYPE, CMD)\n+                     .arg(NAME, name)\n+         );\n+      }\n+   }\n+\n+   @CommandDefinition(name = Get.CMD, description = \"Get a backup from the server\", activator = ConnectionActivator.class)\n+   public static class Get extends AbstractBackupCommand {\n+      public static final String CMD = \"get\";\n+      public static final String NO_CONTENT = \"no-content\";\n+\n+      @Argument(description = \"The name of the backup\", completer = BackupCompleter.class, required = true)\n+      String name;\n+\n+      @Option(description = \"No content is downloaded, but the command only returns once the backup has finished\", hasValue = false, name = NO_CONTENT)\n+      boolean noContent;\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         return invocation.execute(\n+               new CommandInputLine(Backup.CMD)\n+                     .arg(TYPE, CMD)\n+                     .arg(NAME, name)\n+                     .option(NO_CONTENT, noContent)\n+         );\n+      }\n+   }\n+\n+   @CommandDefinition(name = ListBackups.CMD, description = \"List all backups on the server\", activator = ConnectionActivator.class)\n+   public static class ListBackups extends AbstractBackupCommand {\n+      public static final String CMD = \"ls\";\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         return invocation.execute(\n+               new CommandInputLine(Backup.CMD)\n+                     .arg(TYPE, CMD)\n+         );\n+      }\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Create a backup on the server\", activator = ConnectionActivator.class)\n+   public static class Create extends AbstractResourceCommand {\n+      public static final String CMD = \"create\";\n+      public static final String DIR = \"dir\";\n+\n+      @Option(shortName = 'd', description = \"The directory on the server to be used for creating and storing the backup\")\n+      String dir;\n+\n+      @Option(shortName = 'n', description = \"The name of the backup\")\n+      String name;\n+\n+      public Create() {\n+         super(CMD);\n+      }\n+\n+      @Override\n+      protected void additionalArgs(CommandInputLine cmd) {\n+         cmd.option(DIR, dir)\n+               .option(NAME, name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = Restore.CMD, description = \"Restore a backup\", activator = ConnectionActivator.class)\n+   public static class Restore extends AbstractResourceCommand {\n+      public static final String CMD = \"restore\";\n+      public static final String UPLOAD_BACKUP = \"upload-backup\";\n+\n+      @Argument(description = \"The path of the backup file \", completer = FileOptionCompleter.class, required = true)\n+      Resource path;\n+\n+      @Option(shortName = 'u', description = \"Indicates that the path is a local file which must be uploaded to the server\", hasValue = false, name = UPLOAD_BACKUP)\n+      boolean upload;\n+\n+      public Restore() {\n+         super(CMD);\n+      }\n+\n+      @Override\n+      protected void additionalArgs(CommandInputLine cmd) {\n+         if (!upload && !((FileResource) path).getFile().isAbsolute())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3NDMzMA==", "bodyText": "I don't think so, the only other implementation is PipelineResource which returns \"\" or false for all methods. Unfortunately it's not possible to use FileResource directly as the variable type, because aesh does not know how to set the value, resulting in a NPE being thrown.", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482974330", "createdAt": "2020-09-03T13:24:15Z", "author": {"login": "ryanemerson"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Backup.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package org.infinispan.cli.commands;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.aesh.io.FileResource;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.completers.BackupCompleter;\n+import org.infinispan.cli.completers.CacheCompleter;\n+import org.infinispan.cli.completers.CacheConfigurationCompleter;\n+import org.infinispan.cli.completers.CounterCompleter;\n+import org.infinispan.cli.completers.SchemaCompleter;\n+import org.infinispan.cli.completers.TaskCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Ryan Emerson\n+ * @since 12.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Backup.CMD, description = \"Manages container backup creation and restoration\", activator = ConnectionActivator.class,\n+      groupCommands = {Backup.Create.class, Backup.Delete.class, Backup.Get.class, Backup.ListBackups.class, Backup.Restore.class})\n+public class Backup extends CliCommand {\n+\n+   public static final String CMD = \"backup\";\n+   public static final String CACHES = \"caches\";\n+   public static final String CACHE_CONFIGS = \"cache-configs\";\n+   public static final String COUNTERS = \"counters\";\n+   public static final String PROTO_SCHEMAS = \"proto-schemas\";\n+   public static final String SCRIPTS = \"scripts\";\n+   public static final String[] ALL_RESOURCE_TYPES = new String[]{CACHES, CACHE_CONFIGS, COUNTERS, PROTO_SCHEMAS, SCRIPTS};\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   public static Map<String, List<String>> createResourceMap(CommandInputLine cmd) {\n+      Map<String, List<String>> resourceMap = new HashMap<>();\n+      for (String resource : Backup.ALL_RESOURCE_TYPES) {\n+         if (cmd.hasArg(resource)) {\n+            resourceMap.put(resource, cmd.argAs(resource));\n+         }\n+      }\n+      return resourceMap;\n+   }\n+\n+   @CommandDefinition(name = Delete.CMD, description = \"Delete a backup on the server\", activator = ConnectionActivator.class)\n+   public static class Delete extends AbstractBackupCommand {\n+      public static final String CMD = \"delete\";\n+\n+      @Argument(description = \"The name of the backup\", completer = BackupCompleter.class, required = true)\n+      String name;\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         return invocation.execute(\n+               new CommandInputLine(Backup.CMD)\n+                     .arg(TYPE, CMD)\n+                     .arg(NAME, name)\n+         );\n+      }\n+   }\n+\n+   @CommandDefinition(name = Get.CMD, description = \"Get a backup from the server\", activator = ConnectionActivator.class)\n+   public static class Get extends AbstractBackupCommand {\n+      public static final String CMD = \"get\";\n+      public static final String NO_CONTENT = \"no-content\";\n+\n+      @Argument(description = \"The name of the backup\", completer = BackupCompleter.class, required = true)\n+      String name;\n+\n+      @Option(description = \"No content is downloaded, but the command only returns once the backup has finished\", hasValue = false, name = NO_CONTENT)\n+      boolean noContent;\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         return invocation.execute(\n+               new CommandInputLine(Backup.CMD)\n+                     .arg(TYPE, CMD)\n+                     .arg(NAME, name)\n+                     .option(NO_CONTENT, noContent)\n+         );\n+      }\n+   }\n+\n+   @CommandDefinition(name = ListBackups.CMD, description = \"List all backups on the server\", activator = ConnectionActivator.class)\n+   public static class ListBackups extends AbstractBackupCommand {\n+      public static final String CMD = \"ls\";\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         return invocation.execute(\n+               new CommandInputLine(Backup.CMD)\n+                     .arg(TYPE, CMD)\n+         );\n+      }\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Create a backup on the server\", activator = ConnectionActivator.class)\n+   public static class Create extends AbstractResourceCommand {\n+      public static final String CMD = \"create\";\n+      public static final String DIR = \"dir\";\n+\n+      @Option(shortName = 'd', description = \"The directory on the server to be used for creating and storing the backup\")\n+      String dir;\n+\n+      @Option(shortName = 'n', description = \"The name of the backup\")\n+      String name;\n+\n+      public Create() {\n+         super(CMD);\n+      }\n+\n+      @Override\n+      protected void additionalArgs(CommandInputLine cmd) {\n+         cmd.option(DIR, dir)\n+               .option(NAME, name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = Restore.CMD, description = \"Restore a backup\", activator = ConnectionActivator.class)\n+   public static class Restore extends AbstractResourceCommand {\n+      public static final String CMD = \"restore\";\n+      public static final String UPLOAD_BACKUP = \"upload-backup\";\n+\n+      @Argument(description = \"The path of the backup file \", completer = FileOptionCompleter.class, required = true)\n+      Resource path;\n+\n+      @Option(shortName = 'u', description = \"Indicates that the path is a local file which must be uploaded to the server\", hasValue = false, name = UPLOAD_BACKUP)\n+      boolean upload;\n+\n+      public Restore() {\n+         super(CMD);\n+      }\n+\n+      @Override\n+      protected void additionalArgs(CommandInputLine cmd) {\n+         if (!upload && !((FileResource) path).getFile().isAbsolute())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0OTY5NA=="}, "originalCommit": {"oid": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTYzMzg0OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/completers/BackupCompleter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0OTowN1rOHMlA9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0OTowN1rOHMlA9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MTQxMg==", "bodyText": "javadoc ?", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482951412", "createdAt": "2020-09-03T12:49:07Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/completers/BackupCompleter.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package org.infinispan.cli.completers;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+\n+import org.infinispan.cli.Context;\n+import org.infinispan.cli.connection.Connection;\n+\n+/**\n+ * @author Ryan Emerson", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTYzNDQzOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/completers/SchemaCompleter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0OToxNVrOHMlBSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo0OToxNVrOHMlBSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MTQ5OQ==", "bodyText": "javadoc ?", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482951499", "createdAt": "2020-09-03T12:49:15Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/completers/SchemaCompleter.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package org.infinispan.cli.completers;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import org.infinispan.cli.Context;\n+import org.infinispan.cli.connection.Connection;\n+import org.infinispan.cli.resources.ContainerResource;\n+\n+/**\n+ * @author Ryan Emerson", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTY1MzQ0OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1Mzo1M1rOHMlMxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzowMzo1OFrOHMllvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NDQzNg==", "bodyText": "shouldn't this have a line break at the end ?", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482954436", "createdAt": "2020-09-03T12:53:53Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "diffHunk": "@@ -247,6 +257,60 @@ public String execute(List<CommandInputLine> commands) throws IOException {\n                }\n                break;\n             }\n+            case Backup.CMD: {\n+               String container = getActiveContainer().getName();\n+               RestCacheManagerClient manager = this.client.cacheManager(container);\n+               responseMode = ResponseMode.BODY;\n+               String backupName;\n+               switch (command.arg(CliCommand.TYPE)) {\n+                  case Backup.Create.CMD:\n+                     backupName = command.optionOrDefault(Backup.NAME, () -> {\n+                        // If the backup name has not been specified generate one based upon the Infinispan version and timestamp\n+                        LocalDateTime now = LocalDateTime.now();\n+                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS\\n\", Version.getBrandName(), now);\n+                     });\n+\n+                     sb.append(\"Creating backup '\").append(backupName).append(\"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2MDgyOA==", "bodyText": "It's unnecessary, as the return value of execute(commands) is written via writeln(). \n  \n    \n      infinispan/cli/cli-client/src/main/java/org/infinispan/cli/impl/ContextImpl.java\n    \n    \n        Lines 221 to 224\n      in\n      fa05280\n    \n    \n    \n    \n\n        \n          \n           String response = connection.execute(commands); \n        \n\n        \n          \n           if (response != null && !response.isEmpty()) { \n        \n\n        \n          \n              shell.writeln(response); \n        \n\n        \n          \n           }", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482960828", "createdAt": "2020-09-03T13:03:58Z", "author": {"login": "ryanemerson"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "diffHunk": "@@ -247,6 +257,60 @@ public String execute(List<CommandInputLine> commands) throws IOException {\n                }\n                break;\n             }\n+            case Backup.CMD: {\n+               String container = getActiveContainer().getName();\n+               RestCacheManagerClient manager = this.client.cacheManager(container);\n+               responseMode = ResponseMode.BODY;\n+               String backupName;\n+               switch (command.arg(CliCommand.TYPE)) {\n+                  case Backup.Create.CMD:\n+                     backupName = command.optionOrDefault(Backup.NAME, () -> {\n+                        // If the backup name has not been specified generate one based upon the Infinispan version and timestamp\n+                        LocalDateTime now = LocalDateTime.now();\n+                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS\\n\", Version.getBrandName(), now);\n+                     });\n+\n+                     sb.append(\"Creating backup '\").append(backupName).append(\"'\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NDQzNg=="}, "originalCommit": {"oid": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTY1NDI3OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1NDowNlrOHMlNTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1NDowNlrOHMlNTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NDU3NA==", "bodyText": "same, line break ?", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482954574", "createdAt": "2020-09-03T12:54:06Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "diffHunk": "@@ -247,6 +257,60 @@ public String execute(List<CommandInputLine> commands) throws IOException {\n                }\n                break;\n             }\n+            case Backup.CMD: {\n+               String container = getActiveContainer().getName();\n+               RestCacheManagerClient manager = this.client.cacheManager(container);\n+               responseMode = ResponseMode.BODY;\n+               String backupName;\n+               switch (command.arg(CliCommand.TYPE)) {\n+                  case Backup.Create.CMD:\n+                     backupName = command.optionOrDefault(Backup.NAME, () -> {\n+                        // If the backup name has not been specified generate one based upon the Infinispan version and timestamp\n+                        LocalDateTime now = LocalDateTime.now();\n+                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS\\n\", Version.getBrandName(), now);\n+                     });\n+\n+                     sb.append(\"Creating backup '\").append(backupName).append(\"'\");\n+                     String directory = command.arg(Backup.Create.DIR);\n+                     response = manager.createBackup(backupName, directory, Backup.createResourceMap(command));\n+                     break;\n+                  case Backup.Delete.CMD:\n+                     backupName = command.arg(Backup.NAME);\n+                     sb.append(\"Deleting backup '\").append(backupName).append(\"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTY1ODc2OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1NTowM1rOHMlP_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1NTowM1rOHMlP_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTI2MQ==", "bodyText": "line break ?", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482955261", "createdAt": "2020-09-03T12:55:03Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "diffHunk": "@@ -247,6 +257,60 @@ public String execute(List<CommandInputLine> commands) throws IOException {\n                }\n                break;\n             }\n+            case Backup.CMD: {\n+               String container = getActiveContainer().getName();\n+               RestCacheManagerClient manager = this.client.cacheManager(container);\n+               responseMode = ResponseMode.BODY;\n+               String backupName;\n+               switch (command.arg(CliCommand.TYPE)) {\n+                  case Backup.Create.CMD:\n+                     backupName = command.optionOrDefault(Backup.NAME, () -> {\n+                        // If the backup name has not been specified generate one based upon the Infinispan version and timestamp\n+                        LocalDateTime now = LocalDateTime.now();\n+                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS\\n\", Version.getBrandName(), now);\n+                     });\n+\n+                     sb.append(\"Creating backup '\").append(backupName).append(\"'\");\n+                     String directory = command.arg(Backup.Create.DIR);\n+                     response = manager.createBackup(backupName, directory, Backup.createResourceMap(command));\n+                     break;\n+                  case Backup.Delete.CMD:\n+                     backupName = command.arg(Backup.NAME);\n+                     sb.append(\"Deleting backup '\").append(backupName).append(\"'\");\n+                     response = manager.deleteBackup(backupName);\n+                     break;\n+                  case Backup.Get.CMD:\n+                     boolean skipBody = command.boolOption(Backup.Get.NO_CONTENT);\n+                     responseMode = skipBody ? ResponseMode.QUIET : ResponseMode.FILE;\n+                     backupName = command.arg(Backup.NAME);\n+                     sb.append(\"Downloading backup '\").append(backupName).append(\"'\\n\");\n+                     // Poll the backup's availability every 500 milliseconds with a maximum of 100 attempts\n+                     response = Flowable.timer(500, TimeUnit.MILLISECONDS, Schedulers.trampoline())\n+                           .repeat(100)\n+                           .flatMapSingle(Void -> Single.fromCompletionStage(manager.getBackup(backupName, skipBody)))\n+                           .takeUntil(rsp -> rsp.getStatus() != 202)\n+                           .lastOrErrorStage();\n+                     break;\n+                  case Backup.ListBackups.CMD:\n+                     sb.append(String.join(\"\\n\", getBackupNames(container)));\n+                     break;\n+                  case Backup.Restore.CMD:\n+                     Map<String, List<String>> resources = Backup.createResourceMap(command);\n+                     Boolean upload = command.argAs(Backup.Restore.UPLOAD_BACKUP);\n+                     FileResource resource = command.argAs(Backup.Restore.PATH);\n+                     if (upload != null && upload) {\n+                        File file = resource.getFile();\n+                        sb.append(\"Uploading backup '\").append(file.getName()).append(\"' and restoring\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTY1OTQ0OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1NToxNFrOHMlQcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMjo1NToxNFrOHMlQcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1NTM3OA==", "bodyText": "line break ?", "url": "https://github.com/infinispan/infinispan/pull/8611#discussion_r482955378", "createdAt": "2020-09-03T12:55:14Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "diffHunk": "@@ -247,6 +257,60 @@ public String execute(List<CommandInputLine> commands) throws IOException {\n                }\n                break;\n             }\n+            case Backup.CMD: {\n+               String container = getActiveContainer().getName();\n+               RestCacheManagerClient manager = this.client.cacheManager(container);\n+               responseMode = ResponseMode.BODY;\n+               String backupName;\n+               switch (command.arg(CliCommand.TYPE)) {\n+                  case Backup.Create.CMD:\n+                     backupName = command.optionOrDefault(Backup.NAME, () -> {\n+                        // If the backup name has not been specified generate one based upon the Infinispan version and timestamp\n+                        LocalDateTime now = LocalDateTime.now();\n+                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS\\n\", Version.getBrandName(), now);\n+                     });\n+\n+                     sb.append(\"Creating backup '\").append(backupName).append(\"'\");\n+                     String directory = command.arg(Backup.Create.DIR);\n+                     response = manager.createBackup(backupName, directory, Backup.createResourceMap(command));\n+                     break;\n+                  case Backup.Delete.CMD:\n+                     backupName = command.arg(Backup.NAME);\n+                     sb.append(\"Deleting backup '\").append(backupName).append(\"'\");\n+                     response = manager.deleteBackup(backupName);\n+                     break;\n+                  case Backup.Get.CMD:\n+                     boolean skipBody = command.boolOption(Backup.Get.NO_CONTENT);\n+                     responseMode = skipBody ? ResponseMode.QUIET : ResponseMode.FILE;\n+                     backupName = command.arg(Backup.NAME);\n+                     sb.append(\"Downloading backup '\").append(backupName).append(\"'\\n\");\n+                     // Poll the backup's availability every 500 milliseconds with a maximum of 100 attempts\n+                     response = Flowable.timer(500, TimeUnit.MILLISECONDS, Schedulers.trampoline())\n+                           .repeat(100)\n+                           .flatMapSingle(Void -> Single.fromCompletionStage(manager.getBackup(backupName, skipBody)))\n+                           .takeUntil(rsp -> rsp.getStatus() != 202)\n+                           .lastOrErrorStage();\n+                     break;\n+                  case Backup.ListBackups.CMD:\n+                     sb.append(String.join(\"\\n\", getBackupNames(container)));\n+                     break;\n+                  case Backup.Restore.CMD:\n+                     Map<String, List<String>> resources = Backup.createResourceMap(command);\n+                     Boolean upload = command.argAs(Backup.Restore.UPLOAD_BACKUP);\n+                     FileResource resource = command.argAs(Backup.Restore.PATH);\n+                     if (upload != null && upload) {\n+                        File file = resource.getFile();\n+                        sb.append(\"Uploading backup '\").append(file.getName()).append(\"' and restoring\");\n+                        response = manager.restore(file, resources);\n+                     } else {\n+                        String path = resource.getAbsolutePath();\n+                        sb.append(\"Restoring from backup '\").append(path).append(\"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "020eec662a0d06ab47d6c2331a44ed0a8fdff29b"}, "originalPosition": 98}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3880, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}