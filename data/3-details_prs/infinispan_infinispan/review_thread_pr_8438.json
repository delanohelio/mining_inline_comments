{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NjE5OTUw", "number": 8438, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTowODoxMlrOEEVsYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNToxMToyMFrOEEVxlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTg1MTg3OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTowODoxMlrOGh5c8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjowMjo0N1rOGh76cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzQ5MQ==", "bodyText": "Why are all these Object, Object instead of parameterized as K, V ?", "url": "https://github.com/infinispan/infinispan/pull/8438#discussion_r438197491", "createdAt": "2020-06-10T15:08:12Z", "author": {"login": "tristantarrant"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java", "diffHunk": "@@ -238,11 +253,36 @@\n     */\n    CloseableIterator<Entry<Object, Object>> retrieveEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);\n \n+   /**\n+    * Publish entries from the server matching a query.\n+    * <p>\n+    * Any subscriber that subscribes to the returned Publisher must not block. It is therefore recommended to offload\n+    * any blocking or long running operations to a different thread and not use the invoking one. Failure to do so\n+    * may cause concurrent operations to stall.\n+    * @param filterQuery {@link Query}\n+    * @param segments    The segments to utilize. If null all segments will be utilized. An empty set will filter out all entries.\n+    * @param batchSize   The number of entries transferred from the server at a time.\n+    * @return Publisher containing matching entries\n+    */\n+   Publisher<Entry<Object, Object>> publishEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "371d44e518f606d6d4bdb90b1a8ac1031c506f23"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIwMzcwMg==", "bodyText": "I guess this comes from a long a time ago in the original methods: they all take either a Query or a filterConverterFactory, so it's technically not always a K,V", "url": "https://github.com/infinispan/infinispan/pull/8438#discussion_r438203702", "createdAt": "2020-06-10T15:16:45Z", "author": {"login": "gustavonalle"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java", "diffHunk": "@@ -238,11 +253,36 @@\n     */\n    CloseableIterator<Entry<Object, Object>> retrieveEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);\n \n+   /**\n+    * Publish entries from the server matching a query.\n+    * <p>\n+    * Any subscriber that subscribes to the returned Publisher must not block. It is therefore recommended to offload\n+    * any blocking or long running operations to a different thread and not use the invoking one. Failure to do so\n+    * may cause concurrent operations to stall.\n+    * @param filterQuery {@link Query}\n+    * @param segments    The segments to utilize. If null all segments will be utilized. An empty set will filter out all entries.\n+    * @param batchSize   The number of entries transferred from the server at a time.\n+    * @return Publisher containing matching entries\n+    */\n+   Publisher<Entry<Object, Object>> publishEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzQ5MQ=="}, "originalCommit": {"oid": "371d44e518f606d6d4bdb90b1a8ac1031c506f23"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIwNDgyMA==", "bodyText": "Unfortunately the query and converter/filter can change the returned types. We might be able to change the first to K. Unfortunately the previous methods were like this so I am not 100% sure.", "url": "https://github.com/infinispan/infinispan/pull/8438#discussion_r438204820", "createdAt": "2020-06-10T15:18:17Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java", "diffHunk": "@@ -238,11 +253,36 @@\n     */\n    CloseableIterator<Entry<Object, Object>> retrieveEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);\n \n+   /**\n+    * Publish entries from the server matching a query.\n+    * <p>\n+    * Any subscriber that subscribes to the returned Publisher must not block. It is therefore recommended to offload\n+    * any blocking or long running operations to a different thread and not use the invoking one. Failure to do so\n+    * may cause concurrent operations to stall.\n+    * @param filterQuery {@link Query}\n+    * @param segments    The segments to utilize. If null all segments will be utilized. An empty set will filter out all entries.\n+    * @param batchSize   The number of entries transferred from the server at a time.\n+    * @return Publisher containing matching entries\n+    */\n+   Publisher<Entry<Object, Object>> publishEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzQ5MQ=="}, "originalCommit": {"oid": "371d44e518f606d6d4bdb90b1a8ac1031c506f23"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyNTA5MA==", "bodyText": "Then I think these should be declared as:\n<K1, V1> Publisher<Entry<K1, V1>> publishEntriesByQuery...", "url": "https://github.com/infinispan/infinispan/pull/8438#discussion_r438225090", "createdAt": "2020-06-10T15:44:42Z", "author": {"login": "tristantarrant"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java", "diffHunk": "@@ -238,11 +253,36 @@\n     */\n    CloseableIterator<Entry<Object, Object>> retrieveEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);\n \n+   /**\n+    * Publish entries from the server matching a query.\n+    * <p>\n+    * Any subscriber that subscribes to the returned Publisher must not block. It is therefore recommended to offload\n+    * any blocking or long running operations to a different thread and not use the invoking one. Failure to do so\n+    * may cause concurrent operations to stall.\n+    * @param filterQuery {@link Query}\n+    * @param segments    The segments to utilize. If null all segments will be utilized. An empty set will filter out all entries.\n+    * @param batchSize   The number of entries transferred from the server at a time.\n+    * @return Publisher containing matching entries\n+    */\n+   Publisher<Entry<Object, Object>> publishEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzQ5MQ=="}, "originalCommit": {"oid": "371d44e518f606d6d4bdb90b1a8ac1031c506f23"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyNzE2NQ==", "bodyText": "Then I think these should be declared as:\n<K1, V1> Publisher<Entry<K1, V1>> publishEntriesByQuery...\n\nSure, I think I can do it as <E> Publisher<Entry<K, E>> publishEntriesByQuery. However the query one may be just Publisher<Entry<K, V>> as I am not sure if it can do translations or not.", "url": "https://github.com/infinispan/infinispan/pull/8438#discussion_r438227165", "createdAt": "2020-06-10T15:47:42Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java", "diffHunk": "@@ -238,11 +253,36 @@\n     */\n    CloseableIterator<Entry<Object, Object>> retrieveEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);\n \n+   /**\n+    * Publish entries from the server matching a query.\n+    * <p>\n+    * Any subscriber that subscribes to the returned Publisher must not block. It is therefore recommended to offload\n+    * any blocking or long running operations to a different thread and not use the invoking one. Failure to do so\n+    * may cause concurrent operations to stall.\n+    * @param filterQuery {@link Query}\n+    * @param segments    The segments to utilize. If null all segments will be utilized. An empty set will filter out all entries.\n+    * @param batchSize   The number of entries transferred from the server at a time.\n+    * @return Publisher containing matching entries\n+    */\n+   Publisher<Entry<Object, Object>> publishEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzQ5MQ=="}, "originalCommit": {"oid": "371d44e518f606d6d4bdb90b1a8ac1031c506f23"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIzNjY0MQ==", "bodyText": "The query one can return either V or Object[]", "url": "https://github.com/infinispan/infinispan/pull/8438#discussion_r438236641", "createdAt": "2020-06-10T16:01:00Z", "author": {"login": "gustavonalle"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java", "diffHunk": "@@ -238,11 +253,36 @@\n     */\n    CloseableIterator<Entry<Object, Object>> retrieveEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);\n \n+   /**\n+    * Publish entries from the server matching a query.\n+    * <p>\n+    * Any subscriber that subscribes to the returned Publisher must not block. It is therefore recommended to offload\n+    * any blocking or long running operations to a different thread and not use the invoking one. Failure to do so\n+    * may cause concurrent operations to stall.\n+    * @param filterQuery {@link Query}\n+    * @param segments    The segments to utilize. If null all segments will be utilized. An empty set will filter out all entries.\n+    * @param batchSize   The number of entries transferred from the server at a time.\n+    * @return Publisher containing matching entries\n+    */\n+   Publisher<Entry<Object, Object>> publishEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzQ5MQ=="}, "originalCommit": {"oid": "371d44e518f606d6d4bdb90b1a8ac1031c506f23"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIzNzgxMQ==", "bodyText": "Yeah, I peaked at the code as well, thanks for the confirmation.\nI made it <E> Publisher<Entry<K, E> publishEntriesByQuery.", "url": "https://github.com/infinispan/infinispan/pull/8438#discussion_r438237811", "createdAt": "2020-06-10T16:02:47Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java", "diffHunk": "@@ -238,11 +253,36 @@\n     */\n    CloseableIterator<Entry<Object, Object>> retrieveEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);\n \n+   /**\n+    * Publish entries from the server matching a query.\n+    * <p>\n+    * Any subscriber that subscribes to the returned Publisher must not block. It is therefore recommended to offload\n+    * any blocking or long running operations to a different thread and not use the invoking one. Failure to do so\n+    * may cause concurrent operations to stall.\n+    * @param filterQuery {@link Query}\n+    * @param segments    The segments to utilize. If null all segments will be utilized. An empty set will filter out all entries.\n+    * @param batchSize   The number of entries transferred from the server at a time.\n+    * @return Publisher containing matching entries\n+    */\n+   Publisher<Entry<Object, Object>> publishEntriesByQuery(Query filterQuery, Set<Integer> segments, int batchSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzQ5MQ=="}, "originalCommit": {"oid": "371d44e518f606d6d4bdb90b1a8ac1031c506f23"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTg2NTE4OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/RemoteInnerPublisherHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNToxMToyMFrOGh5lhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNToxODozMlrOGh56WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5OTY4Nw==", "bodyText": "warnings must have a log id", "url": "https://github.com/infinispan/infinispan/pull/8438#discussion_r438199687", "createdAt": "2020-06-10T15:11:20Z", "author": {"login": "tristantarrant"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/RemoteInnerPublisherHandler.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.infinispan.client.hotrod.impl.iteration;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.net.SocketAddress;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.client.hotrod.exceptions.RemoteIllegalLifecycleStateException;\n+import org.infinispan.client.hotrod.exceptions.TransportException;\n+import org.infinispan.client.hotrod.impl.operations.IterationNextResponse;\n+import org.infinispan.client.hotrod.impl.operations.IterationStartResponse;\n+import org.infinispan.client.hotrod.logging.Log;\n+import org.infinispan.client.hotrod.logging.LogFactory;\n+import org.infinispan.commons.reactive.AbstractAsyncPublisherHandler;\n+import org.infinispan.commons.util.IntSet;\n+import org.infinispan.commons.util.logging.TraceException;\n+\n+import io.netty.channel.Channel;\n+\n+class RemoteInnerPublisherHandler<E> extends AbstractAsyncPublisherHandler<Map.Entry<SocketAddress, IntSet>,\n+      Map.Entry<Object, E>, IterationStartResponse, IterationNextResponse<E>> {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+\n+   protected final RemotePublisher<E> publisher;\n+\n+   // Need to be volatile since cancel can come on a different thread\n+   protected volatile Channel channel;\n+   private volatile byte[] iterationId;\n+   private AtomicBoolean cancelled = new AtomicBoolean();\n+\n+   protected RemoteInnerPublisherHandler(RemotePublisher<E> parent, int batchSize,\n+         Supplier<Map.Entry<SocketAddress, IntSet>> supplier, Map.Entry<SocketAddress, IntSet> firstTarget) {\n+      super(batchSize, supplier, firstTarget);\n+      this.publisher = parent;\n+   }\n+\n+   private String iterationId() {\n+      return publisher.iterationId(iterationId);\n+   }\n+\n+   @Override\n+   protected void sendCancel(Map.Entry<SocketAddress, IntSet> target) {\n+      if (!cancelled.getAndSet(true)) {\n+         actualCancel();\n+      }\n+   }\n+\n+   private void actualCancel() {\n+      if (iterationId != null && channel != null) {\n+         // Just let cancel complete asynchronously\n+         publisher.sendCancel(iterationId, channel);\n+      }\n+   }\n+\n+   @Override\n+   protected CompletionStage<IterationStartResponse> sendInitialCommand(\n+         Map.Entry<SocketAddress, IntSet> target, int batchSize) {\n+      SocketAddress address = target.getKey();\n+      IntSet segments = target.getValue();\n+      if (log.isDebugEnabled()) {\n+         log.debugf(\"Starting iteration with segments %s\", segments);\n+      }\n+      return publisher.newIteratorStartOperation(address, segments, batchSize);\n+   }\n+\n+   @Override\n+   protected CompletionStage<IterationNextResponse<E>> sendNextCommand(Map.Entry<SocketAddress, IntSet> target, int batchSize) {\n+      return publisher.newIteratorNextOperation(iterationId, channel);\n+   }\n+\n+   @Override\n+   protected long handleInitialResponse(IterationStartResponse startResponse, Map.Entry<SocketAddress, IntSet> target) {\n+      this.channel = startResponse.getChannel();\n+      this.iterationId = startResponse.getIterationId();\n+      if (log.isDebugEnabled()) {\n+         log.iterationTransportObtained(channel.remoteAddress(), iterationId());\n+         log.startedIteration(iterationId());\n+      }\n+\n+      if (cancelled.get()) {\n+         actualCancel();\n+      }\n+      return 0;\n+   }\n+\n+   @Override\n+   protected long handleNextResponse(IterationNextResponse<E> nextResponse, Map.Entry<SocketAddress, IntSet> target) {\n+      if (!nextResponse.hasMore()) {\n+         // server doesn't clean up when complete\n+         sendCancel(target);\n+         publisher.completeSegments(target.getValue());\n+         targetComplete();\n+      }\n+      IntSet completedSegments = nextResponse.getCompletedSegments();\n+      if (completedSegments != null && log.isTraceEnabled()) {\n+         IntSet targetSegments = target.getValue();\n+         if (targetSegments != null) {\n+            targetSegments.removeAll(completedSegments);\n+         }\n+      }\n+      publisher.completeSegments(completedSegments);\n+      List<Map.Entry<Object, E>> entries = nextResponse.getEntries();\n+      for (Map.Entry<Object, E> entry : entries) {\n+         if (!onNext(entry)) {\n+            break;\n+         }\n+      }\n+      return entries.size();\n+   }\n+\n+   @Override\n+   protected void handleThrowableInResponse(Throwable t, Map.Entry<SocketAddress, IntSet> target) {\n+      if (t instanceof TransportException || t instanceof RemoteIllegalLifecycleStateException) {\n+         log.warnf(t, \"Error reaching the server during iteration\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "371d44e518f606d6d4bdb90b1a8ac1031c506f23"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIwNTAxNg==", "bodyText": "Sorry, this was taken from the previous code, let me change it over.", "url": "https://github.com/infinispan/infinispan/pull/8438#discussion_r438205016", "createdAt": "2020-06-10T15:18:32Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/RemoteInnerPublisherHandler.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.infinispan.client.hotrod.impl.iteration;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.net.SocketAddress;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.client.hotrod.exceptions.RemoteIllegalLifecycleStateException;\n+import org.infinispan.client.hotrod.exceptions.TransportException;\n+import org.infinispan.client.hotrod.impl.operations.IterationNextResponse;\n+import org.infinispan.client.hotrod.impl.operations.IterationStartResponse;\n+import org.infinispan.client.hotrod.logging.Log;\n+import org.infinispan.client.hotrod.logging.LogFactory;\n+import org.infinispan.commons.reactive.AbstractAsyncPublisherHandler;\n+import org.infinispan.commons.util.IntSet;\n+import org.infinispan.commons.util.logging.TraceException;\n+\n+import io.netty.channel.Channel;\n+\n+class RemoteInnerPublisherHandler<E> extends AbstractAsyncPublisherHandler<Map.Entry<SocketAddress, IntSet>,\n+      Map.Entry<Object, E>, IterationStartResponse, IterationNextResponse<E>> {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+\n+   protected final RemotePublisher<E> publisher;\n+\n+   // Need to be volatile since cancel can come on a different thread\n+   protected volatile Channel channel;\n+   private volatile byte[] iterationId;\n+   private AtomicBoolean cancelled = new AtomicBoolean();\n+\n+   protected RemoteInnerPublisherHandler(RemotePublisher<E> parent, int batchSize,\n+         Supplier<Map.Entry<SocketAddress, IntSet>> supplier, Map.Entry<SocketAddress, IntSet> firstTarget) {\n+      super(batchSize, supplier, firstTarget);\n+      this.publisher = parent;\n+   }\n+\n+   private String iterationId() {\n+      return publisher.iterationId(iterationId);\n+   }\n+\n+   @Override\n+   protected void sendCancel(Map.Entry<SocketAddress, IntSet> target) {\n+      if (!cancelled.getAndSet(true)) {\n+         actualCancel();\n+      }\n+   }\n+\n+   private void actualCancel() {\n+      if (iterationId != null && channel != null) {\n+         // Just let cancel complete asynchronously\n+         publisher.sendCancel(iterationId, channel);\n+      }\n+   }\n+\n+   @Override\n+   protected CompletionStage<IterationStartResponse> sendInitialCommand(\n+         Map.Entry<SocketAddress, IntSet> target, int batchSize) {\n+      SocketAddress address = target.getKey();\n+      IntSet segments = target.getValue();\n+      if (log.isDebugEnabled()) {\n+         log.debugf(\"Starting iteration with segments %s\", segments);\n+      }\n+      return publisher.newIteratorStartOperation(address, segments, batchSize);\n+   }\n+\n+   @Override\n+   protected CompletionStage<IterationNextResponse<E>> sendNextCommand(Map.Entry<SocketAddress, IntSet> target, int batchSize) {\n+      return publisher.newIteratorNextOperation(iterationId, channel);\n+   }\n+\n+   @Override\n+   protected long handleInitialResponse(IterationStartResponse startResponse, Map.Entry<SocketAddress, IntSet> target) {\n+      this.channel = startResponse.getChannel();\n+      this.iterationId = startResponse.getIterationId();\n+      if (log.isDebugEnabled()) {\n+         log.iterationTransportObtained(channel.remoteAddress(), iterationId());\n+         log.startedIteration(iterationId());\n+      }\n+\n+      if (cancelled.get()) {\n+         actualCancel();\n+      }\n+      return 0;\n+   }\n+\n+   @Override\n+   protected long handleNextResponse(IterationNextResponse<E> nextResponse, Map.Entry<SocketAddress, IntSet> target) {\n+      if (!nextResponse.hasMore()) {\n+         // server doesn't clean up when complete\n+         sendCancel(target);\n+         publisher.completeSegments(target.getValue());\n+         targetComplete();\n+      }\n+      IntSet completedSegments = nextResponse.getCompletedSegments();\n+      if (completedSegments != null && log.isTraceEnabled()) {\n+         IntSet targetSegments = target.getValue();\n+         if (targetSegments != null) {\n+            targetSegments.removeAll(completedSegments);\n+         }\n+      }\n+      publisher.completeSegments(completedSegments);\n+      List<Map.Entry<Object, E>> entries = nextResponse.getEntries();\n+      for (Map.Entry<Object, E> entry : entries) {\n+         if (!onNext(entry)) {\n+            break;\n+         }\n+      }\n+      return entries.size();\n+   }\n+\n+   @Override\n+   protected void handleThrowableInResponse(Throwable t, Map.Entry<SocketAddress, IntSet> target) {\n+      if (t instanceof TransportException || t instanceof RemoteIllegalLifecycleStateException) {\n+         log.warnf(t, \"Error reaching the server during iteration\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5OTY4Nw=="}, "originalCommit": {"oid": "371d44e518f606d6d4bdb90b1a8ac1031c506f23"}, "originalPosition": 117}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4063, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}