{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNzM4MTk0", "number": 8783, "title": "ISPN-12430 AsyncNonBlockingStore can have many more modifications tha\u2026", "bodyText": "\u2026n modification queue size\nhttps://issues.redhat.com/browse/ISPN-12430", "createdAt": "2020-10-15T01:09:56Z", "url": "https://github.com/infinispan/infinispan/pull/8783", "merged": true, "mergeCommit": {"oid": "f0e95349d3a0221a385ca642a59447de287d4278"}, "closed": true, "closedAt": "2021-01-22T15:18:39Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSz1wmgBqjM4ODIzNDIzMTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdyqrheABqjQyMzkwNDM3MjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0c0aa356b16420b7e21f3e76fe72da5d1826ff40", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/0c0aa356b16420b7e21f3e76fe72da5d1826ff40", "committedDate": "2020-10-15T01:09:45Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}, "afterCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/789067501e6bb7bd8bdab8a6921650ee247b4c19", "committedDate": "2020-10-15T15:51:36Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTMzMDA2", "url": "https://github.com/infinispan/infinispan/pull/8783#pullrequestreview-515133006", "createdAt": "2020-10-22T21:28:31Z", "commit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMToyODozMVrOHm0hcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzoyMjozOVrOHnBvRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODQ2NA==", "bodyText": "I'd like to see a comment explaining why is this true, or even better separate methods to manipulate the shared state atomically. It might also help to put hasPendingClear + pendingModifications in a State object, which could be then reused for the replicating modifications/clear.\nAlso, shouldn't this be checking replicatingClear as well?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510468464", "createdAt": "2020-10-22T21:28:31Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODU1Ng==", "bodyText": "The javadoc is outdated.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510468556", "createdAt": "2020-10-22T21:28:46Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ==", "bodyText": "Isn't it a risk that you're deciding to submit a new batch in one synchronized block and actually submitting the batch in a different block?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510477735", "createdAt": "2020-10-22T21:48:19Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODkwNg==", "bodyText": "The apply() implementations expect the call to be synchronized on this, but there's no hint in the interface.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510478906", "createdAt": "2020-10-22T21:51:02Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg==", "bodyText": "Hmmm, the javadoc of delete() doesn't say anything about the return value being optional.\nBut since it clearly is optional, could it be that we don't need the return value at all?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510675216", "createdAt": "2020-10-23T07:01:24Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg==", "bodyText": "There should be a comment explaining how these executors changes the test compared to using NamedExecutorsFactory.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510681072", "createdAt": "2020-10-23T07:14:33Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -100,12 +106,19 @@ void startMarshaller() {\n \n       nonBlockingExecutor = new ThreadPoolExecutor(0, ProcessorInfo.availableProcessors() * 2,\n             60L, TimeUnit.SECONDS,\n-            new LinkedBlockingQueue<>(),\n-            getTestThreadFactory(\"NonBlocking\"));\n+            new ArrayBlockingQueue<>(1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ==", "bodyText": "IMO the comment is misleading. It says \"This per-key lock holder provides guarantees that the final expected\nstate has not been affected by ordering issues\", but the key lock is held while performing the store write as well, not just while updating the expectedState map.\nSame with the withStore method, it should be withKeyLock IMO. Also, the worker thread blocks to wait for the key lock and for the store write, and I'm not sure if that scenario is still relevant.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510684999", "createdAt": "2020-10-23T07:22:39Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -134,7 +147,7 @@ void stopMarshaller() throws InterruptedException {\n    // ImmortalCacheEntry{key=key165168, value=ImmortalCacheValue {value=61456}}}\n    // (Thread-194:) Expected state updated with key=key165168, value=61456\n    // (Thread-200:) Expected state updated with key=key165168, value=60483\n-   private LockContainer locks = new PerKeyLockContainer();\n+   private LockContainer locks;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 67}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/789067501e6bb7bd8bdab8a6921650ee247b4c19", "committedDate": "2020-10-15T15:51:36Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}, "afterCommit": {"oid": "3915680c3e8d7623fe00252287b542d9ebfebea4", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/3915680c3e8d7623fe00252287b542d9ebfebea4", "committedDate": "2020-10-29T17:39:44Z", "message": "Rework comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3915680c3e8d7623fe00252287b542d9ebfebea4", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/3915680c3e8d7623fe00252287b542d9ebfebea4", "committedDate": "2020-10-29T17:39:44Z", "message": "Rework comments"}, "afterCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "committedDate": "2020-12-10T21:09:18Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MDYxMzQ0", "url": "https://github.com/infinispan/infinispan/pull/8783#pullrequestreview-557061344", "createdAt": "2020-12-22T12:59:37Z", "commit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjo1OTozOFrOIJ6W1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNTowMzoxM1rOIJ-Mew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDIxNQ==", "bodyText": "Kind of off-topic, but shouldn't we also set a stopping flag so new requests are rejected?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547264215", "createdAt": "2020-12-22T12:59:38Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -130,36 +117,23 @@ public AsyncNonBlockingStore(NonBlockingStore<K, V> actual) {\n       segmentCount = storeConfiguration.segmented() ? cacheConfiguration.clustering().hash().numSegments() : 1;\n       asyncConfiguration = storeConfiguration.async();\n       modificationQueueSize = asyncConfiguration.modificationQueueSize();\n-      // It is possible for multiple threads to write to this processor at the same time\n-      submissionFlowable = UnicastProcessor.<Modification>create(1).toSerialized();\n       nonBlockingExecutor = ctx.getNonBlockingExecutor();\n-      startSub = submissionFlowable.window(requestFlowable).subscribe(this);\n+      stopped = false;\n       return actual.start(ctx);\n    }\n \n    @Override\n    public CompletionStage<Void> stop() {\n       CompletionStage<Void> asyncStage;\n-      if (submissionFlowable != null) {\n-         if (trace) {\n-            log.tracef(\"Stopping async store containing store %s\", actual);\n-         }\n-         submissionFlowable = null;\n-         asyncStage = awaitQuiescence().whenComplete((ignore, t) -> {\n-            // We can only dispose of the subscription after we are sure we are totally stopped\n-            if (startSub != null) {\n-               startSub.dispose();\n-               startSub = null;\n-            }\n-         });\n-\n-      } else {\n-         asyncStage = CompletableFutures.completedNull();\n+      if (trace) {\n+         log.tracef(\"Stopping async store containing store %s\", actual);\n       }\n+      asyncStage = awaitQuiescence();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MDMyNw==", "bodyText": "Shouldn't this be\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     assert replicatingModifications == null || replicatingModifications.isEmpty() && !isReplicatingClear;\n          \n          \n            \n                     assert (replicatingModifications == null || replicatingModifications.isEmpty()) && !isReplicatingClear;", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547280327", "createdAt": "2020-12-22T13:34:25Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -197,84 +171,78 @@ private synchronized void putClearModification() {\n    }\n \n    /**\n-    * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n-    * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n+    * This method should only be invoked after the `batchFuture` was written to in a synchronized block.\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n-\n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         // The isReplicatingClear would be true or replicatingModifications non empty if an update was currently pending\n+         // But we should only allow one at a time\n+         assert replicatingModifications == null || replicatingModifications.isEmpty() && !isReplicatingClear;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NTkxOA==", "bodyText": "I was a bit scared of coming back to this, but let me try to understand this again.\n\nThe assignment of batchFuture protects that. You can only submit a batch if you assigned it to a new value.\n\nThe assignment of batchFuture itself doesn't really protect against anything. If thread A sees !pendingModifications.isEmpty() || hasPendingClear, it writes to batchFuture, but that doesn't prevent thread B from also seeing that !pendingModifications.isEmpty() || hasPendingClear and also writing to batchFuture.\n\nI'm pretty sure the assignment of batchFuture protects agains two threads both seeing a non-empty pendingModifications\n\nI think I meant \"I'm not sure\", at least that's how I see it now.\n\nYou can only submit a batch if you wrote to batchFuture though.\n\nBut there's nothing preventing you from writing to batchFuture here. If there is something somewhere else, I think that link should be made clearer by adding a comment or by moving that code closer.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547285918", "createdAt": "2020-12-22T13:46:02Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5MzY5NA==", "bodyText": "Since the elements of the flatMap() flowable are CompletionStages, is it really ok to ignore all but the last element?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547293694", "createdAt": "2020-12-22T14:01:03Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTU5Ng==", "bodyText": "Incomplete statement.\nI'd also replace the passive voice (\"It is assumed that\") w/ something more imperative, e.g. \"This method is not thread safe, callers must ensure that it is not invoked on multiple threads in parallel.\"", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547295596", "createdAt": "2020-12-22T14:04:46Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.infinispan.persistence.async;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+\n+interface Modification {\n+   /**\n+    * Applies the modification to the provided async store.\n+    * <p>\n+    * It is assumed that callers of this method are done in a thread safe way, either by synchronizing\n+    * the invocation of this invocation, limiting concurrent invocations of this method or by\n+    * protecting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTk3NA==", "bodyText": "Can this be removed?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547295974", "createdAt": "2020-12-22T14:05:35Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();\n+\n+         stageToWaitFor = pendingModifications.size() + replicatingSize > modificationQueueSize\n+               ? batchFuture : null;\n+         if (stageToWaitFor != null) {\n+            System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NzM1NA==", "bodyText": "Maybe replicatingModifications should start non-null, so we can remove these null checks?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547297354", "createdAt": "2020-12-22T14:08:18Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwMTMyMg==", "bodyText": "How about submitStage instead? stageToWaitFor sounds like it could be anything.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547301322", "createdAt": "2020-12-22T14:16:12Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwNjM5Mw==", "bodyText": "Is this really needed?\nThe way I see it, either store operations can complete on any thread, and switching to a non-blocking thread here is not needed, or store operations must complete on a non-blocking thread, and the batch future must have been completed on a non-blocking thread as well.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547306393", "createdAt": "2020-12-22T14:25:40Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();\n+\n+         stageToWaitFor = pendingModifications.size() + replicatingSize > modificationQueueSize\n+               ? batchFuture : null;\n+         if (stageToWaitFor != null) {\n+            System.currentTimeMillis();\n+         }\n+      }\n+\n+      if (trace) {\n+         log.tracef(\"A new modification %s has been enqueued with async store\", modification);\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n-         // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n+      }\n+      if (stageToWaitFor != null && trace) {\n+         log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n       }\n+      return stageToWaitFor == null ? CompletableFutures.completedNull() :\n+            stageToWaitFor.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxMTgxNQ==", "bodyText": "I don't think the result of store.delete() is needed for Cache.remove(key) or for cache statistics, CacheWriterInterceptor ignores it:\n\n  \n    \n      infinispan/core/src/main/java/org/infinispan/interceptors/impl/CacheWriterInterceptor.java\n    \n    \n         Line 219\n      in\n      7206596\n    \n    \n    \n    \n\n        \n          \n           return delayedValue(resultStage, rv);", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547311815", "createdAt": "2020-12-22T14:35:43Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNDI5Mg==", "bodyText": "I didn't get this comment, which test method has this problem? And what does the store write to key X get in a deadlock with?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547314292", "createdAt": "2020-12-22T14:40:14Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -370,7 +370,10 @@ private static ConfigurationBuilder config(boolean passivation) {\n          ConfigurationBuilder config = new ConfigurationBuilder();\n          config.memory().maxCount(1).persistence().passivation(passivation).addStore(LockableStoreConfigurationBuilder.class)\n                .async()\n-                  .modificationQueueSize(1)\n+                  // When using passivation we block a store write to key X - which in turn\n+                  // gets in a deadlock as it never completes - make sure to set queue size one\n+                  // higher so it can complete", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNjI0Mg==", "bodyText": "SLOW_STORE_WAIT is 100, waiting 205ms every time is too much IMO.\nThe store only has slow(true) for testConcurrentClearAndStop, so waiting 10ms to get a timeout should be enough.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547316242", "createdAt": "2020-12-22T14:43:42Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -412,7 +415,7 @@ public void call() throws InterruptedException {\n                   }\n                });\n \n-               Exceptions.expectException(TimeoutException.class, () -> f.get(100, TimeUnit.MILLISECONDS));\n+               Exceptions.expectException(TimeoutException.class, () -> f.get(DummyInMemoryStore.SLOW_STORE_WAIT * 2 + 5, TimeUnit.MILLISECONDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMyNDk4Mw==", "bodyText": "Thanks for renaming the method.\nYou're right that the key lock must be held while doing the write. I was thinking that if you changed the test to acquire and release the lock in a non-blocking way, the thread performing the store operation would no longer necessarily be the worker thread. It could be the same non-blocking thread that performed the previous operation on that key, and the lack of a context switch between the 2 operations might make a potential race more or less likely.\nThinking again, it's not worth the trouble to make this test more life-like, when we can stress-test a full cache instead.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547324983", "createdAt": "2020-12-22T14:59:20Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -134,7 +147,7 @@ void stopMarshaller() throws InterruptedException {\n    // ImmortalCacheEntry{key=key165168, value=ImmortalCacheValue {value=61456}}}\n    // (Thread-194:) Expected state updated with key=key165168, value=61456\n    // (Thread-200:) Expected state updated with key=key165168, value=60483\n-   private LockContainer locks = new PerKeyLockContainer();\n+   private LockContainer locks;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMyNzA5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .location(\"/tmp\")\n          \n          \n            \n                        .location(location)", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547327099", "createdAt": "2020-12-22T15:03:13Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -153,6 +166,7 @@ void stopMarshaller() throws InterruptedException {\n             .getDefaultCacheConfiguration(false)\n             .persistence()\n             .addSingleFileStore()\n+            .location(\"/tmp\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 75}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "committedDate": "2020-12-10T21:09:18Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}, "afterCommit": {"oid": "8249ad48b8202fdab57607c4d01090b4ae518d6e", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/8249ad48b8202fdab57607c4d01090b4ae518d6e", "committedDate": "2021-01-04T22:08:22Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcxMDIzOTY1", "url": "https://github.com/infinispan/infinispan/pull/8783#pullrequestreview-571023965", "createdAt": "2021-01-19T08:56:15Z", "commit": {"oid": "8249ad48b8202fdab57607c4d01090b4ae518d6e"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwODo1NjoxNVrOIWESew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQwOTo1MjozMlrOIWGpUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwOTg1MQ==", "bodyText": "I don't think that will work, unless you also remove the assertNotStopped() check in batch().", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560009851", "createdAt": "2021-01-19T08:56:15Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -130,36 +117,23 @@ public AsyncNonBlockingStore(NonBlockingStore<K, V> actual) {\n       segmentCount = storeConfiguration.segmented() ? cacheConfiguration.clustering().hash().numSegments() : 1;\n       asyncConfiguration = storeConfiguration.async();\n       modificationQueueSize = asyncConfiguration.modificationQueueSize();\n-      // It is possible for multiple threads to write to this processor at the same time\n-      submissionFlowable = UnicastProcessor.<Modification>create(1).toSerialized();\n       nonBlockingExecutor = ctx.getNonBlockingExecutor();\n-      startSub = submissionFlowable.window(requestFlowable).subscribe(this);\n+      stopped = false;\n       return actual.start(ctx);\n    }\n \n    @Override\n    public CompletionStage<Void> stop() {\n       CompletionStage<Void> asyncStage;\n-      if (submissionFlowable != null) {\n-         if (trace) {\n-            log.tracef(\"Stopping async store containing store %s\", actual);\n-         }\n-         submissionFlowable = null;\n-         asyncStage = awaitQuiescence().whenComplete((ignore, t) -> {\n-            // We can only dispose of the subscription after we are sure we are totally stopped\n-            if (startSub != null) {\n-               startSub.dispose();\n-               startSub = null;\n-            }\n-         });\n-\n-      } else {\n-         asyncStage = CompletableFutures.completedNull();\n+      if (trace) {\n+         log.tracef(\"Stopping async store containing store %s\", actual);\n       }\n+      asyncStage = awaitQuiescence();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDIxNQ=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAxMTgyNg==", "bodyText": "Markdown alert :)", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560011826", "createdAt": "2021-01-19T08:59:14Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -196,84 +171,81 @@ private synchronized void putClearModification() {\n    }\n \n    /**\n-    * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n-    * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n+    * This method is protected by the `batchFuture` instance variable. Invoking this method outside of this method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8249ad48b8202fdab57607c4d01090b4ae518d6e"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAyODA2Mg==", "bodyText": "It's still not very clear to me, I'll definitely need a more explicit comment :)\nSo you're saying that when this code executes, batchFuture must be non-null, and any submitTask() running on another thread cannot submit a new batch?", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560028062", "createdAt": "2021-01-19T09:23:48Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAzMDk2Mw==", "bodyText": "That too, but I was also thinking about what happens if one CompletionStage completes with an exception and then the last CompletionStage completes successfully.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560030963", "createdAt": "2021-01-19T09:27:39Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5MzY5NA=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MDcwMw==", "bodyText": "We already have the stat (removeHits). It's just that it's computed in CacheMgmtInterceptor based on the value that was loaded in the invocation context, not on the result of the store operation:\n\n  \n    \n      infinispan/core/src/main/java/org/infinispan/interceptors/impl/CacheMgmtInterceptor.java\n    \n    \n         Line 495\n      in\n      2d53d0a\n    \n    \n    \n    \n\n        \n          \n           if (removeCommand.isConditional()) {", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560040703", "createdAt": "2021-01-19T09:41:20Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, "originalCommit": {"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MTUxMQ==", "bodyText": "Typo: IThis", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560041511", "createdAt": "2021-01-19T09:42:29Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.infinispan.persistence.async;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+\n+interface Modification {\n+   /**\n+    * Applies the modification to the provided async store.\n+    * <p>\n+    * IThis method is not thread safe, callers must ensure that it is not invoked on multiple threads in parallel.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8249ad48b8202fdab57607c4d01090b4ae518d6e"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MjQzOA==", "bodyText": "Forgot to remove the segment-related stuff :)", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560042438", "createdAt": "2021-01-19T09:43:51Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.infinispan.persistence.async;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+\n+interface Modification {\n+   /**\n+    * Applies the modification to the provided async store.\n+    * <p>\n+    * IThis method is not thread safe, callers must ensure that it is not invoked on multiple threads in parallel.\n+    * @param store the store to apply the modification to\n+    * @param <K> key type\n+    * @param <V> value type\n+    */\n+   <K, V> void apply(AsyncNonBlockingStore<K, V> store);\n+\n+   /**\n+    * Returns the segment that maps to this modification. Some modifications may not map to a given\n+    * segment and may throw an {@link UnsupportedOperationException}.\n+    * @return the segment that maps to the modification\n+    */\n+   int getSegment();\n+\n+   /**\n+    * Returns this modification as a stage that is already complete. Some modifications may not map\n+    * to a given segment and may throw an {@link UnsupportedOperationException}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8249ad48b8202fdab57607c4d01090b4ae518d6e"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0ODQ2Nw==", "bodyText": "This test's writes would finish in <1ms if they weren't waiting for store.delayedFuture (unless you're debugging, and then 200ms vs 10ms doesn't change anything).\nIf it was using slow(true), then it would make sense to give it 200ms to finish both writes, but it's not, so f will complete as soon as store.delayedFuture is completed.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560048467", "createdAt": "2021-01-19T09:52:32Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -412,7 +415,7 @@ public void call() throws InterruptedException {\n                   }\n                });\n \n-               Exceptions.expectException(TimeoutException.class, () -> f.get(100, TimeUnit.MILLISECONDS));\n+               Exceptions.expectException(TimeoutException.class, () -> f.get(DummyInMemoryStore.SLOW_STORE_WAIT * 2 + 5, TimeUnit.MILLISECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNjI0Mg=="}, "originalCommit": {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641"}, "originalPosition": 17}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8249ad48b8202fdab57607c4d01090b4ae518d6e", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/8249ad48b8202fdab57607c4d01090b4ae518d6e", "committedDate": "2021-01-04T22:08:22Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}, "afterCommit": {"oid": "4f70ef6bb1a8a28dd7c75522d1de4e12f5076261", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/4f70ef6bb1a8a28dd7c75522d1de4e12f5076261", "committedDate": "2021-01-19T20:53:44Z", "message": "rework comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f70ef6bb1a8a28dd7c75522d1de4e12f5076261", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/4f70ef6bb1a8a28dd7c75522d1de4e12f5076261", "committedDate": "2021-01-19T20:53:44Z", "message": "rework comments"}, "afterCommit": {"oid": "9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae", "committedDate": "2021-01-21T16:08:25Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0MzExOTM2", "url": "https://github.com/infinispan/infinispan/pull/8783#pullrequestreview-574311936", "createdAt": "2021-01-22T14:32:59Z", "commit": {"oid": "9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNDozMjo1OVrOIYmr5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNDozMjo1OVrOIYmr5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY3MDU2NA==", "bodyText": "You removed the lastElement() call, so I think you can also remove this comment.", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562670564", "createdAt": "2021-01-22T14:32:59Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -473,72 +459,70 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      // Note that all of these use the lastElement method to detect completion. This is okay only because the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae"}, "originalPosition": 385}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae", "committedDate": "2021-01-21T16:08:25Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}, "afterCommit": {"oid": "49ec44202e094e6c168733c42f62a0ec3c1c2384", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/49ec44202e094e6c168733c42f62a0ec3c1c2384", "committedDate": "2021-01-22T15:11:55Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d9b52b4bda2a871abdb2c7af3335900907df682", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/2d9b52b4bda2a871abdb2c7af3335900907df682", "committedDate": "2021-01-22T15:16:53Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "49ec44202e094e6c168733c42f62a0ec3c1c2384", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/49ec44202e094e6c168733c42f62a0ec3c1c2384", "committedDate": "2021-01-22T15:11:55Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}, "afterCommit": {"oid": "2d9b52b4bda2a871abdb2c7af3335900907df682", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/2d9b52b4bda2a871abdb2c7af3335900907df682", "committedDate": "2021-01-22T15:16:53Z", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 380, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}