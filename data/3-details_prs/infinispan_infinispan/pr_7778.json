{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2MTE1MTIz", "number": 7778, "title": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are n\u2026", "bodyText": "\u2026ever blocked\nhttps://issues.redhat.com/browse/ISPN-10898", "createdAt": "2020-01-22T23:35:12Z", "url": "https://github.com/infinispan/infinispan/pull/7778", "merged": true, "mergeCommit": {"oid": "cafdff0cc66a9e343adc7f53d5fcf69b4ce872b2"}, "closed": true, "closedAt": "2020-02-24T18:28:17Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8-hyKAFqTM0Njk4MDIyNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHgqTLgBqjMwNjYyMDY3ODY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2OTgwMjI3", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-346980227", "createdAt": "2020-01-22T23:41:23Z", "commit": {"oid": "1ef7d1dfde0062155be78112707b70b73a574a9e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMzo0MToyM1rOFguz3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMzo0MToyM1rOFguz3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NTY5Mg==", "bodyText": "This shouldn't be true anymore afaik.", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r369865692", "createdAt": "2020-01-22T23:41:23Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,66 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+         // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+         builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+         builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+         // Random JGroups stuff\n+         builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // TODO: This can actually block us for a bit, we should really remove this!!!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef7d1dfde0062155be78112707b70b73a574a9e"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2OTgwODEz", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-346980813", "createdAt": "2020-01-22T23:43:01Z", "commit": {"oid": "1ef7d1dfde0062155be78112707b70b73a574a9e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMzo0MzowMlrOFgu1mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMzo0MzowMlrOFgu1mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NjEzOA==", "bodyText": "Maybe we should remove this or convert it to a different Assertion or something.", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r369866138", "createdAt": "2020-01-22T23:43:02Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,66 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+         // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+         builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+         builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+         // Random JGroups stuff\n+         builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // TODO: This can actually block us for a bit, we should really remove this!!!\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+\n+         // Some test utilities may block the cpu thread - which is fine\n+         builder.allowBlockingCallsInside(EvictionWithConcurrentOperationsTest.class.getName() + \"$Latch\", \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"await\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"trigger\");\n+         builder.allowBlockingCallsInside(BlockingInterceptor.class.getName(), \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepRandom\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepThread\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logf\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+         builder.disallowBlockingCallsInside(NonBlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.blockingMethodCallback(bm -> {\n+            throw new CacheException(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ef7d1dfde0062155be78112707b70b73a574a9e"}, "originalPosition": 119}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "212c3a3b98bb787c1332ea50fc629eadf86ea722", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/212c3a3b98bb787c1332ea50fc629eadf86ea722", "committedDate": "2020-01-23T18:23:16Z", "message": "fix leak in block hound test"}, "afterCommit": {"oid": "76da66c8c00b0b838e04b90190ebe492b41fcb64", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/76da66c8c00b0b838e04b90190ebe492b41fcb64", "committedDate": "2020-01-23T19:53:38Z", "message": "fix leak in block hound test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cb08667204e61d262dbd29f640ff4ce06b358028", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/cb08667204e61d262dbd29f640ff4ce06b358028", "committedDate": "2020-01-24T14:18:18Z", "message": "add blockhound to jcache"}, "afterCommit": {"oid": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/30a316010185a17a6f7b9ad9d8be53d8cb1262a0", "committedDate": "2020-01-27T20:48:46Z", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNTI0MTc0", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-351524174", "createdAt": "2020-01-31T14:04:20Z", "commit": {"oid": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNDowNDoyMFrOFkMRSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNDowODowNFrOFkMYOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ5NDA5MQ==", "bodyText": "Is this meant to be version.blockhound?", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r373494091", "createdAt": "2020-01-31T14:04:20Z", "author": {"login": "ryanemerson"}, "path": "build-configuration/pom.xml", "diffHunk": "@@ -125,6 +125,7 @@\n       <version.cdi>2.0</version.cdi>\n       <version.codehaus.jackson>1.9.13</version.codehaus.jackson>\n       <version.console>0.1.Final</version.console>\n+      <version.datahoud>1.0.1.RELEASE</version.datahoud>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ5NTg2NQ==", "bodyText": "I don't want to nitpick, but should this be a separate JIRA for exposure?", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r373495865", "createdAt": "2020-01-31T14:08:04Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java", "diffHunk": "@@ -54,8 +54,8 @@\n    @Inject ConfigurationManager configurationManager;\n    @Inject InternalCacheRegistry internalCacheRegistry;\n    @Inject GlobalComponentRegistry globalComponentRegistry;\n-   @Inject @ComponentName(KnownComponentNames.ASYNC_OPERATIONS_EXECUTOR)\n-   ExecutorService executorService;\n+   @Inject @ComponentName(KnownComponentNames.PERSISTENCE_EXECUTOR)\n+   ExecutorService blockingExecutor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNTYxMDM1", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-351561035", "createdAt": "2020-01-31T14:58:29Z", "commit": {"oid": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNDo1ODoyOVrOFkN-aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQxNDo1ODoyOVrOFkN-aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUyMjAyNA==", "bodyText": "Unfortunately there is no great way to catch these types of errors. We have places where we ignore the error from a CompletionStage or Future. So this is attempting to print out those messages.", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r373522024", "createdAt": "2020-01-31T14:58:29Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,66 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+         // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+         builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+         builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+         // Random JGroups stuff\n+         builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // TODO: This can actually block us for a bit, we should really remove this!!!\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+\n+         // Some test utilities may block the cpu thread - which is fine\n+         builder.allowBlockingCallsInside(EvictionWithConcurrentOperationsTest.class.getName() + \"$Latch\", \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"await\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"trigger\");\n+         builder.allowBlockingCallsInside(BlockingInterceptor.class.getName(), \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepRandom\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepThread\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logf\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+         builder.disallowBlockingCallsInside(NonBlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.blockingMethodCallback(bm -> {\n+            throw new CacheException(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread()));\n+         });\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         t.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0"}, "originalPosition": 124}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/30a316010185a17a6f7b9ad9d8be53d8cb1262a0", "committedDate": "2020-01-27T20:48:46Z", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked"}, "afterCommit": {"oid": "b8385c288794f3d78fba04f52a6592d96c191518", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/b8385c288794f3d78fba04f52a6592d96c191518", "committedDate": "2020-01-31T14:58:41Z", "message": "ISPN-11261 GlobalConfigurationManager should use blocking threads when starting caches"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDk4MDc2", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-353498076", "createdAt": "2020-02-05T06:56:03Z", "commit": {"oid": "b8385c288794f3d78fba04f52a6592d96c191518"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNjo1NjowNFrOFltYuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNzowOTozNFrOFltmtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4NTI0Mw==", "bodyText": "If you don't mind, please add a reference to https://issues.redhat.com/browse/ISPN-11279", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375085243", "createdAt": "2020-02-05T06:56:04Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,67 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8385c288794f3d78fba04f52a6592d96c191518"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4NjM5MA==", "bodyText": "AssertionError would be good, but I'd also report it as a failure directly in case the test expects an exception and doesn't bother to check the exception type.\nSomething like: \n  \n    \n      infinispan/commons-test/src/main/java/org/infinispan/commons/test/RunningTestsRegistry.java\n    \n    \n         Line 72\n      in\n      5bf7675\n    \n    \n    \n    \n\n        \n          \n           private static void writeJUnitReport(String testName, RuntimeException exception) {", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375086390", "createdAt": "2020-02-05T07:00:30Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,66 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+         // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+         builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+         builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+         // Random JGroups stuff\n+         builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // TODO: This can actually block us for a bit, we should really remove this!!!\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+\n+         // Some test utilities may block the cpu thread - which is fine\n+         builder.allowBlockingCallsInside(EvictionWithConcurrentOperationsTest.class.getName() + \"$Latch\", \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"await\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"trigger\");\n+         builder.allowBlockingCallsInside(BlockingInterceptor.class.getName(), \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepRandom\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepThread\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logf\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+         builder.disallowBlockingCallsInside(NonBlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.blockingMethodCallback(bm -> {\n+            throw new CacheException(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NjEzOA=="}, "originalCommit": {"oid": "1ef7d1dfde0062155be78112707b70b73a574a9e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4NzIzMg==", "bodyText": "I don't think we check the console output manually that often, so I'd suggest crafting a JUnit report here too.\nAlso it's enough to just log the exception with FATAL level, (part of) the stack trace will be printed on the console.", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375087232", "createdAt": "2020-02-05T07:03:32Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,66 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+         // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+         builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+         builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+         // Random JGroups stuff\n+         builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // TODO: This can actually block us for a bit, we should really remove this!!!\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+\n+         // Some test utilities may block the cpu thread - which is fine\n+         builder.allowBlockingCallsInside(EvictionWithConcurrentOperationsTest.class.getName() + \"$Latch\", \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"await\");\n+         builder.allowBlockingCallsInside(CheckPoint.class.getName(), \"trigger\");\n+         builder.allowBlockingCallsInside(BlockingInterceptor.class.getName(), \"blockIfNeeded\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepRandom\");\n+         builder.allowBlockingCallsInside(TestingUtil.class.getName(), \"sleepThread\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logf\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+         builder.disallowBlockingCallsInside(NonBlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.blockingMethodCallback(bm -> {\n+            throw new CacheException(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread()));\n+         });\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         t.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzUyMjAyNA=="}, "originalCommit": {"oid": "30a316010185a17a6f7b9ad9d8be53d8cb1262a0"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4ODgyMw==", "bodyText": "One downside to putting this in AbstractInfinispanTest is that it can only be used in modules using TestNG.\nI guess you only care about core tests at this stage, but it's something to consider.", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r375088823", "createdAt": "2020-02-05T07:09:34Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +92,67 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8385c288794f3d78fba04f52a6592d96c191518"}, "originalPosition": 70}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8385c288794f3d78fba04f52a6592d96c191518", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/b8385c288794f3d78fba04f52a6592d96c191518", "committedDate": "2020-01-31T14:58:41Z", "message": "ISPN-11261 GlobalConfigurationManager should use blocking threads when starting caches"}, "afterCommit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/fbe7300b2631520a166acbb51a4eb79abf60b491", "committedDate": "2020-02-05T23:15:33Z", "message": "additional"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MTI5OTY2", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-355129966", "createdAt": "2020-02-07T12:42:11Z", "commit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo0MjoxMVrOFm72ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo0MjoxMVrOFm72ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3MDgyNg==", "bodyText": "Couldn't you reference org.jgroups.Version here instead, so it's loaded before Blockhound is installed?", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376370826", "createdAt": "2020-02-07T12:42:11Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +113,191 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         // Prevent people from calling into distributed streams\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+\n+\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // Topology lock is very short lived - we assume these are okay\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireExclusiveTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseExclusiveTopologyLock\");\n+\n+         // This class tries to reduce blocking as much as possible and compute Function should be block free now\n+         registerAllPublicMethodsOnClass(builder, OffHeapConcurrentMap.class);\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"removePermit\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"runTasks\");\n+         // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+         builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+         // This is invoked when cancelling a task - it locks a lock to update a queue, which shouldn't block\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"remove\");\n+\n+         // If shutting down a cache manager - don't worry if blocking\n+         builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // The cache has to always be LOCAL and cannot be used with persistence\n+         builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logMessage\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.allowBlockingCallsInside(AbstractInfinispanTest.class.getName(), \"writeJUnitReport\");\n+\n+         methodsToBeRemoved(builder);\n+         jgroupsMethodsAllowedToBlock(builder);\n+\n+         questionableMethodsAllowedToBlock(builder);\n+\n+         allowTestsToBlock(builder);\n+\n+         builder.blockingMethodCallback(bm ->\n+            writeJUnitReport(new AssertionError(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread())), \"Blocking\"));\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         LogFactory.getLogger(\"Infinispan-TEST\").fatal(\"Throwable was not caught in thread \" + thread +\n+               \" - exception is: \" + t);\n+         // RxJava propagates via this and we don't want to worry about it\n+         if (!(t instanceof UndeliverableException)) {\n+            writeJUnitReport(t, \"Uncaught\");\n+         }\n+      });\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // Total Order is to be removed!\n+      builder.allowBlockingCallsInside(StateConsumerImpl.class.getName(), \"awaitTotalOrderTransactions\");\n+\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+      builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"get\");\n+\n+      // THIS IS A VERY BAD HACK - because you can't instrument a static block of the class in jgroups Version class\n+      // which loads a properties file\n+      builder.allowBlockingCallsInside(Properties.class.getName(), \"load\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491"}, "originalPosition": 205}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MTM2MzY3", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-355136367", "createdAt": "2020-02-07T12:55:18Z", "commit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo1NToxOVrOFm8JTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo1NToxOVrOFm8JTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3NTYzMA==", "bodyText": "Minor nit: the default queue size is huge, so at least in the tests decrement should never actually await.\nYou're right about the lock though, it would be much cleaner if we could consider the JGroups threads \"blocking\", but switching to/from the non-blocking thread pool in order to do our processing would be really expensive.", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376375630", "createdAt": "2020-02-07T12:55:19Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +113,191 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         // Prevent people from calling into distributed streams\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+\n+\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // Topology lock is very short lived - we assume these are okay\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireExclusiveTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseExclusiveTopologyLock\");\n+\n+         // This class tries to reduce blocking as much as possible and compute Function should be block free now\n+         registerAllPublicMethodsOnClass(builder, OffHeapConcurrentMap.class);\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"removePermit\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"runTasks\");\n+         // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+         builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+         // This is invoked when cancelling a task - it locks a lock to update a queue, which shouldn't block\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"remove\");\n+\n+         // If shutting down a cache manager - don't worry if blocking\n+         builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // The cache has to always be LOCAL and cannot be used with persistence\n+         builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logMessage\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.allowBlockingCallsInside(AbstractInfinispanTest.class.getName(), \"writeJUnitReport\");\n+\n+         methodsToBeRemoved(builder);\n+         jgroupsMethodsAllowedToBlock(builder);\n+\n+         questionableMethodsAllowedToBlock(builder);\n+\n+         allowTestsToBlock(builder);\n+\n+         builder.blockingMethodCallback(bm ->\n+            writeJUnitReport(new AssertionError(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread())), \"Blocking\"));\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         LogFactory.getLogger(\"Infinispan-TEST\").fatal(\"Throwable was not caught in thread \" + thread +\n+               \" - exception is: \" + t);\n+         // RxJava propagates via this and we don't want to worry about it\n+         if (!(t instanceof UndeliverableException)) {\n+            writeJUnitReport(t, \"Uncaught\");\n+         }\n+      });\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // Total Order is to be removed!\n+      builder.allowBlockingCallsInside(StateConsumerImpl.class.getName(), \"awaitTotalOrderTransactions\");\n+\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+      builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"get\");\n+\n+      // THIS IS A VERY BAD HACK - because you can't instrument a static block of the class in jgroups Version class\n+      // which loads a properties file\n+      builder.allowBlockingCallsInside(Properties.class.getName(), \"load\");\n+\n+      // The NonBlockingCreditMap being non blocking is a bit questionable as they hold the lock while doing a lot of\n+      // work - including acquiring other locks and possibly calling await\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"decrement\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491"}, "originalPosition": 209}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MTM3OTE1", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-355137915", "createdAt": "2020-02-07T12:58:31Z", "commit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo1ODozMVrOFm8OAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo1ODozMVrOFm8OAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3NjgzNQ==", "bodyText": "Not just that, but there are plenty of other protocols using locking in the JGroups stack...\nRunning with transfer-queue-bundler would remove the direct socket writes from sendCommand, but the bundler can still block writing to the limited queue.", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376376835", "createdAt": "2020-02-07T12:58:31Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +113,191 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         // Prevent people from calling into distributed streams\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+\n+\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // Topology lock is very short lived - we assume these are okay\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireExclusiveTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseExclusiveTopologyLock\");\n+\n+         // This class tries to reduce blocking as much as possible and compute Function should be block free now\n+         registerAllPublicMethodsOnClass(builder, OffHeapConcurrentMap.class);\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"removePermit\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"runTasks\");\n+         // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+         builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+         // This is invoked when cancelling a task - it locks a lock to update a queue, which shouldn't block\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"remove\");\n+\n+         // If shutting down a cache manager - don't worry if blocking\n+         builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // The cache has to always be LOCAL and cannot be used with persistence\n+         builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logMessage\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.allowBlockingCallsInside(AbstractInfinispanTest.class.getName(), \"writeJUnitReport\");\n+\n+         methodsToBeRemoved(builder);\n+         jgroupsMethodsAllowedToBlock(builder);\n+\n+         questionableMethodsAllowedToBlock(builder);\n+\n+         allowTestsToBlock(builder);\n+\n+         builder.blockingMethodCallback(bm ->\n+            writeJUnitReport(new AssertionError(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread())), \"Blocking\"));\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         LogFactory.getLogger(\"Infinispan-TEST\").fatal(\"Throwable was not caught in thread \" + thread +\n+               \" - exception is: \" + t);\n+         // RxJava propagates via this and we don't want to worry about it\n+         if (!(t instanceof UndeliverableException)) {\n+            writeJUnitReport(t, \"Uncaught\");\n+         }\n+      });\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // Total Order is to be removed!\n+      builder.allowBlockingCallsInside(StateConsumerImpl.class.getName(), \"awaitTotalOrderTransactions\");\n+\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+      builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"get\");\n+\n+      // THIS IS A VERY BAD HACK - because you can't instrument a static block of the class in jgroups Version class\n+      // which loads a properties file\n+      builder.allowBlockingCallsInside(Properties.class.getName(), \"load\");\n+\n+      // The NonBlockingCreditMap being non blocking is a bit questionable as they hold the lock while doing a lot of\n+      // work - including acquiring other locks and possibly calling await\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"decrement\");\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"replenish\");\n+   }\n+\n+   private static void questionableMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // Component registry has a lock to protect its state - is short lived lock\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"prepareWrapperChange\");\n+\n+      // This one should probably not be allowed - it is waiting for another component to start\n+      // TODO: This might actually be a bug in the rewiring logic. (shows in StateTransferOverwritingValueTest)\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"awaitWrapperState\");\n+\n+      // Believe these can technically block for TCP when flushing to socket", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491"}, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MTQzMDQy", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-355143042", "createdAt": "2020-02-07T13:08:58Z", "commit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMzowODo1OFrOFm8c6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMzowODo1OFrOFm8c6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM4MDY0OA==", "bodyText": "This doesn't look very scalable...\nSince you've had to debug all of these, I wonder how much work it would be to move the tests to either return a CompletionStage that's completed from the main thread or to wrap all the calls in something like TestingUtil.pretendItsNotBlocking(() -> blockingMethodCall()). Not in this PR, of course :)", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376380648", "createdAt": "2020-02-07T13:08:58Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/test/AbstractInfinispanTest.java", "diffHunk": "@@ -72,6 +113,191 @@\n @TestSelector(interceptors = AbstractInfinispanTest.OrderByInstance.class)\n public abstract class AbstractInfinispanTest {\n \n+   static {\n+      BlockHound.builder().with(new RxJava2Integration()).with(builder -> {\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+         builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+         builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+         builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+         builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+         // Prevent people from calling into distributed streams\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+         builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+\n+         builder.nonBlockingThreadPredicate(current -> current.or(thread -> thread instanceof NonBlockingThread));\n+\n+\n+         // SecureRandom reads from a socket\n+         builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+\n+         // Just assume all the thread pools don't block - not we check the rejected handler below though\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"getTask\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"processWorkerExit\");\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(ScheduledThreadPoolExecutor.class.getName(), \"schedule\");\n+\n+         // Topology lock is very short lived - we assume these are okay\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseSharedTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"acquireExclusiveTopologyLock\");\n+         builder.allowBlockingCallsInside(StateTransferLockImpl.class.getName(), \"releaseExclusiveTopologyLock\");\n+\n+         // This class tries to reduce blocking as much as possible and compute Function should be block free now\n+         registerAllPublicMethodsOnClass(builder, OffHeapConcurrentMap.class);\n+\n+         // LimitedExecutor just submits a task to another thread pool\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"execute\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"removePermit\");\n+         builder.allowBlockingCallsInside(LimitedExecutor.class.getName(), \"runTasks\");\n+         // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+         builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+         // This is invoked when cancelling a task - it locks a lock to update a queue, which shouldn't block\n+         builder.allowBlockingCallsInside(ThreadPoolExecutor.class.getName(), \"remove\");\n+\n+         // If shutting down a cache manager - don't worry if blocking\n+         builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // The blocking iterator locks to signal at the end - ignore\n+         builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // The cache has to always be LOCAL and cannot be used with persistence\n+         builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+\n+         // Allow logging to block\n+         builder.allowBlockingCallsInside(Logger.class.getName(), \"logMessage\");\n+         builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+\n+         // Make sure our rejection handlers never block in a non blocking thread\n+         builder.disallowBlockingCallsInside(BlockingRejectedExecutionHandler.class.getName(), \"rejectedExecution\");\n+\n+         builder.allowBlockingCallsInside(AbstractInfinispanTest.class.getName(), \"writeJUnitReport\");\n+\n+         methodsToBeRemoved(builder);\n+         jgroupsMethodsAllowedToBlock(builder);\n+\n+         questionableMethodsAllowedToBlock(builder);\n+\n+         allowTestsToBlock(builder);\n+\n+         builder.blockingMethodCallback(bm ->\n+            writeJUnitReport(new AssertionError(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread())), \"Blocking\"));\n+      }).install();\n+\n+      Thread.setDefaultUncaughtExceptionHandler((thread, t) -> {\n+         LogFactory.getLogger(\"Infinispan-TEST\").fatal(\"Throwable was not caught in thread \" + thread +\n+               \" - exception is: \" + t);\n+         // RxJava propagates via this and we don't want to worry about it\n+         if (!(t instanceof UndeliverableException)) {\n+            writeJUnitReport(t, \"Uncaught\");\n+         }\n+      });\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // Total Order is to be removed!\n+      builder.allowBlockingCallsInside(StateConsumerImpl.class.getName(), \"awaitTotalOrderTransactions\");\n+\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+      builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"get\");\n+\n+      // THIS IS A VERY BAD HACK - because you can't instrument a static block of the class in jgroups Version class\n+      // which loads a properties file\n+      builder.allowBlockingCallsInside(Properties.class.getName(), \"load\");\n+\n+      // The NonBlockingCreditMap being non blocking is a bit questionable as they hold the lock while doing a lot of\n+      // work - including acquiring other locks and possibly calling await\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"decrement\");\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"replenish\");\n+   }\n+\n+   private static void questionableMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // Component registry has a lock to protect its state - is short lived lock\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"prepareWrapperChange\");\n+\n+      // This one should probably not be allowed - it is waiting for another component to start\n+      // TODO: This might actually be a bug in the rewiring logic. (shows in StateTransferOverwritingValueTest)\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"awaitWrapperState\");\n+\n+      // Believe these can technically block for TCP when flushing to socket\n+      builder.allowBlockingCallsInside(JGroupsTransport.class.getName(), \"sendCommand\");\n+      builder.allowBlockingCallsInside(JGroupsTransport.class.getName(), \"sendResponse\");\n+\n+      // This method calls initCacheStatusIfAbsent which can invoke readScopedState which reads scope from a file that\n+      // can block the current thread while doing I/O\n+      builder.allowBlockingCallsInside(ClusterTopologyManagerImpl.class.getName(), \"prepareJoin\");\n+      builder.allowBlockingCallsInside(ClusterTopologyManagerImpl.class.getName(), \"updateClusterState\");\n+   }\n+\n+   private static void allowTestsToBlock(BlockHound.Builder builder) {\n+      builder.allowBlockingCallsInside(EvictionWithConcurrentOperationsTest.class.getName() + \"$Latch\", \"blockIfNeeded\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491"}, "originalPosition": 232}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MTQ0NTk1", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-355144595", "createdAt": "2020-02-07T13:11:57Z", "commit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMzoxMTo1OFrOFm8hPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMzoxMTo1OFrOFm8hPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM4MTc1Ng==", "bodyText": "Unused?", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r376381756", "createdAt": "2020-02-07T13:11:58Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/test/JREBlocking.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package org.infinispan.test;\n+\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Exchanger;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class JREBlocking {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491"}, "originalPosition": 10}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fbe7300b2631520a166acbb51a4eb79abf60b491", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/fbe7300b2631520a166acbb51a4eb79abf60b491", "committedDate": "2020-02-05T23:15:33Z", "message": "additional"}, "afterCommit": {"oid": "c373302cf8425a44eb6002d12b14c087041e3331", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/c373302cf8425a44eb6002d12b14c087041e3331", "committedDate": "2020-02-12T17:40:19Z", "message": "additional"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c373302cf8425a44eb6002d12b14c087041e3331", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/c373302cf8425a44eb6002d12b14c087041e3331", "committedDate": "2020-02-12T17:40:19Z", "message": "additional"}, "afterCommit": {"oid": "536bbfd17c2c05745b467811e610d695b2b483ac", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/536bbfd17c2c05745b467811e610d695b2b483ac", "committedDate": "2020-02-18T19:08:52Z", "message": "additional changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "536bbfd17c2c05745b467811e610d695b2b483ac", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/536bbfd17c2c05745b467811e610d695b2b483ac", "committedDate": "2020-02-18T19:08:52Z", "message": "additional changes"}, "afterCommit": {"oid": "fcabe83a5d2eb78973f614e1331ec93c4b117510", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/fcabe83a5d2eb78973f614e1331ec93c4b117510", "committedDate": "2020-02-18T19:26:09Z", "message": "ISPN-11261 GlobalConfigurationManager should use blocking threads when starting caches"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fcabe83a5d2eb78973f614e1331ec93c4b117510", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/fcabe83a5d2eb78973f614e1331ec93c4b117510", "committedDate": "2020-02-18T19:26:09Z", "message": "ISPN-11261 GlobalConfigurationManager should use blocking threads when starting caches"}, "afterCommit": {"oid": "74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28", "committedDate": "2020-02-19T15:13:36Z", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28", "committedDate": "2020-02-19T15:13:36Z", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked"}, "afterCommit": {"oid": "6ae5c3aebad0ecc51f859938438142e9b033219a", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/6ae5c3aebad0ecc51f859938438142e9b033219a", "committedDate": "2020-02-20T22:52:13Z", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMDIyNTI2", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-362022526", "createdAt": "2020-02-20T15:57:42Z", "commit": {"oid": "74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo1Nzo0MlrOFsZHPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNjowMjoxMFrOFs7-Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5MzExNg==", "bodyText": "<optional> is not needed, because it's already in the provided scope", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382093116", "createdAt": "2020-02-20T15:57:42Z", "author": {"login": "danberindei"}, "path": "commons-test/pom.xml", "diffHunk": "@@ -34,6 +34,17 @@\n          <artifactId>testng</artifactId>\n          <scope>provided</scope>\n       </dependency>\n+\n+      <dependency>\n+         <groupId>org.kohsuke.metainf-services</groupId>\n+         <artifactId>metainf-services</artifactId>\n+         <optional>true</optional>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NTE1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               // as commons doesn't rely on commons-test only the commons jar does\n          \n          \n            \n               // as commons doesn't rely on commons-test, only the commons test jar does", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382095150", "createdAt": "2020-02-20T16:00:37Z", "author": {"login": "danberindei"}, "path": "commons-test/src/main/java/org/infinispan/commons/test/CommonsTestBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package org.infinispan.commons.test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.security.SecureRandom;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import org.kohsuke.MetaInfServices;\n+\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@SuppressWarnings(\"unused\")\n+@MetaInfServices\n+public class CommonsTestBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      // SecureRandom reads from a socket\n+      builder.allowBlockingCallsInside(SecureRandom.class.getName(), \"nextBytes\");\n+\n+      // Just assume all the thread pools don't block in our test suite - NOTE rejection policy can still be an issue!\n+      CommonsTestBlockHoundIntegration.registerAllPublicMethodsOnClass(builder, ThreadPoolExecutor.class);\n+      CommonsTestBlockHoundIntegration.registerAllPublicMethodsOnClass(builder, ScheduledThreadPoolExecutor.class);\n+\n+      // Allow logging to block in our test suite\n+      builder.allowBlockingCallsInside(org.apache.logging.log4j.Logger.class.getName(), \"logMessage\");\n+      builder.allowBlockingCallsInside(java.util.logging.Logger.class.getName(), \"log\");\n+   }\n+\n+   // This is a duplicate of CommonsBlockHoundIntegration - but unfortunately neither can reference each other\n+   // as commons doesn't rely on commons-test only the commons jar does", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjU3Ng==", "bodyText": "It's already <scope>provided</scope>, same as metainf-services", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382096576", "createdAt": "2020-02-20T16:02:53Z", "author": {"login": "danberindei"}, "path": "commons/pom.xml", "diffHunk": "@@ -58,6 +58,18 @@\n          <optional>true</optional>\n       </dependency>\n \n+      <dependency>\n+         <groupId>io.projectreactor.tools</groupId>\n+         <artifactId>blockhound</artifactId>\n+         <optional>true</optional>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74e6f5f0dcf6f9e6b89b9e8a5d803d763cb80b28"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MDcyMg==", "bodyText": "This looks incomplete :)", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382660722", "createdAt": "2020-02-21T15:56:23Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.affinity.impl.KeyAffinityServiceImpl;\n+import org.infinispan.cache.impl.CacheImpl;\n+import org.infinispan.commons.internal.CommonsBlockHoundIntegration;\n+import org.infinispan.container.offheap.OffHeapConcurrentMap;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.expiration.impl.ClusterExpirationManager;\n+import org.infinispan.factories.impl.BasicComponentRegistryImpl;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.remoting.transport.jgroups.JGroupsTransport;\n+import org.infinispan.statetransfer.StateTransferLockImpl;\n+import org.infinispan.topology.ClusterTopologyManagerImpl;\n+import org.infinispan.transaction.xa.recovery.RecoveryManagerImpl;\n+import org.jgroups.Version;\n+import org.jgroups.protocols.FlowControl;\n+import org.jgroups.protocols.UDP;\n+import org.jgroups.util.NonBlockingCreditMap;\n+import org.jgroups.util.Table;\n+import org.kohsuke.MetaInfServices;\n+\n+import io.reactivex.internal.operators.flowable.BlockingFlowableIterable;\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@SuppressWarnings(\"unused\")\n+@MetaInfServices\n+public class CoreBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      registerBlockingMethods(builder);\n+\n+      // Block designates methods that should only hold a lock very briefly\n+      {\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, OffHeapConcurrentMap.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, StateTransferLockImpl.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, LimitedExecutor.class);\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+      }\n+      // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+      builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+\n+      // If shutting down a cache manager - don't worry if blocking\n+      builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+      // The blocking iterator locks to signal at the end - ignore\n+      builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+      methodsToBeRemoved(builder);\n+\n+      jgroupsMethodsAllowedToBlock(builder);\n+\n+      questionableMethodsAllowedToBlock(builder);\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      // https://issues.redhat.com/browse/ISPN-11272\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void registerBlockingMethods(BlockHound.Builder builder) {\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+      builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+      builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+      builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae5c3aebad0ecc51f859938438142e9b033219a"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2MTY2MQ==", "bodyText": "Please add the same for TCP, in case anyone runs the tests with -Dinfinispan.cluster.stack=tcp", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382661661", "createdAt": "2020-02-21T15:57:58Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.affinity.impl.KeyAffinityServiceImpl;\n+import org.infinispan.cache.impl.CacheImpl;\n+import org.infinispan.commons.internal.CommonsBlockHoundIntegration;\n+import org.infinispan.container.offheap.OffHeapConcurrentMap;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.expiration.impl.ClusterExpirationManager;\n+import org.infinispan.factories.impl.BasicComponentRegistryImpl;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.remoting.transport.jgroups.JGroupsTransport;\n+import org.infinispan.statetransfer.StateTransferLockImpl;\n+import org.infinispan.topology.ClusterTopologyManagerImpl;\n+import org.infinispan.transaction.xa.recovery.RecoveryManagerImpl;\n+import org.jgroups.Version;\n+import org.jgroups.protocols.FlowControl;\n+import org.jgroups.protocols.UDP;\n+import org.jgroups.util.NonBlockingCreditMap;\n+import org.jgroups.util.Table;\n+import org.kohsuke.MetaInfServices;\n+\n+import io.reactivex.internal.operators.flowable.BlockingFlowableIterable;\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@SuppressWarnings(\"unused\")\n+@MetaInfServices\n+public class CoreBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      registerBlockingMethods(builder);\n+\n+      // Block designates methods that should only hold a lock very briefly\n+      {\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, OffHeapConcurrentMap.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, StateTransferLockImpl.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, LimitedExecutor.class);\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+      }\n+      // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+      builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+\n+      // If shutting down a cache manager - don't worry if blocking\n+      builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+      // The blocking iterator locks to signal at the end - ignore\n+      builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+      methodsToBeRemoved(builder);\n+\n+      jgroupsMethodsAllowedToBlock(builder);\n+\n+      questionableMethodsAllowedToBlock(builder);\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      // https://issues.redhat.com/browse/ISPN-11272\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void registerBlockingMethods(BlockHound.Builder builder) {\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+      builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+      builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+      builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+      // Distributed streams are blocking!\n+      builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+      builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae5c3aebad0ecc51f859938438142e9b033219a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2NDIzNA==", "bodyText": "Do we need to add all the individual JGroups protocol methods as well, if we have these 2, or even just JChannel#send?", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382664234", "createdAt": "2020-02-21T16:02:10Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.affinity.impl.KeyAffinityServiceImpl;\n+import org.infinispan.cache.impl.CacheImpl;\n+import org.infinispan.commons.internal.CommonsBlockHoundIntegration;\n+import org.infinispan.container.offheap.OffHeapConcurrentMap;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.expiration.impl.ClusterExpirationManager;\n+import org.infinispan.factories.impl.BasicComponentRegistryImpl;\n+import org.infinispan.manager.DefaultCacheManager;\n+import org.infinispan.remoting.transport.jgroups.JGroupsTransport;\n+import org.infinispan.statetransfer.StateTransferLockImpl;\n+import org.infinispan.topology.ClusterTopologyManagerImpl;\n+import org.infinispan.transaction.xa.recovery.RecoveryManagerImpl;\n+import org.jgroups.Version;\n+import org.jgroups.protocols.FlowControl;\n+import org.jgroups.protocols.UDP;\n+import org.jgroups.util.NonBlockingCreditMap;\n+import org.jgroups.util.Table;\n+import org.kohsuke.MetaInfServices;\n+\n+import io.reactivex.internal.operators.flowable.BlockingFlowableIterable;\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@SuppressWarnings(\"unused\")\n+@MetaInfServices\n+public class CoreBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      registerBlockingMethods(builder);\n+\n+      // Block designates methods that should only hold a lock very briefly\n+      {\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, OffHeapConcurrentMap.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, StateTransferLockImpl.class);\n+         CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, LimitedExecutor.class);\n+\n+         // This method by design will never block; It may block very shortly if another thread is removing or adding\n+         // to the queue, but it will never block for an extended period by design as there will always be room\n+         builder.allowBlockingCallsInside(ClusterExpirationManager.class.getName(), \"addStageToPermits\");\n+\n+         // This shouldn't block long when held - but it is a write lock which can be delayed\n+         builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+      }\n+      // This invokes the actual runnable - we have to make sure it doesn't block as normal\n+      builder.disallowBlockingCallsInside(LimitedExecutor.class.getName(), \"actualRun\");\n+\n+      // If shutting down a cache manager - don't worry if blocking\n+      builder.allowBlockingCallsInside(DefaultCacheManager.class.getName(), \"stop\");\n+\n+      // The blocking iterator locks to signal at the end - ignore\n+      builder.allowBlockingCallsInside(BlockingFlowableIterable.class.getName() + \"$BlockingFlowableIterator\", \"signalConsumer\");\n+\n+      methodsToBeRemoved(builder);\n+\n+      jgroupsMethodsAllowedToBlock(builder);\n+\n+      questionableMethodsAllowedToBlock(builder);\n+   }\n+\n+   private static void methodsToBeRemoved(BlockHound.Builder builder) {\n+      // The internal map only supports local mode - we need to replace with Caffeine\n+      // https://issues.redhat.com/browse/ISPN-11272\n+      builder.allowBlockingCallsInside(RecoveryManagerImpl.class.getName(), \"registerInDoubtTransaction\");\n+   }\n+\n+   private static void registerBlockingMethods(BlockHound.Builder builder) {\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"()I\");\n+      builder.markAsBlocking(CacheImpl.class, \"size\", \"(J)I\");\n+      builder.markAsBlocking(CacheImpl.class, \"containsKey\", \"(Ljava/lang/Object;)Z\");\n+      builder.markAsBlocking(CacheImpl.class, \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n+      builder.markAsBlocking(CacheImpl.class, \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\");\n+\n+      // Distributed streams are blocking!\n+      builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"stream\", \"()Lorg/infinispan/CacheStream;\");\n+      builder.markAsBlocking(\"org.infinispan.interceptors.distribution.DistributionBulkInterceptor$BackingEntrySet\", \"parallelStream\", \"()Lorg/infinispan/CacheStream;\");\n+   }\n+\n+   private static void jgroupsMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // UDP calls PlainDatagramSocketImpl#send which can block if OS buffer is full - but we just ignore\n+      builder.allowBlockingCallsInside(UDP.class.getName(), \"_send\");\n+      builder.allowBlockingCallsInside(FlowControl.class.getName(), \"adjustCredit\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"add\");\n+      builder.allowBlockingCallsInside(Table.class.getName(), \"get\");\n+\n+      // Force Version class to be loaded before installing block hound (eagerly runs class initializer which blocks)\n+      System.out.println(\"BlockHound in use with JGroups: \" + Version.printVersion());\n+\n+      // The NonBlockingCreditMap being non blocking is a bit questionable as they hold the lock while doing a lot of\n+      // work - including acquiring other locks and possibly calling await\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"decrement\");\n+      builder.allowBlockingCallsInside(NonBlockingCreditMap.class.getName(), \"replenish\");\n+   }\n+\n+   private static void questionableMethodsAllowedToBlock(BlockHound.Builder builder) {\n+      // Component registry has a lock to protect its state - is short lived lock\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"prepareWrapperChange\");\n+\n+      // This one should probably not be allowed - it is waiting for another component to start\n+      // TODO: This might actually be a bug in the rewiring logic. (shows in StateTransferOverwritingValueTest)\n+      builder.allowBlockingCallsInside(BasicComponentRegistryImpl.class.getName(), \"awaitWrapperState\");\n+\n+      // Believe these can technically block for TCP when flushing to socket\n+      builder.allowBlockingCallsInside(JGroupsTransport.class.getName(), \"sendCommand\");\n+      builder.allowBlockingCallsInside(JGroupsTransport.class.getName(), \"sendResponse\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae5c3aebad0ecc51f859938438142e9b033219a"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzYwNDk4", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-362760498", "createdAt": "2020-02-21T16:36:44Z", "commit": {"oid": "6ae5c3aebad0ecc51f859938438142e9b033219a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNjozNjo0NFrOFs9Jfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNjozNjo0NFrOFs9Jfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MzUxOQ==", "bodyText": "Please also do a TestSuiteProgress.fakeTestFailure(testName, exception), I have a script that looks for those Test failed messages in the output when I run the tests locally :)", "url": "https://github.com/infinispan/infinispan/pull/7778#discussion_r382683519", "createdAt": "2020-02-21T16:36:44Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/util/CoreTestBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.infinispan.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+import org.infinispan.commons.internal.CommonsBlockHoundIntegration;\n+import org.infinispan.commons.test.PolarionJUnitXMLWriter;\n+import org.infinispan.distribution.BlockingInterceptor;\n+import org.infinispan.eviction.impl.EvictionWithConcurrentOperationsTest;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.test.concurrent.StateSequencer;\n+import org.infinispan.test.fwk.CheckPoint;\n+import org.infinispan.test.fwk.TestResourceTracker;\n+import org.infinispan.util.concurrent.ReclosableLatch;\n+import org.infinispan.util.logging.LogFactory;\n+import org.kohsuke.MetaInfServices;\n+\n+import io.reactivex.exceptions.UndeliverableException;\n+import reactor.blockhound.BlockHound;\n+import reactor.blockhound.integration.BlockHoundIntegration;\n+\n+@SuppressWarnings(\"unused\")\n+@MetaInfServices\n+public class CoreTestBlockHoundIntegration implements BlockHoundIntegration {\n+   @Override\n+   public void applyTo(BlockHound.Builder builder) {\n+      allowTestsToBlock(builder);\n+\n+      builder.allowBlockingCallsInside(CoreTestBlockHoundIntegration.class.getName(), \"writeJUnitReport\");\n+\n+      builder.blockingMethodCallback(bm ->\n+            writeJUnitReport(new AssertionError(String.format(\"Blocking call! %s on thread %s\", bm, Thread.currentThread())), \"Blocking\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae5c3aebad0ecc51f859938438142e9b033219a"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyODAyMjQ2", "url": "https://github.com/infinispan/infinispan/pull/7778#pullrequestreview-362802246", "createdAt": "2020-02-21T17:42:46Z", "commit": {"oid": "ed4b1d7fd78375845673eedc3980d3846bbe0a1f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed4b1d7fd78375845673eedc3980d3846bbe0a1f", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/ed4b1d7fd78375845673eedc3980d3846bbe0a1f", "committedDate": "2020-02-21T17:25:56Z", "message": "more stuff"}, "afterCommit": {"oid": "09c6405ada1f9d48e742fdf52993264d2c17aa17", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/09c6405ada1f9d48e742fdf52993264d2c17aa17", "committedDate": "2020-02-21T17:47:01Z", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02534a9f700560c0ed04ad3cf31ce39163a331f0", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/02534a9f700560c0ed04ad3cf31ce39163a331f0", "committedDate": "2020-02-24T14:36:29Z", "message": "make blockhound installation optional based on classpath"}, "afterCommit": {"oid": "0f54dc101d0c739ded4b993402a18d999115341e", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/0f54dc101d0c739ded4b993402a18d999115341e", "committedDate": "2020-02-24T16:56:00Z", "message": "make blockhound installation optional based on classpath"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6b4a2535891b7d49eb61421a428d6ca4e809193", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/f6b4a2535891b7d49eb61421a428d6ca4e809193", "committedDate": "2020-02-24T17:06:35Z", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f54dc101d0c739ded4b993402a18d999115341e", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/0f54dc101d0c739ded4b993402a18d999115341e", "committedDate": "2020-02-24T16:56:00Z", "message": "make blockhound installation optional based on classpath"}, "afterCommit": {"oid": "f6b4a2535891b7d49eb61421a428d6ca4e809193", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/f6b4a2535891b7d49eb61421a428d6ca4e809193", "committedDate": "2020-02-24T17:06:35Z", "message": "ISPN-10898 Add Blockound to test suite to make sure cpu threads are never blocked"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1241, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}