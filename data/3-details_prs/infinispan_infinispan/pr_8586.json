{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2MjQyMTE0", "number": 8586, "title": "ISPN-12156 Security Realm identity caching", "bodyText": "https://issues.redhat.com/browse/ISPN-12156", "createdAt": "2020-07-24T11:45:46Z", "url": "https://github.com/infinispan/infinispan/pull/8586", "merged": true, "mergeCommit": {"oid": "6b9d14ef8c832335af10a156d568c2ea21df7524"}, "closed": true, "closedAt": "2020-12-22T16:44:46Z", "author": {"login": "tristantarrant"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6UPUBgFqTQ1OTE2MzM2NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdotScogFqTU1NzIxMzQ4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MTYzMzY0", "url": "https://github.com/infinispan/infinispan/pull/8586#pullrequestreview-459163364", "createdAt": "2020-07-31T13:14:43Z", "commit": {"oid": "386282d2f300871ae09c2b373059609ce4a0de36"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxMzoxNDo0NFrOG6IGcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxMzoyMzozM1rOG6IYCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYwMzMxNA==", "bodyText": "Isn't 16 kind of small?", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r463603314", "createdAt": "2020-07-31T13:14:44Z", "author": {"login": "danberindei"}, "path": "server/runtime/src/main/java/org/infinispan/server/configuration/security/RealmConfiguration.java", "diffHunk": "@@ -15,9 +15,11 @@\n  */\n public class RealmConfiguration implements ConfigurationInfo {\n    static final AttributeDefinition<String> NAME = AttributeDefinition.builder(\"name\", null, String.class).build();\n+   static final AttributeDefinition<Integer> CACHE_MAX_SIZE = AttributeDefinition.builder(\"cacheMaxSize\", 16).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386282d2f300871ae09c2b373059609ce4a0de36"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYwNzgxOQ==", "bodyText": "I know it's not our API but I feel like it merits a comment, seeing the result of build() unused is puzzling.", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r463607819", "createdAt": "2020-07-31T13:23:33Z", "author": {"login": "danberindei"}, "path": "server/runtime/src/main/java/org/infinispan/server/configuration/security/RealmConfigurationBuilder.java", "diffHunk": "@@ -157,4 +179,35 @@ SSLContext getSSLContext() {\n    public void addFeature(ServerSecurityRealm.Feature feature) {\n       features.add(feature);\n    }\n+\n+   private SecurityRealm cacheable(SecurityRealm realm) {\n+      int maxEntries = attributes.attribute(CACHE_MAX_SIZE).get();\n+      if (maxEntries > 0 && realm instanceof CacheableSecurityRealm) {\n+         if (cache == null) {\n+            cache = new LRURealmIdentityCache(maxEntries, attributes.attribute(CACHE_LIFESPAN).get());\n+         }\n+         if (realm instanceof ModifiableSecurityRealm) {\n+            return new CachingModifiableSecurityRealm((CacheableSecurityRealm) realm, cache);\n+         } else {\n+            return new CachingSecurityRealm((CacheableSecurityRealm) realm, cache);\n+         }\n+      } else {\n+         return realm;\n+      }\n+   }\n+\n+   public void addRealm(String realmName, SecurityRealm realm) {\n+      addRealm(realmName, realm, null);\n+   }\n+\n+   public void addRealm(String realmName, SecurityRealm realm, Consumer<SecurityDomain.RealmBuilder> realmBuilderConsumer) {\n+      SecurityDomain.RealmBuilder realmBuilder = domainBuilder.addRealm(realmName, cacheable(realm));\n+      if (realmBuilderConsumer != null) {\n+         realmBuilderConsumer.accept(realmBuilder);\n+      }\n+      realmBuilder.build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386282d2f300871ae09c2b373059609ce4a0de36"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MDI2MTgw", "url": "https://github.com/infinispan/infinispan/pull/8586#pullrequestreview-464026180", "createdAt": "2020-08-10T08:05:02Z", "commit": {"oid": "386282d2f300871ae09c2b373059609ce4a0de36"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODowNTowMlrOG-E3Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwODowODoxMlrOG-E8ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc0NDU5MQ==", "bodyText": "It seems so. If I understand it correctly, this cache is mapped 1:1 to user credentials in the realm. If the entries are small, we could maybe up this number?", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r467744591", "createdAt": "2020-08-10T08:05:02Z", "author": {"login": "gustavonalle"}, "path": "server/runtime/src/main/java/org/infinispan/server/configuration/security/RealmConfiguration.java", "diffHunk": "@@ -15,9 +15,11 @@\n  */\n public class RealmConfiguration implements ConfigurationInfo {\n    static final AttributeDefinition<String> NAME = AttributeDefinition.builder(\"name\", null, String.class).build();\n+   static final AttributeDefinition<Integer> CACHE_MAX_SIZE = AttributeDefinition.builder(\"cacheMaxSize\", 16).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYwMzMxNA=="}, "originalCommit": {"oid": "386282d2f300871ae09c2b373059609ce4a0de36"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc0NTkxNQ==", "bodyText": "What is the reason for this change?", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r467745915", "createdAt": "2020-08-10T08:08:12Z", "author": {"login": "gustavonalle"}, "path": "server/tests/src/test/java/org/infinispan/server/security/authentication/RestAuthentication.java", "diffHunk": "@@ -78,7 +78,7 @@ public void testStaticResourcesAnonymously() {\n \n    @Test\n    public void testRestReadWrite() {\n-      RestClientConfigurationBuilder builder = new RestClientConfigurationBuilder();\n+      RestClientConfigurationBuilder builder = new RestClientConfigurationBuilder().socketTimeout(100_000).connectionTimeout(100_000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "386282d2f300871ae09c2b373059609ce4a0de36"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "386282d2f300871ae09c2b373059609ce4a0de36", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/386282d2f300871ae09c2b373059609ce4a0de36", "committedDate": "2020-07-24T11:45:07Z", "message": "ISPN-12156 Security Realm identity caching"}, "afterCommit": {"oid": "8b2bda78d63760fed87dacb59676eec337d4c131", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/8b2bda78d63760fed87dacb59676eec337d4c131", "committedDate": "2020-09-04T12:41:45Z", "message": "ISPN-12156 Security Realm identity caching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8b2bda78d63760fed87dacb59676eec337d4c131", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/8b2bda78d63760fed87dacb59676eec337d4c131", "committedDate": "2020-09-04T12:41:45Z", "message": "ISPN-12156 Security Realm identity caching"}, "afterCommit": {"oid": "47de697f3d97431632c42c2689c2a18e51fefc18", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/47de697f3d97431632c42c2689c2a18e51fefc18", "committedDate": "2020-09-04T15:47:03Z", "message": "ISPN-12156 Security Realm identity caching"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NzcyMjU3", "url": "https://github.com/infinispan/infinispan/pull/8586#pullrequestreview-514772257", "createdAt": "2020-10-22T14:12:02Z", "commit": {"oid": "47de697f3d97431632c42c2689c2a18e51fefc18"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNDoxMjowM1rOHmj0zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNDoxMjowM1rOHmj0zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE5NDg5Mg==", "bodyText": "Missing isTraceEnabled() (in getAttributes() as well)", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r510194892", "createdAt": "2020-10-22T14:12:03Z", "author": {"login": "danberindei"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/CachingSecurityRealm.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.wildfly.common.Assert.checkNotNullParam;\n+import static org.infinispan.server.Server.log;\n+\n+import java.security.Principal;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.realm.CacheableSecurityRealm;\n+import org.wildfly.security.auth.server.IdentityCredentials;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.auth.server.event.RealmEvent;\n+import org.wildfly.security.authz.Attributes;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.cache.RealmIdentityCache;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.Password;\n+import org.wildfly.security.password.interfaces.ClearPassword;\n+\n+/**\n+ * <p>A wrapper class that provides caching capabilities for a {@link SecurityRealm} and its identities.\n+ *\n+ * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n+ */\n+public class CachingSecurityRealm implements SecurityRealm {\n+\n+   private final CacheableSecurityRealm realm;\n+   private final RealmIdentityCache cache;\n+\n+   /**\n+    * Creates a new instance.\n+    *\n+    * @param realm the {@link SecurityRealm} whose {@link RealmIdentity} should be cached.\n+    * @param cache the {@link RealmIdentityCache} instance\n+    */\n+   public CachingSecurityRealm(CacheableSecurityRealm realm, RealmIdentityCache cache) {\n+      this.realm = checkNotNullParam(\"realm\", realm);\n+      this.cache = checkNotNullParam(\"cache\", cache);\n+\n+      if (realm instanceof CacheableSecurityRealm) {\n+         CacheableSecurityRealm cacheable = (CacheableSecurityRealm) realm;\n+         cacheable.registerIdentityChangeListener(this::removeFromCache);\n+      } else {\n+         throw new IllegalArgumentException(realm.toString());\n+      }\n+   }\n+\n+   @Override\n+   public RealmIdentity getRealmIdentity(Principal principal) throws RealmUnavailableException {\n+      RealmIdentity cached = cache.get(principal);\n+\n+      if (cached != null) {\n+         log.tracef(\"Returning cached RealmIdentity for '%s'\", principal);\n+         return cached;\n+      }\n+\n+      RealmIdentity realmIdentity = getCacheableRealm().getRealmIdentity(principal);\n+\n+      if (!realmIdentity.exists()) {\n+         log.tracef(\"RealmIdentity for '%s' does not exist, skipping cache.'\", principal);\n+         return realmIdentity;\n+      }\n+\n+      RealmIdentity cachedIdentity = new RealmIdentity() {\n+         final RealmIdentity identity = realmIdentity;\n+\n+         AuthorizationIdentity authorizationIdentity = null;\n+         Attributes attributes = null;\n+         IdentityCredentials credentials = IdentityCredentials.NONE;\n+         int verifiedEvidenceHash;\n+\n+         @Override\n+         public Principal getRealmIdentityPrincipal() {\n+            return identity.getRealmIdentityPrincipal();\n+         }\n+\n+         @Override\n+         public SupportLevel getCredentialAcquireSupport(Class<? extends Credential> credentialType, String algorithmName, final AlgorithmParameterSpec parameterSpec) throws RealmUnavailableException {\n+            if (credentials.contains(credentialType, algorithmName, parameterSpec)) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredentialAcquireSupport credentialType='%s' with algorithmName='%' known for pincipal='%s'\", credentialType.getName(), algorithmName, principal.getName());\n+               }\n+               return credentials.getCredentialAcquireSupport(credentialType, algorithmName, parameterSpec);\n+            }\n+            Credential credential = identity.getCredential(credentialType, algorithmName, parameterSpec);\n+            if (credential != null) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredentialAcquireSupport Credential for credentialType='%s' with algorithmName='%' obtained from identity - caching for principal='%s'\",\n+                        credentialType.getName(), algorithmName, principal.getName());\n+               }\n+               credentials = credentials.withCredential(credential);\n+            }\n+            return credentials.getCredentialAcquireSupport(credentialType, algorithmName, parameterSpec);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(Class<C> credentialType) throws RealmUnavailableException {\n+            if (credentials.contains(credentialType)) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' cached, returning cached credential for principal='%s'\", credentialType.getName(), principal.getName());\n+               }\n+               return credentials.getCredential(credentialType);\n+            }\n+            Credential credential = identity.getCredential(credentialType);\n+            if (credential != null) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' obtained from identity - caching for principal='%s'\", credentialType.getName(), principal.getName());\n+               }\n+               credentials = credentials.withCredential(credential);\n+            }\n+            return credentials.getCredential(credentialType);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(Class<C> credentialType, String algorithmName) throws RealmUnavailableException {\n+            if (credentials.contains(credentialType, algorithmName)) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' with algorithmName='%' cached, returning cached credential for principal='%s'\", credentialType.getName(), algorithmName, principal.getName());\n+               }\n+               return credentials.getCredential(credentialType, algorithmName);\n+            }\n+            Credential credential = identity.getCredential(credentialType, algorithmName);\n+            if (credential != null) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' with algorithmName='%' obtained from identity - caching.\", credentialType.getName(), algorithmName);\n+               }\n+               credentials = credentials.withCredential(credential);\n+            }\n+            return credentials.getCredential(credentialType, algorithmName);\n+         }\n+\n+         @Override\n+         public <C extends Credential> C getCredential(final Class<C> credentialType, final String algorithmName, final AlgorithmParameterSpec parameterSpec) throws RealmUnavailableException {\n+            if (credentials.contains(credentialType, algorithmName, parameterSpec)) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' with algorithmName='%s' cached, returning cached credential for principal='%s'\", credentialType.getName(), algorithmName, principal.getName());\n+               }\n+               return credentials.getCredential(credentialType, algorithmName, parameterSpec);\n+            }\n+            Credential credential = identity.getCredential(credentialType, algorithmName, parameterSpec);\n+            if (credential != null) {\n+               if (log.isTraceEnabled()) {\n+                  log.tracef(\"getCredential credentialType='%s' with algorithmName='%s' obtained from identity - caching for principal='%s'\", credentialType.getName(), algorithmName, principal.getName());\n+               }\n+               credentials = credentials.withCredential(credential);\n+            }\n+            return credentials.getCredential(credentialType, algorithmName, parameterSpec);\n+         }\n+\n+         @Override\n+         public void updateCredential(Credential credential) throws RealmUnavailableException {\n+            log.tracef(\"updateCredential For principal='%s'\", principal);\n+            try {\n+               identity.updateCredential(credential);\n+            } finally {\n+               removeFromCache(identity.getRealmIdentityPrincipal());\n+            }\n+         }\n+\n+         @Override\n+         public SupportLevel getEvidenceVerifySupport(Class<? extends Evidence> evidenceType, String algorithmName) throws RealmUnavailableException {\n+            if (PasswordGuessEvidence.class.isAssignableFrom(evidenceType)) {\n+               if (credentials.canVerify(evidenceType, algorithmName)) {\n+                  if (log.isTraceEnabled()) {\n+                     log.tracef(\"getEvidenceVerifySupport evidenceType='%s' with algorithmName='%' can verify from cache for principal='%s'\", evidenceType.getName(), algorithmName, principal.getName());\n+                  }\n+                  return SupportLevel.SUPPORTED;\n+               }\n+               Credential credential = identity.getCredential(PasswordCredential.class);\n+               if (credential != null) {\n+                  if (log.isTraceEnabled()) {\n+                     log.tracef(\"getEvidenceVerifySupport evidenceType='%s' with algorithmName='%' credential obtained from identity and cached for principal='%s'\",\n+                           evidenceType.getName(), algorithmName, principal.getName());\n+                  }\n+                  credentials = credentials.withCredential(credential);\n+                  if (credential.canVerify(evidenceType, algorithmName)) {\n+                     return SupportLevel.SUPPORTED;\n+                  }\n+               }\n+            }\n+            if (log.isTraceEnabled()) {\n+               log.tracef(\"getEvidenceVerifySupport evidenceType='%s' with algorithmName='%' falling back to direct support of identity for principal='%s'\",\n+                     evidenceType.getName(), algorithmName, principal.getName());\n+            }\n+            return identity.getEvidenceVerifySupport(evidenceType, algorithmName);\n+         }\n+\n+         @Override\n+         public boolean verifyEvidence(Evidence evidence) throws RealmUnavailableException {\n+            if (evidence instanceof PasswordGuessEvidence) {\n+               char[] guess = ((PasswordGuessEvidence) evidence).getGuess();\n+               int evidenceHash = Arrays.hashCode(guess);\n+               if (evidenceHash == verifiedEvidenceHash) {\n+                  return true;\n+               }\n+               if (credentials.canVerify(evidence)) {\n+                  log.tracef(\"verifyEvidence For principal='%s' using cached credential\", principal);\n+                  return credentials.verify(evidence);\n+               }\n+               Credential credential = identity.getCredential(PasswordCredential.class);\n+               if (credential != null) {\n+                  log.tracef(\"verifyEvidence Credential obtained from identity and cached for principal='%s'\", principal);\n+                  credentials = credentials.withCredential(credential);\n+                  if (credential.canVerify(evidence)) {\n+                     boolean res = credential.verify(evidence);\n+                     if (res) {\n+                        verifiedEvidenceHash = evidenceHash;\n+                     }\n+                     return res;\n+                  }\n+               }\n+               Password password = ClearPassword.createRaw(ClearPassword.ALGORITHM_CLEAR, guess);\n+               log.tracef(\"verifyEvidence Falling back to direct support of identity for principal='%s'\", principal);\n+               if (identity.verifyEvidence(evidence)) {\n+                  credentials = credentials.withCredential(new PasswordCredential(password));\n+                  return true;\n+               }\n+               return false;\n+            }\n+            return identity.verifyEvidence(evidence);\n+         }\n+\n+         @Override\n+         public boolean exists() throws RealmUnavailableException {\n+            return true; // non-existing identities will not be wrapped\n+         }\n+\n+         @Override\n+         public AuthorizationIdentity getAuthorizationIdentity() throws RealmUnavailableException {\n+            if (authorizationIdentity == null) {\n+               log.tracef(\"getAuthorizationIdentity Caching AuthorizationIdentity for principal='%s'\", principal);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47de697f3d97431632c42c2689c2a18e51fefc18"}, "originalPosition": 238}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0OTczODkx", "url": "https://github.com/infinispan/infinispan/pull/8586#pullrequestreview-514973891", "createdAt": "2020-10-22T17:44:49Z", "commit": {"oid": "47de697f3d97431632c42c2689c2a18e51fefc18"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNzo0NDo0OVrOHmtCjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNzo1Mjo1MVrOHmtWAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM0NTg2OQ==", "bodyText": "Seems this is unused?", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r510345869", "createdAt": "2020-10-22T17:44:49Z", "author": {"login": "wburns"}, "path": "server/rest/src/main/java/org/infinispan/rest/RestRequestHandler.java", "diffHunk": "@@ -124,6 +131,19 @@ public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) thr\n       });\n    }\n \n+   private boolean matchAuthorizationHeader(String authz, String cached) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47de697f3d97431632c42c2689c2a18e51fefc18"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM1MDg1MA==", "bodyText": "Looks like the code says 256?", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r510350850", "createdAt": "2020-10-22T17:52:51Z", "author": {"login": "wburns"}, "path": "server/runtime/src/main/resources/schema/infinispan-server-12.0.xsd", "diffHunk": "@@ -820,6 +820,20 @@\n          <xs:element type=\"tns:security-realm-truststore\" name=\"truststore-realm\" minOccurs=\"0\"/>\n       </xs:sequence>\n       <xs:attribute name=\"name\" type=\"xs:string\" use=\"required\"/>\n+      <xs:attribute name=\"cache-max-size\" type=\"xs:int\" default=\"16\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47de697f3d97431632c42c2689c2a18e51fefc18"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "47de697f3d97431632c42c2689c2a18e51fefc18", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/47de697f3d97431632c42c2689c2a18e51fefc18", "committedDate": "2020-09-04T15:47:03Z", "message": "ISPN-12156 Security Realm identity caching"}, "afterCommit": {"oid": "126c95663fa2c12d04a6814f671d35342d68bcfc", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/126c95663fa2c12d04a6814f671d35342d68bcfc", "committedDate": "2020-11-30T09:54:06Z", "message": "ISPN-12156 Security Realm identity caching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "126c95663fa2c12d04a6814f671d35342d68bcfc", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/126c95663fa2c12d04a6814f671d35342d68bcfc", "committedDate": "2020-11-30T09:54:06Z", "message": "ISPN-12156 Security Realm identity caching"}, "afterCommit": {"oid": "4eb35cde6275655b99cba94885d35363c3251303", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/4eb35cde6275655b99cba94885d35363c3251303", "committedDate": "2020-11-30T10:18:40Z", "message": "ISPN-12156 Security Realm identity caching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4eb35cde6275655b99cba94885d35363c3251303", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/4eb35cde6275655b99cba94885d35363c3251303", "committedDate": "2020-11-30T10:18:40Z", "message": "ISPN-12156 Security Realm identity caching"}, "afterCommit": {"oid": "9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6", "committedDate": "2020-12-17T11:08:40Z", "message": "ISPN-12156 Security Realm identity caching"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MTU3MjQ4", "url": "https://github.com/infinispan/infinispan/pull/8586#pullrequestreview-557157248", "createdAt": "2020-12-22T15:21:02Z", "commit": {"oid": "9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNToyMTowMlrOIJ-zpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNToyOTowN1rOIJ_FwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzNzEyNA==", "bodyText": "Cast is not needed", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r547337124", "createdAt": "2020-12-22T15:21:02Z", "author": {"login": "danberindei"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/CachingSecurityRealm.java", "diffHunk": "@@ -0,0 +1,322 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.wildfly.common.Assert.checkNotNullParam;\n+import static org.infinispan.server.Server.log;\n+\n+import java.security.Principal;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.realm.CacheableSecurityRealm;\n+import org.wildfly.security.auth.server.IdentityCredentials;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.auth.server.event.RealmEvent;\n+import org.wildfly.security.authz.Attributes;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.cache.RealmIdentityCache;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.Password;\n+import org.wildfly.security.password.interfaces.ClearPassword;\n+\n+/**\n+ * <p>A wrapper class that provides caching capabilities for a {@link SecurityRealm} and its identities.\n+ *\n+ * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n+ */\n+public class CachingSecurityRealm implements SecurityRealm {\n+\n+   private final CacheableSecurityRealm realm;\n+   private final RealmIdentityCache cache;\n+\n+   /**\n+    * Creates a new instance.\n+    *\n+    * @param realm the {@link SecurityRealm} whose {@link RealmIdentity} should be cached.\n+    * @param cache the {@link RealmIdentityCache} instance\n+    */\n+   public CachingSecurityRealm(CacheableSecurityRealm realm, RealmIdentityCache cache) {\n+      this.realm = checkNotNullParam(\"realm\", realm);\n+      this.cache = checkNotNullParam(\"cache\", cache);\n+\n+      if (realm instanceof CacheableSecurityRealm) {\n+         CacheableSecurityRealm cacheable = (CacheableSecurityRealm) realm;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM0MTc2MQ==", "bodyText": "So it's not enough to cache the RealmIdentity, we also have to cache the AuthorizationIdentity and IdentityCredentials?", "url": "https://github.com/infinispan/infinispan/pull/8586#discussion_r547341761", "createdAt": "2020-12-22T15:29:07Z", "author": {"login": "danberindei"}, "path": "server/runtime/src/main/java/org/infinispan/server/security/realm/CachingSecurityRealm.java", "diffHunk": "@@ -0,0 +1,322 @@\n+package org.infinispan.server.security.realm;\n+\n+import static org.wildfly.common.Assert.checkNotNullParam;\n+import static org.infinispan.server.Server.log;\n+\n+import java.security.Principal;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+import org.wildfly.security.auth.SupportLevel;\n+import org.wildfly.security.auth.realm.CacheableSecurityRealm;\n+import org.wildfly.security.auth.server.IdentityCredentials;\n+import org.wildfly.security.auth.server.RealmIdentity;\n+import org.wildfly.security.auth.server.RealmUnavailableException;\n+import org.wildfly.security.auth.server.SecurityRealm;\n+import org.wildfly.security.auth.server.event.RealmEvent;\n+import org.wildfly.security.authz.Attributes;\n+import org.wildfly.security.authz.AuthorizationIdentity;\n+import org.wildfly.security.cache.RealmIdentityCache;\n+import org.wildfly.security.credential.Credential;\n+import org.wildfly.security.credential.PasswordCredential;\n+import org.wildfly.security.evidence.Evidence;\n+import org.wildfly.security.evidence.PasswordGuessEvidence;\n+import org.wildfly.security.password.Password;\n+import org.wildfly.security.password.interfaces.ClearPassword;\n+\n+/**\n+ * <p>A wrapper class that provides caching capabilities for a {@link SecurityRealm} and its identities.\n+ *\n+ * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n+ */\n+public class CachingSecurityRealm implements SecurityRealm {\n+\n+   private final CacheableSecurityRealm realm;\n+   private final RealmIdentityCache cache;\n+\n+   /**\n+    * Creates a new instance.\n+    *\n+    * @param realm the {@link SecurityRealm} whose {@link RealmIdentity} should be cached.\n+    * @param cache the {@link RealmIdentityCache} instance\n+    */\n+   public CachingSecurityRealm(CacheableSecurityRealm realm, RealmIdentityCache cache) {\n+      this.realm = checkNotNullParam(\"realm\", realm);\n+      this.cache = checkNotNullParam(\"cache\", cache);\n+\n+      if (realm instanceof CacheableSecurityRealm) {\n+         CacheableSecurityRealm cacheable = (CacheableSecurityRealm) realm;\n+         cacheable.registerIdentityChangeListener(this::removeFromCache);\n+      } else {\n+         throw new IllegalArgumentException(realm.toString());\n+      }\n+   }\n+\n+   @Override\n+   public RealmIdentity getRealmIdentity(Principal principal) throws RealmUnavailableException {\n+      RealmIdentity cached = cache.get(principal);\n+\n+      if (cached != null) {\n+         if(log.isTraceEnabled()) {\n+            log.tracef(\"Returning cached RealmIdentity for '%s'\", principal);\n+         }\n+         return cached;\n+      }\n+\n+      RealmIdentity realmIdentity = getCacheableRealm().getRealmIdentity(principal);\n+\n+      if (!realmIdentity.exists()) {\n+         if(log.isTraceEnabled()) {\n+            log.tracef(\"RealmIdentity for '%s' does not exist, skipping cache.'\", principal);\n+         }\n+         return realmIdentity;\n+      }\n+\n+      RealmIdentity cachedIdentity = new RealmIdentity() {\n+         final RealmIdentity identity = realmIdentity;\n+\n+         AuthorizationIdentity authorizationIdentity = null;\n+         Attributes attributes = null;\n+         IdentityCredentials credentials = IdentityCredentials.NONE;\n+         int verifiedEvidenceHash;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6"}, "originalPosition": 81}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/9f1a6bd1f2c92fb21a73841e9f9b2d1452ddfee6", "committedDate": "2020-12-17T11:08:40Z", "message": "ISPN-12156 Security Realm identity caching"}, "afterCommit": {"oid": "fb20b5be12a632ee59c2442466767892a2a9fdb6", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/fb20b5be12a632ee59c2442466767892a2a9fdb6", "committedDate": "2020-12-22T16:21:56Z", "message": "ISPN-12156 Security Realm identity caching"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4a5884b1947f1df33a6c2de6b17923b1de869c9", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/c4a5884b1947f1df33a6c2de6b17923b1de869c9", "committedDate": "2020-12-22T16:37:33Z", "message": "ISPN-12156 Security Realm identity caching"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb20b5be12a632ee59c2442466767892a2a9fdb6", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/fb20b5be12a632ee59c2442466767892a2a9fdb6", "committedDate": "2020-12-22T16:21:56Z", "message": "ISPN-12156 Security Realm identity caching"}, "afterCommit": {"oid": "c4a5884b1947f1df33a6c2de6b17923b1de869c9", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/c4a5884b1947f1df33a6c2de6b17923b1de869c9", "committedDate": "2020-12-22T16:37:33Z", "message": "ISPN-12156 Security Realm identity caching"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MjEzNDg4", "url": "https://github.com/infinispan/infinispan/pull/8586#pullrequestreview-557213488", "createdAt": "2020-12-22T16:40:05Z", "commit": {"oid": "c4a5884b1947f1df33a6c2de6b17923b1de869c9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 547, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}