{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyODA4MjAz", "number": 8385, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTo0NzozNFrOD_bAag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoyNToxMVrOEAQzwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODI5MzU0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxNTo0NzozNFrOGaE-kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzoyOToyOVrOGbVjwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5NzcxMw==", "bodyText": "@wburns here do we lose meaning if we change \"signals\" to \"indicates\"? or is \"signals\" terminology that is consistent with rxjava etc?", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r429997713", "createdAt": "2020-05-25T15:47:34Z", "author": {"login": "oraNod"}, "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -87,146 +83,145 @@\n     */\n    enum Characteristic {\n       /**\n-       * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database. This characteristic is here solely for validation of the store configuration.\n+       * If this store can be shared across multiple Infinispan nodes; for example, an external system such as\n+       * a database. This characteristic allows validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n-       * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * If this store supports only being read from. Write-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n        * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n-       * will not be invoked on a store that has this characteristic.\n+       * are not invoked on stores with this characteristic.\n        */\n       READ_ONLY,\n       /**\n-       * If this store only supports being written to. Any read based operations will never be invoked on this store.\n+       * If this store supports only being written to. Read-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #load(int, Object)} and\n-       * {@link #containsKey(int, Object)} methods will not be invoked on a store that has this characteristic.\n+       * {@link #containsKey(int, Object)} methods are not invoked on stores with this characteristic.\n        */\n       WRITE_ONLY,\n       /**\n-       * If this store supports bulk read operations. If a store does not have this characteristic operations such\n-       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} will not utilize this store.\n+       * If this store supports bulk read operations. If a store does not have this characteristic, operations such\n+       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} do not use this store.\n        * <p>\n        * Stores that have this characteristic must override the {@link #publishKeys(IntSet, Predicate)},\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}  and {@link #size(IntSet)} methods.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)} and {@link #size(IntSet)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}.\n        */\n       BULK_READ,\n       /**\n-       * If this store supports being invoked in a transactional context with a prepare and commit or rollback phases.\n-       * Stores of this type may take part of the actual transaction if present.\n+       * If this store supports being invoked in a transactional context with prepare and commit or rollback phases.\n+       * Stores of this type can participate in the actual transaction, if present.\n        * <p>\n        * Stores that have this characteristic must override the\n        * {@link #prepareWithModifications(Transaction, BatchModification)}, {@link #commit(Transaction)} and\n        * {@link #rollback(Transaction)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #READ_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #READ_ONLY}.\n        */\n       TRANSACTIONAL,\n       /**\n-       * Whether this store supports being segmented. All methods in this SPI take as an argument a way to map a given\n+       * If this store supports segmentation. All methods in this SPI take as an argument a way to map a given\n        * entry to a segment. A segment in Infinispan is an int that acts as a bucket for many keys. Many store\n        * implementations may be able to store and load entries in a more performant way if they segment their data\n        * accordingly.\n        * <p>\n        * If this store is not segmentable then invokers of this SPI are not required to calculate these segments before\n-       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Please\n-       * see each method to see how they may be affected when this store is not segmentable.\n+       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Refer to\n+       * each method to determine their effect when this store is not segmented.\n        * <p>\n-       * Note that a store may also be configured at runtime to be segmented or not. If this store is configured to not\n-       * be segmented this store will be treated as if it does not have the SEGMENTABLE characteristic (causing possible\n-       * parameters to be null or invalid segment numbers). A store implementation may want to block this configuration\n-       * by throwing an exception in the {@link #start(InitializationContext)} method if it does not want to support this.\n+       * Note that you can also configure stores at runtime to be segmented or not. If the runtime configuration of this\n+       * store is non-segmented, it is equivalent to the store not having the SEGMENTABLE characteristic, which might cause\n+       * parameters to be null or invalid segment numbers. Store implementation can block this configuration\n+       * by throwing an exception in the {@link #start(InitializationContext)} method.\n        * <p>\n-       * While it is possible that a SEGMENTABLE store can be configured as not segmented, a store that is not\n-       * SEGMENTABLE will never be allowed to be configured as segmented.\n+       * While it is possible that a SEGMENTABLE store can be configured as non-segmented, a store that is not\n+       * SEGMENTABLE can never then later be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n-       * via configuration these methods will not be invoked though.\n+       * {@link #removeSegments(IntSet)} methods. However, if a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods are not invoked.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * If this store uses expiration metadata so that it never returns expired entries\n        * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n-       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n-       * entry has expired.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. Stores should use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if entries are\n+       * expired.\n        * <p>\n-       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n-       * which is accessible from the {@link MarshallableEntry} which is provided.\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata},\n+       * accessible from the {@link MarshallableEntry} that is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n-    * The first method that will be invoked to allow the store to be configured and for any additional steps, such as\n-    * connecting via a socket or opening file descriptors, to be performed.\n+    * The first method to invoke so that the store can be configured and additional steps, such as connecting through\n+    * a socket or opening file descriptors, are performed.\n     * <p>\n     * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n     * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n-    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * an executor reserved for non-blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n     * {@link #stop()} has been invoked and allowed for its stage to complete.\n-    * @param ctx initialization context used to initialize this store\n-    * @return a stage that when complete signals that this store has been successfully started\n+    * @param ctx initialization context used to initialize this store.\n+    * @return a stage that, when complete, signals that this store has started successfully.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66376032cb3c2a209962460bbe8a476728f63a5d"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMxNzk1Mw==", "bodyText": "No, signal is just a term I used here. This is specific to CompletionStage as well at this point, so I am fine either way.", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431317953", "createdAt": "2020-05-27T17:29:29Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -87,146 +83,145 @@\n     */\n    enum Characteristic {\n       /**\n-       * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database. This characteristic is here solely for validation of the store configuration.\n+       * If this store can be shared across multiple Infinispan nodes; for example, an external system such as\n+       * a database. This characteristic allows validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n-       * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * If this store supports only being read from. Write-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n        * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n-       * will not be invoked on a store that has this characteristic.\n+       * are not invoked on stores with this characteristic.\n        */\n       READ_ONLY,\n       /**\n-       * If this store only supports being written to. Any read based operations will never be invoked on this store.\n+       * If this store supports only being written to. Read-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #load(int, Object)} and\n-       * {@link #containsKey(int, Object)} methods will not be invoked on a store that has this characteristic.\n+       * {@link #containsKey(int, Object)} methods are not invoked on stores with this characteristic.\n        */\n       WRITE_ONLY,\n       /**\n-       * If this store supports bulk read operations. If a store does not have this characteristic operations such\n-       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} will not utilize this store.\n+       * If this store supports bulk read operations. If a store does not have this characteristic, operations such\n+       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} do not use this store.\n        * <p>\n        * Stores that have this characteristic must override the {@link #publishKeys(IntSet, Predicate)},\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}  and {@link #size(IntSet)} methods.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)} and {@link #size(IntSet)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}.\n        */\n       BULK_READ,\n       /**\n-       * If this store supports being invoked in a transactional context with a prepare and commit or rollback phases.\n-       * Stores of this type may take part of the actual transaction if present.\n+       * If this store supports being invoked in a transactional context with prepare and commit or rollback phases.\n+       * Stores of this type can participate in the actual transaction, if present.\n        * <p>\n        * Stores that have this characteristic must override the\n        * {@link #prepareWithModifications(Transaction, BatchModification)}, {@link #commit(Transaction)} and\n        * {@link #rollback(Transaction)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #READ_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #READ_ONLY}.\n        */\n       TRANSACTIONAL,\n       /**\n-       * Whether this store supports being segmented. All methods in this SPI take as an argument a way to map a given\n+       * If this store supports segmentation. All methods in this SPI take as an argument a way to map a given\n        * entry to a segment. A segment in Infinispan is an int that acts as a bucket for many keys. Many store\n        * implementations may be able to store and load entries in a more performant way if they segment their data\n        * accordingly.\n        * <p>\n        * If this store is not segmentable then invokers of this SPI are not required to calculate these segments before\n-       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Please\n-       * see each method to see how they may be affected when this store is not segmentable.\n+       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Refer to\n+       * each method to determine their effect when this store is not segmented.\n        * <p>\n-       * Note that a store may also be configured at runtime to be segmented or not. If this store is configured to not\n-       * be segmented this store will be treated as if it does not have the SEGMENTABLE characteristic (causing possible\n-       * parameters to be null or invalid segment numbers). A store implementation may want to block this configuration\n-       * by throwing an exception in the {@link #start(InitializationContext)} method if it does not want to support this.\n+       * Note that you can also configure stores at runtime to be segmented or not. If the runtime configuration of this\n+       * store is non-segmented, it is equivalent to the store not having the SEGMENTABLE characteristic, which might cause\n+       * parameters to be null or invalid segment numbers. Store implementation can block this configuration\n+       * by throwing an exception in the {@link #start(InitializationContext)} method.\n        * <p>\n-       * While it is possible that a SEGMENTABLE store can be configured as not segmented, a store that is not\n-       * SEGMENTABLE will never be allowed to be configured as segmented.\n+       * While it is possible that a SEGMENTABLE store can be configured as non-segmented, a store that is not\n+       * SEGMENTABLE can never then later be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n-       * via configuration these methods will not be invoked though.\n+       * {@link #removeSegments(IntSet)} methods. However, if a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods are not invoked.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * If this store uses expiration metadata so that it never returns expired entries\n        * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n-       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n-       * entry has expired.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. Stores should use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if entries are\n+       * expired.\n        * <p>\n-       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n-       * which is accessible from the {@link MarshallableEntry} which is provided.\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata},\n+       * accessible from the {@link MarshallableEntry} that is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n-    * The first method that will be invoked to allow the store to be configured and for any additional steps, such as\n-    * connecting via a socket or opening file descriptors, to be performed.\n+    * The first method to invoke so that the store can be configured and additional steps, such as connecting through\n+    * a socket or opening file descriptors, are performed.\n     * <p>\n     * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n     * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n-    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * an executor reserved for non-blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n     * {@link #stop()} has been invoked and allowed for its stage to complete.\n-    * @param ctx initialization context used to initialize this store\n-    * @return a stage that when complete signals that this store has been successfully started\n+    * @param ctx initialization context used to initialize this store.\n+    * @return a stage that, when complete, signals that this store has started successfully.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5NzcxMw=="}, "originalCommit": {"oid": "66376032cb3c2a209962460bbe8a476728f63a5d"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDIzMDIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/spi/InitializationContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODozMDo1M1rOGa-5Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODozMDo1M1rOGa-5Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0NjYwMw==", "bodyText": "How about just \"an executor for non-blocking tasks\"?", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r430946603", "createdAt": "2020-05-27T08:30:53Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/spi/InitializationContext.java", "diffHunk": "@@ -51,17 +51,18 @@\n    ExecutorService getExecutor();\n \n    /**\n-    * Returns an executor that Infinispan uses internally for non blocking tasks. The user must guarantee tasks\n-    * submitted to this executor will not block the thread it is ran on. Failure to do so can slow down Infinispan's\n-    * handling of operations as these threads are limited to the number of cores and are used extensively.\n-    * @return an executor that can be used to submit tasks that will not block the thread it runs on\n+    * Returns an executor that Infinispan uses to perform tasks in a non-blocking manner. Users must guarantee that the tasks they\n+    * submit to this executor do not block the thread in which the executor runs. Doing so can cause Infinispan to handle operations\n+    * more slowly, reducing performance, because threads are limited to the number of cores and are used extensively.\n+    * @return an executor that can submit non-blocking tasks.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66376032cb3c2a209962460bbe8a476728f63a5d"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NDIzNTc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/spi/InitializationContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwODozMjoyN1rOGa-8yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwOTo0NTo1OVrOGbBtrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0NzUyOQ==", "bodyText": "IMO the original better conveys the purpose of the BlockingManager.", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r430947529", "createdAt": "2020-05-27T08:32:27Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/spi/InitializationContext.java", "diffHunk": "@@ -51,17 +51,18 @@\n    ExecutorService getExecutor();\n \n    /**\n-    * Returns an executor that Infinispan uses internally for non blocking tasks. The user must guarantee tasks\n-    * submitted to this executor will not block the thread it is ran on. Failure to do so can slow down Infinispan's\n-    * handling of operations as these threads are limited to the number of cores and are used extensively.\n-    * @return an executor that can be used to submit tasks that will not block the thread it runs on\n+    * Returns an executor that Infinispan uses to perform tasks in a non-blocking manner. Users must guarantee that the tasks they\n+    * submit to this executor do not block the thread in which the executor runs. Doing so can cause Infinispan to handle operations\n+    * more slowly, reducing performance, because threads are limited to the number of cores and are used extensively.\n+    * @return an executor that can submit non-blocking tasks.\n     */\n    Executor getNonBlockingExecutor();\n \n    /**\n-    * Returns a manager that is designed to execute tasks that may block. This manager ensures that only the blocking\n-    * portion is ran on a blocking thread and any stage is continued on a non blocking thread.\n-    * @return a manager that should be used to execute blocking operations\n+    * Returns a manager that can execute thread-blocking operations. The manager runs any blocking operations on blocking threads,\n+    * any stages continue on non-blocking threads. Use this manager to ensure that blocking operations do not leak into the\n+    * Infinispan internal system.\n+    * @return a manager that can execute blocking operations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66376032cb3c2a209962460bbe8a476728f63a5d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MjgxMg==", "bodyText": "thanks @ryanemerson I've changed back to the original (with a couple minor tweaks)", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r430992812", "createdAt": "2020-05-27T09:45:59Z", "author": {"login": "oraNod"}, "path": "core/src/main/java/org/infinispan/persistence/spi/InitializationContext.java", "diffHunk": "@@ -51,17 +51,18 @@\n    ExecutorService getExecutor();\n \n    /**\n-    * Returns an executor that Infinispan uses internally for non blocking tasks. The user must guarantee tasks\n-    * submitted to this executor will not block the thread it is ran on. Failure to do so can slow down Infinispan's\n-    * handling of operations as these threads are limited to the number of cores and are used extensively.\n-    * @return an executor that can be used to submit tasks that will not block the thread it runs on\n+    * Returns an executor that Infinispan uses to perform tasks in a non-blocking manner. Users must guarantee that the tasks they\n+    * submit to this executor do not block the thread in which the executor runs. Doing so can cause Infinispan to handle operations\n+    * more slowly, reducing performance, because threads are limited to the number of cores and are used extensively.\n+    * @return an executor that can submit non-blocking tasks.\n     */\n    Executor getNonBlockingExecutor();\n \n    /**\n-    * Returns a manager that is designed to execute tasks that may block. This manager ensures that only the blocking\n-    * portion is ran on a blocking thread and any stage is continued on a non blocking thread.\n-    * @return a manager that should be used to execute blocking operations\n+    * Returns a manager that can execute thread-blocking operations. The manager runs any blocking operations on blocking threads,\n+    * any stages continue on non-blocking threads. Use this manager to ensure that blocking operations do not leak into the\n+    * Infinispan internal system.\n+    * @return a manager that can execute blocking operations.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0NzUyOQ=="}, "originalCommit": {"oid": "66376032cb3c2a209962460bbe8a476728f63a5d"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjUzMTMzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzo0NToxMFrOGbWIPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxMjozNTo0MlrOGca1rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyNzI5NA==", "bodyText": "can determine if stores are segmented\nThis is really more that the store itself is configured to be segmented. I am not sure of the best way to word this. But basically if a store is SEGMENTABLE it doesn't mean it is configured to be so.", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431327294", "createdAt": "2020-05-27T17:45:10Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -24,53 +24,49 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n- * The contract for defining a way for a cache to interface with external source of data, such as a database,\n- * filesystem etc. As the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n+ * The contract for defining how caches interface with external sources of data, such as databases or filesystems.\n+ * As the name implies, any method in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n- * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working state\n- * and is ready to handle operations. Infinispan guarantees the visibility of variables written during\n- * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n- * of the store itself.\n+ * The first method invoked on this store is {@link #start(InitializationContext)}, which starts the store.\n+ * Once the returned stage has completed, the store is assumed to be in working state and ready to handle operations.\n+ * Infinispan guarantees the visibility of variables written during the start method, so you do not need to\n+ * synchronize them manually unless they are mutated in the normal operations of the store itself.\n  * <p>\n- * After the store has started, Infinispan will utilise the {@link #characteristics()} method to query the store's\n- * characteristics. It is highly recommended that this method never change the values it returns once the\n- * store has been started as these may or may not be cached. For more information on how the characteristics affect\n- * the store operations, please see {@link Characteristic} and its various values.\n+ * After the store starts, Infinispan uses the {@link #characteristics()} method to query the characteristics of\n+ * the store. It is highly recommended that this method never change the values it returns after the\n+ * store starts because characteristics might not be cached. For more information, see {@link Characteristic}\n+ * and its various values.\n  * <p>\n- * By default this interface only requires half a dozen or so methods to be implemented. However, there are more\n- * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n- * characteristic for that method, so Infinispan knows to invoke it. If Infinispan has been told a\n+ * By default, this interface has only a few required methods. If you implement any of the optional methods,\n+ * ensure that you advertise the appropriate characteristic for that method so that Infinispan invokes it.\n+ * If Infinispan is instructed that a\n  * characteristic is available and the method is not overridden, an {@link UnsupportedOperationException} will be\n  * thrown when trying to invoke the appropriate method. Each {@link Characteristic} defines what methods map to which\n  * characteristic.\n  * <p>\n- * Although recommended, Segmentation support in a store implementation is not required. Segment parameters are provided\n- * for all methods where segment information would be required, for example {@link #load(int, Object)} and\n- * {@link #publishEntries(IntSet, Predicate, boolean). When a store does not support segmentation, these parameters can\n- * simply be ignored by the implementation. As previously stated, it's recommended that segmentation is supported as an\n- * Infinispan cache can perform much more efficiently when segmentation is supported when\n- * performing bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. It also decreases state\n- * transfer duration when {@link PersistenceConfiguration#fetchPersistentState()} is enabled, as well as the time\n- * required to remove data by segments. To indicate that a store implementation supports segmentation, it's necessary\n- * that the {@link Characteristic#SEGMENTABLE} characteristic is returned via the {@link #characteristics()} method. A\n- * store implementation can tell if segmentation is enabled by checking the store configuration\n- * {@link StoreConfiguration#segmented()} available from the {@code InitializationContext}.\n+ * Although recommended, segmentation support in store implementations is optional. Segment parameters are provided\n+ * for all methods where segment information is required, for example {@link #load(int, Object)} and\n+ * {@link #publishEntries(IntSet, Predicate, boolean). If your store implementation does not support segmentation,\n+ * you can ignore these parameters. However, you should note that segmented stores allow Infinispan caches to more\n+ * efficiently perform bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. Segmentation\n+ * also decreases the duration of state transfers when {@link PersistenceConfiguration#fetchPersistentState()} is enabled,\n+ * as well as the time required to remove data by segments. To indicate that a store implementation supports segmentation,\n+ * the {@link Characteristic#SEGMENTABLE} characteristic must be returned by the {@link #characteristics()} method. Store\n+ * implementations can determine if stores are segmented if {@link StoreConfiguration#segmented()} is enabled, which is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dffd152256336ba0cdfeb1311ee5e50234a39fb"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxOTgxNg==", "bodyText": "@wburns hmm. thanks, I updated but maybe the phrasing still isn't 100%. could you look at this line again please?", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431419816", "createdAt": "2020-05-27T20:23:06Z", "author": {"login": "oraNod"}, "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -24,53 +24,49 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n- * The contract for defining a way for a cache to interface with external source of data, such as a database,\n- * filesystem etc. As the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n+ * The contract for defining how caches interface with external sources of data, such as databases or filesystems.\n+ * As the name implies, any method in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n- * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working state\n- * and is ready to handle operations. Infinispan guarantees the visibility of variables written during\n- * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n- * of the store itself.\n+ * The first method invoked on this store is {@link #start(InitializationContext)}, which starts the store.\n+ * Once the returned stage has completed, the store is assumed to be in working state and ready to handle operations.\n+ * Infinispan guarantees the visibility of variables written during the start method, so you do not need to\n+ * synchronize them manually unless they are mutated in the normal operations of the store itself.\n  * <p>\n- * After the store has started, Infinispan will utilise the {@link #characteristics()} method to query the store's\n- * characteristics. It is highly recommended that this method never change the values it returns once the\n- * store has been started as these may or may not be cached. For more information on how the characteristics affect\n- * the store operations, please see {@link Characteristic} and its various values.\n+ * After the store starts, Infinispan uses the {@link #characteristics()} method to query the characteristics of\n+ * the store. It is highly recommended that this method never change the values it returns after the\n+ * store starts because characteristics might not be cached. For more information, see {@link Characteristic}\n+ * and its various values.\n  * <p>\n- * By default this interface only requires half a dozen or so methods to be implemented. However, there are more\n- * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n- * characteristic for that method, so Infinispan knows to invoke it. If Infinispan has been told a\n+ * By default, this interface has only a few required methods. If you implement any of the optional methods,\n+ * ensure that you advertise the appropriate characteristic for that method so that Infinispan invokes it.\n+ * If Infinispan is instructed that a\n  * characteristic is available and the method is not overridden, an {@link UnsupportedOperationException} will be\n  * thrown when trying to invoke the appropriate method. Each {@link Characteristic} defines what methods map to which\n  * characteristic.\n  * <p>\n- * Although recommended, Segmentation support in a store implementation is not required. Segment parameters are provided\n- * for all methods where segment information would be required, for example {@link #load(int, Object)} and\n- * {@link #publishEntries(IntSet, Predicate, boolean). When a store does not support segmentation, these parameters can\n- * simply be ignored by the implementation. As previously stated, it's recommended that segmentation is supported as an\n- * Infinispan cache can perform much more efficiently when segmentation is supported when\n- * performing bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. It also decreases state\n- * transfer duration when {@link PersistenceConfiguration#fetchPersistentState()} is enabled, as well as the time\n- * required to remove data by segments. To indicate that a store implementation supports segmentation, it's necessary\n- * that the {@link Characteristic#SEGMENTABLE} characteristic is returned via the {@link #characteristics()} method. A\n- * store implementation can tell if segmentation is enabled by checking the store configuration\n- * {@link StoreConfiguration#segmented()} available from the {@code InitializationContext}.\n+ * Although recommended, segmentation support in store implementations is optional. Segment parameters are provided\n+ * for all methods where segment information is required, for example {@link #load(int, Object)} and\n+ * {@link #publishEntries(IntSet, Predicate, boolean). If your store implementation does not support segmentation,\n+ * you can ignore these parameters. However, you should note that segmented stores allow Infinispan caches to more\n+ * efficiently perform bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. Segmentation\n+ * also decreases the duration of state transfers when {@link PersistenceConfiguration#fetchPersistentState()} is enabled,\n+ * as well as the time required to remove data by segments. To indicate that a store implementation supports segmentation,\n+ * the {@link Characteristic#SEGMENTABLE} characteristic must be returned by the {@link #characteristics()} method. Store\n+ * implementations can determine if stores are segmented if {@link StoreConfiguration#segmented()} is enabled, which is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyNzI5NA=="}, "originalCommit": {"oid": "8dffd152256336ba0cdfeb1311ee5e50234a39fb"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1MzAzNw==", "bodyText": "Seems okay to me.", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r432453037", "createdAt": "2020-05-29T12:35:42Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -24,53 +24,49 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n- * The contract for defining a way for a cache to interface with external source of data, such as a database,\n- * filesystem etc. As the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n+ * The contract for defining how caches interface with external sources of data, such as databases or filesystems.\n+ * As the name implies, any method in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n- * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working state\n- * and is ready to handle operations. Infinispan guarantees the visibility of variables written during\n- * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n- * of the store itself.\n+ * The first method invoked on this store is {@link #start(InitializationContext)}, which starts the store.\n+ * Once the returned stage has completed, the store is assumed to be in working state and ready to handle operations.\n+ * Infinispan guarantees the visibility of variables written during the start method, so you do not need to\n+ * synchronize them manually unless they are mutated in the normal operations of the store itself.\n  * <p>\n- * After the store has started, Infinispan will utilise the {@link #characteristics()} method to query the store's\n- * characteristics. It is highly recommended that this method never change the values it returns once the\n- * store has been started as these may or may not be cached. For more information on how the characteristics affect\n- * the store operations, please see {@link Characteristic} and its various values.\n+ * After the store starts, Infinispan uses the {@link #characteristics()} method to query the characteristics of\n+ * the store. It is highly recommended that this method never change the values it returns after the\n+ * store starts because characteristics might not be cached. For more information, see {@link Characteristic}\n+ * and its various values.\n  * <p>\n- * By default this interface only requires half a dozen or so methods to be implemented. However, there are more\n- * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n- * characteristic for that method, so Infinispan knows to invoke it. If Infinispan has been told a\n+ * By default, this interface has only a few required methods. If you implement any of the optional methods,\n+ * ensure that you advertise the appropriate characteristic for that method so that Infinispan invokes it.\n+ * If Infinispan is instructed that a\n  * characteristic is available and the method is not overridden, an {@link UnsupportedOperationException} will be\n  * thrown when trying to invoke the appropriate method. Each {@link Characteristic} defines what methods map to which\n  * characteristic.\n  * <p>\n- * Although recommended, Segmentation support in a store implementation is not required. Segment parameters are provided\n- * for all methods where segment information would be required, for example {@link #load(int, Object)} and\n- * {@link #publishEntries(IntSet, Predicate, boolean). When a store does not support segmentation, these parameters can\n- * simply be ignored by the implementation. As previously stated, it's recommended that segmentation is supported as an\n- * Infinispan cache can perform much more efficiently when segmentation is supported when\n- * performing bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. It also decreases state\n- * transfer duration when {@link PersistenceConfiguration#fetchPersistentState()} is enabled, as well as the time\n- * required to remove data by segments. To indicate that a store implementation supports segmentation, it's necessary\n- * that the {@link Characteristic#SEGMENTABLE} characteristic is returned via the {@link #characteristics()} method. A\n- * store implementation can tell if segmentation is enabled by checking the store configuration\n- * {@link StoreConfiguration#segmented()} available from the {@code InitializationContext}.\n+ * Although recommended, segmentation support in store implementations is optional. Segment parameters are provided\n+ * for all methods where segment information is required, for example {@link #load(int, Object)} and\n+ * {@link #publishEntries(IntSet, Predicate, boolean). If your store implementation does not support segmentation,\n+ * you can ignore these parameters. However, you should note that segmented stores allow Infinispan caches to more\n+ * efficiently perform bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. Segmentation\n+ * also decreases the duration of state transfers when {@link PersistenceConfiguration#fetchPersistentState()} is enabled,\n+ * as well as the time required to remove data by segments. To indicate that a store implementation supports segmentation,\n+ * the {@link Characteristic#SEGMENTABLE} characteristic must be returned by the {@link #characteristics()} method. Store\n+ * implementations can determine if stores are segmented if {@link StoreConfiguration#segmented()} is enabled, which is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyNzI5NA=="}, "originalCommit": {"oid": "8dffd152256336ba0cdfeb1311ee5e50234a39fb"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjUzNDUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzo0NjowNlrOGbWKRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzo0NjowNlrOGbWKRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyNzgxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * by running runs any blocking operations on blocking threads, while any stages continue on non-blocking threads.\n          \n          \n            \n             * by running any blocking operations on blocking threads, while any stages continue on non-blocking threads.", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431327812", "createdAt": "2020-05-27T17:46:06Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -24,53 +24,49 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n- * The contract for defining a way for a cache to interface with external source of data, such as a database,\n- * filesystem etc. As the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n+ * The contract for defining how caches interface with external sources of data, such as databases or filesystems.\n+ * As the name implies, any method in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n- * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working state\n- * and is ready to handle operations. Infinispan guarantees the visibility of variables written during\n- * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n- * of the store itself.\n+ * The first method invoked on this store is {@link #start(InitializationContext)}, which starts the store.\n+ * Once the returned stage has completed, the store is assumed to be in working state and ready to handle operations.\n+ * Infinispan guarantees the visibility of variables written during the start method, so you do not need to\n+ * synchronize them manually unless they are mutated in the normal operations of the store itself.\n  * <p>\n- * After the store has started, Infinispan will utilise the {@link #characteristics()} method to query the store's\n- * characteristics. It is highly recommended that this method never change the values it returns once the\n- * store has been started as these may or may not be cached. For more information on how the characteristics affect\n- * the store operations, please see {@link Characteristic} and its various values.\n+ * After the store starts, Infinispan uses the {@link #characteristics()} method to query the characteristics of\n+ * the store. It is highly recommended that this method never change the values it returns after the\n+ * store starts because characteristics might not be cached. For more information, see {@link Characteristic}\n+ * and its various values.\n  * <p>\n- * By default this interface only requires half a dozen or so methods to be implemented. However, there are more\n- * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n- * characteristic for that method, so Infinispan knows to invoke it. If Infinispan has been told a\n+ * By default, this interface has only a few required methods. If you implement any of the optional methods,\n+ * ensure that you advertise the appropriate characteristic for that method so that Infinispan invokes it.\n+ * If Infinispan is instructed that a\n  * characteristic is available and the method is not overridden, an {@link UnsupportedOperationException} will be\n  * thrown when trying to invoke the appropriate method. Each {@link Characteristic} defines what methods map to which\n  * characteristic.\n  * <p>\n- * Although recommended, Segmentation support in a store implementation is not required. Segment parameters are provided\n- * for all methods where segment information would be required, for example {@link #load(int, Object)} and\n- * {@link #publishEntries(IntSet, Predicate, boolean). When a store does not support segmentation, these parameters can\n- * simply be ignored by the implementation. As previously stated, it's recommended that segmentation is supported as an\n- * Infinispan cache can perform much more efficiently when segmentation is supported when\n- * performing bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. It also decreases state\n- * transfer duration when {@link PersistenceConfiguration#fetchPersistentState()} is enabled, as well as the time\n- * required to remove data by segments. To indicate that a store implementation supports segmentation, it's necessary\n- * that the {@link Characteristic#SEGMENTABLE} characteristic is returned via the {@link #characteristics()} method. A\n- * store implementation can tell if segmentation is enabled by checking the store configuration\n- * {@link StoreConfiguration#segmented()} available from the {@code InitializationContext}.\n+ * Although recommended, segmentation support in store implementations is optional. Segment parameters are provided\n+ * for all methods where segment information is required, for example {@link #load(int, Object)} and\n+ * {@link #publishEntries(IntSet, Predicate, boolean). If your store implementation does not support segmentation,\n+ * you can ignore these parameters. However, you should note that segmented stores allow Infinispan caches to more\n+ * efficiently perform bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. Segmentation\n+ * also decreases the duration of state transfers when {@link PersistenceConfiguration#fetchPersistentState()} is enabled,\n+ * as well as the time required to remove data by segments. To indicate that a store implementation supports segmentation,\n+ * the {@link Characteristic#SEGMENTABLE} characteristic must be returned by the {@link #characteristics()} method. Store\n+ * implementations can determine if stores are segmented if {@link StoreConfiguration#segmented()} is enabled, which is\n+ * available from the {@code InitializationContext}.\n  * <p>\n- * A store implementation may have to interact with blocking APIs to perform their required operations, however we\n- * should never block the invoking thread, therefore Infinispan provides a utility helper for these operations. This is\n- * the {@link org.infinispan.util.concurrent.BlockingManager} and may be obtained by invoking\n- * {@link InitializationContext#getBlockingManager()} on the provided context in the start method. This utility class\n- * comes with an assortment of methods ranging from equivalent methods for more commonly used methods such as\n- * {@link java.util.concurrent.CompletableFuture#supplyAsync(Supplier, Executor)} to a wrapper around a\n- * {@link Publisher} that ensures it is subscribed and obversed on the proper threads. The {@code BlockingManager} is\n- * special in that it guarantees the code that is blocking is ran on a blocking thread but any stages it produces are\n- * continued on a non blocking thread, which is very important to not leak blocking threads to the internal Infinispan\n- * system.\n+ * Store implementations might need to interact with blocking APIs to perform their required operations. However the invoking\n+ * thread must never be blocked, so Infinispan provides a {@link org.infinispan.util.concurrent.BlockingManager} utility class\n+ * that handles blocking operations to ensure that they do not leak into the internal system. {@code BlockingManager} does this\n+ * by running runs any blocking operations on blocking threads, while any stages continue on non-blocking threads.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dffd152256336ba0cdfeb1311ee5e50234a39fb"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjU1OTI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzo1MDo1NFrOGbWZIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzo1MDo1NFrOGbWZIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMzMTYxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * The default implementations return a completed stage with the value {@code Boolean.TRUE}.\n          \n          \n            \n                * The default implementation returns a completed stage with the value {@code Boolean.TRUE}.", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431331619", "createdAt": "2020-05-27T17:50:54Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -87,146 +83,145 @@\n     */\n    enum Characteristic {\n       /**\n-       * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database. This characteristic is here solely for validation of the store configuration.\n+       * If this store can be shared across multiple Infinispan nodes; for example, an external system such as\n+       * a database. This characteristic allows validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n-       * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * If this store supports only being read from. Write-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n        * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n-       * will not be invoked on a store that has this characteristic.\n+       * are not invoked on stores with this characteristic.\n        */\n       READ_ONLY,\n       /**\n-       * If this store only supports being written to. Any read based operations will never be invoked on this store.\n+       * If this store supports only being written to. Read-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #load(int, Object)} and\n-       * {@link #containsKey(int, Object)} methods will not be invoked on a store that has this characteristic.\n+       * {@link #containsKey(int, Object)} methods are not invoked on stores with this characteristic.\n        */\n       WRITE_ONLY,\n       /**\n-       * If this store supports bulk read operations. If a store does not have this characteristic operations such\n-       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} will not utilize this store.\n+       * If this store supports bulk read operations. If a store does not have this characteristic, operations such\n+       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} do not use this store.\n        * <p>\n        * Stores that have this characteristic must override the {@link #publishKeys(IntSet, Predicate)},\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}  and {@link #size(IntSet)} methods.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)} and {@link #size(IntSet)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}.\n        */\n       BULK_READ,\n       /**\n-       * If this store supports being invoked in a transactional context with a prepare and commit or rollback phases.\n-       * Stores of this type may take part of the actual transaction if present.\n+       * If this store supports being invoked in a transactional context with prepare and commit or rollback phases.\n+       * Stores of this type can participate in the actual transaction, if present.\n        * <p>\n        * Stores that have this characteristic must override the\n        * {@link #prepareWithModifications(Transaction, BatchModification)}, {@link #commit(Transaction)} and\n        * {@link #rollback(Transaction)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #READ_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #READ_ONLY}.\n        */\n       TRANSACTIONAL,\n       /**\n-       * Whether this store supports being segmented. All methods in this SPI take as an argument a way to map a given\n+       * If this store supports segmentation. All methods in this SPI take as an argument a way to map a given\n        * entry to a segment. A segment in Infinispan is an int that acts as a bucket for many keys. Many store\n        * implementations may be able to store and load entries in a more performant way if they segment their data\n        * accordingly.\n        * <p>\n        * If this store is not segmentable then invokers of this SPI are not required to calculate these segments before\n-       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Please\n-       * see each method to see how they may be affected when this store is not segmentable.\n+       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Refer to\n+       * each method to determine their effect when this store is not segmented.\n        * <p>\n-       * Note that a store may also be configured at runtime to be segmented or not. If this store is configured to not\n-       * be segmented this store will be treated as if it does not have the SEGMENTABLE characteristic (causing possible\n-       * parameters to be null or invalid segment numbers). A store implementation may want to block this configuration\n-       * by throwing an exception in the {@link #start(InitializationContext)} method if it does not want to support this.\n+       * Note that you can also configure stores at runtime to be segmented or not. If the runtime configuration of this\n+       * store is non-segmented, it is equivalent to the store not having the SEGMENTABLE characteristic, which might cause\n+       * parameters to be null or invalid segment numbers. Store implementation can block this configuration\n+       * by throwing an exception in the {@link #start(InitializationContext)} method.\n        * <p>\n-       * While it is possible that a SEGMENTABLE store can be configured as not segmented, a store that is not\n-       * SEGMENTABLE will never be allowed to be configured as segmented.\n+       * While it is possible that a SEGMENTABLE store can be configured as non-segmented, a store that is not\n+       * SEGMENTABLE can never then later be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n-       * via configuration these methods will not be invoked though.\n+       * {@link #removeSegments(IntSet)} methods. However, if a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods are not invoked.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * If this store uses expiration metadata so that it never returns expired entries\n        * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n-       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n-       * entry has expired.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. Stores should use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if entries are\n+       * expired.\n        * <p>\n-       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n-       * which is accessible from the {@link MarshallableEntry} which is provided.\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata},\n+       * accessible from the {@link MarshallableEntry} that is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n-    * The first method that will be invoked to allow the store to be configured and for any additional steps, such as\n-    * connecting via a socket or opening file descriptors, to be performed.\n+    * The first method to invoke so that the store can be configured and additional steps, such as connecting through\n+    * a socket or opening file descriptors, are performed.\n     * <p>\n     * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n     * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n-    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * an executor reserved for non-blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n     * {@link #stop()} has been invoked and allowed for its stage to complete.\n-    * @param ctx initialization context used to initialize this store\n-    * @return a stage that when complete signals that this store has been successfully started\n+    * @param ctx initialization context used to initialize this store.\n+    * @return a stage that, when complete, signals that this store has started successfully.\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n-    * This method will be invoked when the cache is being shutdown. It is expected that all resources related to the\n-    * store to be freed upon completion of the returned stage.\n+    * This method is invoked when the cache is being shutdown. It is expected that all resources related to the\n+    * store are freed when the returned stage is complete.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n     * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n-    * @return a stage that when complete signals that this store has been stopped\n+    * @return a stage that, when complete, signals that this store has stopped.\n     */\n    CompletionStage<Void> stop();\n \n    /**\n     * Returns a set of characteristics for this store and its elements. This method may be invoked multiple times\n-    * to determine which methods of the store can be used and how its data can be handled.\n+    * to determine which methods of the store can be used and how the data in the store can be handled.\n     * <p>\n-    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n-    * store as supporting.\n+    * Refer to {@link Characteristic} and its values for descriptions of each characteristic for stores.\n     * @implSpec\n-    * The default implementation returns an empty set\n-    * @return the set of characteristics that this store supports\n+    * The default implementation returns an empty set.\n+    * @return the set of characteristics that this store supports.\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    * Returns a stage that when complete returns a boolean indicating whether the current store can be accessed for\n+    * Returns a stage that, when complete, returns a boolean indicating whether the current store can be accessed for\n     * requests. This can be useful for store implementations that rely on an external source, such as a remote database,\n     * that may become unreachable. This can reduce sending requests to a store that is not available, as subsequent cache\n     * requests will result in a {@link StoreUnavailableException} being thrown until the store becomes available again.\n     * <p>\n-    * Store availability is is polled periodically to update a store's status if it's availability changes. This method\n-    * will not be invoked concurrently with itself (ie. this method will not be invoked until after the previous stage\n-    * has completed), but will be invoked concurrently with other operations, excluding\n+    * Store availability is is polled periodically to update the status of stores if their availability changes. This method\n+    * is not invoked concurrently with itself. In other words, this method is not invoked until after the previous stage\n+    * has completed. However this method is invoked concurrently with other operations, except for\n     * {@link #start(InitializationContext)} and {@link #stop()}.\n     * <p>\n-    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it's\n+    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it is\n     possible for the cache operations to be accepted in the interim period between the loss of availability and the\n     modification-queue becoming full. This allows for this store to be unavailable for short periods of time without a\n-    {@link StoreUnavailableException} being thrown, however if the store does not become available before the queue\n-    fills, then a {@link StoreUnavailableException} is eventually thrown.\n+    {@link StoreUnavailableException} being thrown; however if the store does not become available before the queue\n+    fills, then a {@link StoreUnavailableException} is thrown.\n     * @implSpec\n-    * The default implementations returns a completed stage with the value {@code Boolean.TRUE}\n-    * @return stage that when complete signals if the store is available\n+    * The default implementations return a completed stage with the value {@code Boolean.TRUE}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dffd152256336ba0cdfeb1311ee5e50234a39fb"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjYwMjI0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzo1ODowNFrOGbWy2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzo1ODowNFrOGbWy2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMzODIwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * of operations across threads if need TRACE logs.\n          \n          \n            \n             * of operations across threads if TRACE logs are used.", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431338202", "createdAt": "2020-05-27T17:58:04Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -9,155 +9,156 @@\n import org.reactivestreams.Publisher;\n \n /**\n- * Runs tasks on the blocking executor and returns a {@code CompletionStage} or {@code Publisher} that continues on the\n- * non-blocking executor, similar to {@code stage.handleAsync(callback, blockingExecutor).whenCompleteAsync(NOOP, nonBlockingExecutor)}.\n+ * Manager utility for blocking operations that runs tasks on the blocking executor and returns a\n+ * {@code CompletionStage} or {@code Publisher} that continues on the non-blocking executor, similar\n+ * to {@code stage.handleAsync(callback, blockingExecutor).whenCompleteAsync(NOOP, nonBlockingExecutor)}.\n  * <p>\n- * If the current thread is blocking, it blocks until the task may run, runs the task in the current thread, and returns a\n- * completed {@code CompletionStage}, so it <em>does not</em> continue the execution on the non-blocking executor.\n+ * If the current thread is blocking, it blocks until the task can run, then runs the task in the current thread and returns a\n+ * completed {@code CompletionStage} so it <em>does not</em> continue the execution on the non-blocking executor.\n  * <p>\n- * Many of the methods on {@code BlockingManager} allow an id to be passed when performing the operation. This id will\n- * be printed to the TRACE log. It is therefore advised to provide something unique so that\n- * if a log is needed it will be easier to track the stream of operations across threads.\n+ * Many of the methods on {@code BlockingManager} let you pass an identifier (ID) when performing the operation. This ID is\n+ * printed with TRACE logs. For this reason, you should provide IDs that are unique, making it easier to track the stream\n+ * of operations across threads if need TRACE logs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8dffd152256336ba0cdfeb1311ee5e50234a39fb"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NzEwODQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDoyNToxMVrOGbb1RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDo0NjoxMlrOGbcfOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyMDc0MA==", "bodyText": "@wburns could you also please check this line? \"default store implementations return\" or should it be \"default store implementation returns\"? I presume the former as Infinispan provides multiple store implementations.", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431420740", "createdAt": "2020-05-27T20:25:11Z", "author": {"login": "oraNod"}, "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -87,146 +83,145 @@\n     */\n    enum Characteristic {\n       /**\n-       * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database. This characteristic is here solely for validation of the store configuration.\n+       * If this store can be shared across multiple Infinispan nodes; for example, an external system such as\n+       * a database. This characteristic allows validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n-       * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * If this store supports only being read from. Write-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n        * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n-       * will not be invoked on a store that has this characteristic.\n+       * are not invoked on stores with this characteristic.\n        */\n       READ_ONLY,\n       /**\n-       * If this store only supports being written to. Any read based operations will never be invoked on this store.\n+       * If this store supports only being written to. Read-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #load(int, Object)} and\n-       * {@link #containsKey(int, Object)} methods will not be invoked on a store that has this characteristic.\n+       * {@link #containsKey(int, Object)} methods are not invoked on stores with this characteristic.\n        */\n       WRITE_ONLY,\n       /**\n-       * If this store supports bulk read operations. If a store does not have this characteristic operations such\n-       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} will not utilize this store.\n+       * If this store supports bulk read operations. If a store does not have this characteristic, operations such\n+       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} do not use this store.\n        * <p>\n        * Stores that have this characteristic must override the {@link #publishKeys(IntSet, Predicate)},\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}  and {@link #size(IntSet)} methods.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)} and {@link #size(IntSet)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}.\n        */\n       BULK_READ,\n       /**\n-       * If this store supports being invoked in a transactional context with a prepare and commit or rollback phases.\n-       * Stores of this type may take part of the actual transaction if present.\n+       * If this store supports being invoked in a transactional context with prepare and commit or rollback phases.\n+       * Stores of this type can participate in the actual transaction, if present.\n        * <p>\n        * Stores that have this characteristic must override the\n        * {@link #prepareWithModifications(Transaction, BatchModification)}, {@link #commit(Transaction)} and\n        * {@link #rollback(Transaction)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #READ_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #READ_ONLY}.\n        */\n       TRANSACTIONAL,\n       /**\n-       * Whether this store supports being segmented. All methods in this SPI take as an argument a way to map a given\n+       * If this store supports segmentation. All methods in this SPI take as an argument a way to map a given\n        * entry to a segment. A segment in Infinispan is an int that acts as a bucket for many keys. Many store\n        * implementations may be able to store and load entries in a more performant way if they segment their data\n        * accordingly.\n        * <p>\n        * If this store is not segmentable then invokers of this SPI are not required to calculate these segments before\n-       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Please\n-       * see each method to see how they may be affected when this store is not segmentable.\n+       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Refer to\n+       * each method to determine their effect when this store is not segmented.\n        * <p>\n-       * Note that a store may also be configured at runtime to be segmented or not. If this store is configured to not\n-       * be segmented this store will be treated as if it does not have the SEGMENTABLE characteristic (causing possible\n-       * parameters to be null or invalid segment numbers). A store implementation may want to block this configuration\n-       * by throwing an exception in the {@link #start(InitializationContext)} method if it does not want to support this.\n+       * Note that you can also configure stores at runtime to be segmented or not. If the runtime configuration of this\n+       * store is non-segmented, it is equivalent to the store not having the SEGMENTABLE characteristic, which might cause\n+       * parameters to be null or invalid segment numbers. Store implementation can block this configuration\n+       * by throwing an exception in the {@link #start(InitializationContext)} method.\n        * <p>\n-       * While it is possible that a SEGMENTABLE store can be configured as not segmented, a store that is not\n-       * SEGMENTABLE will never be allowed to be configured as segmented.\n+       * While it is possible that a SEGMENTABLE store can be configured as non-segmented, a store that is not\n+       * SEGMENTABLE can never then later be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n-       * via configuration these methods will not be invoked though.\n+       * {@link #removeSegments(IntSet)} methods. However, if a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods are not invoked.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * If this store uses expiration metadata so that it never returns expired entries\n        * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n-       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n-       * entry has expired.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. Stores should use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if entries are\n+       * expired.\n        * <p>\n-       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n-       * which is accessible from the {@link MarshallableEntry} which is provided.\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata},\n+       * accessible from the {@link MarshallableEntry} that is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n-    * The first method that will be invoked to allow the store to be configured and for any additional steps, such as\n-    * connecting via a socket or opening file descriptors, to be performed.\n+    * The first method to invoke so that the store can be configured and additional steps, such as connecting through\n+    * a socket or opening file descriptors, are performed.\n     * <p>\n     * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n     * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n-    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * an executor reserved for non-blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n     * {@link #stop()} has been invoked and allowed for its stage to complete.\n-    * @param ctx initialization context used to initialize this store\n-    * @return a stage that when complete signals that this store has been successfully started\n+    * @param ctx initialization context used to initialize this store.\n+    * @return a stage that, when complete, indicates that this store has started successfully.\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n-    * This method will be invoked when the cache is being shutdown. It is expected that all resources related to the\n-    * store to be freed upon completion of the returned stage.\n+    * This method is invoked when the cache is being shutdown. It is expected that all resources related to the\n+    * store are freed when the returned stage is complete.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n     * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n-    * @return a stage that when complete signals that this store has been stopped\n+    * @return a stage that, when complete, indicates that this store has stopped.\n     */\n    CompletionStage<Void> stop();\n \n    /**\n     * Returns a set of characteristics for this store and its elements. This method may be invoked multiple times\n-    * to determine which methods of the store can be used and how its data can be handled.\n+    * to determine which methods of the store can be used and how the data in the store can be handled.\n     * <p>\n-    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n-    * store as supporting.\n+    * Refer to {@link Characteristic} and its values for descriptions of each characteristic for stores.\n     * @implSpec\n-    * The default implementation returns an empty set\n-    * @return the set of characteristics that this store supports\n+    * The default implementation returns an empty set.\n+    * @return the set of characteristics that this store supports.\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    * Returns a stage that when complete returns a boolean indicating whether the current store can be accessed for\n+    * Returns a stage that, when complete, returns a boolean indicating whether the current store can be accessed for\n     * requests. This can be useful for store implementations that rely on an external source, such as a remote database,\n     * that may become unreachable. This can reduce sending requests to a store that is not available, as subsequent cache\n     * requests will result in a {@link StoreUnavailableException} being thrown until the store becomes available again.\n     * <p>\n-    * Store availability is is polled periodically to update a store's status if it's availability changes. This method\n-    * will not be invoked concurrently with itself (ie. this method will not be invoked until after the previous stage\n-    * has completed), but will be invoked concurrently with other operations, excluding\n+    * Store availability is is polled periodically to update the status of stores if their availability changes. This method\n+    * is not invoked concurrently with itself. In other words, this method is not invoked until after the previous stage\n+    * has completed. However this method is invoked concurrently with other operations, except for\n     * {@link #start(InitializationContext)} and {@link #stop()}.\n     * <p>\n-    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it's\n+    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it is\n     possible for the cache operations to be accepted in the interim period between the loss of availability and the\n     modification-queue becoming full. This allows for this store to be unavailable for short periods of time without a\n-    {@link StoreUnavailableException} being thrown, however if the store does not become available before the queue\n-    fills, then a {@link StoreUnavailableException} is eventually thrown.\n+    {@link StoreUnavailableException} being thrown; however if the store does not become available before the queue\n+    fills, then a {@link StoreUnavailableException} is thrown.\n     * @implSpec\n-    * The default implementations returns a completed stage with the value {@code Boolean.TRUE}\n-    * @return stage that when complete signals if the store is available\n+    * The default store implementations return a completed stage with the value {@code Boolean.TRUE}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c85bd6693fa890e0de9a92030007dfa9552e7abf"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyMzkxOQ==", "bodyText": "No this is referring to the default implementation of this method. TBH I think it should just be \"The default implementation returns ..\"", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431423919", "createdAt": "2020-05-27T20:31:36Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -87,146 +83,145 @@\n     */\n    enum Characteristic {\n       /**\n-       * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database. This characteristic is here solely for validation of the store configuration.\n+       * If this store can be shared across multiple Infinispan nodes; for example, an external system such as\n+       * a database. This characteristic allows validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n-       * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * If this store supports only being read from. Write-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n        * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n-       * will not be invoked on a store that has this characteristic.\n+       * are not invoked on stores with this characteristic.\n        */\n       READ_ONLY,\n       /**\n-       * If this store only supports being written to. Any read based operations will never be invoked on this store.\n+       * If this store supports only being written to. Read-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #load(int, Object)} and\n-       * {@link #containsKey(int, Object)} methods will not be invoked on a store that has this characteristic.\n+       * {@link #containsKey(int, Object)} methods are not invoked on stores with this characteristic.\n        */\n       WRITE_ONLY,\n       /**\n-       * If this store supports bulk read operations. If a store does not have this characteristic operations such\n-       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} will not utilize this store.\n+       * If this store supports bulk read operations. If a store does not have this characteristic, operations such\n+       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} do not use this store.\n        * <p>\n        * Stores that have this characteristic must override the {@link #publishKeys(IntSet, Predicate)},\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}  and {@link #size(IntSet)} methods.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)} and {@link #size(IntSet)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}.\n        */\n       BULK_READ,\n       /**\n-       * If this store supports being invoked in a transactional context with a prepare and commit or rollback phases.\n-       * Stores of this type may take part of the actual transaction if present.\n+       * If this store supports being invoked in a transactional context with prepare and commit or rollback phases.\n+       * Stores of this type can participate in the actual transaction, if present.\n        * <p>\n        * Stores that have this characteristic must override the\n        * {@link #prepareWithModifications(Transaction, BatchModification)}, {@link #commit(Transaction)} and\n        * {@link #rollback(Transaction)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #READ_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #READ_ONLY}.\n        */\n       TRANSACTIONAL,\n       /**\n-       * Whether this store supports being segmented. All methods in this SPI take as an argument a way to map a given\n+       * If this store supports segmentation. All methods in this SPI take as an argument a way to map a given\n        * entry to a segment. A segment in Infinispan is an int that acts as a bucket for many keys. Many store\n        * implementations may be able to store and load entries in a more performant way if they segment their data\n        * accordingly.\n        * <p>\n        * If this store is not segmentable then invokers of this SPI are not required to calculate these segments before\n-       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Please\n-       * see each method to see how they may be affected when this store is not segmentable.\n+       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Refer to\n+       * each method to determine their effect when this store is not segmented.\n        * <p>\n-       * Note that a store may also be configured at runtime to be segmented or not. If this store is configured to not\n-       * be segmented this store will be treated as if it does not have the SEGMENTABLE characteristic (causing possible\n-       * parameters to be null or invalid segment numbers). A store implementation may want to block this configuration\n-       * by throwing an exception in the {@link #start(InitializationContext)} method if it does not want to support this.\n+       * Note that you can also configure stores at runtime to be segmented or not. If the runtime configuration of this\n+       * store is non-segmented, it is equivalent to the store not having the SEGMENTABLE characteristic, which might cause\n+       * parameters to be null or invalid segment numbers. Store implementation can block this configuration\n+       * by throwing an exception in the {@link #start(InitializationContext)} method.\n        * <p>\n-       * While it is possible that a SEGMENTABLE store can be configured as not segmented, a store that is not\n-       * SEGMENTABLE will never be allowed to be configured as segmented.\n+       * While it is possible that a SEGMENTABLE store can be configured as non-segmented, a store that is not\n+       * SEGMENTABLE can never then later be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n-       * via configuration these methods will not be invoked though.\n+       * {@link #removeSegments(IntSet)} methods. However, if a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods are not invoked.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * If this store uses expiration metadata so that it never returns expired entries\n        * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n-       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n-       * entry has expired.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. Stores should use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if entries are\n+       * expired.\n        * <p>\n-       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n-       * which is accessible from the {@link MarshallableEntry} which is provided.\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata},\n+       * accessible from the {@link MarshallableEntry} that is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n-    * The first method that will be invoked to allow the store to be configured and for any additional steps, such as\n-    * connecting via a socket or opening file descriptors, to be performed.\n+    * The first method to invoke so that the store can be configured and additional steps, such as connecting through\n+    * a socket or opening file descriptors, are performed.\n     * <p>\n     * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n     * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n-    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * an executor reserved for non-blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n     * {@link #stop()} has been invoked and allowed for its stage to complete.\n-    * @param ctx initialization context used to initialize this store\n-    * @return a stage that when complete signals that this store has been successfully started\n+    * @param ctx initialization context used to initialize this store.\n+    * @return a stage that, when complete, indicates that this store has started successfully.\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n-    * This method will be invoked when the cache is being shutdown. It is expected that all resources related to the\n-    * store to be freed upon completion of the returned stage.\n+    * This method is invoked when the cache is being shutdown. It is expected that all resources related to the\n+    * store are freed when the returned stage is complete.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n     * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n-    * @return a stage that when complete signals that this store has been stopped\n+    * @return a stage that, when complete, indicates that this store has stopped.\n     */\n    CompletionStage<Void> stop();\n \n    /**\n     * Returns a set of characteristics for this store and its elements. This method may be invoked multiple times\n-    * to determine which methods of the store can be used and how its data can be handled.\n+    * to determine which methods of the store can be used and how the data in the store can be handled.\n     * <p>\n-    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n-    * store as supporting.\n+    * Refer to {@link Characteristic} and its values for descriptions of each characteristic for stores.\n     * @implSpec\n-    * The default implementation returns an empty set\n-    * @return the set of characteristics that this store supports\n+    * The default implementation returns an empty set.\n+    * @return the set of characteristics that this store supports.\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    * Returns a stage that when complete returns a boolean indicating whether the current store can be accessed for\n+    * Returns a stage that, when complete, returns a boolean indicating whether the current store can be accessed for\n     * requests. This can be useful for store implementations that rely on an external source, such as a remote database,\n     * that may become unreachable. This can reduce sending requests to a store that is not available, as subsequent cache\n     * requests will result in a {@link StoreUnavailableException} being thrown until the store becomes available again.\n     * <p>\n-    * Store availability is is polled periodically to update a store's status if it's availability changes. This method\n-    * will not be invoked concurrently with itself (ie. this method will not be invoked until after the previous stage\n-    * has completed), but will be invoked concurrently with other operations, excluding\n+    * Store availability is is polled periodically to update the status of stores if their availability changes. This method\n+    * is not invoked concurrently with itself. In other words, this method is not invoked until after the previous stage\n+    * has completed. However this method is invoked concurrently with other operations, except for\n     * {@link #start(InitializationContext)} and {@link #stop()}.\n     * <p>\n-    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it's\n+    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it is\n     possible for the cache operations to be accepted in the interim period between the loss of availability and the\n     modification-queue becoming full. This allows for this store to be unavailable for short periods of time without a\n-    {@link StoreUnavailableException} being thrown, however if the store does not become available before the queue\n-    fills, then a {@link StoreUnavailableException} is eventually thrown.\n+    {@link StoreUnavailableException} being thrown; however if the store does not become available before the queue\n+    fills, then a {@link StoreUnavailableException} is thrown.\n     * @implSpec\n-    * The default implementations returns a completed stage with the value {@code Boolean.TRUE}\n-    * @return stage that when complete signals if the store is available\n+    * The default store implementations return a completed stage with the value {@code Boolean.TRUE}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyMDc0MA=="}, "originalCommit": {"oid": "c85bd6693fa890e0de9a92030007dfa9552e7abf"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMTQ4Mw==", "bodyText": "thanks @wburns I see that now \ud83e\udd26 was probably over-complicating things...", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431431483", "createdAt": "2020-05-27T20:46:12Z", "author": {"login": "oraNod"}, "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -87,146 +83,145 @@\n     */\n    enum Characteristic {\n       /**\n-       * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database. This characteristic is here solely for validation of the store configuration.\n+       * If this store can be shared across multiple Infinispan nodes; for example, an external system such as\n+       * a database. This characteristic allows validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n-       * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * If this store supports only being read from. Write-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n        * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n-       * will not be invoked on a store that has this characteristic.\n+       * are not invoked on stores with this characteristic.\n        */\n       READ_ONLY,\n       /**\n-       * If this store only supports being written to. Any read based operations will never be invoked on this store.\n+       * If this store supports only being written to. Read-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #load(int, Object)} and\n-       * {@link #containsKey(int, Object)} methods will not be invoked on a store that has this characteristic.\n+       * {@link #containsKey(int, Object)} methods are not invoked on stores with this characteristic.\n        */\n       WRITE_ONLY,\n       /**\n-       * If this store supports bulk read operations. If a store does not have this characteristic operations such\n-       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} will not utilize this store.\n+       * If this store supports bulk read operations. If a store does not have this characteristic, operations such\n+       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} do not use this store.\n        * <p>\n        * Stores that have this characteristic must override the {@link #publishKeys(IntSet, Predicate)},\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}  and {@link #size(IntSet)} methods.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)} and {@link #size(IntSet)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}.\n        */\n       BULK_READ,\n       /**\n-       * If this store supports being invoked in a transactional context with a prepare and commit or rollback phases.\n-       * Stores of this type may take part of the actual transaction if present.\n+       * If this store supports being invoked in a transactional context with prepare and commit or rollback phases.\n+       * Stores of this type can participate in the actual transaction, if present.\n        * <p>\n        * Stores that have this characteristic must override the\n        * {@link #prepareWithModifications(Transaction, BatchModification)}, {@link #commit(Transaction)} and\n        * {@link #rollback(Transaction)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #READ_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #READ_ONLY}.\n        */\n       TRANSACTIONAL,\n       /**\n-       * Whether this store supports being segmented. All methods in this SPI take as an argument a way to map a given\n+       * If this store supports segmentation. All methods in this SPI take as an argument a way to map a given\n        * entry to a segment. A segment in Infinispan is an int that acts as a bucket for many keys. Many store\n        * implementations may be able to store and load entries in a more performant way if they segment their data\n        * accordingly.\n        * <p>\n        * If this store is not segmentable then invokers of this SPI are not required to calculate these segments before\n-       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Please\n-       * see each method to see how they may be affected when this store is not segmentable.\n+       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Refer to\n+       * each method to determine their effect when this store is not segmented.\n        * <p>\n-       * Note that a store may also be configured at runtime to be segmented or not. If this store is configured to not\n-       * be segmented this store will be treated as if it does not have the SEGMENTABLE characteristic (causing possible\n-       * parameters to be null or invalid segment numbers). A store implementation may want to block this configuration\n-       * by throwing an exception in the {@link #start(InitializationContext)} method if it does not want to support this.\n+       * Note that you can also configure stores at runtime to be segmented or not. If the runtime configuration of this\n+       * store is non-segmented, it is equivalent to the store not having the SEGMENTABLE characteristic, which might cause\n+       * parameters to be null or invalid segment numbers. Store implementation can block this configuration\n+       * by throwing an exception in the {@link #start(InitializationContext)} method.\n        * <p>\n-       * While it is possible that a SEGMENTABLE store can be configured as not segmented, a store that is not\n-       * SEGMENTABLE will never be allowed to be configured as segmented.\n+       * While it is possible that a SEGMENTABLE store can be configured as non-segmented, a store that is not\n+       * SEGMENTABLE can never then later be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n-       * via configuration these methods will not be invoked though.\n+       * {@link #removeSegments(IntSet)} methods. However, if a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods are not invoked.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * If this store uses expiration metadata so that it never returns expired entries\n        * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n-       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n-       * entry has expired.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. Stores should use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if entries are\n+       * expired.\n        * <p>\n-       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n-       * which is accessible from the {@link MarshallableEntry} which is provided.\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata},\n+       * accessible from the {@link MarshallableEntry} that is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n-    * The first method that will be invoked to allow the store to be configured and for any additional steps, such as\n-    * connecting via a socket or opening file descriptors, to be performed.\n+    * The first method to invoke so that the store can be configured and additional steps, such as connecting through\n+    * a socket or opening file descriptors, are performed.\n     * <p>\n     * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n     * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n-    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * an executor reserved for non-blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n     * {@link #stop()} has been invoked and allowed for its stage to complete.\n-    * @param ctx initialization context used to initialize this store\n-    * @return a stage that when complete signals that this store has been successfully started\n+    * @param ctx initialization context used to initialize this store.\n+    * @return a stage that, when complete, indicates that this store has started successfully.\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n-    * This method will be invoked when the cache is being shutdown. It is expected that all resources related to the\n-    * store to be freed upon completion of the returned stage.\n+    * This method is invoked when the cache is being shutdown. It is expected that all resources related to the\n+    * store are freed when the returned stage is complete.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n     * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n-    * @return a stage that when complete signals that this store has been stopped\n+    * @return a stage that, when complete, indicates that this store has stopped.\n     */\n    CompletionStage<Void> stop();\n \n    /**\n     * Returns a set of characteristics for this store and its elements. This method may be invoked multiple times\n-    * to determine which methods of the store can be used and how its data can be handled.\n+    * to determine which methods of the store can be used and how the data in the store can be handled.\n     * <p>\n-    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n-    * store as supporting.\n+    * Refer to {@link Characteristic} and its values for descriptions of each characteristic for stores.\n     * @implSpec\n-    * The default implementation returns an empty set\n-    * @return the set of characteristics that this store supports\n+    * The default implementation returns an empty set.\n+    * @return the set of characteristics that this store supports.\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    * Returns a stage that when complete returns a boolean indicating whether the current store can be accessed for\n+    * Returns a stage that, when complete, returns a boolean indicating whether the current store can be accessed for\n     * requests. This can be useful for store implementations that rely on an external source, such as a remote database,\n     * that may become unreachable. This can reduce sending requests to a store that is not available, as subsequent cache\n     * requests will result in a {@link StoreUnavailableException} being thrown until the store becomes available again.\n     * <p>\n-    * Store availability is is polled periodically to update a store's status if it's availability changes. This method\n-    * will not be invoked concurrently with itself (ie. this method will not be invoked until after the previous stage\n-    * has completed), but will be invoked concurrently with other operations, excluding\n+    * Store availability is is polled periodically to update the status of stores if their availability changes. This method\n+    * is not invoked concurrently with itself. In other words, this method is not invoked until after the previous stage\n+    * has completed. However this method is invoked concurrently with other operations, except for\n     * {@link #start(InitializationContext)} and {@link #stop()}.\n     * <p>\n-    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it's\n+    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it is\n     possible for the cache operations to be accepted in the interim period between the loss of availability and the\n     modification-queue becoming full. This allows for this store to be unavailable for short periods of time without a\n-    {@link StoreUnavailableException} being thrown, however if the store does not become available before the queue\n-    fills, then a {@link StoreUnavailableException} is eventually thrown.\n+    {@link StoreUnavailableException} being thrown; however if the store does not become available before the queue\n+    fills, then a {@link StoreUnavailableException} is thrown.\n     * @implSpec\n-    * The default implementations returns a completed stage with the value {@code Boolean.TRUE}\n-    * @return stage that when complete signals if the store is available\n+    * The default store implementations return a completed stage with the value {@code Boolean.TRUE}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyMDc0MA=="}, "originalCommit": {"oid": "c85bd6693fa890e0de9a92030007dfa9552e7abf"}, "originalPosition": 284}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4113, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}