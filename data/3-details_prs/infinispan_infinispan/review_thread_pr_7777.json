{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2MTEwNzI4", "number": 7777, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxODowNDo1NVrODeGr0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxODowNDo1NVrODeGr0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODkzMzk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxODowNDo1NVrOFnFfxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxODowNDo1NVrOFnFfxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUyODgzOA==", "bodyText": "Shouldn't we check if (isCompletedSuccessfully(stage)) first?", "url": "https://github.com/infinispan/infinispan/pull/7777#discussion_r376528838", "createdAt": "2020-02-07T18:04:55Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/factories/InternalCacheFactory.java", "diffHunk": "@@ -311,56 +312,18 @@ public boolean containsKey(Object key) {\n       }\n \n       @Override\n-      public CompletableFuture<V> getAsync(K key) {\n-         return getCacheEntryAsync(key)\n-               .thenApply(ice -> ice != null ? ice.getValue() : null);\n-      }\n-\n-      private InternalCacheEntry<K, V> internalPeekCacheEntry(Object key, int segment) {\n+      public InternalCacheEntry<K, V> getCacheEntry(Object key) {\n          assertKeyNotNull(key);\n          checkCanRun(cache, cache.getName());\n-         return getDataContainer().peek(segment, key);\n-      }\n-\n-      @Override\n-      public InternalCacheEntry<K, V> getCacheEntry(Object key) {\n-         int segment = keyPartitioner.getSegment(key);\n-         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n-         if (ice != null) {\n-            if (ice.canExpire()) {\n-               CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n-               if (CompletionStages.join(stage)) {\n-                  ice = null;\n-               }\n-            }\n-         }\n-         return ice;\n-      }\n-\n-      @Override\n-      public CompletableFuture<CacheEntry<K, V>> getCacheEntryAsync(Object key) {\n          int segment = keyPartitioner.getSegment(key);\n-         InternalCacheEntry<K, V> ice = internalPeekCacheEntry(key, segment);\n-         if (ice == null) {\n-            return CompletableFutures.completedNull();\n-         }\n-         if (ice.canExpire()) {\n+         InternalCacheEntry<K, V> ice = getDataContainer().peek(segment, key);\n+         if (ice != null && ice.canExpire()) {\n             CompletionStage<Boolean> stage = expirationManager.handlePossibleExpiration(ice, segment, false);\n-            if (CompletionStages.isCompletedSuccessfully(stage)) {\n-               if (CompletionStages.join(stage)) {\n-                  return CompletableFutures.completedNull();\n-               }\n-               return CompletableFuture.completedFuture(ice);\n-            } else {\n-               return stage.thenApply(expired -> {\n-                  if (expired == Boolean.TRUE) {\n-                     return null;\n-                  }\n-                  return (CacheEntry<K, V>) ice;\n-               }).toCompletableFuture();\n+            if (CompletionStages.join(stage)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf6c34b93921cd1a1433cb0566b021d7024f4a58"}, "originalPosition": 95}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4523, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}