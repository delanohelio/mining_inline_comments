{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMDI2Njk0", "number": 7849, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMzo1NjowOVrODedjyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNjoxOTozMFrODhxpvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMjY4MTY4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/CacheStatusCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMzo1NjowOVrOFnm5xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMzo1NjowOVrOFnm5xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3NjE2Ng==", "bodyText": "You don't need to create the Response. GlobalInboundInvocationHandler wraps the return value for you,", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377076166", "createdAt": "2020-02-10T13:56:09Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/commands/topology/CacheStatusCommand.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.remoting.responses.SuccessfulResponse;\n+\n+/**\n+ * The coordinator is requesting information about the running caches.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class CacheStatusCommand extends AbstractTopologyCommand {\n+\n+   public static final byte COMMAND_ID = 96;\n+\n+   private int viewId;\n+\n+   // For CommandIdUniquenessTest only\n+   public CacheStatusCommand() {\n+      super(COMMAND_ID);\n+   }\n+\n+   public CacheStatusCommand(int viewId) {\n+      super(COMMAND_ID);\n+      this.viewId = viewId;\n+   }\n+\n+   @Override\n+   public CompletionStage<?> invokeAsync(GlobalComponentRegistry gcr) throws Throwable {\n+      return gcr.getLocalTopologyManager()\n+            .handleStatusRequest(viewId)\n+            .thenApply(SuccessfulResponse::create);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMjY5NTA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/ConfirmRebalancePhaseCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxMzo1OTo0NVrOFnnB_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzoyMDowNVrOFnupLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3ODI3MQ==", "bodyText": "we can avoid sending the sender. You have ReplicableCommand.setOrigin(Address) that is invoked on the receiver side with the sender address.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377078271", "createdAt": "2020-02-10T13:59:45Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/commands/topology/ConfirmRebalancePhaseCommand.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.remoting.responses.SuccessfulResponse;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheTopology;\n+\n+/**\n+ * A member is confirming that it has finished a topology change during rebalance. This confirmation is sent after\n+ * topologies with {@link CacheTopology.Phase#READ_OLD_WRITE_ALL}, {@link CacheTopology.Phase#READ_ALL_WRITE_ALL} and\n+ * {@link CacheTopology.Phase#READ_NEW_WRITE_ALL} rebalance phases are installed, but not after a topology change with\n+ * {@link CacheTopology.Phase#NO_REBALANCE} phase.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class ConfirmRebalancePhaseCommand extends AbstractTopologyCommand {\n+\n+   public static final byte COMMAND_ID = 87;\n+\n+   private String cacheName;\n+   private Address sender;\n+   private Throwable throwable;\n+   private int topologyId;\n+   private int viewId;\n+\n+   // For CommandIdUniquenessTest only\n+   public ConfirmRebalancePhaseCommand() {\n+      super(COMMAND_ID);\n+   }\n+\n+   public ConfirmRebalancePhaseCommand(String cacheName, Address sender, Throwable throwable, int topologyId, int viewId) {\n+      super(COMMAND_ID);\n+      this.cacheName = cacheName;\n+      this.sender = sender;\n+      this.throwable = throwable;\n+      this.topologyId = topologyId;\n+      this.viewId = viewId;\n+   }\n+\n+   @Override\n+   public CompletionStage<?> invokeAsync(GlobalComponentRegistry gcr) throws Throwable {\n+      return gcr.getClusterTopologyManager()\n+            .handleRebalancePhaseConfirm(cacheName, sender, topologyId, throwable, viewId)\n+            .thenApply(SuccessfulResponse::create);\n+   }\n+\n+   public String getCacheName() {\n+      return cacheName;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      MarshallUtil.marshallString(cacheName, output);\n+      output.writeObject(sender);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIwMjk4OA==", "bodyText": "Good spot \ud83d\udc4d", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377202988", "createdAt": "2020-02-10T17:20:05Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/topology/ConfirmRebalancePhaseCommand.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.remoting.responses.SuccessfulResponse;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheTopology;\n+\n+/**\n+ * A member is confirming that it has finished a topology change during rebalance. This confirmation is sent after\n+ * topologies with {@link CacheTopology.Phase#READ_OLD_WRITE_ALL}, {@link CacheTopology.Phase#READ_ALL_WRITE_ALL} and\n+ * {@link CacheTopology.Phase#READ_NEW_WRITE_ALL} rebalance phases are installed, but not after a topology change with\n+ * {@link CacheTopology.Phase#NO_REBALANCE} phase.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class ConfirmRebalancePhaseCommand extends AbstractTopologyCommand {\n+\n+   public static final byte COMMAND_ID = 87;\n+\n+   private String cacheName;\n+   private Address sender;\n+   private Throwable throwable;\n+   private int topologyId;\n+   private int viewId;\n+\n+   // For CommandIdUniquenessTest only\n+   public ConfirmRebalancePhaseCommand() {\n+      super(COMMAND_ID);\n+   }\n+\n+   public ConfirmRebalancePhaseCommand(String cacheName, Address sender, Throwable throwable, int topologyId, int viewId) {\n+      super(COMMAND_ID);\n+      this.cacheName = cacheName;\n+      this.sender = sender;\n+      this.throwable = throwable;\n+      this.topologyId = topologyId;\n+      this.viewId = viewId;\n+   }\n+\n+   @Override\n+   public CompletionStage<?> invokeAsync(GlobalComponentRegistry gcr) throws Throwable {\n+      return gcr.getClusterTopologyManager()\n+            .handleRebalancePhaseConfirm(cacheName, sender, topologyId, throwable, viewId)\n+            .thenApply(SuccessfulResponse::create);\n+   }\n+\n+   public String getCacheName() {\n+      return cacheName;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      MarshallUtil.marshallString(cacheName, output);\n+      output.writeObject(sender);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3ODI3MQ=="}, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMjY5ODczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/ConsistentHashUpdateCommand.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNDowMDo1MVrOFnnEQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxMTowMzo1MVrOFoE4Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3ODg0OQ==", "bodyText": "CacheTopology has an externalizer. You can extract the code to static methods and invoke them. No need to declare all these fields neither copy-paste the write/read code.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377078849", "createdAt": "2020-02-10T14:00:51Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/commands/topology/ConsistentHashUpdateCommand.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.distribution.ch.ConsistentHash;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.partitionhandling.AvailabilityMode;\n+import org.infinispan.remoting.responses.SuccessfulResponse;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheTopology;\n+import org.infinispan.topology.PersistentUUID;\n+\n+/**\n+ * Coordinator to member:\n+ * The coordinator is updating the consistent hash.\n+ * Used to signal the end of rebalancing as well.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class ConsistentHashUpdateCommand extends AbstractTopologyCommand {\n+\n+   public static final byte COMMAND_ID = 95;\n+\n+   private String cacheName;\n+   private Address sender;\n+   private ConsistentHash currentCH;\n+   private ConsistentHash pendingCH;\n+   private CacheTopology.Phase phase;\n+   private List<Address> actualMembers;\n+   private List<PersistentUUID> persistentUUIDs;\n+   private AvailabilityMode availabilityMode;\n+   private int rebalanceId;\n+   private int topologyId;\n+   private int viewId;\n+\n+   // For CommandIdUniquenessTest only\n+   public ConsistentHashUpdateCommand() {\n+      super(COMMAND_ID);\n+   }\n+\n+   public ConsistentHashUpdateCommand(String cacheName, Address sender, CacheTopology cacheTopology,\n+                                      AvailabilityMode availabilityMode, int viewId) {\n+      super(COMMAND_ID);\n+      this.cacheName = cacheName;\n+      this.sender = sender;\n+      this.topologyId = cacheTopology.getTopologyId();\n+      this.rebalanceId = cacheTopology.getRebalanceId();\n+      this.currentCH = cacheTopology.getCurrentCH();\n+      this.pendingCH = cacheTopology.getPendingCH();\n+      this.phase = cacheTopology.getPhase();\n+      this.availabilityMode = availabilityMode;\n+      this.actualMembers = cacheTopology.getActualMembers();\n+      this.persistentUUIDs = cacheTopology.getMembersPersistentUUIDs();\n+      this.viewId = viewId;\n+   }\n+\n+   @Override\n+   public CompletionStage<?> invokeAsync(GlobalComponentRegistry gcr) throws Throwable {\n+      CacheTopology topology = new CacheTopology(topologyId, rebalanceId, currentCH, pendingCH, phase, actualMembers, persistentUUIDs);\n+      return gcr.getLocalTopologyManager()\n+            .handleTopologyUpdate(cacheName, topology, availabilityMode, viewId, sender)\n+            .thenApply(SuccessfulResponse::create);\n+   }\n+\n+   public String getCacheName() {\n+      return cacheName;\n+   }\n+\n+   public ConsistentHash getCurrentCH() {\n+      return currentCH;\n+   }\n+\n+   public ConsistentHash getPendingCH() {\n+      return pendingCH;\n+   }\n+\n+   public CacheTopology.Phase getPhase() {\n+      return phase;\n+   }\n+\n+   public int getTopologyId() {\n+      return topologyId;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      MarshallUtil.marshallString(cacheName, output);\n+      output.writeObject(sender);\n+      output.writeObject(currentCH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5NzI3MQ==", "bodyText": "The CacheTopology externalizer will be removed, as well this writeTo implementation once the GlobalMarshaller is converted to protostream. I just lifted this code from the old command.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377197271", "createdAt": "2020-02-10T17:09:44Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/topology/ConsistentHashUpdateCommand.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.distribution.ch.ConsistentHash;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.partitionhandling.AvailabilityMode;\n+import org.infinispan.remoting.responses.SuccessfulResponse;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheTopology;\n+import org.infinispan.topology.PersistentUUID;\n+\n+/**\n+ * Coordinator to member:\n+ * The coordinator is updating the consistent hash.\n+ * Used to signal the end of rebalancing as well.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class ConsistentHashUpdateCommand extends AbstractTopologyCommand {\n+\n+   public static final byte COMMAND_ID = 95;\n+\n+   private String cacheName;\n+   private Address sender;\n+   private ConsistentHash currentCH;\n+   private ConsistentHash pendingCH;\n+   private CacheTopology.Phase phase;\n+   private List<Address> actualMembers;\n+   private List<PersistentUUID> persistentUUIDs;\n+   private AvailabilityMode availabilityMode;\n+   private int rebalanceId;\n+   private int topologyId;\n+   private int viewId;\n+\n+   // For CommandIdUniquenessTest only\n+   public ConsistentHashUpdateCommand() {\n+      super(COMMAND_ID);\n+   }\n+\n+   public ConsistentHashUpdateCommand(String cacheName, Address sender, CacheTopology cacheTopology,\n+                                      AvailabilityMode availabilityMode, int viewId) {\n+      super(COMMAND_ID);\n+      this.cacheName = cacheName;\n+      this.sender = sender;\n+      this.topologyId = cacheTopology.getTopologyId();\n+      this.rebalanceId = cacheTopology.getRebalanceId();\n+      this.currentCH = cacheTopology.getCurrentCH();\n+      this.pendingCH = cacheTopology.getPendingCH();\n+      this.phase = cacheTopology.getPhase();\n+      this.availabilityMode = availabilityMode;\n+      this.actualMembers = cacheTopology.getActualMembers();\n+      this.persistentUUIDs = cacheTopology.getMembersPersistentUUIDs();\n+      this.viewId = viewId;\n+   }\n+\n+   @Override\n+   public CompletionStage<?> invokeAsync(GlobalComponentRegistry gcr) throws Throwable {\n+      CacheTopology topology = new CacheTopology(topologyId, rebalanceId, currentCH, pendingCH, phase, actualMembers, persistentUUIDs);\n+      return gcr.getLocalTopologyManager()\n+            .handleTopologyUpdate(cacheName, topology, availabilityMode, viewId, sender)\n+            .thenApply(SuccessfulResponse::create);\n+   }\n+\n+   public String getCacheName() {\n+      return cacheName;\n+   }\n+\n+   public ConsistentHash getCurrentCH() {\n+      return currentCH;\n+   }\n+\n+   public ConsistentHash getPendingCH() {\n+      return pendingCH;\n+   }\n+\n+   public CacheTopology.Phase getPhase() {\n+      return phase;\n+   }\n+\n+   public int getTopologyId() {\n+      return topologyId;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      MarshallUtil.marshallString(cacheName, output);\n+      output.writeObject(sender);\n+      output.writeObject(currentCH);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3ODg0OQ=="}, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIzMjk1MQ==", "bodyText": "I noticed the \"copy-paste\" style :)\nHow long until it is converted to protostream? Is it worth to make the change/refactorization?", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377232951", "createdAt": "2020-02-10T18:17:53Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/commands/topology/ConsistentHashUpdateCommand.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.distribution.ch.ConsistentHash;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.partitionhandling.AvailabilityMode;\n+import org.infinispan.remoting.responses.SuccessfulResponse;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheTopology;\n+import org.infinispan.topology.PersistentUUID;\n+\n+/**\n+ * Coordinator to member:\n+ * The coordinator is updating the consistent hash.\n+ * Used to signal the end of rebalancing as well.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class ConsistentHashUpdateCommand extends AbstractTopologyCommand {\n+\n+   public static final byte COMMAND_ID = 95;\n+\n+   private String cacheName;\n+   private Address sender;\n+   private ConsistentHash currentCH;\n+   private ConsistentHash pendingCH;\n+   private CacheTopology.Phase phase;\n+   private List<Address> actualMembers;\n+   private List<PersistentUUID> persistentUUIDs;\n+   private AvailabilityMode availabilityMode;\n+   private int rebalanceId;\n+   private int topologyId;\n+   private int viewId;\n+\n+   // For CommandIdUniquenessTest only\n+   public ConsistentHashUpdateCommand() {\n+      super(COMMAND_ID);\n+   }\n+\n+   public ConsistentHashUpdateCommand(String cacheName, Address sender, CacheTopology cacheTopology,\n+                                      AvailabilityMode availabilityMode, int viewId) {\n+      super(COMMAND_ID);\n+      this.cacheName = cacheName;\n+      this.sender = sender;\n+      this.topologyId = cacheTopology.getTopologyId();\n+      this.rebalanceId = cacheTopology.getRebalanceId();\n+      this.currentCH = cacheTopology.getCurrentCH();\n+      this.pendingCH = cacheTopology.getPendingCH();\n+      this.phase = cacheTopology.getPhase();\n+      this.availabilityMode = availabilityMode;\n+      this.actualMembers = cacheTopology.getActualMembers();\n+      this.persistentUUIDs = cacheTopology.getMembersPersistentUUIDs();\n+      this.viewId = viewId;\n+   }\n+\n+   @Override\n+   public CompletionStage<?> invokeAsync(GlobalComponentRegistry gcr) throws Throwable {\n+      CacheTopology topology = new CacheTopology(topologyId, rebalanceId, currentCH, pendingCH, phase, actualMembers, persistentUUIDs);\n+      return gcr.getLocalTopologyManager()\n+            .handleTopologyUpdate(cacheName, topology, availabilityMode, viewId, sender)\n+            .thenApply(SuccessfulResponse::create);\n+   }\n+\n+   public String getCacheName() {\n+      return cacheName;\n+   }\n+\n+   public ConsistentHash getCurrentCH() {\n+      return currentCH;\n+   }\n+\n+   public ConsistentHash getPendingCH() {\n+      return pendingCH;\n+   }\n+\n+   public CacheTopology.Phase getPhase() {\n+      return phase;\n+   }\n+\n+   public int getTopologyId() {\n+      return topologyId;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      MarshallUtil.marshallString(cacheName, output);\n+      output.writeObject(sender);\n+      output.writeObject(currentCH);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3ODg0OQ=="}, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU2NzI5NQ==", "bodyText": "I'm refactoring the commands to make the protostream conversion easier, so it's actually already started \ud83d\ude42", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377567295", "createdAt": "2020-02-11T11:03:51Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/topology/ConsistentHashUpdateCommand.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.distribution.ch.ConsistentHash;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.partitionhandling.AvailabilityMode;\n+import org.infinispan.remoting.responses.SuccessfulResponse;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheTopology;\n+import org.infinispan.topology.PersistentUUID;\n+\n+/**\n+ * Coordinator to member:\n+ * The coordinator is updating the consistent hash.\n+ * Used to signal the end of rebalancing as well.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class ConsistentHashUpdateCommand extends AbstractTopologyCommand {\n+\n+   public static final byte COMMAND_ID = 95;\n+\n+   private String cacheName;\n+   private Address sender;\n+   private ConsistentHash currentCH;\n+   private ConsistentHash pendingCH;\n+   private CacheTopology.Phase phase;\n+   private List<Address> actualMembers;\n+   private List<PersistentUUID> persistentUUIDs;\n+   private AvailabilityMode availabilityMode;\n+   private int rebalanceId;\n+   private int topologyId;\n+   private int viewId;\n+\n+   // For CommandIdUniquenessTest only\n+   public ConsistentHashUpdateCommand() {\n+      super(COMMAND_ID);\n+   }\n+\n+   public ConsistentHashUpdateCommand(String cacheName, Address sender, CacheTopology cacheTopology,\n+                                      AvailabilityMode availabilityMode, int viewId) {\n+      super(COMMAND_ID);\n+      this.cacheName = cacheName;\n+      this.sender = sender;\n+      this.topologyId = cacheTopology.getTopologyId();\n+      this.rebalanceId = cacheTopology.getRebalanceId();\n+      this.currentCH = cacheTopology.getCurrentCH();\n+      this.pendingCH = cacheTopology.getPendingCH();\n+      this.phase = cacheTopology.getPhase();\n+      this.availabilityMode = availabilityMode;\n+      this.actualMembers = cacheTopology.getActualMembers();\n+      this.persistentUUIDs = cacheTopology.getMembersPersistentUUIDs();\n+      this.viewId = viewId;\n+   }\n+\n+   @Override\n+   public CompletionStage<?> invokeAsync(GlobalComponentRegistry gcr) throws Throwable {\n+      CacheTopology topology = new CacheTopology(topologyId, rebalanceId, currentCH, pendingCH, phase, actualMembers, persistentUUIDs);\n+      return gcr.getLocalTopologyManager()\n+            .handleTopologyUpdate(cacheName, topology, availabilityMode, viewId, sender)\n+            .thenApply(SuccessfulResponse::create);\n+   }\n+\n+   public String getCacheName() {\n+      return cacheName;\n+   }\n+\n+   public ConsistentHash getCurrentCH() {\n+      return currentCH;\n+   }\n+\n+   public ConsistentHash getPendingCH() {\n+      return pendingCH;\n+   }\n+\n+   public CacheTopology.Phase getPhase() {\n+      return phase;\n+   }\n+\n+   public int getTopologyId() {\n+      return topologyId;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      MarshallUtil.marshallString(cacheName, output);\n+      output.writeObject(sender);\n+      output.writeObject(currentCH);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3ODg0OQ=="}, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMjcwNzc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNDowMzoxMVrOFnnJgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxODoxNDo0NVrOFnwX_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MDE5Mw==", "bodyText": "not sure what is the state about custom commands (or modules command).", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377080193", "createdAt": "2020-02-10T14:03:11Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java", "diffHunk": "@@ -154,6 +154,7 @@ private ReplicableCommandRunner(ReplicableCommand command, Reply reply,\n       @Override\n       public void run() {\n          try {\n+            // TODO can we remove this?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5ODc2Ng==", "bodyText": "I think we can move it so that it's in the else block of the command instanceof GlobalRpcCommand, because if it's a GlobalRpcCommand (new interface as of 11) it should be utilising the component registry passed with invokeAsync. @danberindei Any thoughts?", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377198766", "createdAt": "2020-02-10T17:12:19Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java", "diffHunk": "@@ -154,6 +154,7 @@ private ReplicableCommandRunner(ReplicableCommand command, Reply reply,\n       @Override\n       public void run() {\n          try {\n+            // TODO can we remove this?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MDE5Mw=="}, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIzMTM1OA==", "bodyText": "+1 to move it.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377231358", "createdAt": "2020-02-10T18:14:45Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java", "diffHunk": "@@ -154,6 +154,7 @@ private ReplicableCommandRunner(ReplicableCommand command, Reply reply,\n       @Override\n       public void run() {\n          try {\n+            // TODO can we remove this?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MDE5Mw=="}, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMjcxODkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/topology/TopologyManagementHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNDowNjozNlrOFnnQfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNDowNjozNlrOFnnQfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MTk4MQ==", "bodyText": "AFAIK, yes. I think can change the methods to receive AbstractTopologyCommand instead of ReplicableCommand.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377081981", "createdAt": "2020-02-10T14:06:36Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/topology/TopologyManagementHelper.java", "diffHunk": "@@ -115,6 +115,7 @@ public void executeOnCoordinatorAsync(Transport transport, ReplicableCommand com\n          if (trace)\n             log.tracef(\"Attempting to execute command on self: %s\", command);\n          try {\n+            // TODO can we remove this as it's always the ConfirmRebalancePhaseCommand?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fa43ee551a03ac077f54e2d0d041785dacae319"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNjU2NzUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/AbstractTopologyCommand.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo1MDozOFrOFoL34g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo0Njo0OVrOFr3BOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4MTg5MA==", "bodyText": "this constructor isn't required. origin will be set on the receiver node.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377681890", "createdAt": "2020-02-11T14:50:38Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/commands/topology/AbstractTopologyCommand.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package org.infinispan.commands.topology;\n+\n+import org.infinispan.commands.GlobalRpcCommand;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.remoting.transport.Address;\n+\n+@Scope(Scopes.NONE)\n+public abstract class AbstractTopologyCommand implements GlobalRpcCommand {\n+\n+   private final byte commandId;\n+\n+   protected transient Address origin;\n+\n+   AbstractTopologyCommand(byte commandId) {\n+      this(commandId, null);\n+   }\n+\n+   AbstractTopologyCommand(byte commandId, Address origin) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf0d3be8c13aa250d6d7e9e1a4a9fc39b914cd0"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczNzgyMQ==", "bodyText": "It is set on the receiver side, however the address is also used for local invocations so we need this in place. I tried removing the origin, however it results in the testsuite hanging.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377737821", "createdAt": "2020-02-11T16:12:35Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/topology/AbstractTopologyCommand.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package org.infinispan.commands.topology;\n+\n+import org.infinispan.commands.GlobalRpcCommand;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.remoting.transport.Address;\n+\n+@Scope(Scopes.NONE)\n+public abstract class AbstractTopologyCommand implements GlobalRpcCommand {\n+\n+   private final byte commandId;\n+\n+   protected transient Address origin;\n+\n+   AbstractTopologyCommand(byte commandId) {\n+      this(commandId, null);\n+   }\n+\n+   AbstractTopologyCommand(byte commandId, Address origin) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4MTg5MA=="}, "originalCommit": {"oid": "acf0d3be8c13aa250d6d7e9e1a4a9fc39b914cd0"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzMTg0Mg==", "bodyText": "ah! I see... the TopologyManagementHelper invokes the command directly. \ud83d\udc4d", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r377831842", "createdAt": "2020-02-11T18:55:15Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/commands/topology/AbstractTopologyCommand.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package org.infinispan.commands.topology;\n+\n+import org.infinispan.commands.GlobalRpcCommand;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.remoting.transport.Address;\n+\n+@Scope(Scopes.NONE)\n+public abstract class AbstractTopologyCommand implements GlobalRpcCommand {\n+\n+   private final byte commandId;\n+\n+   protected transient Address origin;\n+\n+   AbstractTopologyCommand(byte commandId) {\n+      this(commandId, null);\n+   }\n+\n+   AbstractTopologyCommand(byte commandId, Address origin) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4MTg5MA=="}, "originalCommit": {"oid": "acf0d3be8c13aa250d6d7e9e1a4a9fc39b914cd0"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNDUyMQ==", "bodyText": "Ugh, maybe TopologyManagementHelper should be changed instead -- I'll have a look at it later :)", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r381534521", "createdAt": "2020-02-19T20:46:49Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/topology/AbstractTopologyCommand.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package org.infinispan.commands.topology;\n+\n+import org.infinispan.commands.GlobalRpcCommand;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.remoting.transport.Address;\n+\n+@Scope(Scopes.NONE)\n+public abstract class AbstractTopologyCommand implements GlobalRpcCommand {\n+\n+   private final byte commandId;\n+\n+   protected transient Address origin;\n+\n+   AbstractTopologyCommand(byte commandId) {\n+      this(commandId, null);\n+   }\n+\n+   AbstractTopologyCommand(byte commandId, Address origin) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4MTg5MA=="}, "originalCommit": {"oid": "acf0d3be8c13aa250d6d7e9e1a4a9fc39b914cd0"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MjU4MjQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/GlobalRpcCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMTozODoxOVrOFqhdSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMTozODoxOVrOFqhdSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzMjY4MQ==", "bodyText": "@link uses #\nI also suggest adding new lines after . and/or before {@link to avoid splitting links.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r380132681", "createdAt": "2020-02-17T11:38:19Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/GlobalRpcCommand.java", "diffHunk": "@@ -5,8 +5,10 @@\n import org.infinispan.factories.GlobalComponentRegistry;\n \n /**\n- * Commands correspond to specific areas of functionality in the cluster, and can be replicated using the\n- * {@link org.infinispan.remoting.inboundhandler.GlobalInboundInvocationHandler}.\n+ * Commands correspond to specific areas of functionality in the cluster, and can be replicated using the {@link\n+ * org.infinispan.remoting.inboundhandler.GlobalInboundInvocationHandler}. Implementations of this interface should not\n+ * rely on calls to {@link GlobalComponentRegistry::wireDependencies}, as all components should be accessed via the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d798faa40a2aa0eae84e7ef5a50bec28539638f"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTY5NDY4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/ConfirmRebalancePhaseCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToyOTo0OFrOFr4Tiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMTo0ODo1NlrOFsQboA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NTU5NQ==", "bodyText": "You missed TRANSITORY... maybe it's best not to mention the phases here at all.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r381555595", "createdAt": "2020-02-19T21:29:48Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/topology/ConfirmRebalancePhaseCommand.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheTopology;\n+\n+/**\n+ * A member is confirming that it has finished a topology change during rebalance. This confirmation is sent after\n+ * topologies with {@link CacheTopology.Phase#READ_OLD_WRITE_ALL}, {@link CacheTopology.Phase#READ_ALL_WRITE_ALL} and\n+ * {@link CacheTopology.Phase#READ_NEW_WRITE_ALL} rebalance phases are installed, but not after a topology change with", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d798faa40a2aa0eae84e7ef5a50bec28539638f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk1MDg4MA==", "bodyText": "\ud83d\udc4d It was just a copy and paste, so I'll remove the offending bits.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r381950880", "createdAt": "2020-02-20T11:48:56Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/topology/ConfirmRebalancePhaseCommand.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheTopology;\n+\n+/**\n+ * A member is confirming that it has finished a topology change during rebalance. This confirmation is sent after\n+ * topologies with {@link CacheTopology.Phase#READ_OLD_WRITE_ALL}, {@link CacheTopology.Phase#READ_ALL_WRITE_ALL} and\n+ * {@link CacheTopology.Phase#READ_NEW_WRITE_ALL} rebalance phases are installed, but not after a topology change with", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NTU5NQ=="}, "originalCommit": {"oid": "8d798faa40a2aa0eae84e7ef5a50bec28539638f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTczMDI1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/ConsistentHashUpdateCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0MTozNFrOFr4pZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0MTozNFrOFr4pZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2MTE4OQ==", "bodyText": "Should be TopologyUpdateCommand, I've wanted to update that constant's name for a long time.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r381561189", "createdAt": "2020-02-19T21:41:34Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/topology/ConsistentHashUpdateCommand.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.distribution.ch.ConsistentHash;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.partitionhandling.AvailabilityMode;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheTopology;\n+import org.infinispan.topology.PersistentUUID;\n+\n+/**\n+ * Coordinator to member:\n+ * The coordinator is updating the consistent hash.\n+ * Used to signal the end of rebalancing as well.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class ConsistentHashUpdateCommand extends AbstractTopologyCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d798faa40a2aa0eae84e7ef5a50bec28539638f"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTczNzA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/TopologyJoinCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0Mzo0M1rOFr4tdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0Mzo0M1rOFr4tdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2MjIzMQ==", "bodyText": "I'd call it CacheJoinCommand", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r381562231", "createdAt": "2020-02-19T21:43:43Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/topology/TopologyJoinCommand.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheJoinInfo;\n+\n+/**\n+ * A node is requesting to join the cluster.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class TopologyJoinCommand extends AbstractTopologyCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d798faa40a2aa0eae84e7ef5a50bec28539638f"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTc0MTAwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/TopologyLeaveCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0NDo1OVrOFr4v7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0NDo1OVrOFr4v7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2Mjg2Mg==", "bodyText": "And this one CacheLeaveCommand.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r381562862", "createdAt": "2020-02-19T21:44:59Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/topology/TopologyLeaveCommand.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.remoting.transport.Address;\n+\n+/**\n+ * A node is signaling that it wants to leave the cluster.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class TopologyLeaveCommand extends AbstractTopologyCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d798faa40a2aa0eae84e7ef5a50bec28539638f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTgwMzk2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/RebalanceGetPolicyCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMjowNjoxN1rOFr5YEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMjowNjoxN1rOFr5YEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU3MzEzNg==", "bodyText": "This command probably shouldn't exist, and the rebalancing status/policy should be part of the join response.\nIt also looks a lot like RebalanceStatusCommand.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r381573136", "createdAt": "2020-02-19T22:06:17Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/topology/RebalanceGetPolicyCommand.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+\n+/**\n+ * Check whether rebalancing is enabled.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class RebalanceGetPolicyCommand extends AbstractTopologyCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d798faa40a2aa0eae84e7ef5a50bec28539638f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTg0MDI4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/ShutdownCacheCommand.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMjoxODo1MlrOFr5u2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNDowNTo1NFrOFsUkGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU3ODk2OQ==", "bodyText": "You could have a single ShutdownCacheCommand and call either handleShutdownRequest or handleCacheShutdown based on whether the local node was the coordinator.\nI'm not 100% sure it's a a good idea, but I thought I'd mention it :)", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r381578969", "createdAt": "2020-02-19T22:18:52Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/topology/ShutdownCacheCommand.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+\n+/**\n+ * Tell members to shutdown cache.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class ShutdownCacheCommand extends AbstractTopologyCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d798faa40a2aa0eae84e7ef5a50bec28539638f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk0NjczOA==", "bodyText": "IMO having the two distinct commands is much more explicit and will make reading trace logs easier.", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r381946738", "createdAt": "2020-02-20T11:40:08Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/topology/ShutdownCacheCommand.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+\n+/**\n+ * Tell members to shutdown cache.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class ShutdownCacheCommand extends AbstractTopologyCommand {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU3ODk2OQ=="}, "originalCommit": {"oid": "8d798faa40a2aa0eae84e7ef5a50bec28539638f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxODU4Nw==", "bodyText": "Maybe... But I already forgot which command goes to the coordinator and which goes from the coordinator since reading the code yesterday :)", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r382018587", "createdAt": "2020-02-20T14:05:54Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/topology/ShutdownCacheCommand.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.infinispan.commands.topology;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commons.marshall.MarshallUtil;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+\n+/**\n+ * Tell members to shutdown cache.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+public class ShutdownCacheCommand extends AbstractTopologyCommand {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU3ODk2OQ=="}, "originalCommit": {"oid": "8d798faa40a2aa0eae84e7ef5a50bec28539638f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzQzMDI0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/GlobalRpcCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNjoxOTowM1rOFsstgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNjoxOTowM1rOFsstgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNDIwOA==", "bodyText": "\"should\" is not strong enough IMO, I would say\n{@code @Inject} annotations on implementations will be ignored, components must be accessed via the\n{@link GlobalComponentRegistry} parameter of {@link #invokeAsync(GlobalComponentRegistry)}.\n\nAlso please start on a new line ;)", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r382414208", "createdAt": "2020-02-21T06:19:03Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/GlobalRpcCommand.java", "diffHunk": "@@ -5,8 +5,10 @@\n import org.infinispan.factories.GlobalComponentRegistry;\n \n /**\n- * Commands correspond to specific areas of functionality in the cluster, and can be replicated using the\n- * {@link org.infinispan.remoting.inboundhandler.GlobalInboundInvocationHandler}.\n+ * Commands correspond to specific areas of functionality in the cluster, and can be replicated using the {@link\n+ * org.infinispan.remoting.inboundhandler.GlobalInboundInvocationHandler}. Implementations of this interface should not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a510389ed48a51931a7d43669b0a1941b02d821"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzQzMTAyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/commands/topology/AbstractCacheControlCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNjoxOTozMFrOFsst8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNjoxOTozMFrOFsst8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNDMyMA==", "bodyText": "Missing javadoc", "url": "https://github.com/infinispan/infinispan/pull/7849#discussion_r382414320", "createdAt": "2020-02-21T06:19:30Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/commands/topology/AbstractCacheControlCommand.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package org.infinispan.commands.topology;\n+\n+import org.infinispan.commands.GlobalRpcCommand;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.remoting.transport.Address;\n+\n+@Scope(Scopes.NONE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a510389ed48a51931a7d43669b0a1941b02d821"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4561, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}