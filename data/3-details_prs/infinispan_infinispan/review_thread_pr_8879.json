{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1ODM4Njk0", "number": 8879, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0MDoyMlrOFAUSWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjo0NDo1MFrOFAWbgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODc2Njk2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0MDoyMlrOH-izrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0MDoyMlrOH-izrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NDA0Nw==", "bodyText": "We should be able to utilize the segment from the command if it is a single key command. Otherwise we will have to calculate the segment for each command. Sadly multi put doesn't yet have this optimization.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535344047", "createdAt": "2020-12-03T15:40:22Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -134,4 +146,12 @@ private Object handleClearReturn(InvocationContext ctx, ClearCommand rCommand, O\n          return localTx.getModifications().stream();\n       }\n    }\n+\n+   public Stream<?> keysFromMods(Stream<WriteCommand> modifications) {\n+      return modifications\n+            .filter(WriteCommand::isSuccessful)\n+            .filter(BaseBackupInterceptor::backupToRemoteSite)\n+            .flatMap(BaseBackupInterceptor::keyStream)\n+            .filter(this::isWriteOwner);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODc3MTg4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/interceptors/xsite/OptimisticBackupInterceptor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0MTowOFrOH-i2-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODowODo1OFrOH-qJag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NDg4OQ==", "bodyText": "We again calculate the segment for the key here too. Is there a better way we can share the segment down the line?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535344889", "createdAt": "2020-12-03T15:41:08Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/OptimisticBackupInterceptor.java", "diffHunk": "@@ -44,13 +44,13 @@ public Object visitCommitCommand(TxInvocationContext ctx, CommitCommand command)\n \n       return invokeNextThenApply(ctx, command, (rCtx, rCommand, rv) -> {\n          //we need to track the keys only after it is applied in the local node!\n-         iracManager.trackKeysFromTransaction(getModificationsFrom(rCommand), rCommand.getGlobalTransaction());\n+         keysFromMods(getModificationsFrom(rCommand)).forEach(key -> iracManager.trackUpdatedKey(getSegment(key), key, rCommand.getGlobalTransaction()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2NDI5OA==", "bodyText": "probably aggregating the key&segment in some data class.\nyeah, I think it would be possible.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535464298", "createdAt": "2020-12-03T18:08:58Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/OptimisticBackupInterceptor.java", "diffHunk": "@@ -44,13 +44,13 @@ public Object visitCommitCommand(TxInvocationContext ctx, CommitCommand command)\n \n       return invokeNextThenApply(ctx, command, (rCtx, rCommand, rv) -> {\n          //we need to track the keys only after it is applied in the local node!\n-         iracManager.trackKeysFromTransaction(getModificationsFrom(rCommand), rCommand.getGlobalTransaction());\n+         keysFromMods(getModificationsFrom(rCommand)).forEach(key -> iracManager.trackUpdatedKey(getSegment(key), key, rCommand.getGlobalTransaction()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NDg4OQ=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODc3NDMwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/interceptors/xsite/PessimisticBackupInterceptor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0MToyOVrOH-i4aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0MToyOVrOH-i4aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NTI1Nw==", "bodyText": "Same here about segment being recalculated.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535345257", "createdAt": "2020-12-03T15:41:29Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/PessimisticBackupInterceptor.java", "diffHunk": "@@ -40,7 +40,8 @@ public Object visitPrepareCommand(TxInvocationContext ctx, PrepareCommand comman\n \n       return invokeNextThenApply(ctx, command, (rCtx, rCommand, rv) -> {\n          //for async, all nodes need to keep track of the updates keys after it is applied locally.\n-         iracManager.trackKeysFromTransaction(Arrays.stream(rCommand.getModifications()), rCommand.getGlobalTransaction());\n+         keysFromMods(Arrays.stream(rCommand.getModifications()))\n+               .forEach(key -> iracManager.trackUpdatedKey(getSegment(key), key, rCommand.getGlobalTransaction()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODc4MTUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0MjozNFrOH-i9FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODowOToyN1rOH-qK1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NjQ1Mw==", "bodyText": "It seems we can remove backoffSleep now?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535346453", "createdAt": "2020-12-03T15:42:34Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -50,4 +58,12 @@ public void reset() {\n     */\n    void reset();\n \n+   /**\n+    * Same as {@link #backoffSleep()} but it returns a {@link CompletionStage} which is completed after the back-off", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2NDY2MA==", "bodyText": "I'm free to ideas... I can keep it or remove it. it isn't used anymore.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535464660", "createdAt": "2020-12-03T18:09:27Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -50,4 +58,12 @@ public void reset() {\n     */\n    void reset();\n \n+   /**\n+    * Same as {@link #backoffSleep()} but it returns a {@link CompletionStage} which is completed after the back-off", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NjQ1Mw=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODgyNDUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0OToxMFrOH-jYtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODowOTo1MVrOH-qL4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1MzUyNQ==", "bodyText": "I assume the use of thenCompose(this) is to avoid the lambda allocation?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535353525", "createdAt": "2020-12-03T15:49:10Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.util.ExponentialBackOff;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.concurrent.WithinThreadExecutor;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Executes the \"IRAC\" sending task in a single thread.\n+ * <p>\n+ * This executor makes sure no more than one task is running at the same time. Also, it avoids \"queueing\" multiple tasks\n+ * by queuing at most one. This is possible because the task does the same thing: iterator over pending updates and send\n+ * them to the remote site.\n+ * <p>\n+ * In addition, it iteracts with the {@link ExponentialBackOff} to add delays in case of network failures.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracExecutor implements Function<Void, CompletionStage<Void>> {\n+\n+   private static final Log log = LogFactory.getLog(IracExecutor.class);\n+\n+   private final WrappedRunnable runnable;\n+   private volatile CompletableFuture<Void> lastRunnable;\n+   private volatile Executor executor;\n+   private volatile ExponentialBackOff backOff;\n+   final AtomicBoolean hasPendingRunnable;\n+   private volatile boolean backOffEnabled;\n+\n+\n+   public IracExecutor(Supplier<CompletionStage<Void>> runnable) {\n+      this.runnable = new WrappedRunnable(Objects.requireNonNull(runnable));\n+      this.lastRunnable = CompletableFutures.completedNull();\n+      this.executor = new WithinThreadExecutor();\n+      this.hasPendingRunnable = new AtomicBoolean();\n+   }\n+\n+   public void setExecutor(Executor executor) {\n+      this.executor = Objects.requireNonNull(executor);\n+   }\n+\n+   public void setBackOff(ExponentialBackOff backOff) {\n+      this.backOff = Objects.requireNonNull(backOff);\n+   }\n+\n+   /**\n+    * Executes, in a new thread, or queues the task.\n+    */\n+   public void run() {\n+      if (hasPendingRunnable.compareAndSet(false, true)) {\n+         if (backOffEnabled) {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenCompose(this).thenComposeAsync(runnable, executor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2NDkyOQ==", "bodyText": "yes. it adds the backoff completion stage to the chain.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535464929", "createdAt": "2020-12-03T18:09:51Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.util.ExponentialBackOff;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.concurrent.WithinThreadExecutor;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Executes the \"IRAC\" sending task in a single thread.\n+ * <p>\n+ * This executor makes sure no more than one task is running at the same time. Also, it avoids \"queueing\" multiple tasks\n+ * by queuing at most one. This is possible because the task does the same thing: iterator over pending updates and send\n+ * them to the remote site.\n+ * <p>\n+ * In addition, it iteracts with the {@link ExponentialBackOff} to add delays in case of network failures.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracExecutor implements Function<Void, CompletionStage<Void>> {\n+\n+   private static final Log log = LogFactory.getLog(IracExecutor.class);\n+\n+   private final WrappedRunnable runnable;\n+   private volatile CompletableFuture<Void> lastRunnable;\n+   private volatile Executor executor;\n+   private volatile ExponentialBackOff backOff;\n+   final AtomicBoolean hasPendingRunnable;\n+   private volatile boolean backOffEnabled;\n+\n+\n+   public IracExecutor(Supplier<CompletionStage<Void>> runnable) {\n+      this.runnable = new WrappedRunnable(Objects.requireNonNull(runnable));\n+      this.lastRunnable = CompletableFutures.completedNull();\n+      this.executor = new WithinThreadExecutor();\n+      this.hasPendingRunnable = new AtomicBoolean();\n+   }\n+\n+   public void setExecutor(Executor executor) {\n+      this.executor = Objects.requireNonNull(executor);\n+   }\n+\n+   public void setBackOff(ExponentialBackOff backOff) {\n+      this.backOff = Objects.requireNonNull(backOff);\n+   }\n+\n+   /**\n+    * Executes, in a new thread, or queues the task.\n+    */\n+   public void run() {\n+      if (hasPendingRunnable.compareAndSet(false, true)) {\n+         if (backOffEnabled) {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenCompose(this).thenComposeAsync(runnable, executor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1MzUyNQ=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODgzMjExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo1MDoxM1rOH-jdnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDoyNDowNVrOIA5JSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NDc4MA==", "bodyText": "Maybe I am misreading but doesn't this mean you can run another task at the same time if IracExecutor#run is invoked while runnable supplier is being invoked and the stage has not been completed? Or what is the definition of a task in the class javadoc header?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535354780", "createdAt": "2020-12-03T15:50:13Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.util.ExponentialBackOff;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.concurrent.WithinThreadExecutor;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Executes the \"IRAC\" sending task in a single thread.\n+ * <p>\n+ * This executor makes sure no more than one task is running at the same time. Also, it avoids \"queueing\" multiple tasks\n+ * by queuing at most one. This is possible because the task does the same thing: iterator over pending updates and send\n+ * them to the remote site.\n+ * <p>\n+ * In addition, it iteracts with the {@link ExponentialBackOff} to add delays in case of network failures.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracExecutor implements Function<Void, CompletionStage<Void>> {\n+\n+   private static final Log log = LogFactory.getLog(IracExecutor.class);\n+\n+   private final WrappedRunnable runnable;\n+   private volatile CompletableFuture<Void> lastRunnable;\n+   private volatile Executor executor;\n+   private volatile ExponentialBackOff backOff;\n+   final AtomicBoolean hasPendingRunnable;\n+   private volatile boolean backOffEnabled;\n+\n+\n+   public IracExecutor(Supplier<CompletionStage<Void>> runnable) {\n+      this.runnable = new WrappedRunnable(Objects.requireNonNull(runnable));\n+      this.lastRunnable = CompletableFutures.completedNull();\n+      this.executor = new WithinThreadExecutor();\n+      this.hasPendingRunnable = new AtomicBoolean();\n+   }\n+\n+   public void setExecutor(Executor executor) {\n+      this.executor = Objects.requireNonNull(executor);\n+   }\n+\n+   public void setBackOff(ExponentialBackOff backOff) {\n+      this.backOff = Objects.requireNonNull(backOff);\n+   }\n+\n+   /**\n+    * Executes, in a new thread, or queues the task.\n+    */\n+   public void run() {\n+      if (hasPendingRunnable.compareAndSet(false, true)) {\n+         if (backOffEnabled) {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenCompose(this).thenComposeAsync(runnable, executor);\n+         } else {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenComposeAsync(runnable, executor);\n+         }\n+      }\n+   }\n+\n+   public void enableBackOff() {\n+      backOffEnabled = true;\n+   }\n+\n+   public void disableBackOff() {\n+      backOffEnabled = false;\n+      backOff.reset();\n+   }\n+\n+   /**\n+    * Used by {@link CompletableFuture#thenComposeAsync(Function, Executor)}, it adds the {@link ExponentialBackOff}\n+    * delay.\n+    *\n+    * @param unused Unused value.\n+    * @return The {@link CompletionStage} from {@link ExponentialBackOff#asyncBackOff()}.\n+    */\n+   @Override\n+   public CompletionStage<Void> apply(Void unused) {\n+      return backOff.asyncBackOff();\n+   }\n+\n+   private class WrappedRunnable implements Function<Void, CompletionStage<Void>> {\n+      private final Supplier<CompletionStage<Void>> runnable;\n+\n+      private WrappedRunnable(Supplier<CompletionStage<Void>> runnable) {\n+         this.runnable = runnable;\n+      }\n+\n+      /**\n+       * Use by {@link CompletableFuture#thenComposeAsync(Function, Executor)}, executes the task and returns the {@link\n+       * CompletionStage} return by it.\n+       *\n+       * @param unused Unused value.\n+       * @return The {@link CompletionStage} from the task.\n+       */\n+      @Override\n+      public CompletionStage<Void> apply(Void unused) {\n+         hasPendingRunnable.set(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3NTg0OQ==", "bodyText": "The task is \"iterate over all pending keys and send the update to the remote site\" (not sure how to call it or if you have a better name)\nSo, my idea was to keep the chain of \"thenCompose\" smaller a possible and have a single task pending in \"thenCompose\". When hasPendingRunnable is false, a write operation is able to \"queue\" the task. When this task starts executing, it sets it to false and allows the next write operation to queue.\nnot sure If I was clear... it is late and my brain is lagging :/", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535475849", "createdAt": "2020-12-03T18:22:29Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.util.ExponentialBackOff;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.concurrent.WithinThreadExecutor;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Executes the \"IRAC\" sending task in a single thread.\n+ * <p>\n+ * This executor makes sure no more than one task is running at the same time. Also, it avoids \"queueing\" multiple tasks\n+ * by queuing at most one. This is possible because the task does the same thing: iterator over pending updates and send\n+ * them to the remote site.\n+ * <p>\n+ * In addition, it iteracts with the {@link ExponentialBackOff} to add delays in case of network failures.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracExecutor implements Function<Void, CompletionStage<Void>> {\n+\n+   private static final Log log = LogFactory.getLog(IracExecutor.class);\n+\n+   private final WrappedRunnable runnable;\n+   private volatile CompletableFuture<Void> lastRunnable;\n+   private volatile Executor executor;\n+   private volatile ExponentialBackOff backOff;\n+   final AtomicBoolean hasPendingRunnable;\n+   private volatile boolean backOffEnabled;\n+\n+\n+   public IracExecutor(Supplier<CompletionStage<Void>> runnable) {\n+      this.runnable = new WrappedRunnable(Objects.requireNonNull(runnable));\n+      this.lastRunnable = CompletableFutures.completedNull();\n+      this.executor = new WithinThreadExecutor();\n+      this.hasPendingRunnable = new AtomicBoolean();\n+   }\n+\n+   public void setExecutor(Executor executor) {\n+      this.executor = Objects.requireNonNull(executor);\n+   }\n+\n+   public void setBackOff(ExponentialBackOff backOff) {\n+      this.backOff = Objects.requireNonNull(backOff);\n+   }\n+\n+   /**\n+    * Executes, in a new thread, or queues the task.\n+    */\n+   public void run() {\n+      if (hasPendingRunnable.compareAndSet(false, true)) {\n+         if (backOffEnabled) {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenCompose(this).thenComposeAsync(runnable, executor);\n+         } else {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenComposeAsync(runnable, executor);\n+         }\n+      }\n+   }\n+\n+   public void enableBackOff() {\n+      backOffEnabled = true;\n+   }\n+\n+   public void disableBackOff() {\n+      backOffEnabled = false;\n+      backOff.reset();\n+   }\n+\n+   /**\n+    * Used by {@link CompletableFuture#thenComposeAsync(Function, Executor)}, it adds the {@link ExponentialBackOff}\n+    * delay.\n+    *\n+    * @param unused Unused value.\n+    * @return The {@link CompletionStage} from {@link ExponentialBackOff#asyncBackOff()}.\n+    */\n+   @Override\n+   public CompletionStage<Void> apply(Void unused) {\n+      return backOff.asyncBackOff();\n+   }\n+\n+   private class WrappedRunnable implements Function<Void, CompletionStage<Void>> {\n+      private final Supplier<CompletionStage<Void>> runnable;\n+\n+      private WrappedRunnable(Supplier<CompletionStage<Void>> runnable) {\n+         this.runnable = runnable;\n+      }\n+\n+      /**\n+       * Use by {@link CompletableFuture#thenComposeAsync(Function, Executor)}, executes the task and returns the {@link\n+       * CompletionStage} return by it.\n+       *\n+       * @param unused Unused value.\n+       * @return The {@link CompletionStage} from the task.\n+       */\n+      @Override\n+      public CompletionStage<Void> apply(Void unused) {\n+         hasPendingRunnable.set(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NDc4MA=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgwNzE3OQ==", "bodyText": "Okay I see you are enqueuing as a chained stage and only allowing chaining if the most recent chain has started running/completed.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r537807179", "createdAt": "2020-12-07T20:24:05Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.util.ExponentialBackOff;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.concurrent.WithinThreadExecutor;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Executes the \"IRAC\" sending task in a single thread.\n+ * <p>\n+ * This executor makes sure no more than one task is running at the same time. Also, it avoids \"queueing\" multiple tasks\n+ * by queuing at most one. This is possible because the task does the same thing: iterator over pending updates and send\n+ * them to the remote site.\n+ * <p>\n+ * In addition, it iteracts with the {@link ExponentialBackOff} to add delays in case of network failures.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracExecutor implements Function<Void, CompletionStage<Void>> {\n+\n+   private static final Log log = LogFactory.getLog(IracExecutor.class);\n+\n+   private final WrappedRunnable runnable;\n+   private volatile CompletableFuture<Void> lastRunnable;\n+   private volatile Executor executor;\n+   private volatile ExponentialBackOff backOff;\n+   final AtomicBoolean hasPendingRunnable;\n+   private volatile boolean backOffEnabled;\n+\n+\n+   public IracExecutor(Supplier<CompletionStage<Void>> runnable) {\n+      this.runnable = new WrappedRunnable(Objects.requireNonNull(runnable));\n+      this.lastRunnable = CompletableFutures.completedNull();\n+      this.executor = new WithinThreadExecutor();\n+      this.hasPendingRunnable = new AtomicBoolean();\n+   }\n+\n+   public void setExecutor(Executor executor) {\n+      this.executor = Objects.requireNonNull(executor);\n+   }\n+\n+   public void setBackOff(ExponentialBackOff backOff) {\n+      this.backOff = Objects.requireNonNull(backOff);\n+   }\n+\n+   /**\n+    * Executes, in a new thread, or queues the task.\n+    */\n+   public void run() {\n+      if (hasPendingRunnable.compareAndSet(false, true)) {\n+         if (backOffEnabled) {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenCompose(this).thenComposeAsync(runnable, executor);\n+         } else {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenComposeAsync(runnable, executor);\n+         }\n+      }\n+   }\n+\n+   public void enableBackOff() {\n+      backOffEnabled = true;\n+   }\n+\n+   public void disableBackOff() {\n+      backOffEnabled = false;\n+      backOff.reset();\n+   }\n+\n+   /**\n+    * Used by {@link CompletableFuture#thenComposeAsync(Function, Executor)}, it adds the {@link ExponentialBackOff}\n+    * delay.\n+    *\n+    * @param unused Unused value.\n+    * @return The {@link CompletionStage} from {@link ExponentialBackOff#asyncBackOff()}.\n+    */\n+   @Override\n+   public CompletionStage<Void> apply(Void unused) {\n+      return backOff.asyncBackOff();\n+   }\n+\n+   private class WrappedRunnable implements Function<Void, CompletionStage<Void>> {\n+      private final Supplier<CompletionStage<Void>> runnable;\n+\n+      private WrappedRunnable(Supplier<CompletionStage<Void>> runnable) {\n+         this.runnable = runnable;\n+      }\n+\n+      /**\n+       * Use by {@link CompletableFuture#thenComposeAsync(Function, Executor)}, executes the task and returns the {@link\n+       * CompletionStage} return by it.\n+       *\n+       * @param unused Unused value.\n+       * @return The {@link CompletionStage} from the task.\n+       */\n+      @Override\n+      public CompletionStage<Void> apply(Void unused) {\n+         hasPendingRunnable.set(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NDc4MA=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODg3OTgyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/xsite/irac/IracResponseCollector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo1ODo1NFrOH-j6gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODoxNjo0NlrOH-qjCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2MjE3OA==", "bodyText": "This class really reminds me of the AggregateCompletionStage. Is there no way we can use that instead of adding more aggregation logic?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535362178", "createdAt": "2020-12-03T15:58:54Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracResponseCollector.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.BiConsumer;\n+\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.status.DefaultTakeOfflineManager;\n+\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * A response collector for a single key update.\n+ * <p>\n+ * This class extends {@link CompletableFuture}. It is completed when all sites involved in the updated have replied (or\n+ * timed-out). There are 3 possible outcomes enumerated by {@link Result}.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracResponseCollector extends CompletableFuture<IracResponseCollector.Result> implements BiConsumer<Void, Throwable> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3MDg1Ng==", "bodyText": "I kind of copied it. But I needed special logic to merge the values from the remote sites.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535470856", "createdAt": "2020-12-03T18:16:46Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracResponseCollector.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.BiConsumer;\n+\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.status.DefaultTakeOfflineManager;\n+\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * A response collector for a single key update.\n+ * <p>\n+ * This class extends {@link CompletableFuture}. It is completed when all sites involved in the updated have replied (or\n+ * timed-out). There are 3 possible outcomes enumerated by {@link Result}.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracResponseCollector extends CompletableFuture<IracResponseCollector.Result> implements BiConsumer<Void, Throwable> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2MjE3OA=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTExODA4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjo0NDo1MFrOH-mKGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxNjoxODoyNlrOH_X-xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA==", "bodyText": "Can't this be the non blocking executor? Or does something block in DefaultIracManager#run?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535398938", "createdAt": "2020-12-03T16:44:50Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "diffHunk": "@@ -73,115 +69,66 @@\n  * @since 11.0\n  */\n @Scope(Scopes.NAMED_CACHE)\n-public class DefaultIracManager implements IracManager, Runnable {\n+public class DefaultIracManager implements IracManager {\n \n    private static final Log log = LogFactory.getLog(DefaultIracManager.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    @Inject RpcManager rpcManager;\n-   @Inject Configuration config;\n    @Inject TakeOfflineManager takeOfflineManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n    @Inject CommandsFactory commandsFactory;\n    @Inject IracVersionGenerator iracVersionGenerator;\n \n-   private final Map<Object, Object> updatedKeys;\n-   private final Semaphore senderNotifier;\n-   private volatile ExponentialBackOff backOff;\n+   private final Map<Object, State> updatedKeys;\n+   private final Collection<XSiteBackup> asyncBackups;\n+   private final IracExecutor iracExecutor;\n    private volatile boolean hasClear;\n-   private volatile Collection<XSiteBackup> asyncBackups;\n-   private volatile Thread sender;\n-   private volatile boolean running;\n \n-   public DefaultIracManager() {\n+   public DefaultIracManager(Configuration config) {\n       this.updatedKeys = new ConcurrentHashMap<>();\n-      this.senderNotifier = new Semaphore(0);\n-      this.backOff = new ExponentialBackOffImpl();\n+      this.iracExecutor = new IracExecutor(this::run);\n+      this.asyncBackups = asyncBackups(config);\n    }\n \n-   private static Collection<XSiteBackup> asyncBackups(Configuration config, String localSiteName) {\n+   private static Collection<XSiteBackup> asyncBackups(Configuration config) {\n       return config.sites().asyncBackupsStream()\n-            .filter(bc -> !localSiteName.equals(bc.site()))\n             .map(bc -> new XSiteBackup(bc.site(), true, bc.replicationTimeout())) //convert to sync\n             .collect(Collectors.toList());\n    }\n \n-   private static Stream<?> keyStream(WriteCommand command) {\n-      return command.getAffectedKeys().stream();\n-   }\n-\n-   private static boolean backupToRemoteSite(WriteCommand command) {\n-      return !command.hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP);\n-   }\n-\n    private static IntSet newIntSet(Address ignored) {\n       return IntSets.mutableEmptySet();\n    }\n \n+   @Inject\n+   public void inject(@ComponentName(KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR) ScheduledExecutorService executorService,\n+                      @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2Nzk0OQ==", "bodyText": "It peeks the DataContainer & Persistence (if enabled). I didn't want to do a special case for when persistence is disabled :)\n(ps. also, can block in JGroups' Flow Control)", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535467949", "createdAt": "2020-12-03T18:13:25Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "diffHunk": "@@ -73,115 +69,66 @@\n  * @since 11.0\n  */\n @Scope(Scopes.NAMED_CACHE)\n-public class DefaultIracManager implements IracManager, Runnable {\n+public class DefaultIracManager implements IracManager {\n \n    private static final Log log = LogFactory.getLog(DefaultIracManager.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    @Inject RpcManager rpcManager;\n-   @Inject Configuration config;\n    @Inject TakeOfflineManager takeOfflineManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n    @Inject CommandsFactory commandsFactory;\n    @Inject IracVersionGenerator iracVersionGenerator;\n \n-   private final Map<Object, Object> updatedKeys;\n-   private final Semaphore senderNotifier;\n-   private volatile ExponentialBackOff backOff;\n+   private final Map<Object, State> updatedKeys;\n+   private final Collection<XSiteBackup> asyncBackups;\n+   private final IracExecutor iracExecutor;\n    private volatile boolean hasClear;\n-   private volatile Collection<XSiteBackup> asyncBackups;\n-   private volatile Thread sender;\n-   private volatile boolean running;\n \n-   public DefaultIracManager() {\n+   public DefaultIracManager(Configuration config) {\n       this.updatedKeys = new ConcurrentHashMap<>();\n-      this.senderNotifier = new Semaphore(0);\n-      this.backOff = new ExponentialBackOffImpl();\n+      this.iracExecutor = new IracExecutor(this::run);\n+      this.asyncBackups = asyncBackups(config);\n    }\n \n-   private static Collection<XSiteBackup> asyncBackups(Configuration config, String localSiteName) {\n+   private static Collection<XSiteBackup> asyncBackups(Configuration config) {\n       return config.sites().asyncBackupsStream()\n-            .filter(bc -> !localSiteName.equals(bc.site()))\n             .map(bc -> new XSiteBackup(bc.site(), true, bc.replicationTimeout())) //convert to sync\n             .collect(Collectors.toList());\n    }\n \n-   private static Stream<?> keyStream(WriteCommand command) {\n-      return command.getAffectedKeys().stream();\n-   }\n-\n-   private static boolean backupToRemoteSite(WriteCommand command) {\n-      return !command.hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP);\n-   }\n-\n    private static IntSet newIntSet(Address ignored) {\n       return IntSets.mutableEmptySet();\n    }\n \n+   @Inject\n+   public void inject(@ComponentName(KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR) ScheduledExecutorService executorService,\n+                      @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU1MjYxNA==", "bodyText": "The former two are fine (data container peek is non blocking and persistence uses a blocking thread if needed). And sadly JGroups blocking is something that can just happen atm, not much we can do. I would propose making this the non blocking executor though.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535552614", "createdAt": "2020-12-03T20:10:30Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "diffHunk": "@@ -73,115 +69,66 @@\n  * @since 11.0\n  */\n @Scope(Scopes.NAMED_CACHE)\n-public class DefaultIracManager implements IracManager, Runnable {\n+public class DefaultIracManager implements IracManager {\n \n    private static final Log log = LogFactory.getLog(DefaultIracManager.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    @Inject RpcManager rpcManager;\n-   @Inject Configuration config;\n    @Inject TakeOfflineManager takeOfflineManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n    @Inject CommandsFactory commandsFactory;\n    @Inject IracVersionGenerator iracVersionGenerator;\n \n-   private final Map<Object, Object> updatedKeys;\n-   private final Semaphore senderNotifier;\n-   private volatile ExponentialBackOff backOff;\n+   private final Map<Object, State> updatedKeys;\n+   private final Collection<XSiteBackup> asyncBackups;\n+   private final IracExecutor iracExecutor;\n    private volatile boolean hasClear;\n-   private volatile Collection<XSiteBackup> asyncBackups;\n-   private volatile Thread sender;\n-   private volatile boolean running;\n \n-   public DefaultIracManager() {\n+   public DefaultIracManager(Configuration config) {\n       this.updatedKeys = new ConcurrentHashMap<>();\n-      this.senderNotifier = new Semaphore(0);\n-      this.backOff = new ExponentialBackOffImpl();\n+      this.iracExecutor = new IracExecutor(this::run);\n+      this.asyncBackups = asyncBackups(config);\n    }\n \n-   private static Collection<XSiteBackup> asyncBackups(Configuration config, String localSiteName) {\n+   private static Collection<XSiteBackup> asyncBackups(Configuration config) {\n       return config.sites().asyncBackupsStream()\n-            .filter(bc -> !localSiteName.equals(bc.site()))\n             .map(bc -> new XSiteBackup(bc.site(), true, bc.replicationTimeout())) //convert to sync\n             .collect(Collectors.toList());\n    }\n \n-   private static Stream<?> keyStream(WriteCommand command) {\n-      return command.getAffectedKeys().stream();\n-   }\n-\n-   private static boolean backupToRemoteSite(WriteCommand command) {\n-      return !command.hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP);\n-   }\n-\n    private static IntSet newIntSet(Address ignored) {\n       return IntSets.mutableEmptySet();\n    }\n \n+   @Inject\n+   public void inject(@ComponentName(KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR) ScheduledExecutorService executorService,\n+                      @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5ODYzOQ==", "bodyText": "If we have persistence, the non-blocking thread will iterate over all keys and trigger a persistence.load() to send the key/value to the remote site.\nWouldn't it spawn a new blocking thread for each key? if it would, would it be ok?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r536198639", "createdAt": "2020-12-04T15:54:02Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "diffHunk": "@@ -73,115 +69,66 @@\n  * @since 11.0\n  */\n @Scope(Scopes.NAMED_CACHE)\n-public class DefaultIracManager implements IracManager, Runnable {\n+public class DefaultIracManager implements IracManager {\n \n    private static final Log log = LogFactory.getLog(DefaultIracManager.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    @Inject RpcManager rpcManager;\n-   @Inject Configuration config;\n    @Inject TakeOfflineManager takeOfflineManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n    @Inject CommandsFactory commandsFactory;\n    @Inject IracVersionGenerator iracVersionGenerator;\n \n-   private final Map<Object, Object> updatedKeys;\n-   private final Semaphore senderNotifier;\n-   private volatile ExponentialBackOff backOff;\n+   private final Map<Object, State> updatedKeys;\n+   private final Collection<XSiteBackup> asyncBackups;\n+   private final IracExecutor iracExecutor;\n    private volatile boolean hasClear;\n-   private volatile Collection<XSiteBackup> asyncBackups;\n-   private volatile Thread sender;\n-   private volatile boolean running;\n \n-   public DefaultIracManager() {\n+   public DefaultIracManager(Configuration config) {\n       this.updatedKeys = new ConcurrentHashMap<>();\n-      this.senderNotifier = new Semaphore(0);\n-      this.backOff = new ExponentialBackOffImpl();\n+      this.iracExecutor = new IracExecutor(this::run);\n+      this.asyncBackups = asyncBackups(config);\n    }\n \n-   private static Collection<XSiteBackup> asyncBackups(Configuration config, String localSiteName) {\n+   private static Collection<XSiteBackup> asyncBackups(Configuration config) {\n       return config.sites().asyncBackupsStream()\n-            .filter(bc -> !localSiteName.equals(bc.site()))\n             .map(bc -> new XSiteBackup(bc.site(), true, bc.replicationTimeout())) //convert to sync\n             .collect(Collectors.toList());\n    }\n \n-   private static Stream<?> keyStream(WriteCommand command) {\n-      return command.getAffectedKeys().stream();\n-   }\n-\n-   private static boolean backupToRemoteSite(WriteCommand command) {\n-      return !command.hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP);\n-   }\n-\n    private static IntSet newIntSet(Address ignored) {\n       return IntSets.mutableEmptySet();\n    }\n \n+   @Inject\n+   public void inject(@ComponentName(KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR) ScheduledExecutorService executorService,\n+                      @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5OTcwOA==", "bodyText": "Oh you are manually iterating? And not using keySet or Publisher or anything?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r536199708", "createdAt": "2020-12-04T15:55:37Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "diffHunk": "@@ -73,115 +69,66 @@\n  * @since 11.0\n  */\n @Scope(Scopes.NAMED_CACHE)\n-public class DefaultIracManager implements IracManager, Runnable {\n+public class DefaultIracManager implements IracManager {\n \n    private static final Log log = LogFactory.getLog(DefaultIracManager.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    @Inject RpcManager rpcManager;\n-   @Inject Configuration config;\n    @Inject TakeOfflineManager takeOfflineManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n    @Inject CommandsFactory commandsFactory;\n    @Inject IracVersionGenerator iracVersionGenerator;\n \n-   private final Map<Object, Object> updatedKeys;\n-   private final Semaphore senderNotifier;\n-   private volatile ExponentialBackOff backOff;\n+   private final Map<Object, State> updatedKeys;\n+   private final Collection<XSiteBackup> asyncBackups;\n+   private final IracExecutor iracExecutor;\n    private volatile boolean hasClear;\n-   private volatile Collection<XSiteBackup> asyncBackups;\n-   private volatile Thread sender;\n-   private volatile boolean running;\n \n-   public DefaultIracManager() {\n+   public DefaultIracManager(Configuration config) {\n       this.updatedKeys = new ConcurrentHashMap<>();\n-      this.senderNotifier = new Semaphore(0);\n-      this.backOff = new ExponentialBackOffImpl();\n+      this.iracExecutor = new IracExecutor(this::run);\n+      this.asyncBackups = asyncBackups(config);\n    }\n \n-   private static Collection<XSiteBackup> asyncBackups(Configuration config, String localSiteName) {\n+   private static Collection<XSiteBackup> asyncBackups(Configuration config) {\n       return config.sites().asyncBackupsStream()\n-            .filter(bc -> !localSiteName.equals(bc.site()))\n             .map(bc -> new XSiteBackup(bc.site(), true, bc.replicationTimeout())) //convert to sync\n             .collect(Collectors.toList());\n    }\n \n-   private static Stream<?> keyStream(WriteCommand command) {\n-      return command.getAffectedKeys().stream();\n-   }\n-\n-   private static boolean backupToRemoteSite(WriteCommand command) {\n-      return !command.hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP);\n-   }\n-\n    private static IntSet newIntSet(Address ignored) {\n       return IntSets.mutableEmptySet();\n    }\n \n+   @Inject\n+   public void inject(@ComponentName(KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR) ScheduledExecutorService executorService,\n+                      @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIxNTIzNw==", "bodyText": "It is a ConcurrentHashMap. It contains the keys changes.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r536215237", "createdAt": "2020-12-04T16:18:26Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "diffHunk": "@@ -73,115 +69,66 @@\n  * @since 11.0\n  */\n @Scope(Scopes.NAMED_CACHE)\n-public class DefaultIracManager implements IracManager, Runnable {\n+public class DefaultIracManager implements IracManager {\n \n    private static final Log log = LogFactory.getLog(DefaultIracManager.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    @Inject RpcManager rpcManager;\n-   @Inject Configuration config;\n    @Inject TakeOfflineManager takeOfflineManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n    @Inject CommandsFactory commandsFactory;\n    @Inject IracVersionGenerator iracVersionGenerator;\n \n-   private final Map<Object, Object> updatedKeys;\n-   private final Semaphore senderNotifier;\n-   private volatile ExponentialBackOff backOff;\n+   private final Map<Object, State> updatedKeys;\n+   private final Collection<XSiteBackup> asyncBackups;\n+   private final IracExecutor iracExecutor;\n    private volatile boolean hasClear;\n-   private volatile Collection<XSiteBackup> asyncBackups;\n-   private volatile Thread sender;\n-   private volatile boolean running;\n \n-   public DefaultIracManager() {\n+   public DefaultIracManager(Configuration config) {\n       this.updatedKeys = new ConcurrentHashMap<>();\n-      this.senderNotifier = new Semaphore(0);\n-      this.backOff = new ExponentialBackOffImpl();\n+      this.iracExecutor = new IracExecutor(this::run);\n+      this.asyncBackups = asyncBackups(config);\n    }\n \n-   private static Collection<XSiteBackup> asyncBackups(Configuration config, String localSiteName) {\n+   private static Collection<XSiteBackup> asyncBackups(Configuration config) {\n       return config.sites().asyncBackupsStream()\n-            .filter(bc -> !localSiteName.equals(bc.site()))\n             .map(bc -> new XSiteBackup(bc.site(), true, bc.replicationTimeout())) //convert to sync\n             .collect(Collectors.toList());\n    }\n \n-   private static Stream<?> keyStream(WriteCommand command) {\n-      return command.getAffectedKeys().stream();\n-   }\n-\n-   private static boolean backupToRemoteSite(WriteCommand command) {\n-      return !command.hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP);\n-   }\n-\n    private static IntSet newIntSet(Address ignored) {\n       return IntSets.mutableEmptySet();\n    }\n \n+   @Inject\n+   public void inject(@ComponentName(KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR) ScheduledExecutorService executorService,\n+                      @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA=="}, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3800, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}