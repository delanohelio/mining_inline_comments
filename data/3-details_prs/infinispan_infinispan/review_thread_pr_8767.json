{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwODE3MDgz", "number": 8767, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxMDo0NzowM1rOExJ1nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoyNTo0MVrOE22EsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTc2ODYxOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/ProtocolVersion.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxMDo0NzowM1rOHnIrJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjoxMzo1N1rOHu0VaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5ODYzMA==", "bodyText": "aren't we giving up on protocol versions? I thought we no longer increment versions and just add new operations (and keep the old ones unchanged)", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r510798630", "createdAt": "2020-10-23T10:47:03Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/ProtocolVersion.java", "diffHunk": "@@ -35,10 +36,11 @@\n    PROTOCOL_VERSION_28(2, 8, new Codec28()),\n    PROTOCOL_VERSION_29(2, 9, new Codec29()),\n    PROTOCOL_VERSION_30(3, 0, new Codec30()),\n+   PROTOCOL_VERSION_31(3, 1, new Codec31()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e7444f5eb4688719701072873d3014978818b6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NTU3MQ==", "bodyText": "Oh, I wasn't aware. Unfortunately, this changes an existing operation by adding a new field. So I am not sure how that works. Do we have versioned operations then?", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r510975571", "createdAt": "2020-10-23T15:44:37Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/ProtocolVersion.java", "diffHunk": "@@ -35,10 +36,11 @@\n    PROTOCOL_VERSION_28(2, 8, new Codec28()),\n    PROTOCOL_VERSION_29(2, 9, new Codec29()),\n    PROTOCOL_VERSION_30(3, 0, new Codec30()),\n+   PROTOCOL_VERSION_31(3, 1, new Codec31()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5ODYzMA=="}, "originalCommit": {"oid": "92e7444f5eb4688719701072873d3014978818b6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNTUxOA==", "bodyText": "I hope I'm not mistaken...\njust create a new operation: https://github.com/infinispan/infinispan/blob/master/server/hotrod/src/main/resources/hotrod.gr#L324", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r511025518", "createdAt": "2020-10-23T17:14:15Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/ProtocolVersion.java", "diffHunk": "@@ -35,10 +36,11 @@\n    PROTOCOL_VERSION_28(2, 8, new Codec28()),\n    PROTOCOL_VERSION_29(2, 9, new Codec29()),\n    PROTOCOL_VERSION_30(3, 0, new Codec30()),\n+   PROTOCOL_VERSION_31(3, 1, new Codec31()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5ODYzMA=="}, "originalCommit": {"oid": "92e7444f5eb4688719701072873d3014978818b6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0ODIyNQ==", "bodyText": "I had originally commented that I was fine with this, but the more I think about it the more I believe this deserves its own operation unless we are going to have bloom filters for listeners in general", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r518748225", "createdAt": "2020-11-06T13:24:33Z", "author": {"login": "tristantarrant"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/ProtocolVersion.java", "diffHunk": "@@ -35,10 +36,11 @@\n    PROTOCOL_VERSION_28(2, 8, new Codec28()),\n    PROTOCOL_VERSION_29(2, 9, new Codec29()),\n    PROTOCOL_VERSION_30(3, 0, new Codec30()),\n+   PROTOCOL_VERSION_31(3, 1, new Codec31()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5ODYzMA=="}, "originalCommit": {"oid": "92e7444f5eb4688719701072873d3014978818b6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg0MzEyOA==", "bodyText": "Sure, I can do that. I had debated about a different operation since we don't need the filter, converter, or include state.", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r518843128", "createdAt": "2020-11-06T15:56:01Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/ProtocolVersion.java", "diffHunk": "@@ -35,10 +36,11 @@\n    PROTOCOL_VERSION_28(2, 8, new Codec28()),\n    PROTOCOL_VERSION_29(2, 9, new Codec29()),\n    PROTOCOL_VERSION_30(3, 0, new Codec30()),\n+   PROTOCOL_VERSION_31(3, 1, new Codec31()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5ODYzMA=="}, "originalCommit": {"oid": "92e7444f5eb4688719701072873d3014978818b6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1Mzk5Mw==", "bodyText": "Ok, please do that then.", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r518853993", "createdAt": "2020-11-06T16:13:57Z", "author": {"login": "tristantarrant"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/ProtocolVersion.java", "diffHunk": "@@ -35,10 +36,11 @@\n    PROTOCOL_VERSION_28(2, 8, new Codec28()),\n    PROTOCOL_VERSION_29(2, 9, new Codec29()),\n    PROTOCOL_VERSION_30(3, 0, new Codec30()),\n+   PROTOCOL_VERSION_31(3, 1, new Codec31()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc5ODYzMA=="}, "originalCommit": {"oid": "92e7444f5eb4688719701072873d3014978818b6"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTI3MjExOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/configuration/NearCacheConfigurationBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNTo0OToyNVrOHv1F6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjo1MDozOVrOHv3_Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkxNDk4Nw==", "bodyText": "is maxEntries==0 a valid value?", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519914987", "createdAt": "2020-11-09T15:49:25Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/configuration/NearCacheConfigurationBuilder.java", "diffHunk": "@@ -71,19 +83,25 @@ public NearCacheConfigurationBuilder cacheNamePattern(Pattern pattern) {\n \n    @Override\n    public void validate() {\n-      if (mode.enabled() && maxEntries == null)\n-         throw HOTROD.nearCacheMaxEntriesUndefined();\n+      if (mode.enabled()) {\n+         if (maxEntries == null) {\n+            throw HOTROD.nearCacheMaxEntriesUndefined();\n+         } else if (maxEntries < 0 && bloomFilter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2MjQzNA==", "bodyText": "Yes, 0 just means unlimited.", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519962434", "createdAt": "2020-11-09T16:50:39Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/configuration/NearCacheConfigurationBuilder.java", "diffHunk": "@@ -71,19 +83,25 @@ public NearCacheConfigurationBuilder cacheNamePattern(Pattern pattern) {\n \n    @Override\n    public void validate() {\n-      if (mode.enabled() && maxEntries == null)\n-         throw HOTROD.nearCacheMaxEntriesUndefined();\n+      if (mode.enabled()) {\n+         if (maxEntries == null) {\n+            throw HOTROD.nearCacheMaxEntriesUndefined();\n+         } else if (maxEntries < 0 && bloomFilter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkxNDk4Nw=="}, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTMxNDUzOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/counter/impl/NotificationManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNTo1NzozNlrOHv1gHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzoxNjozMVrOHv5Lgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkyMTY5Mg==", "bodyText": "it is not clear to me where the SocketAddress is required.\nI noticed the signature change in org.infinispan.client.hotrod.event.impl.EventDispatcher#executeFailover() but I've never found any invocation that uses the SocketAddress (neither the Short for that matter... it could be Void)", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519921692", "createdAt": "2020-11-09T15:57:36Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/counter/impl/NotificationManager.java", "diffHunk": "@@ -108,13 +108,13 @@ private void removeListener(String counterName, HandleImpl<?> handle) {\n       });\n    }\n \n-   private CompletableFuture<Short> failover() {\n+   private CompletableFuture<SocketAddress> failover() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk4MTk1NQ==", "bodyText": "Sure. I think originally the intent was so we could know what socket it failed over to for use with sending new requests for get. Having it as SocketAddress does avoid some allocations during failover, but I guess making it void is fine too.\nhttps://github.com/infinispan/infinispan/pull/8767/files#diff-550652eec0d6b5bc9b6e55f502c4ad4e4cba85328b35707f1be58372459559d2R139", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519981955", "createdAt": "2020-11-09T17:16:31Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/counter/impl/NotificationManager.java", "diffHunk": "@@ -108,13 +108,13 @@ private void removeListener(String counterName, HandleImpl<?> handle) {\n       });\n    }\n \n-   private CompletableFuture<Short> failover() {\n+   private CompletableFuture<SocketAddress> failover() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkyMTY5Mg=="}, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTM2Nzc1OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/InvalidatedNearRemoteCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjowOToxN1rOHv2BPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjowOToxN1rOHv2BPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMDE3Mg==", "bodyText": "typo\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           // cache values upon a retry as we can't guarantee the bloom filter is updated on the serevr properly\n          \n          \n            \n                           // cache values upon a retry as we can't guarantee the bloom filter is updated on the server properly", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519930172", "createdAt": "2020-11-09T16:09:17Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/InvalidatedNearRemoteCache.java", "diffHunk": "@@ -42,21 +64,47 @@\n       return value.thenApply(v -> v != null ? v.getValue() : null);\n    }\n \n+   private int getCurrentVersion() {\n+      if (bloomFilterUpdateVersion != null) {\n+         return bloomFilterUpdateVersion.get();\n+      }\n+      return 0;\n+   }\n+\n    @Override\n    public CompletableFuture<MetadataValue<V>> getWithMetadataAsync(K key) {\n       MetadataValue<V> nearValue = nearcache.get(key);\n       if (nearValue == null) {\n          clientStatistics.incrementNearCacheMisses();\n-         CompletableFuture<MetadataValue<V>> remoteValue = super.getWithMetadataAsync(key);\n+         int prevVersion = getCurrentVersion();\n+         RetryAwareCompletionStage<MetadataValue<V>> remoteValue = super.getWithMetadataAsync(key, listenerAddress);\n          return remoteValue.thenApply(v -> {\n+            // We cannot cache the value if a retry was required - which means we did not talk to the listener node\n             if (v != null) {\n-               nearcache.putIfAbsent(key, v);\n-               if (v.getMaxIdle() > 0) {\n-                  HOTROD.nearCacheMaxIdleUnsupported();\n+               // If previous version is odd we can't cache as that means it was started during\n+               // a bloom filter update. We also can't cache if the new version doesn't match the prior\n+               // as it overlapped a bloom update.\n+               if ((prevVersion & 1) == 1 || prevVersion != getCurrentVersion()) {\n+                  if (trace) {\n+                     log.tracef(\"Unable to cache returned value for key %s as operation was performed during a\" +\n+                           \" bloom filter update\");\n+                  }\n+               }\n+               // Having a listener address means it has a bloom filter. When we have a bloom filter we cannot\n+               // cache values upon a retry as we can't guarantee the bloom filter is updated on the serevr properly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTM4NzQ0OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AddBloomNearCacheClientListenerOperation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoxMzoyN1rOHv2NIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoxMzoyN1rOHv2NIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMzIxNw==", "bodyText": "unused", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519933217", "createdAt": "2020-11-09T16:13:27Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AddBloomNearCacheClientListenerOperation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package org.infinispan.client.hotrod.impl.operations;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.DataFormat;\n+import org.infinispan.client.hotrod.RemoteCacheManager;\n+import org.infinispan.client.hotrod.annotation.ClientListener;\n+import org.infinispan.client.hotrod.configuration.Configuration;\n+import org.infinispan.client.hotrod.event.impl.ClientEventDispatcher;\n+import org.infinispan.client.hotrod.event.impl.ClientListenerNotifier;\n+import org.infinispan.client.hotrod.impl.InternalRemoteCache;\n+import org.infinispan.client.hotrod.impl.protocol.Codec;\n+import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;\n+import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;\n+import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+/**\n+ * @author Galder Zamarre\u00f1o\n+ */\n+public class AddBloomNearCacheClientListenerOperation extends ClientListenerOperation {\n+\n+   private final int bloomFilterBits;\n+   private final InternalRemoteCache<?, ?> remoteCache;\n+\n+   protected AddBloomNearCacheClientListenerOperation(Codec codec, ChannelFactory channelFactory,\n+                                                      String cacheName, AtomicInteger topologyId, int flags, Configuration cfg,\n+                                                      ClientListenerNotifier listenerNotifier, Object listener,\n+                                                      DataFormat dataFormat,\n+                                                      int bloomFilterBits, InternalRemoteCache<?, ?> remoteCache) {\n+      this(codec, channelFactory, cacheName, topologyId, flags, cfg, generateListenerId(),\n+            listenerNotifier, listener, dataFormat, bloomFilterBits,\n+            remoteCache);\n+   }\n+\n+   private AddBloomNearCacheClientListenerOperation(Codec codec, ChannelFactory channelFactory,\n+                                                    String cacheName, AtomicInteger topologyId, int flags, Configuration cfg,\n+                                                    byte[] listenerId, ClientListenerNotifier listenerNotifier, Object listener,\n+                                                    DataFormat dataFormat,\n+                                                    int bloomFilterBits, InternalRemoteCache<?, ?> remoteCache) {\n+      super(ADD_BLOOM_FILTER_NEAR_CACHE_LISTENER_REQUEST, ADD_BLOOM_FILTER_NEAR_CACHE_LISTENER_RESPONSE, codec, channelFactory,\n+            RemoteCacheManager.cacheNameBytes(cacheName), topologyId, flags, cfg, listenerId, dataFormat, listener,\n+            cacheName, listenerNotifier);\n+      this.bloomFilterBits = bloomFilterBits;\n+      this.remoteCache = remoteCache;\n+   }\n+\n+   public AddBloomNearCacheClientListenerOperation copy() {\n+      return new AddBloomNearCacheClientListenerOperation(codec, channelFactory, cacheNameString, header.topologyId(), flags, cfg,\n+            listenerId, listenerNotifier, listener, dataFormat,\n+            bloomFilterBits, remoteCache);\n+   }\n+\n+   @Override\n+   protected void actualExecute(Channel channel) {\n+      ClientListener clientListener = extractClientListener();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTM5NTAzOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ClientListenerOperation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoxNTowN1rOHv2R9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoxNTowN1rOHv2R9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzNDQ1Mg==", "bodyText": "unused", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519934452", "createdAt": "2020-11-09T16:15:07Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ClientListenerOperation.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.infinispan.client.hotrod.impl.operations;\n+\n+import static org.infinispan.client.hotrod.logging.Log.HOTROD;\n+\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.DataFormat;\n+import org.infinispan.client.hotrod.annotation.ClientListener;\n+import org.infinispan.client.hotrod.configuration.Configuration;\n+import org.infinispan.client.hotrod.event.impl.ClientListenerNotifier;\n+import org.infinispan.client.hotrod.impl.protocol.Codec;\n+import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;\n+import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;\n+import org.infinispan.client.hotrod.impl.transport.netty.ChannelRecord;\n+import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;\n+import org.infinispan.commons.util.ReflectionUtil;\n+import org.infinispan.commons.util.Util;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+\n+public abstract class ClientListenerOperation extends RetryOnFailureOperation<SocketAddress> {\n+   public final byte[] listenerId;\n+   public final Object listener;\n+   protected final String cacheNameString;\n+   protected final ClientListenerNotifier listenerNotifier;\n+\n+   // Holds which address we are currently executing the operation on\n+   protected SocketAddress address;\n+\n+   protected ClientListenerOperation(short requestCode, short responseCode, Codec codec, ChannelFactory channelFactory,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTQxNTQ0OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec20.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoxOTozN1rOHv2ecQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzowOTozOVrOHv45GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzNzY0OQ==", "bodyText": "I would rather disable the bloom filter in org.infinispan.client.hotrod.RemoteCacheManager#createRemoteCache(java.lang.String) since you have access to the version than add a new method to the codec.", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519937649", "createdAt": "2020-11-09T16:19:37Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec20.java", "diffHunk": "@@ -87,6 +87,13 @@ public void writeExpirationParams(ByteBuf buf, long lifespan, TimeUnit lifespanT\n       ByteBufUtil.writeVInt(buf, maxIdleSeconds);\n    }\n \n+   @Override\n+   public void writeBloomFilter(ByteBuf buf, int bloomFilterBits) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3NzI0MQ==", "bodyText": "I personally prefer to keep versioned stuff in the Codec. That is what we have been doing recently at least. It ends up being a single place for version specific stuff, to me at least.", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519977241", "createdAt": "2020-11-09T17:09:39Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec20.java", "diffHunk": "@@ -87,6 +87,13 @@ public void writeExpirationParams(ByteBuf buf, long lifespan, TimeUnit lifespanT\n       ByteBufUtil.writeVInt(buf, maxIdleSeconds);\n    }\n \n+   @Override\n+   public void writeBloomFilter(ByteBuf buf, int bloomFilterBits) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzNzY0OQ=="}, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTQzNzI3OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/near/NearCache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoyNDoxMVrOHv2rpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzoxMDowNVrOHv46aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0MTAzMA==", "bodyText": "nit: key's iterator would be enough.", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519941030", "createdAt": "2020-11-09T16:24:11Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/near/NearCache.java", "diffHunk": "@@ -1,13 +1,15 @@\n package org.infinispan.client.hotrod.near;\n \n+import java.util.Map;\n+\n import org.infinispan.client.hotrod.MetadataValue;\n \n /**\n  * Near cache contract.\n  *\n  * @since 7.1\n  */\n-public interface NearCache<K, V> {\n+public interface NearCache<K, V> extends Iterable<Map.Entry<K, MetadataValue<V>>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3NzU3OQ==", "bodyText": "Yeah, but I feel this is more flexible.", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519977579", "createdAt": "2020-11-09T17:10:05Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/near/NearCache.java", "diffHunk": "@@ -1,13 +1,15 @@\n package org.infinispan.client.hotrod.near;\n \n+import java.util.Map;\n+\n import org.infinispan.client.hotrod.MetadataValue;\n \n /**\n  * Near cache contract.\n  *\n  * @since 7.1\n  */\n-public interface NearCache<K, V> {\n+public interface NearCache<K, V> extends Iterable<Map.Entry<K, MetadataValue<V>>> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0MTAzMA=="}, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTQ0NDk3OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/near/NearCacheService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjoyNTo0MVrOHv2wZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzoxMTo0MlrOHv4-nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0MjI0NQ==", "bodyText": "could be cached in the constructor?", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519942245", "createdAt": "2020-11-09T16:25:41Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/near/NearCacheService.java", "diffHunk": "@@ -28,26 +38,62 @@\n \n    private final NearCacheConfiguration config;\n    private final ClientListenerNotifier listenerNotifier;\n+   private final AtomicInteger nearCacheRemovals = new AtomicInteger();\n    private Object listener;\n    private byte[] listenerId;\n    private NearCache<K, V> cache;\n    private Runnable invalidationCallback;\n+   private int bloomFilterBits = -1;\n+   private InternalRemoteCache<K, V> remote;\n+\n+   private SocketAddress listenerAddress;\n \n    protected NearCacheService(NearCacheConfiguration config, ClientListenerNotifier listenerNotifier) {\n       this.config = config;\n       this.listenerNotifier = listenerNotifier;\n    }\n \n-   public void start(RemoteCache<K, V> remote) {\n+   public SocketAddress start(InternalRemoteCache<K, V> remote) {\n       if (cache == null) {\n          // Create near cache\n-         cache = createNearCache(config);\n+         cache = createNearCache(config, this::entryRemovedFromNearCache);\n          // Add a listener that updates the near cache\n          listener = new InvalidatedNearCacheListener<>(this);\n-         remote.addClientListener(listener);\n+         int maxEntries = config.maxEntries();\n+         if (maxEntries > 0 && config.bloomFilter()) {\n+            bloomFilterBits = determineBloomFilterBits(maxEntries);\n+            listenerAddress = remote.addNearCacheListener(listener, bloomFilterBits);\n+         } else {\n+            remote.addClientListener(listener);\n+         }\n          // Get the listener ID for faster listener connected lookups\n          listenerId = listenerNotifier.findListenerId(listener);\n       }\n+      this.remote = remote;\n+      return listenerAddress;\n+   }\n+\n+   private static int determineBloomFilterBits(int maxEntries) {\n+      int bloomFilterBitScaler = Integer.parseInt(System.getProperty(\"infinispan.bloom-filter.bit-multiplier\", \"4\"));\n+      return maxEntries * bloomFilterBitScaler;\n+   }\n+\n+   void entryRemovedFromNearCache(K key, MetadataValue<V> value) {\n+      // We want to scale the update frequency of the bloom filter to be based on the number of max entries\n+      // This number along with default values of 3 hash algorithms and 4x bit size we end up with\n+      // between 14.689 and 16.573 percent hits per entry.\n+      int updateThreshold = config.maxEntries() / 16 + 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3ODM2OA==", "bodyText": "Okay", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519978368", "createdAt": "2020-11-09T17:11:16Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/near/NearCacheService.java", "diffHunk": "@@ -28,26 +38,62 @@\n \n    private final NearCacheConfiguration config;\n    private final ClientListenerNotifier listenerNotifier;\n+   private final AtomicInteger nearCacheRemovals = new AtomicInteger();\n    private Object listener;\n    private byte[] listenerId;\n    private NearCache<K, V> cache;\n    private Runnable invalidationCallback;\n+   private int bloomFilterBits = -1;\n+   private InternalRemoteCache<K, V> remote;\n+\n+   private SocketAddress listenerAddress;\n \n    protected NearCacheService(NearCacheConfiguration config, ClientListenerNotifier listenerNotifier) {\n       this.config = config;\n       this.listenerNotifier = listenerNotifier;\n    }\n \n-   public void start(RemoteCache<K, V> remote) {\n+   public SocketAddress start(InternalRemoteCache<K, V> remote) {\n       if (cache == null) {\n          // Create near cache\n-         cache = createNearCache(config);\n+         cache = createNearCache(config, this::entryRemovedFromNearCache);\n          // Add a listener that updates the near cache\n          listener = new InvalidatedNearCacheListener<>(this);\n-         remote.addClientListener(listener);\n+         int maxEntries = config.maxEntries();\n+         if (maxEntries > 0 && config.bloomFilter()) {\n+            bloomFilterBits = determineBloomFilterBits(maxEntries);\n+            listenerAddress = remote.addNearCacheListener(listener, bloomFilterBits);\n+         } else {\n+            remote.addClientListener(listener);\n+         }\n          // Get the listener ID for faster listener connected lookups\n          listenerId = listenerNotifier.findListenerId(listener);\n       }\n+      this.remote = remote;\n+      return listenerAddress;\n+   }\n+\n+   private static int determineBloomFilterBits(int maxEntries) {\n+      int bloomFilterBitScaler = Integer.parseInt(System.getProperty(\"infinispan.bloom-filter.bit-multiplier\", \"4\"));\n+      return maxEntries * bloomFilterBitScaler;\n+   }\n+\n+   void entryRemovedFromNearCache(K key, MetadataValue<V> value) {\n+      // We want to scale the update frequency of the bloom filter to be based on the number of max entries\n+      // This number along with default values of 3 hash algorithms and 4x bit size we end up with\n+      // between 14.689 and 16.573 percent hits per entry.\n+      int updateThreshold = config.maxEntries() / 16 + 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0MjI0NQ=="}, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3ODY1Mw==", "bodyText": "Oh and actually has to be cached in start :)", "url": "https://github.com/infinispan/infinispan/pull/8767#discussion_r519978653", "createdAt": "2020-11-09T17:11:42Z", "author": {"login": "wburns"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/near/NearCacheService.java", "diffHunk": "@@ -28,26 +38,62 @@\n \n    private final NearCacheConfiguration config;\n    private final ClientListenerNotifier listenerNotifier;\n+   private final AtomicInteger nearCacheRemovals = new AtomicInteger();\n    private Object listener;\n    private byte[] listenerId;\n    private NearCache<K, V> cache;\n    private Runnable invalidationCallback;\n+   private int bloomFilterBits = -1;\n+   private InternalRemoteCache<K, V> remote;\n+\n+   private SocketAddress listenerAddress;\n \n    protected NearCacheService(NearCacheConfiguration config, ClientListenerNotifier listenerNotifier) {\n       this.config = config;\n       this.listenerNotifier = listenerNotifier;\n    }\n \n-   public void start(RemoteCache<K, V> remote) {\n+   public SocketAddress start(InternalRemoteCache<K, V> remote) {\n       if (cache == null) {\n          // Create near cache\n-         cache = createNearCache(config);\n+         cache = createNearCache(config, this::entryRemovedFromNearCache);\n          // Add a listener that updates the near cache\n          listener = new InvalidatedNearCacheListener<>(this);\n-         remote.addClientListener(listener);\n+         int maxEntries = config.maxEntries();\n+         if (maxEntries > 0 && config.bloomFilter()) {\n+            bloomFilterBits = determineBloomFilterBits(maxEntries);\n+            listenerAddress = remote.addNearCacheListener(listener, bloomFilterBits);\n+         } else {\n+            remote.addClientListener(listener);\n+         }\n          // Get the listener ID for faster listener connected lookups\n          listenerId = listenerNotifier.findListenerId(listener);\n       }\n+      this.remote = remote;\n+      return listenerAddress;\n+   }\n+\n+   private static int determineBloomFilterBits(int maxEntries) {\n+      int bloomFilterBitScaler = Integer.parseInt(System.getProperty(\"infinispan.bloom-filter.bit-multiplier\", \"4\"));\n+      return maxEntries * bloomFilterBitScaler;\n+   }\n+\n+   void entryRemovedFromNearCache(K key, MetadataValue<V> value) {\n+      // We want to scale the update frequency of the bloom filter to be based on the number of max entries\n+      // This number along with default values of 3 hash algorithms and 4x bit size we end up with\n+      // between 14.689 and 16.573 percent hits per entry.\n+      int updateThreshold = config.maxEntries() / 16 + 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk0MjI0NQ=="}, "originalCommit": {"oid": "d5c2ff34f64fbf491ccac140457170089c0ff2a0"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3857, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}