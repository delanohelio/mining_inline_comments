{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5OTM0MDEx", "number": 8063, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoxMToyMFrODpk5jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOTo0OToxNFrODrX2lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTIyNzY2OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoxMToyMFrOF41wIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoxMToyMFrOF41wIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0NTI1MA==", "bodyText": "A little too many \"in order to\" :)\nI'd say something like\n// Shutdown Log4jk context manually as we set shutdownHook=\"disable\" \n// Log4j's shutdownHook may run concurrently with our shutdownHook,\n// disabling logging before the server has finished stopping.", "url": "https://github.com/infinispan/infinispan/pull/8063#discussion_r395145250", "createdAt": "2020-03-19T16:11:20Z", "author": {"login": "danberindei"}, "path": "server/runtime/src/main/java/org/infinispan/server/Server.java", "diffHunk": "@@ -408,12 +409,15 @@ private void localShutdown(ExitStatus exitStatus) {\n       }\n       // Shutdown the protocol servers in parallel\n       protocolServers.values().parallelStream().forEach(ProtocolServer::stop);\n-      cacheManagers.values().forEach(cm -> SecurityActions.stopCacheManager(cm));\n+      cacheManagers.values().forEach(SecurityActions::stopCacheManager);\n       this.status = ComponentStatus.TERMINATED;\n       // Don't wait for the scheduler to finish\n       if (scheduler != null) {\n          scheduler.shutdown();\n       }\n+      // Shutdown Log4jk context manually as we set shutdownHook=\"disable\" in order to disable the default Log4j\n+      // shutdownHook being registered in order to allow logging during server shutdown", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef45021b501e5e5aebecd05261f4adef9ef5dda"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTI0MTg5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/statetransfer/StatefulSetRollingUpgradeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoxNDozMVrOF415MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoxNDozMVrOF415MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0NzU2OA==", "bodyText": "The comment seems superfluous now.\nMaybe we should call waitForClusterToForm(CACHE_NAME) before starting the joiner, too?", "url": "https://github.com/infinispan/infinispan/pull/8063#discussion_r395147568", "createdAt": "2020-03-19T16:14:31Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/statetransfer/StatefulSetRollingUpgradeTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.infinispan.statetransfer;\n+\n+import static org.infinispan.commons.test.CommonsTestingUtil.tmpDirectory;\n+import static org.infinispan.test.fwk.TestCacheManagerFactory.createClusteredCacheManager;\n+\n+import java.io.File;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.partitionhandling.PartitionHandling;\n+import org.infinispan.test.MultipleCacheManagersTest;\n+import org.infinispan.test.fwk.CleanupAfterMethod;\n+import org.infinispan.test.fwk.TransportFlags;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Start cluster (A,B) redeploy after upgrade. Rolling upgrades always occur in the order B,A and A does not restart\n+ * until B has completed successfully.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@CleanupAfterMethod\n+@Test(groups = \"functional\", testName = \"statetransfer.StateTransferRollingUpgradeTest\")\n+public class StatefulSetRollingUpgradeTest extends MultipleCacheManagersTest {\n+\n+   private static final String CACHE_NAME = \"testCache\";\n+   private static final int NUM_ROLLING_UPGRADES = 4;\n+\n+   private int numNodes;\n+\n+   @Override\n+   public Object[] factory() {\n+      return new Object[]{\n+            new StatefulSetRollingUpgradeTest().setNumNodes(2),\n+            new StatefulSetRollingUpgradeTest().setNumNodes(3),\n+            new StatefulSetRollingUpgradeTest().setNumNodes(4),\n+            new StatefulSetRollingUpgradeTest().setNumNodes(5)\n+      };\n+   }\n+\n+   private StatefulSetRollingUpgradeTest setNumNodes(int numNodes) {\n+      this.numNodes = numNodes;\n+      return this;\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"nodes\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{numNodes};\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      cacheManagers = IntStream.range(0, numNodes).boxed().map(ignore -> (EmbeddedCacheManager) null).collect(Collectors.toList());\n+      Util.recursiveFileRemove(tmpDirectory(this.getClass().getSimpleName()));\n+\n+      for (int id = 0; id < numNodes; id++)\n+         createStatefulCacheManager(id);\n+\n+      waitForClusterToForm(CACHE_NAME);\n+   }\n+\n+   public void testStateTransferRestart() {\n+      for (int i = 0; i < NUM_ROLLING_UPGRADES; i++) {\n+         for (int j = numNodes - 1; j > -1; j--) {\n+            // Stop the cache manager in the same manner as via the ShutdownHook", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef45021b501e5e5aebecd05261f4adef9ef5dda"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0OTI0NzQwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/statetransfer/StatefulSetRollingUpgradeTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoxNTo0OVrOF4180w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNjoxNTo0OVrOF4180w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0ODQ5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Test(groups = \"functional\", testName = \"statetransfer.StateTransferRollingUpgradeTest\")\n          \n          \n            \n            @Test(groups = \"functional\", testName = \"statetransfer.StatefulSetRollingUpgradeTest\")", "url": "https://github.com/infinispan/infinispan/pull/8063#discussion_r395148499", "createdAt": "2020-03-19T16:15:49Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/statetransfer/StatefulSetRollingUpgradeTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.infinispan.statetransfer;\n+\n+import static org.infinispan.commons.test.CommonsTestingUtil.tmpDirectory;\n+import static org.infinispan.test.fwk.TestCacheManagerFactory.createClusteredCacheManager;\n+\n+import java.io.File;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.partitionhandling.PartitionHandling;\n+import org.infinispan.test.MultipleCacheManagersTest;\n+import org.infinispan.test.fwk.CleanupAfterMethod;\n+import org.infinispan.test.fwk.TransportFlags;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Start cluster (A,B) redeploy after upgrade. Rolling upgrades always occur in the order B,A and A does not restart\n+ * until B has completed successfully.\n+ *\n+ * @author Ryan Emerson\n+ * @since 11.0\n+ */\n+@CleanupAfterMethod\n+@Test(groups = \"functional\", testName = \"statetransfer.StateTransferRollingUpgradeTest\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef45021b501e5e5aebecd05261f4adef9ef5dda"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2ODA2MTY2OnYy", "diffSide": "RIGHT", "path": "server/runtime/src/main/java/org/infinispan/server/Server.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOTo0OToxNFrOF7rr3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOTo0OToxNFrOF7rr3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyNjA0Ng==", "bodyText": "Guess I never knew we required log4j in the server.", "url": "https://github.com/infinispan/infinispan/pull/8063#discussion_r398126046", "createdAt": "2020-03-25T19:49:14Z", "author": {"login": "wburns"}, "path": "server/runtime/src/main/java/org/infinispan/server/Server.java", "diffHunk": "@@ -409,12 +410,16 @@ private void localShutdown(ExitStatus exitStatus) {\n       }\n       // Shutdown the protocol servers in parallel\n       protocolServers.values().parallelStream().forEach(ProtocolServer::stop);\n-      cacheManagers.values().forEach(cm -> SecurityActions.stopCacheManager(cm));\n+      cacheManagers.values().forEach(SecurityActions::stopCacheManager);\n       this.status = ComponentStatus.TERMINATED;\n       // Don't wait for the scheduler to finish\n       if (scheduler != null) {\n          scheduler.shutdown();\n       }\n+      // Shutdown Log4jk context manually as we set shutdownHook=\"disable\"\n+      // Log4j's shutdownHook may run concurrently with our shutdownHook,\n+      // disabling logging before the server has finished stopping.\n+      LogManager.shutdown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47aed3e6a0a8f1e6ce915351422aa0d1e0f5bbe6"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4458, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}